K_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_CONTEXT_INFO contextInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    PVOID   context;

    *Information = 0;

    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_CONTEXT_INFO32  contextInfo32;
            if (InputBufferLength<sizeof (*contextInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*contextInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_CONTEXT_INFO32));
            }
            contextInfo32 = InputBuffer;
            contextInfo.SocketHandle = contextInfo32->SocketHandle;
            contextInfo.SwitchContext = contextInfo32->SwitchContext;
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (contextInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (contextInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT_INFO));
            }

            contextInfo = *((PAFD_SWITCH_CONTEXT_INFO)InputBuffer);
        }

        if (contextInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastCompleteAccept\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        if (RequestorMode!=KernelMode) {
            ProbeForWrite (contextInfo.SwitchContext,
                            sizeof (*contextInfo.SwitchContext),
                            PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT));
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            contextInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            contextInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;

    //
    // Make sure that endpoints are of correct type
    //
    context = AfdLockEndpointContext (sanEndpoint);
    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    if (!sanEndpoint->EndpointCleanedUp &&
         sanEndpoint->State==AfdEndpointStateOpen) {
        //
        // See if accept IRP is still there
        //
        if (!IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
            AFD_SWITCH_CONTEXT  localContext = {0,0,0,0};

            acceptIrp = CONTAINING_RECORD (
                            sanEndpoint->Common.SanEndp.IrpList.Flink,
                            IRP,
                            Tail.Overlay.ListEntry);
            RemoveEntryList (&acceptIrp->Tail.Overlay.ListEntry);
            acceptIrp->Tail.Overlay.ListEntry.Flink = NULL;
            sanEndpoint->Common.SanEndp.SelectEventsActive = AFD_POLL_SEND;
            sanEndpoint->State = AfdEndpointStateConnected;
            sanEndpoint->DisableFastIoSend = TRUE;
            sanEndpoint->DisableFastIoRecv = TRUE;
            sanEndpoint->EnableSendEvent = TRUE;

            ASSERT (sanEndpoint->Common.SanEndp.LocalContext==NULL);
            sanEndpoint->Common.SanEndp.LocalContext = &localContext;
            AFD_END_STATE_CHANGE (sanEndpoint);
            AfdIndicateEventSelectEvent (sanEndpoint, AFD_POLL_SEND, STATUS_SUCCESS);
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            AfdIndicatePollEvent (sanEndpoint, AFD_POLL_SEND, STATUS_SUCCESS);
            status = AfdSanPollMerge (sanEndpoint, &localContext);
            sanEndpoint->Common.SanEndp.LocalContext = NULL;

            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdFastSanCompleteAccept: endp-%p, irp-%p\n",
                            sanEndpoint,
                            acceptIrp));
            }



            if (IoSetCancelRoutine (acceptIrp, NULL)==NULL) {
                KIRQL cancelIrql;
                //
                // Irp is being cancelled, sync up with cancel routine
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }

            //
            // Copy receive data if passed and IRP has buffer for it
            //
            if ((OutputBufferLength>0) && (acceptIrp->MdlAddress!=NULL)) {
                try {
                    ULONG   bytesCopied;
                    NTSTATUS tdiStatus;
                    tdiStatus = TdiCopyBufferToMdl (
                                OutputBuffer,
                                0,
                                OutputBufferLength,
                                acceptIrp->MdlAddress,
                                0,
                                &bytesCopied);
                    ASSERT (NT_SUCCESS (tdiStatus));
                    *Information = bytesCopied;
                    acceptIrp->IoStatus.Information = bytesCopied;
                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                    //
                    // Even if copy failed, we still have to complete
                    // the accept IRP because we have already removed
                    // cancel routine and modified endpoint state.
                    //
                }
            }
            else {
                acceptIrp->IoStatus.Information = 0;
            }

            acceptIrp->IoStatus.Status = status;
            //
            // Complete the accept IRP.
            //
            IoCompleteRequest (acceptIrp, AfdPriorityBoost);

	        //
	        // undo the references done in AfdAcceptCore()
	        //
            ASSERT( InterlockedDecrement( &sanEndpoint->ObReferenceBias ) >= 0 );
            ObDereferenceObject (sanFileObject); 
        }
        else {
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            status = STATUS_LOCAL_DISCONNECT;
        }

    }
    else {
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_HANDLE;
    }
    AfdUnlockEndpointContext (sanEndpoint, context);
	

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastCompletAccept, status: %lx", status);
    ObDereferenceObject (sanFileObject); // undo reference we did earlier in this routine
    return status;
}


//
// Macros to make request/context passing code readable.
//
#define AfdSanRequestInfo       Tail.Overlay
#define AfdSanRequestCtx        DriverContext[0]
#define AfdSanSwitchCtx         DriverContext[1]
#define AfdSanProcessId         DriverContext[2]
#define AfdSanHelperEndp        DriverContext[3]



NTSTATUS
FASTCALL
AfdSanRedirectRequest (
    IN PIRP    Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Redirects file system Read/Write IRP to SAN provider

Arguments:

    Irp - the to be redirected.
    IrpSp - current stack location

Return Value:

    Status of the redirect operation.

--*/
{
    PAFD_ENDPOINT   sanEndpoint;
    NTSTATUS        status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG_PTR       requestInfo;
    ULONG           requestType;
    PVOID           requestCtx;
    BOOLEAN         postRequest = FALSE;;

    Irp->IoStatus.Information = 0;

    //
    // Get the endpoint and validate it.
    //
    sanEndpoint = IrpSp->FileObject->FsContext;
    ASSERT (IS_SAN_ENDPOINT (sanEndpoint));


    //
    // Make sure Irp has not been cancelled meanwhile
    //
    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    IoSetCancelRoutine (Irp, AfdSanCancelRequest);
    if (Irp->Cancel) {
        //
        // Oops, let it go
        //
        Irp->Tail.Overlay.ListEntry.Flink = NULL;
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        if (IoSetCancelRoutine (Irp, NULL)==NULL) {
            KIRQL cancelIrql;
            //
            // Cancel routine must be running, make sure
            // it complete before we complete the IRP
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        status = STATUS_CANCELLED;
        goto complete;
    }

    if (sanEndpoint->State!=AfdEndpointStateConnected) {
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    
    if (sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_PENDING &&
            sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_MORE_PROCESSING_REQUIRED) {
        if (!NT_SUCCESS (sanEndpoint->Common.SanEndp.CtxTransferStatus)) {
            status = sanEndpoint->Common.SanEndp.CtxTransferStatus;
            Irp->Tail.Overlay.ListEntry.Flink = NULL;
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                KIRQL cancelIrql;
                //
                // Cancel routine must be running, make sure
                // it complete before we complete the IRP
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            goto complete;
        }

        //
        // Get the request information based on IRP MJ code
        //
        switch (IrpSp->MajorFunction) {
        case IRP_MJ_READ:
            requestType = AFD_SWITCH_REQUEST_READ;
            requestInfo = IrpSp->Parameters.Read.Length;
            break;
        case IRP_MJ_WRITE:
            requestType = AFD_SWITCH_REQUEST_WRITE;
            requestInfo = IrpSp->Parameters.Write.Length;
            break;
        default:
            ASSERT (!"Unsupported IRP Major Function");
            __assume (0);
        }

        //
        // Generate request context that uniquely identifies
        // it among other requests on the same endpoint.
        //
        requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                            sanEndpoint->Common.SanEndp.RequestId,
                            requestType); 
        sanEndpoint->Common.SanEndp.RequestId += 1;

        //
        // Store the request context in the Irp and insert it into
        // the list
        //
        Irp->AfdSanRequestInfo.AfdSanRequestCtx = requestCtx;
        postRequest = TRUE;
        UPDATE_ENDPOINT (sanEndpoint);
    }
    else {
        Irp->AfdSanRequestInfo.AfdSanRequestCtx = NULL;
        UPDATE_ENDPOINT (sanEndpoint);
    }

    //
    // We are going to pend this IRP, mark it so
    //
    IoMarkIrpPending (Irp);

    InsertTailList (&sanEndpoint->Common.SanEndp.IrpList,
                    &Irp->Tail.Overlay.ListEntry);
    AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);

    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanRedirectRequest: endp-%p, irp-%p, context-%p\n",
                    sanEndpoint, Irp, requestCtx));
    }

    if (postRequest) {
        AfdSanNotifyRequest (sanEndpoint, requestCtx, STATUS_SUCCESS, requestInfo);
    }

    return STATUS_PENDING;

complete:
    //
    // Failure before we queued the IRP, complete and return
    // status to the caller.
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);
    return status;
}

NTSTATUS
AfdSanFastCompleteRequest (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Completes the redirected read/write request processed by SAN provider

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CMPL_ACCEPT)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_REQUEST_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies the request to complete
                        RequestStatus - status with which to complete the request (
                                        STATUS_PENDING has special meaning, request
                                        is not completed - merely data is copied)
                        DataOffset - offset in the request buffer to read/write the data
    InputBufferLength - sizeof (AFD_SWITCH_REQUEST_INFO)

    OutputBuffer - switch buffer to read/write data
    OutputBufferLength - length of the buffer
    Information     - pointer to buffer to return number of bytes copied

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper or SAN endpoint is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
    STATUS_CANCELLED - request to be completed has already been cancelled
    other - failed when attempting to access SAN endpoint, input buffer or output buffers.
--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION  irpSp;
    PIRP    irp;
    ULONG   bytesCopied;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_REQUEST_INFO requestInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;

    *Information = 0;

    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_REQUEST_INFO32  requestInfo32;
            if (InputBufferLength<sizeof (*requestInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*requestInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_REQUEST_INFO32));
            }
            requestInfo32 = InputBuffer;
            requestInfo.SocketHandle = requestInfo32->SocketHandle;
            requestInfo.SwitchContext = requestInfo32->SwitchContext;
            requestInfo.RequestContext = requestInfo32->RequestContext;
            requestInfo.RequestStatus = requestInfo32->RequestStatus;
            requestInfo.DataOffset = requestInfo32->DataOffset;
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (requestInfo)) {
                return STATUS_INVALID_PARAMETER;
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (requestInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_REQUEST_INFO));
            }

            requestInfo = *((PAFD_SWITCH_REQUEST_INFO)InputBuffer);
        }



        if (requestInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastCompleteRequest\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            requestInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            requestInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;



    //
    // Find and dequeue the request in question
    //
    irp = AfdSanDequeueRequest (sanEndpoint, requestInfo.RequestContext);
    if (irp!=NULL)  {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanFastCompleteRequest: endp-%p, irp-%p, context-%p, status-%lx\n",
                        sanEndpoint, irp,
                        requestInfo.RequestContext,
                        requestInfo.RequestStatus));
        }
        //
        // Expect the operation to succeed
        //
        status = STATUS_SUCCESS;

        //
        // Get IRP stack location and perform data copy
        //
        irpSp = IoGetCurrentIrpStackLocation (irp);
        switch (irpSp->MajorFunction) {
        case IRP_MJ_READ:
            //
            // Read request, data is copied from switch buffer
            // to the request MDL
            //
            ASSERT (AFD_SWITCH_REQUEST_TYPE(requestInfo.RequestContext)==AFD_SWITCH_REQUEST_READ);
            if (NT_SUCCESS (requestInfo.RequestStatus) &&
                    (MmGetMdlByteCount (irp->MdlAddress)>requestInfo.DataOffset)) {
                if (irp->MdlAddress!=NULL) {
                    try {
                        if (RequestorMode!=KernelMode) {
                            ProbeForRead (OutputBuffer,
                                            OutputBufferLength,
                                            sizeof (UCHAR));
                        }
                        status = TdiCopyBufferToMdl (
                                    OutputBuffer,
                                    0,
                                    OutputBufferLength,
                                    irp->MdlAddress,
                                    requestInfo.DataOffset,
                                    &bytesCopied
                                    );
                        *Information = bytesCopied;
                        ASSERT (irp->IoStatus.Information==requestInfo.DataOffset);
                        irp->IoStatus.Information += bytesCopied;
                    }
                    except (AFD_EXCEPTION_FILTER (&status)) {
                    }
                }
                else {
                    //
                    // Indicate to the switch that offset
                    // is outside of the buffer
                    //
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            break;
        case IRP_MJ_WRITE:
            //
            // Write request, data is copied to switch buffer
            // from the request MDL
            //
            ASSERT (AFD_SWITCH_REQUEST_TYPE(requestInfo.RequestContext)==AFD_SWITCH_REQUEST_WRITE);
            if (NT_SUCCESS (requestInfo.RequestStatus) &&
                    (irp->MdlAddress!=NULL)) {
                if (MmGetMdlByteCount (irp->MdlAddress)>requestInfo.DataOffset) {
                    try {
                        if (RequestorMode!=KernelMode) {
                            ProbeForWrite (OutputBuffer,
                                            OutputBufferLength,
                                            sizeof (UCHAR));
                        }
                        status = TdiCopyMdlToBuffer (
                                        irp->MdlAddress,
                                        requestInfo.DataOffset,
                                        OutputBuffer,
                                        0,
                                        OutputBufferLength,
                                        &bytesCopied
                                        );
                        *Information = bytesCopied;
                        ASSERT (irp->IoStatus.Information==requestInfo.DataOffset);
                        irp->IoStatus.Information += bytesCopied;
                    }
                    except (AFD_EXCEPTION_FILTER (&status)) {
                    }
                }
                else {
                    //
                    // Indicate to the switch that offset
                    // is outside of the buffer
                    //
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            break;

        default:
            ASSERT (!"Unsupported IRP Major Function");
            __assume (0);
        }

        //
        // If switch did not ask to pend the request, complete it
        //
        if (NT_SUCCESS (status) && requestInfo.RequestStatus!=STATUS_PENDING) {
            //
            // Prepeare the request for completion
            //
            irp->IoStatus.Status = AfdValidateStatus (requestInfo.RequestStatus);
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
        else {
            //
            // Otherwise, put it back into the queue
            //
            AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            IoSetCancelRoutine (irp, AfdSanCancelRequest);
            //
            // Of course, we need to make sure that request
            // was not cancelled while we were processing it.
            //
            if (!irp->Cancel) {
                InsertHeadList (&sanEndpoint->Common.SanEndp.IrpList,
                                    &irp->Tail.Overlay.ListEntry);
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            }
            else {
                //
                // Request has already been cancelled
                //
                ASSERT (irp->Tail.Overlay.ListEntry.Flink == NULL);
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                if (IoSetCancelRoutine (irp, NULL)==NULL) {
                    KIRQL cancelIrql;
                    //
                    // Cancel routine is running, synchronize with
                    // it
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
                //
                // Complete the request and indicate to the
                // switch that it was cancelled
                //
                irp->IoStatus.Status = STATUS_CANCELLED;
                IoCompleteRequest (irp, AfdPriorityBoost);
                status = STATUS_CANCELLED;
            }
        }
    }
    else {
        //
        // Could not find the request, it must have been
        // cancelled already
        //
        status = STATUS_CANCELLED;
    }

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastCompleteRequest, status: %lx", status);
    ObDereferenceObject (sanFileObject);
    return status;
}

NTSTATUS
AfdSanFastCompleteIo (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Simulates async IO completion for the switch.

Arguments:
    FileObject      - SAN endpoint on which to complete the IO
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CMPL_IO)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (IO_STATUS_BLOCK)
                        Status - final operation status
                        Information - associated information (number of bytes 
                                        transferred to/from request buffer(s))
    InputBufferLength - sizeof (IO_STATUS_BLOCK)

    OutputBuffer - unused
    OutputBufferLength - unused
    Information     - pointer to buffer to return number of bytes transferred

Return Value:
    STATUS_INVALID_PARAMETER - input buffer is of invalid size.
    other - status of the IO operation or failure code when attempting to access input buffer.
--*/
{
    NTSTATUS    status;

    PAGED_CODE ();
#ifdef _WIN64
    if (IoIs32bitProcess (NULL)) {
        if (InputBufferLength>=sizeof (IO_STATUS_BLOCK32)) {

            // Carefully write status info
            try {
                if (RequestorMode!=KernelMode) {
                    ProbeForRead (InputBuffer,
                                    sizeof (IO_STATUS_BLOCK32),
                                    PROBE_ALIGNMENT32 (IO_STATUS_BLOCK32));
                }
                *Information = ((PIO_STATUS_BLOCK32)InputBuffer)->Information;
                status = AfdValidateStatus (((PIO_STATUS_BLOCK32)InputBuffer)->Status);
            }
            except (AFD_EXCEPTION_FILTER (&status)) {
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else
#endif //_WIN64
    {

        if (InputBufferLength>=sizeof (IO_STATUS_BLOCK)) {

            // Carefully write status info
            try {
                if (RequestorMode!=KernelMode) {
                    ProbeForRead (InputBuffer,
                                    sizeof (IO_STATUS_BLOCK),
                                    PROBE_ALIGNMENT (IO_STATUS_BLOCK));
                }
                *Information = ((PIO_STATUS_BLOCK)InputBuffer)->Information;
                status = AfdValidateStatus (((PIO_STATUS_BLOCK)InputBuffer)->Status);
            }
            except (AFD_EXCEPTION_FILTER (&status)) {
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
    }

    UPDATE_ENDPOINT2 (FileObject->FsContext, "AfdSanFastCompletIo, status: %lx", status);
    return status;
}

NTSTATUS
AfdSanFastRefreshEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Refreshes endpoint so it can be used again in AcceptEx

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_REFRESH_ENDP)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                        SocketHandle - SAN endpoint on which to referesh
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
    InputBufferLength - unused
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    other - failed when attempting to access SAN socket.
--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    KIRQL              oldIrql;
    NTSTATUS    status;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_CONTEXT_INFO contextInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;

    *Information = 0;

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_CONTEXT_INFO32  contextInfo32;
            if (InputBufferLength<sizeof (*contextInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*contextInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_CONTEXT_INFO32));
            }
            contextInfo32 = InputBuffer;
            contextInfo.SocketHandle = contextInfo32->SocketHandle;
            contextInfo.SwitchContext = contextInfo32->SwitchContext;
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (contextInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (contextInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT_INFO));
            }

            contextInfo = *((PAFD_SWITCH_CONTEXT_INFO)InputBuffer);
        }

        if (contextInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastRefereshEndpoint\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }
        if (RequestorMode!=KernelMode) {
            ProbeForWrite (contextInfo.SwitchContext,
                            sizeof (*contextInfo.SwitchContext),
                            PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT));
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }


    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            contextInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            contextInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;


    //
    // Just make sure that endpoints are of correct type
    // and in correct state
    //
    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);
    AfdAcquireSpinLockAtDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
    if (!sanEndpoint->EndpointCleanedUp &&
          sanEndpoint->State==AfdEndpointStateConnected) {

        //
        // Reset the state so we can't get anymore IRPs
        //
        sanEndpoint->State = AfdEndpointStateTransmitClosing;

        //
        // Cleanup all IRPs on the endpoint.
        //

        if (!IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
            PIRP    irp;
            PDRIVER_CANCEL  cancelRoutine;
            KIRQL cancelIrql;
            AfdReleaseSpinLockFromDpcLevel (&sanEndpoint->SpinLock, &lockHandle);

            //
            // Acquire cancel spinlock and endpoint spinlock in
            // this order and recheck the IRP list
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            ASSERT (cancelIrql==DISPATCH_LEVEL);
            AfdAcquireSpinLockAtDpcLevel (&sanEndpoint->SpinLock, &lockHandle);

            //
            // While list is not empty attempt to cancel the IRPs
            //
            while (!IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
                irp = CONTAINING_RECORD (
                        sanEndpoint->Common.SanEndp.IrpList.Flink,
                        IRP,
                        Tail.Overlay.ListEntry);
                //
                // Reset the cancel routine.
                //
                cancelRoutine = IoSetCancelRoutine (irp, NULL);
                if (cancelRoutine!=NULL) {
                    //
                    // Cancel routine was not NULL, cancel it here.
                    // If someone else attempts to complete this IRP
                    // it will have to wait at least until cancel
                    // spinlock is released, so we can release
                    // the endpoint spinlock
                    //
                    AfdReleaseSpinLockFromDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
                    irp->CancelIrql = DISPATCH_LEVEL;
                    irp->Cancel = TRUE;
                    (*cancelRoutine) (AfdDeviceObject, irp);
                }

                IoAcquireCancelSpinLock (&cancelIrql);
                ASSERT (cancelIrql==DISPATCH_LEVEL);
                AfdAcquireSpinLockAtDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
            }
            IoReleaseCancelSpinLock (DISPATCH_LEVEL);
        }


        if (sanEndpoint->Common.SanEndp.SanHlpr!=NULL) {
            DEREFERENCE_ENDPOINT (sanEndpoint->Common.SanEndp.SanHlpr);
        }

        //
        // Make sure we cleanup all the fields since they will be
        // treated as other part (VC) of the endpoint union.
        //
        RtlZeroMemory (&sanEndpoint->Common.SanEndp,
                        sizeof (sanEndpoint->Common.SanEndp));


        //
        // Reinitialize the endpoint structure.
        //

        sanEndpoint->Type = AfdBlockTypeEndpoint;
		if (sanEndpoint->AddressFileObject!=NULL) {
			//
			// This is TransmitFile after SuperConnect
			//
			sanEndpoint->State = AfdEndpointStateBound;
		}
		else {
			//
			// This is TransmitFile after SuperAccept
			//
			sanEndpoint->State = AfdEndpointStateOpen;
		}
        sanEndpoint->DisconnectMode = 0;
        sanEndpoint->EndpointStateFlags = 0;

        AfdRecordEndpointsReused ();
        status = STATUS_SUCCESS;


    }
    else {
        status = STATUS_INVALID_HANDLE;
    }
    AfdReleaseSpinLockFromDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
    KeLowerIrql (oldIrql);

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastRefreshEndpoint, status: %lx", status);
	ObDereferenceObject( sanFileObject );
    return status;
}


NTSTATUS
AfdSanFastGetPhysicalAddr (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Returns physical address corresponding to provided virtual address.

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR)
    RequestorMode   - mode of the caller
    InputBuffer     - user mode virtual address
    InputBufferLength - access mode
    OutputBuffer    - Buffer to place physical address into.
    OutputBufferLength - sizeof (PHYSICAL_ADDRESS)
    Information     - pointer for buffer to place the size of the return information into
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
    STATUS_INVALID_PARAMETER - invalid access mode.
    STATUS_BUFFER_TOO_SMALL - output buffer is of incorrect size.
    other - failed when attempting to access input virtual address or output buffer.
--*/
{
#ifndef TEST_RDMA_CACHE
	return STATUS_INVALID_PARAMETER;
#else
    NTSTATUS status;
	PVOID			Va;			// virtual address
	ULONG accessMode;
    PAFD_ENDPOINT   sanHlprEndpoint;

    PAGED_CODE ();
    *Information = 0;
	Va = InputBuffer;
	accessMode = InputBufferLength;

    if (accessMode!=MEM_READ_ACCESS &&
		accessMode!=MEM_WRITE_ACCESS) {
        return STATUS_INVALID_PARAMETER;
    }

    if (OutputBufferLength<sizeof(PHYSICAL_ADDRESS)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    sanHlprEndpoint = FileObject->FsContext;

	if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
		return STATUS_INVALID_HANDLE;
	}

    try {
        if (RequestorMode!=KernelMode) {
			//
			// Do some verification on the app buffer. Make sure it is
			// mapped and that it is a user-mode address with appropriate
			// read or write permissions
			//
			if (accessMode == MEM_READ_ACCESS) {
				ProbeAndReadChar ((PCHAR)Va);
			}
			else {
				ProbeForWriteChar ((PCHAR)Va);
			}
        }
		//
		// Validate the output structure if it comes from the user mode
		// application
		//

		if (RequestorMode != KernelMode ) {
			ASSERT(sizeof(PHYSICAL_ADDRESS) == sizeof(QUAD));
			ProbeForWriteQuad ((PQUAD)OutputBuffer);
		}

		*(PPHYSICAL_ADDRESS)OutputBuffer = MmGetPhysicalAddress(Va);

		*Information = sizeof(PHYSICAL_ADDRESS);
		status = STATUS_SUCCESS;

	} except( AFD_EXCEPTION_FILTER(&status) ) {
	}

    UPDATE_ENDPOINT2 (sanHlprEndpoint, "AfdSanGetPhysicalAddress, status: %lx", status);
	return status;
#endif // 0
}


NTSTATUS
AfdSanFastGetServicePid (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Returns PID of SAN service process.

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR)
    RequestorMode   - mode of the caller
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
    Information     - pointer to buffer to return pid of the SAN service process
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
--*/
{
    PAFD_ENDPOINT   sanHlprEndpoint;

    PAGED_CODE ();
    *Information = 0;

    sanHlprEndpoint = FileObject->FsContext;

	if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
		return STATUS_INVALID_HANDLE;
	}

    *Information = (ULONG_PTR)AfdSanServicePid;
    UPDATE_ENDPOINT2 (sanHlprEndpoint,
                        "AfdSanFastGetServicePid, pid: %lx", 
                        HandleToUlong (AfdSanServicePid));
	return STATUS_SUCCESS;
}

NTSTATUS
AfdSanFastSetServiceProcess (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Set the service helper endpoint

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR)
    RequestorMode   - mode of the caller
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
    Information     - 0, ignored
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
    STATUS_ACCESS_DENIED - process is not priviliged enough to become service process.
    STATUS_ADDRESS_ALREADY_EXISTS - service process has already registered.
--*/
{
    NTSTATUS status;
    PAFD_ENDPOINT   sanHlprEndpoint;

    PAGED_CODE ();
    *Information = 0;

    sanHlprEndpoint = FileObject->FsContext;

	if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
		return STATUS_INVALID_HANDLE;
	}

    if (!sanHlprEndpoint->AdminAccessGranted) {
        return STATUS_ACCESS_DENIED;
    }


    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    if (AfdSanServiceHelper==NULL) {
        AfdSanServiceHelper = sanHlprEndpoint;
        AfdSanServicePid = PsGetCurrentProcessId ();
        //
        // HACKHACK.  Force IO subsystem to call us when last handle to the file is closed
        // in any given process.  We are specifically intersted only in this process
        // only.
        //
        FileObject->LockOperation = TRUE;
        status = STATUS_SUCCESS;
    }
    else if (AfdSanServiceHelper==sanHlprEndpoint) {
        ASSERT (FileObject->LockOperation == TRUE);
        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_ADDRESS_ALREADY_EXISTS;
    }

    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
    UPDATE_ENDPOINT2 (sanHlprEndpoint, "AfdSanFastSetServiceProcess, status: %lx", status);
	return status;
}

NTSTATUS
AfdSanFastProviderChange (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Notifies interested processes of SAN provider addition/deletion/change

Arguments:
    FileObject      - SAN helper object for the service process communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_PROVIDER_CHANGE)
    RequestorMode   - mode of the caller
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
    Information     - 0, ignored
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
    STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
--*/
{
    PAFD_ENDPOINT           sanHlprEndpoint;

    *Information = 0;

    sanHlprEndpoint = FileObject->FsContext;

	if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
		return STATUS_INVALID_HANDLE;
	}

    if (sanHlprEndpoint!=AfdSanServiceHelper) {
        return STATUS_ACCESS_DENIED;
    }

    UPDATE_ENDPOINT2 (sanHlprEndpoint,
                        "AfdSanFastProviderChange, seq num: %ld",
                        AfdSanProviderListSeqNum);

    AfdSanProcessAddrListForProviderChange (NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
FASTCALL
AfdSanAddrListChange (
    IN PIRP    Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Processes address SAN list change IRP
    Notifies both of address list changes and SAN
    provider changes.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    PAFD_ENDPOINT   sanHlprEndpoint;
    NTSTATUS        status;
    sanHlprEndpoint = IrpSp->FileObject->FsContext;

	if (IS_SAN_HELPER(sanHlprEndpoint) &&
                 sanHlprEndpoint->OwningProcess==IoGetCurrentProcess ()) {

        if (AfdSanProviderListSeqNum==0 ||
                sanHlprEndpoint->Common.SanHlpr.Plsn==AfdSanProviderListSeqNum) {
            status = AfdAddressListChange (Irp, IrpSp);
            if (AfdSanProviderListSeqNum==0 ||
                    sanHlprEndpoint->Common.SanHlpr.Plsn==AfdSanProviderListSeqNum) {
                UPDATE_ENDPOINT (sanHlprEndpoint);
            }
            else {
                UPDATE_ENDPOINT (sanHlprEndpoint);
                AfdSanProcessAddrListForProviderChange (sanHlprEndpoint);
            }
            return status;
        }
        else {

            sanHlprEndpoint->Common.SanHlpr.Plsn = AfdSanProviderListSeqNum;
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sanHlprEndpoint->Common.SanHlpr.Plsn;
            UPDATE_ENDPOINT (sanHlprEndpoint);
        }
    }
    else {
        status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        UPDATE_ENDPOINT (sanHlprEndpoint);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;
}

NTSTATUS
FASTCALL
AfdSanAcquireContext (
    IN PIRP    Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Requests trasfer of the socket context to the current process.

Arguments:

    Irp - acquire conect IRP
    IrpSp - current stack location

Return Value:
    STATUS_PENDING   - operation was successfully enqued
--*/
{

    NTSTATUS status;
    AFD_SWITCH_ACQUIRE_CTX_INFO ctxInfo;
    PAFD_ENDPOINT   sanHlprEndpoint, sanEndpoint;
    PFILE_OBJECT sanFileObject = NULL;
    PVOID   requestCtx;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN doTransfer;



    try {
#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_SWITCH_ACQUIRE_CTX_INFO ctxInfo32;
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ctxInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (*ctxInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_ACQUIRE_CTX_INFO32));
            }
            ctxInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            ctxInfo.SocketHandle = ctxInfo32->SocketHandle;
            ctxInfo.SwitchContext = ctxInfo32->SwitchContext;
            ctxInfo.SocketCtxBuf = ctxInfo32->SocketCtxBuf;
            ctxInfo.SocketCtxBufSize = ctxInfo32->SocketCtxBufSize;
        }
        else
#endif //_WIN64
        {
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ctxInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (ctxInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_ACQUIRE_CTX_INFO));
            }

            ctxInfo = *((PAFD_SWITCH_ACQUIRE_CTX_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        }

        Irp->MdlAddress = IoAllocateMdl (ctxInfo.SocketCtxBuf,   // VirtualAddress
                            ctxInfo.SocketCtxBufSize,   // Length
                            FALSE,                      // SecondaryBuffer
                            TRUE,                       // ChargeQuota
                            NULL);                      // Irp
        if (Irp->MdlAddress==NULL) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        MmProbeAndLockPages(
            Irp->MdlAddress,            // MemoryDescriptorList
            Irp->RequestorMode,         // AccessMode
            IoWriteAccess               // Operation
            );

        
        if (MmGetSystemAddressForMdlSafe(Irp->MdlAddress, LowPagePriority)==NULL) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0) {

            Irp->MdlAddress->Next = IoAllocateMdl (Irp->UserBuffer,   // VirtualAddress
                                IrpSp->Parameters.DeviceIoControl.OutputBufferLength,// Length
                                FALSE,                      // SecondaryBuffer
                                TRUE,                       // ChargeQuota
                                NULL);                      // Irp
            if (Irp->MdlAddress->Next==NULL) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

            MmProbeAndLockPages(
                Irp->MdlAddress->Next,      // MemoryDescriptorList
                Irp->RequestorMode,         // AccessMode
                IoWriteAccess               // Operation
                );

        
            if (MmGetSystemAddressForMdlSafe(Irp->MdlAddress->Next, LowPagePriority)==NULL) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }
        }

    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        //
        // Cleanup partially processed MDLs since IO subsystem can't do it.
        //
        while (Irp->MdlAddress!=NULL) {
            PMDL    mdl = Irp->MdlAddress;
            Irp->MdlAddress = mdl->Next;
            mdl->Next = NULL;
            if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
                MmUnlockPages (mdl);
            }
            IoFreeMdl (mdl);
        }
        goto complete;
    }

    status = ObReferenceObjectByHandle (
                            ctxInfo.SocketHandle,
                            (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14)&3,
                            *IoFileObjectType,
                            Irp->RequestorMode,
                            (PVOID)&sanFileObject,
                            NULL
                            );
    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (sanFileObject->DeviceObject!=AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    sanHlprEndpoint = IrpSp->FileObject->FsContext;
    sanEndpoint = sanFileObject->FsContext;



    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanFastAcquireCtx: endp-%p.\n",
                    sanEndpoint));
    }

    //
    // Just make sure that endpoints are of correct type
    //
    if (IS_SAN_HELPER(sanHlprEndpoint) &&
            sanHlprEndpoint->OwningProcess==IoGetCurrentProcess () &&
            IS_SAN_ENDPOINT(sanEndpoint)) {

        if (sanEndpoint->Common.SanEndp.SanHlpr==AfdSanServiceHelper  &&
                    sanHlprEndpoint==AfdSanServiceHelper &&
                    sanEndpoint->Common.SanEndp.CtxTransferStatus==STATUS_MORE_PROCESSING_REQUIRED) {
            PVOID   context;

            ASSERT ((ULONG_PTR)sanEndpoint->Common.SanEndp.SavedContext>MM_USER_PROBE_ADDRESS);
            context = AfdLockEndpointContext (sanEndpoint);
            if (ctxInfo.SocketCtxBufSize <= sanEndpoint->Common.SanEndp.SavedContextLength &&
                    ctxInfo.SocketCtxBufSize + 
                        IrpSp->Parameters.DeviceIoControl.OutputBufferLength >
                            sanEndpoint->Common.SanEndp.SavedContextLength) {

                RtlCopyMemory (
                        MmGetSystemAddressForMdl (Irp->MdlAddress),
                        sanEndpoint->Common.SanEndp.SavedContext,
                        ctxInfo.SocketCtxBufSize);

                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0) {
                    Irp->IoStatus.Information = 
                            sanEndpoint->Common.SanEndp.SavedContextLength-
                            ctxInfo.SocketCtxBufSize;
                    RtlCopyMemory (
                            MmGetSystemAddressForMdl (Irp->MdlAddress->Next),
                            (PCHAR)sanEndpoint->Common.SanEndp.SavedContext+
                                    ctxInfo.SocketCtxBufSize,
                            Irp->IoStatus.Information);
                }
                else {
                    Irp->IoStatus.Information = 0;
                }
                AFD_FREE_POOL (sanEndpoint->Common.SanEndp.SavedContext, AFD_SAN_CONTEXT_POOL_TAG);
                // sanEndpoint->Common.SanEndp.SavedContext = NULL;
                sanEndpoint->Common.SanEndp.SwitchContext = ctxInfo.SwitchContext;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            AfdUnlockEndpointContext (sanEndpoint, context);

            if (NT_SUCCESS (status)) {
                UPDATE_ENDPOINT (sanEndpoint);
                Irp->IoStatus.Status = status;
                IoCompleteRequest (Irp, AfdPriorityBoost);
                AfdSanRestartRequestProcessing (sanEndpoint, status);
                ObDereferenceObject (sanFileObject);
                return status;
            }
        }
        else {

            AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            //
            // Make sure Irp has not been cancelled meanwhile
            //
            IoSetCancelRoutine (Irp, AfdSanCancelRequest);
            if (Irp->Cancel) {
                //
                // Oops, let it go
                //
                Irp->Tail.Overlay.ListEntry.Flink = NULL;
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                    KIRQL cancelIrql;
                    //
                    // Cancel routine must be running, make sure
                    // it completes before we complete the IRP
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
                status = STATUS_CANCELLED;
                goto complete;
            }

            if (sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_PENDING &&
                    sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_MORE_PROCESSING_REQUIRED) {
                if (!NT_SUCCESS (sanEndpoint->Common.SanEndp.CtxTransferStatus)) {
                    status = sanEndpoint->Common.SanEndp.CtxTransferStatus;
                    Irp->Tail.Overlay.ListEntry.Flink = NULL;
                    AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                    if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                        KIRQL cancelIrql;
                        //
                        // Cancel routine must be running, make sure
                        // it completes before we complete the IRP
                        //
                        IoAcquireCancelSpinLock (&cancelIrql);
                        IoReleaseCancelSpinLock (cancelIrql);
                    }
                    goto complete;
                }
                //
                // Generate request context that uniquely identifies
                // it among other requests on the same endpoint.
                //
                requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                                    sanEndpoint->Common.SanEndp.RequestId,
                                    AFD_SWITCH_REQUEST_TFCTX); 
                sanEndpoint->Common.SanEndp.RequestId += 1;

                //
                // Store the request context in the Irp and insert it into
                // the list
                //
                Irp->AfdSanRequestInfo.AfdSanRequestCtx = requestCtx;


                sanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_PENDING;
                doTransfer = TRUE;
            }
            else {
                Irp->AfdSanRequestInfo.AfdSanRequestCtx = NULL;
                doTransfer = FALSE;
            }

            Irp->AfdSanRequestInfo.AfdSanSwitchCtx = ctxInfo.SwitchContext;
            Irp->AfdSanRequestInfo.AfdSanProcessId = PsGetCurrentProcessId();
            Irp->AfdSanRequestInfo.AfdSanHelperEndp = sanHlprEndpoint;
            //
            // We are going to pend this IRP, mark it so
            //
            IoMarkIrpPending (Irp);

            InsertTailList (&sanEndpoint->Common.SanEndp.IrpList,
                                    &Irp->Tail.Overlay.ListEntry);
            IoGetCurrentIrpStackLocation(Irp)->FileObject = sanFileObject;
            UPDATE_ENDPOINT (sanEndpoint);
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);

            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdSanRedirectRequest: endp-%p, irp-%p, context-%p\n",
                            sanEndpoint, Irp, requestCtx));
            }

            if (doTransfer) {
                if (!AfdSanNotifyRequest (sanEndpoint,
                        requestCtx, 
                        STATUS_SUCCESS,
                        (ULONG_PTR)PsGetCurrentProcessId())) {
                    AfdSanRestartRequestProcessing (sanEndpoint, STATUS_SUCCESS);
                }
            }

            //
            // The request is in the queue or completed, we no longer need
            // object reference.
            //
            ObDereferenceObject (sanFileObject);
            return STATUS_PENDING;
        }
    }
    else {
        status = STATUS_INVALID_HANDLE;
    }

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanAcquireContext, status: %lx", status);

complete:

    if (sanFileObject!=NULL)
        ObDereferenceObject (sanFileObject);
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;
}

NTSTATUS
AfdSanFastTransferCtx (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Requests AFD to transfer endpoint into another process context

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_TRANSFER_CTX)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_TRANSFER_CTX_INFO)
                        SocketHandle - SAN endpoint to be transferred
                        RequestContext - value that identifies corresponding acquire request.
                        SocketCtxBuf - endpoint context buffer to copy destination process
                                            acquire request
                        SocketCtxSize - size of the buffer to copy
                        RcvBufferArray - array of buffered data to transfer to 
                                            destination process acquire request
                        RcvBufferCount - number of elements in the array.
    InputBufferLength - sizeof (AFD_SWITCH_TRANSFER_CTX_INFO)

    OutputBuffer - unused
    OutputBufferLength - unused
    Information     - pointer to buffer to return number of bytes copied
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch endpoint is of incorrect type
    STATUS_INVALID_PARAMETER - invalid input buffer size.
    other - failed when attempting to access san endpoint or input buffer(s).
--*/
{
    NTSTATUS status;
    AFD_SWITCH_TRANSFER_CTX_INFO ctxInfo;
    PVOID context;
    PAFD_ENDPOINT   sanHlprEndpoint, sanEndpoint;
    PFILE_OBJECT sanFileObject;
    PIRP irp;
    PIO_STACK_LOCATION  irpSp;
#ifdef _WIN64
    WSABUF          localArray[8];
    LPWSABUF        pArray = localArray;
#endif

    PAGED_CODE ();


    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_TRANSFER_CTX_INFO ctxInfo32;
            ULONG   i;
            if (InputBufferLength<sizeof (*ctxInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*ctxInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_TRANSFER_CTX_INFO32));
            }
            ctxInfo32 = InputBuffer;
            ctxInfo.SocketHandle = ctxInfo32->SocketHandle;
            ctxInfo.SwitchContext = ctxInfo32->SwitchContext;
            ctxInfo.RequestContext = ctxInfo32->RequestContext;
            ctxInfo.SocketCtxBuf = ctxInfo32->SocketCtxBuf;
            ctxInfo.SocketCtxBufSize = ctxInfo32->SocketCtxBufSize;
            ctxInfo.RcvBufferArray = ctxInfo32->RcvBufferArray;
            ctxInfo.RcvBufferCount = ctxInfo32->RcvBufferCount;
            ctxInfo.Status = ctxInfo32->Status;
            if (RequestorMode!=KernelMode) {
                if (ctxInfo.SocketCtxBufSize==0 ||
                    ctxInfo.RcvBufferCount>(MAXULONG/sizeof (WSABUF32))) {

                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
                ProbeForRead (ctxInfo.SocketCtxBuf,
                                ctxInfo.SocketCtxBufSize,
                                sizeof (UCHAR));
                ProbeForRead (ctxInfo.RcvBufferArray,
                                sizeof (WSABUF32)*ctxInfo.RcvBufferCount,
                                PROBE_ALIGNMENT32 (WSABUF32));
            }
            if (ctxInfo.RcvBufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                NonPagedPool,
                                sizeof (WSABUF)*ctxInfo.RcvBufferCount,
                                AFD_TEMPORARY_POOL_TAG);
                // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                ASSERT (pArray!=NULL);
            }

            for (i=0; i<ctxInfo.RcvBufferCount; i++) {
                pArray[i].buf = ctxInfo.RcvBufferArray[i].buf;
                pArray[i].len = ctxInfo.RcvBufferArray[i].len;
            }
            ctxInfo.RcvBufferArray = pArray;
        }
        else
#endif //_WIN64
        {
            if (InputBufferLength<sizeof (ctxInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (ctxInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_TRANSFER_CTX_INFO));
            }

            ctxInfo = *((PAFD_SWITCH_TRANSFER_CTX_INFO)InputBuffer);
            if (RequestorMode!=KernelMode) {

                if (ctxInfo.SocketCtxBufSize==0 ||
                    ctxInfo.RcvBufferCount>(MAXULONG/sizeof (WSABUF))) {

                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                ProbeForRead (ctxInfo.SocketCtxBuf,
                                ctxInfo.SocketCtxBufSize,
                                sizeof (UCHAR));

                ProbeForRead (ctxInfo.RcvBufferArray,
                                sizeof (ctxInfo.RcvBufferArray)*ctxInfo.RcvBufferCount,
                                PROBE_ALIGNMENT (WSABUF));

            }
        }

        if (ctxInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastTransferCtx\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        goto complete;
    }

    ctxInfo.Status = AfdValidateStatus (ctxInfo.Status);

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            ctxInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            ctxInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    sanEndpoint = sanFileObject->FsContext;


    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanFastTransferCtx: endp-%p.\n",
                    sanEndpoint));
    }

    if (ctxInfo.RequestContext==NULL ||
            ctxInfo.RequestContext==AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_TFCTX)) {
        PVOID   savedContext = NULL;
        ULONG   ctxLength;

        if (NT_SUCCESS (ctxInfo.Status)) {
            try {
                ctxLength = ctxInfo.SocketCtxBufSize;
                if (ctxInfo.RcvBufferCount>0)
                    ctxLength += AfdCalcBufferArrayByteLength(
                                    ctxInfo.RcvBufferArray,
                                        ctxInfo.RcvBufferCount);
                savedContext = AFD_ALLOCATE_POOL (PagedPool,
                                                    ctxLength,
                                                    AFD_SAN_CONTEXT_POOL_TAG);
                if (savedContext==NULL) {
                    ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                }

                RtlCopyMemory (
                    savedContext,
                    ctxInfo.SocketCtxBuf,
                    ctxInfo.SocketCtxBufSize);

                if (ctxInfo.RcvBufferCount>0) {
                    AfdCopyBufferArrayToBuffer (
                                (PUCHAR)savedContext+ctxInfo.SocketCtxBufSize,
                                ctxLength-ctxInfo.SocketCtxBufSize,
                                ctxInfo.RcvBufferArray,
                                ctxInfo.RcvBufferCount);
                }

            }
            except (AFD_EXCEPTION_FILTER (&status)) {
            }

            if (NT_SUCCESS (status)) {
                status = AfdSanDupEndpointIntoServiceProcess (sanFileObject,
                                                                savedContext,
                                                                ctxLength);
            }

            if (!NT_SUCCESS (status)) {
                if (savedContext!=NULL) {
                    AFD_FREE_POOL (savedContext, AFD_SAN_CONTEXT_POOL_TAG);
                }
                AfdSanRestartRequestProcessing (sanEndpoint, status);
            }
        }
        else {
            AfdSanRestartRequestProcessing (sanEndpoint, ctxInfo.Status);
        }

    }
    else {
        irp = AfdSanDequeueRequest (sanEndpoint, ctxInfo.RequestContext);
        if (irp!=NULL) {
            //
            // Get IRP stack location and perform data copy
            //
            irpSp = IoGetCurrentIrpStackLocation (irp);
            if (NT_SUCCESS (ctxInfo.Status)) {
                AFD_SWITCH_CONTEXT  localContext;
                status = STATUS_SUCCESS;
                try {

                    if ( MmGetMdlByteCount(irp->MdlAddress)!=ctxInfo.SocketCtxBufSize ||
                            (ctxInfo.RcvBufferCount!=0 &&
                                irpSp->Parameters.DeviceIoControl.OutputBufferLength<
                                     AfdCalcBufferArrayByteLength(
                                            ctxInfo.RcvBufferArray,
                                            ctxInfo.RcvBufferCount)) ){
                        ExRaiseStatus (STATUS_INVALID_PARAMETER);
                    }

                    RtlCopyMemory (
                        MmGetSystemAddressForMdl (irp->MdlAddress),
                        ctxInfo.SocketCtxBuf,
                        ctxInfo.SocketCtxBufSize);

                    if (ctxInfo.RcvBufferCount>0) {
                        irp->IoStatus.Information = 
                            AfdCopyBufferArrayToBuffer (
                                    MmGetSystemAddressForMdl (irp->MdlAddress->Next),
                                    irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    ctxInfo.RcvBufferArray,
                                    ctxInfo.RcvBufferCount);
                    }
                    else {
                        irp->IoStatus.Information = 0;
                    }
                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                }
                if (NT_SUCCESS (status)) {
			        //
			        // Now change sanEndpoint's SanHlpr and SwitchContext to point
			        // to the new address space and switch socket
			        //
                    context = AfdLockEndpointContext (sanEndpoint);
                    try {
                        localContext = *sanEndpoint->Common.SanEndp.SwitchContext;
                    }
                    except (AFD_EXCEPTION_FILTER(&status)) {
                    }
                    if (NT_SUCCESS (status)) {
                        KeAttachProcess (PsGetProcessPcb(((PAFD_ENDPOINT)irp->AfdSanRequestInfo.AfdSanHelperEndp)->OwningProcess));
                        try {
				            //
				            // Place info regarding select/eventselect events in SwitchContext
				            // of the new switch socket
				            //
                            *((PAFD_SWITCH_CONTEXT)irp->AfdSanRequestInfo.AfdSanSwitchCtx) = localContext;
                        }
                        except (AFD_EXCEPTION_FILTER(&status)) {
                        }
                        KeDetachProcess ();

                        if (NT_SUCCESS (status)) {
                            sanEndpoint->Common.SanEndp.SanHlpr = irp->AfdSanRequestInfo.AfdSanHelperEndp;
                            REFERENCE_ENDPOINT2 (sanEndpoint->Common.SanEndp.SanHlpr, 
                                                    "Transfer TO %lx",
                                                    HandleToUlong (ctxInfo.SocketHandle) );
                            sanEndpoint->Common.SanEndp.SwitchContext = irp->AfdSanRequestInfo.AfdSanSwitchCtx;
                            //
                            // Reset implicit dup flag if it was set.
                            // We are satisfying explicit request for
                            // duplication.
                            //
                            sanEndpoint->Common.SanEndp.ImplicitDup = FALSE;
                            DEREFERENCE_ENDPOINT2 (sanHlprEndpoint,
                                                    "Transfer FROM %lx",
                                                    HandleToUlong (ctxInfo.SocketHandle));
                        }
                    }
                    AfdUnlockEndpointContext (sanEndpoint, context);

                }

                irp->IoStatus.Status = status;
                ctxInfo.Status = status;
            }
            else {
                irp->IoStatus.Status = ctxInfo.Status;
                status = STATUS_SUCCESS;
            }

            IoCompleteRequest (irp, AfdPriorityBoost);
            AfdSanRestartRequestProcessing (sanEndpoint, ctxInfo.Status);
        }
        else
            status = STATUS_INVALID_PARAMETER;
    }


    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastTransferCtx, status: %lx", status);
    ObDereferenceObject (sanFileObject);

complete:
#ifdef _WIN64
    if (pArray!=localArray) {
        AFD_FREE_POOL (pArray, AFD_TEMPORARY_POOL_TAG);
    }
#endif //_WIN64
    return status;
}

BOOLEAN
AfdSanFastUnlockAll (
    IN PFILE_OBJECT     FileObject,
    IN PEPROCESS        Process,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Called by the system when last handle to the file object in closed
    in some process while other processes still have handles opened
    This is only called on files that were marked as locked at some point of time.

Arguments:
    FileObject      - file object of interest
    Process         - process which has last handle being closed
    IoStatus        - buffer to return operation status and information
    DeviceObject    - device object with which file object is associated
Return Value:

    TRUE     - operation completed OK.    

--*/
{
    PAFD_ENDPOINT   sanEndpoint;
    PVOID           context;

    sanEndpoint = FileObject->FsContext;
    if (IS_SAN_ENDPOINT (sanEndpoint)) {
        context = AfdLockEndpointContext (sanEndpoint);
        if (sanEndpoint->Common.SanEndp.SanHlpr!=NULL) {
            if (sanEndpoint->Common.SanEndp.SanHlpr->OwningProcess==Process) {
                if (sanEndpoint->Common.SanEndp.SanHlpr!=AfdSanServiceHelper) {
                    //
                    // Last handle in the process that owns the socket is being
                    // closed while there are handles to it in other processes.
                    // Need to transfer the context to the service process
                    //
                    if (PsGetProcessExitTime( ).QuadPart==0) {
                        IoSetIoCompletion (
                            sanEndpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.IoCompletionPort,
                            sanEndpoint->Common.SanEndp.SwitchContext,
                            AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_TFCTX),
                            STATUS_SUCCESS,
                            (ULONG_PTR)AfdSanServicePid,
                            FALSE           // ChargeQuota - Don't, handle is going away, no
                                            // way for the run-away app to mount an attack
                            );
                        UPDATE_ENDPOINT (sanEndpoint);
                    }
                    else {
                        //
                        // Process has already exited, not much we can do.
                        //
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                                        "AFD: Process %p has exited before SAN context could be transferred out.\n",
                                        Process));
                        UPDATE_ENDPOINT (sanEndpoint);
                    }
                }
            }
            else {
                if (sanEndpoint->Common.SanEndp.ImplicitDup) {
                    //
                    // Process is exiting and the only handle is in the
                    // other process where the handle was duplicated
                    // impilictly (without application request, e.g.
                    // cross proceess accepting socket duplicated into
                    // listening process to complete the accept or socket
                    // duplication into service process while waiting on 
                    // other process to request ownership).
                    //
                    if (ObReferenceObject (FileObject)==3) { 
                        // Why are we checking for refcount of 3?
                        // 1 - Handle in the implicit process
                        // 1 - IO manager for this call
                        // 1 - we just added
                        UPDATE_ENDPOINT (sanEndpoint);
                        IoSetIoCompletion (
                            sanEndpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.IoCompletionPort,
                            sanEndpoint->Common.SanEndp.SwitchContext,
                            AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_CLSOC),
                            STATUS_SUCCESS,
                            (ULONG_PTR)0,
                            FALSE);         // ChargeQuota - Don't, handle is going away, no
                                            // way for the run-away app to mount an attack
                    }
                    ObDereferenceObject (FileObject);
                }
            }
        }
        AfdUnlockEndpointContext (sanEndpoint, context);
    }
    else if (sanEndpoint==AfdSanServiceHelper) {
        ASSERT (IS_SAN_HELPER (sanEndpoint));
        if (Process==sanEndpoint->OwningProcess) {
            //
            // Last handle to the service helper is being closed in
            // the service process (there must be some duplicates around).
            // We can no longer count on it, clear our global.
            //
            KeEnterCriticalRegion ();
            ExAcquireResourceExclusiveLite( AfdResource, TRUE );
            AfdSanServiceHelper = NULL;
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
        }
    }


    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;
    return TRUE;
}

//
// Internal routines.
//


NTSTATUS
AfdSanAcceptCore (
    PIRP            AcceptIrp,
    PFILE_OBJECT    AcceptFileObject,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    Accept the incoming SAN connection on endpoint provided

Arguments:
    AcceptIrp   - accept IRP to complete
    AcceptFileObject - file object of accepting endpoint
    Connection - pointer to connection object that represents the incoming connection
    LockHandle - IRQL at which listening endpoint spinlock was taken on entry to this routine.
    
Return Value:

    STATUS_PENDING - accept operation started OK
    STATUS_REMOTE_DISCONNECT - connection being accepted was aborted by the remote.
    STATUS_CANCELLED - accepting endpoint was closed or accept IRP cancelled
--*/
{
    PIRP            connectIrp;
    PIO_STACK_LOCATION irpSp;
    PAFD_SWITCH_CONNECT_INFO connectInfo;
    PAFD_ENDPOINT   listenEndpoint, acceptEndpoint;
    HANDLE          acceptHandle;
    ULONG           receiveLength;
    PKPROCESS       listenProcess;

    ASSERT (LockHandle->LockHandle.OldIrql < DISPATCH_LEVEL);

    irpSp = IoGetCurrentIrpStackLocation (AcceptIrp);
    listenEndpoint = irpSp->FileObject->FsContext;
    acceptEndpoint = AcceptFileObject->FsContext;

    ASSERT (Connection->SanConnection);

    //
    // Snag the connect indication IRP
    //
    connectIrp = Connection->ConnectIrp;
    ASSERT (connectIrp!=NULL);
    Connection->ConnectIrp = NULL;


	//
	// Handle EventSelect signalling
	//
    listenEndpoint->EventsActive &= ~AFD_POLL_ACCEPT;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanAcceptCore: Endp %p, Active %lx\n",
                    listenEndpoint,
                    listenEndpoint->EventsActive
                    ));
    }

    if (!IsListEmpty (&listenEndpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
        AfdIndicateEventSelectEvent(
                listenEndpoint,
                AFD_POLL_ACCEPT,
                STATUS_SUCCESS
                );
    }

    //
    // We no longer need the connection object for SAN
    // endpoint, return it
    //
    Connection->Endpoint = NULL;
    Connection->SanConnection = FALSE;
    AfdSanReleaseConnection (listenEndpoint, Connection, FALSE);
    DEREFERENCE_ENDPOINT (listenEndpoint);

    if (IoSetCancelRoutine (connectIrp, NULL)==NULL) {

        AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);
        connectIrp->IoStatus.Status = STATUS_CANCELLED;
        connectIrp->IoStatus.Information = 0;
        IoCompleteRequest (connectIrp, AfdPriorityBoost);
        return STATUS_REMOTE_DISCONNECT;
    }
    AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);


    //
    // Check that accept IRP and SAN connection IRP belong to the same process
    //
    if (IoThreadToProcess (AcceptIrp->Tail.Overlay.Thread)!=
                IoThreadToProcess (connectIrp->Tail.Overlay.Thread)) {
        //
        // Listen process is different than the accepting one.
        // We need to duplicate accepting handle into the listening
        // process so that accept can take place there and the accepting
        // socket will later get dup-ed into the accepting process when
        // that process performs an IO operation on it.
        //
        NTSTATUS        status;
        listenProcess = PsGetProcessPcb(IoThreadToProcess (connectIrp->Tail.Overlay.Thread));
        KeAttachProcess (listenProcess);

        status = ObOpenObjectByPointer (
                                AcceptFileObject,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                MAXIMUM_ALLOWED,
                                *IoFileObjectType,
                                KernelMode,
                                &acceptHandle);
        KeDetachProcess ();
        if (!NT_SUCCESS (status)) {
            connectIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
            connectIrp->IoStatus.Information = 0;
            IoCompleteRequest (connectIrp, AfdPriorityBoost);
            return STATUS_REMOTE_DISCONNECT;
        }
    }
    else {
        acceptHandle = AcceptIrp->Tail.Overlay.DriverContext[3];
        listenProcess = NULL;
    }

    //
    // Now take care of the accept endpoint
    //
    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, LockHandle);
    IoSetCancelRoutine (AcceptIrp, AfdSanCancelAccept);
    if (acceptEndpoint->EndpointCleanedUp || AcceptIrp->Cancel) {
        //
        // Endpoint was closed or IRP cancelled,
        // reset accept irp pointer and return error
        // to both application and SAN provider (to refuse
        // the connection)
        //
        AcceptIrp->Tail.Overlay.ListEntry.Flink = NULL;
        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, LockHandle);
        if (listenProcess!=NULL) {
#if DBG
            NTSTATUS status = STATUS_UNSUCCESSFUL;
#endif
            //
            // Destroy the handle that we created for
            // accepting socket duplication.
            //
            KeAttachProcess (listenProcess);
            try {
#if DBG
                status =
#endif
                    NtClose (acceptHandle);
            }
            finally {
                KeDetachProcess ();
            }
            ASSERT (NT_SUCCESS (status));
        }
        connectIrp->IoStatus.Status = STATUS_CANCELLED;
        connectIrp->IoStatus.Information = 0;
        IoCompleteRequest (connectIrp, AfdPriorityBoost);
        return STATUS_CANCELLED;
    }

    //
    // Pend the accept IRP till provider
    // completes it.  This may take quite a while,
    // which is not expected by the msafd and application,
    // but we have no choice here
    //

    IoMarkIrpPending (AcceptIrp);
    irpSp = IoGetCurrentIrpStackLocation (AcceptIrp);
    receiveLength = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;

    connectInfo = connectIrp->AssociatedIrp.SystemBuffer;
    //
    // Remove super accept IRP from the endpoint
    //
    acceptEndpoint->Irp = NULL; 

    //
    // Convert endpoint to SAN
    //
    AfdSanInitEndpoint (IoGetCurrentIrpStackLocation (connectIrp)->FileObject->FsContext,
                            AcceptFileObject,
                            connectInfo->SwitchContext);
    
    
    if (listenProcess!=NULL) {
        //
        // Note that socket was duplicated implicitly, without application request
        //
        acceptEndpoint->Common.SanEndp.ImplicitDup = TRUE;
    }

    UPDATE_ENDPOINT (acceptEndpoint);

    InsertTailList (&acceptEndpoint->Common.SanEndp.IrpList,
                        &AcceptIrp->Tail.Overlay.ListEntry);

    if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength>0) {
        ULONG remoteAddressLength = 
                    FIELD_OFFSET (
                        TRANSPORT_ADDRESS, 
                        Address[0].Address[
                            connectInfo->RemoteAddress.Address[0].AddressLength]);

#ifndef i386
        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
            USHORT addressLength = 
                    connectInfo->RemoteAddress.Address[0].AddressLength
                    + sizeof (USHORT);
            USHORT UNALIGNED *pAddrLength = (PVOID)
                        ((PUCHAR)MmGetSystemAddressForMdl (AcceptIrp->MdlAddress)
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                         - sizeof (USHORT));
            RtlMoveMemory (
                        (PUCHAR)MmGetSystemAddressForMdl (AcceptIrp->MdlAddress)
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                         &connectInfo->RemoteAddress.Address[0].AddressType,
                         addressLength);
            *pAddrLength = addressLength;
        }
        else
#endif
        {
            RtlMoveMemory (
                        (PUCHAR)MmGetSystemAddressForMdl (AcceptIrp->MdlAddress)
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                         &connectInfo->RemoteAddress,
                         remoteAddressLength);
        }

        if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) {
            PTA_ADDRESS localAddress = (PTA_ADDRESS)
                    &(connectInfo->RemoteAddress.Address[0].Address[
                            connectInfo->RemoteAddress.Address[0].AddressLength]);
            TDI_ADDRESS_INFO  UNALIGNED *addressInfo = (PVOID)
                    ((PUCHAR)MmGetSystemAddressForMdl(AcceptIrp->MdlAddress)
                        + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
#ifndef i386
            if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                USHORT UNALIGNED * pAddrLength = (PVOID)
                    ((PUCHAR)addressInfo 
                    +irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                    -sizeof(USHORT));
                RtlMoveMemory (
                    addressInfo,
                    &localAddress->AddressType,
                    localAddress->AddressLength+sizeof (USHORT));
                *pAddrLength = localAddress->AddressLength+sizeof (USHORT);
            }
            else
#endif
            {
                addressInfo->ActivityCount = 0;
                addressInfo->Address.TAAddressCount = 1;
                RtlMoveMemory (
                    &addressInfo->Address.Address,
                    localAddress,
                    FIELD_OFFSET (TA_ADDRESS, Address[localAddress->AddressLength]));

            }
        }

    }
    AfdReleaseSpinLock (&acceptEndpoint->SpinLock, LockHandle);


    //
    // Setup the accept info for the provider
    //
    //
    // Do this under protection of exception handler since application
    // can change protection attributes of the virtual address range
    // or even deallocate it.  Make sure to attach to the listening
    // process if necessary.
    //
    if (listenProcess!=NULL) {
        KeAttachProcess (listenProcess);
    }
    else {
        ASSERT (IoGetCurrentProcess ()==IoThreadToProcess (connectIrp->Tail.Overlay.Thread));
    }

    try {

#ifdef _WIN64
        if (IoIs32bitProcess (connectIrp)) {
            PAFD_SWITCH_ACCEPT_INFO32 acceptInfo32;
            acceptInfo32 = MmGetMdlVirtualAddress (connectIrp->MdlAddress);
            ASSERT (acceptInfo32!=NULL);
            ASSERT (MmGetMdlByteCount (connectIrp->MdlAddress)>=sizeof (*acceptInfo32));
            acceptInfo32->AcceptHandle = (VOID * POINTER_32)acceptHandle;
            acceptInfo32->ReceiveLength = receiveLength;
            connectIrp->IoStatus.Information = sizeof (*acceptInfo32);
        }
        else
#endif _WIN64
        {
            PAFD_SWITCH_ACCEPT_INFO acceptInfo;
            acceptInfo = MmGetMdlVirtualAddress (connectIrp->MdlAddress);
            ASSERT (acceptInfo!=NULL);
            ASSERT (MmGetMdlByteCount (connectIrp->MdlAddress)>=sizeof (*acceptInfo));
            acceptInfo->AcceptHandle = acceptHandle;
            acceptInfo->ReceiveLength = receiveLength;
            connectIrp->IoStatus.Information = sizeof (*acceptInfo);
        }

        connectIrp->IoStatus.Status = (listenProcess==NULL) ? STATUS_SUCCESS : STATUS_MORE_ENTRIES;
    }
    except (AFD_EXCEPTION_FILTER (&connectIrp->IoStatus.Status)) {
        //
        // If the app is playing with switch's virtual addresses
        // we can't help much - it's accept IRP will probably
        // just hang since the switch is not going to follow
        // the failed connect IRP with accept completion.
        //
    }

    if (listenProcess!=NULL) {
        KeDetachProcess ();
    }

    //
    // Complete the provider IRP.
    //
    IoCompleteRequest (connectIrp, AfdPriorityBoost);

    return STATUS_PENDING;
}


VOID
AfdSanReleaseConnection (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_CONNECTION Connection,
    BOOLEAN CheckBacklog
    )
{
    LONG    failedAdds;
    failedAdds = InterlockedDecrement (
        &ListenEndpoint->Common.VcListening.FailedConnectionAdds);

    if (CheckBacklog || failedAdds>=0) {
        if (!IS_DELAYED_ACCEPTANCE_ENDPOINT (ListenEndpoint)) {
            InterlockedPushEntrySList (
                &ListenEndpoint->Common.VcListening.FreeConnectionListHead,
                &Connection->SListEntry
                );
            return;
        }
        else {
            NTSTATUS    status;
            status = AfdDelayedAcceptListen (ListenEndpoint, Connection);
            if (NT_SUCCESS (status)) {
                return;
            }
        }
    }

    InterlockedIncrement(
        &ListenEndpoint->Common.VcListening.FailedConnectionAdds
        );
    DEREFERENCE_CONNECTION (Connection);
}

VOID
AfdSanCancelConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a connection indication IRP from SAN provider

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PAFD_CONNECTION     connection;
    PAFD_ENDPOINT       endpoint;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    connection = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->SanConnection);

    endpoint = connection->Endpoint;
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));
    ASSERT (endpoint->Listening);

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
    //
    // If IRP still there, cancel it.
    // Otherwise, it is being completed anyway.
    //
    if (connection->ConnectIrp!=NULL) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCancelConnect: endp-%p, irp-%p\n",
                        endpoint, Irp));
        }
        ASSERT (connection->ConnectIrp == Irp);
        connection->ConnectIrp = NULL;
        ASSERT (connection->Endpoint == endpoint);
        connection->Endpoint = NULL;
        connection->SanConnection = FALSE;
        ASSERT (connection->State == AfdConnectionStateUnaccepted ||
                    connection->State==AfdConnectionStateReturned);
        RemoveEntryList (&connection->ListEntry);

        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        ASSERT ((endpoint->Type&AfdBlockTypeVcListening)==AfdBlockTypeVcListening);
        AfdSanReleaseConnection (endpoint, connection, TRUE);
        DEREFERENCE_ENDPOINT (endpoint);

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, AfdPriorityBoost);
    }
    else {
        //
        // Irp is about to be completed.
        //
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }
}

VOID
AfdSanCancelAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels an accept IRP from application waiting on accept
    completion from SAN

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT        acceptFileObject;
    PAFD_ENDPOINT       acceptEndpoint;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    acceptFileObject = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (acceptEndpoint->Type==AfdBlockTypeSanEndpoint);

    ASSERT (KeGetCurrentIrql()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel (&acceptEndpoint->SpinLock, &lockHandle);
    //
    // If IRP still there, cancel it.
    // Otherwise, it is being completed anyway.
    //
    if (Irp->Tail.Overlay.ListEntry.Flink!=NULL) {
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCancelAccept: endp-%p, irp-%p\n",
                        acceptEndpoint, Irp));
        }
        if (!acceptEndpoint->EndpointCleanedUp) {
            if (acceptEndpoint->Common.SanEndp.SanHlpr!=NULL) {
                DEREFERENCE_ENDPOINT (acceptEndpoint->Common.SanEndp.SanHlpr);
            }


            //
            // Make sure we cleanup all the fields since they will be
            // treated as other part (VC) of the endpoint union.
            //
            RtlZeroMemory (&acceptEndpoint->Common.SanEndp,
                            sizeof (acceptEndpoint->Common.SanEndp));


            //
            // Reinitialize the endpoint structure.
            //

            acceptEndpoint->Type = AfdBlockTypeEndpoint;
            acceptEndpoint->State = AfdEndpointStateOpen;
            acceptEndpoint->DisconnectMode = 0;
            acceptEndpoint->EndpointStateFlags = 0;
        }

        AfdReleaseSpinLockFromDpcLevel (&acceptEndpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        AFD_END_STATE_CHANGE (acceptEndpoint);


        //
        // Dereference accept file object and complete the IRP.
        //
        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        ObDereferenceObject (acceptFileObject);
        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, AfdPriorityBoost);
    }
    else {
        //
        // Irp is about to be completed.
        //
        AfdReleaseSpinLockFromDpcLevel (&acceptEndpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }
}


VOID
AfdSanCancelRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a redirected IRP 

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION  irpSp;
    PAFD_ENDPOINT       endpoint;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    endpoint = irpSp->FileObject->FsContext;
    ASSERT (endpoint->Type==AfdBlockTypeSanEndpoint);


    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
    //
    // If IRP still there, cancel it.
    // Otherwise, it is being completed anyway.
    //
    if (Irp->Tail.Overlay.ListEntry.Flink!=NULL) {
        BOOLEAN needRestartProcessing = FALSE;
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

        if (AFD_SWITCH_REQUEST_TYPE (Irp->AfdSanRequestInfo.AfdSanRequestCtx)
                        == AFD_SWITCH_REQUEST_TFCTX) {
            ASSERT (endpoint->Common.SanEndp.CtxTransferStatus==STATUS_PENDING);
            if (!IsListEmpty (&endpoint->Common.SanEndp.IrpList)) {
                needRestartProcessing = TRUE;
            }
            else {
                endpoint->Common.SanEndp.CtxTransferStatus = STATUS_SUCCESS;
            }
        }

        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCancelRequest: endp-%p, irp-%p, context-%p\n",
                        endpoint, Irp, Irp->AfdSanRequestInfo.AfdSanRequestCtx));
        }
        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        if (Irp->AfdSanRequestInfo.AfdSanRequestCtx!=NULL) {
            //
            // Notify the switch that request was cancelled
            //

            AfdSanNotifyRequest (endpoint, Irp->AfdSanRequestInfo.AfdSanRequestCtx,
                                            STATUS_CANCELLED,
                                            0);
            if (needRestartProcessing) {
                AfdSanRestartRequestProcessing (endpoint, STATUS_SUCCESS);
            }
        }

        IoCompleteRequest (Irp, AfdPriorityBoost);
    }
    else {
        //
        // Irp is about to be completed.
        //
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }
}


VOID
AfdSanRestartRequestProcessing (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    )
/*++

Routine Description:

    Restarts request processing after completion of the
    transfer context request.

Arguments:

    Endpoint - endpoint on which to restart request processing


Return Value:

    None

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    LIST_ENTRY  irpList;
    InitializeListHead (&irpList);
    
Again:
    
    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);

    //
    // The enpoint should have just finished transferring context
    // from one process to another.  The CtxTransferStatus
    // should still be pending.
    //
    ASSERT (Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_PENDING ||
                Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_MORE_PROCESSING_REQUIRED ||
                !NT_SUCCESS (Endpoint->Common.SanEndp.CtxTransferStatus) ||
                !NT_SUCCESS (Status));

    //
    // Scan the list for the request that have not been comminicated
    // to the switch.
    //
    listEntry = Endpoint->Common.SanEndp.IrpList.Flink;
    while (listEntry!=&Endpoint->Common.SanEndp.IrpList) {
        ULONG_PTR   requestInfo;
        ULONG       requestType;
        PVOID       requestCtx;
        PIRP        irp = CONTAINING_RECORD (listEntry,
                                        IRP,
                                        Tail.Overlay.ListEntry);
        listEntry = listEntry->Flink;

        if (NT_SUCCESS (Status)) {
            if (irp->AfdSanRequestInfo.AfdSanRequestCtx==NULL) {
                PIO_STACK_LOCATION  irpSp;

                //
                // Create request context based on request type.
                //
                irpSp = IoGetCurrentIrpStackLocation (irp);
                switch (irpSp->MajorFunction) {
                case IRP_MJ_READ:
                    requestType = AFD_SWITCH_REQUEST_READ;
                    requestInfo = irpSp->Parameters.Read.Length;
                    break;
                case IRP_MJ_WRITE:
                    requestType = AFD_SWITCH_REQUEST_WRITE;
                    requestInfo = irpSp->Parameters.Write.Length;
                    break;
                case IRP_MJ_DEVICE_CONTROL:
                    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                    case IOCTL_AFD_SWITCH_ACQUIRE_CTX:
                        requestType = AFD_SWITCH_REQUEST_TFCTX;
                        requestInfo = (ULONG_PTR)irp->AfdSanRequestInfo.AfdSanProcessId;
                        break;
                    default:
                        ASSERT (!"Unsupported IOCTL");
                        __assume (0);
                    }
                    break;

                default:
                    ASSERT (!"Unsupported IRP Major Function");
                    __assume (0);
                }
                requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                                Endpoint->Common.SanEndp.RequestId,
                                requestType);
                irp->AfdSanRequestInfo.AfdSanRequestCtx = requestCtx;
                Endpoint->Common.SanEndp.RequestId += 1;
                UPDATE_ENDPOINT (Endpoint);
                AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

                //
                // If we successfully sent another context transfer request, we should
                // stop processing until this request is completed.  The context transfer
                // flag should remain set.
                //
                if (AfdSanNotifyRequest (Endpoint, requestCtx, STATUS_SUCCESS, requestInfo) &&
                            requestType==AFD_SWITCH_REQUEST_TFCTX) {
                    return;
                }
                else {
                    //
                    // Reacquire the lock and continue processing from the beggining
                    // as the list could have changed while spinlock was released.
                    //

                    goto Again;
                }
            }
        }
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        InsertTailList (&irpList, &irp->Tail.Overlay.ListEntry);
    }
    //
    // Ran till the end of the list and did not find another transfer request.
    // We can reset the flag now.
    //
    Endpoint->Common.SanEndp.CtxTransferStatus = Status;
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    while (!IsListEmpty (&irpList)) {
        PIRP        irp;
        listEntry = RemoveHeadList (&irpList);
        irp = CONTAINING_RECORD (listEntry,
                                        IRP,
                                        Tail.Overlay.ListEntry);
        irp->IoStatus.Status = Status;
        irp->IoStatus.Information = 0;
        IoCompleteRequest (irp, AfdPriorityBoost);
    }
}


PIRP
AfdSanDequeueRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx
    )
/*++

Routine Description:

    Removes the request from the san endpoint list 

Arguments:

    SanEndpoint - endpoint from which to remove the request

    RequestCtx - context that identifies the request

Return Value:

    The request or NULL is not found.

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;

    AfdAcquireSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    listEntry = SanEndpoint->Common.SanEndp.IrpList.Flink;
    //
    // Walk the list till we find the request
    //
    while (listEntry!=&SanEndpoint->Common.SanEndp.IrpList) {
        PIRP    irp = CONTAINING_RECORD (listEntry,
                                        IRP,
                                        Tail.Overlay.ListEntry);
        listEntry = listEntry->Flink;
        if (irp->AfdSanRequestInfo.AfdSanRequestCtx==RequestCtx) {
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            irp->Tail.Overlay.ListEntry.Flink = NULL;
            AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
            //
            // Check if request is being cancelled and synchronize
            // with the cancel routine if so.
            //
            if (IoSetCancelRoutine (irp, NULL)==NULL) {
                KIRQL cancelIrql;
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            return irp;
        }
        else if (irp->AfdSanRequestInfo.AfdSanRequestCtx==NULL) {
            break;
        }
    }
    AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    return NULL;
}



BOOLEAN
AfdSanNotifyRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx,
    NTSTATUS        Status,
    ULONG_PTR       Information
    )
{
    PVOID   context;
    PAFD_ENDPOINT   sanHlprEndpoint;
    NTSTATUS    status;

    PAGED_CODE ();

    context = AfdLockEndpointContext (SanEndpoint);

    //
    // Get the san helper endpoint which we use to communicate
    // with the switch
    //
    sanHlprEndpoint = SanEndpoint->Common.SanEndp.SanHlpr;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));

    //
    // Notify the switch about the request.
    //
    status = IoSetIoCompletion (
                sanHlprEndpoint->Common.SanHlpr.IoCompletionPort,// Port
                SanEndpoint->Common.SanEndp.SwitchContext,  // Key
                RequestCtx,                                 // ApcContext
                Status,                                     // Status
                Information,                                // Information
                TRUE                                        // ChargeQuota
                );
    AfdUnlockEndpointContext (SanEndpoint, context);

    if (NT_SUCCESS (status) || Status==STATUS_CANCELLED) {
        return TRUE;
    }
    else {
        PIRP irp;
        //
        // If notification failed, fail the request.
        // Note that we cannot return the failure status directly
        // as we already marked IRP as pending. Also, the IRP
        // could have been cancelled, so we have to search for
        // it in the list.
        //
        irp = AfdSanDequeueRequest (SanEndpoint, RequestCtx);
        if (irp!=NULL) {
            //
            // Complete the Irp as we found it.
            //
            irp->IoStatus.Status = status;
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
        return FALSE;
    }
}



NTSTATUS
AfdSanPollBegin (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    )
/*++

Routine Description:

    Records poll call so that switch knows to notify AFD to complete
    select/AsyncSelect/EventSelect requests

Arguments:

    Endpoint - endpoint to record

    EventMask - events that needs to be notified

Return Value:

    NTSTATUS - may fail to access user mode address

Note:
    This routine must be called in the context of user mode process
    that owns the endpoint
--*/
{
    LONG   currentEvents, newEvents;
    PVOID context;
    BOOLEAN attached = FALSE;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE ();
    
    context = AfdLockEndpointContext (Endpoint);

    if (IoGetCurrentProcess()!=Endpoint->Common.SanEndp.SanHlpr->OwningProcess) {
        KeAttachProcess (PsGetProcessPcb(Endpoint->Common.SanEndp.SanHlpr->OwningProcess));
        attached = TRUE;
    }

    try {

        //
        // Increment appropriate counts to inform the switch that we are interested
        // in the event.
        //
        if (EventMask & AFD_POLL_RECEIVE) {
            InterlockedIncrement (&Endpoint->Common.SanEndp.SwitchContext->RcvCount);

			//
			// Inform switch that select has happened on this endpoint
			//
			Endpoint->Common.SanEndp.SwitchContext->SelectFlag = TRUE;
        }
        if (EventMask & AFD_POLL_RECEIVE_EXPEDITED) {
            InterlockedIncrement (&Endpoint->Common.SanEndp.SwitchContext->ExpCount);
        }
        if (EventMask & AFD_POLL_SEND) {
            InterlockedIncrement (&Endpoint->Common.SanEndp.SwitchContext->SndCount);
        }

        //
        // Update our event record.
        //
        do {
            currentEvents = *((LONG volatile *)&Endpoint->Common.SanEndp.SelectEventsActive);
            newEvents = *((LONG volatile *)&Endpoint->Common.SanEndp.SwitchContext->EventsActive);
        }
        while (InterlockedCompareExchange (
                    (PLONG)&Endpoint->Common.SanEndp.SelectEventsActive,
                    newEvents,
                    currentEvents)!=currentEvents);

    }
    except (AFD_EXCEPTION_FILTER (&status)) {
    }

    if (attached) {
        KeDetachProcess ();
    }

    AfdUnlockEndpointContext (Endpoint, context);

    return status;
}

VOID
AfdSanPollEnd (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    )
/*++

Routine Description:

    Records poll call completion, so that switch can avoild expensive calls to notify AFD 
    to complete select/AsyncSelect/EventSelect requests

Arguments:

    Endpoint - endpoint to record

    EventMask - events that needs to be dereferenced

Return Value:

    NTSTATUS - may fail to access user mode address

Note:
    This routine must be called in the context of user mode process
    that owns the endpoint
--*/
{
    BOOLEAN attached = FALSE;
    PVOID context;

    PAGED_CODE ();
    
    context = AfdLockEndpointContext (Endpoint);

    if (IoGetCurrentProcess()!=Endpoint->Common.SanEndp.SanHlpr->OwningProcess) {
        KeAttachProcess (PsGetProcessPcb(Endpoint->Common.SanEndp.SanHlpr->OwningProcess));
        attached = TRUE;
    }

    try {

        //
        // Decrement appropriate counts to inform the switch that we are no longer interested
        // in the event.
        //
        if (EventMask & AFD_POLL_RECEIVE) {
            InterlockedDecrement (&Endpoint->Common.SanEndp.SwitchContext->RcvCount);
        }
        if (EventMask & AFD_POLL_RECEIVE_EXPEDITED) {
            InterlockedDecrement (&Endpoint->Common.SanEndp.SwitchContext->ExpCount);
        }
        if (EventMask & AFD_POLL_SEND) {
            InterlockedDecrement (&Endpoint->Common.SanEndp.SwitchContext->SndCount);
        }

    }
    except (AFD_EXCEPTION_FILTER (NULL)) {
        //
        // Not much we can do. The switch will have to call us with all the events.
        //
    }

    if (attached) {
        KeDetachProcess ();
    }

    AfdUnlockEndpointContext (Endpoint, context);

}



VOID
AfdSanPollUpdate (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    )
/*++

Routine Description:

    Updates local kernel information currently outstanding polls on the
    endpoint to be later merged into information maitained by the switch

Arguments:

    Endpoint - endpoint to record

    EventMask - events that needs to be recorded

Return Value:

    None
--*/
{

    ASSERT (KeGetCurrentIrql()==DISPATCH_LEVEL);
    ASSERT (Endpoint->Common.SanEndp.LocalContext!=NULL);

    if (EventMask & AFD_POLL_RECEIVE) {
        InterlockedIncrement (&Endpoint->Common.SanEndp.LocalContext->RcvCount);
    }
    if (EventMask & AFD_POLL_RECEIVE_EXPEDITED) {
        InterlockedIncrement (&Endpoint->Common.SanEndp.LocalContext->ExpCount);
    }
    if (EventMask & AFD_POLL_SEND) {
        InterlockedIncrement (&Endpoint->Common.SanEndp.LocalContext->SndCount);
    }
}


NTSTATUS
AfdSanPollMerge (
    PAFD_ENDPOINT       Endpoint,
    PAFD_SWITCH_CONTEXT Context
    )
/*++

Routine Description:

    Merges information about outstanding poll calls into switch counts.

Arguments:

    Endpoint - endpoint to record

    Context - outstanding select info merge in

Return Value:

    NTSTATUS - may fail to access user mode address

Note:
    This routine must be called in the context of user mode process
    that owns the endpoint
--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PAGED_CODE ();

    ASSERT (IoGetCurrentProcess()==Endpoint->Common.SanEndp.SanHlpr->OwningProcess);
    ASSERT (Endpoint->Common.SanEndp.LocalContext == Context);

    try {

        InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SwitchContext->RcvCount,
                                    Context->RcvCount);
        InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SwitchContext->SndCount,
                                    Context->SndCount);
        InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SwitchContext->ExpCount,
                                    Context->ExpCount);
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
    }
    return status;
}


VOID
AfdSanInitEndpoint (
    PAFD_ENDPOINT   SanHlprEndpoint,
    PFILE_OBJECT    SanFileObject,
    PAFD_SWITCH_CONTEXT SwitchContext
    )
/*++

Routine Description:

    Initializes SAN endpoint structure

Arguments:

    SanHlprEndpoint - switch helper endpoint - communication channel
                        between the switch and AFD for the owner process.

    SanFile - file object for the endpoint to be initialized.

Return Value:

    None

--*/
{
    PAFD_ENDPOINT   sanEndpoint = SanFileObject->FsContext;

    ASSERT (IS_SAN_HELPER(SanHlprEndpoint));

    sanEndpoint->Type = AfdBlockTypeSanEndpoint;
    REFERENCE_ENDPOINT (SanHlprEndpoint);
    sanEndpoint->Common.SanEndp.SanHlpr = SanHlprEndpoint;
    
    sanEndpoint->Common.SanEndp.FileObject = SanFileObject;
    sanEndpoint->Common.SanEndp.SwitchContext = SwitchContext;
    // sanEndpoint->Common.SanEndp.SavedContext = NULL;
    sanEndpoint->Common.SanEndp.LocalContext = NULL;
    InitializeListHead (&sanEndpoint->Common.SanEndp.IrpList);
    sanEndpoint->Common.SanEndp.SelectEventsActive = 0;
    sanEndpoint->Common.SanEndp.RequestId = 1;
    sanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_SUCCESS;
    sanEndpoint->Common.SanEndp.ImplicitDup = FALSE;

    //
    // HACKHACK.  Force IO subsystem to call us when last handle to the file is closed
    // in any given process.
    //
    SanFileObject->LockOperation = TRUE;

}


VOID
AfdSanAbortConnection (
    PAFD_CONNECTION Connection
    )
{
    PIRP    connectIrp;
    PDRIVER_CANCEL  cancelRoutine;
    KIRQL cancelIrql;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint = Connection->Endpoint;

    ASSERT (Connection->SanConnection==TRUE);

    //
    // Acquire cancel spinlock and endpoint spinlock in
    // this order and recheck the accept IRP
    //

    IoAcquireCancelSpinLock (&cancelIrql);
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
    connectIrp = Connection->ConnectIrp;
    if ((connectIrp!=NULL) && 
            ((cancelRoutine=IoSetCancelRoutine (connectIrp, NULL))!=NULL)) {
        //
        // Accept IRP was still there and was not cancelled/completed
        // cancel it
        //
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        connectIrp->CancelIrql = cancelIrql;
        connectIrp->Cancel = TRUE;
        (*cancelRoutine) (AfdDeviceObject, connectIrp);
    }
    else {
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (cancelIrql);
    }
}

VOID
AfdSanCleanupEndpoint (
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Cleans up SAN specific fields in AFD_ENDPOINT
Arguments:
    Endpoint - endpoint to cleanup

Return Value:
    None
--*/
{
    PAFD_ENDPOINT   sanHlprEndpoint;

    ASSERT (IsListEmpty (&Endpoint->Common.SanEndp.IrpList));
    ASSERT (Endpoint->Common.SanEndp.LocalContext == NULL);

    sanHlprEndpoint = Endpoint->Common.SanEndp.SanHlpr;

    if (sanHlprEndpoint!=NULL) {
        ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
        DEREFERENCE_ENDPOINT (sanHlprEndpoint);
        Endpoint->Common.SanEndp.SanHlpr = NULL;
    }
}

VOID
AfdSanCleanupHelper (
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Cleans up SAN helper specific fields in AFD_ENDPOINT
Arguments:
    Endpoint - endpoint to cleanup

Return Value:
    None
--*/
{
    ASSERT  (Endpoint->Common.SanHlpr.IoCompletionPort!=NULL);
    ObDereferenceObject (Endpoint->Common.SanHlpr.IoCompletionPort);
    Endpoint->Common.SanHlpr.IoCompletionPort = NULL;
    ASSERT  (Endpoint->Common.SanHlpr.IoCompletionEvent!=NULL);
    ObDereferenceObject (Endpoint->Common.SanHlpr.IoCompletionEvent);
    Endpoint->Common.SanHlpr.IoCompletionEvent = NULL;
    
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    ASSERT (IS_SAN_HELPER (Endpoint));
    ASSERT (AfdSanServiceHelper!=Endpoint); // Should have been removed in cleanup.

    ASSERT (!IsListEmpty (&Endpoint->Common.SanHlpr.SanListLink));

    RemoveEntryList (&Endpoint->Common.SanHlpr.SanListLink);
    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
}



BOOLEAN
AfdSanReferenceEndpointObject (
    PAFD_ENDPOINT   Endpoint
    )
/*++

Routine Description:

    Reference file object with which san endpoint is associated

Arguments:
    Endpoint    - endpoint of interest
Return Value:
    TRUE    - reference successed
    FALSE   - endpoint has already been cleaned up and its file object
                is about to be closed.
--*/
{
    BOOLEAN res = TRUE;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (!Endpoint->EndpointCleanedUp) {
        ObReferenceObject (Endpoint->Common.SanEndp.FileObject);
    }
    else {
        res = FALSE;
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return res;
}

NTSTATUS
AfdSanReferenceSwitchSocketByHandle (
    IN HANDLE              SocketHandle,
    IN ACCESS_MASK         DesiredAccess,
    IN KPROCESSOR_MODE     RequestorMode,
    IN PAFD_ENDPOINT       SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT SwitchContext OPTIONAL,
    OUT PFILE_OBJECT       *FileObject
    )
/*++

Routine Description:

    Finds and validates AFD endpoint based on the handle/context combination passed in
    by the switch.
Arguments:
    SocketHandle    - Socket handle being referenced
    DesiredAccess   - Required access to the object to perform operation
    RequestorMode   - Mode of the caller
    SanHlprEndpoint - helper endpoint - communication channel between AFD and switch
    SwitchContext   - context associated by the switch with the socket being referenced
    FileObject      - file object corresponding to socket handle
Return Value:
    STATUS_SUCCESS - operation succeeded
    other - failed to find/access endpoint associated with the socket handle/context
--*/
{
    NTSTATUS    status;

    if (IS_SAN_HELPER (SanHlprEndpoint) &&
            SanHlprEndpoint->OwningProcess==IoGetCurrentProcess ()) {
        status = ObReferenceObjectByHandle (
                                SocketHandle,
                                DesiredAccess,
                                *IoFileObjectType,
                                RequestorMode,
                                FileObject,
                                NULL
                                );
        if (NT_SUCCESS (status) && 
                (*FileObject)->DeviceObject==AfdDeviceObject &&
                //
                // Ether socket belongs to the current process and context matches
                // the one supplied by the switch
                //
                ((IS_SAN_ENDPOINT((PAFD_ENDPOINT)(*FileObject)->FsContext) &&
                    ((PAFD_ENDPOINT)((*FileObject)->FsContext))->Common.SanEndp.SanHlpr==SanHlprEndpoint &&
                    ((PAFD_ENDPOINT)((*FileObject)->FsContext))->Common.SanEndp.SwitchContext==SwitchContext)

                                ||
                    //
                    // Or this is just a non-SAN socket being converted to one or just
                    // used for select signalling.
                    //
                    (SwitchContext==NULL &&
                        ((PAFD_ENDPOINT)(*FileObject)->FsContext)->Type==AfdBlockTypeEndpoint)) ){
            NOTHING;
        }
        else {
            if (NT_SUCCESS (status)) {
                //
                // Undo object referencing since it doesn't match the one that switch expects
                //
                ObDereferenceObject (*FileObject);
                status = STATUS_INVALID_HANDLE;
            }

            //
            // If switch supplied the context, try to find the socket
            // in the current process that has the same one.
            //
            if (SwitchContext!=NULL) {
                status = AfdSanFindSwitchSocketByProcessContext (
                            status,
                            SanHlprEndpoint,
                            SwitchContext,
                            FileObject);
            }
        }
    }
    else
        status = STATUS_INVALID_HANDLE;

    return status;
}

NTSTATUS
AfdSanFindSwitchSocketByProcessContext (
    IN NTSTATUS             Status,
    IN PAFD_ENDPOINT        SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT  SwitchContext,
    OUT PFILE_OBJECT        *FileObject
    )
/*++

Routine Description:

    Find SAN endpoint given its process (helper endpoint) and switch context.

Arguments:
    Status          - status returned by the ob object reference operation
                        (to be propagated to the caller in case of failure).
    SanHlprEndpoint - helper endpoint for the process to look in
    SwitchContext   - switch context associated with the endpoint
    FileObject      - returns endpont's file object if found
Return Value:
    STATUS_SUCCESS - san endpoint was found
    other - failed to find endpoint based on the switch context.
--*/
{
    PLIST_ENTRY listEntry;
    PAFD_ENDPOINT   sanEndpoint = NULL;
    HANDLE  socketHandle;
    PVOID   context;

    PAGED_CODE ();

    //
    // Walk the global endpoint list and try to find the entry 
    // that matches the switch context
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite (AfdResource, TRUE);
    listEntry = AfdEndpointListHead.Flink;
    while (listEntry!=&AfdEndpointListHead) {
        sanEndpoint = CONTAINING_RECORD (listEntry, AFD_ENDPOINT, GlobalEndpointListEntry);
        context = AfdLockEndpointContext (sanEndpoint);
        if (IS_SAN_ENDPOINT (sanEndpoint) &&
                sanEndpoint->Common.SanEndp.SanHlpr==SanHlprEndpoint &&
                sanEndpoint->Common.SanEndp.SwitchContext==SwitchContext &&
            AfdSanReferenceEndpointObject (sanEndpoint)) {
            break;
        }
        AfdUnlockEndpointContext (sanEndpoint, context);
        listEntry = listEntry->Flink;
    }
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();

    if (listEntry==&sanEndpoint->GlobalEndpointListEntry) {

        //
        // Try to find the real handle for the switch to use in the future
        //
        *FileObject = sanEndpoint->Common.SanEndp.FileObject;
        if (ObFindHandleForObject (SanHlprEndpoint->OwningProcess,
                                            sanEndpoint->Common.SanEndp.FileObject,
                                            *IoFileObjectType,
                                            NULL,
                                            &socketHandle)) {
            UPDATE_ENDPOINT2 (sanEndpoint, 
                              "AfdSanFindSwitchSocketByProcessContext, handle: %lx",
                              HandleToUlong (socketHandle));
            //
            // Notify switch of handle to be used.
            // Ignore failure, the switch will still be able to communicate via
            // slow lookup path.
            //
            IoSetIoCompletion (
                            SanHlprEndpoint->Common.SanHlpr.IoCompletionPort,
                            SwitchContext,
                            AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_CHCTX),
                            STATUS_SUCCESS,
                            (ULONG_PTR)socketHandle,
                            TRUE                    // Charge quota
                            );

        }
        else {
            UPDATE_ENDPOINT (sanEndpoint);
        }
        AfdUnlockEndpointContext (sanEndpoint, context);
        Status = STATUS_SUCCESS;
    }

    return Status;
}



VOID
AfdSanResetPendingRequests (
    PAFD_ENDPOINT   SanEndpoint
    )
/*++

Routine Description:

    Reset request pending on SAN endpoint while transfering
    context to service process.

Arguments:
    SanEndpoint - endpoint on which to reset requests.

Return Value:
    None
--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY     listEntry;

    AfdAcquireSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    listEntry = SanEndpoint->Common.SanEndp.IrpList.Flink;
    while (listEntry!=&SanEndpoint->Common.SanEndp.IrpList) {
        PIRP    irp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);
        irp->AfdSanRequestInfo.AfdSanRequestCtx = NULL;
        listEntry = listEntry->Flink;
    }
    SanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_MORE_PROCESSING_REQUIRED;
    AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
}

NTSTATUS
AfdSanDupEndpointIntoServiceProcess (
    PFILE_OBJECT    SanFileObject,
    PVOID           SavedContext,
    ULONG           ContextLength
    )
/*++

Routine Description:

    Duplicate endpoint into the context of the service process
    and save switch context on it
Arguments:
    SanFileObject - file object being duplicated
    SaveContext   - pointer to switch context data
    ContextLength - length of the context

Return Value:
    STATUS_SUCCESS - successfully duped
    other - failed.
--*/
{
    NTSTATUS    status;
    HANDLE      handle;
    PAFD_ENDPOINT   sanEndpoint = SanFileObject->FsContext;
    PVOID   context;

    //
    // Take the lock to make sure that service helper won't
    // exit on us and take the helper endpoint with it.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite (AfdResource, TRUE);
    if (AfdSanServiceHelper!=NULL) {

        //
        // Attach to the process and create handle for the file object.
        //

        KeAttachProcess (PsGetProcessPcb(AfdSanServiceHelper->OwningProcess));
        status = ObOpenObjectByPointer (
                                SanFileObject,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                MAXIMUM_ALLOWED,
                                *IoFileObjectType,
                                KernelMode,
                                &handle);
        KeDetachProcess ();
        if (NT_SUCCESS (status)) {
            context = AfdLockEndpointContext (sanEndpoint);

            //
            // Notify the service process that it needs to acquire endpoint context.
            //

            if (sanEndpoint->Common.SanEndp.SanHlpr!=AfdSanServiceHelper) {
                status = IoSetIoCompletion (
                            AfdSanServiceHelper->Common.SanHlpr.IoCompletionPort,
                            NULL,
                            AFD_SWITCH_MAKE_REQUEST_CONTEXT (0,AFD_SWITCH_REQUEST_AQCTX),
                            STATUS_SUCCESS,
                            (ULONG_PTR)handle,
                            TRUE                // Charge quota
                            );
                if (NT_SUCCESS (status)) {

                    //
                    // Change the process affiliation of the endpoint
                    // and suspend the request queue processing until
                    // service process comes back at acquires the context.
                    //
                    UPDATE_ENDPOINT (sanEndpoint);
                    DEREFERENCE_ENDPOINT (sanEndpoint->Common.SanEndp.SanHlpr);
					REFERENCE_ENDPOINT(AfdSanServiceHelper);
                    sanEndpoint->Common.SanEndp.SanHlpr = AfdSanServiceHelper;
                    //sanEndpoint->Common.SanEndp.SwitchContext = NULL; 
                    sanEndpoint->Common.SanEndp.SavedContext = SavedContext;
                    sanEndpoint->Common.SanEndp.SavedContextLength = ContextLength;
                    //
                    // Note that socket was duplicated implicitly without
                    // application request.
                    //
                    sanEndpoint->Common.SanEndp.ImplicitDup = TRUE;
                    AfdSanResetPendingRequests (sanEndpoint);

                    AfdUnlockEndpointContext (sanEndpoint, context);

                    ExReleaseResourceLite (AfdResource);
                    KeLeaveCriticalRegion ();

                    return status;
                }
            }
            else {
                //
                // Endpoint is already in the service process.
                //
                status = STATUS_INVALID_PARAMETER;
            }

            AfdUnlockEndpointContext (sanEndpoint, context);

            KeAttachProcess (PsGetProcessPcb(sanEndpoint->Common.SanEndp.SanHlpr->OwningProcess));
            try {
                NtClose (handle);
            }
            finally {
                KeDetachProcess ();
            }
        }
    }
    else {
        status = STATUS_UNSUCCESSFUL;
    }
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
    return status;
}


VOID
AfdSanProcessAddrListForProviderChange (
    PAFD_ENDPOINT   SpecificEndpoint OPTIONAL
    )
/*++

Routine Description:
    Fires address list notifications for SAN helper endpoints
    to inform switch of Winsock provider list change.
Arguments:
    SpecificEndpoint - optinally indentifies specific
               helper endpoint to fire notifications for
Return Value:
    None.
--*/
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PLIST_ENTRY             listEntry;
    LIST_ENTRY              completedChangeList;
    PAFD_ADDRESS_CHANGE     change;
    PAFD_REQUEST_CONTEXT    requestCtx;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PAFD_ENDPOINT           endpoint;
    LONG                    plsn;

    ASSERT (SpecificEndpoint==NULL || IS_SAN_HELPER (SpecificEndpoint));
    //
    // Create local list to process notifications after spinlock is released
    //

    InitializeListHead (&completedChangeList);

    //
    // Walk the list and move matching notifications to the local list
    //

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);

    if (SpecificEndpoint==NULL) {
        //
        // General notification, increment provider
        // list change sequence number.
        //
        AfdSanProviderListSeqNum += 1;
        if (AfdSanProviderListSeqNum==0) {
            AfdSanProviderListSeqNum += 1;
        }
    }

    plsn = AfdSanProviderListSeqNum;

    listEntry = AfdAddressChangeList.Flink;
    while (listEntry!=&AfdAddressChangeList) {
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        listEntry = listEntry->Flink;
        if (!change->NonBlocking) {
            irp = change->Irp;
            irpSp = IoGetCurrentIrpStackLocation (irp);
            requestCtx = (PAFD_REQUEST_CONTEXT)&irpSp->Parameters.DeviceIoControl;
            endpoint = irpSp->FileObject->FsContext;
            ASSERT (change==(PAFD_ADDRESS_CHANGE)irp->Tail.Overlay.DriverContext);

            if (IS_SAN_HELPER (endpoint) &&
                    (SpecificEndpoint==NULL ||
                        endpoint==SpecificEndpoint)) {
                AFD_LOCK_QUEUE_HANDLE endpointLockHandle;
                ASSERT (change->AddressType==TDI_ADDRESS_TYPE_IP);

                RemoveEntryList (&change->ChangeListLink);
                change->ChangeListLink.Flink = NULL;
                //
                // If request is already canceled, let cancel routine complete it
                //
                if (IoSetCancelRoutine (irp, NULL)==NULL) {
                    continue;
                }

                AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
                if (AfdIsRequestInQueue (requestCtx)) {
                    endpoint->Common.SanHlpr.Plsn = plsn;
                    //
                    // Context is still in the list, just remove it so
                    // no-one can see it anymore and complete
                    //
                    RemoveEntryList (&requestCtx->EndpointListLink);
                    InsertTailList (&completedChangeList,
                                        &change->ChangeListLink);
                }
                else if (!AfdIsRequestCompleted (requestCtx)) {
                    //
                    // During endpoint cleanup, this context was removed from the
                    // list and cleanup routine is about to be called, don't
                    // free this IRP until cleanup routine is called
                    // Also, indicate to the cleanup routine that we are done
                    // with this IRP and it can free it.
                    //
                    AfdMarkRequestCompleted (requestCtx);
                }

                AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            }
        }
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    //
    // Signal interested clients and complete IRPs as necessary
    //

    while (!IsListEmpty (&completedChangeList)) {
        listEntry = RemoveHeadList (&completedChangeList);
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        irp = change->Irp;
        irp->IoStatus.Status = STATUS_SUCCESS;
        //
        // Assigning plsn (can't be 0) distinguishes
        // this from regular address list change
        // notification.
        //
        irp->IoStatus.Information = plsn;
        IF_DEBUG (ADDRESS_LIST) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdProcessAddressChangeList: Completing change IRP: %p  with status: 0 .\n",
                        irp));
        }
        IoCompleteRequest (irp, AfdPriorityBoost);
    }

}


NTSTATUS
AfdSanGetCompletionObjectTypePointer (
    VOID
    )
/*++

Routine Description:
    Obtains completion port object type pointer for
    completion port handle validation purposes.
    Note, that this type is not exported from kernel like
    most other types that afd uses.
Arguments:
    None.
Return Value:
    0 - success, other - could not obtain reference.
--*/
{
    NTSTATUS status;
    UNICODE_STRING  obName;
    OBJECT_ATTRIBUTES obAttr;
    HANDLE obHandle;
    PVOID obType;

    RtlInitUnicodeString (&obName, L"\\ObjectTypes\\IoCompletion");
    
    InitializeObjectAttributes(
        &obAttr,
        &obName,                    // name
        OBJ_KERNEL_HANDLE,          // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ObOpenObjectByName (
        &obAttr,                    // ObjectAttributes
        NULL,                       // ObjectType
        KernelMode,                 // AccessMode
        NULL,                       // PassedAccessState
        0,                          // DesiredAccess
        NULL,                       // DesiredAccess
        &obHandle                   // Handle
        );
    if (NT_SUCCESS (status)) {
        status = ObReferenceObjectByHandle (
                    obHandle,
                    0,              // DesiredAccess
                    NULL,           // ObjectType
                    KernelMode,     // AccessMode
                    &obType,        // Object
                    NULL            // HandleInformation
                    );
        ZwClose (obHandle);
        if (NT_SUCCESS (status)) {
            //
            // Make sure we only keep one reference to the object type
            //
            if (InterlockedCompareExchangePointer (
                        (PVOID *)&IoCompletionObjectType,
                        obType,
                        NULL)!=NULL) {
                //
                // The reference we have already must be the same
                // is we just obtained - there should be only one
                // completion object type in the system!
                //
                ASSERT (obType==(PVOID)IoCompletionObjectType);
                //
                // Get rid of the extra reference
                //
                ObDereferenceObject (obType);
            }
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\send.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains the code for passing on send IRPs to
    TDI providers.

Author:

    David Treadwell (davidtr)    13-Mar-1992

Revision History:

--*/

#include "afdp.h"

VOID
AfdCancelSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdRestartSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSendConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSendTdiConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

typedef struct _AFD_SEND_CONN_DATAGRAM_CONTEXT {
    PAFD_ENDPOINT Endpoint;
    TDI_CONNECTION_INFORMATION ConnectionInformation;
} AFD_SEND_CONN_DATAGRAM_CONTEXT, *PAFD_SEND_CONN_DATAGRAM_CONTEXT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdSend )
#pragma alloc_text( PAGEAFD, AfdSendDatagram )
#pragma alloc_text( PAGEAFD, AfdCancelSend )
#pragma alloc_text( PAGEAFD, AfdRestartSend )
#pragma alloc_text( PAGEAFD, AfdRestartBufferSend )
#pragma alloc_text( PAGEAFD, AfdProcessBufferSend )
#pragma alloc_text( PAGEAFD, AfdRestartSendConnDatagram )
#pragma alloc_text( PAGEAFD, AfdRestartSendTdiConnDatagram )
#pragma alloc_text( PAGEAFD, AfdRestartSendDatagram )
#pragma alloc_text( PAGEAFD, AfdSendPossibleEventHandler )
#endif

//
// Macros to make the send restart code more maintainable.
//

#define AfdRestartSendInfo  DeviceIoControl
#define AfdMdlChain         Type3InputBuffer
#define AfdSendFlags        InputBufferLength
#define AfdOriginalLength   OutputBufferLength
#define AfdCurrentLength    IoControlCode

#define AFD_SEND_MDL_HAS_NOT_BEEN_MAPPED 0x80000000


NTSTATUS
FASTCALL
AfdSend (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    ULONG sendLength;
    ULONG sendOffset = 0;
    ULONG currentOffset;
    PMDL  mdl;
    PAFD_CONNECTION connection;
    PAFD_BUFFER afdBuffer = NULL;
    ULONG sendFlags;
    ULONG afdFlags;
    ULONG bufferCount;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PEPROCESS   process;

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    if ( endpoint->State != AfdEndpointStateConnected) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    //
    // If send has been shut down on this endpoint, fail.  We need to be
    // careful about what error code we return here: if the connection
    // has been aborted, be sure to return the apprpriate error code.
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 ) {

        if ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ) {
            status = STATUS_LOCAL_DISCONNECT;
        } else {
            status = STATUS_PIPE_DISCONNECTED;
        }

        goto complete;
    }

    //
    // Set up the IRP on the assumption that it will complete successfully.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // If this is an IOCTL_AFD_SEND, then grab the parameters from the
    // supplied AFD_SEND_INFO structure, build an MDL chain describing
    // the WSABUF array, and attach the MDL chain to the IRP.
    //
    // If this is an IRP_MJ_WRITE IRP, just grab the length from the IRP
    // and set the flags to zero.
    //

    if ( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL ) {

#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_SEND_INFO32 sendInfo32;
            LPWSABUF32 bufferArray32;

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*sendInfo32) ) {

                try {


                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    sendInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForRead(
                            sendInfo32,
                            sizeof(*sendInfo32),
                            PROBE_ALIGNMENT32(AFD_SEND_INFO32)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    sendFlags = sendInfo32->TdiFlags;
                    afdFlags = sendInfo32->AfdFlags;
                    bufferArray32 = sendInfo32->BufferArray;
                    bufferCount = sendInfo32->BufferCount;


                    //
                    // Create the MDL chain describing the WSABUF array.
                    // This will also validate the buffer array and individual
                    // buffers
                    //

                    status = AfdAllocateMdlChain32(
                                 Irp,       // Requestor mode passed along
                                 bufferArray32,
                                 bufferCount,
                                 IoReadAccess,
                                 &sendLength
                                 );


                } except( AFD_EXCEPTION_FILTER(&status) ) {

                    //
                    //  Exception accessing input structure.
                    //


                }
            } else {

                //
                // Invalid input buffer length.
                //

                status = STATUS_INVALID_PARAMETER;

            }
        }
        else 
#endif _WIN64
        {
            PAFD_SEND_INFO sendInfo;
            LPWSABUF bufferArray;

            //
            // Sanity check.
            //

            ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_SEND );

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*sendInfo) ) {

                try {


                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    sendInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForRead(
                            sendInfo,
                            sizeof(*sendInfo),
                            PROBE_ALIGNMENT (AFD_SEND_INFO)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    sendFlags = sendInfo->TdiFlags;
                    afdFlags = sendInfo->AfdFlags;
                    bufferArray = sendInfo->BufferArray;
                    bufferCount = sendInfo->BufferCount;


                    //
                    // Create the MDL chain describing the WSABUF array.
                    // This will also validate the buffer array and individual
                    // buffers
                    //

                    status = AfdAllocateMdlChain(
                                 Irp,       // Requestor mode passed along
                                 bufferArray,
                                 bufferCount,
                                 IoReadAccess,
                                 &sendLength
                                 );


                } except( AFD_EXCEPTION_FILTER(&status) ) {

                    //
                    //  Exception accessing input structure.
                    //


                }
            } else {

                //
                // Invalid input buffer length.
                //

                status = STATUS_INVALID_PARAMETER;

            }
        }
        if( !NT_SUCCESS(status) ) {

            goto complete;

        }

        if (IS_SAN_ENDPOINT(endpoint)) {
            IrpSp->MajorFunction = IRP_MJ_WRITE;
            IrpSp->Parameters.Read.Length = sendLength;
            return AfdSanRedirectRequest (Irp, IrpSp);
        }

    } else {

        ASSERT( IrpSp->MajorFunction == IRP_MJ_WRITE );

        sendFlags = 0;
        afdFlags = AFD_OVERLAPPED;
        sendLength = IrpSp->Parameters.Write.Length;

    }

    //
    // AfdSend() will either complete fully or will fail.
    //

    Irp->IoStatus.Information = sendLength;

    //
    // Setup for possible restart if the transport completes
    // the send partially.
    //

    IrpSp->Parameters.AfdRestartSendInfo.AfdMdlChain = Irp->MdlAddress;
    IrpSp->Parameters.AfdRestartSendInfo.AfdSendFlags = sendFlags;
    IrpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength = sendLength;
    IrpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength = sendLength;

    //
    // Buffer sends if the TDI provider does not buffer.
    //

    if ( IS_TDI_BUFFERRING(endpoint) &&
            endpoint->NonBlocking) {
        //
        // If this is a nonblocking endpoint, set the TDI nonblocking
        // send flag so that the request will fail if the send cannot be
        // performed immediately.
        //

        sendFlags |= TDI_SEND_NON_BLOCKING;

    }

    //
    // If this is a datagram endpoint, format up a send datagram request
    // and pass it on to the TDI provider.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        //
        // It is illegal to send expedited data on a datagram socket.
        //

        if ( (sendFlags & TDI_SEND_EXPEDITED) != 0 ) {
            status = STATUS_NOT_SUPPORTED;
            goto complete;
        }

        if (!IS_TDI_DGRAM_CONNECTION(endpoint)) {
            PAFD_SEND_CONN_DATAGRAM_CONTEXT context;


            //
            // Allocate space to hold the connection information structure
            // we'll use on input.
            //

            try {
                context = AFD_ALLOCATE_POOL_WITH_QUOTA(
                          NonPagedPool,
                          sizeof(*context),
                          AFD_TDI_POOL_TAG
                          );

            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode ();
                context = NULL;
                goto complete;
            }

            REFERENCE_ENDPOINT2 (endpoint,"AfdSend, length", sendLength);
            context->Endpoint = endpoint;
            context->ConnectionInformation.UserDataLength = 0;
            context->ConnectionInformation.UserData = NULL;
            context->ConnectionInformation.OptionsLength = 0;
            context->ConnectionInformation.Options = NULL;
            context->ConnectionInformation.RemoteAddressLength =
                endpoint->Common.Datagram.RemoteAddressLength;
            context->ConnectionInformation.RemoteAddress =
                endpoint->Common.Datagram.RemoteAddress;

            //
            // Build a send datagram request.
            //

            TdiBuildSendDatagram(
                Irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartSendConnDatagram,
                context,
                Irp->MdlAddress,
                sendLength,
                &context->ConnectionInformation
                );
        }
        else {
            REFERENCE_ENDPOINT2 (endpoint,"AfdSend(conn), length", sendLength);
            TdiBuildSend(
                Irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartSendTdiConnDatagram,
                endpoint,
                Irp->MdlAddress,
                0,
                sendLength
                );
        }

        //
        // Call the transport to actually perform the send operation.
        //

        return AfdIoCallDriver(
                   endpoint,
                   endpoint->AddressDeviceObject,
                   Irp
                   );
    }

    process = endpoint->OwningProcess;

retry_buffer:
    if (!IS_TDI_BUFFERRING(endpoint) && 
            (!endpoint->DisableFastIoSend ||
                (endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED )) ) ) {
        //
        // Get AFD buffer structure that contains an IRP and a
        // buffer to hold the data.
        //

        try {
            afdBuffer = AfdGetBufferRaiseOnFailure (
                                        sendLength,
                                        0,
                                        process );
            if ( Irp->MdlAddress != NULL ) {
                status = AfdCopyMdlChainToBufferAvoidMapping(
                    Irp->MdlAddress,
                    0,
                    sendLength,
                    afdBuffer->Buffer,
                    afdBuffer->BufferLength
                    );

                if (!NT_SUCCESS (status)) {
                    goto complete;
                }
            }
            else {
                ASSERT (sendLength==0);
                ASSERT (IrpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength == 0);
            }

        }
        except (AFD_EXCEPTION_FILTER (&status)) {

            //
            // If we failed to get the buffer, and application request
            // is larger than one page,  and it is blocking or overlapped,
            // and this is not a message-oriented socket,
            // allocate space for last page only (if we can) and send
            // the first portion from the app buffer.
            //

            if ( (sendLength>AfdBufferLengthForOnePage) &&
                    !IS_MESSAGE_ENDPOINT (endpoint) &&
                    (!endpoint->NonBlocking || (afdFlags & AFD_OVERLAPPED ) ) ) {
                try {
                    afdBuffer = AfdGetBufferRaiseOnFailure (
                                            AfdBufferLengthForOnePage,
                                            0,
                                            process);

                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                    goto complete;
                }

                sendOffset = sendLength-(ULONG)AfdBufferLengthForOnePage;
                sendLength = (ULONG)AfdBufferLengthForOnePage;
                currentOffset = sendOffset;
                mdl = Irp->MdlAddress;
                //
                // Adjust MDL length to be in sync with IRP
                // send length parameter to not to confuse
                // the transport
                //

                while (currentOffset>MmGetMdlByteCount (mdl)) {
                    currentOffset -= MmGetMdlByteCount (mdl);
                    mdl = mdl->Next;
                }

                status = AfdCopyMdlChainToBufferAvoidMapping(
                    mdl,
                    currentOffset,
                    sendLength,
                    afdBuffer->Buffer,
                    afdBuffer->BufferLength
                    );

                if (!NT_SUCCESS (status)) {
                    goto complete;
                }

            } // not qualified for partial allocation
            else {
                goto complete;
            }
        } // exception allocating big buffer.
    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AFD_CONNECTION_FROM_ENDPOINT(endpoint);

    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // Check whether the remote end has aborted the connection, in which
    // case we should complete the receive.
    //

    if ( connection->AbortIndicated ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CONNECTION_RESET;
        goto complete;
    }

    //
    // Buffer sends if the TDI provider does not buffer
    // and application did not specifically requested us not
    // to do so
    //

    if ( !IS_TDI_BUFFERRING(endpoint)) {
        if ( afdBuffer!=NULL ) {
            BOOLEAN completeSend = FALSE;
            PFILE_OBJECT fileObject = NULL;

            if (connection->OwningProcess!=process) {
                //
                // Weird case when connection and endpoint belong to
                // different processes.
                //

                process = connection->OwningProcess;
                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                AfdReturnBuffer (&afdBuffer->Header, process);
                goto retry_buffer;
            }

            ASSERT( !connection->TdiBufferring );

            //
            // First make sure that we don't have too many bytes of send
            // data already outstanding and that someone else isn't already
            // in the process of completing pended send IRPs.  We can't
            // issue the send here if someone else is completing pended
            // sends because we have to preserve ordering of the sends.
            //
            // Note that we'll give the send data to the TDI provider even
            // if we have exceeded our send buffer limits, but that we don't
            // complete the user's IRP until some send buffer space has
            // freed up.  This effects flow control by blocking the user's
            // thread while ensuring that the TDI provider always has lots
            // of data available to be sent.
            //


            if ( connection->VcBufferredSendBytes >= connection->MaxBufferredSendBytes &&
                    endpoint->NonBlocking && 
                    !( afdFlags & AFD_OVERLAPPED ) &&
                    connection->VcBufferredSendBytes>0) {
                //
                // There is already as much send data bufferred on the
                // connection as is allowed.  If this is a nonblocking
                // endpoint and this is not an overlapped operation and at least
                // on byte is buferred, fail the request.
                // Note, that we have already allocated the buffer and copied data
                // and now we are dropping it.  We should only be here in some
                // really weird case when fast IO has been bypassed.
                //


                //
                // Enable the send event.
                //

                endpoint->EventsActive &= ~AFD_POLL_SEND;
                endpoint->EnableSendEvent = TRUE;

                IF_DEBUG(EVENT_SELECT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSend: Endp %p, Active %lx\n",
                        endpoint,
                        endpoint->EventsActive
                        ));
                }

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                status = STATUS_DEVICE_NOT_READY;
                goto complete;
            }

            if (sendOffset==0) {
                if ( connection->VcBufferredSendBytes >= connection->MaxBufferredSendBytes ) {

                    //
                    // Special hack to prevent completion of this IRP
                    // while we have not finished sending all the data
                    // that came with it.  If we do not do this, the
                    // app can receive completion port notificaiton in
                    // another thread and come back with another send
                    // which can get in the middle of this one.
                    //
                    Irp->Tail.Overlay.DriverContext[0] = NULL;

                    //
                    // Set up the cancellation routine in the IRP.  If the IRP
                    // has already been cancelled, just complete the IRP
                    //

                    IoSetCancelRoutine( Irp, AfdCancelSend );

                    if ( Irp->Cancel ) {

                        Irp->Tail.Overlay.ListEntry.Flink = NULL;

                        if ( IoSetCancelRoutine( Irp, NULL ) == NULL ) {
                            IoMarkIrpPending (Irp);
                            Irp->Tail.Overlay.DriverContext[0] = (PVOID)-1;
                            //
                            // The cancel routine is running and will complete the IRP
                            //
                            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                            AfdReturnBuffer (&afdBuffer->Header, process);
                            return STATUS_PENDING;
                        }

                        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                        status = STATUS_CANCELLED;
                        goto complete;
                    }

                    //
                    // We're going to have to pend the request here in AFD.
                    // Place the IRP on the connection's list of pended send
                    // IRPs and mark the IRP as pended.
                    //

                    InsertTailList(
                        &connection->VcSendIrpListHead,
                        &Irp->Tail.Overlay.ListEntry
                        );

                    IoMarkIrpPending( Irp );

                }
                else {
                    //
                    // We are going to complete the IRP inline
                    //
                    completeSend = TRUE;
                }

            }
            else {
                connection->VcBufferredSendBytes += sendOffset;
                connection->VcBufferredSendCount += 1;

                //
                // Special hack to prevent completion of this IRP
                // while we have not finished sending all the data
                // that came with it.  If we do not do this, the
                // app can receive completion port notificaiton in
                // another thread and come back with another send
                // which can get in the middle of this one.
                //
                fileObject = IrpSp->FileObject;
                IrpSp->FileObject = NULL;


                REFERENCE_CONNECTION2( connection, "AfdSend (split,non-buffered part), offset:%lx", sendOffset );
            }

            //
            // Update count of send bytes pending on the connection.
            //

            connection->VcBufferredSendBytes += sendLength;
            connection->VcBufferredSendCount += 1;

            //
            // Reference the conneciton so it does not go away
            // until we finish with send
            //
            REFERENCE_CONNECTION2( connection, "AfdSend (buffered), length:%lx", sendLength );

            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Remember the connection in the AFD buffer structure.  We need
            // this in order to access the connection in the restart routine.
            //

            afdBuffer->Context = connection;


            //
            // We have to rebuild the MDL in the AFD buffer structure to
            // represent exactly the number of bytes we're going to be
            // sending.
            //

            afdBuffer->Mdl->ByteCount = sendLength;


            //
            // Copy the user's data into the AFD buffer.  If the MDL in the
            // IRP is NULL, then don't bother doing the copy--this is a
            // send of length 0.
            //

            if (sendOffset==0) {
                // Use the IRP in the AFD buffer structure to give to the TDI
                // provider.  Build the TDI send request.
                //

                TdiBuildSend(
                    afdBuffer->Irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartBufferSend,
                    afdBuffer,
                    afdBuffer->Mdl,
                    sendFlags,
                    sendLength
                    );

                //
                // Call the transport to actually perform the send.
                //

                status = IoCallDriver(connection->DeviceObject, afdBuffer->Irp );

                //
                // If we did not pend the Irp, complete it
                //
                if (completeSend) {
                    if (NT_SUCCESS (status)) {
                        ASSERT (Irp->IoStatus.Status == STATUS_SUCCESS);
                        ASSERT (Irp->IoStatus.Information == sendLength);
                        ASSERT ((status==STATUS_SUCCESS) || (status==STATUS_PENDING));
                        status = STATUS_SUCCESS;    // We did not mark irp as
                                                    // pending, so returning
                                                    // STATUS_PENDING (most likely
                                                    // to be status returned by the
                                                    // transport) will really confuse
                                                    // io subsystem.
                    }
                    else {
                        Irp->IoStatus.Status = status;
                        Irp->IoStatus.Information = 0;
                    }
                    UPDATE_CONN2 (connection, "AfdSend, bytes sent/status reported 0x%lX", 
                                                (NT_SUCCESS(Irp->IoStatus.Status) 
                                                            ? (ULONG)Irp->IoStatus.Information
                                                            : (ULONG)Irp->IoStatus.Status));
                    IoCompleteRequest (Irp, AfdPriorityBoost);
                }
                else {
                    //
                    // We don't need the MDL anymore, destroy it
                    // while we still own the IRP.
                    //

                    AfdDestroyMdlChain (Irp);

                    //
                    // Complete the IRP if it was completed by the transport
                    // and kept around to let us finish posting all the data
                    // originally submitted by the app before completing it
                    //
                    ASSERT (Irp->Tail.Overlay.DriverContext[0]==NULL
                        || Irp->Tail.Overlay.DriverContext[0]==(PVOID)-1);
                    if (InterlockedExchangePointer (
                                &Irp->Tail.Overlay.DriverContext[0],
                                (PVOID)Irp)!=NULL) {
                        UPDATE_CONN2 (connection, "AfdSend, bytes sent reported 0x%lX", 
                                                    (ULONG)Irp->IoStatus.Information);
                        IoCompleteRequest (Irp, AfdPriorityBoost);
                    }

                    status = STATUS_PENDING;
                }
            }
            else {

                //
                // Save the original values to restore in
                // completion routine.
                //

                IrpSp->Parameters.AfdRestartSendInfo.AfdMdlChain = mdl->Next;
                IrpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength =
                            MmGetMdlByteCount (mdl);

                //
                // Note if we need to unmap MDL before completing
                // the IRP if it is mapped by the transport.
                //
                if ((mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)==0) {
                    IrpSp->Parameters.AfdRestartSendInfo.AfdSendFlags |=
                                        AFD_SEND_MDL_HAS_NOT_BEEN_MAPPED;
                }
                
                //
                // Reset the last MDL to not confuse the transport
                // with different length values in MDL and send parameters
                //
                mdl->ByteCount = currentOffset;
                mdl->Next = NULL;

                //
                // Build and pass first portion of the data with original (app)
                // IRP
                //
                TdiBuildSend(
                    Irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartSend,
                    connection,
                    Irp->MdlAddress,
                    sendFlags,
                    sendOffset
                    );

                status = AfdIoCallDriver (endpoint, 
                                            connection->DeviceObject,
                                            Irp);
                // 
                // Build an pass buffered last page
                //

                TdiBuildSend(
                    afdBuffer->Irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartBufferSend,
                    afdBuffer,
                    afdBuffer->Mdl,
                    sendFlags,
                    sendLength
                    );


                IoCallDriver(connection->DeviceObject, afdBuffer->Irp );

                //
                // Complete the IRP if it was completed by the transport
                // and kept around to let us finish posting all the data
                // originally submitted by the app before completing it
                //
                ASSERT (fileObject!=NULL);
                ASSERT (IrpSp->FileObject==NULL || IrpSp->FileObject==(PFILE_OBJECT)-1);
                if (InterlockedExchangePointer (
                            (PVOID *)&IrpSp->FileObject,
                            fileObject)!=NULL) {
                    UPDATE_CONN2 (connection, "AfdSend(split), bytes sent reported 0x%lX", 
                                                (ULONG)Irp->IoStatus.Information);
                    IoCompleteRequest (Irp, AfdPriorityBoost);
                }

            }

            return status;
        }
        else {
            //
            // Count sends pended in the provider too, so
            // we do not buffer in excess and complete
            // buffered application sends before the transport
            // completes sends forwarded to it.
            //
            connection->VcBufferredSendBytes += sendLength;
            connection->VcBufferredSendCount += 1;
        }
    }
    else {
        ASSERT (afdBuffer==NULL);
    }

    //
    // Add a reference to the connection object since the send
    // request will complete asynchronously.
    //

    REFERENCE_CONNECTION2( connection, "AfdSend (non-buffered), length:%lx", sendLength );

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    TdiBuildSend(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartSend,
        connection,
        Irp->MdlAddress,
        sendFlags,
        sendLength
        );


    //
    // Call the transport to actually perform the send.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete:

    if (afdBuffer!=NULL) {
        AfdReturnBuffer (&afdBuffer->Header, process);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdSend


NTSTATUS
AfdRestartSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PMDL mdlChain;
    PMDL nextMdl;
    NTSTATUS status;
    PIRP disconnectIrp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    connection = Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );

    irpSp = IoGetCurrentIrpStackLocation( Irp );


    IF_DEBUG(SEND) {
       KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartSend: send completed for IRP %p, endpoint %p, "
                "status = %X\n",
                Irp, Context, Irp->IoStatus.Status ));
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    if (IS_TDI_BUFFERRING (endpoint)) {

        ASSERT (irpSp->FileObject!=NULL);

        //
        // If the request failed indicating that the send would have blocked,
        // and the client issues a nonblocking send, remember that nonblocking
        // sends won't work until we get a send possible indication.  This
        // is required for write polls to work correctly.
        //
        // If the status code is STATUS_REQUEST_NOT_ACCEPTED, then the
        // transport does not want us to update our internal variable that
        // remembers that nonblocking sends are possible.  The transport
        // will tell us when sends are or are not possible.
        //
        // !!! should we also say that nonblocking sends are not possible if
        //     a send is completed with fewer bytes than were requested?

        if ( Irp->IoStatus.Status == STATUS_DEVICE_NOT_READY ) {

            //
            // Reenable the send event.
            //

            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

            endpoint->EventsActive &= ~AFD_POLL_SEND;
            endpoint->EnableSendEvent = TRUE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSend: Endp %p, Active %lx\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            connection->VcNonBlockingSendPossible = FALSE;

        }

        //
        // If this is a send IRP on a nonblocking endpoint and fewer bytes
        // were actually sent than were requested to be sent, reissue
        // another send for the remaining buffer space.
        //

        if ( !endpoint->NonBlocking && NT_SUCCESS(Irp->IoStatus.Status) &&
                 Irp->IoStatus.Information <
                     irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength ) {

            ASSERT( Irp->MdlAddress != NULL );

            //
            // Advance the MDL chain by the number of bytes actually sent.
            //

            Irp->MdlAddress = AfdAdvanceMdlChain(
                            Irp->MdlAddress,
                            (ULONG)Irp->IoStatus.Information
                            );


            //
            // Update our restart info.
            //

            irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength -=
                (ULONG)Irp->IoStatus.Information;

            //
            // Reissue the send.
            //

            TdiBuildSend(
                Irp,
                connection->FileObject->DeviceObject,
                connection->FileObject,
                AfdRestartSend,
                connection,
                Irp->MdlAddress,
                irpSp->Parameters.AfdRestartSendInfo.AfdSendFlags,
                irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength
                );

            UPDATE_CONN2 (connection, "Restarting incomplete send, bytes: 0x%lX", 
                                        (ULONG)Irp->IoStatus.Information);
            
            status = AfdIoCallDriver(
                         endpoint,
                         connection->FileObject->DeviceObject,
                         Irp
                         );

            IF_DEBUG(SEND) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdRestartSend: IoCallDriver returned %lx\n",
                                status
                                ));
                }
            }

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // Restore the IRP to its former glory before completing it
        // unless it is a non-blocking endpoint in which case
        // we shouldn't have modified it in the first place and
        // we also want to return the actual number of bytes sent
        // by the transport.
        //

        if ( !endpoint->NonBlocking ) {
            Irp->IoStatus.Information = irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength;
        }
        //
        // Remove the reference added just before calling the transport.
        //

        DEREFERENCE_CONNECTION2( connection, "AfdRestartSend-tdib, sent/error: %lx",
            (NT_SUCCESS (Irp->IoStatus.Status) 
                ? (ULONG)Irp->IoStatus.Information
                : (ULONG)Irp->IoStatus.Status));
    }
    else {

        AfdProcessBufferSend (connection, Irp);
        //
        // If we buffered last page of the send, adjust last MDL
        // and fix returned byte count if necessary
        //

        if (Irp->MdlAddress!=irpSp->Parameters.AfdRestartSendInfo.AfdMdlChain) {
            PMDL    mdl = Irp->MdlAddress;

            ASSERT (mdl!=NULL);

            while (mdl->Next!=NULL) {
                mdl = mdl->Next;
            }

            //
            // Unmap the pages that could have been mapped by
            // the transport before adjusting the MDL size back
            // so that MM does not try to unmap more than was
            // mapped by the transport.
            //

            if ((mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) &&
                    (irpSp->Parameters.AfdRestartSendInfo.AfdSendFlags &
                            AFD_SEND_MDL_HAS_NOT_BEEN_MAPPED)) {
                MmUnmapLockedPages (mdl->MappedSystemVa, mdl);
            }

            mdl->ByteCount
                 = irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength;
            mdl->Next = irpSp->Parameters.AfdRestartSendInfo.AfdMdlChain;

            //
            // Remove the reference added just before calling the transport.
            //

            DEREFERENCE_CONNECTION2( connection, "AfdRestartSend-split, sent/error: %lx",
                (NT_SUCCESS (Irp->IoStatus.Status) 
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status));

            if (NT_SUCCESS (Irp->IoStatus.Status)) {
                //
                // Make sure that the TDI provider sent everything we requested that
                // he send.
                //
                ASSERT (Irp->IoStatus.Information+(ULONG)AfdBufferLengthForOnePage==
                            irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength);
                Irp->IoStatus.Information = 
                    irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength;
            }


        }
        else {
            //
            // Remove the reference added just before calling the transport.
            //

            DEREFERENCE_CONNECTION2( connection, "AfdRestartSend, sent/error: %lx",
                (NT_SUCCESS (Irp->IoStatus.Status) 
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status));


            //
            // Make sure that the TDI provider sent everything we requested that
            // he send.
            //

            ASSERT (!NT_SUCCESS (Irp->IoStatus.Status) ||
                     (Irp->IoStatus.Information ==
                         irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength));
        }

    }


    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    //
    // The send dispatch routine temporarily yanks the file
    // object pointer if it wants to make sure that the IRP
    // is not completed until it is fully done with it.
    //
    if (InterlockedExchangePointer (
                (PVOID *)&irpSp->FileObject,
                (PVOID)-1)==NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
        return STATUS_SUCCESS;

} // AfdRestartSend


NTSTATUS
AfdRestartBufferSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_BUFFER afdBuffer;
    PAFD_CONNECTION connection;
#if REFERENCE_DEBUG
    IO_STATUS_BLOCK ioStatus = Irp->IoStatus;
#endif

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));

    connection = afdBuffer->Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( connection->ReferenceCount > 0 );

    //
    // Make sure that the TDI provider sent everything we requested that
    // he send.
    //

    ASSERT( !NT_SUCCESS (Irp->IoStatus.Status)
            || (Irp->IoStatus.Information == afdBuffer->Mdl->ByteCount) );

    //
    // Process the Irp (note that Irp is part of the buffer)
    //
    AfdProcessBufferSend (connection, Irp);

    //
    // Now we can free the buffer
    //

    afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
    AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );


    //
    // Remove the reference added just before calling the transport.
    //


    DEREFERENCE_CONNECTION2( connection, "AfdRestartBufferSend, sent/error:%lx",
        (NT_SUCCESS (ioStatus.Status) 
            ? (ULONG)ioStatus.Information
            : (ULONG)ioStatus.Status));

    //
    // Tell the IO system to stop processing IO completion for this IRP.
    // becuase it belongs to our buffer structure and we do not want
    // to have it freed
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
} // AfdRestartBufferSend

VOID
AfdProcessBufferSend (
    PAFD_CONNECTION Connection,
    PIRP            Irp
    )
{
   
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PIRP irp;
    BOOLEAN sendPossible;
    PIRP disconnectIrp;
    LIST_ENTRY irpsToComplete;

    endpoint = Connection->Endpoint;
    ASSERT( endpoint != NULL );
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth);
    ASSERT( !IS_TDI_BUFFERRING(endpoint) );


    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdProcessBufferSend: send completed for IRP %p, connection %p, "
                    "status = %X\n",
                    Irp, Connection, Irp->IoStatus.Status ));
    }

    //
    // Update the count of send bytes outstanding on the connection.
    // Note that we must do this BEFORE we check to see whether there
    // are any pended sends--otherwise, there is a timing window where
    // a new send could come in, get pended, and we would not kick
    // the sends here.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    ASSERT( Connection->VcBufferredSendBytes >= Irp->IoStatus.Information );
    ASSERT( (Connection->VcBufferredSendCount & 0x8000) == 0 );
    ASSERT( Connection->VcBufferredSendCount != 0 );

    Connection->VcBufferredSendBytes -= (ULONG)Irp->IoStatus.Information;
    Connection->VcBufferredSendCount -= 1;

    //
    // If the send failed, abort the connection.
    //

    if ( !NT_SUCCESS(Irp->IoStatus.Status) ) {

        disconnectIrp = Connection->VcDisconnectIrp;
        if ( disconnectIrp != NULL ) {
            Connection->VcDisconnectIrp = NULL;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );


        AfdBeginAbort( Connection );

        //
        // If there was a disconnect IRP, rather than just freeing it
        // give it to the transport.  This will cause the correct cleanup
        // stuff (dereferenvce objects, free IRP and disconnect context)
        // to occur.  Note that we do this AFTER starting to abort the
        // Connection so that we do not confuse the other side.
        //

        if ( disconnectIrp != NULL ) {
            IoCallDriver( Connection->DeviceObject, disconnectIrp );
        }

        AfdDeleteConnectedReference( Connection, FALSE );

        return;
    }

    //
    // Before we release the lock on the endpoint, remember
    // if the number of bytes outstanding in the TDI provider exceeds
    // the limit.  We must grab this while holding the endpoint lock.
    //

    sendPossible = (Connection->VcBufferredSendBytes<Connection->MaxBufferredSendBytes);

    //
    // If there are no pended sends on the connection, we're done.  Tell
    // the IO system to stop processing IO completion for this IRP.
    //

    if ( IsListEmpty( &Connection->VcSendIrpListHead ) ) {

        //
        // If there is no "special condition" on the endpoint, return
        // immediately.  We use the special condition indication so that
        // we need only a single test in the typical case.
        //

        if ( !Connection->SpecialCondition ) {

            ASSERT( Connection->TdiBufferring || Connection->VcDisconnectIrp == NULL );
            ASSERT( Connection->ConnectedReferenceAdded );

            //
            // There are no sends outstanding on the Connection, so indicate
            // that the endpoint is writable.
            //

            if (sendPossible) {
                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_SEND,
                    STATUS_SUCCESS
                    );
            }
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            if (sendPossible) {
                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_SEND,
                    STATUS_SUCCESS
                    );
            }

            return;
        }


        disconnectIrp = Connection->VcDisconnectIrp;
        if ( disconnectIrp != NULL && Connection->VcBufferredSendCount == 0 ) {
            Connection->VcDisconnectIrp = NULL;
        } else {
            disconnectIrp = NULL;
            if ( sendPossible ) {
                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_SEND,
                    STATUS_SUCCESS
                    );
            }
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // If there is a disconnect IRP, give it to the TDI provider.
        //

        if ( disconnectIrp != NULL ) {
            IoCallDriver( Connection->DeviceObject, disconnectIrp );
        }
        else if ( sendPossible ) {

            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_SEND,
                STATUS_SUCCESS
                );
        }


        //
        // If the connected reference delete is pending, attempt to
        // remove it.
        //

        AfdDeleteConnectedReference( Connection, FALSE );

    
        return;
    }

    //
    // Now loop completing as many pended sends as possible. Note that
    // in order to avoid a nasty race condition (between this thread and
    // a thread performing sends on this connection) we must build a local
    // list of IRPs to complete while holding the endpoint
    // spinlock. After that list is built then we can release the lock
    // and scan the list to actually complete the IRPs.
    //
    // We complete sends when we fall below the send bufferring limits, OR
    // when there is only a single send pended.  We want to be agressive
    // in completing the send if there is only one because we want to
    // give applications every oppurtunity to get data down to us--we
    // definitely do not want to incur excessive blocking in the
    // application.
    //

    InitializeListHead( &irpsToComplete );

    while ( (Connection->VcBufferredSendBytes <=
                 Connection->MaxBufferredSendBytes ||
             Connection->VcSendIrpListHead.Flink ==
                 Connection->VcSendIrpListHead.Blink)


            &&

            !IsListEmpty( &Connection->VcSendIrpListHead ) ) {

        //
        // Take the first pended user send IRP off the connection's
        // list of pended send IRPs.
        //

        listEntry = RemoveHeadList( &Connection->VcSendIrpListHead );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Reset the cancel routine in the user IRP since we're about
        // to complete it.
        //

        if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {
            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            irp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }

        //
        // Append the IRP to the local list.
        //

        InsertTailList(
            &irpsToComplete,
            &irp->Tail.Overlay.ListEntry
            );

    }

    if ( sendPossible ) {

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_SEND,
            STATUS_SUCCESS
            );

    }

    //
    // Now we can release the locks and scan the local list of IRPs
    // we need to complete, and actually complete them.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    while( !IsListEmpty( &irpsToComplete ) ) {
        PIO_STACK_LOCATION irpSp;

        //
        // Remove the first item from the IRP list.
        //

        listEntry = RemoveHeadList( &irpsToComplete );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Complete the user's IRP with a successful status code.  The IRP
        // should already be set up with the correct status and bytes
        // written count.
        //

        irpSp = IoGetCurrentIrpStackLocation( irp );

#if DBG
        if ( irp->IoStatus.Status == STATUS_SUCCESS ) {
            ASSERT( irp->IoStatus.Information == irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength );
        }
#endif
        //
        // The send dispatch routine puts NULL into this
        // field if it wants to make sure that the IRP
        // is not completed until it is fully done with it
        //
        if (InterlockedExchangePointer (
                    &irp->Tail.Overlay.DriverContext[0],
                    (PVOID)-1)!=NULL) {
            UPDATE_CONN2 (Connection, "AfdProcessBufferSend, bytes sent reported 0x%lX", 
                                        (ULONG)irp->IoStatus.Information);
            IoCompleteRequest( irp, AfdPriorityBoost );
        }
    }

    if ( sendPossible ) {

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_SEND,
            STATUS_SUCCESS
            );

    }

    return;

} // AfdProcessBufferSend


NTSTATUS
AfdRestartSendConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_SEND_CONN_DATAGRAM_CONTEXT context = Context;
    PAFD_ENDPOINT   endpoint = context->Endpoint;

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSendConnDatagram: send conn completed for "
                    "IRP %p, endpoint %p, status = %X\n",
                    Irp, endpoint, Irp->IoStatus.Status ));
    }

    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS ||
                Irp->IoStatus.Information
                    ==IoGetCurrentIrpStackLocation (Irp)->Parameters.AfdRestartSendInfo.AfdOriginalLength);

    //
    // Free the context structure we allocated earlier.
    //

    AfdCompleteOutstandingIrp( endpoint, Irp );
    AFD_FREE_POOL(
        context,
        AFD_TDI_POOL_TAG
        );

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartSendConnDatagram, status", Irp->IoStatus.Status);
    return STATUS_SUCCESS;

} // AfdRestartSendConnDatagram


NTSTATUS
AfdRestartSendTdiConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_ENDPOINT endpoint = Context;

    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS ||
                Irp->IoStatus.Information
                    ==IoGetCurrentIrpStackLocation (Irp)->Parameters.AfdRestartSendInfo.AfdOriginalLength);
    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSendTdiConnDatagram: send conn completed for "
                    "IRP %p, endpoint %p, status = %X\n",
                    Irp, endpoint, Irp->IoStatus.Status ));
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartSendTdiConnDatagram, status", Irp->IoStatus.Status);
    return STATUS_SUCCESS;

} // AfdRestartSendTdiConnDatagram


NTSTATUS
FASTCALL
AfdSendDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PTRANSPORT_ADDRESS destinationAddress;
    ULONG destinationAddressLength;
    PAFD_BUFFER_TAG afdBuffer = NULL;
    ULONG sendLength;
    ULONG bufferCount;

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );


    if ( !IS_DGRAM_ENDPOINT (endpoint) ||
            ((endpoint->State != AfdEndpointStateBound )
                && (endpoint->State != AfdEndpointStateConnected)) ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SEND_DATAGRAM_INFO32 sendInfo32;
        LPWSABUF32 bufferArray32;

        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(*sendInfo32) ) {

            try {

                //
                // Validate the input structure if it comes from the user mode 
                // application
                //

                sendInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                if( Irp->RequestorMode != KernelMode ) {

                    ProbeForRead(
                        sendInfo32,
                        sizeof(*sendInfo32),
                        PROBE_ALIGNMENT32 (AFD_SEND_DATAGRAM_INFO32)
                        );

                }

                //
                // Make local copies of the embeded pointer and parameters
                // that we will be using more than once in case malicios
                // application attempts to change them while we are
                // validating
                //

                bufferArray32 = sendInfo32->BufferArray;
                bufferCount = sendInfo32->BufferCount;
                destinationAddress =
                    sendInfo32->TdiConnInfo.RemoteAddress;
                destinationAddressLength =
                    sendInfo32->TdiConnInfo.RemoteAddressLength;


                //
                // Create the MDL chain describing the WSABUF array.
                // This will also validate the buffer array and individual
                // buffers
                //

                status = AfdAllocateMdlChain32(
                             Irp,       // Requestor mode passed along
                             bufferArray32,
                             bufferCount,
                             IoReadAccess,
                             &sendLength
                             );


            } except( AFD_EXCEPTION_FILTER(&status) ) {

                //
                //  Exception accessing input structure.
                //

            }
        } else {

            //
            // Invalid input buffer length.
            //

            status = STATUS_INVALID_PARAMETER;

        }
    }
    else
#endif _WIN64
    {
        PAFD_SEND_DATAGRAM_INFO sendInfo;
        LPWSABUF bufferArray;
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(*sendInfo) ) {


            try {


                //
                // Validate the input structure if it comes from the user mode 
                // application
                //

                sendInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                if( Irp->RequestorMode != KernelMode ) {

                    ProbeForRead(
                        sendInfo,
                        sizeof(*sendInfo),
                        PROBE_ALIGNMENT (AFD_SEND_DATAGRAM_INFO)
                        );

                }

                //
                // Make local copies of the embeded pointer and parameters
                // that we will be using more than once in case malicios
                // application attempts to change them while we are
                // validating
                //

                bufferArray = sendInfo->BufferArray;
                bufferCount = sendInfo->BufferCount;
                destinationAddress =
                    sendInfo->TdiConnInfo.RemoteAddress;
                destinationAddressLength =
                    sendInfo->TdiConnInfo.RemoteAddressLength;



                //
                // Create the MDL chain describing the WSABUF array.
                // This will also validate the buffer array and individual
                // buffers
                //

                status = AfdAllocateMdlChain(
                            Irp,            // Requestor mode passed along
                            bufferArray,
                            bufferCount,
                            IoReadAccess,
                            &sendLength
                            );


            } except( AFD_EXCEPTION_FILTER(&status) ) {

                //
                // Exception accessing input structure.
                //


            }

        } else {

            //
            // Invalid input buffer length.
            //

            status = STATUS_INVALID_PARAMETER;

        }
    }


    if( !NT_SUCCESS(status) ) {
        goto complete;
    }

    //
    // If send has been shut down on this endpoint, fail.
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) ) {
        status = STATUS_PIPE_DISCONNECTED;
        goto complete;
    }

    //
    // Copy the destination address to the AFD buffer.
    //

    try {

        //
        // Get an AFD buffer to use for the request.  We need this to
        // hold the destination address for the datagram.
        //

        afdBuffer = AfdGetBufferTagRaiseOnFailure(
                                        destinationAddressLength, 
                                        endpoint->OwningProcess );
        //
        // Probe the address buffer if it comes from the user mode
        // application
        //
        if( Irp->RequestorMode != KernelMode ) {
            ProbeForRead (
                destinationAddress,
                destinationAddressLength,
                sizeof (UCHAR));
        }

        RtlCopyMemory(
            afdBuffer->TdiInfo.RemoteAddress,
            destinationAddress,
            destinationAddressLength
            );

        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->TAAddressCount!=1) ||
                (LONG)destinationAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        afdBuffer->TdiInfo.RemoteAddressLength = destinationAddressLength;
        ASSERT (afdBuffer->TdiInfo.RemoteAddress !=NULL);
        afdBuffer->TdiInfo.Options = NULL;
        afdBuffer->TdiInfo.OptionsLength = 0;
        afdBuffer->TdiInfo.UserData = NULL;
        afdBuffer->TdiInfo.UserDataLength = 0;

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        if (afdBuffer!=NULL) {
            AfdReturnBuffer ( &afdBuffer->Header, endpoint->OwningProcess );
        }
        goto complete;
    }

    //
    // Build the request to send the datagram.
    //

    REFERENCE_ENDPOINT2 (endpoint,"AfdSendDatagram, length", sendLength);
    afdBuffer->Context = endpoint;
#if DBG
    //
    // Store send length to check transport upon completion
    //
    IrpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength = sendLength;
#endif

    TdiBuildSendDatagram(
        Irp,
        endpoint->AddressDeviceObject,
        endpoint->AddressFileObject,
        AfdRestartSendDatagram,
        afdBuffer,
        Irp->MdlAddress,
        sendLength,
        &afdBuffer->TdiInfo
        );

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendDatagram: SendDGInfo at %p, len = %ld\n",
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength ));
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendDatagram: remote address at %p, len = %ld\n",
                    destinationAddress,
                    destinationAddressLength ));
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendDatagram: output buffer length = %ld\n",
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength ));
    }

    //
    // Call the transport to actually perform the send datagram.
    //

    return AfdIoCallDriver( endpoint, endpoint->AddressDeviceObject, Irp );

complete:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdSendDatagram


NTSTATUS
AfdRestartSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_BUFFER_TAG afdBuffer;
    PAFD_ENDPOINT endpoint;

    afdBuffer = Context;

    endpoint = afdBuffer->Context;

    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS ||
                Irp->IoStatus.Information
                    ==IoGetCurrentIrpStackLocation (Irp)->Parameters.AfdRestartSendInfo.AfdOriginalLength);
    AfdCompleteOutstandingIrp( endpoint, Irp );

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSendDatagram: send datagram completed for "
                    "IRP %p, endpoint %p, status = %X\n",
                    Irp, Context, Irp->IoStatus.Status ));
    }

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdReturnBuffer( &afdBuffer->Header,  endpoint->OwningProcess  );

    DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartSendDatagram, status", Irp->IoStatus.Status);
    return STATUS_SUCCESS;

} // AfdRestartSendDatagram


NTSTATUS
AfdSendPossibleEventHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    BOOLEAN       result;

    UNREFERENCED_PARAMETER( TdiEventContext );
    UNREFERENCED_PARAMETER( BytesAvailable );

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION (connection, result);
    if (!result) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT( IS_TDI_BUFFERRING(endpoint) );
    ASSERT( connection->TdiBufferring );

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendPossibleEventHandler: send possible on endpoint %p "
                    " conn %p bytes=%ld\n", endpoint, connection, BytesAvailable ));
    }

    //
    // Remember that it is now possible to do a send on this connection.
    //

    if ( BytesAvailable != 0 ) {

        connection->VcNonBlockingSendPossible = TRUE;

        //
        // Complete any outstanding poll IRPs waiting for a send poll.
        //

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            AFD_LOCK_QUEUE_HANDLE   lockHandle;
            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_SEND,
                STATUS_SUCCESS
                );
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_SEND,
                STATUS_SUCCESS
                );
        }

    } else {

        connection->VcNonBlockingSendPossible = FALSE;
    }

    DEREFERENCE_CONNECTION (connection);
    return STATUS_SUCCESS;

} // AfdSendPossibleEventHandler


VOID
AfdCancelSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Cancels a send IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    //
    // Get the endpoint pointer from our IRP stack location and the
    // connection pointer from the endpoint.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Remove the IRP from the endpoint's IRP list if it has not been
    // removed already
    //

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel ( &endpoint->SpinLock, &lockHandle);

    if ( Irp->Tail.Overlay.ListEntry.Flink != NULL ) {
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    }

    //
    // Release the cancel spin lock and complete the IRP with a
    // cancellation status code.
    //

    AfdReleaseSpinLockFromDpcLevel ( &endpoint->SpinLock, &lockHandle);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    //
    // The send dispatch routine puts NULL into this
    // field if it wants to make sure that the IRP
    // is not completed until it is fully done with it
    //
    if (InterlockedExchangePointer (
                &Irp->Tail.Overlay.DriverContext[0],
                (PVOID)-1)!=NULL) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
        IoCompleteRequest( Irp, AfdPriorityBoost );
    }
    else {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }
    return;
} // AfdCancelSend


BOOLEAN
AfdCleanupSendIrp (
    PIRP    Irp
    )
{
    //
    // The send dispatch routine puts NULL into this
    // field if it wants to make sure that the IRP
    // is not completed until it is fully done with it
    //
    if (InterlockedExchangePointer (
                &Irp->Tail.Overlay.DriverContext[0],
                (PVOID)-1)!=NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\tpackets.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    tpackets.c

Abstract:

    This module contains support for fast kernel-level file transmission
    over a socket handle.

Author:

    Vadim Eydelman (VadimE)	January 1999

Revision History:

--*/

#include "afdp.h"

//
// Macros to make TransmitPackets code readble
//
#define AfdTPacketsInfo         DeviceIoControl
#define AfdTPacketsFlags        IoControlCode



#if DBG
PIRP    Irp;
C_ASSERT (sizeof (AFD_TPACKETS_IRP_CTX)<=sizeof (Irp->Tail.Overlay.DriverContext));
#endif

#if DBG
ULONG
__inline
AFD_SET_TP_FLAGS (
     PIRP                        TpIrp,
     ULONG                       Flags
     )
{
    PAFD_TPACKETS_IRP_CTX   ctx = AFD_GET_TPIC(TpIrp);
    ASSERT ((ctx->StateFlags & Flags)==0);
    return InterlockedExchangeAdd ((PLONG)&(ctx)->StateFlags, Flags);
}

ULONG
__inline
AFD_CLEAR_TP_FLAGS (
     PIRP                        TpIrp,
     ULONG                       Flags
     )
{
    PAFD_TPACKETS_IRP_CTX   ctx = AFD_GET_TPIC(TpIrp);
    ASSERT ((ctx->StateFlags & Flags)==Flags);
    return InterlockedExchangeAdd ((PLONG)&(ctx)->StateFlags, 0-Flags);
}

#else

#define AFD_SET_TP_FLAGS(_i,_f)     \
    InterlockedExchangeAdd ((PLONG)&AFD_GET_TPIC(_i)->StateFlags, _f)

#define AFD_CLEAR_TP_FLAGS(_i,_f)   \
    InterlockedExchangeAdd ((PLONG)&AFD_GET_TPIC(_i)->StateFlags, 0-(_f))
#endif

//
// Reference/dereference macros for transmit info structure.
// We keep transmit IRP pending and all the elements of
// the structure till last reference to it is gone.
// Note, that reference can be added only if structure
// already has non-0 reference count.
//
#if REFERENCE_DEBUG
VOID
AfdReferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    );

LONG
AfdDereferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdUpdateTPacketsTrack (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define REFERENCE_TPACKETS(_i) {                                        \
        static LONG _arl;                                               \
        AfdReferenceTPackets(_i,AFD_GET_ARL(__FILE__"(%d)+"),__LINE__); \
    }

#define DEREFERENCE_TPACKETS(_i) {                                      \
        static LONG _arl;                                               \
        if (AfdDereferenceTPackets(_i,AFD_GET_ARL(__FILE__"(%d)-"),__LINE__)==0) {\
            AfdCompleteTPackets(_i);                                    \
        };\
    }

#define DEREFERENCE_TPACKETS_S(_i) {                                    \
        static LONG _arl;                                               \
        if (AfdDereferenceTPackets(_i,AFD_GET_ARL(__FILE__"(%d)-"),__LINE__)==0) {\
            AfdStartTPacketsWorker(AfdCompleteTPackets,_i);             \
        }                                                               \
    }

#define UPDATE_TPACKETS(_i) {                                           \
        static LONG _arl;                                               \
        AfdUpdateTPacketsTrack((_i),AFD_GET_ARL(__FILE__"(%d)="),__LINE__);\
    }

#define UPDATE_TPACKETS2(_i,_s,_p) {                                    \
        static LONG _arl;                                               \
        AfdUpdateTPacketsTrack((_i),AFD_GET_ARL(_s"="),_p);             \
    }
#else // REFERENCE_DEBUG

#define REFERENCE_TPACKETS(_i)                                          \
    InterlockedIncrement ((PLONG)&AFD_GET_TPIC(_i)->ReferenceCount)

#define DEREFERENCE_TPACKETS(_i)                                        \
    if (InterlockedDecrement((PLONG)&AFD_GET_TPIC(_i)->ReferenceCount)==0) {\
        AfdCompleteTPackets(_i);                                        \
    }

#define DEREFERENCE_TPACKETS_S(_i) {                                    \
    if (InterlockedDecrement((PLONG)&AFD_GET_TPIC(_i)->ReferenceCount)==0) {\
        AfdStartTPacketsWorker(AfdCompleteTPackets, _i);                \
    }                                                                   \
}

#define UPDATE_TPACKETS(_i)

#define UPDATE_TPACKETS2(_i,_s,_p)

#endif // REFERENCE_DEBUG

#if DBG
//
// Doesn't seem like we have a file system that does not
// support cache.  So this is here for debugging purposes.
//
ULONG   AfdUseCache=TRUE;
#define AFD_USE_CACHE(file) \
    (AfdUseCache&&(((file)->Flags&FO_CACHE_SUPPORTED)!=0))

#else   // DBG

#define AFD_USE_CACHE(file) (((file)->Flags & FO_CACHE_SUPPORTED)!=0)

#endif  // DBG

VOID
AfdTPacketsWorker (
    PVOID   Context
    );

VOID
AfdPerformSuperDisconnect (
    PIRP    TpIrp
    );

NTSTATUS
AfdBuildPacketChain (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  *Pd
    );

BOOLEAN
AfdCleanupPacketChain (
    PIRP    TpIrp,
    BOOLEAN BelowDispatch
    );

NTSTATUS
AfdTPacketsSend (
    PIRP    TpIrp,
    USHORT  SendIrp
    );

NTSTATUS
AfdRestartTPacketsSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartTPDetachedSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

USHORT
AfdTPacketsFindSendIrp (
    PIRP    TpIrp
    );

NTSTATUS
AfdTPacketsMdlRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    );

NTSTATUS
AfdRestartTPacketsMdlRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdMdlReadComplete (
    PFILE_OBJECT	FileObject,
    PMDL            FileMdl,
	PLARGE_INTEGER	FileOffset
    );


NTSTATUS
AfdRestartMdlReadComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdLRMdlReadComplete (
    PAFD_BUFFER_HEADER  Pd
    );

BOOLEAN
AfdLRProcessFileMdlList (
    PAFD_LR_LIST_ITEM Item
    );

NTSTATUS
AfdTPacketsBufferRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    );

NTSTATUS
AfdRestartTPacketsBufferRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
AfdTPacketsContinueAfterRead (
    PIRP    TpIrp
    );

VOID
AfdCompleteTPackets (
    PVOID       Context
    );

VOID
AfdAbortTPackets (
    PIRP        TpIrp,
    NTSTATUS    Status
    );

VOID
AfdCancelTPackets (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
BOOLEAN
AfdTPacketsEnableSendAndDisconnect (
    PIRP TpIrp
    );
#endif // TDI_SERVICE_SEND_AND_DISCONNECT

BOOLEAN
AfdQueueTransmit (
    PIRP        Irp
    );

VOID
AfdStartNextQueuedTransmit(
    VOID
    );

VOID
AfdStartTPacketsWorker (
    PWORKER_THREAD_ROUTINE  WorkerRoutine,
    PIRP                    TpIrp
    );

VOID
AfdTPacketsApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdTPacketsApcRundownRoutine (
    IN struct _KAPC *Apc
    );

BOOLEAN
AfdEnqueueTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    );

VOID
AfdStartNextTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    );

BOOLEAN
AfdGetTPacketsReference (
    PIRP    Irp
    );

PAFD_TPACKETS_INFO_INTERNAL
AfdGetTpInfo (
    ULONG   ElementCount
    );

VOID
AfdReturnTpInfo (
    PAFD_TPACKETS_INFO_INTERNAL TpInfo
    );

#ifdef _WIN64
NTSTATUS
AfdTransmitPackets32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PAFD_TPACKETS_INFO_INTERNAL *TpInfo
    );
#endif //_WIN64

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdTransmitPackets )
#ifdef _WIN64
#pragma alloc_text( PAGE, AfdTransmitPackets32 )
#endif //_WIN64
#pragma alloc_text( PAGE, AfdTPacketsWorker )
#pragma alloc_text( PAGE, AfdPerformSuperDisconnect )
#pragma alloc_text( PAGE, AfdBuildPacketChain )
#pragma alloc_text( PAGEAFD, AfdCleanupPacketChain )
#pragma alloc_text( PAGEAFD, AfdTPacketsSend )
#pragma alloc_text( PAGEAFD, AfdRestartTPacketsSend )
#pragma alloc_text( PAGEAFD, AfdRestartTPDetachedSend )
#pragma alloc_text( PAGEAFD, AfdTPacketsFindSendIrp)
#pragma alloc_text( PAGE, AfdTPacketsMdlRead )
#pragma alloc_text( PAGEAFD, AfdRestartTPacketsMdlRead )
#pragma alloc_text( PAGE, AfdMdlReadComplete )
#pragma alloc_text( PAGEAFD, AfdRestartMdlReadComplete )
#pragma alloc_text( PAGE, AfdLRMdlReadComplete )
#pragma alloc_text( PAGE, AfdLRProcessFileMdlList )
#pragma alloc_text( PAGE, AfdTPacketsBufferRead )
#pragma alloc_text( PAGEAFD, AfdRestartTPacketsBufferRead )
#pragma alloc_text( PAGEAFD, AfdTPacketsContinueAfterRead )
#pragma alloc_text( PAGEAFD, AfdCompleteTPackets )
#pragma alloc_text( PAGEAFD, AfdAbortTPackets )
#pragma alloc_text( PAGEAFD, AfdCancelTPackets )
#pragma alloc_text( PAGEAFD, AfdCompleteClosePendedTPackets )
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
#pragma alloc_text( PAGEAFD, AfdTPacketsEnableSendAndDisconnect )
#endif
#pragma alloc_text( PAGEAFD, AfdQueueTransmit )
#pragma alloc_text( PAGEAFD, AfdStartNextQueuedTransmit )
#pragma alloc_text( PAGEAFD, AfdStartTPacketsWorker )
#pragma alloc_text( PAGE, AfdTPacketsApcKernelRoutine )
#pragma alloc_text( PAGE, AfdTPacketsApcRundownRoutine )
#pragma alloc_text( PAGEAFD, AfdEnqueueTPacketsIrp )
#pragma alloc_text( PAGEAFD, AfdStartNextTPacketsIrp )
#pragma alloc_text( PAGEAFD, AfdGetTPacketsReference )
#if REFERENCE_DEBUG
#pragma alloc_text( PAGEAFD, AfdReferenceTPackets )
#pragma alloc_text( PAGEAFD, AfdDereferenceTPackets )
#pragma alloc_text( PAGEAFD, AfdUpdateTPacketsTrack )
#endif
#pragma alloc_text( PAGE, AfdGetTpInfo )
#pragma alloc_text( PAGEAFD, AfdReturnTpInfo )
#pragma alloc_text( INIT, AfdComputeTpInfoSize )
#pragma alloc_text( PAGEAFD, AfdAllocateTpInfo )
#pragma alloc_text( PAGEAFD, AfdFreeTpInfo )
#endif



NTSTATUS
FASTCALL
AfdTransmitPackets (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling transmit packets IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT       endpoint;
    NTSTATUS            status;
    AFD_TPACKETS_INFO   params;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = NULL;
    BOOLEAN             irpQueued;


    PAGED_CODE ();
    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Special hack to let the user mode dll know that it
    // should try SAN provider instead.
    //

    if (IS_SAN_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

    //
    // Make sure we only execute one transmitfile transmitpackets request
    // at a time on a given endpoint.
    //
    if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }


    //
    // The endpoint must be connected and underlying transport must support
    // TdiSend (not just TdiSendDatagram).
    //
    if ( (endpoint->Type != AfdBlockTypeVcConnecting &&
                (endpoint->Type != AfdBlockTypeDatagram ||
                        !IS_TDI_DGRAM_CONNECTION(endpoint))) ||
            endpoint->State != AfdEndpointStateConnected ) {
        status = STATUS_INVALID_CONNECTION;
        goto complete_state_change;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdTransmitPackets32 (Irp, IrpSp, &tpInfo);
        if (!NT_SUCCESS (status)) {
            goto complete_state_change;
        }
    }
    else
#endif _WIN64
    {
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_TPACKETS_INFO) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete_state_change;
        }

        //
        // Because we're using type 3 (neither) I/O for this IRP, the I/O
        // system does no verification on the user buffer.  Therefore, we
        // must manually check it for validity inside a try-except block.
        // We also leverage the try-except to validate and lock down the
        // head and/or tail buffers specified by the caller.
        //

        try {
            PFILE_OBJECT        fileObject;
            HANDLE              fileHandle;
            ULONG               lastSmallBuffer, currentLength, xLength;
            ULONG               maxPacketSize;

            if( Irp->RequestorMode != KernelMode ) {

                //
                // Validate the control buffer.
                //

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    sizeof (AFD_TPACKETS_INFO),
                    PROBE_ALIGNMENT (AFD_TPACKETS_INFO)
                    );

            }


            params = *((PAFD_TPACKETS_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        
            //
            // Validate any flags specified in the request.
            //

            if ( ((params.Flags &
                     ~(AFD_TF_WRITE_BEHIND |
                                AFD_TF_DISCONNECT |
                                AFD_TF_REUSE_SOCKET |
                                AFD_TF_WORKER_KIND_MASK) )
                            != 0 )
                        ||
                 ((params.Flags & AFD_TF_WORKER_KIND_MASK) 
                            == AFD_TF_WORKER_KIND_MASK)
                        ||

                 (endpoint->Type==AfdBlockTypeDatagram &&
                     (params.Flags & (AFD_TF_DISCONNECT |
                                        AFD_TF_REUSE_SOCKET))
                            !=0) ) {
                status = STATUS_INVALID_PARAMETER;
                goto complete_state_change;
            }

            //
            // Protect from overflow
            //
            if ((params.ElementArray==NULL) || 
                    (params.ElementCount==0) ||
                    (params.ElementCount>(MAXULONG/sizeof (params.ElementArray[0])))) {
                status = STATUS_INVALID_PARAMETER;
                goto complete_state_change;
            }
            //
            // If transmit worker is not specified, use system default setting
            //
            if ((params.Flags & AFD_TF_WORKER_KIND_MASK)==AFD_TF_USE_DEFAULT_WORKER) {
                params.Flags |= AfdDefaultTransmitWorker;
            }

            //
            // Allocate tpackets info for the request
            //
            tpInfo = AfdGetTpInfo (params.ElementCount);
            if (tpInfo==NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete_state_change;
            }

            tpInfo->SendPacketLength = params.SendSize;
            if (tpInfo->SendPacketLength==0)
                tpInfo->SendPacketLength = AfdTransmitIoLength;
            //
            // Probe and copy/walk the array of the elements to transmit.
            //

            if( Irp->RequestorMode != KernelMode ) {
                ProbeForRead(
                    params.ElementArray,
                    sizeof (TRANSMIT_PACKETS_ELEMENT)*params.ElementCount,
                    PROBE_ALIGNMENT (TRANSMIT_PACKETS_ELEMENT)
                    );
            }

            lastSmallBuffer = 0;
            currentLength = 0;
            fileHandle = NULL;
            xLength = 0;
            tpInfo->RemainingPkts = 0;
            maxPacketSize = 0;
            for (tpInfo->ElementCount=0; 
                        tpInfo->ElementCount<params.ElementCount; 
                        tpInfo->ElementCount++) {
                PAFD_TRANSMIT_PACKETS_ELEMENT  pel;
                pel = &tpInfo->ElementArray[tpInfo->ElementCount];
                pel->Flags = params.ElementArray[tpInfo->ElementCount].dwElFlags;
                if ( ((pel->Flags & (~(TP_MEMORY|TP_FILE|TP_EOP)))!=0) ||
                        ((pel->Flags & (TP_MEMORY|TP_FILE))
                                                ==(TP_MEMORY|TP_FILE)) ||
                        ((pel->Flags & (TP_MEMORY|TP_FILE))==0) ) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete_state_change;
                }

                pel->Length = params.ElementArray[tpInfo->ElementCount].cLength;
                if (pel->Flags & TP_FILE) {
                    HANDLE  hFile = params.ElementArray[tpInfo->ElementCount].hFile;


                    //
                    // Check if we already cached the file object
                    //
                    if (fileHandle==NULL || hFile!=fileHandle) {
                        //
                        // Get a referenced pointer to the file object 
                        // for the file that we're going to transmit.  This call 
                        // will fail if the file handle specified by the caller 
                        // is invalid.
                        //

                        status = ObReferenceObjectByHandle(
                                     hFile,
                                     FILE_READ_DATA,
                                     *IoFileObjectType,
                                     Irp->RequestorMode,
                                     (PVOID *)&fileObject,
                                     NULL
                                     );
                        if ( !NT_SUCCESS(status) ) {
                            //
                            // Tell the caller that we encountered an error
                            // when accessing file not socket.
                            //
                            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                                if (Irp->RequestorMode != KernelMode) {
                                    ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                                }
                                else {
                                    *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                                }
                            }
                            goto complete_state_change;
                        }
                    }
                    else {
                        //
                        // Use our 1-element file info cache.
                        //
                        ObReferenceObject (fileObject);
                    }
                    AfdRecordFileRef();

                    //
                    // Save the file object instead of handle.
                    //
                    pel->FileObject = fileObject;

                    pel->FileOffset = params.ElementArray[
                                            tpInfo->ElementCount].nFileOffset;

                    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) &&
                             (pel->FileOffset.QuadPart == 0) ) {
                        //
                        // Use current offset if file is opened syncronously
                        // and offset is not specified.
                        //

                        pel->FileOffset = fileObject->CurrentByteOffset;
                    }

                    if ( pel->Length == 0 ) {
                        //
                        // Length was not specified, figure out the
                        // size of the entire file
                        //

                        FILE_STANDARD_INFORMATION fileInfo;
                        IO_STATUS_BLOCK ioStatusBlock;

                        status = ZwQueryInformationFile(
                                     hFile,
                                     &ioStatusBlock,
                                     &fileInfo,
                                     sizeof(fileInfo),
                                     FileStandardInformation
                                     );
                        if ( !NT_SUCCESS(status) ) {
                            //
                            // Bump element count so that file object
                            // is dereferenced in cleanup
                            //
                            tpInfo->ElementCount += 1;
                            //
                            // Tell the caller that we encountered an error
                            // when accessing file not socket.
                            //
                            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                                if (Irp->RequestorMode != KernelMode) {
                                    ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                                }
                                else {
                                    *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                                }
                            }
                            goto complete_state_change;
                        }

                        //
                        // Make sure that offset is within the file
                        //
                        if (pel->FileOffset.QuadPart < 0
                                        ||
                            pel->FileOffset.QuadPart > fileInfo.EndOfFile.QuadPart
                                        ||
                                (fileInfo.EndOfFile.QuadPart - 
                                        pel->FileOffset.QuadPart > MAXLONG)) {
                            //
                            // Bump element count so that file object
                            // is dereferenced in cleanup
                            //
                            tpInfo->ElementCount += 1;
                            status = STATUS_INVALID_PARAMETER;
                            goto complete_state_change;

                        }
                        pel->Length = (ULONG)(fileInfo.EndOfFile.QuadPart - 
                                                    pel->FileOffset.QuadPart);
                    }
                    else if (pel->FileOffset.QuadPart<0) {
                        //
                        // Bump element count so that file object
                        // is dereferenced in cleanup
                        //
                        tpInfo->ElementCount += 1;
                        status = STATUS_INVALID_PARAMETER;
                        goto complete_state_change;

                    }
                    //
                    // Update our 1-element file information cache
                    //
                    fileHandle = hFile;

                }
                else {
                    ASSERT (pel->Flags & TP_MEMORY);
                    //
                    // For memory object just save the buffer pointer 
                    // (length is saved above), we'll probe and lock/copy
                    // the data as we send it.
                    //
                    pel->Buffer = params.ElementArray[
                                            tpInfo->ElementCount].pBuffer;
                    if (pel->Length<=AfdTPacketsCopyThreshold) {
                        if (lastSmallBuffer!=0 &&
                                (lastSmallBuffer+=pel->Length) <= AfdTPacketsCopyThreshold &&
                                (currentLength+lastSmallBuffer) <= tpInfo->SendPacketLength) {
                            (pel-1)->Flags |= TP_COMBINE;
                        }
                        else
                            lastSmallBuffer = pel->Length;
                        if (!(pel->Flags & TP_EOP))
                            goto NoBufferReset;
                    }

                }
                lastSmallBuffer = 0;

            NoBufferReset:
                if (pel->Flags & TP_EOP) {
                    currentLength = 0;
                }
                else {
                    currentLength = (currentLength+pel->Length)%tpInfo->SendPacketLength;
                }

                //
                // Compute the total number of packets that we will send.
                // This is necessary so that once we are close to the end
                // we can buffer the remaining data and stop processing
                // early.
                //
                if (tpInfo->RemainingPkts!=MAXULONG) {
                    ULONG   n;
                    ULONGLONG x;
                    //
                    // Add length of the element to data left from the 
                    // previous one.
                    //
                    x = xLength + pel->Length;

                    //
                    // Compute total number of packets pased on max packet
                    // length.
                    //
                    n = tpInfo->RemainingPkts + (ULONG)(xLength/tpInfo->SendPacketLength);

                    //
                    // Compute the length of the last incomplete packet to
                    // be combined with the next element.
                    //
                    xLength = (ULONG)(x%tpInfo->SendPacketLength);

                    //
                    // Compute the max size of the packet
                    //
                    if (x>tpInfo->SendPacketLength)
                        maxPacketSize = tpInfo->SendPacketLength; // This is absolute max.
                    else if (maxPacketSize<xLength)
                        maxPacketSize = xLength;

                    if (n>=tpInfo->RemainingPkts && n<MAXULONG) {
                        tpInfo->RemainingPkts = n;
                        if (pel->Flags & TP_EOP) {
                            if (xLength!=0 || pel->Length==0) {
                                tpInfo->RemainingPkts += 1;
                                xLength = 0;
                            }
                        }
                    }
                    else {
                        tpInfo->RemainingPkts = MAXULONG;
                    }
                }
            }

            if (maxPacketSize==0) {
                maxPacketSize = tpInfo->SendPacketLength;
            }

            //
            // Compute the total number of IRPS to use based
            // on SO_SNDBUF setting and maximum packet size
            // (we do not want to buffer more than SO_SNDBUF).
            //
            {
                ULONG   maxSendBytes, irpCount;
                if (endpoint->Type==AfdBlockTypeVcConnecting) {
                    maxSendBytes = endpoint->Common.VcConnecting.Connection->MaxBufferredSendBytes;
                }
                else {
                    ASSERT (endpoint->Type==AfdBlockTypeDatagram);
                    maxSendBytes = endpoint->Common.Datagram.MaxBufferredSendBytes;
                }

                irpCount = maxSendBytes/maxPacketSize;
                if (irpCount>AFD_TP_MIN_SEND_IRPS) {
                    if (irpCount>AFD_TP_MAX_SEND_IRPS) {
                        tpInfo->NumSendIrps = AFD_TP_MAX_SEND_IRPS;
                    }
                    else {
                        tpInfo->NumSendIrps = (USHORT)irpCount;
                    }
                }
            }

            //
            // Initialize flags.
            //
            IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags = params.Flags;

        } except( AFD_EXCEPTION_FILTER(&status) ) {

            goto complete_state_change;
        }
    }


    if (endpoint->Type==AfdBlockTypeVcConnecting) {
        //
        // Connection endpoint, get connection file object and device
        //
        tpInfo->TdiFileObject = 
            endpoint->Common.VcConnecting.Connection->FileObject;
        tpInfo->TdiDeviceObject = 
            endpoint->Common.VcConnecting.Connection->DeviceObject;
        //
        // Setting AFD_TF_REUSE_SOCKET implies that a disconnect is desired.
        // Also, setting this flag means that no more I/O is legal on the
        // endpoint until the transmit request has been completed, so
        // set up the endpoint's state so that I/O fails.
        //

        if ( (IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_REUSE_SOCKET) != 0 ) {
            IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags |= AFD_TF_DISCONNECT;
            endpoint->State = AfdEndpointStateTransmitClosing;
        }
        UPDATE_TPACKETS2 (Irp, "Connection object handle: %lx",
            HandleToUlong (endpoint->Common.VcConnecting.Connection->Handle));
    }
    else { 
        //
        // Datagram endpoint, get address file object and device
        //
        ASSERT (endpoint->Type==AfdBlockTypeDatagram);
        tpInfo->TdiFileObject = endpoint->AddressFileObject;
        tpInfo->TdiDeviceObject = endpoint->AddressDeviceObject;
        UPDATE_TPACKETS2 (Irp, "Address object handle: %lx", HandleToUlong (endpoint->AddressHandle));
    }


    //
    // Save tpacket info in the IRP
    //
    Irp->AssociatedIrp.SystemBuffer = tpInfo;

    //
    // Clear the Flink in the IRP to indicate this IRP is not queued.
    // Blink is cleared to indicate that IRP was counted towards
    // active maximum.
    //

    Irp->Tail.Overlay.ListEntry.Flink = NULL;
    Irp->Tail.Overlay.ListEntry.Blink = NULL;

    //
    // Initialize the IRP result fields
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // We are going to pend this IRP
    //
    IoMarkIrpPending( Irp );

    //
    // Initialize queuing and state information.
    //
    InitializeListHead (&AFD_GET_TPIC(Irp)->EndpQueueEntry);
    AFD_GET_TPIC(Irp)->ReferenceCount = 1;
    AFD_GET_TPIC(Irp)->StateFlags = AFD_TP_WORKER_SCHEDULED;

    irpQueued = (InterlockedCompareExchangePointer ((PVOID *)&endpoint->Irp,
                                                Irp,
                                                NULL)!=NULL) &&
                AfdEnqueueTPacketsIrp (endpoint, Irp);


    //
    // If disconnect is not specified, end state change.
    // This will permit queuing of another transmit IRP
    //
    if (!(IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT)) {
        AFD_END_STATE_CHANGE (endpoint);
    }

    IoSetCancelRoutine( Irp, AfdCancelTPackets );

    //
    //  Check to see if this Irp has been cancelled.
    //

    if ( !Irp->Cancel ) {
        if (irpQueued) {
            DEREFERENCE_TPACKETS (Irp);
        }
        else {
            //
            // Determine if we can really start this file transmit now. If we've
            // exceeded the configured maximum number of active TransmitFile/Packets
            // requests, then append this IRP to the TransmitFile/Packets queue 
            // and set a flag in the transmit info structure to indicate that 
            // this IRP is queued.
            //
            if( AfdMaxActiveTransmitFileCount == 0 || 
                    !AfdQueueTransmit (Irp)) {
                    //
                    // Start I/O
                    //
                    AfdTPacketsWorker (Irp);
            }
        }
    }
    else {
        //
        // Abort the request
        // Note that neither cancel nor endpoint cleanup can complete 
        // the IRP since we hold the reference to the tpInfo structure.
        //
        AfdAbortTPackets (Irp, STATUS_CANCELLED);
        
        //
        // Remove the initial reference and force completion.
        //
        DEREFERENCE_TPACKETS (Irp);
    }

    return STATUS_PENDING;


complete_state_change:

    ASSERT ( endpoint->Irp != Irp );
    AFD_END_STATE_CHANGE (endpoint);


    if (tpInfo!=NULL) {
        //
        // AfdReturnTpInfo will dereference all file objects we
        // managed to reference.
        //
        AfdReturnTpInfo (tpInfo);
    }

complete:
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTransmitPackets: Failing Irp-%p,endpoint-%p,status-%lx\n",
                    Irp,endpoint,status));
    }
    //
    // Complete the request.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;
}

#ifdef _WIN64
NTSTATUS
AfdTransmitPackets32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PAFD_TPACKETS_INFO_INTERNAL *TpInfo
    )

/*++

Routine Description:

    32-bit thunk.
    Initial entrypoint for handling transmit packets IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT       endpoint;
    NTSTATUS            status = STATUS_SUCCESS;
    AFD_TPACKETS_INFO32 params;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = NULL;


    PAGED_CODE ();

    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(AFD_TPACKETS_INFO32) ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Because we're using type 3 (neither) I/O for this IRP, the I/O
    // system does no verification on the user buffer.  Therefore, we
    // must manually check it for validity inside a try-except block.
    // We also leverage the try-except to validate and lock down the
    // head and/or tail buffers specified by the caller.
    //

    try {
        PFILE_OBJECT        fileObject;
        HANDLE              fileHandle;
        ULONG               lastSmallBuffer, currentLength, xLength;
        ULONG               maxPacketSize;

        if( Irp->RequestorMode != KernelMode ) {

            //
            // Validate the control buffer.
            //

            ProbeForRead(
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                sizeof (AFD_TPACKETS_INFO32),
                PROBE_ALIGNMENT32 (AFD_TPACKETS_INFO32)
                );

        }


        params = *((PAFD_TPACKETS_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        
        //
        // Validate any flags specified in the request.
        //

        if ( ((params.Flags &
                 ~(AFD_TF_WRITE_BEHIND |
                            AFD_TF_DISCONNECT |
                            AFD_TF_REUSE_SOCKET |
                            AFD_TF_WORKER_KIND_MASK) )
                        != 0 )
                    ||
             ((params.Flags & AFD_TF_WORKER_KIND_MASK) 
                        == AFD_TF_WORKER_KIND_MASK)
                    ||

             (endpoint->Type==AfdBlockTypeDatagram &&
                 (params.Flags & (AFD_TF_DISCONNECT |
                                    AFD_TF_REUSE_SOCKET))
                        !=0) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Protect from overflow
        //
        if ((params.ElementArray==NULL) || 
                (params.ElementCount==0) ||
                (params.ElementCount>(MAXULONG/sizeof (params.ElementArray[0])))) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // If transmit worker is not specified, use system default setting
        //
        if ((params.Flags & AFD_TF_WORKER_KIND_MASK)==AFD_TF_USE_DEFAULT_WORKER) {
            params.Flags |= AfdDefaultTransmitWorker;
        }

        //
        // Allocate tpackets info for the request
        //
        tpInfo = AfdGetTpInfo (params.ElementCount);
        if (tpInfo==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        tpInfo->SendPacketLength = params.SendSize;
        if (tpInfo->SendPacketLength==0)
            tpInfo->SendPacketLength = AfdTransmitIoLength;
        //
        // Probe and copy/walk the array of the elements to transmit.
        //

        if( Irp->RequestorMode != KernelMode ) {
            ProbeForRead(
                params.ElementArray,
                sizeof (TRANSMIT_PACKETS_ELEMENT32)*params.ElementCount,
                PROBE_ALIGNMENT32 (TRANSMIT_PACKETS_ELEMENT32)
                );
        }

        lastSmallBuffer = 0;
        currentLength = 0;
        fileHandle = NULL;
        xLength = 0;
        tpInfo->RemainingPkts = 0;
        maxPacketSize = 0;
        for (tpInfo->ElementCount=0; 
                    tpInfo->ElementCount<params.ElementCount; 
                    tpInfo->ElementCount++) {
            PAFD_TRANSMIT_PACKETS_ELEMENT  pel;
            pel = &tpInfo->ElementArray[tpInfo->ElementCount];
            pel->Flags = params.ElementArray[tpInfo->ElementCount].dwElFlags;
            if ( ((pel->Flags & (~(TP_MEMORY|TP_FILE|TP_EOP)))!=0) ||
                    ((pel->Flags & (TP_MEMORY|TP_FILE))
                                            ==(TP_MEMORY|TP_FILE)) ||
                    ((pel->Flags & (TP_MEMORY|TP_FILE))==0) ) {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            pel->Length = params.ElementArray[tpInfo->ElementCount].cLength;
            if (pel->Flags & TP_FILE) {
                HANDLE  hFile = params.ElementArray[tpInfo->ElementCount].hFile;


                //
                // Check if we already cached the file object
                //
                if (fileHandle==NULL || hFile!=fileHandle) {
                    //
                    // Get a referenced pointer to the file object 
                    // for the file that we're going to transmit.  This call 
                    // will fail if the file handle specified by the caller 
                    // is invalid.
                    //

                    status = ObReferenceObjectByHandle(
                                 hFile,
                                 FILE_READ_DATA,
                                 *IoFileObjectType,
                                 Irp->RequestorMode,
                                 (PVOID *)&fileObject,
                                 NULL
                                 );
                    if ( !NT_SUCCESS(status) ) {
                        //
                        // Tell the caller that we encountered an error
                        // when accessing file not socket.
                        //
                        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                            if (Irp->RequestorMode != KernelMode) {
                                ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                            }
                            else {
                                *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                            }
                        }
                        goto complete;
                    }
                }
                else {
                    //
                    // Use our 1-element file info cache.
                    //
                    ObReferenceObject (fileObject);
                }
                AfdRecordFileRef();

                //
                // Save the file object instead of handle.
                //
                pel->FileObject = fileObject;

                pel->FileOffset = params.ElementArray[
                                        tpInfo->ElementCount].nFileOffset;

                if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) &&
                         (pel->FileOffset.QuadPart == 0) ) {
                    //
                    // Use current offset if file is opened syncronously
                    // and offset is not specified.
                    //

                    pel->FileOffset = fileObject->CurrentByteOffset;
                }

                if ( pel->Length == 0 ) {
                    //
                    // Length was not specified, figure out the
                    // size of the entire file
                    //

                    FILE_STANDARD_INFORMATION fileInfo;
                    IO_STATUS_BLOCK ioStatusBlock;

                    status = ZwQueryInformationFile(
                                 hFile,
                                 &ioStatusBlock,
                                 &fileInfo,
                                 sizeof(fileInfo),
                                 FileStandardInformation
                                 );
                    if ( !NT_SUCCESS(status) ) {
                        //
                        // Bump element count so that file object
                        // is dereferenced in cleanup
                        //
                        tpInfo->ElementCount += 1;
                        //
                        // Tell the caller that we encountered an error
                        // when accessing file not socket.
                        //
                        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                            if (Irp->RequestorMode != KernelMode) {
                                ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                            }
                            else {
                                *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                            }
                        }
                        goto complete;
                    }

                    //
                    // Make sure that offset is within the file
                    //
                    if (pel->FileOffset.QuadPart < 0
                                        ||
                            pel->FileOffset.QuadPart > fileInfo.EndOfFile.QuadPart
                                        ||
                                (fileInfo.EndOfFile.QuadPart - 
                                        pel->FileOffset.QuadPart > MAXLONG)) {
                        //
                        // Bump element count so that file object
                        // is dereferenced in cleanup
                        //
                        tpInfo->ElementCount += 1;
                        status = STATUS_INVALID_PARAMETER;
                        goto complete;

                    }
                    pel->Length = (ULONG)(fileInfo.EndOfFile.QuadPart - 
                                                pel->FileOffset.QuadPart);
                }
                else if (pel->FileOffset.QuadPart<0) {
                    //
                    // Bump element count so that file object
                    // is dereferenced in cleanup
                    //
                    tpInfo->ElementCount += 1;
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }
                //
                // Update our 1-element file information cache
                //
                fileHandle = hFile;

            }
            else {
                ASSERT (pel->Flags & TP_MEMORY);
                //
                // For memory object just save the buffer pointer 
                // (length is saved above), we'll probe and lock/copy
                // the data as we send it.
                //
                pel->Buffer = params.ElementArray[
                                        tpInfo->ElementCount].pBuffer;

                if (pel->Length<=AfdTPacketsCopyThreshold) {
                    if (lastSmallBuffer!=0 &&
                            (lastSmallBuffer+=pel->Length) <= AfdTPacketsCopyThreshold &&
                            (currentLength+lastSmallBuffer) <= tpInfo->SendPacketLength) {
                        (pel-1)->Flags |= TP_COMBINE;
                    }
                    else
                        lastSmallBuffer = pel->Length;
                    if (!(pel->Flags & TP_EOP))
                        goto NoBufferReset;
                }

            }
            lastSmallBuffer = 0;

        NoBufferReset:
            if (pel->Flags & TP_EOP) {
                currentLength = 0;
            }
            else {
                currentLength = (currentLength+pel->Length)%tpInfo->SendPacketLength;
            }

            //
            // Compute the total number of packets that we will send.
            // This is necessary so that once we are close to the end
            // we can buffer the remaining data and stop processing
            // early.
            //
            if (tpInfo->RemainingPkts!=MAXULONG) {
                ULONG   n;
                ULONGLONG x;
                //
                // Add length of the element to data left from the 
                // previous one.
                //
                x = xLength + pel->Length;

                //
                // Compute total number of packets pased on max packet
                // length.
                //
                n = tpInfo->RemainingPkts + (ULONG)(xLength/tpInfo->SendPacketLength);

                //
                // Compute the length of the last incomplete packet to
                // be combined with the next element.
                //
                xLength = (ULONG)(x%tpInfo->SendPacketLength);

                //
                // Compute the max size of the packet
                //
                if (x>tpInfo->SendPacketLength)
                    maxPacketSize = tpInfo->SendPacketLength; // This is absolute max.
                else if (maxPacketSize<xLength)
                    maxPacketSize = xLength;

                if (n>=tpInfo->RemainingPkts && n<MAXULONG) {
                    tpInfo->RemainingPkts = n;
                    if (pel->Flags & TP_EOP) {
                        if (xLength!=0 || pel->Length==0) {
                            tpInfo->RemainingPkts += 1;
                            xLength = 0;
                        }
                    }
                }
                else {
                    tpInfo->RemainingPkts = MAXULONG;
                }
            }
        }

        if (maxPacketSize==0) {
            maxPacketSize = tpInfo->SendPacketLength;
        }

        //
        // Compute the total number of IRPS to use based
        // on SO_SNDBUF setting and maximum packet size
        // (we do not want to buffer more than SO_SNDBUF).
        //
        {
            ULONG   maxSendBytes, irpCount;
            if (endpoint->Type==AfdBlockTypeVcConnecting) {
                maxSendBytes = endpoint->Common.VcConnecting.Connection->MaxBufferredSendBytes;
            }
            else {
                ASSERT (endpoint->Type==AfdBlockTypeDatagram);
                maxSendBytes = endpoint->Common.Datagram.MaxBufferredSendBytes;
            }

            irpCount = maxSendBytes/maxPacketSize;
            if (irpCount>AFD_TP_MIN_SEND_IRPS) {
                if (irpCount>AFD_TP_MAX_SEND_IRPS) {
                    tpInfo->NumSendIrps = AFD_TP_MAX_SEND_IRPS;
                }
                else {
                    tpInfo->NumSendIrps = (USHORT)irpCount;
                }
            }
        }
        //
        // Initialize flags.
        //
        IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags = params.Flags;

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto complete;
    }

complete:

    *TpInfo = tpInfo;
    return status;
}

#endif //_WIN64


VOID
AfdTPacketsWorker (
    PVOID   Context
    )
/*++

Routine Description:

    Transmit packet engine
    Scheduled as system work item or kernel APC
Arguments:

    Context - pointer to TransmitPackets info for the request

Return Value:

    None.

--*/

{
    PIRP                         TpIrp = Context;
    PAFD_TPACKETS_INFO_INTERNAL  tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    NTSTATUS      status;
    LONG          iteration = 0;
    
    PAGED_CODE ();

#if AFD_PERF_DBG
    tpInfo->WorkersExecuted += 1;
#endif
    UPDATE_TPACKETS2 (TpIrp, "Enter TPWorker, next element: %ld", tpInfo->NextElement);
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsWorker:"
                    " Entering for endpoint-%p,tp_info-%p,elem-%d\n",
                    IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext,
                    tpInfo,tpInfo->NextElement));
    }

    //
    // Continue while we have more elements to transmit or something to free
    //
    do {
        PAFD_BUFFER_HEADER  pd;

        //
        // Check if we need to release packet chain that was already sent.
        //
        if ((tpInfo->HeadMdl!=NULL) && (tpInfo->TailMdl==&tpInfo->HeadMdl)) {
            AfdCleanupPacketChain (TpIrp, TRUE);
        }

        //
        // Check if we are done.
        //
        if (tpInfo->NextElement>=tpInfo->ElementCount) {
            //
            // Handle special case of using TransmitFile to just disconnect
            // (and possibly reuse) the socket.
            //
            if (tpInfo->ElementCount==0) {
                PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(TpIrp);
                PAFD_ENDPOINT endpoint = irpSp->FileObject->FsContext;
                if (irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT) {
                    ASSERT (endpoint->Type==AfdBlockTypeVcConnecting);
                    ASSERT (endpoint->Common.VcConnecting.Connection!=NULL);

                    status = AfdBeginDisconnect(
                              endpoint,
                              NULL,
                              NULL
                              );
                    if (NT_SUCCESS (status)) {
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdTPacketsWorker: Initiated disconnect, tpInfo-%p,status-%lx\n",
                                        tpInfo, status));
                        }
                        //
                        // Return pending to exit the worker
                        // and complete the request.
                        //
                        status = STATUS_PENDING;
                    }
                    else {
                        //
                        // Disconnect failed, we'll have to abort below.
                        //
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdTPacketsWorker: tpInfo-%p, begin discon failed: %lx\n",
                                        tpInfo, status));
                        }
                    }
                }
                else {
                    //
                    // Well, no disconnect and nothing to transmit.
                    // Why were called at all?  We'll have to handle this anyway.
                    //
                    AfdStartNextTPacketsIrp (endpoint, TpIrp);
                    status = STATUS_PENDING;
                }
            }
            else {
                status = STATUS_PENDING;
            }
            break;
        }

        //
        // Start building new chain
        //

        status = AfdBuildPacketChain (TpIrp, &pd);

        if (status==STATUS_SUCCESS) {
            USHORT    sendIrp;
            //
            // New chain is ready, find and IRP to send it
            //
            sendIrp = AfdTPacketsFindSendIrp (TpIrp);

            if (sendIrp!=tpInfo->NumSendIrps) {
                //
                // Found send IRP, perform send and continue.
                //
                status = AfdTPacketsSend (TpIrp, sendIrp);
            }
            else {
                //
                // Exit worker waiting for sends to complete.
                //
                status = STATUS_PENDING;
            }
        }
        else if (status==STATUS_PENDING) {
            //
            // Need to perform a read.
            // If read complete in-line, success is returned,
            // otherwise, we'll get STATUS_PENDING or error
            //
            if (AFD_USE_CACHE (pd->FileObject)) {
                status = AfdTPacketsMdlRead (TpIrp, pd);
            }
            else {
                status = AfdTPacketsBufferRead (TpIrp, pd);
            }
        }
        //
        // Continue while everything completes in-line with success
        // Limit number of iterations if we are at APC level.
        //
    }
    while (status==STATUS_SUCCESS && iteration++<tpInfo->NumSendIrps);

    if (NT_SUCCESS (status)) {
        if (status==STATUS_SUCCESS) {
            //
            // Exceeded number of iterations.
            // Reschedule the APC. Transfer the reference to the
            // worker.
            //
            ASSERT (iteration==tpInfo->NumSendIrps+1);
            ASSERT (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);
            UPDATE_TPACKETS2 (TpIrp, "Rescheduling tp worker, NextElement: %ld",
                                        tpInfo->NextElement);
            AfdStartTPacketsWorker (AfdTPacketsWorker, TpIrp);
            return;
        }
        else {
            ASSERT (status==STATUS_PENDING);
        }
    }
    else {
        //
        // Something failed, abort.
        //
        AfdAbortTPackets (TpIrp, status);
    }

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsWorker:"
                    " Exiting for endpoint-%p,tp_info-%p,elem-%d\n",
                    IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext,
                    tpInfo,tpInfo->NextElement));
    }
    //
    // Remove the reference added when we scheduled the worker.
    //
    DEREFERENCE_TPACKETS (TpIrp);
}


NTSTATUS
AfdBuildPacketChain (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  *Pd
    )
/*++

Routine Description:

    Builds MDL chain for a packet using packet descriptors.

Arguments:

    TpIrp - transmit packets IRP
Return Value:

    STATUS_SUCCESS - packet is fully built
    STATUS_PENDING - file read is required
    other - failure.
--*/
{
    NTSTATUS    status = STATUS_MORE_PROCESSING_REQUIRED;
    BOOLEAN     attached = FALSE;
    PAFD_TPACKETS_INFO_INTERNAL        tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PAFD_ENDPOINT   endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;
    PAFD_TRANSMIT_PACKETS_ELEMENT   combinePel = NULL;
    ULONG                           combineLen = 0;

    //
    // Either we have something built or both MDL and PD are empty
    //
    ASSERT (tpInfo->PdLength>0 || 
                ((tpInfo->HeadMdl==NULL || tpInfo->HeadMdl->ByteCount==0)
                    && (tpInfo->HeadPd==NULL || tpInfo->HeadPd->DataLength==0)) );

    //
    // Continue while we haven't got a complet packet and
    // have elements to process
    //
    while (status==STATUS_MORE_PROCESSING_REQUIRED) {
        PAFD_TRANSMIT_PACKETS_ELEMENT   pel;
        PMDL    mdl;
        ULONG   length;

        //
        // Get next element to process
        //
        pel = &tpInfo->ElementArray[tpInfo->NextElement];

        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdBuildPacketChain: tpInfo-%p, pel:%p\n",
                        tpInfo, pel));
        }
        //
        // Snag the element length
        //

        length = pel->Length;
        if (length+tpInfo->PdLength>tpInfo->SendPacketLength) {
            //
            // We hit packet length limit, take what we can
            //
            length = tpInfo->SendPacketLength-tpInfo->PdLength;
            //
            // Indicate that we are done
            //
            status = STATUS_SUCCESS;
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdBuildPacketChain:"
                            " tpInfo-%p, exceeded send length(%ld)\n",
                            tpInfo, tpInfo->SendPacketLength));
            }
        }
        else {
            //
            // We are finished with the current element. We will consume it
            // (or fail), go to the next one 
            //
            tpInfo->NextElement += 1;

            //
            // Check for a complete packet or manual packetization flag set 
            // by the application or just end of element array
            //
            if ((length+tpInfo->PdLength==tpInfo->SendPacketLength) || 
                            (pel->Flags & TP_EOP) || 
                            (tpInfo->NextElement>=tpInfo->ElementCount)) {
                status = STATUS_SUCCESS;
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdBuildPacketChain:"
                                " tpInfo-%p, full length, EOP, or last %ld\n",
                                tpInfo, tpInfo->NextElement));
                }
            }
        }

        //
        // Adjust the remaining lenght of data in the current element
        // and the length of the packet that we are building.
        //
        pel->Length -= length;
        tpInfo->PdLength += length;

        if (length==0) {
            tpInfo->PdNeedsPps = TRUE;  // Don't have a buffer to get an IRP from.
            mdl = IoAllocateMdl (tpInfo, 1, FALSE, FALSE, NULL);
            if (mdl==NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            MmBuildMdlForNonPagedPool( mdl );
            mdl->ByteCount = 0;
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdBuildPacketChain:"
                            " tpInfo-%p, 0-length MDL %p\n",
                            tpInfo,mdl));
            }
            //
            // Insert MDL into the MDL chain
            //
            *(tpInfo->TailMdl) = mdl;
            tpInfo->TailMdl = &(mdl->Next);
        }
        else if (pel->Flags & TP_MEMORY) {
            //
            // Memory block processing
            //
            if (pel->Flags & TP_MDL) {
                tpInfo->PdNeedsPps = TRUE;  // Need to make sure that process
                                            // memory is there until send completes.
                //
                // This a pre-built MDL (TransmitFile header or trailer buffer)
                //
                if (pel->Mdl->ByteCount==length) {
                    mdl = pel->Mdl;
                    pel->Mdl = NULL;
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tpInfo-%p, pre-built mdl-%p(%lx)\n",
                                    tpInfo, mdl, mdl->ByteCount));
                    }
                }
                else {
                    //
                    // We can't send the whole thing at once since it is
                    // bigger than the packet lenght, build partial MDL
                    // for this - it is very unlikely scenario for header
                    // and/or trailer.
                    //
                    mdl = IoAllocateMdl (pel->Buffer, 
                                            length,
                                            FALSE,
                                            FALSE,
                                            NULL);
                    if (mdl==NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    IoBuildPartialMdl(
                        pel->Mdl,
                        mdl,
                        pel->Buffer,
                        length
                        );
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tpInfo-%p, partial mdl %p(%lx)\n",
                                    tpInfo,mdl,mdl->ByteCount));
                    }
                }
            }
            else {

                //
                // If we are not in the context of the process that
                // initiated the request, we will need to attach
                // to it to be able to access the memory.
                //
                if (IoGetCurrentProcess ()!=IoGetRequestorProcess (TpIrp)) {
                    ASSERT (!attached);
                    ASSERT (!KeIsAttachedProcess ());
                    ASSERT (IoGetCurrentIrpStackLocation (TpIrp)->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_USE_SYSTEM_THREAD);

                    KeAttachProcess (
                            PsGetKernelProcess(
                                IoGetRequestorProcess (TpIrp)));
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tp_info-%p,attached to %p\n",
                                    tpInfo,PsGetKernelProcess(
                                                IoGetRequestorProcess (TpIrp))));
                    }
                    //
                    // Set the flag so that we know to detach at exit
                    //
                    attached = TRUE;
                }
                    
                if (length>AfdTPacketsCopyThreshold) {
                    tpInfo->PdNeedsPps = TRUE;  // Need to make sure that process
                                                // memory is there until send completes.
                    //
                    // Memory block is larger than our large (page) 
                    // pre-allocated buffer.
                    // It is better to probe and lock it
                    // First allocate the MDL
                    //
                    mdl = IoAllocateMdl (pel->Buffer,
                                            length,
                                            FALSE, 
                                            TRUE,
                                            NULL);
                    if (mdl==NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tp_info-%p,big mdl-%p(%p,%lx)\n",
                                    tpInfo,mdl,pel->Buffer,length));
                    }


                    //
                    // Probe and lock app's memory
                    //
                    try {
                        MmProbeAndLockPages (mdl,
                                            TpIrp->RequestorMode,
                                            IoReadAccess
                                            );
                    }
                    except (AFD_EXCEPTION_FILTER(&status)) {
                        break;
                   }
                }
                else if (pel->Flags & TP_COMBINE) {
                    //
                    // This memory can be combined with the
                    // next piece in one buffer.
                    //
                    if (combinePel==NULL) {
                        combinePel = pel;
                        combineLen = length;
                    }
                    else {
                        combineLen += length;
                        ASSERT (combineLen<=AfdTPacketsCopyThreshold);
                    }
                    ASSERT (pel->Length==0);
                    pel->Length = length;
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tp_info-%p,small buffer (%x) to be combined with next\n",
                                    tpInfo,length));
                    }
                    continue;
                }
                else {
                    //
                    // 'Small' memory block, better to copy
                    // into pre-allocated (lookaside list) buffer.
                    //
                    PAFD_BUFFER afdBuffer = NULL;
                    PUCHAR  buf;
                    ULONG   bufferLen = length + (combinePel ? combineLen : 0);

                    try {
                        afdBuffer = AfdGetBufferRaiseOnFailure (
                                                    bufferLen, 
                                                    0,
                                                    endpoint->OwningProcess);
                        buf = afdBuffer->Buffer;
                        if (combinePel!=NULL) {
                            //
                            // See if wee need to combine previous elements
                            //
                            ASSERT (combineLen+length<=AfdTPacketsCopyThreshold);
                            ASSERT (combineLen>0);
                            while (combinePel!=pel) {
                                if ( TpIrp->RequestorMode != KernelMode ) {
                                    //
                                    // Probe before copying
                                    //
                                    ProbeForRead (combinePel->Buffer, 
                                                    combinePel->Length,
                                                    sizeof (UCHAR));
                                }
                                RtlCopyMemory (buf, combinePel->Buffer, combinePel->Length);
                                buf += combinePel->Length;
#if DBG
                                ASSERT (combineLen >= combinePel->Length);
                                combineLen -= combinePel->Length;
#endif
                                combinePel++;
                            }

                            //
                            // Reset the local.
                            //
                            ASSERT (combineLen==0);
                            combinePel = NULL;
                        }

                        if ( TpIrp->RequestorMode != KernelMode ) {
                            //
                            // Probe before copying
                            //
                            ProbeForRead (pel->Buffer, 
                                            length,
                                            sizeof (UCHAR));
                        }
                        RtlCopyMemory (buf, pel->Buffer, length);
                    }
                    except (AFD_EXCEPTION_FILTER (&status)) {
                        if (afdBuffer!=NULL) {
                            AfdReturnBuffer (&afdBuffer->Header, 
                                            endpoint->OwningProcess);
                        }
                        break;
                    }

                    //
                    // Initialize the buffer structure so that we do not
                    // mistake it for file buffer descriptor and insert
                    // it into the packet chain
                    //
                    afdBuffer->FileObject = NULL;
                    afdBuffer->Next = NULL;
                    (*tpInfo->TailPd) = &afdBuffer->Header;
                    tpInfo->TailPd = &(afdBuffer->Next);

                    mdl = afdBuffer->Mdl;
                    //
                    // Adjust MDL length to the amount of data that we
                    // actualy sending from the buffer.
                    //
                    mdl->ByteCount = bufferLen;

                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tp_info-%p,small buffer-%p(%p,%lx)\n",
                                    tpInfo,(PVOID)afdBuffer,mdl,length));
                    }
                }
            }
            //
            // Insert MDL into the MDL chain
            //
            *(tpInfo->TailMdl) = mdl;
            tpInfo->TailMdl = &(mdl->Next);

            //
            // Advance app's buffer pointer
            //
            ((PUCHAR)pel->Buffer) += length;

        }
        else {
            //
            // This must be a file block
            //
            ASSERT ((pel->Flags & TP_FILE)!=0);
            ASSERT (length!=0);

            if (AFD_USE_CACHE (pel->FileObject)) {
                //
                // Caching file system, get it from cache.
                // We just need a buffer tag to save buffer info
                // so we can return it back to the cache when we
                // are done sending.
                //
                IO_STATUS_BLOCK ioStatus;
                PAFD_BUFFER_TAG afdBufferTag;

                tpInfo->PdNeedsPps = TRUE;  // Need to free the MDL back to file
                                            // system at passive/APC level

                try {
                    afdBufferTag = AfdGetBufferTagRaiseOnFailure (
                                        0,
                                        endpoint->OwningProcess);
                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                    break;
                }

                //
                // Copy file parameters to the packet descriptor.
                //
                afdBufferTag->FileOffset = pel->FileOffset;
                afdBufferTag->FileObject = pel->FileObject;
                pel->FileOffset.QuadPart += length;
                afdBufferTag->DataLength = length;

                //
                // Set fileMdl to NULL because FsRtlMdlRead attempts to
                // chain the MDLs it returns off the input MDL variable.
                //
                afdBufferTag->Mdl = NULL;

                //
                // Attempt to use the fast path to get file data MDLs
                // directly from the cache.
                //
                if (FsRtlMdlRead(
                              afdBufferTag->FileObject,
                              &afdBufferTag->FileOffset,
                              length,
                              0,
                              &afdBufferTag->Mdl,
                              &ioStatus
                              )) {
                    if ( ioStatus.Information < length) {
                        //
                        // Could not read the whole thing, must be end of file
                        //
                        status = AfdMdlReadComplete (
                                                    afdBufferTag->FileObject,
                                                    afdBufferTag->Mdl,
                                                    &afdBufferTag->FileOffset);
                        if (NT_SUCCESS (status)) {
                            AfdReturnBuffer (&afdBufferTag->Header, 
                                                endpoint->OwningProcess);
                        }
                        else {
                            REFERENCE_ENDPOINT (endpoint);
                            afdBufferTag->Context = endpoint;
                            AfdLRMdlReadComplete (&afdBufferTag->Header);
                        }
                        status = STATUS_END_OF_FILE;
                        break;
                    }

                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tp_info-%p,file tag-%p(%p,%lx:%I64x)\n",
                                    tpInfo,afdBufferTag,afdBufferTag->Mdl,length,
                                    pel->FileOffset.QuadPart));
                    }
                    //
                    // Insert the file MDL into the chain
                    //
                    mdl = *(tpInfo->TailMdl) = afdBufferTag->Mdl;
                    while (mdl->Next!=NULL)
                        mdl = mdl->Next;
                    tpInfo->TailMdl = &mdl->Next;

                    //
                    // Insert buffer tag into the chain too.
                    //
                    afdBufferTag->Next = NULL;
                    (*tpInfo->TailPd) = &afdBufferTag->Header;
                    tpInfo->TailPd = &(afdBufferTag->Next);
                }
                else {
                    //
                    // File is not in the cache, return STATUS_PENDING
                    // so that the Tpacket worker knows to
                    // perform MDL read via IRP interface
                    //
                    if (status==STATUS_SUCCESS) {
                        afdBufferTag->PartialMessage = FALSE;
                    }
                    else {
                        ASSERT (status==STATUS_MORE_PROCESSING_REQUIRED);
                        afdBufferTag->PartialMessage = TRUE;
                    }
                    afdBufferTag->Next = NULL;
                    *Pd = &afdBufferTag->Header;
                    status = STATUS_PENDING;
                    break;
                }
            }
            else {
                PAFD_BUFFER afdBuffer;

                //
                // Non-cacheable file system, need buffered read.
                // Get the buffer first.
                //

                try {
                    afdBuffer = AfdGetBufferRaiseOnFailure (
                                            length, 
                                            0,
                                            endpoint->OwningProcess);
                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                    break;
                }

                //
                // Copy file parameters to the packet descriptor.
                // and return STATUS_PENDING, so that Tpacket worker knows 
                // to issue an IRP for buffered read.
                //
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdBuildPacketChain:"
                                " tp_info-%p,file buffer-%p(%p,%lx:%I64x)\n",
                                tpInfo,(PVOID)afdBuffer,afdBuffer->Mdl,length,
                                pel->FileOffset.QuadPart));
                }
                afdBuffer->FileOffset = pel->FileOffset;
                afdBuffer->FileObject = pel->FileObject;
                pel->FileOffset.QuadPart += length;
                afdBuffer->DataLength = length;
                afdBuffer->Mdl->ByteCount = length;
                afdBuffer->Next = NULL;
                if (status==STATUS_SUCCESS) {
                    afdBuffer->PartialMessage = FALSE;
                }
                else {
                    ASSERT (status==STATUS_MORE_PROCESSING_REQUIRED);
                    afdBuffer->PartialMessage = TRUE;
                }
                *Pd = &afdBuffer->Header;
                status = STATUS_PENDING;
                break;
            }
        }
    }

    if (attached) {
        //
        // If we attached to the calling, detach before exiting.
        //
        ASSERT (KeIsAttachedProcess ());
        ASSERT (IoGetCurrentIrpStackLocation (TpIrp)->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_USE_SYSTEM_THREAD);
        KeDetachProcess ();
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdBuildPacketChain:"
                        " tp_info-%p, detached\n",
                        tpInfo));
        }
    }

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBuildPacketChain: tp_info-%p,returning %lx\n",
                    tpInfo, status));
    }

    ASSERT (combinePel==NULL || !NT_SUCCESS (status));

    return status;
}

BOOLEAN
AfdCleanupPacketChain (
    PIRP    TpIrp,
    BOOLEAN BelowDispatch
    )
/*++

Routine Description:

    Cleans up (releases all resources in) the packet chain.

Arguments:

    TpIrp - transmit packet IRP
    BelowDispatch  - call is made below DISPATCH_LEVEL, can return MDL to file system

Return Value:

    TRUE - all packets/MDLs are freed
    FALSE - could not return MDLs to file system (when called at DISPATCH)
--*/
{

    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PAFD_BUFFER_HEADER  pd = tpInfo->HeadPd;
    PAFD_ENDPOINT endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;

    ASSERT (tpInfo->HeadMdl!=NULL);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCleanupPacketChain: tp_info-%p,mdl-%p,pd-%p\n",
                    tpInfo,tpInfo->HeadMdl,tpInfo->HeadPd));
    }
    //
    // Continue while we have any MDL's left
    //
    while (tpInfo->HeadMdl) {
        //
        // Advance to the next MDL
        //
        PMDL mdl;

        mdl = tpInfo->HeadMdl;
        tpInfo->HeadMdl = mdl->Next;

        if (pd!=NULL) {
            //
            // We still have descriptors in the chain to compare against.
            //

            if (mdl==pd->Mdl) {
                //
                // This MDL has associated descriptor - file or buffered memory
                // First remove this descriptor from the chain.
                //
                tpInfo->HeadPd = pd->Next;
                if (pd->FileObject!=NULL && AFD_USE_CACHE (pd->FileObject)) {

                    if (BelowDispatch) {
                        //
                        // Cached file, the descriptor is just a tag with info
                        // to return MDL to the cache, do it.
                        //
                        PAFD_BUFFER_TAG afdBufferTag = CONTAINING_RECORD (pd, AFD_BUFFER_TAG, Header);
                        ULONG   size = MmGetMdlByteCount (mdl);
                        PMDL    lastMdl = mdl;
                        NTSTATUS status;
                        //
                        // Scan MDL chain till we find the last one for this file
                        // segment.
                        //
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdCleanupPacketChain:"
                                        " tp_info-%p,file tag-%p(%p,%lx:%I64x)\n",
                                        tpInfo,afdBufferTag,mdl,afdBufferTag->DataLength,
                                        afdBufferTag->FileOffset.QuadPart));
                        }
                        while (size<pd->DataLength) {
                            size += MmGetMdlByteCount (tpInfo->HeadMdl);
                            lastMdl = tpInfo->HeadMdl;
                            tpInfo->HeadMdl = tpInfo->HeadMdl->Next;
                        }
                        lastMdl->Next = NULL;
                        ASSERT (size==pd->DataLength);
                        //
                        // Return the MDL chain to file cache
                        //
                        status = AfdMdlReadComplete (
                                        afdBufferTag->FileObject, 
                                        mdl, 
                                        &afdBufferTag->FileOffset);
                        if (NT_SUCCESS (status)) {
                            //
                            // Success free the corresponding buffer tag
                            //
                            AfdReturnBuffer (pd, endpoint->OwningProcess);
                        }
                        else {
                            //
                            // Failure, queue the descriptor to the low resource
                            // list to be processed by our global timer when
                            // (hopefully) enough memory will be available to do
                            // the work.
                            // We need to reference the endpoint since buffer tag
                            // may have been charged against the process that owns
                            // the endpoint.
                            //
                            REFERENCE_ENDPOINT (endpoint);
                            afdBufferTag->Context = endpoint;
                            AfdLRMdlReadComplete (&afdBufferTag->Header);
                        }
                    }
                    else {
                        //
                        // If we are at dispatch, we can't free MDLs to file
                        // system, return to the caller.
                        //

                        tpInfo->HeadPd = pd;
                        tpInfo->HeadMdl = mdl;

                        return FALSE;
                    }
                }
                else {
                    //
                    // Buffer with either file or memory data, just return
                    // it back to the pool.
                    //
                    PAFD_BUFFER afdBuffer = CONTAINING_RECORD (pd, AFD_BUFFER, Header);

                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdCleanupPacketChain:"
                                    " tp_info-%p,file buffer-%p(%p,%lx:%I64x)\n",
                                    tpInfo,(PVOID)afdBuffer,mdl,afdBuffer->DataLength,
                                    afdBuffer->FileOffset.QuadPart));
                    }
                    afdBuffer->Mdl->Next = NULL;
                    afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
                    AfdReturnBuffer (pd, endpoint->OwningProcess);
                }

                //
                // Move to the next descriptor in the chain.
                //
                pd = tpInfo->HeadPd;
                continue;
            }
        }

        //
        // Stand-alone MDL with memory data
        // Just unlock the pages if they were locked and return it.
        // We never lock memory in partial MDLs, only in their source MDL
        //
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCleanupPacketChain: tp_info-%p, mdl-%p(%p,%x,%x)\n",
                        tpInfo,mdl,
                        MmGetMdlVirtualAddress(mdl),
                        MmGetMdlByteCount (mdl),
                        mdl->MdlFlags));
        }
        mdl->Next = NULL;
        if (mdl->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL) {
            ASSERT (mdl->MappedSystemVa==(PVOID)tpInfo);
            ASSERT (mdl->ByteCount==0);
            mdl->ByteCount = 1;
        }
        else if (mdl->MdlFlags & MDL_PAGES_LOCKED &&
                !(mdl->MdlFlags & MDL_PARTIAL)) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    ASSERT (tpInfo->TailMdl == &tpInfo->HeadMdl);
    ASSERT (tpInfo->HeadPd == NULL);
    ASSERT (tpInfo->TailPd == &tpInfo->HeadPd);

    return TRUE;
}



NTSTATUS
AfdTPacketsSend (
    PIRP    TpIrp,
    USHORT  SendIrp
    )
/*++

Routine Description:

    Takes the packets chain of the TpInfo and sends it.
    Places back the chain sent before, so it can be freed.
    If requested by the app and the last element is being sent,
    initiates the disconnect.

Arguments:

    TpIrp - transmit packet irp
    SendIrp - index of the IRP to use for this send.

Return Value:

    STATUS_SUCCESS - send was queued to the transport OK
    other - send failed
--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    PMDL                    tempMdl=NULL;
    PAFD_BUFFER_HEADER      tempPd=NULL;
    NTSTATUS                status = STATUS_SUCCESS;
    PIRP                    irp, sendIrp=NULL;
    PIO_COMPLETION_ROUTINE  sendCompletion = AfdRestartTPacketsSend; 

    ASSERT (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);

    irp = tpInfo->SendIrp[SendIrp];

    //
    // See if we can use IRP built into the AFD buffer.
    // We do this for last series of the packets only so 
    // we can effectively buffer the data and complete the
    // IRP early.
    //
    if (tpInfo->RemainingPkts!=MAXULONG) {
        tpInfo->RemainingPkts -= 1;

        //
        // The conditions are:
        //  - number of remaining packets is less then total 
        //      outstanding IRPs we can have
        //  - the packet does not need post-processing at below
        //      DPC level and/or in context of the thread/process
        //  - we actually have afd buffer to borrow the IRP.
        //
        if (tpInfo->RemainingPkts < (ULONG)tpInfo->NumSendIrps &&
                !tpInfo->PdNeedsPps &&
                tpInfo->HeadPd!=NULL) {
            PAFD_BUFFER afdBuffer = CONTAINING_RECORD (tpInfo->HeadPd,
                                                        AFD_BUFFER,
                                                        Header);
            ASSERT (afdBuffer->BufferLength!=0);
            ASSERT (afdBuffer->Irp!=NULL);
            sendIrp = afdBuffer->Irp;
            afdBuffer->Context = irpSp->FileObject->FsContext;
            sendCompletion = AfdRestartTPDetachedSend;
            //
            // There will be no completion flag reset - we do not have
            // to wait for this one.
            //
            AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_SEND_COMP_PENDING(SendIrp));
        }
    }

    if (irp!=NULL) {
        //
        // Get the old data from the IRP.
        //
        ASSERT (irp->Overlay.AsynchronousParameters.UserApcRoutine==(PVOID)SendIrp);
        tempPd = irp->Overlay.AsynchronousParameters.UserApcContext;
        tempMdl = irp->MdlAddress;
        if (sendIrp==NULL) {
            //
            // No special send IRP, the data will be reset with
            // data to be sent
            //
            sendIrp = irp;
        }
        else {
            //
            // We are not going to use this IRP, reset data to NULL.
            //
            irp->Overlay.AsynchronousParameters.UserApcContext = NULL;
            irp->MdlAddress = NULL;
        }
    }
    else if (sendIrp==NULL) {
        //
        // We need to allocate an IRP.
        //
        ASSERT (SendIrp>=AFD_TP_MIN_SEND_IRPS);
        tpInfo->SendIrp[SendIrp] = IoAllocateIrp (tpInfo->TdiDeviceObject->StackSize, TRUE);
        if (tpInfo->SendIrp[SendIrp]==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            AfdAbortTPackets (TpIrp, status);
            return status;
        }
        sendIrp = irp = tpInfo->SendIrp[SendIrp];
        irp->Overlay.AsynchronousParameters.UserApcRoutine=(PVOID)SendIrp;
    }

    //
    // Exchange the packet and MDL chains between send IRP and
    // the tpInfo structure
    //
    sendIrp->Overlay.AsynchronousParameters.UserApcContext = tpInfo->HeadPd;

    tpInfo->HeadPd = tempPd;
    tpInfo->TailPd = &tpInfo->HeadPd;


    //
    // Build send IRP.  Used combined send and disconnect if necessary
    // and possible.
    //
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    if ((irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT) &&
            (tpInfo->PdLength>0) && // Must be sending something or no S&D
            (tpInfo->NextElement>=tpInfo->ElementCount) &&
            AfdTPacketsEnableSendAndDisconnect (TpIrp)) {
        AFD_SET_TP_FLAGS (TpIrp, AFD_TP_SEND_AND_DISCONNECT);
        TdiBuildSend (sendIrp,
                tpInfo->TdiDeviceObject,
                tpInfo->TdiFileObject,
                sendCompletion,
                TpIrp,
                tpInfo->HeadMdl,
                TDI_SEND_AND_DISCONNECT,
                tpInfo->PdLength
                );
    }
    else {
        TdiBuildSend (sendIrp,
                tpInfo->TdiDeviceObject,
                tpInfo->TdiFileObject,
                sendCompletion,
                TpIrp,
                tpInfo->HeadMdl,
                0,
                tpInfo->PdLength
                );
    }

#else //TDI_SERVICE_SEND_AND_DISCONNECT

    TdiBuildSend (sendIrp,
            tpInfo->TdiDeviceObject,
            tpInfo->TdiFileObject,
            sendCompletion,
            TpIrp,
            tpInfo->HeadMdl,
            0,
            tpInfo->PdLength
            );
#endif //TDI_SERVICE_SEND_AND_DISCONNECT


    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsSend: tpInfo-%p, sending Irp: %p\n",
                    tpInfo, irp));
    }
    if (sendCompletion==AfdRestartTPacketsSend) {
        //
        // Reference the tpInfo structure so it does not go away
        // till send IRP completes and pass the IRP to the transport.
        //
        REFERENCE_TPACKETS (TpIrp);

        IoCallDriver (tpInfo->TdiDeviceObject, sendIrp);
    }
    else {
        //
        // No need to reference as we are not going to wait for
        // completion.
        //
        status = IoCallDriver (tpInfo->TdiDeviceObject, sendIrp);
        if (NT_SUCCESS (status)) {
            //
            // Change STATUS_PENDING to success not to confuse the caller
            // and add byte count under assumption of success (if it fails
            // later, connection will be dropped and we don't guarantee
            // anything for datagrams anyway).
            //
            status = STATUS_SUCCESS;
#ifdef _WIN64
            InterlockedExchangeAdd64 (
                                &TpIrp->IoStatus.Information,
                                tpInfo->PdLength
                                );
#else //_WIN64
            InterlockedExchangeAdd (
                                &TpIrp->IoStatus.Information,
                                tpInfo->PdLength);
#endif //_WIN64
        }
        else {
            //
            // If send fails, we'll have to abort here since completion routine
            // will not have access to the TpIrp
            //
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdTPacketsSend: tpInfo-%p, detached send failed: %lx\n",
                            tpInfo, status));
            }
            AfdAbortTPackets (TpIrp, status);
        }
    }


    //
    // Setup the chain in the tpInfo so it can be freed.
    //
    tpInfo->HeadMdl = tempMdl;
    tpInfo->TailMdl = &tpInfo->HeadMdl;
    tpInfo->PdLength = 0;
    tpInfo->PdNeedsPps = FALSE;

    if (tpInfo->NextElement>=tpInfo->ElementCount) {
        PAFD_ENDPOINT   endpoint = irpSp->FileObject->FsContext;
        if (!(irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT)) {
            AfdStartNextTPacketsIrp (endpoint, TpIrp);
        }
        else 
            //
            // If necessary and not using combined S&D,
            // sumbit disconnect IRP to the transport
            //
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
            if (!(AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_SEND_AND_DISCONNECT))
#endif // TDI_SERVICE_SEND_AND_DISCONNECT
        {
            ASSERT (endpoint->Type==AfdBlockTypeVcConnecting);
            ASSERT (endpoint->Common.VcConnecting.Connection!=NULL);

            status = AfdBeginDisconnect(
                      endpoint,
                      NULL,
                      NULL
                      );
            if (NT_SUCCESS (status)) {
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdTPacketsSend: Initiated disconnect, tpInfo-%p,status-%lx\n",
                                tpInfo, status));
                }
                //
                // Change STATUS_PENDING to success not to confuse the caller.
                //
                status = STATUS_SUCCESS;
            }
            else {
                //
                // If disconnect fails, we'll have to abort
                //
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdTPacketsSend: tpInfo-%p, begin discon failed: %lx\n",
                                tpInfo, status));
                }
                AfdAbortTPackets (TpIrp, status);
            }
        }
    }

    //
    // Set the flag indicating to the completion routine that we are done
    //
    AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_SEND_CALL_PENDING(SendIrp));
    UPDATE_TPACKETS2 (TpIrp, "Submitted SendIrp: %ld", SendIrp);

    return status;
}


NTSTATUS
AfdRestartTPacketsSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for TPackets send.
    Does another send if packet is ready or schedules worker
    to do the same.
Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - send IRP being completed
    Context      - TpIrp

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PIRP    tpIrp;
    PAFD_TPACKETS_INFO_INTERNAL  tpInfo;
    PAFD_ENDPOINT   endpoint;
    USHORT          sendIrp;

    tpIrp = Context;
    tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    endpoint = IoGetCurrentIrpStackLocation (tpIrp)->FileObject->FsContext;

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Figure out which IRP is being completed.
    //
    sendIrp = (USHORT)Irp->Overlay.AsynchronousParameters.UserApcRoutine;
    ASSERT (tpInfo->SendIrp[sendIrp]==Irp);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPacketsSend: tp_info-%p,Irp-%p,status-%lx\n",
                tpInfo,
                Irp,
                Irp->IoStatus.Status
                ));
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        LONG    stateFlags, newStateFlags;
        BOOLEAN needWorker;

        UPDATE_TPACKETS2 (tpIrp, "Send completed with 0x%lX bytes", 
                                    (ULONG)Irp->IoStatus.Information);
        //
        // Successfull completion, update transfer count.
        // We don't hold the spinlock, so we need to use interlocked operation.
        // Wish we have a common one for both 64 and 32 bit platforms.
        //
#ifdef _WIN64
        InterlockedExchangeAdd64 (
                            &tpIrp->IoStatus.Information,
                            Irp->IoStatus.Information);
#else //_WIN64
        InterlockedExchangeAdd (&tpIrp->IoStatus.Information,
                                    Irp->IoStatus.Information);
#endif //_WIN64
        //
        // See if dispatch routine completed already and
        // the request is not aborted or worker is aready running
        //

        do {
            ULONG   sendMask;
            newStateFlags = stateFlags = AFD_GET_TPIC(tpIrp)->StateFlags;
            if (    (newStateFlags & (AFD_TP_ABORT_PENDING | 
                                      AFD_TP_WORKER_SCHEDULED |
                                      AFD_TP_SEND_CALL_PENDING(sendIrp))) ||
                    ((sendMask = (newStateFlags & AFD_TP_SEND_MASK)) &
                                     ( (sendMask>>2) |
                                       (sendMask<<(AFD_TP_MAX_SEND_IRPS*2-2)) ) )
                                       ) {

                //
                // Can't continue, just clear completion flag
                //
                newStateFlags &= ~AFD_TP_SEND_COMP_PENDING(sendIrp);
                needWorker = FALSE;
            }
            else {
                //
                // Take control over worker scheduling and
                // mark IRP as busy.
                // 
                needWorker = TRUE;
                newStateFlags |= AFD_TP_WORKER_SCHEDULED;
                if (tpInfo->HeadMdl!=NULL) {
                    newStateFlags |= AFD_TP_SEND_CALL_PENDING(sendIrp);
                }
                else {
                    newStateFlags &= ~AFD_TP_SEND_COMP_PENDING(sendIrp);
                }
            }

        }
        while (InterlockedCompareExchange (
                        (PLONG)&AFD_GET_TPIC(tpIrp)->StateFlags,
                        newStateFlags,
                        stateFlags)!=stateFlags);
        if (needWorker) {
            //
            // We can do processing here, see if there is something to send
            //
            if (tpInfo->HeadMdl) {
                //
                // Yes, do it
                //
                AfdTPacketsSend (tpIrp, sendIrp);
            }
            //
            // Start worker to prepare new stuff/free what we sent before.
            // We transfer the reference we added when we queued the request
            // to the worker.
            //
            AfdStartTPacketsWorker (AfdTPacketsWorker, tpIrp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else {
            //
            // Worker was already running or request aborted or dispatch
            // routine not completed yet.
            //
        }
    }
    else {
        //
        // Failure, abort the request even if dispatch did not complete.
        // We do not know if dispatch routine is going to return error status,
        // it may just return STATUS_PENDING and we then loose the error code.
        // Double abort is harmless.
        //
        AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_SEND_COMP_PENDING(sendIrp));
        AfdAbortTPackets (tpIrp, Irp->IoStatus.Status);
    }

    //
    // Remove the reference we added when we queued the request.
    //
    DEREFERENCE_TPACKETS (tpIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AfdRestartTPDetachedSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for detached TPackets send.
    Just frees the buffers.

Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - send IRP being completed
    Context      - Ignore (TpIrp is stored for debugging purposes only).

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PAFD_BUFFER     afdBuffer = Irp->Overlay.AsynchronousParameters.UserApcContext;
    PAFD_ENDPOINT   endpoint = afdBuffer->Context;

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPDetachedSend: Irp-%p,status-%lx\n",
                Irp,
                Irp->IoStatus.Status
                ));
    }

    do {
        PAFD_BUFFER tempBuffer = afdBuffer;
        afdBuffer = CONTAINING_RECORD (afdBuffer->Next, AFD_BUFFER, Header);
        tempBuffer->Next = NULL;
        tempBuffer->Mdl->Next = NULL;
        tempBuffer->Mdl->ByteCount = tempBuffer->BufferLength;
        AfdReturnBuffer (&tempBuffer->Header, endpoint->OwningProcess);
    }
    while (afdBuffer!=NULL);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


USHORT
AfdTPacketsFindSendIrp (
    PIRP            TpIrp
    )
/*++

Routine Description:
    Finds the send IRP that is not currently in use and marks
    it as busy
Arguments:
    TpIrp      - Transmit packets Irp

Return Value:
    0-based index of send irp or TpInfo->NumSendIrps if all IRPs are i use
--*/
{

    LONG    stateFlags, newStateFlags;
    USHORT    sendIrp;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;

    ASSERT( AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED );

    do {
        newStateFlags = stateFlags = AFD_GET_TPIC(TpIrp)->StateFlags;
        if (newStateFlags & AFD_TP_ABORT_PENDING) {
            //
            // Abort is in progress, bail
            //
            sendIrp = tpInfo->NumSendIrps;
            break;
        }

        //
        // See if any send IRP is not in use
        //
        for (sendIrp=0; sendIrp<tpInfo->NumSendIrps; sendIrp++) {
            if ((newStateFlags & AFD_TP_SEND_BUSY(sendIrp))==0) {
                break;
            }
        }

        if (sendIrp!=tpInfo->NumSendIrps) {
            //
            // Found send IRP, mark it as busy
            //
            newStateFlags |= AFD_TP_SEND_BUSY(sendIrp);
        }
        else {
            //
            // No send IRPs, suspend the worker.
            //
            newStateFlags &= (~AFD_TP_WORKER_SCHEDULED);
        }
    }
    while (InterlockedCompareExchange (
                    (PLONG)&AFD_GET_TPIC(TpIrp)->StateFlags,
                    newStateFlags,
                    stateFlags)!=stateFlags);

    return sendIrp;
}


NTSTATUS
AfdTPacketsMdlRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    )
/*++

Routine Description:

    Performs IRP based MDL read (invoked when cache read fails).

Arguments:

    TpIrp  - transmit packet irp
    Pd     - descriptor with file parameters for the read

Return Value:

    STATUS_SUCCESS - read was completed in-line
    STATUS_PENDING - read was queued to file system driver, 
                    will complete lated
    other - read failed
--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PDEVICE_OBJECT          deviceObject;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;

    ASSERT( AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED );

    //
    // Find the device object and allocate IRP of appropriate size
    // if current one does not fit or is not available at all.
    //
    deviceObject = IoGetRelatedDeviceObject (Pd->FileObject);
    if ((tpInfo->ReadIrp==NULL) ||
            (tpInfo->ReadIrp->StackCount<deviceObject->StackSize)) {
        if (tpInfo->ReadIrp!=NULL) {
            IoFreeIrp (tpInfo->ReadIrp);
        }

        tpInfo->ReadIrp = IoAllocateIrp (deviceObject->StackSize, FALSE);
        if (tpInfo->ReadIrp==NULL) {
            PAFD_ENDPOINT   endpoint;
            endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;
            ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
            AfdReturnBuffer (Pd, endpoint->OwningProcess);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Mark IRP as busy and set it up
    //
    AFD_SET_TP_FLAGS (TpIrp, AFD_TP_READ_BUSY);

    irp = tpInfo->ReadIrp;


    irp->MdlAddress = NULL;

    //
    // Set the synchronous flag in the IRP to tell the file system
    // that we are aware of the fact that this IRP will be completed
    // synchronously.  This means that we must supply our own thread
    // for the operation and that the disk read will occur
    // synchronously in this thread if the data is not cached.
    //

    irp->Flags |= IRP_SYNCHRONOUS_API;


    irp->Overlay.AsynchronousParameters.UserApcContext = Pd;
    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread ();

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = IRP_MN_MDL;
    irpSp->FileObject = Pd->FileObject;
    irpSp->DeviceObject = deviceObject;

    IoSetCompletionRoutine(
        irp,
        AfdRestartTPacketsMdlRead,
        TpIrp,
        TRUE,
        TRUE,
        TRUE
        );

    ASSERT( irpSp->Parameters.Read.Key == 0 );

    //
    // Finish building the read IRP.
    //

    irpSp->Parameters.Read.Length = Pd->DataLength;
    irpSp->Parameters.Read.ByteOffset = Pd->FileOffset;
    
    REFERENCE_TPACKETS (TpIrp);
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdTPacketsMdlRead: tp_info-%p,Irp-%p,file-%pd,offset-%I64x,length-%lx\n",
                tpInfo,
                irp,
                Pd->FileObject,
                Pd->FileOffset.QuadPart,
                Pd->DataLength));
    }

    IoCallDriver (deviceObject, irp);

    if (((AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_READ_CALL_PENDING)
                                    & (AFD_TP_READ_COMP_PENDING|AFD_TP_ABORT_PENDING))==0) && 
                    NT_SUCCESS (irp->IoStatus.Status) &&
                    AfdTPacketsContinueAfterRead (TpIrp)) {
        //
        // Read completed successfully inline and post-processing was successfull,
        // tell the worker to go on.
        //
        UPDATE_TPACKETS2 (TpIrp, "MdlRead completed inline with 0x%lX bytes", 
                                    (ULONG)irp->IoStatus.Information);
        return STATUS_SUCCESS;
    }
    else {
        //
        // Read has not completed yet or post processing failed,
        // worker should bail and we will continue when read completes
        // or in final completion routine (AfdCompleteTPackets).
        //
        return STATUS_PENDING;
    }
}

NTSTATUS
AfdRestartTPacketsMdlRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for IRP based MDL read.
    Does another send if packet is ready or schedules worker
    to do the same.
Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - read IRP being completed
    Context      - TpIrp

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PIRP    tpIrp = Context;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    PAFD_ENDPOINT   endpoint;
    PAFD_BUFFER_HEADER  pd;

    endpoint = IoGetCurrentIrpStackLocation (tpIrp)->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT (AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);
    ASSERT (tpInfo->ReadIrp == Irp);

    pd = Irp->Overlay.AsynchronousParameters.UserApcContext;


    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPacketsMdlRead:"
                " tp_info-%p,Irp-%p,status-%lx,length-%p,mdl-%p\n",
                tpInfo,
                Irp,
                Irp->IoStatus.Status,
                Irp->IoStatus.Information,
                Irp->MdlAddress));
    }

    //
    // Insert MDL into the current chain.
    //
    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        PMDL mdl = *(tpInfo->TailMdl) = Irp->MdlAddress;
        while (mdl->Next!=NULL)
            mdl = mdl->Next;        
        tpInfo->TailMdl = &mdl->Next;

        pd->Mdl = Irp->MdlAddress;


        //
        // If FS driver hits EOF, it will still return
        // success to us and we need to handle this case.
        //
        if (pd->DataLength==Irp->IoStatus.Information) {

            (*tpInfo->TailPd) = pd;
            tpInfo->TailPd = &(pd->Next);

            Irp->MdlAddress = NULL;

            if (((AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_READ_COMP_PENDING)
                                        & (AFD_TP_READ_CALL_PENDING|AFD_TP_ABORT_PENDING))==0) &&
                        AfdTPacketsContinueAfterRead (tpIrp)) {
                //
                // Read dispatch has already returned and post-processing 
                // was successfull, schedule the worker to continue processing
                // We transfer the reference that we added when we queued the
                // read to the worker.
                //
        
                UPDATE_TPACKETS2 (tpIrp, "MdlRead completed in restart with 0x%lX bytes",
                                        (ULONG)Irp->IoStatus.Information);
                AfdStartTPacketsWorker (AfdTPacketsWorker, tpIrp);
            }
            else {
                DEREFERENCE_TPACKETS (tpIrp);
            }
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        //
        // FS driver read less than we expected.
        // We must have hit end of file.
        // Save the real packet length so we can cleanup correctly and
        // force abort with STATUS_END_OF_FILE.
        //
        Irp->IoStatus.Status = STATUS_END_OF_FILE;
        pd->DataLength = (ULONG)Irp->IoStatus.Information;
    }
    else {
        ASSERT (Irp->MdlAddress == NULL);
    }
    AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_READ_COMP_PENDING);
    AfdAbortTPackets (tpIrp, Irp->IoStatus.Status);

    if (pd->Mdl==NULL) {
        //
        //  No MDL was returned by the file system.
        //  We can free the packed descriptor immediately.
        //
        AfdReturnBuffer (pd, endpoint->OwningProcess);
    }
    else {
        //
        // File system did return MDL to us.
        // Save the descriptor so the MDL can be
        // properly returned back to the file system
        // by the cleanup routine.
        //
        (*tpInfo->TailPd) = pd;
        tpInfo->TailPd = &(pd->Next);
    }
    DEREFERENCE_TPACKETS (tpIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AfdMdlReadComplete (
    PFILE_OBJECT	FileObject,
    PMDL            FileMdl,
	PLARGE_INTEGER	FileOffset
    )
/*++

Routine Description:
    Returns MDL to the file system / cache manager

Arguments:
    FileObject  - file object from which MDL comes
    FileMdl     - MDL itself
    FileOffset  - offset in the file where MDL data begins

Return Value:

    STATUS_SUCCESS - operation completed immediately
    STATUS_PENDING - request is sumbitted to file system driver
    other - operation failed.
Notes:


--*/
{
    PIRP    irp;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_OBJECT  deviceObject;
    ASSERT (KeGetCurrentIrql()<=APC_LEVEL);

    if( FsRtlMdlReadComplete (
                        FileObject,
                        FileMdl) ) {
        return STATUS_SUCCESS;
    }

    
    //
    // Fast path failed, so create a new IRP.
    //

    deviceObject =  IoGetRelatedDeviceObject (FileObject);
    irp = IoAllocateIrp(
              deviceObject->StackSize,
              FALSE
              );

    if( irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Setup the IRP.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irp->MdlAddress = FileMdl;

    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;

    irpSp->Parameters.Read.Length = 0;
    while (FileMdl!=NULL) {
        irpSp->Parameters.Read.Length += FileMdl->ByteCount;
        FileMdl = FileMdl->Next;
    }

    irpSp->Parameters.Read.ByteOffset = *FileOffset;
    
    irpSp->Parameters.Read.Key = 0;

    //
    // Reference file object so it does not go away till this
    // IRP completes
    //
    ObReferenceObject (FileObject);
    AfdRecordFileRef ();

    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Submit the IRP
    //

    IoSetCompletionRoutine(
        irp,
        AfdRestartMdlReadComplete,
        FileObject,
        TRUE,
        TRUE,
        TRUE
        );

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdMdlReadComplete: file-%p,Irp-%p,offset-%I64x\n",
                FileObject,
                irp,
                FileOffset->QuadPart));
    }
    IoCallDriver (deviceObject, irp);

    return STATUS_PENDING;
}


NTSTATUS
AfdRestartMdlReadComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Completion routine for IRPs issued by AfdMdlReadComplete. The only
    purpose of this completion routine is to free the IRPs created by
    AfdMdlReadComplete() and release file object reference.

Arguments:

    DeviceObject - Unused.

    Irp - The completed IRP.

    Context - FileObject on which MDL is returned

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - AFD takes care of the IRP

--*/

{
    PFILE_OBJECT    FileObject = Context;
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartMdlReadComplete: Irp-%p,status-%lx,length-%p\n",
                    Irp,
                    Irp->IoStatus.Status,
                    Irp->IoStatus.Information));
    }

    //
    // Dereference the file object
    //
    ObDereferenceObject (FileObject);
    AfdRecordFileDeref ();

    //
    // Free the IRP since it's no longer needed.
    //

    IoFreeIrp( Irp );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartMdlReadComplete


VOID
AfdLRMdlReadComplete (
    PAFD_BUFFER_HEADER  Pd
    )
{
    if (InterlockedPushEntrySList (
                &AfdLRFileMdlList,
                &Pd->SList)==NULL) {
        AfdLRListAddItem (&AfdLRFileMdlListItem,
                                AfdLRProcessFileMdlList);
    }
}

BOOLEAN
AfdLRProcessFileMdlList (
    PAFD_LR_LIST_ITEM   Item
    )
{
    PSINGLE_LIST_ENTRY  localList;
    BOOLEAN res = TRUE;

    ASSERT (Item==&AfdLRFileMdlListItem);
    DEBUG Item->SListLink.Next = UlongToPtr(0xBAADF00D);

    localList = InterlockedFlushSList (&AfdLRFileMdlList);

    while (localList!=NULL) {
        PAFD_BUFFER_HEADER  pd;
        NTSTATUS    status;
        pd = CONTAINING_RECORD (localList, AFD_BUFFER_HEADER, SList);
        localList = localList->Next;

        if (pd->BufferLength==0) {
            PAFD_BUFFER_TAG afdBufferTag = CONTAINING_RECORD (
                                                pd,
                                                AFD_BUFFER_TAG,
                                                Header);
            PAFD_ENDPOINT   endpoint = afdBufferTag->Context;
            status = AfdMdlReadComplete (afdBufferTag->FileObject,
                                            afdBufferTag->Mdl,
                                            &afdBufferTag->FileOffset);
            if (NT_SUCCESS (status)) {
                AfdReturnBuffer (&afdBufferTag->Header, 
                                    endpoint->OwningProcess);
                DEREFERENCE_ENDPOINT (endpoint);
                continue;
            }
        }
        else {
            PAFD_BUFFER afdBuffer = CONTAINING_RECORD (
                                                pd,
                                                AFD_BUFFER,
                                                Header);
            PAFD_CONNECTION connection = afdBuffer->Context;
            status = AfdMdlReadComplete (afdBuffer->FileObject,
                                            afdBuffer->Mdl->Next,
                                            &afdBuffer->FileOffset);
            if (NT_SUCCESS (status)) {
                afdBuffer->Mdl->Next = NULL;
                afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
                AfdReturnBuffer (&afdBuffer->Header, 
                                    connection->OwningProcess);
                DEREFERENCE_CONNECTION (connection);
                continue;
            }
        }

        if (InterlockedPushEntrySList (
                    &AfdLRFileMdlList,
                    &pd->SList)==NULL) {
            ASSERT (Item->SListLink.Next==UlongToPtr(0xBAADF00D));
            res = FALSE;
        }
    }

    return res;
}

NTSTATUS
AfdTPacketsBufferRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    )
/*++

Routine Description:

    Performs buffered file read for file systems that do
    not support caching

Arguments:

    TpIrp  - transmit packet irp
    Pd     - descriptor with file parameters for the read

Return Value:

    STATUS_SUCCESS - read was completed in-line
    STATUS_PENDING - read was queued to file system driver, 
                    will complete lated
    other - read failed
--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PDEVICE_OBJECT          deviceObject;
    PIRP                    irp;
    PAFD_BUFFER             afdBuffer;
    PIO_STACK_LOCATION      irpSp;

    ASSERT( AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED );

    afdBuffer = CONTAINING_RECORD (Pd, AFD_BUFFER, Header);

    //
    // Find the device object and allocate IRP of appropriate size
    // if current one does not fit or is not available at all.
    //
    deviceObject = IoGetRelatedDeviceObject (afdBuffer->FileObject);

    if ((tpInfo->ReadIrp==NULL) ||
            (tpInfo->ReadIrp->StackCount<deviceObject->StackSize)) {
        if (tpInfo->ReadIrp!=NULL) {
            IoFreeIrp (tpInfo->ReadIrp);
        }

        if (afdBuffer->Irp->StackCount<deviceObject->StackSize) {
            tpInfo->ReadIrp = IoAllocateIrp (deviceObject->StackSize, FALSE);
            if (tpInfo->ReadIrp==NULL) {
                PAFD_ENDPOINT   endpoint;
                endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;
                ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
                Pd->Mdl->ByteCount = Pd->BufferLength;
                AfdReturnBuffer (Pd, endpoint->OwningProcess);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            tpInfo->ReadIrp = afdBuffer->Irp;
        }
    }

    //
    // Mark IRP as busy and set it up
    //

    AFD_SET_TP_FLAGS (TpIrp, AFD_TP_READ_BUSY);

    irp = tpInfo->ReadIrp;


    //
    // Setup and sumbit the IRP
    //
    irp->MdlAddress = afdBuffer->Mdl;
    irp->AssociatedIrp.SystemBuffer = afdBuffer->Buffer;
    irp->UserBuffer = afdBuffer->Buffer;

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread ();
    irp->Overlay.AsynchronousParameters.UserApcContext = Pd;


    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = IRP_MN_NORMAL;
    irpSp->FileObject = afdBuffer->FileObject;


    irpSp->Parameters.Read.Length = Pd->DataLength;
    irpSp->Parameters.Read.ByteOffset = Pd->FileOffset;
    IoSetCompletionRoutine(
        irp,
        AfdRestartTPacketsBufferRead,
        TpIrp,
        TRUE,
        TRUE,
        TRUE
        );


    REFERENCE_TPACKETS (TpIrp);
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsBufferRead:"
                    " Initiating read, tp_info-%p,file-%p,buffer-%p,length-%lx,offset-%I64x\n",
                    tpInfo,
                    afdBuffer->FileObject,
                    (PVOID)afdBuffer,
                    afdBuffer->DataLength,
                    afdBuffer->FileOffset.QuadPart
                    ));
    }

    IoCallDriver (deviceObject, irp);

    if (((AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_READ_CALL_PENDING)
                                    & (AFD_TP_READ_COMP_PENDING|AFD_TP_ABORT_PENDING))==0) && 
                    NT_SUCCESS (irp->IoStatus.Status) &&
                    AfdTPacketsContinueAfterRead (TpIrp)) {
        //
        // Read completed successfully inline and post-processing was successfull,
        // tell the worker to go on.
        //
        UPDATE_TPACKETS2 (TpIrp, "BufRead completed inline with 0x%lX bytes",
                                (ULONG)irp->IoStatus.Information);
        return STATUS_SUCCESS;
    }
    else {
        //
        // Read has not completed yet or post processing failed,
        // worker should bail and we will continue when read completes
        // or in final completion routine (AfdCompleteTPackets).
        //

        return STATUS_PENDING;
    }
}

NTSTATUS
AfdRestartTPacketsBufferRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for buffered read.
    Does another send if packet is ready or schedules worker
    to do the same.
Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - read IRP being completed
    Context      - TpIrp

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PIRP            tpIrp = Context;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    PAFD_ENDPOINT   endpoint;
    PAFD_BUFFER     afdBuffer;
    ULONG           flags;

    endpoint = IoGetCurrentIrpStackLocation (tpIrp)->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT (AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);
    ASSERT (tpInfo->ReadIrp == Irp ||
        AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_ABORT_PENDING);

    afdBuffer = Irp->Overlay.AsynchronousParameters.UserApcContext;


    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPacketsBufferRead: tp_info-%p,Irp-%p,status-%lx,length-%p\n",
                tpInfo,
                Irp,
                Irp->IoStatus.Status,
                Irp->IoStatus.Information));
    }

    //
    // Insert MDL into the current chain
    // even if fs driver failed so that common
    // cleanup routine takes care of its disposal
    // together with AfdBuffer.
    //
    *(tpInfo->TailMdl) = afdBuffer->Mdl;
    tpInfo->TailMdl = &(afdBuffer->Mdl->Next);
    ASSERT (*(tpInfo->TailMdl)==NULL);

    (*tpInfo->TailPd) = &afdBuffer->Header;
    tpInfo->TailPd = &(afdBuffer->Next);
    ASSERT (*(tpInfo->TailPd)==NULL);

    flags = AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_READ_COMP_PENDING);

    if (Irp==afdBuffer->Irp) {
        //
        // If abort is aready in progress, we need to use
        // interlocked exchange to synchronize with
        // AfdAbortTPackets which may be attempting to cancel
        // this IRP.
        //
        if (flags & AFD_TP_ABORT_PENDING) {
#if DBG
            PIRP    irp =
#endif
            InterlockedExchangePointer ((PVOID *)&tpInfo->ReadIrp, NULL);
            ASSERT (irp==Irp || irp==(PVOID)-1);
        }
        else {
            tpInfo->ReadIrp = NULL;
        }
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        if (((flags & (AFD_TP_READ_CALL_PENDING|AFD_TP_ABORT_PENDING))==0) &&
                    AfdTPacketsContinueAfterRead (tpIrp)) {
            //
            // Read dispatch has already returned and post-processing 
            // was successfull, schedule the worker to continue processing
            // We transfer the reference that we added when we queued the
            // read to the worker.
            //
            UPDATE_TPACKETS2 (tpIrp, "BufRead completed in restart with %08x bytes", (ULONG)Irp->IoStatus.Information);
            AfdStartTPacketsWorker (AfdTPacketsWorker, tpIrp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    else {
        AfdAbortTPackets (tpIrp, Irp->IoStatus.Status);
    }

    DEREFERENCE_TPACKETS (tpIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
AfdTPacketsContinueAfterRead (
    PIRP    TpIrp
    )
/*++

Routine Description:
    Read post-processing common for cached and non-cached case.
    Queues new send if packet is complete and send IRP is available
Arguments:
    TpInfo      - transmit packets IRP
Return Value:
    TRUE - continue processing
    FALSE - processing cannot be continued because there are no
            available send IRPs
--*/

{
    PAFD_BUFFER_HEADER  pd;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;

    pd = CONTAINING_RECORD (tpInfo->TailPd, AFD_BUFFER_HEADER, Next);
    if (!pd->PartialMessage) {
        USHORT    sendIrp;

        sendIrp = AfdTPacketsFindSendIrp (TpIrp);
        if (sendIrp!=tpInfo->NumSendIrps) {
            AfdTPacketsSend (TpIrp, sendIrp);
        }
        else {
            return FALSE;
        }
    }
    else {
        //
        // Need to complete the packet chain before we can send again
        //
        ASSERT (tpInfo->PdLength<tpInfo->SendPacketLength);
        pd->PartialMessage = FALSE;
        UPDATE_TPACKETS2 (TpIrp, "Continue building packet after read, cur len: 0x%lX",
                                                tpInfo->PdLength);
    }

    return TRUE;
}


VOID
AfdCompleteTPackets (
    PVOID       Context
    )
/*++

Routine Description:
  This routine is called when all activity on transmit IRP request is completed
  and reference count drops to 0.  It cleans up remaining resources and
  completes the IRP or initiates endpoint reuse if so requested
Arguments:

    Context  - TransmitInfo associated with the request
Return Value:

    None
--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIRP    tpIrp = Context;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (tpIrp);
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    LONG    sendIrp;
    PAFD_ENDPOINT   endpoint;
    BOOLEAN checkQueue;
    PIRP    nextIrp = NULL;

    ASSERT (AFD_GET_TPIC(tpIrp)->ReferenceCount==0);
    endpoint = irpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    ASSERT ((AFD_GET_TPIC(tpIrp)->StateFlags 
                                 & (AFD_TP_SEND_BUSY(0) |
                                    AFD_TP_SEND_BUSY(1) |
                                    AFD_TP_READ_BUSY)) == 0);


    if (tpInfo!=NULL) {
        KIRQL   currentIrql;
        currentIrql = KeGetCurrentIrql ();

        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCompleteTPackets: tp_info-%p, irql-%x\n",
                        tpInfo, currentIrql));
        }

        UPDATE_TPACKETS2 (tpIrp, "CompletTPackets @ irql %lx", currentIrql);

        //
        // Cleanup what's in the TpInfo structure
        //
        if (tpInfo->HeadMdl!=NULL) {
            tpInfo->TailMdl = &tpInfo->HeadMdl;
            tpInfo->TailPd = &tpInfo->HeadPd;
            if (!AfdCleanupPacketChain (tpIrp, currentIrql<=APC_LEVEL)) {
                ASSERT (currentIrql>APC_LEVEL);
                AfdStartTPacketsWorker (AfdCompleteTPackets, tpIrp);
                return;
            }
        }

        //
        // Cleanup what remains in IRPs
        //
        for (sendIrp=0; sendIrp<tpInfo->NumSendIrps ; sendIrp++) {
            if (tpInfo->SendIrp[sendIrp]!=NULL) {
                if (tpInfo->SendIrp[sendIrp]->MdlAddress!=NULL) {
                    tpInfo->HeadMdl = tpInfo->SendIrp[sendIrp]->MdlAddress;
                    tpInfo->TailMdl = &tpInfo->HeadMdl;
                    tpInfo->SendIrp[sendIrp]->MdlAddress = NULL;
                    tpInfo->HeadPd = tpInfo->SendIrp[sendIrp]->Overlay.AsynchronousParameters.UserApcContext;
                    tpInfo->TailPd = &tpInfo->HeadPd;
                    tpInfo->SendIrp[sendIrp]->Overlay.AsynchronousParameters.UserApcContext = NULL;
                    if (!AfdCleanupPacketChain (tpIrp, currentIrql<=APC_LEVEL)) {
                        ASSERT (currentIrql>APC_LEVEL);
                        AfdStartTPacketsWorker (AfdCompleteTPackets, tpIrp);
                        return;
                    }

                }
                tpInfo->SendIrp[sendIrp]->Cancel = FALSE; // So we can reuse it.
            }
        }

        //
        // Free read IRP if we used one
        //
        if (tpInfo->ReadIrp!=NULL) {
            IoFreeIrp (tpInfo->ReadIrp);
            tpInfo->ReadIrp = NULL;
        }
    }

    ASSERT (tpIrp->Tail.Overlay.ListEntry.Flink == NULL);

    //
    // If request succeeded and reuse is required, attempt to
    // initiate it
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

    if ( NT_SUCCESS(tpIrp->IoStatus.Status) &&
                 (irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_REUSE_SOCKET) != 0 ) {

        PAFD_CONNECTION connection;

        IS_VC_ENDPOINT (endpoint);

        //
        // Check if we still have endpoint and connection intact
        // under the lock.  If this is not the case, we won't try
        // to reuse it (it must have been closed or aborted).
        //
        connection = endpoint->Common.VcConnecting.Connection;
        if (connection!=NULL) {

            ASSERT (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND ||
                        connection->AbortIndicated);
            //
            // Remember that there is a transmit IRP pended on the endpoint,
            // so that when we're freeing up the connection we also complete
            // the transmit IRP.
            //

            connection->ClosePendedTransmit = TRUE;

            //
            // Since we are going to effectively close this connection,
            // remember that we have started cleanup on this connection.
            // This allows AfdDeleteConnectedReference to remove the
            // connected reference when appropriate.
            //

            connection->CleanupBegun = TRUE;

            //
            // Delete the endpoint's reference to the connection in
            // preparation for reusing this endpoint.
            //

            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // This is to simplify debugging.
            // If connection is not being closed by the transport
            // we want to be able to find it in the debugger faster
            // then thru !poolfind AfdC.
            //
            endpoint->WorkItem.Context = connection;

            //
            // We are going to free TPackets info since we are done
            // with sends and no longer need this.
            // This will also be our indication that we are in the
            // reuse state (for the cancel routine).
            //
            tpIrp->AssociatedIrp.SystemBuffer = (PVOID)-1;
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
            if ((AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_SEND_AND_DISCONNECT) 
                    && !connection->DisconnectIndicated
                    && !connection->AbortIndicated) {
                ASSERT (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND);
                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                AfdDisconnectEventHandler (endpoint,
                                    connection,
                                    0, NULL, 0, NULL,
                                    TDI_DISCONNECT_RELEASE
                                    );
                DEREFERENCE_CONNECTION2 (connection, "S&D disconnect", 0);
            }
            else
#endif
            {
                //
                // Attempt to remove the connected reference.
                //

                AfdDeleteConnectedReference( connection, TRUE );

                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            
                DEREFERENCE_CONNECTION2 (connection,
                                            "No S&D disconnect, flags: %lx",
                                            connection->ConnectionStateFlags);
            }

            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdCompleteTPackets: tp_info-%p, initiating reuse\n",
                            tpInfo));
            }

            if (tpInfo!=NULL) {
                AfdReturnTpInfo (tpInfo);
            }
            //
            // DO NOT access the IRP after this point, since it may have
            // been completed inside AfdDereferenceConnection!
            //

            return;
        }

        UPDATE_ENDPOINT (endpoint);
    }


    if (NT_SUCCESS (tpIrp->IoStatus.Status)) {
        ASSERT (AFD_GET_TPIC(tpIrp)->EndpQueueEntry.Flink==NULL ||
                    irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT);
        if (endpoint->Irp==tpIrp) {
            endpoint->Irp = NULL;
        }
    }
    else {
        if (endpoint->Irp==tpIrp) {
            //
            // Check if all sends has been completed and IRP is not
            // a part of the queue.
            //
            if (AFD_GET_TPIC(tpIrp)->EndpQueueEntry.Flink!=NULL) {
                //
                // Irp is still a part of the queue.  Check
                // if anything else is there and schedule processing.
                //
                if (!IsListEmpty (&AFD_GET_TPIC(tpIrp)->EndpQueueEntry)) {
                    ASSERT (!(irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT));
                    nextIrp = CONTAINING_RECORD (
                        AFD_GET_TPIC(tpIrp)->EndpQueueEntry.Flink,
                        IRP,
                        Tail.Overlay.DriverContext);
                    //
                    // Remove the original IRP from the beginning of the queue.
                    //
                    RemoveEntryList (&AFD_GET_TPIC(tpIrp)->EndpQueueEntry);
                }
                AFD_GET_TPIC(tpIrp)->EndpQueueEntry.Flink = NULL;
            }
            endpoint->Irp = nextIrp;
        }
        else if (endpoint->Irp!=NULL) {
            nextIrp = endpoint->Irp;
            if (AfdGetTPacketsReference (nextIrp)) {
                ASSERT (nextIrp->AssociatedIrp.SystemBuffer!=(PVOID)-1);
            }
            else {
                nextIrp = NULL;
            }
        }
    }


    UPDATE_ENDPOINT2 (endpoint, "Completing irp with status: %lx", tpIrp->IoStatus.Status);

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    if (NT_SUCCESS(tpIrp->IoStatus.Status) &&
            (AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_SEND_AND_DISCONNECT) &&
            (endpoint->Common.VcConnecting.Connection!=NULL) ) {
        PAFD_CONNECTION connection;

        ASSERT (IS_VC_ENDPOINT (endpoint));

        connection = endpoint->Common.VcConnecting.Connection;
        REFERENCE_CONNECTION (connection);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        AfdAbortConnection (connection);
    }
    else
#endif // TDI_SERVICE_SEND_AND_DISCONNECT
    {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    if (IoSetCancelRoutine( tpIrp, NULL ) == NULL) {
        KIRQL cancelIrql;

        //
        // The cancel routine has or is about to run. Synchonize with
        // the cancel routine by acquiring and releasing the cancel
        // and endpoint spinlocks.  The cancel routine won't touch
        // the IRP as it will see that its reference count is 0 and SystemBuffer
        // is not yet NULL.
        //

        IoAcquireCancelSpinLock (&cancelIrql);
        ASSERT( tpIrp->Cancel );
        IoReleaseCancelSpinLock (cancelIrql);
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    if (irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT) {
        ASSERT (nextIrp==NULL);
        AFD_END_STATE_CHANGE (endpoint);
    }

    checkQueue = (tpIrp->Tail.Overlay.ListEntry.Blink == NULL);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdCompleteTPackets: tp_info-%p, completing IRP-%p\n",
                tpInfo, tpIrp));
    }
    tpIrp->AssociatedIrp.SystemBuffer = NULL;
    if (tpInfo!=NULL) {
        AfdReturnTpInfo (tpInfo);
    }

    IoCompleteRequest( tpIrp, AfdPriorityBoost );

    //
    // If we're enforcing a maximum active TransmitFile count,
    // and this Irp was counted towards active maximum, then
    // check the list of queued TransmitFile requests and start the
    // next one.
    //

    if( (AfdMaxActiveTransmitFileCount > 0) && 
            checkQueue ) {

        AfdStartNextQueuedTransmit();

    }

    if (nextIrp) {
        if (nextIrp->AssociatedIrp.SystemBuffer) {
            //
            // This is transmit IRP.
            // For VC endpoints, we have to fail all the onces that
            // follow as long as at least one fails - the connection
            // is most likely broken anyway.
            // For datagrams, we can still send (at least try).
            //
            if (IS_VC_ENDPOINT(endpoint)) {
                AfdAbortTPackets (nextIrp, STATUS_CANCELLED);
                DEREFERENCE_TPACKETS_S (nextIrp);
            }
            else {
                if( AfdMaxActiveTransmitFileCount == 0 || 
                        !AfdQueueTransmit (nextIrp)) {

                    AfdStartTPacketsWorker (AfdTPacketsWorker, nextIrp);
                }
            }
        }
        else {
            //
            // DisconnectEx IRP.
            // If we are asked to reuse, we'll attempt to do so
            // even if something failed.
            //
            ASSERT (IS_VC_ENDPOINT (endpoint));
            irpSp = IoGetCurrentIrpStackLocation (nextIrp);
            if ((irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_REUSE_SOCKET)==0) {
                AfdAbortTPackets (nextIrp, STATUS_CANCELLED);
            }
            DEREFERENCE_TPACKETS (nextIrp);
        }
    }

}

VOID
AfdAbortTPackets (
    PIRP        TpIrp,
    NTSTATUS    Status
    )
/*++

Routine Description:
  This routine is used to stop the transmit file request in progress
  and save the status which would be reported to the app as the
  cause of failure

Arguments:

    TransmitInfo     - trasnmit info structure associated with the request
    Status           - status code for the error that caused the abort
Return Value:

    None


--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    LONG    stateFlags, newStateFlags;
    USHORT  sendIrp;

    do {
        newStateFlags = stateFlags = AFD_GET_TPIC(TpIrp)->StateFlags;
        if (newStateFlags & AFD_TP_ABORT_PENDING) {
            return;
        }

        newStateFlags |= AFD_TP_ABORT_PENDING;
    }
    while (InterlockedCompareExchange (
                            (PLONG)&AFD_GET_TPIC(TpIrp)->StateFlags,
                            newStateFlags,
                            stateFlags)!=stateFlags);
    if (NT_SUCCESS (TpIrp->IoStatus.Status)) {
        TpIrp->IoStatus.Status = Status;
        UPDATE_TPACKETS2 (TpIrp, "Abort with status: %lx", Status);
    }

    if (tpInfo!=NULL) {
        //
        // Cancel any outstanding IRPs.  It is safe to cancel IRPs even if
        // they are already completed and before they are submitted 
        // (although we try to avoid doing this unnecessarily).
        // Note that the completion pending flag can be set even
        // before the irp is allocated, so check for NULL is important.
        // However, after IRP is allocated and assigned, it is not freed
        // until transmit packets is completed.
        //

        for (sendIrp=0; sendIrp<tpInfo->NumSendIrps; sendIrp++) {
            if (tpInfo->SendIrp[sendIrp]!=NULL &&
                    AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_SEND_COMP_PENDING(sendIrp)) {
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdAbortTPackets: tp_info-%p, canceling send irp1-%p\n",
                                tpInfo,
                                tpInfo->SendIrp[sendIrp]));
                }
                UPDATE_TPACKETS2 (TpIrp, "Aborting send irp %ld", sendIrp);
                IoCancelIrp (tpInfo->SendIrp[sendIrp]);
            }
        }

        if (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_READ_COMP_PENDING) {
            do {
                PIRP    irp;

                //
                // Check if completion routine did not manage
                // to reset this IRP (because it was part of
                // AFD buffer structure - buffered reads case).
                //
                irp = tpInfo->ReadIrp;
                ASSERT (irp!=(PVOID)-1);
                if (irp==NULL) {
                    break;
                }

                //
                // Set this field to a "special" value so that
                // we know if we need to reset it back to previous
                // value when we are done with the IRP or if completion 
                // rouine done this already.
                //
                else if (InterlockedCompareExchangePointer (
                                    (PVOID *)&tpInfo->ReadIrp,
                                    (PVOID)-1,
                                    irp)==irp) {
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdAbortTPackets: tp_info-%p, canceling read irp-%p\n",
                                    tpInfo,
                                    irp));
                    }
                    UPDATE_TPACKETS2 (TpIrp, "Aborting read IRP", 0);
                    IoCancelIrp (irp);

                    //
                    // Reset the field to its original value
                    // unless completion routine already done this for us.
                    //
#if DBG
                    irp =
#endif
                    InterlockedCompareExchangePointer (
                                    (PVOID *)&tpInfo->ReadIrp,
                                    irp,
                                    (PVOID)-1);
                    ASSERT (irp==NULL || irp==(PVOID)-1);
                    break;
                }
            }
            while (1);
        }
    }
}

VOID
AfdCancelTPackets (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    The cancel routine for transmit packets requests.

Arguments:

    DeviceObject - ignored.

    Irp - a pointer to the transmit packets IRP to cancel.

Return Value:

    None.

--*/

{

    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    AFD_LOCK_QUEUE_HANDLE transmitLockHandle;


    //
    // Initialize some locals and grab the endpoint spin lock.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    tpInfo = Irp->AssociatedIrp.SystemBuffer;

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle);

    //
    // We can release cancel spinlock as we hold endpoint lock now.
    //

    IoReleaseCancelSpinLock (DISPATCH_LEVEL);

    //
    // If this transmit IRP is on the TransmitFile queue, remove it.
    //

    AfdAcquireSpinLockAtDpcLevel( &AfdQueuedTransmitFileSpinLock,
                                                    &transmitLockHandle);

    if ( Irp->Tail.Overlay.ListEntry.Flink != NULL ) {

        ASSERT (tpInfo!=NULL && tpInfo!=(PVOID)-1);

        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

        //
        // Reset Flink to indicate that IRP is no longer in the queue
        // Note that Blink is not reset so that completion routine knows
        // that this IRP was not counted towards active maximum and thus
        // new IRP should not be initiated when this one is being
        // completed.
        //

        Irp->Tail.Overlay.ListEntry.Flink = NULL;
        ASSERT (Irp->Tail.Overlay.ListEntry.Blink!=NULL);

        AfdReleaseSpinLockFromDpcLevel( &AfdQueuedTransmitFileSpinLock, &transmitLockHandle );
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        KeLowerIrql (Irp->CancelIrql);

        //
        // Although we know that there is nothing to abort, we call
        // this routine to set the status code in the IRP.
        //
        AfdAbortTPackets (Irp, STATUS_CANCELLED);

        IF_DEBUG (TRANSMIT) {
           KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCancelTPackets: Removed from the queue, tp_info-%p, irp-%p\n",
                        tpInfo, Irp));
        }
        //
        // Remove initial reference
        //
        DEREFERENCE_TPACKETS (Irp);
    }
    else {
        KIRQL   cancelIrql = Irp->CancelIrql;

        AfdReleaseSpinLockFromDpcLevel( &AfdQueuedTransmitFileSpinLock,
                                                        &transmitLockHandle);

        

        if (AfdGetTPacketsReference (Irp)) {
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
            if (cancelIrql!=DISPATCH_LEVEL) {
                KeLowerIrql (cancelIrql);
            }

            //
            // Transmit is still in progress, perform the abort
            //
            AfdAbortTPackets (Irp, STATUS_CANCELLED);

            //
            // Remove extra reference that we added above.
            //
            DEREFERENCE_TPACKETS (Irp);
        }
        else if (tpInfo==(PVOID)-1) {
            //
            // Endpoint is being disconnected and reused just complete the  IRP 
            // (we reset the pointer to it so that reuse routine won't do it again).
            //
            BOOLEAN checkQueue = (Irp->Tail.Overlay.ListEntry.Blink == NULL);


            ASSERT (endpoint->Irp==Irp);
            endpoint->Irp = NULL;
            //
            // Reset the pointer so we do not confuse the IO subsystem
            //
            Irp->AssociatedIrp.SystemBuffer = NULL;

            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
            if (Irp->CancelIrql!=DISPATCH_LEVEL) {
                KeLowerIrql (Irp->CancelIrql);
            }
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdCancelTPackets: Completing, irp-%p\n",
                            Irp));
            }

            UPDATE_ENDPOINT (endpoint);
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest (Irp, AfdPriorityBoost);


            //
            // If we're enforcing a maximum active TransmitFile count,
            // and this Irp was counted towards active maximum, then
            // check the list of queued TransmitFile requests and start the
            // next one.
            //

            if( AfdMaxActiveTransmitFileCount > 0 && checkQueue) {

                AfdStartNextQueuedTransmit();

            }
        }
        else {
            //
            // Everything is done anyway, let go.
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
            if (cancelIrql!=DISPATCH_LEVEL) {
                KeLowerIrql (cancelIrql);
            }
        }
    }

} // AfdCancelTPackets



VOID
AfdCompleteClosePendedTPackets (
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Completes a transmit IRP that was waiting for the connection to be
    completely disconnected.

Arguments:

    Endpoint - the endpoint on which the transmit request is pending.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIRP tpIrp;
    BOOLEAN checkQueue;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    //
    // First make sure that thre is really a transmit request pended on
    // this endpoint.  We do this while holding the appropriate locks
    // to close the timing window that would exist otherwise, since
    // the caller may not have had the locks when making the test.
    //

    tpIrp = Endpoint->Irp;
    if ( tpIrp == NULL ) {
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCompleteClosePendedTPackets: Irp is gone, endpoint-%p",
                        Endpoint));
        }
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return;
    }

    ASSERT (tpIrp->AssociatedIrp.SystemBuffer == (PVOID)-1);
    tpIrp->AssociatedIrp.SystemBuffer = NULL;

    Endpoint->Irp = NULL;

    //
    // Release the lock before completing the transmit IRP--it is
    // illegal to call IoCompleteRequest while holding a spin lock.
    //

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    //
    // Reset the cancel routine in the IRP before attempting to complete
    // it.
    //

    if ( IoSetCancelRoutine( tpIrp, NULL ) == NULL ) {
        KIRQL cancelIrql;
        //
        // The cancel routine has or is about to run. Synchonize with
        // the cancel routine by acquiring and releasing the cancel
        // and endpoint spinlocks.  The cancel routine won't touch
        // the IRP as it will see that IRP pointer was reset in the
        // transmit info structure.
        //
        IoAcquireCancelSpinLock (&cancelIrql);
        ASSERT( tpIrp->Cancel );
        IoReleaseCancelSpinLock (cancelIrql);

    }


    //
    // Make sure to refresh the endpoint BEFORE completing the transmit
    // IRP.  This is because the user-mode caller may reuse the endpoint
    // as soon as the IRP completes, and there would be a timing window
    // between reuse of the endpoint and the refresh otherwise.
    //

    AfdRefreshEndpoint( Endpoint );

    ASSERT (tpIrp->IoStatus.Status==STATUS_SUCCESS);

    AFD_END_STATE_CHANGE (Endpoint);

    checkQueue = (tpIrp->Tail.Overlay.ListEntry.Blink == NULL);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCompleteClosePendedTPackets: Completing irp-%p",
                    tpIrp));
    }
    //
    // Finally, we can complete the transmit request.
    //
    UPDATE_ENDPOINT(Endpoint);

    IoCompleteRequest( tpIrp, AfdPriorityBoost );

    //
    // If we're enforcing a maximum active TransmitFile count,
    // and this Irp was counted towards active maximum, then
    // check the list of queued TransmitFile requests and start the
    // next one.
    //

    if( (AfdMaxActiveTransmitFileCount > 0) &&
            checkQueue) {

        AfdStartNextQueuedTransmit();

    }

} // AfdCompleteClosePendedTPackets

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
BOOLEAN
AfdTPacketsEnableSendAndDisconnect (
    PIRP    TpIrp
    )
/*++

Routine Description:

    Check if combined send and disconnect can be used and update
    endpoint state appropriately

Arguments:

    TpIrp    - transmit packets IRP

Return Value:

    TRUE - S&D can be used, endpoint state updated.
    FALSE - no, use normal disconnect (which updates the state by itself).

--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    PAFD_ENDPOINT   endpoint;
    BOOLEAN         res = FALSE;

    endpoint = irpSp->FileObject->FsContext;
    if ( AfdUseTdiSendAndDisconnect &&
                (irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_REUSE_SOCKET) &&
                (endpoint->TdiServiceFlags & TDI_SERVICE_SEND_AND_DISCONNECT)) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        ASSERT (IS_VC_ENDPOINT (endpoint));

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        if (!(endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) &&
                endpoint->Common.VcConnecting.Connection!=NULL &&
                endpoint->Common.VcConnecting.Connection->ConnectDataBuffers==NULL
                ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
            res = TRUE;
            UPDATE_TPACKETS2 (TpIrp, "Enabling S&D", 0);
        }
        else {
            UPDATE_TPACKETS2 (TpIrp, "Disabling S&D, disconnect mode: %lx", 
                                            endpoint->DisconnectMode);
        }

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }
    else {
        UPDATE_TPACKETS2 (TpIrp, 
                            "Not enabling S&D, flags: %lx",
                            irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags);
    }

    return res;
}

#endif // TDI_SERVICE_SEND_AND_DISCONNECT

BOOLEAN
AfdQueueTransmit (
    PIRP        Irp
    )
/*++

Routine Description:

    Check transmit IRP can be process immediately or needs to be put
    in the queue because of exceeded simmulteneous send limit

Arguments:

    Irp     - TransmitIrp
Return Value:

    TRUE - Irp was queued, can't send
    FALSE - We are below the limit, go ahed and send.

--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    AfdAcquireSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);

    if( AfdActiveTransmitFileCount >= AfdMaxActiveTransmitFileCount ) {

        InsertTailList(
            &AfdQueuedTransmitFileListHead,
            &Irp->Tail.Overlay.ListEntry
            );
        UPDATE_TPACKETS2 (Irp, "Queuing, current count: %ld", AfdActiveTransmitFileCount);

        AfdReleaseSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdQueueTransmit: Queuing Irp-%p,endpoint-%p,tp_info-%p\n",
                        Irp,
                        IoGetCurrentIrpStackLocation (Irp)->FileObject->FsContext,
                        Irp->AssociatedIrp.SystemBuffer));
        }
        return TRUE;
    } else {

        AfdActiveTransmitFileCount++;

        AfdReleaseSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);
        return FALSE;
    }
}


VOID
AfdStartNextQueuedTransmit(
    VOID
    )
/*++

Routine Description:
  Starts next transmit file in the queue if the number of pending
  request drops below maximum

Arguments:

    None.

Return Value:

    None.

--*/
{

    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PAFD_TPACKETS_INFO_INTERNAL    tpInfo;

    //
    // This should only be called if we're actually enforcing a maximum
    // TransmitFile count.
    //

    ASSERT( AfdMaxActiveTransmitFileCount > 0 );

    //
    // The TransmitFile request queue is protected by a
    // spinlock, so grab that lock before examining the queue.
    //

    AfdAcquireSpinLock( &AfdQueuedTransmitFileSpinLock, &lockHandle );

    //
    // This routine is only called after a pended TransmitFile IRP
    // completes, so account for that completion here.
    //

    ASSERT( AfdActiveTransmitFileCount > 0 );
    AfdActiveTransmitFileCount--;

    if( !IsListEmpty( &AfdQueuedTransmitFileListHead ) ) {

        //
        // Dequeue exactly one IRP from the list, then start the
        // TransmitFile.
        //

        listEntry = RemoveHeadList(
                        &AfdQueuedTransmitFileListHead
                        );

        irp = CONTAINING_RECORD(
                  listEntry,
                  IRP,
                  Tail.Overlay.ListEntry
                  );

        tpInfo = irp->AssociatedIrp.SystemBuffer;

        ASSERT( tpInfo != NULL );

        //
        // Mark this TransmitFile request as no longer queued.
        // and counted towards active maximum.
        //

        irp->Tail.Overlay.ListEntry.Flink = NULL;
        irp->Tail.Overlay.ListEntry.Blink = NULL;
        
        //
        // Adjust the count, release the spinlock, then queue the
        // TransmitFile.
        //

        AfdActiveTransmitFileCount++;
        ASSERT( AfdActiveTransmitFileCount <= AfdMaxActiveTransmitFileCount );

    
        UPDATE_TPACKETS2 (irp,"Restarting from queue, count: %ld", AfdActiveTransmitFileCount);
        AfdReleaseSpinLock( &AfdQueuedTransmitFileSpinLock, &lockHandle );

        ASSERT (irp->AssociatedIrp.SystemBuffer!=NULL);
        //
        // Schedule the worker for the  transmit.
        //
        AfdStartTPacketsWorker (AfdTPacketsWorker, irp);

    } else {

        //
        // Release the spinlock before returning.
        //

        AfdReleaseSpinLock( &AfdQueuedTransmitFileSpinLock, &lockHandle );
    }

}   // AfdStartNextQueuedTransmit


BOOLEAN
AfdEnqueueTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    )
/*++

Routine Description:

    Check if transmit IRP can be process immediately or needs to be put
    in the queue because there is already an active transmit IRP on the
    endpoint.

Arguments:

    Endpoint - endpoint to check
    Irp      - TransmitIrp
Return Value:

    TRUE - Irp was queued, can't send
    FALSE - There are no other IRPs on the endpoint, can send now.

--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    PIRP            oldIrp;
    BOOLEAN         busy = FALSE;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    //
    // Use interlocked operation since another thread can claim the
    // spot without spinlock.  Note, that the IRP field cannot be cleared
    // outside of spinlock though.
    //
    oldIrp = InterlockedCompareExchangePointer ((PVOID *)&Endpoint->Irp,
                                                TpIrp,
                                                NULL);
    if (oldIrp!=NULL) {
        //
        // Another IRP is still pending, check if sends are still
        // pending.
        //
        if (AFD_GET_TPIC(oldIrp)->EndpQueueEntry.Flink!=NULL) {
            //
            // Add this IRP behind the last one in the list.
            //
            InsertTailList (&AFD_GET_TPIC(oldIrp)->EndpQueueEntry,
                            &AFD_GET_TPIC(TpIrp)->EndpQueueEntry);
            //
            // This IRP will not be counted towards maximum for now.
            //
            TpIrp->Tail.Overlay.ListEntry.Blink = (PVOID)2;
            busy = TRUE;
            //
            // Add extra reference so that the caller can 
            // be sure that this IRP will not get completed before
            // it can properly set it up.
            //
            REFERENCE_TPACKETS (TpIrp);
        }
        else {
            //
            // Sending is finished, we can replace the IRP with ours.
            //
            Endpoint->Irp = TpIrp;
        }
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return busy;
}

VOID
AfdStartNextTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    )
/*++

Routine Description:

    Check if there are other IRPs enqueued behind the one we about
    to finish with (perform last send) and start it.

Arguments:

    Endpoint - endpoint to check
    Irp      - TransmitIrp
Return Value:
    None.
--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    PIRP                    newIrp;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (!IsListEmpty (&AFD_GET_TPIC(TpIrp)->EndpQueueEntry)) {
        newIrp = CONTAINING_RECORD (
                        AFD_GET_TPIC(TpIrp)->EndpQueueEntry.Flink,
                        IRP,
                        Tail.Overlay.DriverContext);
        RemoveEntryList (&AFD_GET_TPIC(TpIrp)->EndpQueueEntry);
        Endpoint->Irp = newIrp;

        //
        // Set the field to indicate we are counting towards active
        // maximum.
        //
        if (newIrp->AssociatedIrp.SystemBuffer!=NULL) {
            //
            // Regular TransmitPackets/File, mark as counted
            // towards maximum.  QueueTransmit will re-initalize
            // if called.
            //
            newIrp->Tail.Overlay.ListEntry.Blink = NULL;
        }
        else {
            //
            // DisconnectEx is never counted towards maximum
            //
            newIrp->Tail.Overlay.ListEntry.Blink = (PVOID)3;
        }
    }
    else {
        newIrp = NULL;
    }
    //
    // Indicate that the sends in the IRP are processed
    //
    AFD_GET_TPIC(TpIrp)->EndpQueueEntry.Flink = NULL;
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (newIrp!=NULL) {
        if (newIrp->AssociatedIrp.SystemBuffer!=NULL) {
            if( AfdMaxActiveTransmitFileCount == 0 || 
                    !AfdQueueTransmit (newIrp)) {
                //
                // Start I/O
                //

                AfdStartTPacketsWorker (AfdTPacketsWorker, newIrp);
            }
        }
        else {
            //
            // We never count DisconnectEx towards active maximum.
            // Just queue the disconnect.
            //
            AfdPerformSuperDisconnect (newIrp);
        }
    }
}

VOID
AfdStartTPacketsWorker (
    PWORKER_THREAD_ROUTINE  WorkerRoutine,
    PIRP                    TpIrp
    )
/*++

Routine Description:

  Posts work item to be executed at IRQL above DPC_LEVEL so that
  file system can be accessed.  It uses one of three methods 
  of doing this: special kernel APC, normal kernel APC, or
  system thread (work queue item).

Arguments:

    WorkerRoutine   - routine to execute
    TransmitInfo    - associated transmit info (also parameter to 
                        the worker routine).
Return Value:

    None.

--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    ASSERT ((AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED) 
                || (AFD_GET_TPIC(TpIrp)->ReferenceCount==0));

    switch (irpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_WORKER_KIND_MASK) {
    case AFD_TF_USE_KERNEL_APC:
        //
        // Initialize normal APC but with normal routine set
        // to special value so we know to run the worker
        // inside the special routine of normal APC and queue it
        //
        KeInitializeApc (&tpInfo->Apc,
                            PsGetThreadTcb (TpIrp->Tail.Overlay.Thread),
                            TpIrp->ApcEnvironment,
                            AfdTPacketsApcKernelRoutine,
                            AfdTPacketsApcRundownRoutine,
                            (PKNORMAL_ROUTINE)-1,
                            KernelMode,
                            NULL
                            );
        if (KeInsertQueueApc (&tpInfo->Apc,
                                WorkerRoutine,
                                TpIrp,
                                AfdPriorityBoost))
            return;
        //
        // If APC cannot be inserted into the queue, drop
        // to use the system worker thread
        //
        break;
    case AFD_TF_USE_SYSTEM_THREAD:
        //
        // This is the default case which is also used if everything else fails,
        // so just break out.
        //
        break;
    default:
        ASSERT (!"Unknown worker type!");
        __assume (0);
    }

    ExInitializeWorkItem (&tpInfo->WorkItem,
                                WorkerRoutine,
                                TpIrp
                                );
    ExQueueWorkItem (&tpInfo->WorkItem, DelayedWorkQueue);
}


VOID
AfdTPacketsApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
/*++

Routine Description:

  Special kernel apc routine. Executed in the context of
  the target thread at APC_LEVEL

Arguments:
    NormalRoutine  - pointer containing address of normal routine (it will
                    be NULL for special kernel APC and not NULL for normal
                    kernel APC)

    SystemArgument1 - pointer to the address of worker routine to execute
    SystemArgument2 - pointer to the argument to pass to worker routine

Return Value:

    None.

--*/
{
#if DBG
    try {
#endif
        ASSERT (CONTAINING_RECORD (Apc,AFD_TPACKETS_INFO_INTERNAL,Apc)
                    ==((PIRP)*SystemArgument2)->AssociatedIrp.SystemBuffer);

        //
        // Normal APC, but we are requested to run in its special
        // routine which avoids raising and lowering IRQL
        //
        ASSERT (*NormalRoutine==(PKNORMAL_ROUTINE)-1);
        *NormalRoutine = NULL;
        ((PWORKER_THREAD_ROUTINE)*SystemArgument1) (*SystemArgument2);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


VOID
AfdTPacketsApcRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

  APC rundown routine. Executed if APC cannot be delivered for
  some reason (thread exiting).
  We just fall back to system threads to execute the worker

Arguments:

    Apc     - APC structure

Return Value:

    None.

--*/
{
    PIRP    tpIrp;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;
    PWORKER_THREAD_ROUTINE      workerRoutine;
#if DBG
    try {
#endif

    workerRoutine = Apc->SystemArgument1;
    tpIrp = Apc->SystemArgument2;
    tpInfo = tpIrp->AssociatedIrp.SystemBuffer;

    ASSERT (tpInfo==CONTAINING_RECORD (Apc,AFD_TPACKETS_INFO_INTERNAL,Apc));

    ExInitializeWorkItem (&tpInfo->WorkItem,
                                workerRoutine,
                                tpIrp
                                );
    ExQueueWorkItem (&tpInfo->WorkItem, DelayedWorkQueue);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


BOOLEAN
AfdGetTPacketsReference (
    PIRP Irp
    )
{
    LONG   count;

    //
    // Only if transmit info is not completed yet, cancel all the IRPs
    // We release the spinlock while cancelling the IRP, so we need
    // to make sure that one of the cancelled IRPs won't initiate
    // completion while we trying to cancel the other IRPs
    //
    do {
        count = AFD_GET_TPIC(Irp)->ReferenceCount;
        if (count==0) {
            break;
        }
    }
    while (InterlockedCompareExchange ((PLONG)
        &AFD_GET_TPIC(Irp)->ReferenceCount,
        (count+1),
        count)!=count);
    if (count!=0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//
// Debug reference/dereference code, validates reference count
// and saves tracing information.
//
#if REFERENCE_DEBUG
VOID
AfdReferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    )
{                                                     
    LONG   count; 

    do {                 
        count = AFD_GET_TPIC(Irp)->ReferenceCount;
        ASSERT (count>0);
    }                                             
    while (InterlockedCompareExchange ((PLONG)
            &AFD_GET_TPIC(Irp)->ReferenceCount,
            (count+1),
            count)!=count);

    if (Irp->AssociatedIrp.SystemBuffer) {
        AFD_UPDATE_REFERENCE_DEBUG (
                (PAFD_TPACKETS_INFO_INTERNAL)Irp->AssociatedIrp.SystemBuffer,
                count+1,
                LocationId, 
                Param);
    }

}

LONG
AfdDereferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    )
{                                                     
    LONG    count;

    if (Irp->AssociatedIrp.SystemBuffer) {
        AFD_UPDATE_REFERENCE_DEBUG (
                (PAFD_TPACKETS_INFO_INTERNAL)Irp->AssociatedIrp.SystemBuffer,
                AFD_GET_TPIC(Irp)->ReferenceCount-1,
                LocationId,
                Param);
    }

    count = InterlockedDecrement ((PLONG)
                &AFD_GET_TPIC(Irp)->ReferenceCount);
    ASSERT (count>=0);                      
    return count;
}

VOID
AfdUpdateTPacketsTrack (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    )
{
    if (Irp->AssociatedIrp.SystemBuffer) {
        AFD_UPDATE_REFERENCE_DEBUG (
                (PAFD_TPACKETS_INFO_INTERNAL)Irp->AssociatedIrp.SystemBuffer,
                AFD_GET_TPIC(Irp)->ReferenceCount,
                LocationId,
                Param);
    }
}
#endif // REFERENCE_DEBUG


PAFD_TPACKETS_INFO_INTERNAL
AfdGetTpInfo (
    ULONG   ElementCount
    )
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;

    ASSERT (ElementCount<=(MAXULONG/sizeof (AFD_TRANSMIT_PACKETS_ELEMENT)));

    tpInfo = ExAllocateFromNPagedLookasideList(&AfdLookasideLists->TpInfoList);
    if (tpInfo!=NULL) {
        ASSERT (tpInfo->ReadIrp==NULL);
        ASSERT (tpInfo->NumSendIrps==AFD_TP_MIN_SEND_IRPS);

        tpInfo->HeadMdl = NULL;
        tpInfo->TailMdl = &tpInfo->HeadMdl;
        tpInfo->HeadPd = NULL;
        tpInfo->TailPd = &tpInfo->HeadPd;
        tpInfo->PdLength = 0;
        tpInfo->PdNeedsPps = FALSE;
        tpInfo->NextElement = 0;
        tpInfo->RemainingPkts = MAXULONG;

#if REFERENCE_DEBUG
        tpInfo->CurrentReferenceSlot = -1;
        RtlZeroMemory (&tpInfo->ReferenceDebug, 
                            sizeof (tpInfo->ReferenceDebug));
#endif
#if AFD_PERF_DBG
        tpInfo->WorkersExecuted = 0;
#endif
        if (ElementCount<=3) {
            return tpInfo;
        }

        try {
            tpInfo->ElementArray =
                    AFD_ALLOCATE_POOL_WITH_QUOTA (
                        NonPagedPool,
                        ElementCount*sizeof (AFD_TRANSMIT_PACKETS_ELEMENT),
                        AFD_TRANSMIT_INFO_POOL_TAG);
            tpInfo->ArrayAllocated = TRUE;
            return tpInfo;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
        }
        AfdReturnTpInfo (tpInfo);
    }

    return NULL;
}

VOID
AfdReturnTpInfo (
    PAFD_TPACKETS_INFO_INTERNAL TpInfo
    )
{
    ULONG   i;

    //
    // Validate that built-in send IRPs are properly deinitialized.
    //

#if DBG
    for (i=0; i<AFD_TP_MIN_SEND_IRPS; i++) {
        ASSERT (TpInfo->SendIrp[i]->MdlAddress == NULL);
        ASSERT (TpInfo->SendIrp[i]->Overlay.AsynchronousParameters.UserApcContext == NULL);
        ASSERT (TpInfo->SendIrp[i]->Cancel==FALSE);
    }
#endif

    //
    // Dispose of extra allocated IRPs.
    //
    while (TpInfo->NumSendIrps>AFD_TP_MIN_SEND_IRPS) {
        TpInfo->NumSendIrps -= 1;
        if (TpInfo->SendIrp[TpInfo->NumSendIrps]!=NULL) {
            IoFreeIrp (TpInfo->SendIrp[TpInfo->NumSendIrps]);
            TpInfo->SendIrp[TpInfo->NumSendIrps] = NULL;
        }
    }

    if (TpInfo->ReadIrp!=NULL) {
        IoFreeIrp (TpInfo->ReadIrp);
        TpInfo->ReadIrp = NULL;
    }


    //
    // Cleanup all file objects and MDLs that we may have already referenced
    //
    for (i=0; i<TpInfo->ElementCount; i++) {
        PAFD_TRANSMIT_PACKETS_ELEMENT  pel;

        pel = &TpInfo->ElementArray[i];
        if (pel->Flags & TP_FILE) {
            if (pel->FileObject!=NULL) {
                ObDereferenceObject( pel->FileObject );
                AfdRecordFileDeref();
            }
        }
        else if (pel->Flags & TP_MDL) {
            ASSERT (pel->Flags & TP_MEMORY);
            if (pel->Mdl!=NULL) {
                if (pel->Mdl->MdlFlags & MDL_PAGES_LOCKED) {
                    MmUnlockPages (pel->Mdl);
                }
                IoFreeMdl (pel->Mdl);
            }
        }
    }

    //
    // Free non-default sized array of packets if necessary.
    //
    if (TpInfo->ArrayAllocated) {
        AFD_FREE_POOL (TpInfo->ElementArray, AFD_TRANSMIT_INFO_POOL_TAG);
        TpInfo->ElementArray = ALIGN_UP_TO_TYPE_POINTER (
                        (PUCHAR)TpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                        AFD_TRANSMIT_PACKETS_ELEMENT);
        TpInfo->ArrayAllocated = FALSE;
    }
    else {
        ASSERT (TpInfo->ElementCount<=AfdDefaultTpInfoElementCount);
        ASSERT (TpInfo->ElementArray == ALIGN_UP_TO_TYPE_POINTER (
                        (PUCHAR)TpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                        AFD_TRANSMIT_PACKETS_ELEMENT));
    }

#if AFD_PERF_DBG
    InterlockedExchangeAdd (&AfdTPWorkersExecuted, TpInfo->WorkersExecuted);
    InterlockedIncrement (&AfdTPRequests);
#endif
    ExFreeToNPagedLookasideList( &AfdLookasideLists->TpInfoList, TpInfo );
}


ULONG
AfdComputeTpInfoSize (
    ULONG   ElementCount,
    LONG    IrpCount,
    CCHAR   IrpStackCount
    )
{
    USHORT  irpSize = (USHORT)ALIGN_UP_TO_TYPE(IoSizeOfIrp (IrpStackCount), IRP);
    return 
        ALIGN_UP_TO_TYPE(
            ALIGN_UP_TO_TYPE (
                sizeof (AFD_TPACKETS_INFO_INTERNAL),
                AFD_TRANSMIT_PACKETS_ELEMENT ) +
            ElementCount*sizeof (AFD_TRANSMIT_PACKETS_ELEMENT),
            IRP ) +
        irpSize*IrpCount;
}

PVOID
AfdAllocateTpInfo (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    AFD TpInfo structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the tp info structure

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized TpInfo, or NULL if the allocation
        attempt fails.

--*/

{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;
    tpInfo = AFD_ALLOCATE_POOL (
                    NonPagedPool,
                    NumberOfBytes,
                    AFD_TRANSMIT_INFO_POOL_TAG);

    if (tpInfo!=NULL) {
        USHORT  irpSize = IoSizeOfIrp (AfdIrpStackSize-1);
        LONG    i;

        RtlZeroMemory (tpInfo, sizeof (*tpInfo));

        tpInfo->ElementArray = ALIGN_UP_TO_TYPE_POINTER (
                        (PUCHAR)tpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                        AFD_TRANSMIT_PACKETS_ELEMENT);

        tpInfo->NumSendIrps = AFD_TP_MIN_SEND_IRPS;
        tpInfo->SendIrp[0] = ALIGN_UP_TO_TYPE_POINTER (
                                    &tpInfo->ElementArray[AfdDefaultTpInfoElementCount],
                                    IRP);
        IoInitializeIrp (tpInfo->SendIrp[0], irpSize, AfdIrpStackSize-1);
        tpInfo->SendIrp[0]->Overlay.AsynchronousParameters.UserApcRoutine = (PVOID)0;
        for (i=1; i<AFD_TP_MIN_SEND_IRPS; i++) {
            tpInfo->SendIrp[i] = ALIGN_UP_TO_TYPE_POINTER (
                                    (PUCHAR)tpInfo->SendIrp[i-1]+irpSize,
                                    IRP);
            IoInitializeIrp (tpInfo->SendIrp[i], irpSize, AfdIrpStackSize-1);
            tpInfo->SendIrp[i]->Overlay.AsynchronousParameters.UserApcRoutine = (PVOID)(UINT_PTR)i;
        }
    }
    return tpInfo;
}


VOID
NTAPI
AfdFreeTpInfo (
    PVOID   TpInfo
    )
{
    ASSERT (((PAFD_TPACKETS_INFO_INTERNAL)TpInfo)->ElementArray == ALIGN_UP_TO_TYPE_POINTER (
                    (PUCHAR)TpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                    AFD_TRANSMIT_PACKETS_ELEMENT));
    AFD_FREE_POOL (TpInfo, AFD_TRANSMIT_INFO_POOL_TAG);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *            T R A N S M I T   F I L E   I M P L E M E N T A T I O N
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


NTSTATUS
AfdRestartFastTransmitSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdDoMdlReadComplete (
    PVOID   Context
    );

VOID
AfdFastTransmitApcRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
AfdFastTransmitApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdFastTransmitFile )
#pragma alloc_text( PAGEAFD, AfdRestartFastTransmitSend )
#pragma alloc_text( PAGE, AfdFastTransmitApcKernelRoutine )
#pragma alloc_text( PAGE, AfdFastTransmitApcRundownRoutine )
#pragma alloc_text( PAGE, AfdDoMdlReadComplete )
#pragma alloc_text( PAGE, AfdTransmitFile )
#endif


BOOLEAN
AfdFastTransmitFile (
    IN PAFD_ENDPOINT endpoint,
    IN PAFD_TRANSMIT_FILE_INFO transmitInfo,
    OUT PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    Attempts to perform a fast TransmitFile call.  This will succeed
    only if the caller requests write behind, the file data to be sent
    is small, and the data is in the file system cache.

Arguments:

    endpoint - the endpoint of interest.

    transmitInfo - AFD_TRANSMIT_FILE_INFO structure.

    IoStatus - points to the IO status block that will be set on successful
        return from this function.

Return Value:

    TRUE if the fast path was successful; FALSE if we need to do through
    the normal path.

--*/

{
    PAFD_CONNECTION connection;
    PAFD_BUFFER afdBuffer;
    ULARGE_INTEGER sendLength;
    PFILE_OBJECT fileObject;
    BOOLEAN success;
    BOOLEAN sendCountersUpdated;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG fileWriteLength, bufferLength;
    NTSTATUS status;
    LARGE_INTEGER fileOffset;
    PMDL fileMdl;
    PIRP irp;

    //
    // If the endpoint is shut down in any way, bail out of fast IO.
    //

    if ( endpoint->DisconnectMode != 0 ) {
        return FALSE;
    }

    if ( endpoint->Type != AfdBlockTypeVcConnecting ||
             endpoint->State != AfdEndpointStateConnected ) {
        return FALSE;
    }

    //
    // If the TDI provider for this endpoint supports bufferring,
    // don't use fast IO.
    //

    if ( IS_TDI_BUFFERRING(endpoint) ) {
        return FALSE;
    }

    //
    // Make sure that the flags are specified such that a fast-path
    // TransmitFile is reasonable.  The caller must have specified
    // the write-behind flag, but not the disconnect or reuse
    // socket flags.
    //

    if ( ((transmitInfo->Flags &
                (~(AFD_TF_WRITE_BEHIND |
                   AFD_TF_DISCONNECT |
                   AFD_TF_REUSE_SOCKET |
                   AFD_TF_WORKER_KIND_MASK))) != 0 ) ||
            ((transmitInfo->Flags & AFD_TF_WORKER_KIND_MASK)
                    == AFD_TF_WORKER_KIND_MASK) ||
            ((transmitInfo->Flags &(~AFD_TF_WORKER_KIND_MASK))
                    != AFD_TF_WRITE_BEHIND) ) {
        return FALSE;
    }

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastTransmitFile: attempting fast IO on endp %p, "
                    "conn %p\n", endpoint, endpoint->Common.VcConnecting.Connection));
    }


    //
    // Initialize locals so that cleanup is easier.
    //

    fileObject = NULL;
    afdBuffer = NULL;
    sendCountersUpdated = FALSE;
    fileMdl = NULL;

    //
    // Calculate the length the entire send.
    //

    if (transmitInfo->FileHandle!=NULL) {
        fileWriteLength = transmitInfo->WriteLength.LowPart;
    }
    else {
        fileWriteLength = 0;
    }

    sendLength.QuadPart = (ULONGLONG)transmitInfo->HeadLength +
                            (ULONGLONG)fileWriteLength +
                            (ULONGLONG)transmitInfo->TailLength;

    //
    // Require the following for the fast path:
    //
    //    - There be no limitation on the count of simultaneous
    //      TransmitFile calls.  The fast path would work around
    //      this limit, if it exists.
    //    - The caller must specify the write length (if it specified file at all).
    //    - The write length must be less than the configured maximum.
    //    - If the entire send is larger than an AFD buffer page,
    //      we're going to use FsRtlMdlRead, so for purposes of
    //      simplicity there must be:
    //        - a head buffer, and
    //        - no tail buffer
    //    - The configured maximum will always be less than 4GB.
    //    - The head buffer, if any, fits on a single page.
    //

    if (AfdMaxActiveTransmitFileCount != 0

             ||

         (transmitInfo->FileHandle!=NULL &&
            (fileWriteLength == 0 ||
             transmitInfo->Offset.QuadPart <0 ))

             ||

         sendLength.QuadPart > AfdMaxFastTransmit

             ||

         ( sendLength.LowPart > AfdMaxFastCopyTransmit &&
               (transmitInfo->HeadLength == 0 ||
                transmitInfo->TailLength != 0 ) )

             ||

         transmitInfo->WriteLength.HighPart != 0

             ||

         transmitInfo->HeadLength > AfdBufferLengthForOnePage ) {

        return FALSE;
    }

    
    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    connection = endpoint->Common.VcConnecting.Connection;
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return FALSE;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // Determine whether there is already too much send data
    // pending on the connection.  If there is too much send
    // data, don't do the fast path.
    //

    if ( AfdShouldSendBlock( endpoint, connection, sendLength.LowPart ) ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        goto complete;
    }
    //
    // Add a reference to the connection object since the send
    // request will complete asynchronously.
    //
    REFERENCE_CONNECTION( connection );

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);


    //
    // AfdShouldSendBlock() updates the send counters in the AFD
    // connection object.  Remember this fact so that we can clean
    // them up if the fast path fails after this point.
    //

    sendCountersUpdated = TRUE;

    //
    // Grab an AFD buffer large enough to hold the entire send.
    //

    if (sendLength.LowPart>AfdMaxFastCopyTransmit) {
        bufferLength = transmitInfo->HeadLength;
    }
    else {
        bufferLength = sendLength.LowPart;
    }

    if (bufferLength<max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM))) {
        bufferLength = max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM));
    }

    afdBuffer = AfdGetBuffer( bufferLength, 0,
                                    connection->OwningProcess );
    if ( afdBuffer == NULL ) {
        goto complete;
    }

    //
    // Initialize buffer fields for proper cleanup.
    //

    irp = afdBuffer->Irp;
    afdBuffer->Irp->Tail.Overlay.Thread = NULL;
    afdBuffer->FileObject = NULL;

    //
    // We use exception handler because buffers are user
    // mode pointers
    //
    try {

        //
        // Copy in the head and tail buffers, if necessary.  Note that if we
        // are goint to use MDL read, then there cannot be a tail buffer because of
        // the check at the beginning of this function.
        //

        if ( transmitInfo->HeadLength > 0 ) {
            RtlCopyMemory(
                afdBuffer->Buffer,
                transmitInfo->Head,
                transmitInfo->HeadLength
                );
        }

        if ( transmitInfo->TailLength > 0 ) {
            RtlCopyMemory(
                (PCHAR)afdBuffer->Buffer + transmitInfo->HeadLength +
                    fileWriteLength,
                transmitInfo->Tail,
                transmitInfo->TailLength
                );
        }

    } except( AFD_EXCEPTION_FILTER(NULL) ) {

        goto complete;
    }

    if (transmitInfo->FileHandle!=NULL) {
        //
        // Get a referenced pointer to the file object for the file that
        // we're going to transmit.  This call will fail if the file
        // handle specified by the caller is invalid.
        //

        status = ObReferenceObjectByHandle(
                     transmitInfo->FileHandle,
                     FILE_READ_DATA,
                     *IoFileObjectType,
                     ExGetPreviousMode (),
                     (PVOID *)&fileObject,
                     NULL
                     );
        if ( !NT_SUCCESS(status) ) {
            goto complete;
        }
        AfdRecordFileRef();

        //
        // If the file system doesn't support the fast cache manager
        // interface, bail and go through the IRP path.
        //

        if( !AFD_USE_CACHE(fileObject)) {
            goto complete;
        }

        //
        // Grab the file offset into a local so that we know that the
        // offset pointer we pass to FsRtlCopyRead is valid.
        //

        fileOffset = transmitInfo->Offset;

        if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) &&
                 (fileOffset.QuadPart == 0) ) {
            //
            // Use current offset if file is opened syncronously
            // and offset is not specified.
            //

            fileOffset = fileObject->CurrentByteOffset;
        }
        //
        // Get the file data.  If the amount of file data is small, copy
        // it directly into the AFD buffer.  If it is large, get an MDL
        // chain for the data and chain it on to the AFD buffer chain.
        //

        if ( sendLength.LowPart <= AfdMaxFastCopyTransmit ) {

            success = FsRtlCopyRead(
                          fileObject,
                          &fileOffset,
                          fileWriteLength,
                          FALSE,
                          0,
                          (PCHAR)afdBuffer->Buffer + transmitInfo->HeadLength,
                          IoStatus,
                          IoGetRelatedDeviceObject( fileObject )
                          );

            //
            // We're done with the file object, so deference it now.
            //

            ObDereferenceObject( fileObject );
            AfdRecordFileDeref();
            fileObject = NULL;

            if ( !success ) {
#if AFD_PERF_DBG
                InterlockedIncrement (&AfdFastTfReadFailed);
#endif
                goto complete;
            }

        } else {

            success = FsRtlMdlRead(
                          fileObject,
                          &fileOffset,
                          fileWriteLength,
                          0,
                          &fileMdl,
                          IoStatus
                          );

            if (success) {
                //
                // Save the file object in the AFD buffer.  The send restart
                // routine will handle dereferencing the file object and
                // returning the file MDLs to the system.
                //

                afdBuffer->FileObject = fileObject;
                afdBuffer->FileOffset = fileOffset;

                //
                // If caller asked us to use kernel APC to execute the request,
                // allocate and queue the IRP to the current thread to make 
                // sure it won't go away until IRP is completed.
                //
                if ((((transmitInfo->Flags & AFD_TF_WORKER_KIND_MASK)
                                    == AFD_TF_USE_KERNEL_APC) ||
                        (((transmitInfo->Flags & AFD_TF_WORKER_KIND_MASK)
                                == AFD_TF_USE_DEFAULT_WORKER) &&
                                (AfdDefaultTransmitWorker==AFD_TF_USE_KERNEL_APC))) ) {
                    //
                    // Allocation will occur right before we call the
                    // transport, set IRP to null to trigger this.
                    // 
                    irp = NULL;
                }
            }
            else {
#if AFD_PERF_DBG
                InterlockedIncrement (&AfdFastTfReadFailed);
#endif
                goto complete;
            }
        }

        //
        // If we read less information than was requested, we must have
        // hit the end of the file.  Fail the transmit request, since
        // this can only happen if the caller requested that we send
        // more data than the file currently contains.
        //

        if ( IoStatus->Information < fileWriteLength ) {
            goto complete;
        }
     }

    //
    // We have to rebuild the MDL in the AFD buffer structure to
    // represent exactly the number of bytes we're going to be
    // sending.  If the AFD buffer has all the send data, indicate
    // that.  If we did MDL file I/O, then chain the file data on
    // to the head MDL.
    //

    if ( fileMdl == NULL ) {
        afdBuffer->Mdl->ByteCount = sendLength.LowPart;
    } else {
        afdBuffer->Mdl->ByteCount = transmitInfo->HeadLength;
        afdBuffer->Mdl->Next = fileMdl;
    }

    //
    // We can have only one transmit file operation on endpoint
    // at a time.  Treat is as a state change
    //
    if (AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {

        //
        // Verify state under protection of state change flag
        //
        if (endpoint->State!=AfdEndpointStateConnected) {
            AFD_END_STATE_CHANGE (endpoint);
            goto complete;
        }

        //
        // Save connection to dereference in completion routine.
        //
        afdBuffer->Context = connection;

        if (irp==NULL) {
            //
            // Need to allocate IRP and let the io subsystem queue
            // it to the current thread, so we can run APC upon
            // IRP completion.
            //
            irp = TdiBuildInternalDeviceControlIrp (
                            TDI_SEND,
                            connection->DeviceObject,
                            connection->FileObject,
                            NULL,
                            &AfdDontCareIoStatus   // we will have our completion
                            // routine installed in the IRP which will get the
                            // status, so we do not care if IO system writes
                            // it there for us, but still must provide valid
                            // storage to avoid failure.
                            );
                    
            if (irp==NULL) {
                //
                // Could not allocate IRP, use worker threads
                //
                irp = afdBuffer->Irp;
            }
        }
        else {
            ASSERT (irp==afdBuffer->Irp);
        }

        //
        // Use the IRP in the AFD buffer structure to give to the TDI
        // provider.  Build the TDI send request.
        //

        TdiBuildSend(
            irp,
            connection->DeviceObject,
            connection->FileObject,
            AfdRestartFastTransmitSend,
            afdBuffer,
            afdBuffer->Mdl,
            0,
            sendLength.LowPart
            );

        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFastTransmit: Starting send for endp-%p,file-%p,"
                        "afdBuffer-%p,length-%ld.\n",
                        endpoint,fileObject,(PVOID)afdBuffer,sendLength.LowPart));
        }

        //
        // Call the transport to actually perform the send.
        //

        status = IoCallDriver( connection->DeviceObject, irp );


        AFD_END_STATE_CHANGE (endpoint);

        //
        // The fast path succeeded--complete the call.  Note that we
        // change the status code from what was returned by the TDI
        // provider into STATUS_SUCCESS.  This is because we don't want
        // to complete the IRP with STATUS_PENDING etc.
        //

        if ( NT_SUCCESS(status) ) {
            IoStatus->Information = sendLength.LowPart;
            IoStatus->Status = STATUS_SUCCESS;

            return TRUE;
        }
        else {
            // The restart routine will handle cleanup
            // and we cannot duplicate cleanup in the
            // case of a failure or exception below.
            //
            return FALSE;
        }
    }

    //
    // The call failed for some reason.  Fail fast IO.
    //


complete:

    if ( fileMdl != NULL ) {
        ASSERT (afdBuffer!=NULL);
        status = AfdMdlReadComplete( fileObject, fileMdl, &fileOffset );
        if (!NT_SUCCESS (status)) {
            afdBuffer->Context = connection;
            REFERENCE_CONNECTION (connection);
            ASSERT (afdBuffer->FileObject==fileObject);
            ASSERT (afdBuffer->Mdl->Next==fileMdl);
            ASSERT (afdBuffer->FileOffset.QuadPart==fileOffset.QuadPart);
            AfdLRMdlReadComplete (&afdBuffer->Header);
            afdBuffer = NULL;
            fileObject = NULL;
        }
    }

    if ( fileObject != NULL ) {
        ObDereferenceObject( fileObject );
        AfdRecordFileDeref();
    }

    if ( afdBuffer != NULL ) {
        ASSERT ((irp==NULL) || (irp==afdBuffer->Irp));
        afdBuffer->Mdl->Next = NULL;
        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
    }

    if ( sendCountersUpdated ) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        connection->VcBufferredSendBytes -= sendLength.LowPart;
        connection->VcBufferredSendCount -= 1;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_CONNECTION (connection);
    }

    return FALSE;

} // AfdFastTransmitFile

NTSTATUS
AfdRestartFastTransmitSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

  This is the completion routine for fast transmit send IRPs.
  It initiates the completion of the request.

Arguments:

    DeviceObject - ignored.

    Irp - the send IRP that is completing.

    Context - a pointer to the AfdBuffer structure with the buffer that
            was sent.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED which indicates to the I/O system
    that it should stop completion processing of this IRP.  User request
    has already been completed on the fast path, we just free resources here.

--*/
{
	PAFD_BUFFER		afdBuffer = Context;
    PAFD_CONNECTION connection = afdBuffer->Context;
    NTSTATUS        status = STATUS_MORE_PROCESSING_REQUIRED;

    IF_DEBUG (TRANSMIT) {
       KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartFastTransmitSend: Completing send for file-%p,"
                    "afdBuffer-%p,status-%lx.\n",
                    afdBuffer->FileObject,(PVOID)afdBuffer,Irp->IoStatus.Status));
    }

    AfdProcessBufferSend (connection, Irp);

    //
    // If file object is not NULL we need to
    // return MDL back to file system driver/cache
    //
    if (afdBuffer->FileObject!=NULL) {

        //
        // If we used a separate IRP, then
        // the caller requested that we do processing
        // inside kernel APC, otherwise, we are using
        // system worker threads.
        //
        if (afdBuffer->Irp!=Irp) {
            //
            // The IRP is owned by IO subsystem.
            // We must let it complete and free the IRP, hence
            // return STATUS_SUCCESS and remove MDL field as IO
            // subsytem cannot handle non-paged pool memory in MDL
            //
            status = STATUS_SUCCESS;
            Irp->MdlAddress = NULL;

            //
            // If IRP was not cancelled, attempt to initialize and queue APC
            // Otherwise, the thread is probably exiting and we won't be
            // able to queue apc anyway.
            //
            if (!Irp->Cancel) {
                ASSERT (afdBuffer->BufferLength>=sizeof(KAPC));
                KeInitializeApc (afdBuffer->Buffer,
                                    PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                                    Irp->ApcEnvironment,
                                    AfdFastTransmitApcKernelRoutine,
                                    AfdFastTransmitApcRundownRoutine,
                                    (PKNORMAL_ROUTINE)-1,
                                    KernelMode,
                                    NULL
                                    );
                if (KeInsertQueueApc (afdBuffer->Buffer,
                                        afdBuffer,
                                        afdBuffer->FileObject,
                                        AfdPriorityBoost)) {
                    //
                    // Success, we are done.
                    //
                    goto exit;
                }
            }

            //
            // Can't queue APC, revert to system worker threads
            //
        }

        ASSERT (afdBuffer->BufferLength>=sizeof(WORK_QUEUE_ITEM));
        ExInitializeWorkItem (
                    (PWORK_QUEUE_ITEM)afdBuffer->Buffer,
                    AfdDoMdlReadComplete,
                    afdBuffer
                    );
        ExQueueWorkItem (afdBuffer->Buffer, DelayedWorkQueue);
    }
    else {

        ASSERT (afdBuffer->Irp==Irp);
        ASSERT (afdBuffer->Mdl->Next == NULL);
        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
        DEREFERENCE_CONNECTION (connection);
    }

exit:
    return status;
}

VOID
AfdFastTransmitApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
/*++

Routine Description:

  Special kernel apc routine. Executed in the context of
  the target thread at APC_LEVEL

Arguments:
    NormalRoutine  - pointer containing address of normal routine (it will
                    be NULL for special kernel APC and not NULL for normal
                    kernel APC)

    SystemArgument1 - pointer to the address of worker routine to execute
    SyetemArgument2 - pointer to the argument to pass to worker routine

Return Value:

    None.

--*/
{
    PAFD_BUFFER     afdBuffer;
    
    PAGED_CODE ();
#if DBG
    try {
#endif
    afdBuffer = *SystemArgument1;
    ASSERT (Apc==afdBuffer->Buffer);
    ASSERT (afdBuffer->FileObject==*SystemArgument2);

    //
    // Normal APC, but we are requested to run in its special
    // routine which avoids raising and lowering IRQL
    //

    ASSERT (*NormalRoutine==(PKNORMAL_ROUTINE)-1);
    *NormalRoutine = NULL;
    AfdDoMdlReadComplete (afdBuffer);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


VOID
AfdFastTransmitApcRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

  APC rundown routine. Executed if APC cannot be delivered for
  some reason (thread exiting).
  We just fall back to system threads to execute the worker

Arguments:

    Apc     - APC structure

Return Value:

    None.

--*/
{
    PAFD_BUFFER                 afdBuffer;

    PAGED_CODE ();
#if DBG
    try {
#endif
    afdBuffer = Apc->SystemArgument1;
    ASSERT (Apc==afdBuffer->Buffer);
    ASSERT (afdBuffer->FileObject==Apc->SystemArgument2);

    //
    // APC could not be run, revert to system worker thread
    //

    ExInitializeWorkItem (
                (PWORK_QUEUE_ITEM)afdBuffer->Buffer,
                AfdDoMdlReadComplete,
                afdBuffer
                );

    ExQueueWorkItem (afdBuffer->Buffer, DelayedWorkQueue);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}

VOID
AfdDoMdlReadComplete (
    PVOID   Context
    )
{
	PAFD_BUFFER		afdBuffer = Context;
    PAFD_CONNECTION connection = afdBuffer->Context;
    NTSTATUS        status;

    PAGED_CODE ();

    //
    // Return mdl to the file system
    //
    status = AfdMdlReadComplete(
        afdBuffer->FileObject,
        afdBuffer->Mdl->Next,
		&afdBuffer->Irp->Overlay.AllocationSize
        );
    if (NT_SUCCESS (status)) {
        //
        // Release file object reference (the AfdMdlReadComplete makes its own
        // reference if it needs to return MDL asynchronously.
        //
        ObDereferenceObject( afdBuffer->FileObject );
        AfdRecordFileDeref();

        afdBuffer->Mdl->Next = NULL;
        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
        DEREFERENCE_CONNECTION (connection);
    }
    else {
        AfdLRMdlReadComplete (&afdBuffer->Header);
    }
}


NTSTATUS
FASTCALL
AfdTransmitFile (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling transmit file IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT endpoint;
    NTSTATUS status;
    AFD_TRANSMIT_FILE_INFO params;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = NULL;
    PAFD_TRANSMIT_PACKETS_ELEMENT  pel;
    BOOLEAN irpQueued;

    PAGED_CODE ();

    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Special hack to let the user mode dll know that it
    // should try SAN provider instead.
    //

    if (IS_SAN_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_TRANSMIT_FILE_INFO32) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }
    else
#endif _WIN64
    {
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_TRANSMIT_FILE_INFO) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }

    //
    // Because we're using type 3 (neither) I/O for this IRP, the I/O
    // system does no verification on the user buffer.  Therefore, we
    // must manually check it for validity inside a try-except block.
    // We also leverage the try-except to validate and lock down the
    // head and/or tail buffers specified by the caller.
    //

    try {


#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_TRANSMIT_FILE_INFO32 pInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            if( Irp->RequestorMode != KernelMode ) {

                //
                // Validate the control buffer.
                //

                ProbeForRead(
                    pInfo,
                    sizeof(AFD_TRANSMIT_FILE_INFO32),
                    PROBE_ALIGNMENT32 (AFD_TRANSMIT_FILE_INFO32)
                    );
            }
            params.Offset = pInfo->Offset;
            params.WriteLength = pInfo->WriteLength;
            params.SendPacketLength = pInfo->SendPacketLength;
            params.FileHandle = pInfo->FileHandle;
            params.Head = pInfo->Head;
            params.HeadLength = pInfo->HeadLength;
            params.Tail = pInfo->Tail;
            params.TailLength = pInfo->TailLength;
            params.Flags = pInfo->Flags;
        }
        else
#endif _WIN64
        {
            if( Irp->RequestorMode != KernelMode ) {
                //
                // Validate the control buffer.
                //

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    sizeof(AFD_TRANSMIT_FILE_INFO),
                    PROBE_ALIGNMENT (AFD_TRANSMIT_FILE_INFO)
                    );
            }

            params = *((PAFD_TRANSMIT_FILE_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        }


        
        //
        // Validate any flags specified in the request.
        // and make sure that file offset is positive (of course if file is specified)
        //

        if ( ((params.Flags &
                 ~(AFD_TF_WRITE_BEHIND | AFD_TF_DISCONNECT | AFD_TF_REUSE_SOCKET | AFD_TF_WORKER_KIND_MASK) )
                     != 0 ) ||
                ((params.Flags & AFD_TF_WORKER_KIND_MASK) == AFD_TF_WORKER_KIND_MASK) ||
                (params.FileHandle!=NULL && params.Offset.QuadPart<0)){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // If transmit worker is not specified, use system default setting
        //
        if ((params.Flags & AFD_TF_WORKER_KIND_MASK)==AFD_TF_USE_DEFAULT_WORKER) {
            params.Flags |= AfdDefaultTransmitWorker;
        }

            
        tpInfo = AfdGetTpInfo (3);
        if (tpInfo==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        tpInfo->ElementCount = 0;

        tpInfo->SendPacketLength = params.SendPacketLength;
        if (tpInfo->SendPacketLength==0)
            tpInfo->SendPacketLength = AfdTransmitIoLength;
        //
        // If the caller specified head and/or tail buffers, probe and
        // lock the buffers so that we have MDLs we can use to send the
        // buffers.
        //

        if ( params.HeadLength > 0 ) {
            pel = &tpInfo->ElementArray[tpInfo->ElementCount++];
            pel->Buffer = params.Head;
            pel->Length = params.HeadLength;
            pel->Flags = TP_MEMORY;

            if (params.Flags & AFD_TF_USE_SYSTEM_THREAD) {
                pel->Flags |= TP_MDL;
                pel->Mdl = IoAllocateMdl(
                                        params.Head,
                                        params.HeadLength,
                                        FALSE,         // SecondaryBuffer
                                        TRUE,          // ChargeQuota
                                        NULL           // Irp
                                        );
                if ( pel->Mdl == NULL ) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;
                }

                MmProbeAndLockPages( pel->Mdl, Irp->RequestorMode, IoReadAccess );
            }
        }

        if (params.FileHandle!=NULL) {
            pel = &tpInfo->ElementArray[tpInfo->ElementCount++];
            pel->Flags = TP_FILE;
            pel->FileOffset = params.Offset;
            
            //
            // Get a referenced pointer to the file object for the file that
            // we're going to transmit.  This call will fail if the file handle
            // specified by the caller is invalid.
            //

            status = ObReferenceObjectByHandle(
                         params.FileHandle,
                         FILE_READ_DATA,
                         *IoFileObjectType,
                         Irp->RequestorMode,
                         (PVOID *)&pel->FileObject,
                         NULL
                         );
            if ( !NT_SUCCESS(status) ) {
                //
                // Unbump element count, so that uninitialied memory
                // is NOT improperly dereferenced in cleanup.
                //
                tpInfo->ElementCount -= 1;
                //
                // Tell the caller that we encountered an error
                // when accessing file not socket.
                //
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                    }
                    else {
                        *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                    }
                }
                goto complete;
            }

            AfdRecordFileRef();


            //
            // Use pre-allocated buffers by default when
            // file is not cached
            //
            if (params.SendPacketLength==0 && !AFD_USE_CACHE(pel->FileObject)) {
                tpInfo->SendPacketLength = AfdLargeBufferSize;
            }

            if ( (pel->FileObject->Flags & FO_SYNCHRONOUS_IO) &&
                     (pel->FileOffset.QuadPart == 0) ) {
                //
                // Use current offset if file is opened syncronously
                // and offset is not specified.
                //

                pel->FileOffset = pel->FileObject->CurrentByteOffset;
            }

            if ( params.WriteLength.QuadPart == 0 ) {
                //
                // Length was not specified, figure out the
                // size of the entire file
                //

                FILE_STANDARD_INFORMATION fileInfo;
                IO_STATUS_BLOCK ioStatusBlock;

                status = ZwQueryInformationFile(
                             params.FileHandle,
                             &ioStatusBlock,
                             &fileInfo,
                             sizeof(fileInfo),
                             FileStandardInformation
                             );
                if ( !NT_SUCCESS(status) ) {
                    //
                    // Tell the caller that we encountered an error
                    // when accessing file not socket.
                    //
                    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                        if (Irp->RequestorMode != KernelMode) {
                            ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                        }
                        else {
                            *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                        }
                    }
                    goto complete;
                }

                //
                // Make sure that offset is within the file
                //
                if (pel->FileOffset.QuadPart<0 
                                ||
                        pel->FileOffset.QuadPart>fileInfo.EndOfFile.QuadPart 
                                ||
                        (fileInfo.EndOfFile.QuadPart
                                - pel->FileOffset.QuadPart>MAXLONG)) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;

                }
                pel->Length = (ULONG)(fileInfo.EndOfFile.QuadPart - pel->FileOffset.QuadPart);
            }
            else if (params.WriteLength.QuadPart<=MAXLONG &&
                        pel->FileOffset.QuadPart>=0) {
                pel->Length = (ULONG)params.WriteLength.QuadPart;
            }
            else {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }
        }


        if ( params.TailLength > 0 ) {

            pel = &tpInfo->ElementArray[tpInfo->ElementCount++];
            pel->Buffer = params.Tail;
            pel->Length = params.TailLength;
            pel->Flags = TP_MEMORY;

            if (params.Flags & AFD_TF_USE_SYSTEM_THREAD) {
                pel->Flags |= TP_MDL;
                pel->Mdl = IoAllocateMdl(
                                        params.Tail,
                                        params.TailLength,
                                        FALSE,         // SecondaryBuffer
                                        TRUE,          // ChargeQuota
                                        NULL           // Irp
                                        );
                if ( pel->Mdl == NULL ) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;
                }

                MmProbeAndLockPages( pel->Mdl, Irp->RequestorMode, IoReadAccess );
            }
        }

        IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags = params.Flags;

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto complete;
    }




    if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }



    if ( endpoint->Type != AfdBlockTypeVcConnecting ||
             endpoint->State != AfdEndpointStateConnected ) {
        status = STATUS_INVALID_CONNECTION;
        goto complete_state_change;
    }


    //
    // Connection endpoint, get connection file object and device
    //
    tpInfo->TdiFileObject = endpoint->Common.VcConnecting.Connection->FileObject;
    tpInfo->TdiDeviceObject = endpoint->Common.VcConnecting.Connection->DeviceObject;
    //
    // Setting AFD_TF_REUSE_SOCKET implies that a disconnect is desired.
    // Also, setting this flag means that no more I/O is legal on the
    // endpoint until the transmit request has been completed, so
    // set up the endpoint's state so that I/O fails.
    //

    if ( (IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_REUSE_SOCKET) != 0 ) {
        IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags |= AFD_TF_DISCONNECT;
        endpoint->State = AfdEndpointStateTransmitClosing;
    }
    UPDATE_TPACKETS2 (Irp, "Connection object handle: %lx",
                                HandleToUlong(endpoint->Common.VcConnecting.Connection->Handle));
    //
    // Save tpacket info in the IRP
    //
    Irp->AssociatedIrp.SystemBuffer = tpInfo;

    //
    // Clear the Flink in the IRP to indicate this IRP is not queued.
    // Blink is cleared to indicate that IRP was counted towards
    // active maximum.
    //

    Irp->Tail.Overlay.ListEntry.Flink = NULL;
    Irp->Tail.Overlay.ListEntry.Blink = NULL;

    //
    // Initialize the IRP result fields
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // We are going to pend this IRP
    //
    IoMarkIrpPending( Irp );

    //
    // Initialize queuing and state information.
    //

    InitializeListHead (&AFD_GET_TPIC(Irp)->EndpQueueEntry);
    AFD_GET_TPIC(Irp)->ReferenceCount = 1;
    AFD_GET_TPIC(Irp)->StateFlags = AFD_TP_WORKER_SCHEDULED;

    irpQueued = (InterlockedCompareExchangePointer ((PVOID *)&endpoint->Irp,
                                                Irp,
                                                NULL)!=NULL) &&
                AfdEnqueueTPacketsIrp (endpoint, Irp);


    //
    // If disconnect is not specified, end state change.
    // This will permit queuing of another transmit IRP
    //

    if (!(IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags & AFD_TF_DISCONNECT)) {
        AFD_END_STATE_CHANGE (endpoint);
    }

    IoSetCancelRoutine( Irp, AfdCancelTPackets );
    //
    //  Check to see if this Irp has been cancelled.
    //

    if ( !Irp->Cancel ) {
        if (irpQueued) {
            DEREFERENCE_TPACKETS (Irp);
        }
        else {
            //
            // Determine if we can really start this file transmit now. If we've
            // exceeded the configured maximum number of active TransmitFile/Packets
            // requests, then append this IRP to the TransmitFile/Packets queue and set
            // a flag in the transmit info structure to indicate that this IRP
            // is queued.
            //

            if( AfdMaxActiveTransmitFileCount == 0 || !AfdQueueTransmit (Irp)) {
                //
                // Start I/O
                //
                AfdTPacketsWorker (Irp);
            }
        }


    }
    else {
        //
        // Abort the request
        // Note that neither cancel nor endpoint cleanup can complete 
        // the IRP since we hold the reference to the tpInfo structure.
        //
        AfdAbortTPackets (Irp, STATUS_CANCELLED);
        
        //
        // Remove the initial reference and force completion.
        //
        DEREFERENCE_TPACKETS (Irp);
    }

    return STATUS_PENDING;


complete_state_change:

    ASSERT ( tpInfo != NULL );
    ASSERT ( endpoint->Irp != Irp );
    AFD_END_STATE_CHANGE (endpoint);

complete:

    if (tpInfo!=NULL) {
        AfdReturnTpInfo (tpInfo);
    }

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTransmitPackets: Failing Irp-%p,endpoint-%p,status-%lx\n",
                    Irp,endpoint,status));
    }
    //
    // Complete the request.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdTransmitFile


NTSTATUS
FASTCALL
AfdSuperDisconnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling transmit file IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT endpoint;
    NTSTATUS status;
    AFD_SUPER_DISCONNECT_INFO params;
    BOOLEAN irpQueued;

    PAGED_CODE ();

    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Special hack to let the user mode dll know that it
    // should try SAN provider instead.
    //

    if (IS_SAN_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

    //
    // Because we're using type 3 (neither) I/O for this IRP, the I/O
    // system does no verification on the user buffer.  Therefore, we
    // must manually check it for validity inside a try-except block.
    // We also leverage the try-except to validate and lock down the
    // head and/or tail buffers specified by the caller.
    //

    try {


#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_SUPER_DISCONNECT_INFO32 pInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            if( Irp->RequestorMode != KernelMode ) {

                //
                // Validate the control buffer.
                //

                ProbeForRead(
                    pInfo,
                    sizeof(AFD_SUPER_DISCONNECT_INFO32),
                    PROBE_ALIGNMENT32 (AFD_SUPER_DISCONNECT_INFO32)
                    );
            }
            params.Flags = ((PAFD_SUPER_DISCONNECT_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
        }
        else
#endif _WIN64
        {
            if( Irp->RequestorMode != KernelMode ) {
                //
                // Validate the control buffer.
                //

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    sizeof(AFD_SUPER_DISCONNECT_INFO),
                    PROBE_ALIGNMENT (AFD_SUPER_DISCONNECT_INFO)
                    );
            }

            params = *((PAFD_SUPER_DISCONNECT_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        }

       
        //
        // Validate any flags specified in the request.
        // and make sure that file offset is positive (of course if file is specified)
        //

        if ( (params.Flags & (~AFD_TF_REUSE_SOCKET)) != 0 ){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto complete;
    }

    //
    // Store disconnect parameters/flags in the IRP.
    //
    IrpSp->Parameters.AfdTPacketsInfo.AfdTPacketsFlags = 
                        params.Flags | 
                            AFD_TF_DISCONNECT |     // Implied in the API
                            AFD_TF_USE_KERNEL_APC;  // Just need to start when
                                                    // in the endpoint queue.


    if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }



    if ( endpoint->Type != AfdBlockTypeVcConnecting ||
             endpoint->State != AfdEndpointStateConnected ) {
        status = STATUS_INVALID_CONNECTION;
        goto complete_state_change;
    }


    //
    // Setting AFD_TF_REUSE_SOCKET implies that a disconnect is desired.
    // Also, setting this flag means that no more I/O is legal on the
    // endpoint until the transmit request has been completed, so
    // set up the endpoint's state so that I/O fails.
    //

    if ( (params.Flags & AFD_TF_REUSE_SOCKET) != 0 ) {
        endpoint->State = AfdEndpointStateTransmitClosing;
    }


    //
    // Save tpacket info in the IRP
    //
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // Clear the Flink in the IRP to indicate this IRP is not queued.
    // Blink is set to indicate that IRP was not counted towards active maximum.
    // (we never count disconnect ex IRPs, event on workstation).
    //

    Irp->Tail.Overlay.ListEntry.Flink = NULL;
    Irp->Tail.Overlay.ListEntry.Blink = (PVOID)1;

    //
    // Initialize the IRP result fields
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // We are going to pend this IRP
    //
    IoMarkIrpPending( Irp );

    InitializeListHead (&AFD_GET_TPIC(Irp)->EndpQueueEntry);
    AFD_GET_TPIC(Irp)->ReferenceCount = 1;
    AFD_GET_TPIC(Irp)->StateFlags = AFD_TP_WORKER_SCHEDULED;


    irpQueued = (InterlockedCompareExchangePointer ((PVOID *)&endpoint->Irp,
                                                Irp,
                                                NULL)!=NULL) &&
                AfdEnqueueTPacketsIrp (endpoint, Irp);


    IoSetCancelRoutine( Irp, AfdCancelTPackets );
    //
    //  Check to see if this Irp has been cancelled.
    //

    if ( !Irp->Cancel ) {
        if (irpQueued) {
            DEREFERENCE_TPACKETS (Irp);
        }
        else {
            //
            // Start I/O
            //
            AfdPerformSuperDisconnect (Irp);
        }

    }
    else {
        //
        // Abort the request
        // Note that neither cancel nor endpoint cleanup can complete 
        // the IRP since we hold the reference to the tpInfo structure.
        //
        AfdAbortTPackets (Irp, STATUS_CANCELLED);
        
        //
        // Remove the initial reference and force completion.
        //
        DEREFERENCE_TPACKETS (Irp);
    }


    return STATUS_PENDING;


complete_state_change:

    ASSERT ( endpoint->Irp != Irp );
    AFD_END_STATE_CHANGE (endpoint);

complete:

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSuperDisconnect: Failing Irp-%p,endpoint-%p,status-%lx\n",
                    Irp,endpoint,status));
    }
    //
    // Complete the request.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdSuperDisconnect


VOID
AfdPerformSuperDisconnect (
    PIRP    TpIrp
    )
/*++

Routine Description:

    DisconnectEx engine
Arguments:

    TpIrp - pointer to TransmitPackets Irp for the request

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    PAFD_ENDPOINT       endpoint = irpSp->FileObject->FsContext;
    NTSTATUS            status;

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    status = AfdBeginDisconnect(
              endpoint,
              NULL,
              NULL
              );

    if (NT_SUCCESS (status)) {
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSuperDisconnectWorker: Initiated disconnect, tpIrp-%p,status-%lx\n",
                        TpIrp, status));
        }
    }
    else {
        //
        // Disconnect failed, we'll have to abort below.
        //
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSuperDisconnectWorker: TpInfo-%p, begin discon failed: %lx\n",
                        TpIrp, status));
        }
        AfdAbortTPackets (TpIrp, status);
    }

    DEREFERENCE_TPACKETS (TpIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\addr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    addr.c

Abstract:

    Implements the addr command.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
// Public functions.
//

DECLARE_API( addr )

/*++

Routine Description:

    Dumps the TRANSPORT_ADDRESS structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    UCHAR transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64 address = 0;
    ULONG result;
    INT     i;
    USHORT length;
    CHAR    expr[256];
    PCHAR       argp;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    //
    // Snag the address from the command line.
    //
    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }

        argp+=i;
        address = GetExpression (expr);

        result = GetFieldValue (address, 
                            "AFD!TRANSPORT_ADDRESS",
                            "Address[0].AddressLength",
                            length);
        if (result!=0) {
            dprintf("\naddr: Could not read length of TRANSPORT_ADDRESS @ %p, err: %ld\n",
                        address, result);
            continue;
        }

        length = (USHORT)FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].Address[length]);

        if (!ReadMemory (address,
                            transportAddress,
                            length < sizeof (transportAddress)
                                ? length
                                : sizeof (transportAddress),
                            &result)) {
            dprintf("\naddr: Could not read TRANSPORT_ADDRESS @ %p (%ld bytes)\n",
                        address, length);
            continue;
        }

        if (Options & AFDKD_BRIEF_DISPLAY) {
            dprintf ("\n%s", TransportAddressToString (
                                    (PTRANSPORT_ADDRESS)transportAddress,
                                    address));
        }
        else {
            DumpTransportAddress(
                "",
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
    }

    dprintf ("\n");

}   // addr

DECLARE_API( addrlist )

/*++

Routine Description:

    Dumps the list of addresses registered by the TDI transports,

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64     address, listHead;
    ULONG       result;
    LIST_ENTRY64 listEntry;
    ULONG64     nextEntry;
    ULONG64     nameAddress;
    WCHAR       deviceName[MAX_PATH];
    UCHAR       transportAddress[MAX_TRANSPORT_ADDR];
    USHORT      length;
    PCHAR       argp;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER);
    }

    address = listHead = GetExpression( "afd!AfdAddressEntryList" );
    if( address == 0 ) {

        dprintf( "\naddrlist: Could not find afd!AfdEndpointlistHead\n" );
        return;

    }

    if( !ReadListEntry(
            listHead,
            &listEntry) ) {
        dprintf(
            "\naddrlist: Could not read afd!AfdAddressEntryList @ %p\n",
            listHead
            );
        return;

    }

    nextEntry = listEntry.Flink;

    while( nextEntry != listHead ) {

        if (nextEntry==0) {
            dprintf ("\naddrlist: Flink is NULL, last entry: %p\n", address);
            break;
        }

        if( CheckControlC() ) {

            break;

        }


        address = nextEntry-AddressEntryLinkOffset;

        result = (ULONG)InitTypeRead (address, AFD!AFD_ADDRESS_ENTRY);
        if (result!=0) {
            dprintf(
                "\naddrlist: Could not read AFD_ADDRESS_ENTRY @ %p\n",
                address
                );
            break;
        }
        nextEntry = ReadField (AddressListLink.Flink);
        nameAddress = ReadField (DeviceName.Buffer);
        length = (USHORT)ReadField (DeviceName.Length);

        if (!ReadMemory (nameAddress,
                        deviceName,
                        length < sizeof (deviceName)-1
                            ? length
                            : sizeof (deviceName)-1,
                            &result)) {
            dprintf(
                "\naddrlist: Could not read DeviceName for address entry @ %p\n",
                address
                );
            continue;
        }
        deviceName[result/2+1] = 0;
        length = (USHORT)ReadField (Address.AddressLength);
        length = (USHORT)FIELD_OFFSET (TA_ADDRESS, Address[length]);
        
        if (!ReadMemory (address+AddressEntryAddressOffset,
                            transportAddress+FIELD_OFFSET(TRANSPORT_ADDRESS, Address),
                            length < sizeof (transportAddress)-FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                                ? length
                                : sizeof (transportAddress)-FIELD_OFFSET(TRANSPORT_ADDRESS, Address),
                            &result)) {
            dprintf("\naddrlist: Could not read TRANSPORT_ADDRESS for address entry @ %p (%d bytes)\n",
                        address, length);
            continue;
        }

        if (Options & AFDKD_BRIEF_DISPLAY) {
            dprintf (
                IsPtr64 ()
                    ? "\n%011.011p %-37.37ls %-32.32s"
                    : "\n%008.008p %-37.37ls %-32.32s",
                    DISP_PTR(address),
                    &deviceName[sizeof("\\Device\\")-1],
                    TransportAddressToString (
                                (PTRANSPORT_ADDRESS)transportAddress,
                                address + 
                                    AddressEntryAddressOffset - 
                                    FIELD_OFFSET(TRANSPORT_ADDRESS, Address))
                    );


        }
        else {
            dprintf ("\nAddress List Entry @ %p\n", address);
            dprintf ("    DeviceName =    %ls\n", deviceName);

            DumpTransportAddress(
                "    ",
                (PTRANSPORT_ADDRESS)transportAddress,
                address+AddressEntryAddressOffset-FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                );
        }
    }
    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ADDRLIST_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

}





DECLARE_API( tranlist )

/*++

Routine Description:

    Dumps the list of transports which have open sockets associated with them.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address;
    ULONG result;
    LIST_ENTRY64 listEntry;
    ULONG64 nextEntry;
    ULONG64 listHead;
    PAFDKD_TRANSPORT_INFO transportInfo;

    PCHAR       argp;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER);
    }

    listHead = address = GetExpression( "afd!AfdTransportInfoListHead" );
    if( listHead == 0 ) {

        dprintf( "\ntranlist: Could not find afd!AfdTransportInfoListHead\n" );
        return;

    }

    if( !ReadListEntry(
            listHead,
            &listEntry) ) {
        dprintf(
            "\ntranlist: Could not read afd!AfdTransportInfoListHead @ %p\n",
            listHead
            );
        return;

    }

    //
    // Free the old list
    //
    while (!IsListEmpty (&TransportInfoList)) {
        PLIST_ENTRY  listEntry;
        listEntry = RemoveHeadList (&TransportInfoList);
        transportInfo = CONTAINING_RECORD (listEntry,
                                AFDKD_TRANSPORT_INFO,
                                Link);
        RtlFreeHeap (RtlProcessHeap (), 0, transportInfo);
    }

    nextEntry = listEntry.Flink;

    while( nextEntry != listHead ) {


        if (nextEntry==0) {
            dprintf ("\ntranlist: Flink is NULL, last entry: %p\n", address);
            break;
        }

        if( CheckControlC() ) {

            break;

        }

        address = nextEntry-TransportInfoLinkOffset;

        result = (ULONG)InitTypeRead (address, AFD!AFD_TRANSPORT_INFO);

        if (result!=0) {
            dprintf(
                "\ntranlist: Could not read AFD_TRANSPORT_INFO @ %p\n",
                address
                );
            break;
        }
        nextEntry = ReadField (TransportInfoListEntry.Flink);

        transportInfo = ReadTransportInfo (address);
        if (transportInfo!=NULL) {
            InsertHeadList (&TransportInfoList, &transportInfo->Link);
            if (Options & AFDKD_BRIEF_DISPLAY) {
                DumpTransportInfoBrief (transportInfo);
            }
            else {
                DumpTransportInfo (transportInfo);
            }
        }
        else
            break;
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_TRANSPORT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\afdutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    afdutil.c

Abstract:

    Utility functions for dumping various AFD structures.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private constants.
//

//
//  Private globals.
//

PSTR WeekdayNames[] =
     {
         "Sunday",
         "Monday",
         "Tuesday",
         "Wednesday",
         "Thursday",
         "Friday",
         "Saturday"
     };

PSTR MonthNames[] =
     {
         "",
         "January",
         "February",
         "March",
         "April",
         "May",
         "June",
         "July",
         "August",
         "September",
         "October",
         "November",
         "December"
     };


//
//  Private prototypes.
//

PSTR
StructureTypeToString(
    USHORT Type
    );

PSTR
StructureTypeToStringBrief (
    USHORT Type
    );

PSTR
BooleanToString(
    BOOLEAN Flag
    );

PSTR
EndpointStateToString(
    UCHAR State
    );

PSTR
EndpointStateToStringBrief(
    UCHAR State
    );

PSTR
EndpointStateFlagsToString(
    PAFD_ENDPOINT   Endpoint
    );

PSTR
EndpointTypeToString(
        ULONG TypeFlags
    );

PSTR
ConnectionStateToString(
    USHORT State
    );

PSTR
ConnectionStateToStringBrief(
    USHORT State
    );

PSTR
ConnectionStateFlagsToString(
    PAFD_CONNECTION   Connection
    );

PSTR
TranfileFlagsToString(
    ULONG   Flags,
    ULONG   StateFlags
    );

PSTR
BufferFlagsToString(
    PAFD_BUFFER_HEADER   AfdBuffer
    );

PSTR
SystemTimeToString(
    LONGLONG Value
    );

PSTR
GroupTypeToString(
    AFD_GROUP_TYPE GroupType
    );

VOID
DumpReferenceDebug(
    PAFD_REFERENCE_DEBUG ReferenceDebug,
    ULONG CurrentSlot
    );

BOOL
IsTransmitIrpBusy(
    PIRP Irp
    );


PSTR
ListToString (
    ULONG64 ListHead,
    ULONG64 Flink
    );
#define LIST_TO_STRING(_h,_f)   ListToString(_h,ReadField(_f))

PSTR
TdiServiceFlagsToString(
    ULONG   Flags
    );

//
//  Public functions.
//

VOID
DumpAfdEndpoint(
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified AFD_ENDPOINT structure.

Arguments:

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    AFD_ENDPOINT    endpoint;
    ULONG64         address;
    ULONG           length;
    UCHAR           transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64         irp;
    ULONG           result;


    dprintf(
        "\nAFD_ENDPOINT @ %p:\n",
        ActualAddress
        );

    dprintf(
        "    ReferenceCount               = %ld\n",
        (ULONG)ReadField(ReferenceCount)
        );

    endpoint.Type=(USHORT)ReadField (Type);
    dprintf(
        "    Type                         = %04X (%s)\n",
        endpoint.Type,
        StructureTypeToString( endpoint.Type )
        );

    endpoint.State=(UCHAR)ReadField (State);
    dprintf(
        "    State                        = %02X (%s)\n",
        endpoint.State,
        EndpointStateToString(endpoint.State)
        );

    if ((endpoint.StateChangeInProgress=(ULONG)ReadField (StateChangeInProgress))!=0) {
        dprintf(
            "    State changing to            = %02X (%s)\n",
            endpoint.StateChangeInProgress,
            EndpointStateToString( (UCHAR)endpoint.StateChangeInProgress )
            );
    }


    endpoint.TdiServiceFlags=(ULONG)ReadField (TdiServiceFlags);
    dprintf(
        "    TdiTransportFlags            = %08lx (",
        endpoint.TdiServiceFlags
        );
    if (IS_TDI_ORDERLY_RELEASE(&endpoint))
        dprintf (" OrdRel");
    if (IS_TDI_DELAYED_ACCEPTANCE(&endpoint))
        dprintf (" DelAcc");
    if (IS_TDI_EXPEDITED(&endpoint))
        dprintf (" Expd");
    if (IS_TDI_BUFFERRING(&endpoint))
        dprintf (" Buff");
    if (IS_TDI_MESSAGE_MODE(&endpoint))
        dprintf (" Msg");
    if (IS_TDI_DGRAM_CONNECTION(&endpoint))
        dprintf (" DgramCon");
    if (IS_TDI_FORCE_ACCESS_CHECK(&endpoint))
        dprintf (" AccChk");
    dprintf (" )\n");

    dprintf(
        "    StateFlags                   = %08X (",
        endpoint.EndpointStateFlags = (ULONG)ReadField (EndpointStateFlags)
        );

    if (endpoint.Listening)
        dprintf (" Listn");
    if (endpoint.DelayedAcceptance)
        dprintf (" DelAcc");
    if (endpoint.NonBlocking)
        dprintf (" NBlock");
    if (endpoint.InLine)
        dprintf (" InLine");
    if (endpoint.EndpointCleanedUp)
        dprintf (" Clnd-up");
    if (endpoint.PollCalled)
        dprintf (" Polled");
    if (endpoint.RoutingQueryReferenced)
        dprintf (" RtQ");
    if (endpoint.DisableFastIoSend)
        dprintf (" -FastSnd");
    if (endpoint.EnableSendEvent)
        dprintf (" +SndEvt");
    if (endpoint.DisableFastIoRecv)
        dprintf (" -FastRcv");
    dprintf (" )\n");


    dprintf(
        "    TransportInfo                = %p\n",
        address = ReadField (TransportInfo)
        );

    if (address!=0) {
        PAFDKD_TRANSPORT_INFO transportInfo;
        PLIST_ENTRY           listEntry;

        listEntry = TransportInfoList.Flink;
        while (listEntry!=&TransportInfoList) {
            transportInfo = CONTAINING_RECORD (listEntry, AFDKD_TRANSPORT_INFO, Link);
            if (transportInfo->ActualAddress==address)
                break;
            listEntry = listEntry->Flink;
        }

        if (listEntry==&TransportInfoList) {
            transportInfo = ReadTransportInfo (address);
            if (transportInfo!=NULL) {
                InsertHeadList (&TransportInfoList, &transportInfo->Link);
            }
        }

        if (transportInfo!=NULL) {
            dprintf(
                "        TransportDeviceName      = %ls\n",
                transportInfo->DeviceName
                );
        }

    }

    dprintf(
        "    AddressHandle                = %p\n",
        ReadField (AddressHandle)
        );

    dprintf(
        "    AddressFileObject            = %p\n",
        ReadField (AddressFileObject)
        );

    dprintf(
        "    AddressDeviceObject          = %p\n",
        ReadField (AddressDeviceObject)
        );

    dprintf(
        "    AdminAccessGranted           = %s\n",
        BooleanToString( (BOOLEAN)ReadField (AdminAccessGranted))
        );

    switch( endpoint.Type ) {

    case AfdBlockTypeVcConnecting :

        address = ReadField (Common.VirtualCircuit.Connection);
        dprintf(
            "    Connection                   = %p\n",
            address!=0
                ? address
                : (((endpoint.State==AfdEndpointStateClosing ||
                            endpoint.State==AfdEndpointStateTransmitClosing) &&
                        ((address = ReadField (WorkItem.Context))!=0))
                    ? address
                    : 0)
            );

        dprintf(
            "    ListenEndpoint               = %p\n",
            ReadField (Common.VirtualCircuit.ListenEndpoint)
            );

        dprintf(
            "    ConnectDataBuffers           = %p\n",
            ReadField (Common.VirtualCircuit.ConnectDataBuffers)
            );
        break;

    case AfdBlockTypeVcBoth :
        dprintf(
            "    Connection                   = %p\n",
            ReadField (Common.VirtualCircuit.Connection)
            );

        dprintf(
            "    ConnectDataBuffers           = %p\n",
            ReadField (Common.VirtualCircuit.ConnectDataBuffers)
            );

        // Skip through to listening endpoint

    case AfdBlockTypeVcListening :

        if (IS_DELAYED_ACCEPTANCE_ENDPOINT(&endpoint)) {
            dprintf(
                "    ListenConnectionListHead @ %s\n",
                LIST_TO_STRING(
                    ActualAddress+ListenConnListOffset,
                    Common.VirtualCircuit.Listening.ListenConnectionListHead.Flink
                    )
                );

        }
        else {
            dprintf(
                "    FreeConnectionListHead       @ %p(%d)\n",
                ActualAddress + FreeConnListOffset,
                (USHORT)ReadField (Common.VirtualCircuit.Listening.FreeConnectionListHead.Depth)
                );

            dprintf(
                "    AcceptExIrpListHead          @ %p(%d)\n",
                ActualAddress + PreaccConnListOffset,
                (USHORT)ReadField (Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead.Depth)
                );
        }

        dprintf(
            "    UnacceptedConnectionListHead %s\n",
            LIST_TO_STRING(
                ActualAddress + UnacceptedConnListOffset,
                Common.VirtualCircuit.Listening.UnacceptedConnectionListHead.Flink)
            );


        dprintf(
            "    ReturnedConnectionListHead   %s\n",
            LIST_TO_STRING(
                ActualAddress + ReturnedConnListOffset,
                Common.VirtualCircuit.Listening.ReturnedConnectionListHead.Flink)
            );

        dprintf(
            "    ListeningIrpListHead         %s\n",
            LIST_TO_STRING(
                ActualAddress + ListenIrpListOffset,
                Common.VirtualCircuit.Listening.ListeningIrpListHead.Flink)
            );

        dprintf(
            "    FailedConnectionAdds         = %ld\n",
            (LONG)ReadField (Common.VirtualCircuit.Listening.FailedConnectionAdds)
            );

        dprintf(
            "    TdiAcceptPendingCount        = %ld\n",
            (LONG)ReadField (Common.VirtualCircuit.Listening.TdiAcceptPendingCount)
            );


        dprintf(
            "    MaxCachedConnections         = %ld\n",
            (USHORT)ReadField (Common.VirtualCircuit.Listening.MaxExtraConnections)
            );


        dprintf(
            "    ConnectionSequenceNumber     = %ld\n",
            (LONG)ReadField (Common.VirtualCircuit.ListeningSequence)
            );


        dprintf(
            "    BacklogReplenishActive       = %s\n",
            BooleanToString (
                (BOOLEAN)ReadField (Common.VirtualCircuit.Listening.BacklogReplenishActive))
            );

        dprintf(
    
            "    EnableDynamicBacklog         = %s\n",
            BooleanToString (
                (BOOLEAN)(LONG)ReadField (Common.VirtualCircuit.Listening.EnableDynamicBacklog))
            );

        break;

    case AfdBlockTypeDatagram :

        dprintf(
            "    RemoteAddress                = %p\n",
            address = ReadField (Common.Datagram.RemoteAddress)
            );

        dprintf(
            "    RemoteAddressLength          = %lu\n",
            length=(ULONG)ReadField (Common.Datagram.RemoteAddressLength)
            );

        if( address!=0 ) {

            if (ReadMemory (address,
                            transportAddress,
                            length<sizeof (transportAddress) 
                                ? length
                                : sizeof (transportAddress),
                                &length)) {
                DumpTransportAddress(
                    "    ",
                    (PTRANSPORT_ADDRESS)transportAddress,
                    address
                    );
            }
            else {
                dprintf ("\nDumpAfdEndpoint: Could not read transport address @ %p\n", address);
            }

        }

        dprintf(
            "    ReceiveIrpListHead           %s\n",
            LIST_TO_STRING(
                ActualAddress + DatagramRecvListOffset,
                Common.Datagram.ReceiveIrpListHead.Flink)
            );


        dprintf(
            "    PeekIrpListHead              %s\n",
            LIST_TO_STRING(
                ActualAddress + DatagramPeekListOffset,
                Common.Datagram.PeekIrpListHead.Flink)
            );


        dprintf(
            "    ReceiveBufferListHead        %s\n",
            LIST_TO_STRING(
                ActualAddress + DatagramBufferListOffset,
                Common.Datagram.ReceiveBufferListHead.Flink)
            );


        dprintf(
            "    BufferredReceiveBytes        = %08lx\n",
            (ULONG)ReadField (Common.Datagram.BufferredReceiveBytes)
            );

        dprintf(
            "    BufferredReceiveCount        = %04X\n",
            (ULONG)ReadField (Common.Datagram.BufferredReceiveCount)
            );

        dprintf(
            "    MaxBufferredReceiveBytes     = %08lx\n",
            (ULONG)ReadField (Common.Datagram.MaxBufferredReceiveBytes)
            );


        dprintf(
            "    BufferredSendBytes           = %08lx\n",
            (ULONG)ReadField (Common.Datagram.BufferredSendBytes)
            );

        dprintf(
            "    MaxBufferredSendBytes        = %08lx\n",
            (ULONG)ReadField (Common.Datagram.MaxBufferredSendBytes)
            );

        dprintf(
            "    CircularQueueing             = %s\n",
            BooleanToString(
                (BOOLEAN)ReadField (Common.Datagram.CircularQueueing ))
            );

        dprintf(
            "    HalfConnect                  = %s\n",
            BooleanToString( 
                (BOOLEAN)ReadField (Common.Datagram.HalfConnect))
            );

        dprintf(
            "    PacketsDropped due to          %s%s%s%s\n",
            ReadField (Common.Datagram.AddressDrop)
                    ? "source address, "
                    : "",
            ReadField (Common.Datagram.ResourceDrop)
                    ? "out of memory, "
                    : "",
            ReadField (Common.Datagram.BufferDrop)
                    ? "SO_RCVBUF setting, "
                    : "",
            ReadField (Common.Datagram.ErrorDrop)
                    ? "transport error"
                    : ""
            );
        break;

    }

    dprintf(
        "    DisconnectMode               = %08lx\n",
        (ULONG)ReadField (DisconnectMode)
        );

    dprintf(
        "    OutstandingIrpCount          = %08lx\n",
        (ULONG)ReadField (OutstandingIrpCount)
        );

    dprintf(
        "    LocalAddress                 = %p\n",
        address = ReadField (LocalAddress)
        );

    dprintf(
        "    LocalAddressLength           = %08lx\n",
        length = (ULONG)ReadField (LocalAddressLength)
        );

    if (address!=0) {
        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            DumpTransportAddress(
                "    ",
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            dprintf ("\nDumpAfdEndpoint: Could not read transport address @ %p\n", address);
        }
    }

    dprintf(
        "    Context                      = %p\n",
        ReadField (Context)
        );

    dprintf(
        "    ContextLength                = %08lx\n",
        (ULONG)ReadField (ContextLength)
        );

    dprintf(
        "    OwningProcess                = %p\n",
        ReadField (OwningProcess)
        );

    irp = ReadField (Irp);
    if (irp!=0) {
        if (endpoint.State==AfdEndpointStateConnected ||
                endpoint.State==AfdEndpointStateTransmitClosing) {
            ULONG64 tpInfo;
            dprintf(
                "    Transmit Irp                 = %p",
                irp);
            result = GetFieldValue (
                                irp,
                                "NT!_IRP",
                                "AssociatedIrp.SystemBuffer",
                                tpInfo);
            if (result==0) {
                dprintf (" (TPInfo @ %p)\n", tpInfo);
            }
            else {
                dprintf ("\nDumpAfdEndpoint: Could not read Irp's system buffer, err: %d\n",
                    result);
            }
        }
        else {
            dprintf(
                "    Super Accept Irp             = %p\n",
                irp
                );
        }
    }

    dprintf(
        "    RoutingNotificationList      %s\n",
        LIST_TO_STRING(
                ActualAddress + RoutingNotifyListOffset,
                RoutingNotifications.Flink)
        );



    dprintf(
        "    RequestList                  %s\n",
        LIST_TO_STRING(
                ActualAddress + RequestListOffset,
                RequestList.Flink)
        );


    dprintf(
        "    EventObject                  = %p\n",
        ReadField (EventObject)
        );

    dprintf(
        "    EventsEnabled                = %08lx\n",
        (ULONG)ReadField (EventsEnabled)
        );

    dprintf(
        "    EventsActive                 = %08lx\n",
        (ULONG)ReadField (EventsActive)
        );

    dprintf(
        "    EventStatus (non-zero only)  =");
    ReadMemory (ActualAddress+EventStatusOffset,
                    &endpoint.EventStatus,
                    sizeof (endpoint.EventStatus),
                    &length);
    if (endpoint.EventStatus[AFD_POLL_RECEIVE_BIT]!=0) {
        dprintf (" recv:%lx", endpoint.EventStatus[AFD_POLL_RECEIVE_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_RECEIVE_EXPEDITED_BIT]!=0) {
        dprintf (" rcv exp:%lx", endpoint.EventStatus[AFD_POLL_RECEIVE_EXPEDITED_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_SEND_BIT]!=0) {
        dprintf (" send:%lx", endpoint.EventStatus[AFD_POLL_SEND_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_DISCONNECT_BIT]!=0) {
        dprintf (" disc:%lx", endpoint.EventStatus[AFD_POLL_DISCONNECT_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_ABORT_BIT]!=0) {
        dprintf (" abort:%lx", endpoint.EventStatus[AFD_POLL_ABORT_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_LOCAL_CLOSE_BIT]!=0) {
        dprintf (" close:%lx", endpoint.EventStatus[AFD_POLL_LOCAL_CLOSE_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_CONNECT_BIT]!=0) {
        dprintf (" connect:%lx", endpoint.EventStatus[AFD_POLL_CONNECT_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_ACCEPT_BIT]!=0) {
        dprintf (" accept:%lx", endpoint.EventStatus[AFD_POLL_ACCEPT_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_CONNECT_FAIL_BIT]!=0) {
        dprintf (" con fail:%lx", endpoint.EventStatus[AFD_POLL_CONNECT_FAIL_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_QOS_BIT]!=0) {
        dprintf (" qos:%lx", endpoint.EventStatus[AFD_POLL_QOS_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_GROUP_QOS_BIT]!=0) {
        dprintf (" gqos:%lx", endpoint.EventStatus[AFD_POLL_GROUP_QOS_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_ROUTING_IF_CHANGE_BIT]!=0) {
        dprintf (" route chng:%lx", endpoint.EventStatus[AFD_POLL_ROUTING_IF_CHANGE_BIT]);
    }
    if (endpoint.EventStatus[AFD_POLL_ADDRESS_LIST_CHANGE_BIT]!=0) {
        dprintf (" addr chng:%lx", endpoint.EventStatus[AFD_POLL_ADDRESS_LIST_CHANGE_BIT]);
    }
    dprintf ("\n");
        
    dprintf(
        "    GroupID                      = %08lx\n",
        (ULONG)ReadField (GroupID)
        );

    dprintf(
        "    GroupType                    = %s\n",
        GroupTypeToString( (ULONG)ReadField (GroupType) )
        );

    if( IsReferenceDebug ) {

        dprintf(
            "    ReferenceDebug               = %p\n",
            ActualAddress + EndpRefOffset
            );

        dprintf(
            "    CurrentReferenceSlot         = %lu\n",
            (ULONG)ReadField (CurrentReferenceSlot) % MAX_REFERENCE
            );

    }

    dprintf( "\n" );

}   // DumpAfdEndpoint

VOID
DumpAfdEndpointBrief (
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified AFD_ENDPOINT structure in short format.

Endpoint Typ State  Flags    Transport Port    Counts    Evt Pid   Con/RAdr
xxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxx xxxxx xx xx xx xx xxx xxxx  xxxxxxxx

Endpoint    Typ State  Flags    Transport Port    Counts    Evt Pid   Con/RemAddr
xxxxxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxx xxxxx xx xx xx xx xxx xxxx  xxxxxxxxxxx

Arguments:
    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/
{
    CHAR    ctrs[16];
    LPSTR   port;
    UCHAR   transportAddress[MAX_TRANSPORT_ADDR];
    PAFDKD_TRANSPORT_INFO transportInfo = NULL;
    ULONG64 address, trInfoAddr, localAddr;
    ULONG   length;
    ULONG64 pid;
    AFD_ENDPOINT    endpoint;

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    endpoint.AdminAccessGranted = (BOOLEAN)ReadField (AdminAccessGranted);
    endpoint.EndpointStateFlags = (ULONG)ReadField (EndpointStateFlags);
    endpoint.DisconnectMode = (ULONG)ReadField(DisconnectMode);

    switch (endpoint.Type) {
    case AfdBlockTypeDatagram :
        sprintf (ctrs, "%5.5x %5.5x", 
            (ULONG)ReadField (Common.Datagram.BufferredSendBytes),
            (ULONG)ReadField (Common.Datagram.BufferredReceiveBytes)
            );
        address = ReadField (Common.Datagram.RemoteAddress);
        endpoint.Common.Datagram.Flags = 
                        (LOGICAL)ReadField (Common.Datagram.Flags);

        break;
    case AfdBlockTypeVcConnecting:
        address = ReadField (Common.VirtualCircuit.Connection);
        address = 
            address!=0
                ? address
                : (((endpoint.State==AfdEndpointStateClosing ||
                            endpoint.State==AfdEndpointStateTransmitClosing) &&
                        ((address = ReadField (WorkItem.Context))!=0))
                    ? address
                    : 0);
        if (address!=0) {
            AFD_CONNECTION_STATE_FLAGS   flags;
            ULONG sndB = 0, rcvB = 0;
            if (GetFieldValue (address,
                                "AFD!AFD_CONNECTION",
                                "ConnectionStateFlags",
                                flags)==0) {
                if (flags.TdiBufferring) {
                    ULONGLONG taken, there;
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.Bufferring.ReceiveBytesIndicated.QuadPart",
                            taken);
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.Bufferring.ReceiveBytesTaken.QuadPart",
                            there);
                    sndB = 0;
                    rcvB = (ULONG)(taken-there);
                }
                else {
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.NonBufferring.BufferredReceiveBytes",
                            rcvB);
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.NonBufferring.BufferredSendBytes",
                            sndB);
                }
                sprintf (ctrs, "%5.5x %5.5x", sndB, rcvB);
            }
            else {
                sprintf (ctrs, "Read error!");
            }
        }
        else {
            sprintf (ctrs, "           ");
        }
        break;
    case AfdBlockTypeVcListening:
    case AfdBlockTypeVcBoth:
        address = 0;
        if (IS_DELAYED_ACCEPTANCE_ENDPOINT(&endpoint)) {
            sprintf (ctrs, "?? ?? %2.2x %2.2x", 
                (LONG)ReadField(Common.VirtualCircuit.Listening.TdiAcceptPendingCount),
                (LONG)ReadField(Common.VirtualCircuit.Listening.FailedConnectionAdds));
        }
        else {
            sprintf (ctrs, "%2.2x %2.2x %2.2x %2.2x", 
                (USHORT)ReadField (Common.VirtualCircuit.Listening.FreeConnectionListHead.Depth),
                (USHORT)ReadField (Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead.Depth),
                (LONG)ReadField(Common.VirtualCircuit.Listening.TdiAcceptPendingCount),
                (LONG)ReadField(Common.VirtualCircuit.Listening.FailedConnectionAdds));
        }
        break;
    case AfdBlockTypeEndpoint:
    default:
        address = 0;
        sprintf (ctrs, "           ");
        break;
    }

    if ((trInfoAddr=ReadField (TransportInfo))!=0) {
        PLIST_ENTRY  listEntry;

        listEntry = TransportInfoList.Flink;
        while (listEntry!=&TransportInfoList) {
            transportInfo = CONTAINING_RECORD (listEntry, AFDKD_TRANSPORT_INFO, Link);
            if (transportInfo->ActualAddress==trInfoAddr)
                break;
            listEntry = listEntry->Flink;
        }

        if (listEntry==&TransportInfoList) {
            transportInfo = ReadTransportInfo (trInfoAddr);
            if (transportInfo!=NULL) {
                InsertHeadList (&TransportInfoList, &transportInfo->Link);
            }
        }
    }

    port = "     ";
    if ((localAddr=ReadField(LocalAddress))!=0) {
        length = (ULONG)ReadField (LocalAddressLength);
        if (ReadMemory (localAddr,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            port = TransportPortToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                localAddr
                );
        }
        else {
            port = "error";
        }
    }



    if (GetFieldValue (
                ReadField(OwningProcess),
                "NT!_EPROCESS",
                "UniqueProcessId",
                pid)!=0) {
        pid = 0xFEFE;
    }


    /*            Endpoint Typ Sta StFl Tr.Inf    Lport ctrs Events PID   Con/Raddr*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %3s %3s %12s %-12.12ls %5.5s %11s %3.3lx %4.4x %011.011p"
            : "\n%008.008p %3s %3s %12s %-12.12ls %5.5s %11s %3.3lx %4.4x %008.008p",
        DISP_PTR(ActualAddress),
        StructureTypeToStringBrief (endpoint.Type),
        EndpointStateToStringBrief (endpoint.State),
        EndpointStateFlagsToString (&endpoint),
        transportInfo
            ? &transportInfo->DeviceName[sizeof("\\Device\\")-1]
            : L"",
        port,
        ctrs,
        (ULONG)ReadField (EventsActive),
        (ULONG)pid,
        DISP_PTR(address)
        );
}

VOID
DumpAfdConnection(
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified AFD_CONNECTION structures.

Arguments:

    Connection - Points to the AFD_CONNECTION structure to dump.

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    AFD_CONNECTION  connection;
    ULONG64         address, endpAddr;
    ULONG           length;
    UCHAR           transportAddress[MAX_TRANSPORT_ADDR];

    dprintf(
        "\nAFD_CONNECTION @ %p:\n",
        ActualAddress
        );

    connection.Type = (USHORT)ReadField (Type);
    dprintf(
        "    Type                         = %04X (%s)\n",
        connection.Type,
        StructureTypeToString( connection.Type )
        );

    dprintf(
        "    ReferenceCount               = %ld\n",
        (LONG)ReadField (ReferenceCount)
        );

    connection.State = (USHORT)ReadField (State);
    dprintf(
        "    State                        = %08X (%s)\n",
        connection.State,
        ConnectionStateToString( connection.State )
        );

    dprintf(
        "    StateFlags                   = %08X (",
        connection.ConnectionStateFlags = (ULONG)ReadField (ConnectionStateFlags)
        );

    if (connection.TdiBufferring)
        dprintf (" Buf");
    if (connection.AbortIndicated)
        dprintf (" AbortInd");
    if (connection.DisconnectIndicated)
        dprintf (" DscnInd");
    if (connection.ConnectedReferenceAdded)
        dprintf (" +CRef");
    if (connection.SpecialCondition)
        dprintf (" Special");
    if (connection.CleanupBegun)
        dprintf (" ClnBegun");
    if (connection.ClosePendedTransmit)
        dprintf (" ClosingTranFile");
    if (connection.OnLRList)
        dprintf (" LRList");
    dprintf (" )\n");

    dprintf(
        "    Handle                       = %p\n",
        ReadField (Handle)
        );

    dprintf(
        "    FileObject                   = %p\n",
        ReadField (FileObject)
        );

    if (connection.State==AfdConnectionStateConnected) {
        connection.ConnectTime = ReadField (ConnectTime);
        if (SystemTime.QuadPart!=0) {
            dprintf(
                "    ConnectTime                  = %s\n",
                SystemTimeToString( 
                    connection.ConnectTime-
                        InterruptTime.QuadPart+
                        SystemTime.QuadPart));
            dprintf(
                "                             (now: %s)\n",
                SystemTimeToString (SystemTime.QuadPart)
                );
        }
        else {
            dprintf(
                "    ConnectTime                  = %I64x (nsec since boot)\n",
                    connection.ConnectTime
                );
        }
    }
    else {
        dprintf(
            "    Accept/Listen Irp            = %p\n",
            ReadField (AcceptIrp)
            );
    }

    if( connection.TdiBufferring )
    {
        dprintf(
            "    ReceiveBytesIndicated        = %I64d\n",
            ReadField( Common.Bufferring.ReceiveBytesIndicated.QuadPart )
            );

        dprintf(
            "    ReceiveBytesTaken            = %I64d\n",
            ReadField ( Common.Bufferring.ReceiveBytesTaken.QuadPart )
            );

        dprintf(
            "    ReceiveBytesOutstanding      = %I64d\n",
            ReadField( Common.Bufferring.ReceiveBytesOutstanding.QuadPart )
            );

        dprintf(
            "    ReceiveExpeditedBytesIndicated   = %I64d\n",
            ReadField( Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart )
            );

        dprintf(
            "    ReceiveExpeditedBytesTaken       = %I64d\n",
            ReadField( Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart )
            );

        dprintf(
            "    ReceiveExpeditedBytesOutstanding = %I64d\n",
            ReadField( Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart )
            );

        dprintf(
            "    NonBlockingSendPossible      = %s\n",
            BooleanToString( (BOOLEAN)ReadField (Common.Bufferring.NonBlockingSendPossible) )
            );

        dprintf(
            "    ZeroByteReceiveIndicated     = %s\n",
            BooleanToString( (BOOLEAN)ReadField (Common.Bufferring.ZeroByteReceiveIndicated) )
            );
    }
    else
    {

        dprintf(
            "    ReceiveIrpListHead           %s\n",
            LIST_TO_STRING(
                ActualAddress + ConnectionRecvListOffset,
                Common.NonBufferring.ReceiveIrpListHead.Flink)
            );


        dprintf(
            "    ReceiveBufferListHead        %s\n",
            LIST_TO_STRING(
                ActualAddress + ConnectionBufferListOffset,
                Common.NonBufferring.ReceiveBufferListHead.Flink)
            );

        dprintf(
            "    SendIrpListHead              %s\n",
            LIST_TO_STRING(
                ActualAddress + ConnectionSendListOffset,
                Common.NonBufferring.SendIrpListHead.Flink)
            );

        dprintf(
            "    BufferredReceiveBytes        = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.BufferredReceiveBytes)
            );

        dprintf(
            "    BufferredExpeditedBytes      = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.BufferredExpeditedBytes)
            );

        dprintf(
            "    BufferredReceiveCount        = %u\n",
            (USHORT)ReadField (Common.NonBufferring.BufferredReceiveCount)
            );

        dprintf(
            "    BufferredExpeditedCount      = %u\n",
            (USHORT)ReadField (Common.NonBufferring.BufferredExpeditedCount)
            );

        dprintf(
            "    ReceiveBytesInTransport      = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.ReceiveBytesInTransport)
            );

        dprintf(
            "    BufferredSendBytes           = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.BufferredSendBytes)
            );

        dprintf(
            "    BufferredSendCount           = %u\n",
            (USHORT)ReadField (Common.NonBufferring.BufferredSendCount)
            );

        dprintf(
            "    DisconnectIrp                = %p\n",
            ReadField (Common.NonBufferring.DisconnectIrp)
            );

        if (IsCheckedAfd ) {
            dprintf(
                "    ReceiveIrpsInTransport       = %ld\n",
                (ULONG)ReadField (Common.NonBufferring.ReceiveIrpsInTransport)
                );
        }

    }

    dprintf(
        "    Endpoint                     = %p\n",
        endpAddr = ReadField (Endpoint)
        );

    dprintf(
        "    MaxBufferredReceiveBytes     = %lu\n",
        (ULONG)ReadField (MaxBufferredReceiveBytes)
        );

    dprintf(
        "    MaxBufferredSendBytes        = %lu\n",
        (ULONG)ReadField (MaxBufferredSendBytes)
        );

    dprintf(
        "    ConnectDataBuffers           = %p\n",
        ReadField (ConnectDataBuffers)
        );

    dprintf(
        "    OwningProcess                = %p\n",
        ReadField (OwningProcess)
        );

    dprintf(
        "    DeviceObject                 = %p\n",
        ReadField (DeviceObject)
        );

    dprintf(
        "    RemoteAddress                = %p\n",
        address = ReadField (RemoteAddress)
        );

    length = (USHORT)ReadField (RemoteAddressLength);
    dprintf(
        "    RemoteAddressLength          = %lu\n",
        length
        );

    if( address != 0 ) {

        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            DumpTransportAddress(
                "    ",
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            dprintf ("\nDumpAfdConnection: Could not read transport address @ %p\n", address);
        }


    }
    else if ((connection.State==AfdConnectionStateConnected) && (endpAddr!=0)) {
        ULONG result;
        ULONG64 context;
        ULONG contextLength;
        USHORT addressOffset, addressLength;
        PTRANSPORT_ADDRESS taAddress = (PTRANSPORT_ADDRESS)transportAddress;
        USHORT maxAddressLength = (USHORT)(sizeof (transportAddress) - 
                                    FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType));

        //
        // Attempt to read user mode data stored as the context
        //

        if (GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT",
                            "Context", 
                            context)==0 &&
                context!=0 &&
                GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT",
                            "ContextLength", 
                            contextLength)==0 &&
                contextLength!=0 &&
                GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT", 
                            "Common.VirtualCircuit.RemoteSocketAddressOffset",
                            addressOffset)==0 &&
                GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT", 
                            "Common.VirtualCircuit.RemoteSocketAddressLength",
                            addressLength)==0 &&
                addressLength!=0 &&
                contextLength>=(ULONG)(addressOffset+addressLength) &&
                ReadMemory (context+addressOffset,
                            &taAddress->Address[0].AddressType,
                            addressLength<maxAddressLength
                                    ? addressLength 
                                    : maxAddressLength,
                            &result)) {
            //
            // Initialize fields missing in socket address structure
            //

            taAddress->TAAddressCount = 1;
            taAddress->Address[0].AddressLength = addressLength-sizeof (USHORT);
            DumpTransportAddress(
                "    ",
                taAddress,
                context+addressOffset
                );
        }
        else {
            dprintf ("\nDumpAfdConnection: Could not read address info from endpoint context (paged out:%p ?)!\n",
                    context);
        }
    }



    if( IsReferenceDebug ) {

        dprintf(
            "    ReferenceDebug               = %p\n",
            ActualAddress + ConnRefOffset
            );

        dprintf(
            "    CurrentReferenceSlot         = %lu\n",
            (LONG)ReadField (CurrentReferenceSlot) % MAX_REFERENCE
            );


    }

#ifdef _AFD_VERIFY_DATA_
    dprintf(
        "    VerifySequenceNumber         = %lx\n",
        (LONG)ReadField (VerifySequenceNumber)
        );
#endif
    dprintf( "\n" );

}   // DumpAfdConnection

VOID
DumpAfdConnectionBrief(
    ULONG64 ActualAddress
    )
/*++

Routine Description:

    Dumps the specified AFD_CONNECTION structure in short format.

Connectn Stat Flags  Remote Address                   SndB  RcvB  Pid  Endpoint
xxxxxxxx xxx xxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxx xxxxx xxxx xxxxxxxx
Connection  Stat Flags  Remote Address                   SndB  RcvB  Pid  Endpoint   
xxxxxxxxxxx xxx xxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxx xxxxx xxxx xxxxxxxxxxx


Arguments:

    Connection - Points to the AFD_CONNECTION structure to dump.

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/
{
    AFD_CONNECTION  connection;
    CHAR            transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64         address, endpAddr, pid;
    ULONG           length;
    LPSTR           raddr;

    connection.Type = (USHORT)ReadField (Type);
    connection.State = (USHORT)ReadField (State);
    connection.ConnectionStateFlags = (ULONG)ReadField (ConnectionStateFlags);
    endpAddr = ReadField (Endpoint);
    address = ReadField (RemoteAddress);
    length = (ULONG)ReadField (RemoteAddressLength);

    if( address != 0 ) {
        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            raddr = TransportAddressToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            raddr = "Read error!";
        }
    }
    else if ((connection.State==AfdConnectionStateConnected) && (endpAddr!=0)) {
        ULONG result;
        ULONG64 context;
        ULONG contextLength;
        USHORT addressOffset, addressLength;
        PTRANSPORT_ADDRESS taAddress = (PTRANSPORT_ADDRESS)transportAddress;
        USHORT maxAddressLength = (USHORT)(sizeof (transportAddress) - 
                                    FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType));

        //
        // Attempt to read user mode data stored as the context
        //

        if (GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT",
                            "Context", 
                            context)==0 &&
                context!=0 &&
                GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT",
                            "ContextLength", 
                            contextLength)==0 &&
                contextLength!=0 &&
                GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT", 
                            "Common.VirtualCircuit.RemoteSocketAddressOffset",
                            addressOffset)==0 &&
                GetFieldValue (endpAddr,
                            "AFD!AFD_ENDPOINT", 
                            "Common.VirtualCircuit.RemoteSocketAddressLength",
                            addressLength)==0 &&
                addressLength!=0 &&
                contextLength>=(ULONG)(addressOffset+addressLength) &&
                ReadMemory (context+addressOffset,
                            &taAddress->Address[0].AddressType,
                            addressLength<maxAddressLength
                                    ? addressLength 
                                    : maxAddressLength,
                            &result)) {
            //
            // Initialize fields missing in socket address structure
            //

            taAddress->TAAddressCount = 1;
            taAddress->Address[0].AddressLength = addressLength-sizeof (USHORT);
            raddr = TransportAddressToString(
                taAddress,
                context+addressOffset
                );
        }
        else {
            raddr = "Read error (paged-out ?)!";
        }
    }
    else {
        raddr = "";
    }

    if (GetFieldValue (
                ReadField(OwningProcess),
                "NT!_EPROCESS",
                "UniqueProcessId",
                pid)!=0) {
        pid = 0xFEFE;
    }

    //           Connection Sta Flg Rem Addr SndB  RcvB  Pid   Endpoint
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %3s %7s %-32.32s %5.5x %5.5x %4.4x %011.011p"
            : "\n%008.008p %3s %7s %-32.32s %5.5x %5.5x %4.4x %008.008p",
        DISP_PTR(ActualAddress),
        ConnectionStateToStringBrief (connection.State),
        ConnectionStateFlagsToString (&connection),
        raddr,
        connection.TdiBufferring
            ? (ULONG)0
            : (ULONG)ReadField (Common.NonBufferring.BufferredSendBytes),
        connection.TdiBufferring
            ? (ULONG)(ReadField (Common.Bufferring.ReceiveBytesIndicated.QuadPart)
                - ReadField (Common.Bufferring.ReceiveBytesTaken.QuadPart))
            : (ULONG)(ReadField (Common.NonBufferring.BufferredReceiveBytes)
                + ReadField (Common.NonBufferring.ReceiveBytesInTransport)),
        (ULONG)pid,
        DISP_PTR(endpAddr)
        );
}

VOID
DumpAfdReferenceDebug(
    ULONG64 ActualAddress,
    ULONG   Idx
    )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structures associated with an
    AFD_CONNECTION object.

Arguments:

    ReferenceDebug - Points to an array of AFD_REFERENCE_DEBUG structures.
        There are assumed to be MAX_REFERENCE entries in this array.

    ActualAddress - The actual address where the array resides on the
        debugee.

Return Value:

    None.

--*/

{

    ULONG i;
    ULONG result;
    CHAR filePath[MAX_PATH];
    CHAR message[256];
    ULONG64  format;
    ULONG64  address;
    AFD_REFERENCE_DEBUG rd[MAX_REFERENCE];
    ULONG64  locationTable;

    
    if (RefDebugSize==0) {
        dprintf ("\nDumpAfdReferenceDebug: sizeof(AFD!AFD_REFERENCE_DEBUG) is 0!!!\n");
        return;
    }

    result = ReadPtr (GetExpression ("AFD!AfdLocationTable"),
                            &locationTable);
    if (result!=0) {
        dprintf("\nDumpAfdReferenceDebug: Could not read afd!AfdLocationTable, err: %ld\n", result);
        return;
    }


    dprintf(
        "AFD_REFERENCE_DEBUG @ %p @ %u %s\n",
        ActualAddress,
        (TicksToMs!=0) 
            ? (ULONG)(((ULONGLONG)TickCount*TicksToMs)>>24)
            : TickCount,
        (TicksToMs!=0) ? "ms" : ""
        );


    if (!ReadMemory (ActualAddress, rd, sizeof(rd), &result)) {
        dprintf ("\nDumpAfdReferenceDebug: Could not read AFD_REFERENCE_DEBUG @ %p\n", ActualAddress);
        return;
    }

    Idx=(Idx+1)%MAX_REFERENCE;
    for( i = 0 ; i < MAX_REFERENCE ; i++, Idx=(Idx+1)%MAX_REFERENCE ) {
        if( CheckControlC() ) {

            break;

        }


        if( rd[Idx].QuadPart==0) {

            continue;

        }

        if (GetFieldValue (locationTable+RefDebugSize*(rd[Idx].LocationId-1),
                            "AFD!AFD_REFERENCE_LOCATION",
                            "Format",
                            format)==0 &&
            GetFieldValue (locationTable+RefDebugSize*(rd[Idx].LocationId-1),
                            "AFD!AFD_REFERENCE_LOCATION",
                            "Address",
                            address)==0 &&
             (ReadMemory (format,
                          filePath,
                          sizeof (filePath),
                          &result) || 
                          (result>0 && filePath[result-1]==0))) {
            CHAR    *fileName;
            fileName = strrchr (filePath, '\\');
            if (fileName!=NULL) {
                fileName += 1;
            }
            else {
                fileName = filePath;
            }
            sprintf (message, fileName, (ULONG)rd[Idx].Param);
        }
        else {
            sprintf (message, "%lx %lx",
                    (ULONG)rd[Idx].LocationId,
                    (ULONG)rd[Idx].Param);
        }

        dprintf ("    %3lu %s -> %ld @ %u %s\n",
                Idx, message, (ULONG)rd[Idx].NewCount,
                (TicksToMs!=0)
                    ? (ULONG)((rd[Idx].TickCount*TicksToMs)>>24)
                    : (ULONG)rd[Idx].TickCount,
                (TicksToMs!=0) ? "ms" : "");

    }

}   // DumpAfdReferenceDebug


#if GLOBAL_REFERENCE_DEBUG
BOOL
DumpAfdGlobalReferenceDebug(
    PAFD_GLOBAL_REFERENCE_DEBUG ReferenceDebug,
    ULONG64 ActualAddress,
    DWORD CurrentSlot,
    DWORD StartingSlot,
    DWORD NumEntries,
    ULONG64 CompareAddress
    )

/*++

Routine Description:

    Dumps the AFD_GLOBAL_REFERENCE_DEBUG structures.

Arguments:

    ReferenceDebug - Points to an array of AFD_GLOBAL_REFERENCE_DEBUG
        structures.  There are assumed to be MAX_GLOBAL_REFERENCE entries
        in this array.

    ActualAddress - The actual address where the array resides on the
        debugee.

    CurrentSlot - The last slot used.

    CompareAddress - If zero, then dump all records. Otherwise, only dump
        those records with a matching connection pointer.

Return Value:

    None.

--*/

{

    ULONG result;
    LPSTR fileName;
    CHAR decoration;
    CHAR filePath[MAX_PATH];
    CHAR action[16];
    BOOL foundEnd = FALSE;
    ULONG lowTick;

    if( StartingSlot == 0 ) {

        dprintf(
            "AFD_GLOBAL_REFERENCE_DEBUG @ %p, Current Slot = %lu\n",
            ActualAddress,
            CurrentSlot
            );

    }

    for( ; NumEntries > 0 ; NumEntries--, StartingSlot++, ReferenceDebug++ ) {

        if( CheckControlC() ) {

            foundEnd = TRUE;
            break;

        }

        if( ReferenceDebug->Info1 == NULL &&
            ReferenceDebug->Info2 == NULL &&
            ReferenceDebug->Action == 0 &&
            ReferenceDebug->NewCount == 0 &&
            ReferenceDebug->Connection == NULL ) {

            foundEnd = TRUE;
            break;

        }

        if( CompareAddress != 0 &&
            ReferenceDebug->Connection != (PVOID)CompareAddress ) {

            continue;

        }

        if( ReferenceDebug->Action == 0 ||
            ReferenceDebug->Action == 1 ||
            ReferenceDebug->Action == (ULONG64)-1L ) {

            sprintf(
                action,
                "%ld",
                PtrToUlong(ReferenceDebug->Action)
                );

        } else {

            sprintf(
                action,
                "%p",
                ReferenceDebug->Action
                );

        }

        decoration = ( StartingSlot == CurrentSlot ) ? '>' : ' ';
        lowTick = ReferenceDebug->TickCounter.LowPart;

        switch( (ULONG64)ReferenceDebug->Info1 ) {

        case 0xafdafd02 :
            dprintf(
                "%c    %3lu: %p (%8lu) Buffered Send, IRP @ %plx [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0xafdafd03 :
            dprintf(
                "%c    %3lu: %p (%8lu) Nonbuffered Send, IRP @ %p [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0xafd11100 :
        case 0xafd11101 :
            dprintf(
                "%c    %3lu: %p (%8lu) AfdRestartSend (%p), IRP @ %p [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info1,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0xafd11102 :
        case 0xafd11103 :
        case 0xafd11104 :
        case 0xafd11105 :
            dprintf(
                "%c    %3lu: %p (%8lu) AfdRestartBufferSend (%p), IRP @ %p [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info1,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0 :
            if( ReferenceDebug->Info2 == NULL ) {

                dprintf(
                    "%c    %3lu: %p (%8lu) AfdDeleteConnectedReference (%p)\n",
                    decoration,
                    StartingSlot,
                    (ULONG64)ReferenceDebug->Connection,
                    lowTick,
                    (ULONG64)ReferenceDebug->Action
                    );
                break;

            } else {

                //
                // Fall through to default case.
                //

            }

        default :
            if( ReadMemory(
                    (ULONG64)ReferenceDebug->Info1,
                    filePath,
                    sizeof(filePath),
                    &result
                    ) ) {

                fileName = strrchr( filePath, '\\' );

                if( fileName != NULL ) {

                    fileName++;

                } else {

                    fileName = filePath;

                }

            } else {

                sprintf(
                    filePath,
                    "%p",
                    ReferenceDebug->Info1
                    );

                fileName = filePath;

            }

            dprintf(
                "%c    %3lu: %p (%8lu) %s:%lu [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                fileName,
                PtrToUlong (ReferenceDebug->Info2),
                action,
                ReferenceDebug->NewCount
                );
            break;

        }

    }

    return foundEnd;

}   // DumpAfdGlobalReferenceDebug
#endif

VOID
DumpAfdTransmitInfo(
    ULONG64 ActualAddress
    )
{
    ULONG64 fileAddr, endpAddr, tpInfoAddr, irpSpAddr;
    ULONG64  i;
    ULONG    Flags, StateFlags, NumSendIrps, RefCount;
    ULONG result;


    irpSpAddr = ReadField (Tail.Overlay.CurrentStackLocation);
    tpInfoAddr = ReadField (AssociatedIrp.SystemBuffer);

    if ( (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "StateFlags",
                        StateFlags)) !=0 ||
         (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "ReferenceCount",
                        RefCount)) !=0 ) {
        dprintf(
            "\ntran: Could not read AFD_TPACKETS_IRP_CTX @ %p, err:%d\n",
            ActualAddress+DriverContextOffset, result
            );
        return;
    }

    if ( (result=GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "Flags",
                        Flags)) !=0  ||
          (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "FileObject",
                        fileAddr)) !=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    result = GetFieldValue (fileAddr,
                        "NT!_FILE_OBJECT",
                        "FsContext",
                        endpAddr);
    if (result!=0) {
        dprintf(
            "\ntran: Could not read FsContext of FILE_OBJECT @ %p for IRP @ %p, err:%d\n",
            fileAddr, ActualAddress, result
            );
        return;
    }

    dprintf(
        "\nAFD_TRANSMIT_FILE_INFO_INTERNAL @ %p\n",
        tpInfoAddr
        );

    dprintf(
        "    Endpoint               = %p\n",
        endpAddr
        );

    dprintf(
        "    TransmitIrp            = %p\n",
        ActualAddress);

    dprintf(
        "    ReferenceCount         = %ld\n",
        RefCount
        );

    dprintf(
        "    Flags                  = %08lx (",
        Flags
        );

    if (Flags & AFD_TF_WRITE_BEHIND)
        dprintf ("WrB ");
    if (Flags & AFD_TF_DISCONNECT)
        dprintf ("Dsc ");
    if (Flags & AFD_TF_REUSE_SOCKET)
        dprintf ("Reu ");
    if (Flags & AFD_TF_USE_SYSTEM_THREAD)
        dprintf ("Sys ");
    if (Flags & AFD_TF_USE_KERNEL_APC)
        dprintf ("Apc ");
    dprintf (")\n");

    dprintf(
        "    StateFlags             = %08lx (",
        StateFlags = (ULONG)ReadField (StateFlags)
        );
    if (StateFlags & AFD_TP_ABORT_PENDING)
        dprintf ("Abrt ");
    if (StateFlags & AFD_TP_WORKER_SCHEDULED)
        dprintf ("WrkS ");
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    if (StateFlags & AFD_TP_SEND_AND_DISCONNECT)
        dprintf ("S&D ");
#endif
    if (tpInfoAddr==0) {
        dprintf(
            "Disconnecting)\n"
            );
    }
    else if (tpInfoAddr==-1) {
        dprintf(
            "Reusing)\n"
            );
    }
    else {

        result = (ULONG)InitTypeRead (tpInfoAddr, AFD!AFD_TPACKETS_INFO_INTERNAL);
        if (result!=0) {
            dprintf(
                "\ntran: Could not read AFD_TPACKETS_INFO_INTERNAL @ %p, err:%d\n",
                tpInfoAddr, result
                );
            return;
        }

        if (ReadField(PdNeedsPps))
            dprintf ("Pps ");
        if (ReadField(ArrayAllocated))
            dprintf ("Alloc ");
        dprintf (")\n");
        
        dprintf(
            "    SendPacketLength       = %08lx\n",
            (ULONG)ReadField (SendPacketLength)
            );

        dprintf(
            "    PdLength               = %08lx\n",
            (ULONG)ReadField (PdLength)
            );

        dprintf(
            "    NextElement            = %d\n",
            (ULONG)ReadField (NextElement)
            );

        dprintf(
            "    ElementCount           = %d\n",
            (ULONG)ReadField (ElementCount)
            );

        dprintf(
            "    ElementArray           = %p\n",
            ReadField (ElementArray)
            );

        dprintf(
            "    RemainingPkts          = %p\n",
            ReadField (RemainingPkts)
            );

        dprintf(
            "    HeadPd                 = %p\n",
            ReadField (HeadPd)
            );

        dprintf(
            "    TailPd                 = %p\n",
            ReadField (TailPd)
            );

        dprintf(
            "    HeadMdl                = %p\n",
            ReadField (HeadMdl)
            );

        dprintf(
            "    TailMdl                = %p\n",
            ReadField (TailMdl)
            );

        dprintf(
            "    TdiFileObject          = %p\n",
            ReadField (TdiFileObject)
            );

        dprintf(
            "    TdiDeviceObject        = %p\n",
            ReadField (TdiDeviceObject)
            );


        dprintf(
            "    NumSendIrps            = %08lx\n",
            NumSendIrps = (LONG)ReadField (NumSendIrps)
            );

        for (i=0; i<NumSendIrps && i<AFD_TP_MAX_SEND_IRPS; i++) {
            CHAR fieldName[16];
            if (CheckControlC ())
                break;
            sprintf (fieldName, "SendIrp[%1d]",i);
            dprintf(
                "    %s             = %p%s\n",
                fieldName,
                GetShortField (0, fieldName, 0),
                StateFlags & AFD_TP_SEND_BUSY(i)
                    ? " (BUSY)"
                    : ""
                );
        }

        dprintf(
            "    ReadIrp                = %p%s\n",
            ReadField (ReadIrp),
            StateFlags & AFD_TP_READ_BUSY
                ? " (BUSY)"
                : ""
            );

        if( IsReferenceDebug ) {

            dprintf(
                "    ReferenceDebug         = %p\n",
                tpInfoAddr + TPackRefOffset
                );

            dprintf(
                "    CurrentReferenceSlot   = %lu\n",
                (LONG)ReadField (CurrentReferenceSlot) % MAX_REFERENCE
                );
        }
    }
    dprintf( "\n" );

}   // DumpAfdTransmitInfo

VOID
DumpAfdTransmitInfoBrief (
    ULONG64 ActualAddress
    )
/*
TPackets    I    R      P      S    Endpoint   Flags            Next Elmt
Address  Transmit   Send     Read   Address  App | State        Elmt Cnt.
xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxx xxxxxxxxxxx xxxx xxxx

TPackets      I    R     P     S        Endpoint      Flags            Next Elmt
Address     Transmit    S1    Read      Address     App | State        Elmt Cnt.
xxxxxxxxxxx xxxxxxxxxxx xxx xxxxxxxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxx xxxx xxxx
*/
{
    ULONG64 fileAddr, endpAddr, tpInfoAddr, irpSpAddr;
    ULONG Flags, StateFlags;
    ULONG result;

    tpInfoAddr = ReadField (AssociatedIrp.SystemBuffer);
    irpSpAddr = ReadField (Tail.Overlay.CurrentStackLocation);
    if ( (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "Flags",
                        Flags))!=0) {
        dprintf(
            "\ntran: Could not read AFD_TPACKETS_IRP_CTX @ %p, err:%d\n",
            ActualAddress+DriverContextOffset, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "FileObject",
                        fileAddr))!=0 ||
         (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "NT!_IO_STACK_LOCATION",
                        "IoControlCode",
                        StateFlags))!=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    result = GetFieldValue (fileAddr,
                        "NT!_FILE_OBJECT",
                        "FsContext",
                        endpAddr);
    if (result!=0) {
        dprintf(
            "\ntran: Could not read FsContext of FILE_OBJECT @ %p for IRP @ %p, err:%d\n",
            fileAddr, ActualAddress, result
            );
        return;
    }

    if (tpInfoAddr!=0 && tpInfoAddr!=-1 ) {
        result = (ULONG)InitTypeRead (tpInfoAddr, AFD!AFD_TPACKETS_INFO_INTERNAL);
        if (result!=0) {
            dprintf(
                "\ntran: Could not read AFD_TPACKETS_INFO_INTERNAL @ %p, err:%d\n",
                tpInfoAddr, result
                );
            return;
        }

        dprintf (
            IsPtr64() 
                ? "\n%011.011p %011.011p %03.03p %011.011p %011.011p %s %4.4ld %4.4ld"
                : "\n%008.008p %008.008p %08.08p %008.008p %008.008p %s %4.4ld %4.4ld",
            DISP_PTR(tpInfoAddr),
            DISP_PTR(ActualAddress),
            IsPtr64()
                ? DISP_PTR((tpInfoAddr+SendIrpArrayOffset)&0xFFF)
                : DISP_PTR(tpInfoAddr+SendIrpArrayOffset),
            DISP_PTR(ReadField (ReadIrp)),
            DISP_PTR(endpAddr),
            TranfileFlagsToString (Flags, StateFlags),
            (ULONG)ReadField (NextElement),
            (ULONG)ReadField (ElementCount)
            );
    }
    else {
        CHAR    *str;
        if (tpInfoAddr==0) {
            str = "Disconnecting..";
        }
        else {
             str = "Reusing...";
        }

        dprintf (
            IsPtr64() 
                ? "\n%011.011p %011.011p %-15.15s %011.011p %s %4.4ld %4.4ld"
                : "\n%008.008p %008.008p %-17.17s %008.008p %s %4.4ld %4.4ld",
            DISP_PTR(tpInfoAddr),
            DISP_PTR(ActualAddress),
            str,
            DISP_PTR(endpAddr),
            TranfileFlagsToString (Flags, StateFlags),
            0,
            0
            );
    }

} // DumpAfdTransmitInfoBrief

VOID
DumpAfdBuffer(
    ULONG64 ActualAddress
    )
{
    ULONG   result;
    ULONG   length;
    AFD_BUFFER_HEADER   buffer;
    ULONG64 mdl,irp,buf;

    dprintf(
        "AFD_BUFFER @ %p\n",
        ActualAddress
        );

    dprintf(
        "    BufferLength           = %08lx\n",
        length=(ULONG)ReadField (BufferLength)
        );

    dprintf(
        "    DataLength             = %08lx\n",
        (ULONG)ReadField (DataLength)
        );

    dprintf(
        "    DataOffset             = %08lx\n",
        (ULONG)ReadField (DataOffset)
        );

    dprintf(
        "    Context/Status         = %p/%lx\n",
        ReadField (Context), (ULONG)ReadField(Status)
        );

    dprintf(
        "    Mdl                    = %p\n",
        mdl=ReadField (Mdl)
        );

    dprintf(
        "    RemoteAddress          = %p\n",
        ReadField (TdiInfo.RemoteAddress)
        );

    dprintf(
        "    RemoteAddressLength    = %lu\n",
        (ULONG)ReadField (TdiInfo.RemoteAddressLength)
        );

    dprintf(
        "    AllocatedAddressLength = %04X\n",
        (USHORT)ReadField (AllocatedAddressLength)
        );

    dprintf(
        "    Flags                  = %04X (",
        buffer.Flags = (USHORT)ReadField(Flags)
        );

    if (buffer.ExpeditedData)
        dprintf (" Exp");
    if (buffer.PartialMessage)
        dprintf (" Partial");
    if (buffer.Lookaside)
        dprintf (" Lookaside");
    if (buffer.NdisPacket)
        dprintf (" Packet");
    dprintf (" )\n");

    if (length!=AFD_DEFAULT_TAG_BUFFER_SIZE) {
        result = (ULONG)InitTypeRead (ActualAddress, AFD!AFD_BUFFER);
        if (result!=0) {
            dprintf ("\nDumpAfdBuffer: Could not read AFD_BUFFER @p, err: %ld\n",
                        ActualAddress, result);
            return ;
        }
        dprintf(
            "    Buffer                 = %p\n",
            buf=ReadField (Buffer)
            );

        dprintf(
            "    Irp                    = %p\n",
            irp = ReadField (Irp)
            );

        dprintf(
            "    Placement              ="
            );

        switch (buffer.Placement) {
        case AFD_PLACEMENT_HDR:
            dprintf (" Header-first\n");
            buf = ActualAddress;
            break;
        case AFD_PLACEMENT_IRP:
            dprintf (" Irp-first\n");
            buf = irp;
            break;
        case AFD_PLACEMENT_MDL:
            dprintf (" Mdl-first\n");
            buf = mdl;
            break;
        case AFD_PLACEMENT_BUFFER:
            dprintf (" Buffer-first\n");
            // buf = buf;
            break;
        }
        if (buffer.AlignmentAdjusted) {
            ULONG64 adj;
            if (ReadPointer (buf - (IsPtr64 () ? 8 : 4), &adj)) {
                dprintf(
                    "    AlignmentAdjustment    = %p\n",
                    adj
                    );
            }
            else {
                dprintf(
                    "    Could not read alignment adjustment below %p\n",
                    buf);
            }
        }
    }

    dprintf( "\n" );

}   // DumpAfdBuffer


VOID
DumpAfdBufferBrief(
    ULONG64 ActualAddress
    )
{
    ULONG   length;
    LPSTR   raddr;
    UCHAR   transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64 address;
    AFD_BUFFER_HEADER   buffer;

    address = ReadField (TdiInfo.RemoteAddress);
    length = (ULONG)ReadField (TdiInfo.RemoteAddressLength);
    buffer.Flags = (USHORT)ReadField (Flags);

    if( address != 0 && length != 0) {
        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            raddr = TransportAddressToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            raddr = "Read error!";
        }
    }
    else {
        raddr = "";
    }


    dprintf (/*  Buffer    Size Length Offst Context   Mdl|IRP   Flags Rem Addr*/
        IsPtr64 ()
            ? "\n%011.011p %4.4x %4.4x %4.4x %011.011p %011.011p %6s %-32.32s" 
            : "\n%008.008p %4.4x %4.4x %4.4x %008.008p %008.008p %6s %-32.32s",
            DISP_PTR(ActualAddress),
            length = (ULONG)ReadField (BufferLength),
            (ULONG)ReadField (DataLength),
            (ULONG)ReadField (DataOffset),
            DISP_PTR(ReadField (Context)),
            length==0 ? DISP_PTR(ReadField (Mdl)) : DISP_PTR(ReadField (Irp)),
            BufferFlagsToString (&buffer),
            raddr
            );

}   // DumpAfdBufferBrief

ULONG
DumpAfdPollEndpointInfo (
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    ULONG64 file, endp, hndl;
    ULONG   evts;
    ULONG   err;

    if ((err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "FileObject",
                            file))==0 &&
            (err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "Endpoint",
                            endp))==0 &&
            (err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "Handle",
                            hndl))==0 &&
            (err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "PollEvents",
                            evts))==0) {
        dprintf ("        %-16p %-16p %-8x %s%s%s%s%s%s%s%s%s%s%s%s%s\n",
            file, endp, (ULONG)hndl, 
            (evts & AFD_POLL_RECEIVE) ? "rcv " : "",
            (evts & AFD_POLL_RECEIVE_EXPEDITED) ? "rce " : "",
            (evts & AFD_POLL_SEND) ? "snd " : "",
            (evts & AFD_POLL_DISCONNECT) ? "dsc " : "",
            (evts & AFD_POLL_ABORT) ? "abrt " : "",
            (evts & AFD_POLL_LOCAL_CLOSE) ? "cls " : "",
            (evts & AFD_POLL_CONNECT) ? "con " : "",
            (evts & AFD_POLL_ACCEPT) ? "acc " : "",
            (evts & AFD_POLL_CONNECT_FAIL) ? "cnf " : "",
            (evts & AFD_POLL_QOS) ? "qos " : "",
            (evts & AFD_POLL_GROUP_QOS) ? "gqs " : "",
            (evts & AFD_POLL_ROUTING_IF_CHANGE) ? "rif " : "",
            (evts & AFD_POLL_ADDRESS_LIST_CHANGE) ? "adr " : "");
    }
    else {
        dprintf ("        Failed to read endpoint info @ %p, err: %ld\n",
                            pField->address, err);
    }

    return err;
}

VOID
DumpAfdPollInfo (
    ULONG64 ActualAddress
    )
{
    ULONG   numEndpoints, err;
    ULONG64 irp,thread,pid,tid;


    dprintf ("\nAFD_POLL_INFO_INTERNAL @ %p\n", ActualAddress);

    dprintf(
        "    NumberOfEndpoints      = %08lx\n",
        numEndpoints=(ULONG)ReadField (NumberOfEndpoints)
        );

    dprintf(
        "    Irp                    = %p\n",
        irp=ReadField (Irp)
        );

    if ((err=GetFieldValue (irp, "NT!_IRP", "Tail.Overlay.Thread", thread))==0 &&
            (err=GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueProcess", pid))==0 &&
            (err=GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueThread", tid))==0 ){
        dprintf(
            "    Thread                 = %p (%lx.%lx)\n",
            thread, (ULONG)pid, (ULONG)tid);
    }
    else {
        dprintf(
            "   Could not get thread(tid/pid) from irp, err: %ld\n", err);
    }
        

    if (ReadField (TimerStarted)) {
        if (SystemTime.QuadPart!=0 ) {
            dprintf(
                "    Expires                @ %s (cur %s)\n",
                SystemTimeToString (ReadField (Timer.DueTime.QuadPart)-
                                                InterruptTime.QuadPart+
                                                SystemTime.QuadPart),
                SystemTimeToString (SystemTime.QuadPart));
        }
        else {
            dprintf(
                "    Expires                @ %I64x\n",
                ReadField (Timer.DueTime.QuadPart));
        }
    }

     

    dprintf(
        "    Flags                  : %s%s%s\n",
        ReadField (Unique) ? "Unique " : "",
        ReadField (TimerStarted) ? "TimerStarted " : "",
        ReadField (SanPoll) ? "SanPoll " : ""
        );
    if (numEndpoints>0) {
        FIELD_INFO flds = {
                    NULL,
                    NULL,
                    numEndpoints,
                    0,
                    0,
                    DumpAfdPollEndpointInfo};
        SYM_DUMP_PARAM sym = {
           sizeof (SYM_DUMP_PARAM), 
           "AFD!AFD_POLL_ENDPOINT_INFO",
           DBG_DUMP_NO_PRINT | DBG_DUMP_ARRAY,
           ActualAddress+PollEndpointInfoOffset,
           &flds, 
           NULL,
           NULL,
           0,
           NULL
        };    
        dprintf ( "        File Object      Endpoint         Handle   Events\n");
        Ioctl(IG_DUMP_SYMBOL_INFO, &sym, sym.size);
    }
}

VOID
DumpAfdPollInfoBrief (
    ULONG64 ActualAddress
    )
{
    ULONG64 irp, thread=0, pid=0, tid=0;
    BOOLEAN timerStarted, unique, san;
    CHAR dueTime[16];
    
    irp = ReadField (Irp);
    GetFieldValue (irp, "NT!_IRP", "Tail.Overlay.Thread", thread);
    GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueProcess", pid);
    GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueThread", tid);

    timerStarted = ReadField (TimerStarted)!=0;
    unique = ReadField (Unique)!=0;
    san = ReadField (SanPoll)!=0;

    if (timerStarted) {
        TIME_FIELDS timeFields;
        LARGE_INTEGER diff;
        diff.QuadPart = ReadField (Timer.DueTime.QuadPart)-InterruptTime.QuadPart;
        RtlTimeToElapsedTimeFields( &diff, &timeFields );
        sprintf (dueTime, "%2.2d:%2.2d:%2.2d.%3.3d",
                            timeFields.Day*24+timeFields.Hour,
                            timeFields.Minute,
                            timeFields.Second,
                            timeFields.Milliseconds);
    }
    else {
        sprintf (dueTime, "NEVER       ");
    }
    dprintf (//PollInfo    IRP       Thread    (pid.tid)   Expr Flags Hdls  Array
        IsPtr64 ()
            ? "\n%011.011p %011.011p %011.011p %4.4x.%4.4x %12s %1s%1s%1s %4.4x %011.011p"
            : "\n%008.008p %008.008p %008.008p %4.4x.%4.4x %12s %1s%1s%1s %4.4x %008.008p",
        DISP_PTR(ActualAddress),
        DISP_PTR(irp),
        DISP_PTR(thread),
        (ULONG)pid,
        (ULONG)tid,
        dueTime,
        timerStarted ? "T" : " ",
        unique ? "U" : " ",
        san ? "S" : " ",
        (ULONG)ReadField (NumberOfEndpoints),
        DISP_PTR (ActualAddress+PollEndpointInfoOffset));
}
//
//  Private functions.
//

PSTR
StructureTypeToString(
    USHORT Type
    )

/*++

Routine Description:

    Maps an AFD structure type to a displayable string.

Arguments:

    Type - The AFD structure type to map.

Return Value:

    PSTR - Points to the displayable form of the structure type.

--*/

{

    switch( Type ) {

    case AfdBlockTypeEndpoint :
        return "Endpoint";

    case AfdBlockTypeVcConnecting :
        return "VcConnecting";

    case AfdBlockTypeVcListening :
        return "VcListening";

    case AfdBlockTypeDatagram :
        return "Datagram";

    case AfdBlockTypeConnection :
        return "Connection";

    case AfdBlockTypeHelper :
        return "Helper";

    case AfdBlockTypeVcBoth:
        return "Listening Root";

    }

    return "INVALID";

}   // StructureTypeToString

PSTR
StructureTypeToStringBrief (
    USHORT Type
    )

/*++

Routine Description:

    Maps an AFD structure type to a displayable string.

Arguments:

    Type - The AFD structure type to map.

Return Value:

    PSTR - Points to the displayable form of the structure type.

--*/

{

    switch( Type ) {

    case AfdBlockTypeEndpoint :
        return "Enp";

    case AfdBlockTypeVcConnecting :
        return "Vc ";

    case AfdBlockTypeVcListening :
        return "Lsn";

    case AfdBlockTypeDatagram :
        return "Dg ";

    case AfdBlockTypeConnection :
        return "Con";

    case AfdBlockTypeHelper :
        return "Hlp";

    case AfdBlockTypeVcBoth:
        return "Rot";

    }

    return "???";

}   // StructureTypeToString

PSTR
BooleanToString(
    BOOLEAN Flag
    )

/*++

Routine Description:

    Maps a BOOELEAN to a displayable form.

Arguments:

    Flag - The BOOLEAN to map.

Return Value:

    PSTR - Points to the displayable form of the BOOLEAN.

--*/

{

    return Flag ? "TRUE" : "FALSE";

}   // BooleanToString

PSTR
EndpointStateToString(
    UCHAR State
    )

/*++

Routine Description:

    Maps an AFD endpoint state to a displayable string.

Arguments:

    State - The AFD endpoint state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD endpoint state.

--*/

{

    switch( State ) {

    case AfdEndpointStateOpen :
        return "Open";

    case AfdEndpointStateBound :
        return "Bound";

    case AfdEndpointStateConnected :
        return "Connected";

    case AfdEndpointStateCleanup :
        return "Cleanup";

    case AfdEndpointStateClosing :
        return "Closing";

    case AfdEndpointStateTransmitClosing :
        return "Transmit Closing";

    case AfdEndpointStateInvalid :
        return "Invalid";

    }

    return "INVALID";

}   // EndpointStateToString

PSTR
EndpointStateToStringBrief(
    UCHAR State
    )

/*++

Routine Description:

    Maps an AFD endpoint state to a displayable string.

Arguments:

    State - The AFD endpoint state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD endpoint state.

--*/

{

    switch( State ) {

    case AfdEndpointStateOpen :
        return "Opn";

    case AfdEndpointStateBound :
        return "Bnd";

    case AfdEndpointStateConnected :
        return "Con";

    case AfdEndpointStateCleanup :
        return "Cln";

    case AfdEndpointStateClosing :
        return "Cls";

    case AfdEndpointStateTransmitClosing :
        return "TrC";

    case AfdEndpointStateInvalid :
        return "Inv";

    }

    return "???";

}   // EndpointStateToString

PSTR
EndpointStateFlagsToString(
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Maps an AFD endpoint state flags to a displayable string.

Arguments:

    Endpoint - The AFD endpoint which state flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD endpoint state flags.

--*/

{
    static CHAR buffer[13];

    buffer[0] = (Endpoint->NonBlocking) ? 'N' : ' ';
    buffer[1] = (Endpoint->InLine) ? 'I' : ' ';
    buffer[2] = (Endpoint->EndpointCleanedUp) ? 'E' : ' ';
    buffer[3] = (Endpoint->PollCalled) ? 'P' : ' ';
    buffer[4] = (Endpoint->RoutingQueryReferenced) ? 'Q' : ' ';
    buffer[5] = (Endpoint->DisableFastIoSend) ? 'S' : ' ';
    buffer[6] = (Endpoint->DisableFastIoRecv) ? 'R' : ' ';
    buffer[7] = (Endpoint->AdminAccessGranted) ? 'A' : ' ';
    switch (Endpoint->DisconnectMode) {
    case 0:
        buffer[8] = ' ';
        break;
    case 1:
        buffer[8] = 's';
        break;
    case 2:
        buffer[8] = 'r';
        break;
    case 3:
        buffer[8] = 'b';
        break;
    default:
        buffer[8] = '?';
        break;
    }
    if (Endpoint->Type==AfdBlockTypeDatagram) {
        buffer[9]  = Endpoint->Common.Datagram.CircularQueueing ? 'C' : ' ';
        buffer[10] = Endpoint->Common.Datagram.HalfConnect ? 'H' : ' ';
        buffer[11] = '0' + (CHAR)
                           ((Endpoint->Common.Datagram.AddressDrop <<0)+
                            (Endpoint->Common.Datagram.ResourceDrop<<1)+
                            (Endpoint->Common.Datagram.BufferDrop  <<2)+
                            (Endpoint->Common.Datagram.ErrorDrop   <<3));
    }
    else {
        buffer[9]  = (Endpoint->Listening) ? 'L' : ' ';
        buffer[10] = ' ';
        buffer[11] = ' ';
    }
    buffer[12] = 0;

    return buffer;
}

PSTR
EndpointTypeToString(
    ULONG TypeFlags
    )

/*++

Routine Description:

    Maps an AFD_ENDPOINT_TYPE to a displayable string.

Arguments:

    Type - The AFD_ENDPOINT_TYPE to map.

Return Value:

    PSTR - Points to the displayable form of the AFD_ENDPOINT_TYPE.

--*/

{

    switch( TypeFlags ) {

    case AfdEndpointTypeStream :
        return "Stream";

    case AfdEndpointTypeDatagram :
        return "Datagram";

    case AfdEndpointTypeRaw :
        return "Raw";

    case AfdEndpointTypeSequencedPacket :
        return "SequencedPacket";

	default:
		if (TypeFlags&(~AFD_ENDPOINT_VALID_FLAGS))
			return "INVALID";
        else {
            static CHAR buffer[64];
            INT n = 0;
            buffer[0] = 0;
            if (TypeFlags & AFD_ENDPOINT_FLAG_CONNECTIONLESS)
                n += sprintf (&buffer[n], "con-less ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_MESSAGEMODE)
                n += sprintf (&buffer[n], "msg ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_RAW)
                n += sprintf (&buffer[n], "raw ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_MULTIPOINT)
                n += sprintf (&buffer[n], "m-point ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_CROOT)
                n += sprintf (&buffer[n], "croot ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_DROOT)
                n += sprintf (&buffer[n], "droot ");
            return buffer;
        }

    }
}   // EndpointTypeToString

PSTR
ConnectionStateToString(
    USHORT State
    )

/*++

Routine Description:

    Maps an AFD connection state to a displayable string.

Arguments:

    State - The AFD connection state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD connection state.

--*/

{
    switch( State ) {

    case AfdConnectionStateFree :
        return "Free";

    case AfdConnectionStateUnaccepted :
        return "Unaccepted";

    case AfdConnectionStateReturned :
        return "Returned";

    case AfdConnectionStateConnected :
        return "Connected";

    case AfdConnectionStateClosing :
        return "Closing";

    }

    return "INVALID";

}   // ConnectionStateToString

PSTR
ConnectionStateToStringBrief(
    USHORT State
    )

/*++

Routine Description:

    Maps an AFD connection state to a displayable string.

Arguments:

    State - The AFD connection state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD connection state.

--*/

{
    switch( State ) {

    case AfdConnectionStateFree :
        return "Fre";

    case AfdConnectionStateUnaccepted :
        return "UnA";

    case AfdConnectionStateReturned :
        return "Rtn";

    case AfdConnectionStateConnected :
        return "Con";

    case AfdConnectionStateClosing :
        return "Cls";

    }

    return "???";

}   // ConnectionStateToStringBrief

PSTR
ConnectionStateFlagsToString(
    PAFD_CONNECTION   Connection
    )

/*++

Routine Description:

    Maps an AFD connection state flags to a displayable string.

Arguments:

    Connection - The AFD connection which state flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD connection state flags.

--*/

{
    static CHAR buffer[8];

    buffer[0] =  (Connection->AbortIndicated) ? 'A' : ' ';
    buffer[1] =  (Connection->DisconnectIndicated) ? 'D' : ' ';
    buffer[2] =  (Connection->ConnectedReferenceAdded) ? 'R' : ' ';
    buffer[3] =  (Connection->SpecialCondition) ? 'S' : ' ';
    buffer[4] =  (Connection->CleanupBegun) ? 'C' : ' ';
    buffer[5] =  (Connection->ClosePendedTransmit) ? 'T' : ' ';
    buffer[6] =  (Connection->OnLRList) ? 'L' : ' ';
    buffer[7] = 0;

    return buffer;
}

PSTR
TranfileFlagsToString(
    ULONG   Flags,
    ULONG   StateFlags
    )

/*++

Routine Description:

    Maps an AFD transmit file info flags to a displayable string.

Arguments:

    TransmitInfo - The AFD transmit file info which flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD transmit file info flags.

--*/

{
    static CHAR buffer[18];

    buffer[0] =  (Flags & AFD_TF_WRITE_BEHIND) ? 'b' : ' ';
    buffer[1] =  (Flags & AFD_TF_DISCONNECT) ? 'd' : ' ';
    buffer[2] =  (Flags & AFD_TF_REUSE_SOCKET) ? 'r' : ' ';
    buffer[3] =  (Flags & AFD_TF_USE_SYSTEM_THREAD) ? 's' : 'a';
    buffer[4] = '|';
    buffer[5] =  (StateFlags & AFD_TP_ABORT_PENDING) ? 'A' : ' ';
    buffer[6] =  (StateFlags & AFD_TP_WORKER_SCHEDULED) ? 'W' : ' ';
    buffer[7] =  (StateFlags & AFD_TP_READ_BUSY) ? '0' : ' ';
    buffer[8] =  (StateFlags & AFD_TP_SEND_BUSY(0)) ? '1' : ' ';
    buffer[9] =  (StateFlags & AFD_TP_SEND_BUSY(1)) ? '2' : ' ';
    buffer[10] =  (StateFlags & AFD_TP_SEND_BUSY(2)) ? '3' : ' ';
    buffer[11] =  (StateFlags & AFD_TP_SEND_BUSY(3)) ? '4' : ' ';
    buffer[12] =  (StateFlags & AFD_TP_SEND_BUSY(4)) ? '5' : ' ';
    buffer[13] =  (StateFlags & AFD_TP_SEND_BUSY(5)) ? '6' : ' ';
    buffer[14] =  (StateFlags & AFD_TP_SEND_BUSY(6)) ? '7' : ' ';
    buffer[15] =  (StateFlags & AFD_TP_SEND_BUSY(7)) ? '8' : ' ';
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    buffer[16] =  (StateFlags & AFD_TP_SEND_AND_DISCONNECT) ? '&' : ' ';
    buffer[17] = 0;
#else
    buffer[16] = 0;
#endif

    return buffer;
}

PSTR
BufferFlagsToString(
    PAFD_BUFFER_HEADER   AfdBuffer
    )

/*++

Routine Description:

    Maps an AFD buffer flags to a displayable string.

Arguments:

    TransmitInfo - The AFD buffer which flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD buffer flags.

--*/

{
    static CHAR buffer[7];

    buffer[0] =  (AfdBuffer->ExpeditedData) ? 'E' : ' ';
    buffer[1] =  (AfdBuffer->PartialMessage) ? 'P' : ' ';
    buffer[2] =  (AfdBuffer->Lookaside) ? 'L' : ' ';
    buffer[3] =  (AfdBuffer->NdisPacket) ? 'N' : ' ';
    switch (AfdBuffer->Placement) {
    case AFD_PLACEMENT_HDR:
        buffer[4] = 'h';
        break;
    case AFD_PLACEMENT_IRP:
        buffer[4] = 'i';
        break;
    case AFD_PLACEMENT_MDL:
        buffer[4] = 'm';
        break;
    case AFD_PLACEMENT_BUFFER:
        buffer[4] = 'b';
        break;
    }
    buffer[5] = (AfdBuffer->AlignmentAdjusted) ? 'A' : ' ';
    buffer[6] = 0;

    return buffer;
}



PSTR
SystemTimeToString(
    LONGLONG Value
    )

/*++

Routine Description:

    Maps a LONGLONG representing system time to a displayable string.

Arguments:

    Value - The LONGLONG time to map.

Return Value:

    PSTR - Points to the displayable form of the system time.

Notes:

    This routine is NOT multithread safe!

--*/

{

    static char buffer[64];
    NTSTATUS status;
    LARGE_INTEGER systemTime;
    LARGE_INTEGER localTime;
    TIME_FIELDS timeFields;

    systemTime.QuadPart = Value;

    status = RtlSystemTimeToLocalTime( &systemTime, &localTime );

    if( !NT_SUCCESS(status) ) {

		sprintf(buffer, "%I64x", Value);
        return buffer;

    }

    RtlTimeToTimeFields( &localTime, &timeFields );

    sprintf(
        buffer,
        "%s %s %2d %4d %02d:%02d:%02d.%03d",
        WeekdayNames[timeFields.Weekday],
        MonthNames[timeFields.Month],
        timeFields.Day,
        timeFields.Year,
        timeFields.Hour,
        timeFields.Minute,
        timeFields.Second,
        timeFields.Milliseconds
        );

    return buffer;

}   // SystemTimeToString



PSTR
GroupTypeToString(
    AFD_GROUP_TYPE GroupType
    )

/*++

Routine Description:

    Maps an AFD_GROUP_TYPE to a displayable string.

Arguments:

    GroupType - The AFD_GROUP_TYPE to map.

Return Value:

    PSTR - Points to the displayable form of the AFD_GROUP_TYPE.

--*/

{

    switch( GroupType ) {

    case GroupTypeNeither :
        return "Neither";

    case GroupTypeConstrained :
        return "Constrained";

    case GroupTypeUnconstrained :
        return "Unconstrained";

    }

    return "INVALID";

}   // GroupTypeToString

PSTR
ListToString (
    ULONG64 ListHead,
    ULONG64 Flink
    )
{
    static CHAR buffer[32];

    if (ListHead==Flink) {
        sprintf (buffer, "= EMPTY");
    }
    else if (IsPtr64()) {
        sprintf (buffer, "@ %I64X", ListHead);
    }
    else {
        sprintf (buffer, "@ %X", (ULONG)ListHead);
    }
    return buffer;
}

PAFDKD_TRANSPORT_INFO
ReadTransportInfo (
    ULONG64   ActualAddress
    )
{

    ULONG               result, length;
    PAFDKD_TRANSPORT_INFO transportInfo;
    ULONG64             buffer;

    if( GetFieldValue(
            ActualAddress,
            "AFD!AFD_TRANSPORT_INFO",
            "TransportDeviceName.Length",
            length
            )!=0 ||
         GetFieldValue(
            ActualAddress,
            "AFD!AFD_TRANSPORT_INFO",
            "TransportDeviceName.Buffer",
            buffer
            )!=0) {

        dprintf(
            "\nReadTransportInfo: Could not read AFD_TRANSPORT_INFO @ %p\n",
            ActualAddress
            );

        return NULL;

    }

    if (length < sizeof (L"\\Device\\")-2) {
        dprintf(
            "\nReadTransportInfo: transport info (@%p) device name length (%ld) is less than sizeof (L'\\Device\\')-2\n",
            ActualAddress,
            length
            );

        return NULL;
    }


    transportInfo = RtlAllocateHeap (RtlProcessHeap (), 
                                        0,
                                        FIELD_OFFSET (AFDKD_TRANSPORT_INFO,
                                               DeviceName[length/2+1]));
    if (transportInfo==NULL) {
        dprintf(
            "\nReadTransportInfo: Could not allocate space for transport info.\n"
            );
        return NULL;
    }

    transportInfo->ActualAddress = ActualAddress;

    if (GetFieldValue (
                ActualAddress,
                "AFD!AFD_TRANSPORT_INFO",
                "ReferenceCount",
                transportInfo->ReferenceCount)!=0 ||
            GetFieldValue (
                ActualAddress,
                "AFD!AFD_TRANSPORT_INFO",
                "InfoValid",
                transportInfo->InfoValid)!=0 ||
            GetFieldValue (
                ActualAddress,
                "AFD!AFD_TRANSPORT_INFO",
                "ProviderInfo",
                transportInfo->ProviderInfo)!=0 ||
            !ReadMemory(
                buffer,
                &transportInfo->DeviceName,
                length,
                &result
                )) {

        dprintf(
            "\nReadTransportInfo: Could not read AFD_TRANSPORT_INFO @ %p\n",
            ActualAddress
            );
        RtlFreeHeap (RtlProcessHeap (), 0, transportInfo);

        return NULL;

    }

    transportInfo->DeviceName[length/2] = 0;
    return transportInfo;
}


VOID
DumpTransportInfo (
    PAFDKD_TRANSPORT_INFO TransportInfo
    )
{
    dprintf ("\nTransport Info @ %p\n", TransportInfo->ActualAddress);
    dprintf ("    TransportDeviceName           = %ls\n",
                        TransportInfo->DeviceName);
    dprintf ("    ReferenceCount                = %ld\n",
                        TransportInfo->ReferenceCount);
    if (TransportInfo->InfoValid) {
        dprintf ("    ProviderInfo:\n");
        dprintf ("        Version                   = %8.8lx\n",
                            TransportInfo->ProviderInfo.Version);
        dprintf ("        MaxSendSize               = %ld\n",
                            TransportInfo->ProviderInfo.MaxSendSize);
        dprintf ("        MaxConnectionUserData     = %ld\n",
                            TransportInfo->ProviderInfo.MaxConnectionUserData);
        dprintf ("        MaxDatagramSize           = %ld\n",
                            TransportInfo->ProviderInfo.MaxDatagramSize);
        dprintf ("        ServiceFlags              = %lx (",
                            TransportInfo->ProviderInfo.ServiceFlags);
        if (TDI_SERVICE_ORDERLY_RELEASE & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" OrdRel");
        if (TDI_SERVICE_DELAYED_ACCEPTANCE & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" DelAcc");
        if (TDI_SERVICE_EXPEDITED_DATA & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" Expd");
        if (TDI_SERVICE_INTERNAL_BUFFERING & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" Buff");
        if (TDI_SERVICE_MESSAGE_MODE & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" Msg");
        if (TDI_SERVICE_DGRAM_CONNECTION & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" DgramCon");
        if (TDI_SERVICE_FORCE_ACCESS_CHECK & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" AccChk");
        if (TDI_SERVICE_SEND_AND_DISCONNECT & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" S&D");
        if (TDI_SERVICE_DIRECT_ACCEPT & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" DirAcc");
        if (TDI_SERVICE_ACCEPT_LOCAL_ADDR & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" AcLoAd");
        dprintf (" )\n");

        dprintf ("        MinimumLookaheadData      = %ld\n",
                            TransportInfo->ProviderInfo.MinimumLookaheadData);
        dprintf ("        MaximumLookaheadData      = %ld\n",
                            TransportInfo->ProviderInfo.MaximumLookaheadData);
        dprintf ("        NumberOfResources         = %ld\n",
                            TransportInfo->ProviderInfo.NumberOfResources);
        dprintf ("        StartTime                 = %s\n",
                            SystemTimeToString(TransportInfo->ProviderInfo.StartTime.QuadPart));
    }

}


VOID
DumpTransportInfoBrief (
    PAFDKD_TRANSPORT_INFO TransportInfo
    )
{
    dprintf (//PollInfo    IRP       Thread    (pid.tid)   Expr Flags Hdls  Array
        IsPtr64 ()
            ? "\n%011.011p %-30.30ls %4.4x %3.3x %8.8x %5.5x %5.5x %s"
            : "\n%008.008p %-30.30ls %4.4x %3.3x %8.8x %5.5x %5.5x %s",
        DISP_PTR(TransportInfo->ActualAddress),
        &TransportInfo->DeviceName[sizeof ("\\device\\")-1],
        TransportInfo->ReferenceCount,
        TransportInfo->ProviderInfo.Version,
        TransportInfo->ProviderInfo.MaxSendSize,
        TransportInfo->ProviderInfo.MaxDatagramSize,
        TransportInfo->ProviderInfo.ServiceFlags,
        TdiServiceFlagsToString (TransportInfo->ProviderInfo.ServiceFlags));

}

PSTR
TdiServiceFlagsToString(
    ULONG   Flags
    )

/*++

Routine Description:

    Maps an TDI service flags to a displayable string.

Arguments:

    Flags - flags to map

Return Value:

    PSTR - Points to the displayable form of the TDI service flags.

--*/

{
    static CHAR buffer[10];

    buffer[0] = (TDI_SERVICE_ORDERLY_RELEASE & Flags) ? 'O' : ' ',
    buffer[1] = (TDI_SERVICE_DELAYED_ACCEPTANCE & Flags) ? 'D' : ' ',
    buffer[2] = (TDI_SERVICE_EXPEDITED_DATA & Flags) ? 'E' : ' ',
    buffer[3] = (TDI_SERVICE_INTERNAL_BUFFERING & Flags) ? 'B' : ' ',
    buffer[4] = (TDI_SERVICE_MESSAGE_MODE & Flags) ? 'M' : ' ',
    buffer[5] = (TDI_SERVICE_DGRAM_CONNECTION & Flags) ? 'G' : ' ',
    buffer[6] = (TDI_SERVICE_FORCE_ACCESS_CHECK & Flags) ? 'A' : ' ',
    buffer[7] = (TDI_SERVICE_SEND_AND_DISCONNECT & Flags) ? '&' : ' ',
    buffer[8] = (TDI_SERVICE_DIRECT_ACCEPT & Flags) ? 'R' : ' ',
    buffer[9] = 0;

    return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\conn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    conn.c

Abstract:

    Implements the conn command.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

BOOL
DumpConnectionCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindRemotePortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

//
//  Public functions.
//

DECLARE_API( conn )

/*++

Routine Description:

    Dumps the AFD_CONNECTION structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 address;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER);
    }
    
    //
    // Snag the address from the command line.
    //

    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpConnectionCallback,
            0
            );
        dprintf ("\nTotal connections: %ld", EntityCount);
    }
    else {
        while (sscanf( argp, "%s%n", expr, &i )==1) {

            if( CheckControlC() ) {
                break;
            }

            argp += i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf ("\nconn: Could not read AFD_CONNECTION @ %p, err: %d",
                    address, result);
                break;
            }

            if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdConnectionBrief(
                    address
                    );
            else
                DumpAfdConnection(
                    address
                    );

        }

    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }
}   // conn


DECLARE_API( rport )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures connected to the given port.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 val;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER);
    }

    //
    // Snag the port from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i)==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;
        val = GetExpression (expr);
        dprintf ("\nLooking for connections connected to port 0x%I64X(0d%I64d) ", val, val);
        EnumEndpoints(
            FindRemotePortCallback,
            val
            );
        dprintf ("\nTotal connections: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER);
    }
    else {
        dprintf ("\n");
    }
}   // rport

BOOL
DumpConnectionCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for dumping AFD_ENDPOINTs.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{
    ULONG result;
    AFD_ENDPOINT    endpoint;
    ULONG64 connAddr;

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    if (((endpoint.Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) &&
            ( (connAddr=ReadField (Common.VirtualCircuit.Connection))!=0 ||
                ((endpoint.State==AfdEndpointStateClosing || endpoint.State==AfdEndpointStateTransmitClosing) &&
                    (connAddr=ReadField(WorkItem.Context))!=0) ) ) {

        result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
        if (result!=0) {
            dprintf(
                "\nDumpConnectionCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                connAddr, result
                );
            return TRUE;
        }

        if (Options & AFDKD_NO_DISPLAY)
            dprintf ("+");
        else if (Options & AFDKD_BRIEF_DISPLAY)
            DumpAfdConnectionBrief(
                connAddr
                );
        else
            DumpAfdConnection(
                connAddr
                );
        EntityCount += 1;
    }
    else if ((endpoint.Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
        ULONG64 nextEntry;
        ULONG64 listHead;
        LIST_ENTRY64 listEntry;
        
        listHead = ActualAddress+UnacceptedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nDumpConnectionCallback: Could not read UnacceptedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }

        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nDumpConnectionCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nDumpConnectionCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }

            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdConnectionBrief(
                    connAddr
                    );
            else
                DumpAfdConnection(
                    connAddr
                    );
            EntityCount += 1;

        }



        listHead = ActualAddress + ReturnedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nDumpConnectionCallback: Could not read ReturnedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }
        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nDumpConnectionCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nDumpConnectionCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }

            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdConnectionBrief(
                    connAddr
                    );
            else
                DumpAfdConnection(
                    connAddr
                    );
            EntityCount += 1;
        }
    }
    else {
        dprintf (".");
    }

    return TRUE;

}   // DumpConnectionCallback


BOOLEAN
PortMatch (
    PTRANSPORT_ADDRESS  TransportAddress,
    USHORT              Port
    )
{
    PTA_IP_ADDRESS ipAddress;
    USHORT port;

    ipAddress = (PTA_IP_ADDRESS)TransportAddress;

    if( ( ipAddress->TAAddressCount != 1 ) ||
        ( ipAddress->Address[0].AddressLength < sizeof(TDI_ADDRESS_IP) ) ||
        ( ipAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP ) ) {

        dprintf (",");
        return FALSE;

    }

    port = NTOHS(ipAddress->Address[0].Address[0].sin_port);

    return Port == port;
}


BOOL
FindRemotePortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_CONNECTION connected to a specific
    port.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    ULONG result;
    AFD_ENDPOINT    endpoint;
    ULONG64 connAddr;
    ULONG64 remoteAddr;
    ULONG   remoteAddrLength;
    UCHAR   transportAddress[MAX_TRANSPORT_ADDR];

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    if (((endpoint.Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) &&
            ( (connAddr=ReadField (Common.VirtualCircuit.Connection))!=0 ||
                ((endpoint.State==AfdEndpointStateClosing || endpoint.State==AfdEndpointStateTransmitClosing) &&
                    (connAddr=ReadField(WorkItem.Context))!=0) ) ) {
        result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
        if (result!=0) {
            dprintf(
                "\nFindRemotePortCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                connAddr, result
                );
            return TRUE;
        }

        remoteAddr = ReadField (RemoteAddress);
        remoteAddrLength = (ULONG)ReadField (RemoteAddressLength);
        if (remoteAddr!=0) {
            if (!ReadMemory (remoteAddr,
                            transportAddress,
                            remoteAddrLength<sizeof (transportAddress) 
                                ? remoteAddrLength
                                : sizeof (transportAddress),
                                &remoteAddrLength)) {
                dprintf(
                    "\nFindRemotePortCallback: Could not read remote address for connection @ %p\n",
                    connAddr
                    );
                return TRUE;
            }
        }
        else {
            ULONG64 context;
            ULONG contextLength;
            USHORT addressOffset, addressLength;
            PTRANSPORT_ADDRESS taAddress = (PTRANSPORT_ADDRESS)transportAddress;
            USHORT maxAddressLength = (USHORT)(sizeof (transportAddress) - 
                                        FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType));

            //
            // Attempt to read user mode data stored as the context
            //

            if (GetFieldValue (ActualAddress,
                                "AFD!AFD_ENDPOINT",
                                "Context", 
                                context)==0 &&
                    context!=0 &&
                    GetFieldValue (ActualAddress,
                                "AFD!AFD_ENDPOINT",
                                "ContextLength", 
                                contextLength)==0 &&
                    contextLength!=0 &&
                    GetFieldValue (ActualAddress,
                                "AFD!AFD_ENDPOINT", 
                                "Common.VirtualCircuit.RemoteSocketAddressOffset",
                                addressOffset)==0 &&
                    GetFieldValue (ActualAddress,
                                "AFD!AFD_ENDPOINT", 
                                "Common.VirtualCircuit.RemoteSocketAddressLength",
                                addressLength)==0 &&
                    addressLength!=0 &&
                    contextLength>=(ULONG)(addressOffset+addressLength) &&
                    ReadMemory (context+addressOffset,
                                &taAddress->Address[0].AddressType,
                                addressLength<maxAddressLength
                                        ? addressLength 
                                        : maxAddressLength,
                                &result)) {
                //
                // Initialize fields missing in socket address structure
                //

                taAddress->TAAddressCount = 1;
                taAddress->Address[0].AddressLength = addressLength-sizeof (USHORT);
            }
            else {
                dprintf(
                    "\nFindRemotePortCallback: Could not read remote address for connection @ %p of endpoint context\n",
                    connAddr
                    );
                return TRUE;
            }
        }
        if (PortMatch ((PVOID)transportAddress, (USHORT)Context)) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdConnectionBrief(
                    connAddr
                    );
            else
                DumpAfdConnection(
                    connAddr
                    );
            EntityCount += 1;
        }

    }
    else if ((endpoint.Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
        ULONG64 nextEntry;
        ULONG64 listHead;
        LIST_ENTRY64 listEntry;
        
        listHead = ActualAddress+ UnacceptedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nFindRemotePortCallback: Could not read UnacceptedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }

        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nFindRemotePortCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nFindRemotePortCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }


            remoteAddr = ReadField (RemoteAddress);
            remoteAddrLength = (ULONG)ReadField (RemoteAddressLength);

            if (remoteAddr!=0) {
                if (!ReadMemory (remoteAddr,
                                transportAddress,
                                remoteAddrLength<sizeof (transportAddress) 
                                    ? remoteAddrLength
                                    : sizeof (transportAddress),
                                    &remoteAddrLength)) {
                    dprintf(
                        "\nFindRemotePortCallback: Could not read remote address for connection @ %p\n",
                        connAddr
                        );
                    continue;
                }
            }

            if (PortMatch ((PVOID)transportAddress, (USHORT)Context)) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else if (Options & AFDKD_BRIEF_DISPLAY)
                    DumpAfdConnectionBrief(
                        connAddr
                        );
                else
                    DumpAfdConnection(
                        connAddr
                        );
                EntityCount += 1;
            }
            else {
                dprintf (",");
            }
        }



        listHead = ActualAddress + ReturnedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nFindRemotePortCallback: Could not read ReturnedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }
        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nDumpConnectionCallback: cannot read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nFindRemotePortCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }

            remoteAddr = ReadField (RemoteAddress);
            remoteAddrLength = (ULONG)ReadField (RemoteAddressLength);

            if (remoteAddr!=0) {
                if (!ReadMemory (remoteAddr,
                                transportAddress,
                                remoteAddrLength<sizeof (transportAddress) 
                                    ? remoteAddrLength
                                    : sizeof (transportAddress),
                                    &remoteAddrLength)) {
                    dprintf(
                        "\nFindRemotePortCallback: Could not read remote address for connection @ %p\n",
                        connAddr
                        );
                    continue;
                }
            }

            if (PortMatch ((PVOID)transportAddress, (USHORT)Context)) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else if (Options & AFDKD_BRIEF_DISPLAY)
                    DumpAfdConnectionBrief(
                        connAddr
                        );
                else
                    DumpAfdConnection(
                        connAddr
                        );
                EntityCount += 1;
            }
            else {
                dprintf (",");
            }
        }
    }
    else {
        dprintf (".");
    }

    return TRUE;

}   // FindRemotePortCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\cons.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    cons.h

Abstract:

    Global constant definitions for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _CONS_H_
#define _CONS_H_


#define MAX_TRANSPORT_ADDR  256
#define Address00           Address[0].Address[0]
#define UC(x)               ((UINT)((x) & 0xFF))
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )
#define NTOHL(x)            ( ( ((x))              << (8*3)) | \
							  ( ((x) & 0x0000FF00) << (8*1)) | \
							  ( ((x) & 0x00FF0000) >> (8*1)) | \
							  ( ((x))              >> (8*3)) )


#define PTR64_BITS  44
#define PTR64_MASK  ((1I64<<PTR64_BITS)-1)
#define PTR32_BITS  32
#define PTR32_MASK  ((1I64<<PTR32_BITS)-1)
#define DISP_PTR(x) (IsPtr64() ? (ULONG64)((x)&PTR64_MASK):(ULONG64)((x)&PTR32_MASK))

#define AFDKD_BRIEF_DISPLAY         0x00000001
#define AFDKD_BACKWARD_SCAN         0x00000002
#define AFDKD_ENDPOINT_SCAN         0x00000004
#define AFDKD_NO_DISPLAY            0x00000008

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER32   \
"\nEndpoint Typ State  Flags     Transport    LPort   Counts    Evt Pid  Con/RAdr"
// xxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxxxxxx xxxxx xx xx xx xx xxx xxxx xxxxxxxx

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER64   \
"\nEndpoint    Typ State  Flags     Transport    LPort   Counts    Evt Pid  Con/RemAddr"
// xxxxxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxxxxxx xxxxx xx xx xx xx xxx xxxx xxxxxxxxxxx

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER     (IsPtr64()  \
            ? AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER32)

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER \
"\nFlags: Nblock,Inline,clEaned-up,Polled,routeQuery,-fastSnd,-fastRcv,Adm.access"\
"\n       r-SD_RECV,s-SD_SEND,b-SD_BOTH,Listen,Circ.queue,Half.conn,#-dg.drop mask"\
"\nCounts: Dg/Con - buffered send,recv; Lstn - free,AccEx,pending,failed adds     "\
"\n"



#define AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER32 \
"\nConnectn Stat Flags  Remote Address                   SndB  RcvB  Pid  Endpoint"\
// xxxxxxxx xxx xxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxx xxxxx xxxx xxxxxxxx"

#define AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER64 \
"\nConnection  Stat Flags  Remote Address                   RcvB  SndB  Pid  Endpoint   "\
// xxxxxxxxxxx xxx xxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxx xxxxx xxxx xxxxxxxxxxx

#define AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER   (IsPtr64()  \
            ? AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER64       \
            : AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER32)

#define AFDKD_BRIEF_CONNECTION_DISPLAY_TRAILER \
"\nFlags: Abort-,Disc-indicated,+cRef,Special-cond,Cleaning,Tpack closing,Lr-list"\
"\n"

#define AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER32 \
"\nTPackets    I    R      P      S    Endpoint   Flags             Next Elmt"\
"\nAddress  Transmit Send Arr   Read   Address  App | State         Elmt Cnt."\
// xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxx xxxx xxxx

#define AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER64 \
"\nTPackets      I    R     P     S        Endpoint      Flags             Next Elmt"\
"\nAddress     Transmit    SAr   Read      Address     App | State         Elmt Cnt."\
// xxxxxxxxxxx xxxxxxxxxxx xxx xxxxxxxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxx xxxx xxxx

#define AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER   (IsPtr64()    \
            ? AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER32)


#define AFDKD_BRIEF_TRANFILE_DISPLAY_TRAILER \
"\nApp flags: b-write Behind,d-Disconnect,r-Reuse,s-system threads,a-kernel APCs"\
"\nState flags: A-Aborting,W-Working,S-Sent,Q-Queued,&-s&d,0-reading,1-8-sending"\
"\n"


#define AFDKD_BRIEF_BUFFER_DISPLAY_HEADER32 \
"\nBuffer   Buff Data Data Context  Mdl|IRP  Flags  Remote Address"\
"\nAddress  Size Size Offs Status   Address                       "\
// xxxxxxxx xxxx xxxx xxxx xxxxxxxx xxxxxxxx xxxxxx xxxxxxxx:xxxxxxxxxxxx:xxxx

#define AFDKD_BRIEF_BUFFER_DISPLAY_HEADER64 \
"\nBuffer      Buff Data Data Context     Mdl | IRP   Flags  Remote Address"\
"\nAddress     Size Size Offs Status      Address                          "\
// xxxxxxxxxxx xxxx xxxx xxxx xxxxxxxxxxx xxxxxxxxxxx xxxxxx xxxxxxxx:xxxxxxxxxxxx:xxxx

#define AFDKD_BRIEF_BUFFER_DISPLAY_HEADER   (IsPtr64()    \
            ? AFDKD_BRIEF_BUFFER_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_BUFFER_DISPLAY_HEADER32)


#define AFDKD_BRIEF_BUFFER_DISPLAY_TRAILER                  \
"\nFlags: E-expedited,P-partial,L-lookaside,N-ndis packet  "\
"\n       first: h-header,i-irp,m-mdl,b-buffer             "\
"\n"

#define AFDKD_BRIEF_POLL_DISPLAY_HEADER32 \
"\nPollInfo   IRP     Thread  (pid.tid) Expires in   Flg Hdls Array"\
// xxxxxxxx xxxxxxxx xxxxxxxx xxxx:xxxx xx:xx:xx.xxx xxx xxxx xxxxxxxx

#define AFDKD_BRIEF_POLL_DISPLAY_HEADER64 \
"\nPollInfo        IRP       Thread    (pid.tid) Expires in   Flg Hdls Array"\
// xxxxxxxxxxx xxxxxxxxxxx xxxxxxxxxxx xxxx:xxxx xx:xx:xx.xxx xxx xxxx xxxxxxxxxxx

#define AFDKD_BRIEF_POLL_DISPLAY_HEADER   (IsPtr64()    \
            ? AFDKD_BRIEF_POLL_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_POLL_DISPLAY_HEADER32)


#define AFDKD_BRIEF_POLL_DISPLAY_TRAILER        \
"\nFlags: T-timer started, U-unique, S-SAN poll"\
"\n"


#define AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER32   \
"\nAddrLEnt Device Name                           Address"\
// xxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER64   \
"\nAddrLEntry  Device Name                           Address"\
// xxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER   (IsPtr64()\
            ? AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER64     \
            : AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER32)

#define AFDKD_BRIEF_ADDRLIST_DISPLAY_TRAILER            \
"\n"


#define AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER32  \
"\nTranInfo Device Name                    RefC Ver Max.Send MaxDg Flags"\
// xxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxx xxx xxxxxxxx xxxxx xxxxx-xxxxxxxxx

#define AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER64  \
"\nTranInfo    Device Name                    RefC Ver Max.Send MaxDg Flags"\
// xxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxx xxx xxxxxxxx xxxxx xxxxx-xxxxxxxxx

#define AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER32)

#define AFDKD_BRIEF_TRANSPORT_DISPLAY_TRAILER               \
"\nFlags: Orderly release, Delayed accept, Expedited, internal Buffering,"\
"\n       Message mode, dataGram connection, Access check, s&d, diRect accept"\
"\n"
#endif  // _CONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\data.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    data.h

Abstract:

    Global data definitions for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _DATA_H_
#define _DATA_H_


extern EXT_API_VERSION        ApiVersion;
extern WINDBG_EXTENSION_APIS  ExtensionApis;
extern ULONG64                STeip;
extern ULONG64                STebp;
extern ULONG64                STesp;
extern USHORT                 SavedMajorVersion;
extern USHORT                 SavedMinorVersion;
extern BOOL                   IsCheckedAfd;
extern BOOL                   IsReferenceDebug;
extern LIST_ENTRY             TransportInfoList;
extern ULONG                  Options;
extern ULONG                  EntityCount;
extern ULONG64                StartEndpoint;
extern ULONG64                UserProbeAddress;
extern ULONG                  TicksToMs, TickCount;
extern ULONG                  AfdBufferOverhead;
extern ULONG                  AfdStandardAddressLength;
extern ULONG                  AfdBufferTagSize;

extern LARGE_INTEGER          SystemTime, InterruptTime;

extern ULONG                  DatagramBufferListOffset,
                                DatagramRecvListOffset,
                                DatagramPeekListOffset,
                                RoutingNotifyListOffset,
                                RequestListOffset,
                                EventStatusOffset,
                                ConnectionBufferListOffset,
                                ConnectionSendListOffset,
                                ConnectionRecvListOffset,
                                UnacceptedConnListOffset,
                                ReturnedConnListOffset,
                                ListenConnListOffset,
                                FreeConnListOffset,
                                PreaccConnListOffset,
                                ListenIrpListOffset,
                                PollEndpointInfoOffset,
                                DriverContextOffset,
                                SendIrpArrayOffset,
                                FsContextOffset;

extern ULONG                  EndpointLinkOffset,
                                ConnectionLinkOffset,
                                BufferLinkOffset,
                                AddressEntryLinkOffset,
                                TransportInfoLinkOffset,
                                AddressEntryAddressOffset;

extern ULONG                  ConnRefOffset,
                                EndpRefOffset,
                                TPackRefOffset;

extern ULONG                  RefDebugSize;

extern KDDEBUGGER_DATA64      DebuggerData;


#endif  // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\buffer.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    Implements the buffer command.

Author:

    Keith Moore (keithmo) 15-Apr-1996

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

BOOL
DumpBuffersCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

//
//  Public functions.
//

DECLARE_API( buff )

/*++

Routine Description:

    Dumps the AFD_BUFFER structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   result;
    CHAR    expr[256];
    PCHAR   argp;
    INT     i;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_BUFFER_DISPLAY_HEADER);
    }
    
    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpBuffersCallback,
            0
            );
        dprintf ("\nTotal buffers: %ld", EntityCount);
    }
    else {


        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);
            result = (ULONG)InitTypeRead (address, AFD!AFD_BUFFER_HEADER);
            if (result!=0) {
                dprintf ("\nDumpAfdBuffer: Could not read AFD_BUFFER_HEADER @p, err: %ld\n",
                            address, result);
                break ;
            }

            if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdBufferBrief (
                    address
                    );
            else
                DumpAfdBuffer (
                    address
                    );
        }
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_BUFFER_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

}   // buffer

VOID
DumpBufferList (
    ULONG64 ListAddress,
    LPSTR   Header
    )
{
    LIST_ENTRY64 listEntry;
    ULONG64 address;
    ULONG64 nextEntry;
    ULONG result;

    if( !ReadListEntry(
            ListAddress,
            &listEntry) ) {

        dprintf(
            "\nDumpBufferList: Could not read buffer list head @ %p\n",
            ListAddress
            );
        return ;
    }

    if (listEntry.Flink==ListAddress) {
        dprintf(".");
        return ;
    }

    if (Header) {
        dprintf (Header);
    }

    nextEntry = listEntry.Flink;
    while( nextEntry != ListAddress ) {

        if (nextEntry==0) {
            dprintf(
                "\nDumpBuffersCallback: next entry is NULL for list @ %p\n",
                ListAddress
                );
            break;
        }

        if (CheckControlC ())
            break;

        address = nextEntry - BufferLinkOffset;

        result = (ULONG)InitTypeRead (address, AFD!AFD_BUFFER_HEADER);
        if (result!=0) {
            dprintf ("\nDumpBuffersCallback: Could not read AFD_BUFFER_HEADER @p, err: %ld\n",
                        address, result);
            break ;
        }

        nextEntry = ReadField (BufferListEntry.Flink);
        if (Options & AFDKD_NO_DISPLAY)
            dprintf ("+");
        else if (Options & AFDKD_BRIEF_DISPLAY)
            DumpAfdBufferBrief (
                address
                );
        else
            DumpAfdBuffer (
                address
                );
        EntityCount += 1;
    }
}

ULONG
DumpBufferListCB (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG       result;
    CHAR        header[64];
    AFD_CONNECTION_STATE_FLAGS   flags;
    
    result = GetFieldValue (pField->address, "AFD!AFD_CONNECTION", "ConnectionStateFlags", flags);
    if ((result==0) &&
            !flags.TdiBufferring ) {
        sprintf (header, "\nConnection: %I64X", pField->address);
        DumpBufferList (pField->address+ConnectionBufferListOffset, header);
    }

    return result;
}

BOOL
DumpBuffersCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )
/*++

Routine Description:

    Dumps buffers for the endpoint/connection.

Arguments:

    ActualAddress - The actual address of the list

Return Value:

    ULONG - Sum of pool charged for the buffers in the list.

--*/

{
    AFD_ENDPOINT    endpoint;
    ULONG64         connAddr;
    AFD_CONNECTION_STATE_FLAGS   flags;
    CHAR            header[64];

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    if (endpoint.Type==AfdBlockTypeDatagram) {
        sprintf (header, "\nEndpoint %I64X", ActualAddress);
        DumpBufferList (ActualAddress+DatagramBufferListOffset, header);
    }
    else if (((endpoint.Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) &&
                ( (connAddr=ReadField (Common.VirtualCircuit.Connection))!=0 ||
                    ((endpoint.State==AfdEndpointStateClosing || endpoint.State==AfdEndpointStateTransmitClosing) &&
                        (connAddr=ReadField(WorkItem.Context))!=0) ) &&
                (GetFieldValue (connAddr, "AFD!AFD_CONNECTION", "ConnectionStateFlags", flags)==0) &&
                !flags.TdiBufferring ) {
        sprintf (header, "\nEndpoint: %I64X, connection: %I64X", ActualAddress, connAddr);
        DumpBufferList (connAddr+ConnectionBufferListOffset, header);
    }
    else if ((endpoint.Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
        ListType (
            "AFD!AFD_CONNECTION",                   // Type
            ActualAddress+UnacceptedConnListOffset, // Address
            1,                                      // ListByFieldAddress
            "ListLink.Flink",                       // NextPointer
            NULL,                                   // Context
            DumpBufferListCB                        // Callback
            );

        ListType (
            "AFD!AFD_CONNECTION",                   // Type
            ActualAddress+ReturnedConnListOffset,   // Address
            1,                                      // ListByFieldAddress
            "ListLink.Flink",                       // NextPointer
            NULL,                                   // Context
            DumpBufferListCB                        // Callback
            );
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\afdkdp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    afdkdp.h

Abstract:

    Master header file for the AFD.SYS Kernel Debugger Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _AFDKDP_H_
#define _AFDKDP_H_

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

//
//  System include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NOUSER
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include <ntosp.h>

#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


//
//  Project include files.
//

#define _NTIFS_
#include <afdp.h>


//
//  Local include files.
//

#include "cons.h"
#include "type.h"
#include "data.h"
#include "proc.h"


#endif  // _AFDKDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\afds.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    afds.c

Abstract:

    Implements afds command

Author:

    Vadim Eydelman, March 2000

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

enum AFDKD_COM_OPERATOR {
    AFDKD_LT=-2,
    AFDKD_LE=-1,
    AFDKD_EQ=0,
    AFDKD_GE=1,
    AFDKD_GT=2
};
enum AFDKD_REL_OPERATOR {
    AFDKD_AND=0,
    AFDKD_OR=1
};


typedef struct _AFDKD_EXPRESSION_ {
    LPSTR   FieldName;
    ULONG64 Value;
    enum AFDKD_COM_OPERATOR   ComOp;
    enum AFDKD_REL_OPERATOR   RelOp;
} AFDKD_EXPRESSION, *PAFDKD_EXPRESSION;


ULONG
DumpAFD_ENDPOINT (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

LPSTR
ParseAfdsOptions (
    IN  LPSTR              Args
    );

//
// Public functions.
//

AFDKD_EXPRESSION ExpressionArray[16];
LPSTR            FieldArray[16];

DECLARE_API( afds )

/*++

Routine Description:

    Dumps afd endpoints

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 address;
    LIST_ENTRY64 list;

    if (ParseAfdsOptions ((LPSTR)args)==NULL)
        return;

    address = GetExpression ("afd!AfdEndpointListHead");
    if (address==0) {
        dprintf ("\nafds: Could not find afd!AfdEndpointListHead\n");
        return ;
    }
    if (!ReadListEntry (address, &list)) {
        dprintf ("\nafds: Could not read afd!AfdEndpointListHead\n");
        return ;
    }
    ListType (
        "AFD!AFD_ENDPOINT",         // Type
        list.Flink,                 // Address
        1,                          // ListByFieldAddress
        "GlobalEndpointListEntry.Flink",    // NextPointer
        NULL,                       // Context
        DumpAFD_ENDPOINT);
    dprintf ("\n");
}


ULONG
DumpAFD_ENDPOINT (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;
    ULONG64 value;
    INT ei=0, fi=0;
    BOOLEAN res = TRUE;
    FIELD_INFO flds = {NULL, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
    SYM_DUMP_PARAM sym = {
                    sizeof (SYM_DUMP_PARAM),
                    "AFD!AFD_ENDPOINT",
                    DBG_DUMP_NO_PRINT,
                    pField->address,
                    NULL,
                    NULL,
                    NULL,
                    1,
                    &flds
                    };

    for (ei=0; ExpressionArray[ei].FieldName!=NULL && res; ei++) {
        BOOLEAN res1;
        SIZE_T pos;
        LPSTR   p = ExpressionArray[ei].FieldName;

        do {
            if (CheckControlC ())
                break;

            flds.fName = p;
            pos = strlen(p);
            sym.Options = DBG_DUMP_NO_PRINT;
            result = Ioctl( IG_DUMP_SYMBOL_INFO, &sym, sym.size );
            if (result!=0) {
                dprintf ("\nDumpAFD_ENDPOINT: Can't read %s @ %p, err:%ld\n",
                              ExpressionArray[ei].FieldName, pField->address, result);
                return result;
            }
            value = flds.address;
            if (p[pos+1]=='>') {
                sym.Options = DBG_RETURN_TYPE;
                result = Ioctl( IG_DUMP_SYMBOL_INFO, &sym, sym.size );
                if (result!=0) {
                    dprintf ("\nDumpAFD_ENDPOINT: Can't read %s @ %p, err:%ld\n",
                                  ExpressionArray[ei].FieldName, pField->address, result);
                    return result;
                }
            }
        }
        while (1);
            

        if (CheckControlC ())
            break;

        switch (ExpressionArray[ei].ComOp) {
        case AFDKD_LT:
            res1 = (LONG64)ExpressionArray[ei].Value<(LONG64)flds.address;
            break;
        case AFDKD_LE:
            res1 = (LONG64)ExpressionArray[ei].Value<=(LONG64)flds.address;
            break;
        case AFDKD_EQ:
            res1 = ExpressionArray[ei].Value==flds.address;
            break;
        case AFDKD_GE:
            res1 = (LONG64)ExpressionArray[ei].Value>=(LONG64)flds.address;
            break;
        case AFDKD_GT:
            res1 = (LONG64)ExpressionArray[ei].Value>(LONG64)flds.address;
            break;
        }

        switch (ExpressionArray[ei].RelOp) {
        case AFDKD_AND:
            res &= res1;
            break;
        case AFDKD_OR:
            res |= res1;
            break;
        }
    }

    if (res) {
        InitTypeRead (pField->address, AFD!AFD_ENDPOINT);
        DumpAfdEndpointBrief (pField->address);
    }
    return 0;
}


LPSTR
ParseAfdsOptions (
    IN  LPSTR               Args
    )
{
    INT ei=0, fi=0, i;
    CHAR    expr[256];

    while (sscanf( Args, "%s%n", expr, &i )==1) {
        LPSTR p,p1;
        LPSTR first = strstr (Args, expr);
        Args += i;

        if (CheckControlC ())
            break;

        if ((p=strstr (expr,"&&"))!=NULL) {
            ExpressionArray[ei].RelOp = AFDKD_AND;
            ExpressionArray[ei].FieldName = &first[p-expr+2];
        }
        else if ((p=strstr (expr,"&"))!=NULL) {
            ExpressionArray[ei].RelOp = AFDKD_AND;
            ExpressionArray[ei].FieldName = &first[p-expr+1];
        }
        else if ((p=strstr (expr,"||"))!=NULL) {
            ExpressionArray[ei].RelOp = AFDKD_OR;
            ExpressionArray[ei].FieldName = &first[p-expr+2];
        }
        else if ((p=strstr (expr,"|"))!=NULL) {
            ExpressionArray[ei].RelOp = AFDKD_OR;
            ExpressionArray[ei].FieldName = &first[p-expr+1];
        }
        else {
            FieldArray[fi] = first;
            first[strlen(expr)] = 0;
            dprintf ("\n%s", first);
            if (++fi==sizeof (FieldArray)/sizeof (FieldArray[0])-1) {
                break;
            }
            continue;
        }
        p = expr;
        while ((p1=strstr (p,"->"))!=NULL) {
            if (CheckControlC ())
                break;
            *p1 = 0;
            p = p1+2;
        }

        if ((p1=strstr (p,">="))!=NULL) {
            ExpressionArray[ei].ComOp = AFDKD_GE;
            ExpressionArray[ei].Value = GetExpression (p1+2);
        }
        else if ((p1=strstr (p,">"))!=NULL) {
            ExpressionArray[ei].ComOp = AFDKD_GT;
            ExpressionArray[ei].Value = GetExpression (p1+1);
        }
        else if ((p1=strstr (p,"=="))!=NULL) {
            ExpressionArray[ei].ComOp = AFDKD_EQ;
            ExpressionArray[ei].Value = GetExpression (p1+2);
        }
        else if ((p1=strstr (p,"="))!=NULL) {
            ExpressionArray[ei].ComOp = AFDKD_EQ;
            ExpressionArray[ei].Value = GetExpression (p1+1);
        }
        else if ((p1=strstr (p,"<="))!=NULL) {
            ExpressionArray[ei].ComOp = AFDKD_LE;
            ExpressionArray[ei].Value = GetExpression (p1+2);
        }
        else if ((p1=strstr (p,"<"))!=NULL) {
            ExpressionArray[ei].ComOp = AFDKD_LT;
            ExpressionArray[ei].Value = GetExpression (p1+1);
        }
        else {
            dprintf ("\nProcessAfdsOptions: unknown comparison operator in argument %s\n", expr);
            return NULL;
        }
        first[p1-expr] = 0;

        dprintf ("\n%d %s %d %I64x", ExpressionArray[ei].RelOp,
                                    ExpressionArray[ei].FieldName,
                                    ExpressionArray[ei].ComOp,
                                    ExpressionArray[ei].Value);
        if (++ei==sizeof (ExpressionArray)/sizeof (ExpressionArray[0])-1) {
            break;
        }
    }

    ExpressionArray[ei].FieldName = NULL;
    FieldArray[fi] = NULL;

    return Args;
}


DECLARE_API( filefind )
/*++

Routine Description:

    Searches non-paged pool for FILE_OBJECT given its FsContext field.

Arguments:

    None.

Return Value:

    None.

--*/
{

    ULONG64 FsContext;
    ULONG64 PoolStart, PoolEnd, PoolPage;
    ULONG64 PoolExpansionStart, PoolExpansionEnd;
    ULONG   result;
    ULONG64 val;
    BOOLEAN  twoPools;


    FsContext = GetExpression (args);
    if (FsContext==0 || FsContext<UserProbeAddress) {
        return;
    }

    if ( (result = ReadPtr (DebuggerData.MmNonPagedPoolStart, &PoolStart))!=0 ||
        (result = ReadPtr (DebuggerData.MmNonPagedPoolEnd, &PoolEnd))!=0 ) {
        dprintf ("\nfilefind - Cannot get non-paged pool limits, err: %ld\n",
                result);
        return ;
    }

    if (PoolStart + DebuggerData.MmMaximumNonPagedPoolInBytes!=PoolEnd) {
        if ( (result = GetFieldValue (0,
                            "NT!MmSizeOfNonPagedPoolInBytes",
                            NULL,
                            val))!=0 ||
             (result = GetFieldValue (0,
                            "NT!MmNonPagedPoolExpansionStart",
                            NULL,
                            PoolExpansionStart))!=0 ) {
            dprintf ("\nfilefind - Cannot get non-paged pool expansion limits, err: %ld\n",
                     result);
            return;
        }
        PoolExpansionEnd = PoolEnd;
        PoolEnd = PoolStart + val;
        twoPools = TRUE;
    }
    else {
        twoPools = FALSE;
    }


    PoolPage = PoolStart;
    dprintf ("Searching non-paged pool %p - %p...\n", PoolStart, PoolEnd);
    while (PoolPage<PoolEnd) {
        SEARCHMEMORY Search;

        if (CheckControlC ()) {
            break;
        }

        Search.SearchAddress = PoolPage;
        Search.SearchLength = PoolEnd-PoolPage;
        Search.Pattern = &FsContext;
        Search.PatternLength = IsPtr64 () ? sizeof (ULONG64) : sizeof (ULONG);
        Search.FoundAddress = 0;

        if (Ioctl (IG_SEARCH_MEMORY, &Search, sizeof (Search)) && 
                Search.FoundAddress!=0) {
            ULONG64 fileAddr;
            CSHORT  type;
            fileAddr = Search.FoundAddress-FsContextOffset;
            result = (ULONG)InitTypeRead (fileAddr, NT!_FILE_OBJECT);
            if (result==0 && (CSHORT)ReadField (Type)==IO_TYPE_FILE) {
                dprintf ("File object at %p\n", fileAddr);
            }
            else {
                dprintf ("    pool search match at %p\n", Search.FoundAddress);
            }
            PoolPage = Search.FoundAddress + 
                        (IsPtr64() ? sizeof (ULONG64) : sizeof (ULONG));
        }
        else {
            if (!twoPools || PoolEnd==PoolExpansionEnd) {
                break;
            }
            else {
                dprintf ("Searching expansion non-paged pool %p - %p...\n", 
                                PoolExpansionStart, PoolExpansionEnd);
                PoolEnd = PoolExpansionEnd;
                PoolPage = PoolExpansionStart;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\stats.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    stats.c

Abstract:

    Implements the stats command.

Author:

    Keith Moore (keithmo) 06-May-1996

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Public functions.
//

DECLARE_API( stats )

/*++

Routine Description:

    Dumps the debug-only AFD statistic counters.

Arguments:

    None.

Return Value:

    None.

--*/

{
    AFD_QUOTA_STATS quotaStats;
    AFD_HANDLE_STATS handleStats;
    AFD_QUEUE_STATS queueStats;
    AFD_CONNECTION_STATS connectionStats;
    ULONG64 address;
    ULONG result;

    //
    // Dump the quota statistics.
    //

    address = GetExpression( "afd!AfdQuotaStats" );

    if( address == 0 ) {

        dprintf( "\nstats: Could not find afd!AfdQuotaStats\n" );

    } else {

        if( ReadMemory(
                address,
                &quotaStats,
                sizeof(quotaStats),
                &result
                ) ) {

            dprintf(
                "AfdQuotaStats:\n"
                );

            dprintf(
                "    Charged  = %I64x\n",
                quotaStats.Charged.QuadPart
                );

            dprintf(
                "    Returned = %I64x\n",
                quotaStats.Returned.QuadPart
                );

            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdQuotaStats @ %p\n",
                address
                );

        }

    }

    //
    // Dump the handle statistics.
    //

    address = GetExpression( "afd!AfdHandleStats" );

    if( address == 0 ) {

        dprintf( "stats: Could not find afd!AfdHandleStats\n" );

    } else {

        if( ReadMemory(
                address,
                &handleStats,
                sizeof(handleStats),
                &result
                ) ) {

            dprintf(
                "AfdHandleStats:\n"
                );

            dprintf(
                "    AddrOpened = %lu\n",
                handleStats.AddrOpened
                );

            dprintf(
                "    AddrClosed = %lu\n",
                handleStats.AddrClosed
                );

            dprintf(
                "    AddrRef    = %lu\n",
                handleStats.AddrRef
                );

            dprintf(
                "    AddrDeref  = %lu\n",
                handleStats.AddrDeref
                );

            dprintf(
                "    ConnOpened = %lu\n",
                handleStats.ConnOpened
                );

            dprintf(
                "    ConnClosed = %lu\n",
                handleStats.ConnClosed
                );

            dprintf(
                "    ConnRef    = %lu\n",
                handleStats.ConnRef
                );

            dprintf(
                "    ConnDeref  = %lu\n",
                handleStats.ConnDeref
                );

            dprintf(
                "    FileRef    = %lu\n",
                handleStats.FileRef
                );

            dprintf(
                "    FileDeref  = %lu\n",
                handleStats.FileDeref
                );

            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdHandleStats @ %p\n",
                address
                );

        }

    }

    //
    // Dump the queue statistics.
    //

    address = GetExpression( "afd!AfdQueueStats" );

    if( address == 0 ) {

        dprintf( "stats: Could not find afd!AfdQueueStats\n" );

    } else {

        if( ReadMemory(
                address,
                &queueStats,
                sizeof(queueStats),
                &result
                ) ) {

            dprintf(
                "AfdQueueStats:\n"
                );

            dprintf(
                "    AfdWorkItemsQueued    = %lu\n",
                queueStats.AfdWorkItemsQueued
                );

            dprintf(
                "    ExWorkItemsQueued     = %lu\n",
                queueStats.ExWorkItemsQueued
                );

            dprintf(
                "    WorkerEnter           = %lu\n",
                queueStats.WorkerEnter
                );

            dprintf(
                "    WorkerLeave           = %lu\n",
                queueStats.WorkerLeave
                );

            dprintf(
                "    AfdWorkItemsProcessed = %lu\n",
                queueStats.AfdWorkItemsProcessed
                );

            dprintf(
                "    AfdWorkerThread       = %p\n",
                (ULONG64)queueStats.AfdWorkerThread
                );

            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdQueueStats @ %p\n",
                address
                );

        }

    }

    //
    // Dump the queue statistics.
    //

    address = GetExpression( "afd!AfdConnectionStats" );

    if( address == 0 ) {

        dprintf( "\nstats: Could not find afd!AfdConnectionStats\n" );

    } else {

        if( ReadMemory(
                address,
                &connectionStats,
                sizeof(connectionStats),
                &result
                ) ) {

            dprintf(
                "AfdConnectionStats:\n"
                );

            dprintf(
                "    ConnectedReferencesAdded      = %lu\n",
                connectionStats.ConnectedReferencesAdded
                );

            dprintf(
                "    ConnectedReferencesDeleted    = %lu\n",
                connectionStats.ConnectedReferencesDeleted
                );

            dprintf(
                "    GracefulDisconnectsInitiated  = %lu\n",
                connectionStats.GracefulDisconnectsInitiated
                );

            dprintf(
                "    GracefulDisconnectsCompleted  = %lu\n",
                connectionStats.GracefulDisconnectsCompleted
                );

            dprintf(
                "    GracefulDisconnectIndications = %lu\n",
                connectionStats.GracefulDisconnectIndications
                );

            dprintf(
                "    AbortiveDisconnectsInitiated  = %lu\n",
                connectionStats.AbortiveDisconnectsInitiated
                );

            dprintf(
                "    AbortiveDisconnectsCompleted  = %lu\n",
                connectionStats.AbortiveDisconnectsCompleted
                );

            dprintf(
                "    AbortiveDisconnectIndications = %lu\n",
                connectionStats.AbortiveDisconnectIndications
                );

            dprintf(
                "    ConnectionIndications         = %lu\n",
                connectionStats.ConnectionIndications
                );

            dprintf(
                "    ConnectionsDropped            = %lu\n",
                connectionStats.ConnectionsDropped
                );

            dprintf(
                "    ConnectionsAccepted           = %lu\n",
                connectionStats.ConnectionsAccepted
                );

            dprintf(
                "    ConnectionsPreaccepted        = %lu\n",
                connectionStats.ConnectionsPreaccepted
                );

            dprintf(
                "    ConnectionsReused             = %lu\n",
                connectionStats.ConnectionsReused
                );


            dprintf(
                "    EndpointsReused               = %lu\n",
                connectionStats.EndpointsReused
                );


            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdConnectionStats @ %p\n",
                address
                );

        }

    }

}   // stats
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\ref.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ref.c

Abstract:

    Implements the cref, eref, and gref commands.

Author:

    Keith Moore (keithmo) 09-Dec-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Public functions.
//

DECLARE_API( ref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "ref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "Usage: ref address\n" );
        return;

    }

    DumpAfdReferenceDebug(
        address,0
        );

}   // ref

DECLARE_API( eref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   idx;

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "eref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "\nUsage: eref endpoint_address\n" );
        return;

    }

    if (GetFieldValue (address,
             "AFD!AFD_ENDPOINT",
             "CurrentReferenceSlot",
             idx)!=0) {

        dprintf("\neref: Could not read CurrentReferenceSlot for endpoint %p\n",
                  address );
        return;
    }

    DumpAfdReferenceDebug(
        address+EndpRefOffset, idx
        );

}   // eref

DECLARE_API( cref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   idx;

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "cref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "\nUsage: cref connection_address\n" );
        return;

    }

    if (GetFieldValue (address,
             "AFD!AFD_CONNECTION",
             "CurrentReferenceSlot",
             idx)!=0) {

        dprintf("\ncref: Could not read CurrentReferenceSlot for connection %p\n",
                  address );
        return;
    }


    DumpAfdReferenceDebug(
        address+ConnRefOffset, idx
        );

}   // cref

DECLARE_API( tref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   idx;

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "tref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "\nUsage: tref tpacket_info_address\n" );
        return;

    }

    if (GetFieldValue (address,
             "AFD!AFD_TPACKETS_INFO_INTERNAL",
             "CurrentReferenceSlot",
             idx)!=0) {

        dprintf("\ntref: Could not read CurrentReferenceSlot for tpInfo %p\n",
                  address );
        return;
    }


    DumpAfdReferenceDebug(
        address+TPackRefOffset, idx
        );

}   // tref


DECLARE_API( gref )

/*++

Routine Description:

    Dumps the AFD_GLOBAL_REFERENCE_DEBUG structure in the system.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if GLOBAL_REFERENCE_DEBUG

    ULONG64 address;
    DWORD currentSlot;
    DWORD slot;
    ULONG result;
    ULONG64 compareAddress = 0;
    DWORD numEntries;
    DWORD maxEntries;
    DWORD entriesToRead;
    CHAR buffer[sizeof(AFD_GLOBAL_REFERENCE_DEBUG) * 64];

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsCheckedAfd ) {

        dprintf(
            "gref: this command only available with CHECKED AFD.SYS!\n"
            );

        return;

    }

    //
    // Snag the optional "connection compare" address from the command line.
    //

    sscanf( args, "%lx", &compareAddress );

    //
    // Find the global reference data.
    //

    address = GetExpression( "afd!AfdGlobalReference" );

    if( address == 0 ) {

        dprintf( "cannot find afd!AfdGlobalReference\n" );
        return;

    }

    currentSlot = GetExpression( "afd!AfdGlobalReferenceSlot" );

    if( currentSlot == 0 ) {

        dprintf( "cannot find afd!AfdGlobalReferenceSlot\n" );
        return;

    }

    if( !ReadMemory(
            currentSlot,
            &currentSlot,
            sizeof(currentSlot),
            &result
            ) ) {

        dprintf( "cannot read afd!AfdGlobalReferenceSlot\n" );
        return;

    }

    if( currentSlot < MAX_GLOBAL_REFERENCE ) {

        numEntries = currentSlot;

    } else {

        numEntries = MAX_GLOBAL_REFERENCE;

    }

    //
    // Dump it all.
    //

    slot = 0;
    maxEntries = sizeof(buffer) / sizeof(AFD_GLOBAL_REFERENCE_DEBUG);
    currentSlot %= MAX_GLOBAL_REFERENCE;

    while( numEntries > 0 ) {

        entriesToRead = min( numEntries, maxEntries );

        if (CheckControlC ())
            break;

        if( !ReadMemory(
                address,
                buffer,
                entriesToRead * sizeof(AFD_GLOBAL_REFERENCE_DEBUG),
                &result
                ) ) {

            dprintf(
                "gref: cannot read AFD_GLOBAL_REFERENCE_DEBUG @ %p\n",
                address
                );

            return;

        }

        if( DumpAfdGlobalReferenceDebug(
                (PAFD_GLOBAL_REFERENCE_DEBUG)buffer,
                address,
                currentSlot,
                slot,
                entriesToRead,
                compareAddress
                ) ) {

            break;

        }

        address += entriesToRead * sizeof(AFD_GLOBAL_REFERENCE_DEBUG);
        slot += entriesToRead;
        numEntries -= entriesToRead;

    }

#else

    dprintf(
        "gref: not yet implemented\n"
        );

#endif

}   // gref
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    help.c

Abstract:

    Help for AFD.SYS Kernel Debugger Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Public functions.
//

DECLARE_API( help )

/*++

Routine Description:

    Displays help for the AFD.SYS Kernel Debugger Extensions.

Arguments:

    None.

Return Value:

    None.

--*/

{

    dprintf( "?                         - Displays this list\n" );
    dprintf( "help                      - Displays this list\n" );
    dprintf( "\n");
    dprintf( "endp [-b|-c] [-r] [-s endp | endp...] - Dumps endpoint(s)\n" );
    dprintf( "file [-b] [file...]       - Dumps endpoint(s) associated with file object(s)\n" );
    dprintf( "port [-b|-c] [-r] [-s endp] port [port...] - Dumps endpoint(s) bound to port(s)\n" );
    dprintf( "state [-b|-c] [-r] [-s endp] state [state...] - Dumps endpoints in specific states\n" );
    dprintf( "proc [-b|-c] [-r] [-s endp] proc|pid [proc|pid...] - Dumps endpoints owned by processes\n" );
    dprintf( "\n");
    dprintf( "conn [-b|-c] [-r] [-s endp | conn...] - Dumps connections\n" );

    dprintf( "rport [-b|-c] [-r] [-s endp] port [port...] - Dumps connections to remote ports\n" );
    dprintf( "\n");
    dprintf( "tran [-b|-c] [-r] [-s endp | irp...] - Dumps transmit packets(file) info\n" );
    dprintf( "\n");
    dprintf( "buff [-b|-c] [-r] [-s endp | buff...] - Dumps buffer structure\n" );
    dprintf( "\n");
    dprintf( "poll [-b|-c] [-r] [-s endp | poll...] - Dumps poll info structure(s)\n" );
    dprintf( "\n");
    dprintf( "addr [-b] addr... - Dumps transport addresses\n" );
    dprintf( "addrlist -b   - Dumps addresses registered by the transports\n" );
    dprintf( "tranlist -b   - Dumps transports known to afd (have open sockets)\n" );
    dprintf( "filefind <FsContext> - Finds file object given its FsContext field value\n" );
    dprintf( "In all of the above:\n" );
    dprintf( "      -b      - use brief display (1-line per entry),\n" );
    dprintf( "      -c      - don't display entity data, just counts,\n" );
    dprintf( "      -s endp - scan list starting with this endpoint,\n" );
    dprintf( "      -r      - scan endpoint list in reverse order,\n" );
    dprintf( "      endp    - AFD_ENDPOINT structure at address <endp>,\n" );
    dprintf( "      file    - FILE_OBJECT structure at address <file>,\n" );
    dprintf( "      conn    - AFD_CONNECTION structure at address <conn>,\n" );
    dprintf( "      proc    - EPROCESS structure at address <proc>,\n" );
    dprintf( "      pid     - process id,\n" );
    dprintf( "      port    - port in host byte order and current debugger base (use n 10|16 to set),\n" );
    dprintf( "      irp     - TPackets/TFile/DisconnectEx IRP at address <irp>,\n" );
    dprintf( "      buff    - AFD_BUFFER_HEADER structure at address <buff>,\n" );
    dprintf( "      poll    - AFD_POLL_INFO_INTERNAL structure at address <poll>,\n" );
    dprintf( "      addr    - TRANSPORT_ADDRESS structure at address <addr>,\n" );
    dprintf( "      state   - endpoint state, valid states are:\n" );
    dprintf( "                  1 - Open\n" );
    dprintf( "                  2 - Bound\n" );
    dprintf( "                  3 - Connected\n" );
    dprintf( "                  4 - Cleanup\n" );
    dprintf( "                  5 - Closing\n" );
    dprintf( "                  6 - TransmitClosing\n" );
    dprintf( "                  7 - Invalid\n" );
    dprintf( "                  10 - Listening.\n" );
    dprintf( "\n");
    if( IsReferenceDebug ) {
        dprintf( "ref  <ref_addr>     - Dumps reference debug info\n" );
        dprintf( "cref <conn_addr>    - Dumps connection reference debug info\n" );
        dprintf( "eref <endp_addr>    - Dumps endpoint reference debug info\n" );
        dprintf( "tref <tpck_addr>    - Dumps tpacket reference debug info\n" );
        dprintf ("\n");
    }
    dprintf( "stats               - Dumps debug-only statistics\n" );
    dprintf( "\n");
#if GLOBAL_REFERENCE_DEBUG
    dprintf( "gref                - Dumps global reference debug info\n" );
#endif

}   // help


ULONG           Options;
ULONG64         StartEndpoint;

PCHAR
ProcessOptions (
    IN  PCHAR Args
    )
{
    CHAR    expr[256];
    INT     i;

    Options = 0;

    while (sscanf( Args, "%s%n", expr, &i )==1) {
        Args += i;
        if (CheckControlC ())
            break;
        if (expr[0]=='-') {
            switch (expr[1]) {
            case 'B':
            case 'b':
                if ((Options & AFDKD_NO_DISPLAY)==0) {
                    Options |= AFDKD_BRIEF_DISPLAY;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: only one of -c or -b options can be specified.\n");
                }
                break;
            case 'R':
            case 'r':
                Options |= AFDKD_BACKWARD_SCAN;
                continue;
            case 'S':
            case 's':
                Options |= AFDKD_ENDPOINT_SCAN;
                if (sscanf( Args, "%s%n", expr, &i )==1) {
                    Args += i;
                    StartEndpoint = GetExpression (expr);
                    if (StartEndpoint!=0) {
                        dprintf ("ProcessOptions: StartEndpoint-%p\n", StartEndpoint);
                        continue;
                    }
                    else {
                        dprintf ("ProcessOptions: StartEndpoint (%s) evaluates to NULL\n", expr);
                    }

                }
                else {
                    dprintf ("\nProcessOptions: %s option missing required parameter.\n", expr);
                }
                break;
            case 'C':
            case 'c':
                if ((Options & AFDKD_BRIEF_DISPLAY)==0) {
                    Options |= AFDKD_NO_DISPLAY;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: only one of -c or -b options can be specified.\n");
                }
                break;
            default:
                dprintf ("\nProcessOptions: Unrecognized option %s.\n", expr);
            }

            return NULL;
        }
        else {
            Args -= i;
            break;
        }
    }

    return Args;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "afdkdp.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//

EXT_API_VERSION        ApiVersion = {
                                VER_PRODUCTVERSION_W >> 8,
                                VER_PRODUCTVERSION_W & 0xFF,
                                EXT_API_VERSION_NUMBER64,
                                0 
};

WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG64                STeip;
ULONG64                STebp;
ULONG64                STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
LIST_ENTRY             TransportInfoList;

BOOL                   IsCheckedAfd;
BOOL                   IsReferenceDebug;
ULONG64                UserProbeAddress;
ULONG                  TicksToMs, TickCount;
ULONG                  AfdBufferOverhead;
ULONG                  AfdStandardAddressLength;
ULONG                  AfdBufferTagSize;
LARGE_INTEGER          SystemTime, InterruptTime;

ULONG                  DatagramBufferListOffset,
                        DatagramRecvListOffset,
                        DatagramPeekListOffset,
                        RoutingNotifyListOffset,
                        RequestListOffset,
                        EventStatusOffset,
                        ConnectionBufferListOffset,
                        ConnectionSendListOffset,
                        ConnectionRecvListOffset,
                        UnacceptedConnListOffset,
                        ReturnedConnListOffset,
                        ListenConnListOffset,
                        FreeConnListOffset,
                        PreaccConnListOffset,
                        ListenIrpListOffset,
                        PollEndpointInfoOffset,
                        DriverContextOffset,
                        SendIrpArrayOffset,
                        FsContextOffset;

ULONG                  EndpointLinkOffset,
                        ConnectionLinkOffset,
                        BufferLinkOffset,
                        AddressEntryLinkOffset,
                        TransportInfoLinkOffset,
                        AddressEntryAddressOffset;

ULONG                  ConnRefOffset,
                        EndpRefOffset,
                        TPackRefOffset;

ULONG                  RefDebugSize;

KDDEBUGGER_DATA64      DebuggerData;

ULONG                  AfdResult, NtResult;
BOOLEAN                GlobalsRead;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            while (!IsListEmpty (&TransportInfoList)) {
                PLIST_ENTRY  listEntry;
                PAFDKD_TRANSPORT_INFO   transportInfo;
                listEntry = RemoveHeadList (&TransportInfoList);
                transportInfo = CONTAINING_RECORD (listEntry,
                                        AFDKD_TRANSPORT_INFO,
                                        Link);
                RtlFreeHeap (RtlProcessHeap (), 0, transportInfo);
            }
            break;

        case DLL_PROCESS_ATTACH:
            InitializeListHead (&TransportInfoList);
            GlobalsRead = FALSE;
            NtResult = 0;
            AfdResult = 0;
            break;
    }

    return TRUE;
}


ULONG
ReadTimeInfo (
    VOID
    )
{
    ULONG   result;
    if ((result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                            "NT!_KUSER_SHARED_DATA",
                            "TickCountLow",
                            TickCount))!=0 ||
                (result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                            "NT!_KUSER_SHARED_DATA",
                            "TickCountMultiplier",
                            TicksToMs))!=0 ||
                (result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                            "NT!_KUSER_SHARED_DATA",
                            "InterruptTime.High1Time",
                            InterruptTime.HighPart))!=0 ||
                (result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                        "NT!_KUSER_SHARED_DATA",
                        "InterruptTime.LowPart",
                        InterruptTime.LowPart))!=0 ||
                (result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                        "NT!_KUSER_SHARED_DATA",
                        "SystemTime.High1Time",
                        SystemTime.HighPart))!=0 ||
                (result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                        "NT!_KUSER_SHARED_DATA",
                        "SystemTime.LowPart",
                        SystemTime.LowPart))!=0 ) {
    }

    return result;
}

VOID
ReadGlobals ( 
    VOID
    )
{
    ULONG             result;
    ULONG64           val;
    INT               i;
    struct {
        LPSTR       Type;
        LPSTR       Field;
        PULONG      pOffset;
    } MainOffsets[] = {
        {"AFD!AFD_ENDPOINT",    "Common.Datagram.ReceiveBufferListHead",&DatagramBufferListOffset    },
        {"AFD!AFD_ENDPOINT",    "Common.Datagram.ReceiveIrpListHead",   &DatagramRecvListOffset      },
        {"AFD!AFD_ENDPOINT",    "Common.Datagram.PeekIrpListHead",      &DatagramPeekListOffset      },
        {"AFD!AFD_ENDPOINT",    "RoutingNotifications",                 &RoutingNotifyListOffset     },
        {"AFD!AFD_ENDPOINT",    "RequestList",                          &RequestListOffset           },
        {"AFD!AFD_ENDPOINT",    "EventStatus",                          &EventStatusOffset           },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.UnacceptedConnectionListHead",
                                                                        &UnacceptedConnListOffset    },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.ReturnedConnectionListHead",
                                                                        &ReturnedConnListOffset      },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.ListenConnectionListHead",
                                                                        &ListenConnListOffset        },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.FreeConnectionListHead",
                                                                        &FreeConnListOffset          },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead",
                                                                        &PreaccConnListOffset        },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.ListeningIrpListHead",
                                                                        &ListenIrpListOffset         },
        {"AFD!AFD_ENDPOINT",    "GlobalEndpointListEntry",              &EndpointLinkOffset          },
        {"AFD!AFD_CONNECTION",  "Common.NonBufferring.ReceiveBufferListHead",
                                                                        &ConnectionBufferListOffset  },
        {"AFD!AFD_CONNECTION",  "Common.NonBufferring.SendIrpListHead", &ConnectionSendListOffset    },
        {"AFD!AFD_CONNECTION",  "Common.NonBufferring.ReceiveIrpListHead",
                                                                        &ConnectionRecvListOffset    },
        {"AFD!AFD_CONNECTION",  "ListEntry",                            &ConnectionLinkOffset        },
        {"AFD!AFD_POLL_INFO_INTERNAL","EndpointInfo",                   &PollEndpointInfoOffset      },
        {"AFD!AFD_TPACKETS_INFO_INTERNAL","SendIrp",                    &SendIrpArrayOffset          },
        {"AFD!AFD_ADDRESS_ENTRY","Address",                             &AddressEntryAddressOffset   },
        {"AFD!AFD_ADDRESS_ENTRY","AddressListLink",                     &AddressEntryLinkOffset      },
        {"AFD!AFD_BUFFER_HEADER","BufferListEntry",                     &BufferLinkOffset            },
        {"AFD!AFD_TRANSPORT_INFO","TransportInfoListEntry",             &TransportInfoLinkOffset     },
        {"NT!_FILE_OBJECT",     "FsContext",                            &FsContextOffset             },
        {"NT!_IRP",             "Tail.Overlay.DriverContext",           &DriverContextOffset         }
    };
    struct {
        LPSTR       Type;
        LPSTR       Field;
        PULONG      pOffset;
    } RefOffsets[] = {
        {"AFD!AFD_ENDPOINT",    "ReferenceDebug",                       &EndpRefOffset               },
        {"AFD!AFD_CONNECTION",  "ReferenceDebug",                       &ConnRefOffset               },
        {"AFD!AFD_TPACKETS_INFO_INTERNAL","ReferenceDebug",             &TPackRefOffset              }
    };

        


    //
    // Try to get a pointer to afd!AfdDebug. If we can, then we know
    // the target machine is running a checked AFD.SYS.
    //

    IsCheckedAfd = ( GetExpression( "AFD!AfdDebug" ) != 0 );
    IsReferenceDebug = ( GetExpression( "AFD!AfdReferenceEndpoint" ) != 0 );

    if (GetDebuggerData (KDBG_TAG, &DebuggerData, sizeof (DebuggerData))) {
        result = ReadPtr (DebuggerData.MmUserProbeAddress, &UserProbeAddress);
        if (result!=0) {
            if (result!=NtResult) {
                dprintf ("\nReadGlobals: could not read nt!MmUserProbeAddress, err: %ld\n");
                NtResult = result;
            }
        }
    }
    else {
        dprintf ("\nReadGlobals: Could not get KDDEBUGGER_DATA64\n");
        NtResult = 1;
    }

    result = ReadTimeInfo ();
    if (result!=0) {
        if (result!=AfdResult) {
            dprintf("\nReadGlobals: Could not read time info from USER_SHARED_DATA, err: %ld\n", result);
            AfdResult = result;
        }
    }

    result = GetFieldValue (0,
                            "AFD!AfdBufferOverhead",
                            NULL,
                            val);
    if (result!=0) {
        if (result!=AfdResult) {
            dprintf("\nReadGlobals: Could not read afd!AfdBufferOverhead, err: %ld\n", result);
            AfdResult = result;
        }
    }
    AfdBufferOverhead = (ULONG)val;

    result = GetFieldValue (0,
                            "AFD!AfdStandardAddressLength",
                            NULL,
                            val);
    if (result!=0) {
        if (result!=AfdResult) {
            dprintf("\nReadGlobals: Could not read AFD!AfdStandardAddressLength, err: %ld\n", result);
            AfdResult = result;
        }
    }
    AfdStandardAddressLength = (ULONG)val;

    AfdBufferTagSize = GetTypeSize ("AFD!AFD_BUFFER_TAG");
    if (AfdBufferTagSize==0) {
        if (result!=AfdResult) {
            dprintf ("\nReadGlobals: Could not get sizeof (AFD_BUFFER_TAG)\n");
            AfdResult = result;
        }
    }

    for (i=0; i<sizeof (MainOffsets)/sizeof (MainOffsets[0]); i++ ) {
        result = GetFieldOffset (MainOffsets[i].Type, MainOffsets[i].Field, MainOffsets[i].pOffset);
        if (result!=0) {
            if (result!=AfdResult) {
                dprintf ("\nReadGlobals: Could not get offset of %s in %s, err: %ld\n",
                                    MainOffsets[i].Field, MainOffsets[i].Type, result);
                AfdResult = result;
            }
        }
    }

    if (IsReferenceDebug ) {
        for (i=0; i<sizeof (RefOffsets)/sizeof (RefOffsets[0]); i++ ) {
            result = GetFieldOffset (RefOffsets[i].Type, RefOffsets[i].Field, RefOffsets[i].pOffset);
            if (result!=0) {
                if (result!=AfdResult) {
                    dprintf ("\nReadGlobals: Could not get offset of %s in %s, err: %ld\n",
                                        RefOffsets[i].Field, RefOffsets[i].Type, result);
                    AfdResult = result;
                }
            }
        }
        RefDebugSize = GetTypeSize ("AFD!AFD_REFERENCE_LOCATION");
        if (RefDebugSize==0) {
            dprintf ("\nReadGlobals: sizeof (AFD!AFD_REFERENCE_LOCATION) is 0!!!!!\n");
        }
    }

    if (NtResult==0 && AfdResult==0) {
        GlobalsRead = TRUE;
    }


}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    GlobalsRead = FALSE;
    NtResult = 0;
    AfdResult = 0;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    ReadGlobals ();
    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );

    dprintf( "Running %s AFD.SYS\n",
        IsCheckedAfd ? "Checked" : (IsReferenceDebug ? "Free with reference debug" : "Free")
           );
}

VOID
CheckVersion(
    VOID
    )
{
    ULONG   LowTime, result;
    if (!GlobalsRead) {
        ReadGlobals ();
    }
    
    result = GetFieldValue(MM_SHARED_USER_DATA_VA,
                            "NT!_KUSER_SHARED_DATA", 
                            "SystemTime.LowPart", 
                            LowTime);
    if (result==0) {
        if (LowTime!=SystemTime.LowPart) {
            result = ReadTimeInfo ();
            if (result!=0) {
                dprintf("\nCheck version: Could not read time info from USER_SHARED_DATA, err: %ld\n", result);
            }
        }
    }
    else {
        dprintf ("\nCheckVersion: could not read USER_SHARED_DATA, err: %ld\n", result);
    }
    
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\proc.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    proc.h

Abstract:

    Global procedure declarations for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _PROC_H_
#define _PROC_H_


//
//  Functions from AFDUTIL.C.
//

VOID
DumpAfdEndpoint(
    ULONG64 ActualAddress
    );

VOID
DumpAfdEndpointBrief(
    ULONG64 ActualAddress
    );

VOID
DumpAfdConnection(
    ULONG64 ActualAddress
    );

VOID
DumpAfdConnectionBrief(
    ULONG64 ActualAddress
    );

VOID
DumpAfdReferenceDebug(
    ULONG64 ActualAddress,
    ULONG   Idx
    );


#if GLOBAL_REFERENCE_DEBUG
BOOL
DumpAfdGlobalReferenceDebug(
    PAFD_GLOBAL_REFERENCE_DEBUG ReferenceDebug,
    ULONG64 ActualAddress,
    DWORD CurrentSlot,
    DWORD StartingSlot,
    DWORD NumEntries,
    ULONG64 CompareAddress
    );
#endif

VOID
DumpAfdTransmitInfo(
    ULONG64 ActualAddress
    );

VOID
DumpAfdTransmitInfoBrief (
    ULONG64 ActualAddress
    );

VOID
DumpAfdBuffer(
    ULONG64 ActualAddress
    );

VOID
DumpAfdBufferBrief(
    ULONG64 ActualAddress
    );

VOID
DumpAfdPollInfo (
    ULONG64 ActualAddress
    );

VOID
DumpAfdPollInfoBrief (
    ULONG64 ActualAddress
    );

PAFDKD_TRANSPORT_INFO
ReadTransportInfo (
    ULONG64   ActualAddress
    );

VOID
DumpTransportInfo (
    PAFDKD_TRANSPORT_INFO TransportInfo
    );

VOID
DumpTransportInfoBrief (
    PAFDKD_TRANSPORT_INFO TransportInfo
    );

//
// Function from help.c
//

PCHAR
ProcessOptions (
    IN  PCHAR Args
    );

//
//  Functions from DBGUTIL.C.
//

PSTR
LongLongToString(
    LONGLONG Value
    );


//
//  Functions from ENUMENDP.C.
//

VOID
EnumEndpoints(
    PENUM_ENDPOINTS_CALLBACK Callback,
    ULONG64 Context
    );



//
//  Functions from TDIUTIL.C.
//

VOID
DumpTransportAddress(
    PCHAR Prefix,
    PTRANSPORT_ADDRESS Address,
    ULONG64 ActualAddress
    );

LPSTR
TransportAddressToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    );

LPSTR
TransportPortToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    );


#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\poll.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    poll.c

Abstract:

    Implements the poll command

Author:

    Vadim Eydelman (vadime) 25-Oct-2000

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private prototypes.
//

//
//  Public functions.
//

DECLARE_API( poll )

/*++

Routine Description:

    Dumps the AFD_POLL_INFO_INTERNAL structure 

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 address;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return ;

    if (argp[0]==0) {
        LIST_ENTRY64 listEntry;
        ULONG64 nextEntry;
        ULONG64 listHead;

        dprintf (AFDKD_BRIEF_POLL_DISPLAY_HEADER);
        
        listHead = GetExpression( "afd!AfdPollListHead" );
        if( listHead == 0 ) {
            dprintf( "\npoll: Could not find afd!AfdPollListHead\n" );
            return;
        }

        if( !ReadListEntry(
                listHead,
                &listEntry) ) {
            dprintf(
                "\npoll: Could not read afd!AfdPollListHead @ %p\n",
                listHead
                );
            return;
        }
        nextEntry = listEntry.Flink;
        address = listHead;
        while( nextEntry != listHead ) {
            if (nextEntry==0) {
                dprintf ("\npoll: Flink is NULL, last poll: %p\n", address);
                break;
            }

            if( CheckControlC() ) {
                break;
            }

            address = nextEntry;
            result = (ULONG)InitTypeRead (address, AFD!AFD_POLL_INFO_INTERNAL);
            if( result!=0) {
                dprintf(
                    "\npoll: Could not read AFD_POLL_INFO_INTERNAL @ %p, err: %d\n",
                    address, result
                    );
                return;
            }
            nextEntry = ReadField (PollListEntry.Flink);

            DumpAfdPollInfoBrief (address);
        }
        dprintf (AFDKD_BRIEF_POLL_DISPLAY_TRAILER);
    }
    else {
        //
        // Snag the address from the command line.
        //

        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }
            argp += i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, AFD!AFD_POLL_INFO_INTERNAL);
            if (result!=0) {
                dprintf ("\npoll: Could not read AFD_POLL_INFO_INTERNAL @ %p, err: %d\n",
                    address, result);
                break;
            }

            DumpAfdPollInfo (address);
        }
        dprintf ("\n");
    }
}   // poll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\enumendp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    enumendp.c

Abstract:

    Enumerates all AFD_ENDPOINT structures in the system.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

ULONG EntityCount;
//
//  Public functions.
//

VOID
EnumEndpoints(
    PENUM_ENDPOINTS_CALLBACK Callback,
    ULONG64 Context
    )

/*++

Routine Description:

    Enumerates all AFD_ENDPOINT structures in the system, invoking the
    specified callback for each endpoint.

Arguments:

    Callback - Points to the callback to invoke for each AFD_ENDPOINT.

    Context - An uninterpreted context value passed to the callback
        routine.

Return Value:

    None.

--*/

{

    LIST_ENTRY64 listEntry;
    ULONG64 address;
    ULONG64 nextEntry;
    ULONG64 listHead;
    ULONG result;

    EntityCount = 0;

    listHead = GetExpression( "afd!AfdEndpointListHead" );

    if( listHead == 0 ) {

        dprintf( "\nEnumEndpoints: Could not find afd!AfdEndpointlistHead\n" );
        return;

    }

    if( !ReadListEntry(
            listHead,
            &listEntry) ) {

        dprintf(
            "\nEnumEndpoints: Could not read afd!AfdEndpointlistHead @ %p\n",
            listHead
            );
        return;

    }

    if (Options & AFDKD_ENDPOINT_SCAN) {
        nextEntry = StartEndpoint+EndpointLinkOffset;
    }
    else if (Options & AFDKD_BACKWARD_SCAN) {
        nextEntry = listEntry.Blink;
    }
    else {
        nextEntry = listEntry.Flink;
    }

    while( nextEntry != listHead ) {

        if (nextEntry==0) {
            dprintf ("\nEnumEndpoints: Flink is NULL, last endpoint: %p\n", address);
            break;
        }

        if( CheckControlC() ) {

            break;

        }

        address = nextEntry - EndpointLinkOffset;
        result = (ULONG)InitTypeRead (address, AFD!AFD_ENDPOINT);

        if( result!=0) {

            dprintf(
                "\nEnumEndpoints: Could not read AFD_ENDPOINT @ %p, err: %d\n",
                address, result
                );

            return;

        }

        if (Options & AFDKD_BACKWARD_SCAN) {
            nextEntry = ReadField (GlobalEndpointListEntry.Blink);
        }
        else {
            nextEntry = ReadField (GlobalEndpointListEntry.Flink);
        }

        if( !(Callback)( address, Context ) ) {

            break;

        }

    }

}   // EnumEndpoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\endp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    endp.c

Abstract:

    Implements the endp, state, port, and proc commands.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private prototypes.
//

BOOL
DumpEndpointCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindStateCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindPortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindProcessCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

ULONG64
FindProcessByPid (
    ULONG64 Pid
    );

ULONG
FindProcessByPidCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

//
//  Public functions.
//

DECLARE_API( endp )

/*++

Routine Description:

    Dumps the AFD_ENDPOINT structure at the specified address, if
    given or all endpoints.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 address;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }
    
    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpEndpointCallback,
            0
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }
    else {

        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, AFD!AFD_ENDPOINT);
            if (result!=0) {
                dprintf ("\nendp: Could not read AFD_ENDPOINT @ %p, err: %d\n",
                    address, result);
                break;
            }

            if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdEndpointBrief (
                    address
                    );
            else
                DumpAfdEndpoint (
                    address
                    );

        }

    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }
}   // endp


//
//  Public functions.
//

DECLARE_API( file )

/*++

Routine Description:

    Dumps the AFD_ENDPOINT structure associated with AFD file object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 address, endpAddr;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return ;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }
    
    //
    // Snag the address from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }
        argp += i;
        address = GetExpression (expr);
        result = GetFieldValue (address,
                                "NT!_FILE_OBJECT",
                                "FsContext",
                                endpAddr);
        if (result!=0) {
            dprintf ("\nfile: Could not read FILE_OBJECT @ %p, err: %d\n",
                address, result);
            break;
        }

        result = (ULONG)InitTypeRead (endpAddr, AFD!AFD_ENDPOINT);
        if (result!=0) {
            dprintf ("\nfile: Could not read AFD_ENDPOINT @ %p, err: %d\n",
                endpAddr, result);
            break;
        }

        if (Options & AFDKD_BRIEF_DISPLAY)
            DumpAfdEndpointBrief (
                endpAddr
                );
        else
            DumpAfdEndpoint (
                endpAddr
                );

    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
}   // file

DECLARE_API( state )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures in the given state.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 val;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return ;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }

    //
    // Snag the state from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;
        val = GetExpression (expr);
        dprintf ("\nLooking for endpoints in state 0x%I64x ", val);
        EnumEndpoints(
            FindStateCallback,
            val
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

}   // state


DECLARE_API( port )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures bound to the given port.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64   val;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return ;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }

    //
    // Snag the port from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i)==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;
        val = GetExpression (expr);
        dprintf ("\nLooking for endpoints bound to port 0x%I64x (0x%I64d) ", val, val);
        EnumEndpoints(
            FindPortCallback,
            val
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }
}   // port



DECLARE_API( proc )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures owned by the given process.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[256];
    PCHAR   argp;
    ULONG64 val;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return ;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }

    //
    // Snag the process from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;

        val = GetExpression (expr);
        if (val<UserProbeAddress) {
            if (val!=0) {
                dprintf ("\nLooking for process with id %I64x", val);
                val = FindProcessByPid (val);
                if (val==0) {
                    dprintf ("\n");
                    return;
                }
            }
            else {
                ULONG64 CurrentThread;
                GetCurrentThreadAddr (dwProcessor, &CurrentThread);
                GetCurrentProcessAddr (dwProcessor, CurrentThread, &val);
            }
        }
        dprintf ("\nLooking for endpoints in process %p", val);
        EnumEndpoints(
            FindProcessCallback,
            val
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }


}   // proc


//
//  Private prototypes.
//

BOOL
DumpEndpointCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for dumping AFD_ENDPOINTs.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    if (Options & AFDKD_NO_DISPLAY)
        dprintf ("+");
    else if (Options & AFDKD_BRIEF_DISPLAY)
        DumpAfdEndpointBrief (
            ActualAddress
            );
    else
        DumpAfdEndpoint (
            ActualAddress
            );
    EntityCount += 1;

    return TRUE;

}   // DumpEndpointCallback

BOOL
FindStateCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_ENDPOINTs in a specific state.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{
    UCHAR   state = (UCHAR)Context;
    AFD_ENDPOINT    endpoint;

    endpoint.EndpointStateFlags = (ULONG)ReadField (EndpointStateFlags);
    if (state==0x10) {
        if (endpoint.Listening) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdEndpointBrief (
                    ActualAddress
                    );
            else
                DumpAfdEndpoint (
                    ActualAddress
                    );
            EntityCount += 1;

        }
        else {
            dprintf (".");
        }
    }
    else {

        endpoint.State = (UCHAR)ReadField (State);
        if( (endpoint.State == state) && !endpoint.Listening ) {

            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdEndpointBrief (
                    ActualAddress
                    );
            else
                DumpAfdEndpoint (
                    ActualAddress
                    );
            EntityCount += 1;

        }
        else {
            dprintf (".");
        }

    }

    return TRUE;

}   // FindStateCallback

BOOL
FindPortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_ENDPOINT bound to a specific
    port.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    TA_IP_ADDRESS   ipAddress;
    ULONG result;
    USHORT endpointPort;
    ULONG64 address;
    ULONG   length;

    address = ReadField (LocalAddress);
    length = (ULONG)ReadField (LocalAddressLength);


    if( ( length != sizeof(ipAddress) ) ||
        ( address == 0 ) ) {

        dprintf (".");
        return TRUE;

    }

    if( !ReadMemory(
            address,
            &ipAddress,
            sizeof(ipAddress),
            &result
            ) ) {

        dprintf(
            "\nFindPortCallback: Could not read localAddress for endpoint @ %p\n",
            address
            );

        return TRUE;

    }

    if( ( ipAddress.TAAddressCount != 1 ) ||
        ( ipAddress.Address[0].AddressLength != sizeof(TDI_ADDRESS_IP) ) ||
        ( ipAddress.Address[0].AddressType != TDI_ADDRESS_TYPE_IP ) ) {

        dprintf (".");
        return TRUE;

    }

    endpointPort = NTOHS(ipAddress.Address[0].Address[0].sin_port);

    if( endpointPort == (USHORT)Context ) {

        if (Options & AFDKD_NO_DISPLAY)
            dprintf ("+");
        else if (Options & AFDKD_BRIEF_DISPLAY)
            DumpAfdEndpointBrief (
                ActualAddress
                );
        else
            DumpAfdEndpoint (
                ActualAddress
                );
        EntityCount += 1;


    }
    else {
        dprintf (".");
    }


    return TRUE;

}   // FindPortCallback

BOOL
FindProcessCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_ENDPOINTs owned by a specific
    process.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    AFD_ENDPOINT    endpoint;
    ULONG64         process;

    process = ReadField (OwningProcess);
    if( process == Context ) {

        endpoint.Type = (USHORT)ReadField (Type);
        endpoint.State = (UCHAR)ReadField (State);
        if (Options & AFDKD_NO_DISPLAY)
            dprintf ("+");
        else if (Options & AFDKD_BRIEF_DISPLAY)
            DumpAfdEndpointBrief (
                ActualAddress
                );
        else
            DumpAfdEndpoint (
                ActualAddress
                );
        EntityCount += 1;


    }
    else {
        dprintf (".");
    }

    return TRUE;

}   // FindProcessCallback

ULONG
FindProcessByPidCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    PULONG64    pProcess = UserContext;
    ULONG64     Pid;
    ULONG       result;

    result = GetFieldValue (
                    pField->address,
                    "NT!_EPROCESS", 
                    "UniqueProcessId",
                    Pid
                    );
    if (result==0) {
        if (Pid==*pProcess) {
            *pProcess = pField->address;
            result = 1;
        }
        else
            dprintf (".");
    }
    else {
        dprintf ("\nFindProcessByPidCallback: Could not read process @ %p, err: %ld\n",
                    pField->address, result);
        *pProcess = 0;
    }

    return result;
}

ULONG64
FindProcessByPid (
    ULONG64 Pid
    )
{
    ULONG64 Process;
    if (DebuggerData.PsActiveProcessHead==0) {
        dprintf ("\nFindProcessByPid: PsActiveProcessHead is NULL!!!\n");
        return 0;
    }

    Process = Pid;

    ListType (
        "NT!_EPROCESS",                          // Type
        DebuggerData.PsActiveProcessHead,       // Address
        1,                                      // ListByFieldAddress
        "ActiveProcessLinks.Flink",             // NextPointer
        &Process,                               // Context
        FindProcessByPidCallback
        );
    return Process;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\tranfile.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tranfile.c

Abstract:

    Implements the tranfile command.

Author:

    Keith Moore (keithmo) 15-Apr-1996

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

BOOL
DumpTransmitInfoCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

//
//  Public functions.
//

DECLARE_API( tran )

/*++

Routine Description:

    Dumps the AFD_TRANSMIT_FILE_INFO_INTERNAL structure at the specified
    address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    CHAR    expr[256];
    INT     i;
    PCHAR   argp;
    ULONG64 address;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return ;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER);
    }

    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpTransmitInfoCallback,
            0
            );
        dprintf ("\nTotal transmits: %ld", EntityCount);
    }
    else {
        //
        // Snag the address from the command line.
        //

        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }
            argp += i;
            address = GetExpression (expr);
            result = (ULONG)InitTypeRead (address, NT!_IRP);
            if (result!=0) {
                dprintf(
                    "\ntranfile: Could not read IRP @ %p, err:%d\n",
                    address, result
                    );

                break;

            }


            if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdTransmitInfoBrief(
                    address
                    );
            else
                DumpAfdTransmitInfo(
                    address
                    );
        }
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_TRANFILE_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

}   // tranfile

BOOL
DumpTransmitInfoCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for dumping transmit info structures.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{
    ULONG result;
    ULONG64 irp;
    AFD_ENDPOINT endpoint;

    irp = ReadField (Irp);
    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);


    if (irp!=0 && 
            endpoint.Type!=AfdBlockTypeEndpoint && 
            (endpoint.State==AfdEndpointStateConnected ||
                endpoint.State==AfdEndpointStateTransmitClosing)) {
        result = (ULONG)InitTypeRead (irp, NT!_IRP);
        if (result!=0) {
            dprintf(
                "\nDumpTransmitInfoCallback: Could not read irp @ %p, err: %ld\n",
                irp, result
                );
            return TRUE;
        }
        if (Options & AFDKD_NO_DISPLAY)
            dprintf ("+");
        else {
            if (Options & AFDKD_BRIEF_DISPLAY)
                DumpAfdTransmitInfoBrief(
                    irp
                    );
            else
                DumpAfdTransmitInfo(
                    irp
                    );
        }
        EntityCount += 1;
    }
    else {
        dprintf (".");
    }
    return TRUE;

}   // DumpTransmitInfoCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\sys\sh_api.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sh_api.c

Abstract:

    This module implements the Stream Head Driver functions that map
    between NT IRPs and STREAMS APIs.

Author:

    Eric Chin (ericc)           July 1, 1991

Revision History:

--*/
#include "shead.h"
#include "sh_inc.h"




NTSTATUS
SHDispIoctl(
    IN PIRP                 irp,
    IN PIO_STACK_LOCATION   irpsp
    )

/*++

Routine Description:

    This routine unwraps the IRP sent via a STREAMS ioctl(2) api, probes
    the arguments, and calls the appropriate do_*() function.

Arguments:

    irp   - pointer to I/O request packet
    irpsp - pointer to current stack location in IRP

Return Value:

    NTSTATUS - Status of request

--*/

{
    int icode;
    char *inbuf;
    NTSTATUS status;
    int MyErrno, retval;

    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                    METHOD_BUFFERED);
    ASSERT(irpsp->Parameters.DeviceIoControl.IoControlCode ==
                                                    IOCTL_STREAMS_IOCTL);
    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispIoctl(irp = %lx), fileobj = %lx\n",
                            irp, irpsp->FileObject));
    }
    if (irpsp->Parameters.DeviceIoControl.InputBufferLength < sizeof(int)) {

        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispIoctl() insufficient inbuflen = %lx\n",
                        irpsp->Parameters.DeviceIoControl.InputBufferLength));
        }

        shortreply(irp, STATUS_INVALID_PARAMETER, 0);

        return(STATUS_INVALID_PARAMETER);
    }

    /*
     * the first int in the input buffer is the ioctl(2) command code,
     * followed by command-specific parameters.
     */
    icode = * (int *) irp->AssociatedIrp.SystemBuffer;
    inbuf = (char *) irp->AssociatedIrp.SystemBuffer + sizeof(int);

    switch (icode) {
    case I_STR:
        return(SHDispIStr(irp));
        break;

    case I_FDINSERT:
        return(SHDispFdInsert(irp, irpsp));
        break;

    case I_PUSH:
        status = do_push(
            irp,
            inbuf,
            irpsp->Parameters.DeviceIoControl.InputBufferLength - sizeof(int),
           &retval,
           &MyErrno);
        break;

    case I_LINK:
        status = do_link(
            irp,
            inbuf,
            irpsp->Parameters.DeviceIoControl.InputBufferLength - sizeof(int),
           &retval,
           &MyErrno);
        break;

    case I_DEBUG:
        status = do_sdebug(
            irp,
            irpsp->FileObject,
            inbuf,
            irpsp->Parameters.DeviceIoControl.InputBufferLength - sizeof(int),
           &retval,
           &MyErrno);
        break;

    case I_UNLINK:
        status = do_unlink(
            irp,
            inbuf,
            irpsp->Parameters.DeviceIoControl.InputBufferLength - sizeof(int),
           &retval,
           &MyErrno);
        break;

    default:
        retval = -1;
        MyErrno  = EINVAL;
        status = STATUS_SUCCESS;
        break;
    }

    switch (status) {
    case STATUS_PENDING:
        break;

    default:
        if (NT_SUCCESS(status)) {
            SHpGenReply(irp, retval, MyErrno);
        }
        else {
            shortreply(irp, status, 0);
        }
        break;
    }

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispIoctl(irp = %lx) status = %lx\n",
                    irp, status));
    }
    return(status);

} // SHDispIoctl



NTSTATUS
SHDispPoll(
    IN PIRP                 irp,
    IN PIO_STACK_LOCATION   irpsp
    )

/*++

Routine Description:

    This routine unwraps the IRP sent via a STREAMS poll(2) api, probes
    the arguments, and then calls do_poll().

Arguments:

    irp   - pointer to I/O request packet
    irpsp - pointer to current stack location in IRP

Return Value:

    NTSTATUS - Status of request

--*/

{
    NTSTATUS status;
    int MyErrno, retval;

    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                    METHOD_BUFFERED);
    ASSERT(irpsp->Parameters.DeviceIoControl.IoControlCode ==
                                                    IOCTL_STREAMS_POLL);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispPoll(), SysBuf = %lx, UserBuf = %lx\n",
                            irp->AssociatedIrp.SystemBuffer, irp->UserBuffer));
    }
    status = do_poll(
                irp,
                irp->AssociatedIrp.SystemBuffer,
                irpsp->Parameters.DeviceIoControl.InputBufferLength,
               &retval,
               &MyErrno);

    switch (status) {
    case STATUS_PENDING:
        break;

    default:
        if (NT_SUCCESS(status)) {
            SHpGenReply(irp, retval, MyErrno);
        }
        else {
            shortreply(irp, status, 0);
        }
        break;
    }

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispPoll(irp = %lx) status = %lx\n", irp, status));
    }
    return(status);

} // SHDispPoll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\tdiutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tdiutil.c

Abstract:

    Utility functions for dumping various TDI structures.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private prototypes.
//

PSTR
TransportAddressTypeToString(
    USHORT AddressType
    );

PSTR
NetbiosNameTypeToString(
    USHORT NetbiosNameType
    );

PSTR
NetbiosNameTypeToStringBrief(
    USHORT NetbiosNameType
    );

PCHAR
MyIp6AddressToString (
    PTA_IP6_ADDRESS Ip6Address,
    PCHAR           S
    );

//
// Remove once ATM defs are moved to tdi.h
//
#define AFD_TDI_ADDRESS_TYPE_ATM    22
#define AFD_ATM_NSAP                0
#define AFD_ATM_E164                1
#define AFD_SAP_FIELD_ABSENT        ((ULONG)0xfffffffe)
#define AFD_SAP_FIELD_ANY			((ULONG)0xffffffff)
#define AFD_SAP_FIELD_ANY_AESA_SEL	((ULONG)0xfffffffa)	// SEL is wild-carded
#define AFD_SAP_FIELD_ANY_AESA_REST	((ULONG)0xfffffffb)	// All of the address
													// except SEL, is wild-carded

typedef struct _AFD_TDI_ADDRESS_ATM {
    ULONG   AddressType;
    ULONG   NumberOfDigits;
    UCHAR   Address[20];
} AFD_TDI_ADDRESS_ATM, *PAFD_TDI_ADDRESS_ATM;



//
//  Public functions.
//


VOID
DumpTransportAddress(
    PCHAR Prefix,
    PTRANSPORT_ADDRESS Address,
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified TRANSPORT_ADDRESS structure.

Arguments:

    Prefix - A character string prefix to display before each line. Used
        to make things pretty.

    Address - Points to the TRANSPORT_ADDRESS to dump.

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sTRANSPORT_ADDRESS @ %p\n",
        Prefix,
        ActualAddress
        );

    dprintf(
        "%s    AddressLength   = %u\n",
        Prefix,
        Address->Address[0].AddressLength
        );

    dprintf(
        "%s    AddressType     = %u (%s)\n",
        Prefix,
        Address->Address[0].AddressType,
        TransportAddressTypeToString( Address->Address[0].AddressType )
        );

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;

        dprintf(
            "%s    sin_port        = %u\n",
            Prefix,
            NTOHS(ipAddress->Address00.sin_port)
            );

        dprintf(
            "%s    in_addr         = %d.%d.%d.%d\n",
            Prefix,
            UC(ipAddress->Address00.in_addr >>  0),
            UC(ipAddress->Address00.in_addr >>  8),
            UC(ipAddress->Address00.in_addr >> 16),
            UC(ipAddress->Address00.in_addr >> 24)
            );

        }
        break;

    case TDI_ADDRESS_TYPE_IP6: {
        PTA_IP6_ADDRESS ip6Address;
        CHAR    buffer[64];
        ip6Address = (PTA_IP6_ADDRESS)Address;
        dprintf(
            "%s    sin6_port       = %u\n",
            Prefix,
            NTOHS(ip6Address->Address00.sin6_port)
            );
        MyIp6AddressToString (ip6Address, buffer);
        dprintf(
            "%s    sin6_addr       = %s\n",
            Prefix,
            buffer
            );
        dprintf(
            "%s    sin6_scope_id   = %u\n",
            Prefix,
            ip6Address->Address00.sin6_scope_id
            );
        }
        break;
    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;

        dprintf(
            "%s    NetworkAddress  = %08.8lx\n",
            Prefix,
            ipxAddress->Address00.NetworkAddress
            );

        dprintf(
            "%s    NodeAddress     = %02.2X-%02.2X-%02.2X-%02.2X-%02.2X-%02.2X\n",
            Prefix,
            ipxAddress->Address00.NodeAddress[0],
            ipxAddress->Address00.NodeAddress[1],
            ipxAddress->Address00.NodeAddress[2],
            ipxAddress->Address00.NodeAddress[3],
            ipxAddress->Address00.NodeAddress[4],
            ipxAddress->Address00.NodeAddress[5]
            );

        dprintf(
            "%s    Socket          = %04.4X\n",
            Prefix,
            ipxAddress->Address00.Socket
            );

        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        UCHAR netbiosName[16];
        INT i;

        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;

        dprintf(
            "%s    NetbiosNameType = %04.4X (%s)\n",
            Prefix,
            netbiosAddress->Address00.NetbiosNameType,
            NetbiosNameTypeToString( netbiosAddress->Address00.NetbiosNameType )
            );


        RtlCopyMemory(
            netbiosName,
            netbiosAddress->Address00.NetbiosName,
            15
            );

        netbiosName[15] = 0;

        dprintf(
            "%s    NetbiosName     = %s:0x%2.2x (%2.2X",
            Prefix,
            netbiosName,
            (UCHAR)netbiosAddress->Address00.NetbiosName[0],
            (UCHAR)netbiosAddress->Address00.NetbiosName[0]
            );

        for (i=1;i<sizeof(netbiosAddress->Address00.NetbiosName) ;i++) {
            dprintf ("-%2.2X", (UCHAR)netbiosAddress->Address00.NetbiosName[i]);
        }

        dprintf (")\n");


        }
        break;

    case TDI_ADDRESS_TYPE_NBS: // matches AF_OSI
    case TDI_ADDRESS_TYPE_OSI_TSAP : {
        PTDI_ADDRESS_OSI_TSAP   osiAddress;
        INT i;

        osiAddress = (PTDI_ADDRESS_OSI_TSAP)&Address->Address[0].Address;
        dprintf(
            "%s    Type            = %d\n",
            Prefix,
            osiAddress->tp_addr_type
            );
        i = 0;
        if (osiAddress->tp_tsel_len>0) {
            dprintf(
                "%s    Selector        = %02.2X",
                Prefix,
                osiAddress->tp_addr[i++]
                );
            for (; i<osiAddress->tp_tsel_len; i++) {
                if (CheckControlC ())
                    break;
                dprintf ("-%02.2X", osiAddress->tp_addr[i]);
            }
            dprintf ("\n");
        }

        if (osiAddress->tp_taddr_len>i) {
            INT j = i;
            dprintf(
                "%s    Address         = %02.2Xn",
                Prefix,
                osiAddress->tp_addr[j++]
                );
            for ( ; j<osiAddress->tp_taddr_len; j++) {
                if (CheckControlC ())
                    break;
                dprintf ("-%02.2X", osiAddress->tp_addr[j]);
            }
            dprintf ("(");
            for (; i<osiAddress->tp_taddr_len; i++) {
                if (CheckControlC ())
                    break;
                if (isprint (osiAddress->tp_addr[i])) {
                    dprintf ("%c", osiAddress->tp_addr[i]);
                }
                else {
                    dprintf (".");
                }
            }
            dprintf (")\n");
        }

        }
        break;

    case AFD_TDI_ADDRESS_TYPE_ATM : {
        AFD_TDI_ADDRESS_ATM   UNALIGNED *atmAddress;
        UINT i;

        atmAddress = (AFD_TDI_ADDRESS_ATM UNALIGNED *)&Address->Address[0].Address[2];
        dprintf(
            "%s    Type            = ",
            Prefix
            );
        if (atmAddress->AddressType==AFD_ATM_E164) {
            dprintf ("E164");
        }
        else {
            switch (atmAddress->AddressType) {
            case AFD_ATM_NSAP:
                dprintf ("NSAP");
                break;
            case AFD_SAP_FIELD_ABSENT:
                dprintf ("SAP_FIELD_ABSENT");
                break;
            case AFD_SAP_FIELD_ANY:
                dprintf ("SAP_FIELD_ANY");
                break;
            case AFD_SAP_FIELD_ANY_AESA_SEL:
                dprintf ("SAP_FIELD_ANY_AESA_SEL");
                break;
            case AFD_SAP_FIELD_ANY_AESA_REST:
                dprintf ("SAP_FIELD_ANY_AESA_REST");
                break;
            }
        }
        dprintf (" (%lx)\n",
            atmAddress->AddressType);

        dprintf(
            "%s    Address         = ",
            Prefix
            );
        if (atmAddress->AddressType==AFD_ATM_E164) {
            dprintf ("+");
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                if (CheckControlC ())
                    break;
                if (isdigit (atmAddress->Address[i])) {
                    dprintf ("%c",atmAddress->Address[i]);
                }
                else {
                    dprintf ("<%02.2X>", atmAddress->Address[i]);
                }
            }
        }
        else {
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                UCHAR   val;
                if (CheckControlC ())
                    break;
                val = atmAddress->Address[i]>>4;
                dprintf ("%c", (val<=9) ? val+'0' : val+('A'-10));
                val = atmAddress->Address[i]&0xF;
                dprintf ("%c", (val<=9) ? val+'0' : val+('A'-10));
            }
        }

        dprintf ("\n");

        }
        break;
    default :

        dprintf(
            "%s    Unsupported address type\n",
            Prefix
            );

        break;

    }

}   // DumpTransportAddress


PCHAR
MyIp6AddressToString (
    PTA_IP6_ADDRESS Ip6Address,
    PCHAR           S
    )
{

    INT maxFirst, maxLast;
    INT curFirst, curLast;
    INT i;


    // Check for IPv6-compatible, IPv4-mapped, and IPv4-translated
    // addresses
    if ((Ip6Address->Address00.sin6_addr[0] == 0) &&
            (Ip6Address->Address00.sin6_addr[1] == 0) &&
            (Ip6Address->Address00.sin6_addr[2] == 0) &&
            (Ip6Address->Address00.sin6_addr[3] == 0) &&
            (Ip6Address->Address00.sin6_addr[6] != 0)) {
        if ((Ip6Address->Address00.sin6_addr[4] == 0) &&
             ((Ip6Address->Address00.sin6_addr[5] == 0)
                || (Ip6Address->Address00.sin6_addr[5] == 0xffff)))
        {
            // compatible or mapped
            S += sprintf(S, "::%s%u.%u.%u.%u",
                           Ip6Address->Address00.sin6_addr[5] == 0 ? "" : "ffff:",
                           UC(Ip6Address->Address00.sin6_addr[6]>>0),
                           UC(Ip6Address->Address00.sin6_addr[6]>>8),
                           UC(Ip6Address->Address00.sin6_addr[7]>>0), 
                           UC(Ip6Address->Address00.sin6_addr[7]>>9));
        }
        else if ((Ip6Address->Address00.sin6_addr[4] == 0xffff)
                    && (Ip6Address->Address00.sin6_addr[5] == 0)) {
            // translated
            S += sprintf(S, "::ffff:0:%u.%u.%u.%u",
                           UC(Ip6Address->Address00.sin6_addr[6]>>0),
                           UC(Ip6Address->Address00.sin6_addr[6]>>8),
                           UC(Ip6Address->Address00.sin6_addr[7]>>0), 
                           UC(Ip6Address->Address00.sin6_addr[7]>>9));
        }
    }
    // Find largest contiguous substring of zeroes
    // A substring is [First, Last), so it's empty if First == Last.

    maxFirst = maxLast = 0;
    curFirst = curLast = 0;

    for (i = 0; i < 8; i++) {

        if (Ip6Address->Address00.sin6_addr[i] == 0) {
            // Extend current substring
            curLast = i+1;

            // Check if current is now largest
            if (curLast - curFirst > maxLast - maxFirst) {

                maxFirst = curFirst;
                maxLast = curLast;
            }
        }
        else {
            // Start a new substring
            curFirst = curLast = i+1;
        }
    }

    // Ignore a substring of length 1.
    if (maxLast - maxFirst <= 1)
        maxFirst = maxLast = 0;

        // Write colon-separated words.
        // A double-colon takes the place of the longest string of zeroes.
        // All zeroes is just "::".

        for (i = 0; i < 8; i++) {

            // Skip over string of zeroes
            if ((maxFirst <= i) && (i < maxLast)) {

                S += sprintf(S, "::");
                i = maxLast-1;
                continue;
            }
        // Need colon separator if not at beginning
        if ((i != 0) && (i != maxLast))
            S += sprintf(S, ":");

        S += sprintf(S, "%x", NTOHS(Ip6Address->Address00.sin6_addr[i]));
    }

    return S;
}

LPSTR
TransportAddressToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    )

/*++

Routine Description:

    Converts specified transport address to string

Arguments:

    Address - Points to the TRANSPORT_ADDRESS to dump.

Return Value:

    None.

--*/

{
    static CHAR buffer[64];
    PCHAR   s;

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;
        sprintf (buffer, "%d.%d.%d.%d:%d",
            UC(ipAddress->Address00.in_addr >>  0),
            UC(ipAddress->Address00.in_addr >>  8),
            UC(ipAddress->Address00.in_addr >> 16),
            UC(ipAddress->Address00.in_addr >> 24),
            NTOHS(ipAddress->Address00.sin_port)
            );
        }
        break;

    case TDI_ADDRESS_TYPE_IP6: {
        PTA_IP6_ADDRESS ip6Address;
        ip6Address = (PTA_IP6_ADDRESS)Address;
        s = buffer;
        *s++ = '[';
        s = MyIp6AddressToString (ip6Address, s);
        if (ip6Address->Address00.sin6_scope_id != 0)
            s += sprintf(s, "%%%u", ip6Address->Address00.sin6_scope_id);
        sprintf (s, "]:%d",NTOHS(ip6Address->Address00.sin6_port));
        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;
        sprintf (buffer,
            "%8.8x:%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x:%4.4x",
            NTOHL(ipxAddress->Address00.NetworkAddress),
            ipxAddress->Address00.NodeAddress[0],
            ipxAddress->Address00.NodeAddress[1],
            ipxAddress->Address00.NodeAddress[2],
            ipxAddress->Address00.NodeAddress[3],
            ipxAddress->Address00.NodeAddress[4],
            ipxAddress->Address00.NodeAddress[5],
            NTOHS(ipxAddress->Address00.Socket)
            );

        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        UCHAR netbiosName[16];
        INT i;
        BOOLEAN doascii = FALSE;

        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;
        for (i=0; i<15; i++) {
            if (netbiosAddress->Address00.NetbiosName[i]==0)
                break;
            else if (isprint (netbiosAddress->Address00.NetbiosName[i])) {
                doascii = TRUE;
            }
            else {
                doascii = FALSE;
                break;
            }
        }

        s = buffer+sprintf (buffer, "%s:",
            NetbiosNameTypeToString( netbiosAddress->Address00.NetbiosNameType));

        if (doascii) {
            RtlCopyMemory(
                netbiosName,
                netbiosAddress->Address00.NetbiosName,
                15
                );
            netbiosName[15] = 0;

            sprintf (s, "%s:%0x2.2x",
                netbiosName,
                netbiosAddress->Address00.NetbiosName[15]
                );
        }
        else {
            s = buffer;
            for (i=0; i<sizeof (netbiosAddress->Address00.NetbiosName); i++) {
                s += sprintf (s, "%2.2x", (UCHAR)netbiosAddress->Address00.NetbiosName[i]);
            }
        }

        }
        break;
    case AFD_TDI_ADDRESS_TYPE_ATM : {
        AFD_TDI_ADDRESS_ATM   UNALIGNED *atmAddress;
        UINT i;

        atmAddress = (AFD_TDI_ADDRESS_ATM UNALIGNED *)&Address->Address[0].Address[2];
        s = buffer;
        if (atmAddress->AddressType==AFD_ATM_E164) {
            *s++= '+';
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                if (CheckControlC ())
                    break;
                if (isdigit (atmAddress->Address[i])) {
                    s += sprintf (s, "%c",atmAddress->Address[i]);
                }
                else {
                    s += sprintf (s, "<%02.2X>", atmAddress->Address[i]);
                }
            }
        }
        else {
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                UCHAR   val;
                if (CheckControlC ())
                    break;
                val = atmAddress->Address[i]>>4;
                s += sprintf (s, "%c", (val<=9) ? val+'0' : val+('A'-10));
                val = atmAddress->Address[i]&0xF;
                s += sprintf (s, "%c", (val<=9) ? val+'0' : val+('A'-10));
            }
        }

        }
    default :

        sprintf(buffer, "@ %I64x", DISP_PTR(ActualAddress));

        break;

    }

    return buffer;

}   // TransportAddressToString

LPSTR
TransportPortToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    )

/*++

Routine Description:

    Converts specified transport address to string

Arguments:

    Address - Points to the TRANSPORT_ADDRESS to dump.

Return Value:

    None.

--*/

{
    static CHAR buffer[8];

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;
        sprintf (buffer, "%5u",
            NTOHS(ipAddress->Address00.sin_port)
            );
        }
        break;

    case TDI_ADDRESS_TYPE_IP6: {
        PTA_IP6_ADDRESS ip6Address;
        ip6Address = (PTA_IP6_ADDRESS)Address;
        sprintf (buffer, "%5u",
            NTOHS(ip6Address->Address00.sin6_port));
        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;
        sprintf (buffer,"x%4.4x",
            NTOHS(ipxAddress->Address00.Socket)
            );

        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;
        sprintf (buffer, "x%4.4x",
            netbiosAddress->Address00.NetbiosName[15]
            );

        }
        break;
    default :

        sprintf(buffer, "?????");

        break;

    }

    return buffer;

}   // TransportPortToString


//
//  Private functions.
//

PSTR
TransportAddressTypeToString(
    USHORT AddressType
    )

/*++

Routine Description:

    Maps a transport address type to a displayable string.

Arguments:

    AddressType - The transport address type to map.

Return Value:

    PSTR - Points to the displayable form of the tranport address type.

--*/

{

    switch( AddressType ) {

    case TDI_ADDRESS_TYPE_UNSPEC :

        return "Unspecified";

    case TDI_ADDRESS_TYPE_UNIX :

        return "Unix";

    case TDI_ADDRESS_TYPE_IP :

        return "Ip";

    case TDI_ADDRESS_TYPE_IP6 :

        return "Ip6";

    case TDI_ADDRESS_TYPE_IMPLINK :

        return "Implink";

    case TDI_ADDRESS_TYPE_PUP :

        return "Pup";

    case TDI_ADDRESS_TYPE_CHAOS :

        return "Chaos";

    case TDI_ADDRESS_TYPE_IPX :

        return "Ipx";

    case TDI_ADDRESS_TYPE_NBS :

        return "Nbs (or AF_OSI)";

    case TDI_ADDRESS_TYPE_ECMA :

        return "Ecma";

    case TDI_ADDRESS_TYPE_DATAKIT :

        return "Datakit";

    case TDI_ADDRESS_TYPE_CCITT :

        return "Ccitt";

    case TDI_ADDRESS_TYPE_SNA :

        return "Sna";

    case TDI_ADDRESS_TYPE_DECnet :

        return "Decnet";

    case TDI_ADDRESS_TYPE_DLI :

        return "Dli";

    case TDI_ADDRESS_TYPE_LAT :

        return "Lat";

    case TDI_ADDRESS_TYPE_HYLINK :

        return "Hylink";

    case TDI_ADDRESS_TYPE_APPLETALK :

        return "Appletalk";

    case TDI_ADDRESS_TYPE_NETBIOS :

        return "Netbios";

    case TDI_ADDRESS_TYPE_8022 :

        return "8022";

    case TDI_ADDRESS_TYPE_OSI_TSAP :

        return "OSI TSAP";

    case TDI_ADDRESS_TYPE_NETONE :

        return "Netone";

    case AFD_TDI_ADDRESS_TYPE_ATM :

        return "ATM";

    }

    return "UNKNOWN";

}   // TransportAddressTypeToString


PSTR
NetbiosNameTypeToStringBrief(
    USHORT NetbiosNameType
    )

/*++

Routine Description:

    Maps a NetBIOS name type to a displayable string.

Arguments:

    NetbiosNameType - The NetBIOS name type to map.

Return Value:

    PSTR - Points to the displayable form of the NetBIOS name type.

--*/

{

    switch( NetbiosNameType ) {

    case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE :

        return "U";

    case TDI_ADDRESS_NETBIOS_TYPE_GROUP :

        return "G";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE :

        return "QU";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP :

        return "QG";

    }

    return "?";

}   // NetbiosNameTypeToStringBrief


PSTR
NetbiosNameTypeToString(
    USHORT NetbiosNameType
    )

/*++

Routine Description:

    Maps a NetBIOS name type to a displayable string.

Arguments:

    NetbiosNameType - The NetBIOS name type to map.

Return Value:

    PSTR - Points to the displayable form of the NetBIOS name type.

--*/

{

    switch( NetbiosNameType ) {

    case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE :

        return "Unique";

    case TDI_ADDRESS_NETBIOS_TYPE_GROUP :

        return "Group";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE :

        return "Quick Unique";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP :

        return "Quick Group";

    }

    return "UNKNOWN";

}   // NetbiosNameTypeToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\kdext\type.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    type.h

Abstract:

    Global type definitions for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _TYPE_H_
#define _TYPE_H_


typedef
VOID
(* PDUMP_ENDPOINT_ROUTINE)(
    ULONG64 ActualAddress
    );

typedef
VOID
(* PDUMP_CONNECTION_ROUTINE)(
    ULONG64 ActualAddress
    );

typedef
BOOL
(* PENUM_ENDPOINTS_CALLBACK)(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

typedef struct _AFDKD_TRANSPORT_INFO {
    LIST_ENTRY          Link;
    ULONG64             ActualAddress;
    LONG                ReferenceCount;
    BOOLEAN             InfoValid;
    TDI_PROVIDER_INFO   ProviderInfo;
    WCHAR               DeviceName[1];
} AFDKD_TRANSPORT_INFO, *PAFDKD_TRANSPORT_INFO;

#endif  // _TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\inc\pooltrc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pooltrc.h

Abstract:

    This file declares private structures and functions used to implement
    STREAMS NonPaged Pool usage tracing.

Author:

    Mike Massa (mikemas)           January 10, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-10-92    created

Notes:


--*/


#ifndef _POOLTRC_INCLUDED_
#define _POOLTRC_INCLUDED_

#if DBG


/*
 *  NonPaged Pool Usage Debugging Macros
 *
 */

#define ExAllocatePool(P, N)  StrmAllocatePool(P, N, __LINE__, __FILE__)
#if defined(ExFreePool)
#undef ExFreePool
#endif
#define ExFreePool(P)         StrmFreePool(P, __LINE__, __FILE__)


PVOID
StrmAllocatePool(
    IN POOL_TYPE  PoolType,
    IN ULONG      NumberOfBytes,
    IN int        line,
    IN char      *file
    );

VOID
StrmFreePool(
    IN PVOID P,
    IN int   line,
    IN char *file
    );

VOID
StrmListOutstandingPoolBuffers(
    VOID
    );

VOID
StrmFlushPoolTraceTable(
    VOID
    );



#else

#if POOL_TAGGING
#define ExAllocatePool(P, N)  ExAllocatePoolWithTag(P, N, 'mrtS' )
#endif

#endif //DBG

#endif //_POOLTRC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\sys\sh_ioctl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sh_ioctl.c

Abstract:

    This source deals with those streamio(2) functions that are synchronous,
    in that a message is sent downstream, and a reply is waited for.

    It is based on the SpiderSTREAMS source, stremul\msgsrvr.c.

Author:

    Eric Chin (ericc)           January 6, 1992

Revision History:

Notes:

   1. The O_NONBLOCK state of a stream does not affect the behaviour of an
      ioctl(I_STR).

   2. The write error state of a stream is represented by ms->e_werror.  Once
      set, this is never reset.  This corresponds to the STREAMS semantics as
      defined by AT&T.  Once a user is notified of a write error on a stream,
      about the only recourse is to close the stream.

--*/
#include "shead.h"
#include "sh_proto.h"



//
// Private Functions
//
STATIC VOID
cancel_ioctl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

STATIC NTSTATUS
do_sioctl(
    IN PIRP             irp,
    IN BOOLEAN          from_queue,
    IN int             *spl_levelp,
    OUT BOOLEAN        *ignored OPTIONAL
    );

STATIC VOID
handle_ioctlers (
    IN STREAM_ENDPOINT *ms,
    IN int             *spl_levelp
    );


STATIC int
ioc_timeout(
    IN char        *arg
    );





NTSTATUS
SHDispIStr(
    IN PIRP irp
    )

/*++

Routine Description:

    This routine is called to process an ioctl(I_STR).  It is based on the
    SpiderSTREAMS emulator's routine, msgserver().

    This routine merely peels open the IRP, checks the arguments for
    consistency, locks the appropriate stream, and then calls do_sioctl(),
    which does the bulk of the work.

Arguments:

    irp       - pointer to the IRP representing this request

Return Value:

    an NT status code.

--*/

{
    int timout;
    int spl_level;
    int spl_level2;
    NTSTATUS status;
    PSTREAM_ENDPOINT ms;
    PISTR_ARGS_INOUT inbuf;
    struct strioctl *striop;
    PIO_STACK_LOCATION irpsp;

    irpsp = IoGetCurrentIrpStackLocation(irp);

    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                            METHOD_BUFFERED);

    ms = (STREAM_ENDPOINT *) irpsp->FileObject->FsContext;

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength <
                                                sizeof(ISTR_ARGS_INOUT) - 1) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispIStr(%lx) insufficient nbytes = %lx\n",
                    irp, irpsp->Parameters.DeviceIoControl.InputBufferLength));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // the caller marshalled the input arguments contiguously thus:
    //
    //  typedef struct _ISTR_ARGS_INOUT {           // ioctl(,I_STR,)
    //      int                 a_iocode;           //  I_STR
    //      struct strioctl     a_strio;            //  (required)
    //      int                 a_unused[2];        //  (required)
    //      char                a_stuff[1];         //  ic_dp buffer (optional)
    //
    //  } ISTR_ARGS_INOUT, PISTR_ARGS_INOUT;
    //
    //
    //
    inbuf  = (PISTR_ARGS_INOUT) irp->AssociatedIrp.SystemBuffer;
    striop = &(inbuf->a_strio);

    IF_STRMDBG(VERBOSE) {
        STRMTRACE(("SHEAD: SHDispIStr(ic_cmd, timout, len = %lx, %lx, %lx)\n",
                    striop->ic_cmd, striop->ic_timout, striop->ic_len));
    }

    //
    // don't let user-defined ioctl codes coincide with the standard STREAMS
    // ioctl codes.  Otherwise, confusion will reign.
    //
    switch (striop->ic_cmd) {
    case I_LINK:
    case I_UNLINK:
    case I_PLINK:
    case I_PUNLINK:
        SHpGenReply(irp, -1, EINVAL);
        return(STATUS_SUCCESS);
        break;
    }

    if ((striop->ic_timout < -1) || (striop->ic_len < 0)) {
        SHpGenReply(irp, -1, EINVAL);
        return(STATUS_SUCCESS);
    }

    IoAcquireCancelSpinLock(&irp->CancelIrql);

    if (irp->Cancel) {
        IoReleaseCancelSpinLock(irp->CancelIrql);
        shortreply(irp, STATUS_CANCELLED, 0);
        return(STATUS_CANCELLED);
    }

    spl_level = lock_strm(ms->e_strm);

    if (shrange(ms->e_strm, sizeof(struct iocblk), striop->ic_len) < 0) {
        unlock_strm(ms->e_strm, spl_level);
        IoReleaseCancelSpinLock(irp->CancelIrql);
        SHpGenReply(irp, -1, ERANGE);
        return(STATUS_SUCCESS);
    }

    IoMarkIrpPending(irp);

    //
    // if the ioctl is to time out after a specific time, start a timer
    // running.  iocrdy() will clear the timer.
    //
    // Based on a tip from larryo, irp->IoStatus.Information is used only
    // when an IRP is completed successfully.  Hence, we keep the timer
    // id there.
    //
    irp->IoStatus.Information = 0;
    irp->IoStatus.Status      = STATUS_PENDING;

    if (striop->ic_timout != -1) {
        timout = striop->ic_timout ? striop->ic_timout : STRTIMOUT;

        irp->IoStatus.Information = timeout(ioc_timeout,
                                                (char *) irp, timout * HZ);
    }

    //
    // At any given time, there must only be one outstanding ioctl(I_STR) on
    // a stream.  If there is another ioctl outstanding, chain this IRP to
    // the tail of the pending ioctl'ers list.
    //
    if (ms->e_active_ioctl) {
        status = SHAddPendingIrp(&(ms->e_ioctlers), FALSE, irp, do_sioctl);

        unlock_strm(ms->e_strm, spl_level);

        if (status != STATUS_SUCCESS) {
            IoReleaseCancelSpinLock(irp->CancelIrql);
            shortreply(irp, status, 0);
            return(status);
        }

        IoSetCancelRoutine(irp, cancel_ioctl);
        IoReleaseCancelSpinLock(irp->CancelIrql);

        return(STATUS_PENDING);
    }

    ms->e_active_ioctl = irp;

    //
    // do_sioctl() calls unlock_strm(ms->e_strm).
    //

    IoReleaseCancelSpinLock((KIRQL) spl_level);

    spl_level2 = (int) irp->CancelIrql;

    if (do_sioctl(irp, FALSE, &spl_level2, NULL) != STATUS_PENDING) {
        spl_level = lock_strm(ms->e_strm);
        handle_ioctlers(ms, &spl_level);
    }

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispIStr(ms = %lx) returns, irp pending\n", ms));
    }
    return(STATUS_PENDING);

} // SHDispIStr



STATIC VOID
cancel_ioctl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    )

/*++

Routine Description:

    This routine is called when an ioctl(...,I_STR,...) is cancelled.

    It must release the cancel spinlock before returning !!  The caller
    has already acquired the cancel spinlock.  ref: IoCancelIrp().

Arguments:

    device    - pointer to the device object
    irp       - pointer to the irp of this request

Return Value:

    none.

--*/

{
    int spl_level;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;
    PSTREAM_ENDPOINT ms;
    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(irp);
    int spl_level2;

    ASSERT(device == (PDEVICE_OBJECT) StreamDevice);
    ASSERT(irpsp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    ASSERT(irpsp->Parameters.DeviceIoControl.IoControlCode ==
                                                        IOCTL_STREAMS_IOCTL);
    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: cancel_ioctl(irp = %lx) entered\n", irp));
    }
    IoSetCancelRoutine(irp, NULL);              /* unnecessary, but cheap */

    ms        = (PSTREAM_ENDPOINT) irpsp->FileObject->FsContext;
    spl_level = lock_strm(ms->e_strm);

    //
    // I'm releasing the cancel spinlock and stream lock in the reverse
    // order of acquisition.  Thus, I need to swap the irql's.
    //

    spl_level2 = (int) irp->CancelIrql;

    IoReleaseCancelSpinLock((KIRQL) spl_level);

    spl_level = spl_level2;

    if (irp->IoStatus.Information) {
        if (untimeout((int)irp->IoStatus.Information) == 0) {
            //
            // the timeout routine is already running.  Just return and let it
            // handle the irp.
            //

            unlock_strm(ms->e_strm, spl_level);
            return;
        }
        irp->IoStatus.Information = 0;
    }

    if (irp == ms->e_active_ioctl) {

        IF_STRMDBG(CALL) {
            STRMTRACE(("SHEAD: cancel_ioctl(irp = %lx) cancelled\n", irp));
        }
        ms->e_active_ioctl = NULL;

        handle_ioctlers(ms, &spl_level);

        shortreply(irp, STATUS_CANCELLED, 0);
        return;
    }

    for (tmp = ms->e_ioctlers.Flink;
         tmp != &ms->e_ioctlers;
         tmp = tmp->Flink) {

        item = CONTAINING_RECORD(tmp,
                                WAITING_IRP,
                                w_list);

        if (irp != item->w_irp) {
            continue;
        }
        RemoveEntryList(&(item->w_list));
        ExFreePool(item);

        unlock_strm(ms->e_strm, spl_level);
        shortreply(irp, STATUS_CANCELLED, 0);

        IF_STRMDBG(CALL) {
            STRMTRACE(("SHEAD: cancel_ioctl(irp = %lx) cancelled\n", irp));
        }
        return;
    }
    unlock_strm(ms->e_strm, spl_level);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: cancel_ioctl(irp = %lx) not found\n", irp));
    }

} // cancel_ioctl




STATIC NTSTATUS
do_sioctl(
    IN PIRP             irp,
    IN BOOLEAN          ignored,
    IN int             *spl_levelp,
    OUT BOOLEAN        *must_be_null
    )

/*++

Routine Description:

    This function is called to put an M_IOCTL message down a stream.  It
    either sends the message or chains it to ms->e_writers.  This function
    is similar to do_putmsg(), both of which are based on the SpiderStreams
    emulator's function, do_req().

    Call this function with the stream locked !!!

Arguments:

    irp             - pointer to the IRP representing this request
    ignored         - this parameter is ignored
    spl_levelp      - pointer to the interrupt priority level at which the
                        stream was locked
    must_be_null    - since this function doesn't set this optional return
                        parameter, this must be NULL

Return Value:

    an NT status code.  Unless this is STATUS_PENDING, this function has
    completed the IRP.



--*/

{
    int MyErrno;
    mblk_t *mp;
    struct iocblk *iocp;
    PSTREAM_ENDPOINT ms;
    PISTR_ARGS_INOUT inbuf;
    struct strioctl *striop;
    PIO_STACK_LOCATION irpsp;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: do_sioctl(irp = %lx) entered\n", irp));
    }
    ASSERT(must_be_null == NULL);

    irpsp = IoGetCurrentIrpStackLocation(irp);

    //
    // these were already verified by SHDispIStr().
    //
    ASSERT(irpsp->Parameters.DeviceIoControl.InputBufferLength >=
                                                sizeof(ISTR_ARGS_INOUT) - 1);
    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                            METHOD_BUFFERED);

    ms = (STREAM_ENDPOINT *) irpsp->FileObject->FsContext;

    ASSERT(irp == ms->e_active_ioctl);

    if (ms->e_werror) {
        MyErrno = ms->e_werror;
    }
    else if (ms->e_linked) {
        MyErrno = EINVAL;
    }
    else {
        MyErrno = 0;
    }

    if (MyErrno) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: do_sioctl(%lx) error = %d\n", ms, MyErrno));
        }
        if (irp->IoStatus.Information) {
            if (untimeout((int)irp->IoStatus.Information) == 0) {
                //
                // The timeout routine will handle this
                //
                unlock_strm(ms->e_strm, *spl_levelp);
                return(STATUS_PENDING);
            }
            irp->IoStatus.Information = 0;
        }
        ms->e_active_ioctl = NULL;
        unlock_strm(ms->e_strm, *spl_levelp);
        SHpGenReply(irp, -1, MyErrno);
        return(STATUS_SUCCESS);
    }

    //
    // the caller marshalled the input arguments contiguously thus:
    //
    //  typedef struct _ISTR_ARGS_INOUT {           // ioctl(,I_STR,)
    //      int                 a_iocode;           //  I_STR
    //      struct strioctl     a_strio;            //  (required)
    //      int                 a_unused[2];        //  (required)
    //      char                a_stuff[1];         //  ic_dp buffer (optional)
    //
    //  } ISTR_ARGS_INOUT, PISTR_ARGS_INOUT;
    //
    //
    //
    inbuf  = (PISTR_ARGS_INOUT) irp->AssociatedIrp.SystemBuffer;
    striop = &(inbuf->a_strio);

    IF_STRMDBG(VERBOSE) {
        STRMTRACE(("SHEAD: do_sioctl(ic_cmd, timout, len = %lx, %lx, %lx)\n",
                    striop->ic_cmd, striop->ic_timout, striop->ic_len));
    }

    mp = irptomp(irp, BPRI_LO, sizeof(struct iocblk), striop->ic_len,
                                    (char *) &(inbuf->a_strio));

    if (!mp) {
        if (irp->IoStatus.Information) {
            if (untimeout((int)irp->IoStatus.Information) == 0) {
                //
                // The timeout routine will handle this
                //
                unlock_strm(ms->e_strm, *spl_levelp);
                return(STATUS_PENDING);
            }
            irp->IoStatus.Information = 0;
        }
        ms->e_active_ioctl = NULL;
        unlock_strm(ms->e_strm, *spl_levelp);
        shortreply(irp, STATUS_NO_MEMORY, 0);
        return(STATUS_NO_MEMORY);
    }

    ASSERT(mp->b_datap->db_type == M_PROTO);
    mp->b_datap->db_type = M_IOCTL;

    iocp = (struct iocblk *) mp->b_rptr;
    ASSERT(iocp);

    iocp->ioc_cmd = striop->ic_cmd;
    iocp->ioc_uid = 0;
    iocp->ioc_gid = 0;
    iocp->ioc_id  = ++(ms->e_strm->str_iocid);

    if (iocp->ioc_id == 0) {
        iocp->ioc_id = ms->e_strm->str_iocid = 1;
    }
    iocp->ioc_count = striop->ic_len;
    iocp->ioc_error = 0;
    iocp->ioc_rval  = 0;

    //
    // shput() calls unlock_strm(ms->e_strm).
    //
    shput(ms->e_strm, mp, 0, spl_levelp);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: do_sioctl(ms = %lx) returns, irp pending\n", ms));
    }
    return(STATUS_PENDING);

} // do_sioctl



STATIC VOID
handle_ioctlers (
    IN STREAM_ENDPOINT *ms,
    IN int             *spl_levelp
    )

/*++

Routine Description:

    This routine starts the next ioctl() that is pending on a stream.  It
    is based on the SpiderStreams emulator function of the same name.

    This routine is called with the stream locked, and unlocks the stream
    before returning.

Arguments:

    ms          -  pointer to the stream endpoint
    spl_level   -  priority level to resume after releasing lock.

Return Value:

    none.


--*/

{
    PIRP irp;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;

    ASSERT(ms);
    if (ms->e_active_ioctl) {
        //
        // Already processing an ioctl
        //
        unlock_strm(ms->e_strm, *spl_levelp);
        return;
    }
    ASSERT(!ms->e_active_ioctl);

    while (!IsListEmpty(&(ms->e_ioctlers))) {

        tmp  = RemoveHeadList( &(ms->e_ioctlers) );
        item = CONTAINING_RECORD(tmp,
                                    WAITING_IRP,
                                    w_list);

        ASSERT(item->w_function == do_sioctl);

        irp                = item->w_irp;
        ms->e_active_ioctl = irp;

        ExFreePool(item);

        if (do_sioctl(irp, FALSE, spl_levelp, NULL) == STATUS_PENDING) {
            return;
        }
        *spl_levelp = lock_strm(ms->e_strm);
    }

    unlock_strm(ms->e_strm, *spl_levelp);
    return;

} // handle_ioctlers



STATIC int
ioc_timeout(
    IN char        *arg
    )

/*++

Routine Description:

    This function is called when an ioctl() times out.  It is based on the
    SpiderStreams emulator function of the same name.

Arguments:

    arg     -  pointer to irp representing the ioctl() which timed out.

Return Value:

    0

Discussion:

    Suppose iocrdy() is called because our M_IOCACK arrives.  iocrdy() calls
    lock_strm(), and prepares to complete the IRP.  Just then, our timeout
    fires, and this function is called.  We call lock_strm() and spin.

    Then, iocrdy() completes the irp and calls unlock_strm(), unblocking us.
    We unchain an irp from ms->e_ioctlers and completes it with an ETIME
    error.  However, this is the wrong IRP to complete !!

    One possible solution is for arg to be a pointer to a structure containing
    both ms and the IRP.  Then, we can verify that the IRP at the head of the
    list is ours.  Still, what if the IRP is reused ?

    The bug above may arise after any of the following situations:

        1. a stream is dup()'ed,
        2. we are called from a multi-threaded application,
        3. when a stream is NtOpen()'ed without the SYNCHRONOUS flag,
        4. an IRP is cancelled.

--*/

{
    PIRP irp;
    int spl_level;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;
    STREAM_ENDPOINT *ms;
    PIO_STACK_LOCATION irpsp;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: ioc_timeout(irp = %lx) entered\n", arg));
    }

    irp   = (PIRP) arg;
    irpsp = IoGetCurrentIrpStackLocation(irp);
    ms    = (STREAM_ENDPOINT *) irpsp->FileObject->FsContext;

    ASSERT(irpsp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    ASSERT(irpsp->Parameters.DeviceIoControl.IoControlCode ==
                                                        IOCTL_STREAMS_IOCTL);

    spl_level = lock_strm(ms->e_strm);

    if (irp == ms->e_active_ioctl) {
        ms->e_active_ioctl = NULL;

        handle_ioctlers(ms, &spl_level);
    }
    else {

        for (tmp = ms->e_ioctlers.Flink;
             tmp != &(ms->e_ioctlers);
             tmp = tmp->Flink) {

            item = CONTAINING_RECORD(tmp,
                                    WAITING_IRP,
                                    w_list);

            if (irp != item->w_irp) {
                continue;
            }
            RemoveEntryList(&(item->w_list));
            ExFreePool(item);
            break;
        }
        unlock_strm(ms->e_strm, spl_level);
    }

    irp->IoStatus.Information = 0;

    SHpGenReply(irp, -1, ETIME);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: ioc_timeout(irp = %lx) completed\n", irp));
    }
    return(0);

} // ioc_timeout



void
iocrdy(
    IN STREAM_ENDPOINT *ms,
    IN mblk_t          *mp,
    IN int             *spl_levelp
    )

/*++

Routine Description:

    This function is called by the Stream Head Driver when either an M_IOCACK
    or an M_IOCNAK message arrives at its read queue of the specified stream.
    It is based on the SpiderStreams emulator function of the same name.

    This function is called with the stream locked, and unlocks the stream
    before returning.

Arguments:

    ms          -  pointer to the stream endpoint
    mp          -  pointer to the STREAMS message that arrived
    spl_levelp  -  ptr to priority level to resume after releasing lock.

Return Value:

    none.


--*/

{
    PIRP irp;
    struct iocblk *iocp = (struct iocblk *) mp->b_rptr;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: iocrdy(ms = %lx)\n", ms));
    }
    if (!ms) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: iocrdy(ms = NULL) !!\n"));
        }
        freemsg(mp);
        unlock_strm(ms->e_strm, *spl_levelp);
        return;
    }

    irp                = ms->e_active_ioctl;
    ms->e_active_ioctl = NULL;

    //
    // ensure that someone is still waiting for the reply.
    //
    if (!irp) {
        freemsg(mp);
        unlock_strm(ms->e_strm, *spl_levelp);
        qenable((ms->e_strm)->str_sq);
//        handle_ioctlers(ms, spl_levelp);
        return;
    }

    //
    // if there's an ioctl timer running, clear it now.
    //
    if (irp->IoStatus.Information) {
        if (untimeout((int)irp->IoStatus.Information) == 0) {
            //
            // The timeout routine will handle this
            //
            ms->e_active_ioctl = irp;
            unlock_strm(ms->e_strm, *spl_levelp);
            freemsg(mp);
            return;
        }
        irp->IoStatus.Information = 0;
    }

    switch (iocp->ioc_cmd) {
    case I_LINK:
    case I_UNLINK:
        unlock_strm(ms->e_strm, *spl_levelp);
        if (mp->b_datap->db_type == M_IOCACK) {
            SHpGenReply(irp,
                        ((struct linkblk *) (mp->b_cont->b_rptr))->l_index,
                        0);
        }
        else {
            SHpGenReply(irp, -1, iocp->ioc_error);
        }
//        *spl_levelp = lock_strm(ms->e_strm);
        freemsg(mp);
        break;

    case I_PLINK:
    case I_PUNLINK:
        ASSERT(0);
        break;

    //
    // if we get here, it's an ioctl(I_STR).  iocp->ioc_cmd is a some
    // user-defined command code.
    //
    default:
        unlock_strm(ms->e_strm, *spl_levelp);
        (void) iocreply(mp, irp);
//        *spl_levelp = lock_strm(ms->e_strm);
        break;
    }

    qenable((ms->e_strm)->str_sq);
//    handle_ioctlers(ms, spl_levelp);
    return;

} // iocrdy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\sys\sh_get.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sh_get.c

Abstract:

    This source file contains those functions of the Stream Head Driver that
    deal with receiving messages from a stream.

Author:

    Eric Chin (ericc)           August 16, 1991

Revision History:

Notes:

   The read error state of a stream is represented by ms->e_rerror.  Once
   set, this is never reset.  This corresponds to the STREAMS semantics as
   defined by AT&T.  Once a user is notified of a read error on a stream,
   about the only recourse is to close the stream.

--*/
#include "sh_inc.h"


//
// Local (Private) Functions
//
STATIC
VOID
cancel_get(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

NTSTATUS
do_getmsg(
    IN PIRP         irp,
    IN PFILE_OBJECT pfileobj,
    IN int          flags
    );



NTSTATUS
SHDispGetMsg(
    IN PIRP                 irp,
    IN PIO_STACK_LOCATION   irpsp
    )

/*++

Routine Description:

    This routine implements the getmsg(2) API.

Arguments:

    irp       - pointer to the IRP representing this request
    irpsp     - pointer to the IRP stack location for this request

Return Value:

    An NT status code.  Whatever the return value, this function will arrange
    for the IRP to be completed.

--*/

{
    int spl_level;
    NTSTATUS status;
    PSTREAM_ENDPOINT ms;
    int MyErrno, pri;
    PGETMSG_ARGS_INOUT inbuf;
    int ret;
    mblk_t *mp;
    int more = 0;
    struct strbuf *strbufp;
    int ctlsize, datasize, flags, *pretval, remains;

    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                    METHOD_BUFFERED);

    ms = (PSTREAM_ENDPOINT) irpsp->FileObject->FsContext;

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength <
                                            sizeof(GETMSG_ARGS_INOUT) - 1) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispGetMsg(%lx) insufficient nbytes = %lx\n",
	            irp, irpsp->Parameters.DeviceIoControl.InputBufferLength));
        }
        shortreply(irp, STATUS_INVALID_PARAMETER, 0);
        return(STATUS_INVALID_PARAMETER);
    }

    // Need to ensure that the output buffer is big enough.
    {
        int       cbOut        = irpsp->Parameters.DeviceIoControl.OutputBufferLength;
        NTSTATUS  LengthStatus = STATUS_INVALID_PARAMETER;

        if (cbOut >= (sizeof(GETMSG_ARGS_INOUT) - 1))
        {
            pretval  = (int *) irp->AssociatedIrp.SystemBuffer;
            flags    = * (pretval + 1);
            strbufp  = (struct strbuf *) (pretval + 2);
            ctlsize  = strbufp->maxlen;
            datasize = (++strbufp)->maxlen;

            cbOut -= (sizeof(GETMSG_ARGS_INOUT) - 1);

            if (cbOut >= ctlsize)
            {
                cbOut -= ctlsize;

                if (cbOut >= datasize)
                {
                    // cbOut -= datasize;
                    LengthStatus = STATUS_SUCCESS;
                }
            }
        }

        if (LengthStatus != STATUS_SUCCESS)
        {
            IF_STRMDBG(TERSE) {
                STRMTRACE(("SHEAD: SHDispGetMsg(%lx) outbuf insufficient nbytes = %lx\n",
                    irp, irpsp->Parameters.DeviceIoControl.OutputBufferLength));
            }
            shortreply(irp, LengthStatus, 0);
            return (LengthStatus);
        }
    }

    //
    // the caller marshalled the input arguments contiguously thus:
    //
    //  typedef struct _GETMSG_ARGS_INOUT_ {    // getmsg()
    //      int             a_retval;           //  ignore on input
    //      long            a_flags;            //  0 or RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      char            a_stuff[1];         //  a_ctlbuf.buf  (optional)
    //                                          //  a_databuf.buf (optional)
    //  } GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;
    //
    inbuf = (PGETMSG_ARGS_INOUT) irp->AssociatedIrp.SystemBuffer;

    IF_STRMDBG(VERBOSE) {
        STRMTRACE(("SHEAD: SHDispGetMsg(irp = %lx)\n", irp));
    }

    IoAcquireCancelSpinLock(&irp->CancelIrql);

    spl_level = lock_strm(ms->e_strm);

    if (ms->e_rerror) {
        MyErrno = ms->e_rerror;
    }
    else if (ms->e_linked) {
        MyErrno = EINVAL;
    }
    else {
        MyErrno = 0;
    }

    if (MyErrno) {

        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispGetMsg() error = %d\n", MyErrno));
        }
        unlock_strm(ms->e_strm, spl_level);
        IoReleaseCancelSpinLock(irp->CancelIrql);
        SHpGenReply(irp, -1, MyErrno);
        return(STATUS_SUCCESS);
    }
    pri = (inbuf->a_flags == RS_HIPRI) ? QPCTL : 0;

    if (shready(ms->e_strm, pri)) {

        IF_STRMDBG(VERBOSE) {
            STRMTRACE(("SHEAD: SHDispGetMsg() stream's shready()\n"));
        }
// The two lines below are replaced by the lines between the vvv/^^^'s
//        temp = msgreply(ms, irp);
//        ASSERT(temp == 0);

// vvvvvvvv
// vvvvvvvv
        /*
         * the arguments are marshalled in one contiguous chunk, laid out as:
         *
         *      an unused int             (required)
         *      flags                     (required)
         *      struct strbuf ctrlbuf     (required)
         *      struct strbuf databuf     (required)
         */
        pretval  = (int *) irp->AssociatedIrp.SystemBuffer;
        flags    = * (pretval + 1);
        strbufp  = (struct strbuf *) (pretval + 2);
        ctlsize  = strbufp->maxlen;
        datasize = (++strbufp)->maxlen;

        /*
         * st_getmsg() may set MORECTL and/or MOREDATA in *pretval; we must
         * return it to the user-level runtime !!
         */
        ret = st_getmsg(ms->e_strm, ctlsize, datasize, &flags, pretval,
                            &mp, &remains);

        ASSERT(!ret);
        ASSERT(mp);
// ^^^^^^^^
// ^^^^^^^^
        unlock_strm(ms->e_strm, spl_level);
        IoReleaseCancelSpinLock(irp->CancelIrql);

// vvvvvvvv
// vvvvvvvv
        mptoirp(mp, irp);
        freemsg(mp);
// ^^^^^^^^
// ^^^^^^^^

        return(STATUS_SUCCESS);
    }
    if (ms->e_hup) {

        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispGetMsg() stream's was hung up\n"));
        }
        unlock_strm(ms->e_strm, spl_level);
        IoReleaseCancelSpinLock(irp->CancelIrql);
        SHpGenReply(irp, -1, EINTR);
        return(STATUS_SUCCESS);
    }

    //
    // enqueue this request in the waiting list of readers.
    //
    IoMarkIrpPending(irp);

    if (irp->Cancel) {

        unlock_strm(ms->e_strm, spl_level);

        IoSetCancelRoutine(irp, NULL);
        IoReleaseCancelSpinLock(irp->CancelIrql);
        shortreply(irp, STATUS_CANCELLED, 0);
        return(STATUS_CANCELLED);
    }

    status = SHAddPendingIrp(&(ms->e_readers), FALSE, irp, NULL);

    ASSERT(!shready(ms->e_strm, 0));

    unlock_strm(ms->e_strm, spl_level);

    if (status != STATUS_SUCCESS) {

        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispGetMsg() failed to SHAddPendingIrp\n"));
        }
        IoReleaseCancelSpinLock(irp->CancelIrql);
        shortreply(irp, status, 0);
        return(status);
    }

    IoSetCancelRoutine(irp, cancel_get);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    IF_STRMDBG(VERBOSE) {
        STRMTRACE(("SHEAD: SHDispGetMsg(irp = %lx) q_count = %ld\n",
        irp, RD(ms->e_strm->str_sq)->q_count ));
    }
    return(STATUS_PENDING);

} // SHDispGetMsg



int
SHpStreamError(
    IN PLIST_ENTRY listhead,
    IN int error
    )

/*++

Routine Description:

    This routine completes the IRPs waiting on a stream when an M_ERROR or
    M_HANGUP arrives from downstream.

Arguments:

    listhead  - either e_readers, e_writers or e_ioctlers
    error     - the POSIX error code to return

Return Value:

    The number of pending IRPs that were completed.

--*/

{
    int count = 0;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;

    IF_STRMDBG(TERSE) {
	 STRMTRACE(("SHEAD: ShpStreamError() for M_HANGUP/M_ERROR\n"));
    }

    while (!IsListEmpty(listhead)) {

        tmp  = RemoveHeadList(listhead);
        item = CONTAINING_RECORD(tmp,
                                    WAITING_IRP,
                                    w_list);

        SHpGenReply(item->w_irp, -1, error);
        ExFreePool(item);
        count++;
    }
    return(count);

} // SHpStreamError




STATIC
VOID
cancel_get(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    )

/*++

Routine Description:

    This routine is called when a getmsg() is cancelled.

    It must release the cancel spinlock before returning !!  The caller
    has already acquired the cancel spinlock.  ref: IoCancelIrp().

Arguments:

    device    - pointer to the device object
    irp       - pointer to the irp of this request

Return Value:

    none.

--*/

{
    int spl_level;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;
    PSTREAM_ENDPOINT ms;
    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(irp);

    ASSERT(device == (PDEVICE_OBJECT) StreamDevice);
    ASSERT(irpsp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    ASSERT(irpsp->Parameters.DeviceIoControl.IoControlCode ==
                                                        IOCTL_STREAMS_GETMSG);
    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: cancel_get(irp = %lx) entered\n", irp));
    }
    IoSetCancelRoutine(irp, NULL);                  /* unnecessary, but cheap */
    IoReleaseCancelSpinLock(irp->CancelIrql);

    ms = (PSTREAM_ENDPOINT) irpsp->FileObject->FsContext;

    spl_level = lock_strm(ms->e_strm);

    for (tmp = ms->e_readers.Flink; tmp != &ms->e_readers; tmp = tmp->Flink) {

        item = CONTAINING_RECORD(tmp,
                                WAITING_IRP,
                                w_list);

        if (irp != item->w_irp) {
            continue;
        }
        RemoveEntryList(&(item->w_list));

        unlock_strm(ms->e_strm, spl_level);
        ExFreePool(item);

        shortreply(irp, STATUS_CANCELLED, 0);

        IF_STRMDBG(CALL) {
            STRMTRACE(("SHEAD: cancel_get(irp = %lx) cancelled ok\n", irp));
        }
        return;
    }
    unlock_strm(ms->e_strm, spl_level);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: cancel_get(irp = %lx) not found\n", irp));
    }

} // cancel_get



void
msgrdy(
    IN struct msg_strm *ms,
    IN int              mtype
    )

/*++

Routine Description:

    This function is called by the Stream Head Driver when a message arrives
    at the read queue of the specified stream.

    Call this function with the stream endpoint locked !!

Arguments:

    ms      -  pointer to the stream endpoint
    mtype   -  type of the STREAMS message

Return Value:

    none.


--*/

{
    PIRP irp;
    int check, pri;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;
    PGETMSG_ARGS_INOUT inbuf;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: msgrdy(ms = %lx, mtype = %x)\n", ms, mtype));
    }

    switch (mtype) {
    case M_DATA:
    case M_PROTO:
        if (ms->e_strm_flags & POLLIN) {
            ms->e_strm_flags &= ~POLLIN;

            KeReleaseSemaphore(
                &Poll_fired,                    // semaphore
                SEMAPHORE_INCREMENT,            // priority increment
                1,                              // adjustment
                FALSE                           // wait
            );
        }
        break;

    case M_PCPROTO:
        if (ms->e_strm_flags & POLLPRI) {
            ms->e_strm_flags &= ~POLLPRI;

            KeReleaseSemaphore(
                &Poll_fired,                    // semaphore
                SEMAPHORE_INCREMENT,            // priority increment
                1,                              // adjustment
                FALSE                           // wait
            );
        }
        break;

    case M_SIG:
        if (ms->e_strm_flags & POLLMSG) {
            ms->e_strm_flags &= ~POLLMSG;

            KeReleaseSemaphore(
                &Poll_fired,                    // semaphore
                SEMAPHORE_INCREMENT,            // priority increment
                1,                              // adjustment
                FALSE                           // wait
            );
        }
        break;

    default:
        IF_STRMDBG(TERSE) {
           STRMTRACE(("SHEAD: msgrdy(), msg type = %x unexpected\n", mtype));
        }
        ASSERT(0);
    }

    while (!IsListEmpty( &(ms->e_readers) )) {

        tmp  = RemoveHeadList( &(ms->e_readers) );
        item = CONTAINING_RECORD(tmp,
                                    WAITING_IRP,
                                    w_list);
        irp   = item->w_irp;

        //
        // get the RS_HIPRI flag, if any, from the irp.
        //
        inbuf = (PGETMSG_ARGS_INOUT) irp->AssociatedIrp.SystemBuffer;
        pri   = (inbuf->a_flags == RS_HIPRI) ? QPCTL : 0;

        if (!shready(ms->e_strm, pri)) {
            InsertHeadList( &(ms->e_readers), &(item->w_list) );
            return;
        }
        check = msgreply(ms, irp);
        ASSERT(check == 0);

        ExFreePool(item);
    }

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: msgrdy() completed ok\n"));
    }
    return;

} // msgrdy


void
strmevent(
    IN STREAM_ENDPOINT *ms,
    IN int              rerror,
    IN int              werror,
    IN int              t
    )

/*++

Routine Description:

    This function handles special messages that arrive at the stream head.
    It is based on the SpiderStreams function of the same name.

    Only M_ERROR and M_HANGUP messages are handled at present.  M_ERROR is
    straightforward to deal with.  The error status in the stream structure
    is set, and any pending requests failed.

    M_HANGUP is very similar, except that read requests are allowed to
    complete, and subsequent reads are treated as end of file, rather than
    an error condition.

Arguments:

    ms      -  pointer to stream endpoint
    rerror  -  read queue error
    werror  -  write queue error
    t       -  type of STREAMS message

Return Value:


--*/

{
    PIRP irp;
    int succeeded;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: strmevent(ms = %lx) entered\n", ms));
    }

    if (ms->TdiStreamPtr) {
        TdiStreamEvent(ms, rerror, werror, t);
        return;
    }

    if (rerror == NOERROR) {
        rerror = ms->e_rerror;                      // get current value
    }
    else {
        ms->e_rerror = rerror;                      // set read error status
    }

    if (werror == NOERROR) {
        werror = ms->e_werror;                      // get current value
    }
    else {
        ms->e_werror = werror;                      // set write error status
    }

    if ((rerror == 0) && (werror == 0)) {           // errors zeroed out
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: strmevent(ms = %lx) [rw]error = 0\n", ms));
        }
        return;
    }

    switch (t) {
    case M_HANGUP:
        ms->e_hup = 1;
        break;

    default:
        ASSERT(0);
        /* fall through */

    case M_ERROR:
        break;
    }

    if (rerror) {
        SHpStreamError(&(ms->e_readers), rerror);
    }

    //
    // in response to an M_ERROR or M_HANGUP for the write-side, fail
    // any pending ioctl(), putmsg() or write() requests.
    //
    // If a pending ioctl() is being failed, don't forget to abort its
    // timeout !!
    //
    if (werror) {
        irp = ms->e_active_ioctl;

        if (irp) {
            ms->e_active_ioctl = NULL;
            succeeded          = 1;

            if (irp->IoStatus.Information) {
                succeeded = untimeout((int)irp->IoStatus.Information);

                ASSERT((succeeded == 0) || (succeeded == 1));
            }

            if (succeeded) {
                SHpGenReply(irp, -1, werror);
            }
        }

        SHpStreamError(&(ms->e_ioctlers), werror);
        SHpStreamError(&(ms->e_writers), werror);
    }

    //
    // let poll()'ers know of the error/hangup
    //
    KeReleaseSemaphore(
        &Poll_fired,                    // semaphore
        SEMAPHORE_INCREMENT,            // priority increment
        1,                              // adjustment
        FALSE                           // wait
    );

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: strmevent(ms = %lx) completed\n", ms));
    }
    return;

} // strmevent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\sys\sh_irp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sh_irp.c

Abstract:

    This source file contains the functions that convert between NT IRPs
    and STREAMS messages.

    Most functions in this module are based on identically named routines
    in the SpiderStreams emulator source, stremul/msgrtns.c.

Author:

    Eric Chin (ericc)           August 16, 1991

Revision History:

--*/
#include "sh_inc.h"


/*
 * Local (Private) Functions
 */
STATIC void
mp_buf_free(
    IN char    *p
    );

STATIC int
mptoirp(
    IN mblk_t          *mp,
    IN PIRP             irp
    );



VOID
SHpGenReply(
    IN PIRP irp,
    IN int retval,
    IN int MyErrno
    )

/*++

Routine Description:

    This function is called to complete IRPs that convey generic STREAMS
    API's: ioctl(I_FDINSERT), ioctl(I_STR), putmsg(), ....

    By generic, we mean it returns a return value and possible an errno.

Arguments:

    irp     - irp to complete
    retval  - return value of the ioctl(,I_FDINSERT,) or putmsg()
    errno   - POSIX error value, if any

Return Value:

    none.

--*/

{
    PSTRM_ARGS_OUT outptr;
    PIO_STACK_LOCATION pIrpSp;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHpGenReply(irp = %lx, %lx, %lx) entered\n",
                    irp, retval, MyErrno));
    }

    pIrpSp = IoGetCurrentIrpStackLocation(irp);

    // Check size of output buffer.
    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(STRM_ARGS_OUT))
    {
        shortreply(irp, STATUS_BUFFER_TOO_SMALL, 0);
        return;
    }

    //
    // have IopCompleteRequest() copy the following back to the user's
    // output buffer, laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    outptr           = (PSTRM_ARGS_OUT) irp->AssociatedIrp.SystemBuffer;
    outptr->a_retval = retval;
    outptr->a_errno  = MyErrno;

    shortreply(irp, STATUS_SUCCESS, sizeof(STRM_ARGS_OUT));

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHpGenReply(irp = %lx) done\n", irp));
    }
    return;

} // SHpGenReply




int
iocreply(
    IN mblk_t *mp,
    IN PIRP    irp
    )

/*++

Routine Description:

    This function sends the reply to an M_IOCTL message back to the user,
    reverting a STREAMS message into an NT irp.  It is loosely based on the
    SpiderStreams functions, iocreply() and mptomsg(), in stremul/msgrtns.c.

    It should be called after the appropriate routine has taken the message
    off the queue.  If it fails to send a message, it returns a negative
    value.

    Acquire the lock of ms->e_strm before calling, and release it afterwards !!

Arguments:

    mp      -  pointer to the message to reply to
    irp     -  pointer to the IRP

Return Value:

    -1  - no message is ready to be sent to the user
    -2  - failed to send a message to the user


--*/

{
    mblk_t *tmp;
    int length;
    char *outbuf;
    int *pretval;
    int nbytes = 0;
    struct iocblk *iocp;
    struct strioctl *striop;


    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: iocreply(mp = %lx, irp = %lx) entered\n", mp, irp));
    }

    if (!mp) {
        return(-1);
    }
    outbuf   = irp->AssociatedIrp.SystemBuffer;
    pretval  = (int *) outbuf;
    *pretval = 0;

    switch (mp->b_datap->db_type) {

    /*
     * for ioctl(I_STR), arrange the return parameters contiguously in outbuf
     * in the format:
     *
     *      int return value            (required)
     *      union {
     *          int errno;              (required)
     *          struct strioctl;        (ic_cmd is not valid !!)
     *      }
     *      int                         (required)
     *      int                         (required)
     *      ic_dp buffer                (optional)
     */
    case M_IOCACK:
        iocp           = (struct iocblk *) mp->b_rptr;
        *pretval       = iocp->ioc_rval;
        striop         = (struct strioctl *) ((int *) outbuf + 1);
        striop->ic_len = 0;
        outbuf         = (char *) (striop + 1) + 2 * sizeof(int);

        for (tmp = mp->b_cont; tmp; tmp = tmp->b_cont) {
            ASSERT(tmp->b_datap->db_type == M_DATA);
            length = (int)(tmp->b_wptr - tmp->b_rptr);

            ASSERT(length >= 0);
            striop->ic_len += length;

            RtlCopyMemory(outbuf, tmp->b_rptr, length);
            outbuf += length;
        }
        nbytes = (int) ( outbuf - (char *) irp->AssociatedIrp.SystemBuffer );
        break;

    case M_IOCNAK:
        iocp           = (struct iocblk *) mp->b_rptr;
        *pretval       = -1;
        *(pretval + 1) = iocp->ioc_error;
        nbytes         = 2 * sizeof(int);
        break;

    default:
        ASSERT(0);                          /* shouldn't come here */
    }
    shortreply(irp, STATUS_SUCCESS, nbytes);
    freemsg(mp);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: iocreply(irp = %lx) nbytes = %lx, completed ok\n",
                        irp, nbytes));
    }
    return(0);

} // iocreply



mblk_t *
irptomp(
    IN PIRP     irp,
    IN int      pri,
    IN int      ctlsize,
    IN int      datasize,
    IN char    *mbuf
    )

/*++

Routine Description:

    This function converts the buffers associated with an NT irp into a
    STREAMS message.  It is based on the SpiderSTREAMS routine, msgtomp().

    The first block of the message created is either an M_PROTO or M_DATA
    block.  To make it M_PCPROTO, M_IOCTL, ..., set it yourself after
    this function returns !!

Arguments:

    irp      - pointer to the IRP.
    pri      - buffer allocation priority.  BPRI_LO, BPRI_MED or BPRI_HI.
    ctlsize  - length of control part message
    datasize - length of data part of message
    mbuf     - pointer to a contiguous chunk containing first the control
                part of the message, if any, and then the data part.

Return Value:

    pointer to the resulting STREAMS message, or NULL if unsuccessful.

--*/

{
    unsigned char *extra;
    mblk_t *mp  = (mblk_t *) NULL;
    mblk_t *cmp = (mblk_t *) NULL;
    frtn_t fr_rtn;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: irptomp(clen, dlen, mbuf = %lx, %lx, %lx) entered\n",
                                                ctlsize, datasize, mbuf));
    }

    /*
     * special case for constructing a zero length message.
     */
    if ((max(ctlsize, 0) + max(datasize, 0)) == 0) {

        mp = allocb(0, pri);

        if (!mp) {

            IF_STRMDBG(TERSE) {
                STRMTRACE(("SHEAD: irptomp(), allocb of 0 failed\n"));
            }

            return((mblk_t *) NULL);
        }
        ASSERT(mp->b_datap->db_type == M_DATA);

        if (ctlsize != -1) {
            mp->b_datap->db_type = M_PROTO;
        }
        ASSERT(mp->b_wptr == mp->b_rptr);
        return(mp);
    }
    fr_rtn.free_func = mp_buf_free;

    if (ctlsize >= 0) {

        if (ctlsize) {

            extra = ExAllocatePool(NonPagedPool, ctlsize);

            if (!extra) {
                return((mblk_t *) NULL);
            }
            RtlCopyMemory(extra, mbuf, ctlsize);

            fr_rtn.free_arg = (char *) extra;
            cmp = esballoc(extra, ctlsize, pri, &fr_rtn);
        }
        else {
            cmp = allocb(0, pri);
        }
        if (!cmp) {

            IF_STRMDBG(TERSE) {
                STRMTRACE(("SHEAD: irptomp(), esballoc %x failed\n", ctlsize));
            }

            return((mblk_t *) NULL);
        }
        ASSERT(cmp->b_datap->db_type == M_DATA);
        cmp->b_datap->db_type = M_PROTO;

        ASSERT(cmp->b_wptr == cmp->b_rptr);
        cmp->b_wptr += ctlsize;
    }

    if (datasize >= 0) {

        if (datasize) {
            extra = ExAllocatePool(NonPagedPool, datasize);

            if (!extra) {
                if (cmp) {
                    freemsg(cmp);
                }
                return((mblk_t *) NULL);
            }

            RtlCopyMemory(extra,
                            (ctlsize <= 0) ? mbuf : mbuf + ctlsize, datasize);

            fr_rtn.free_arg = (char *) extra;

            mp = esballoc(extra, datasize, pri, &fr_rtn);
            }
        else {
            mp = allocb(0, pri);
        }
        if (!mp) {

            IF_STRMDBG(TERSE) {
                STRMTRACE(("SHEAD: irptomp(), esballoc %x failed\n", ctlsize));
            }

            if (cmp) {
                freemsg(cmp);
            }
            return((mblk_t *) NULL);
        }
        ASSERT(mp->b_datap->db_type == M_DATA);
        ASSERT(mp->b_wptr == mp->b_rptr);
        mp->b_wptr += datasize;
    }
    if (cmp) {
        cmp->b_cont = mp;
        mp          = cmp;
    }

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: irptomp(mbuf = %lx) returns, mp = %lx\n", mbuf, mp));
    }
    return(mp);

} // irptomp



STATIC void
mp_buf_free(
    IN char    *p
    )
{
    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: mp_buf_free(%lx) entered\n", p));
    }
    if (p) {
        ExFreePool(p);
    }

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: mp_buf_free(%lx) completed\n", p));
    }
    return;

} // mp_buf_free



STATIC int
mptoirp(
    IN mblk_t  *mp,
    IN PIRP     irp
    )

/*++

Routine Description:

    This function converts a STREAMS message into an NT irp.  It is based
    on the SpiderStreams routine, mptomsg(), in stremul/msgrtns.c.

    It should be called after the appropriate routine has taken the message
    off the queue.  If it fails to send a message, it returns a negative
    value.

    The caller must free the STREAMS message, mp.  This function doesn't !!

Arguments:

    mp
    irp

Return Value:

    number of bytes copied back to user space, or a negative value if
    unsuccessful.

--*/

{
    char *outbuf;
    int *pretval;
    int length, nbytes;
    struct strbuf *strbufp;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: mptoirp(mp = %lx, irp = %lx) entered\n", mp, irp));
    }

    /*
     * for getmsg(), arrange the return parameters contiguously in outbuf
     * in the format:
     *
     *      int return value            (required)
     *      flags / errno               (required)
     *      struct strbuf ctrlbuf       (required)
     *      struct strbuf databuf       (required)
     *      ctrl buffer                 (optional)
     *      data buffer                 (optional)
     */
    outbuf   = irp->AssociatedIrp.SystemBuffer;
    pretval  = (int *) outbuf;
    strbufp  = (struct strbuf *) (pretval + 2);     /* struct strbuf ctrlbuf */
    outbuf   = (char *) (strbufp + 2);              /* ctrl buffer */

    /*
     * ensure that the return value is copied back to the user-level runtime.
     * It was zeroed in ShDispGetmsg(), and the MORECTL, MOREDATA bits may
     * have set by st_getmsg().
     */
    nbytes = 2 * sizeof(int);

    switch (mp->b_datap->db_type) {

    case M_PCPROTO:
        *(pretval + 1) = RS_HIPRI;                  /* flags */
        goto doproto;

    case M_PROTO:
        *(pretval + 1) = 0;                         /* flags */

    doproto:
        length  = (int)(mp->b_wptr - mp->b_rptr);

        if (strbufp->maxlen < length) {
            length    = strbufp->maxlen;
            *pretval |= MORECTL;
        }
        strbufp->len = length;
        RtlCopyMemory(outbuf, mp->b_rptr, strbufp->len);

        mp = mp->b_cont;
        goto dodata;

    case M_DATA:
        *(pretval + 1) = 0;                         /* flags */
        strbufp->len   = 0;                         /* ctrlbuf->len */

    dodata:
        outbuf += strbufp->len;

        (++strbufp)->len = 0;

        for (; mp; mp = mp->b_cont) {
            ASSERT(mp->b_datap->db_type == M_DATA);
            length = (int)(mp->b_wptr - mp->b_rptr);

            ASSERT(length >= 0);

            if (strbufp->maxlen < length) {
                length    = strbufp->maxlen;
                *pretval |= MOREDATA;
            }
            RtlCopyMemory(outbuf, mp->b_rptr, length);
            outbuf       += length;
            strbufp->len += length;

            if ((strbufp->maxlen -= length) == 0) {
                break;
            }
        }
        nbytes = (int)( outbuf - (char *) irp->AssociatedIrp.SystemBuffer );
        break;

    default:
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: mptoirp(), unexpected db_type = %x\n",
                                                    mp->b_datap->db_type));
        }
        ASSERT(0);                              /* shouldn't come here */
        KeBugCheck(STREAMS_INTERNAL_ERROR);
        break;
    }

    /*
     * no matter what, we always pass back the return value and the flags
     * to the user-level runtime.
     */
    ASSERT(nbytes >= 2 * sizeof(int));
    shortreply(irp, STATUS_SUCCESS, nbytes);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: mptoirp(irp = %lx), %lx, completed\n", irp, nbytes));
    }
    return(nbytes);

} // mptoirp



int
msgreply(
    IN STREAM_ENDPOINT *ms,
    IN PIRP             irp
    )

/*++

Routine Description:

    This function gets a STREAMS message to complete an IRP representing
    a getmsg().  It is based on the SpiderStreams emulator function of the
    same name.

    Lock the stream, ms->e_strm, before calling this function, and unlock
    it after this function returns !!

Arguments:

    ms      -  stream endpoint from whose read queue to get the message from
    irp     -  IRP to complete

Return Value:

     0  - successful completion
    -1  - no message is ready to be sent to the user
    -2  - failed to send a message to the user


--*/

{
    int ret;
    mblk_t *mp;
    int more = 0;
    struct strbuf *strbufp;
    int ctlsize, datasize, flags, *pretval, remains;

    /*
     * the arguments are marshalled in one contiguous chunk, laid out as:
     *
     *      an unused int             (required)
     *      flags                     (required)
     *      struct strbuf ctrlbuf     (required)
     *      struct strbuf databuf     (required)
     */
    pretval  = (int *) irp->AssociatedIrp.SystemBuffer;
    flags    = * (pretval + 1);
    strbufp  = (struct strbuf *) (pretval + 2);
    ctlsize  = strbufp->maxlen;
    datasize = (++strbufp)->maxlen;

    /*
     * st_getmsg() may set MORECTL and/or MOREDATA in *pretval; we must
     * return it to the user-level runtime !!
     */
    ret = st_getmsg(ms->e_strm, ctlsize, datasize, &flags, pretval,
                        &mp, &remains);
    if (ret) {
        ASSERT(0);
        shortreply(irp, STATUS_SUCCESS, 0);
        return(0);
    }

    if (!mp) {
        return(-1);
    }

    //
    // Unlike SpiderSTREAMS, our mptoirp() function never fails !!  Hence
    // the assertion.
    //
    if (mptoirp(mp, irp) < 0) {
        ASSERT(0);
        st_putback(ms->e_strm, mp, remains);
        return(-2);
    }

    /*
     * Spider frees mp by chasing mp->b_next.  Why ?
     */
    ASSERT(!(mp->b_next));

    freemsg(mp);
    return(0);

} // msgreply



int
shortreply(
    IN PIRP     irp,
    IN int      status,
    IN int      nbytes
    )

/*++

Routine Description:

    This function completes an IRP, and arranges for return parameters,
    if any, to be copied.

    Although somewhat a misnomer, this function is named after a similar
    function in the SpiderSTREAMS emulator.

Arguments:

    irp     -  pointer to the IRP to complete
    status  -  completion status of the IRP
    nbytes  -  number of bytes to return

Return Value:

    number of bytes copied back to the user.

--*/

{
    CCHAR priboost;

    IF_STRMDBG(CALL) {
        STRMTRACE((
        "SHEAD: shortreply(irp, status, nbytes = %lx, %lx, %lx) entered\n",
                    irp, status, nbytes));
    }

    //
    // set the irp's cancel routine to NULL, or the system may bugcheck
    // with the bugcode, CANCEL_STATE_IN_COMPLETED_IRP !!
    //
    // ref: IoCancelIrp(), ...\ntos\io\iosubs.c.
    //
    //
    IoAcquireCancelSpinLock(&irp->CancelIrql);
    IoSetCancelRoutine(irp, NULL);
    IoReleaseCancelSpinLock(irp->CancelIrql);


    //
    // irp->IoStatus.Information is meaningful only for STATUS_SUCCESS
    //
    ASSERT(!nbytes || (status == STATUS_SUCCESS));

    irp->IoStatus.Information = nbytes;
    irp->IoStatus.Status      = status;

    priboost = (CCHAR) ((status == STATUS_SUCCESS) ?
                        IO_NETWORK_INCREMENT : IO_NO_INCREMENT);

    IoCompleteRequest(irp, priboost);

    return(nbytes);

} // shortreply
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\makefile.inc ===
$(O)\nlstxt.mc: $(PROJECT_ROOT)\inc\unixapis.mc localmsg.mc
    copy $(PROJECT_ROOT)\inc\unixapis.mc+localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    common.h

Abstract:

    This header file is to be included by all sources in this directory.

Author:

    Eric Chin (ericc)           August  2, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                added includes to get setlasterror

--*/
#ifndef _COMMON_
#define _COMMON_

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// C Run Time Library Headers
//
#include <assert.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// Windows headers
//
#include <windef.h>
#include <windows.h>

//
// Regular STREAMS headers
//
//
#include <crt\errno.h>
#include <poll.h>
#include <stropts.h>


//
// Additional NT STREAMS Headers
//
// ntddstrm.h defines the interface to the Stream Head driver; ntstapi.h
// defines the STREAMS APIs available on NT.
//
#include <ntddstrm.h>
#include <ntstapi.h>


//
// Private Function Prototypes
//
int
MapNtToPosixStatus(
    IN NTSTATUS   status
    );


#endif /* _COMMON_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\sys\sh_proto.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sh_proto.h

Abstract:

    This header file contains the prototypes of the functions that are
    local to this directory.  Non-local items go to ..\inc.

Author:

    Eric Chin (ericc)           September 29, 1992

Revision History:

--*/

#ifndef _SH_PROTO_
#define _SH_PROTO_



//
// Stream Head Driver Dispatch Functions
//
NTSTATUS
SHDispFdInsert(
    IN PIRP                 irp,
    IN PIO_STACK_LOCATION   irpsp
    );

NTSTATUS
SHDispGetMsg (
    IN PIRP               irp,
    IN PIO_STACK_LOCATION irpsp
    );

NTSTATUS
SHDispIoctl (
    IN PIRP               irp,
    IN PIO_STACK_LOCATION irpsp
    );

NTSTATUS
SHDispIStr(
    IN PIRP irp
    );

NTSTATUS
SHDispPoll (
    IN PIRP               irp,
    IN PIO_STACK_LOCATION irpsp
    );

NTSTATUS
SHDispPutMsg (
    IN PIRP               irp,
    IN PIO_STACK_LOCATION irpsp
    );



//
// Private Function Prototypes
//
NTSTATUS
SHpCloseDelay (
    IN strm_t *stream
    );

VOID
SHpCloseRun (
    VOID
    );

VOID
SHpUnlinkRun (
    VOID
    );

NTSTATUS
SHpCloseStream (
    IN PIRP             irp
    );

VOID
SHpGenReply(
    IN PIRP irp,
    IN int retval,
    IN int MyErrno
    );

NTSTATUS
SHpOpenStream (
    IN PIRP     irp,
    IN dev_t    sdevno
    );

NTSTATUS
StrmpCreateThreads(
    VOID
    );

NTSTATUS
StrmpTerminateThreads(
    VOID
    );

NTSTATUS
do_link(
    IN PIRP         irp,
    IN char        *inbuf,
    IN ULONG        nbytes,
    OUT int        *pretval,
    OUT int        *pMyErrno
    );

NTSTATUS
do_poll(
    IN PIRP         irp,
    IN OUT char    *inbuf,
    IN ULONG        nbytes,
    OUT int        *pretval,
    OUT int        *pMyErrno
    );

NTSTATUS
do_push(
    IN PIRP         irp,
    IN char        *name,
    IN ULONG        nbytes,
    OUT int        *pretval,
    OUT int        *pMyErrno
    );

NTSTATUS
do_sdebug(
    IN PIRP         irp,
    IN PFILE_OBJECT pfileobj,
    IN char        *inbuf,
    IN ULONG        nbytes,
    OUT int        *pretval,
    OUT int        *pMyErrno
    );

NTSTATUS
do_unlink(
    IN PIRP         irp,
    IN char        *inbuf,
    IN ULONG        nbytes,
    OUT int        *pretval,
    OUT int        *pMyErrno
    );

NTSTATUS
init_poll(
    VOID
    );

NTSTATUS
init_u(
    VOID
    );

void
iocrdy(
    IN PSTREAM_ENDPOINT ms,
    IN mblk_t          *mp,
    IN int             *spl_levelp
    );

int
iocreply(
    IN mblk_t *mp,
    IN PIRP    irp
    );

mblk_t *
irptomp(
    IN PIRP             irp,
    IN int              pri,
    IN int              ctlsize,
    IN int              datasize,
    IN char            *mbuf
    );

void
msgrdy(
    IN struct msg_strm *ms,
    IN int              mtype
    );

int
msgreply(
    IN STREAM_ENDPOINT *ms,
    IN PIRP             irp
    );

int
shopen(
    IN int      dev,
    IN int      flag,
    IN strm_t **sp,
    IN caddr_t  handle
    );

int
shortreply(
    IN PIRP     irp,
    IN int      status,
    IN int      nbytes
    );

int
shrange(
    IN strm_t  *strm,
    IN int      ctlsize,
    IN int      datasize
    );

int
shready(
    IN strm_t  *strm,
    IN int      pri
    );

int
shtype(
    IN strm_t  *strm
    );


void
shwsrv(
    IN struct msg_strm *ms
    );

void
sigevent(
    IN char *cp,
    IN int signo
    );

int
st_getmsg(
    IN strm_t          *s,
    IN int              datasize,
    IN int              ctlsize,
    IN OUT int         *flags,
    IN OUT int         *more,
    OUT mblk_t        **mpp,
    OUT int            *remains
    );

void
st_putback(
    IN strm_t *s,
    IN mblk_t *mp,
    IN int remains
    );

void
strmevent(
    IN PSTREAM_ENDPOINT ms,
    IN int              rerror,
    IN int              werror,
    IN int              type
    );

void
stropts(
    IN char *cp,
    IN struct stroptions *opts
    );

int
st_getmsg(
    IN strm_t          *s,
    IN int              datasize,
    IN int              ctlsize,
    IN OUT int         *flags,
    IN OUT int         *more,
    OUT mblk_t        **mpp,
    OUT int            *remains
    );

void
st_putback(
    IN strm_t *s,
    IN mblk_t *mp,
    IN int remains
    );

void
trypoll(
    );


STATIC int
mptoirp(
    IN mblk_t          *mp,
    IN PIRP             irp
    );

#endif /* _SH_PROTO_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\status.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    status.c

Abstract:

    This module attempts to map NT status codes to Unix error
    numbers as specified by the X/Open Transport Interface.

Author:

    Eric Chin (ericc)           August  2, 1991

Revision History:

--*/

#include "common.h"
#include <sock_err.h>

int
MapNtToPosixStatus(
    IN NTSTATUS   status
    )

/*++

Routine Description:

    This function returns a POSIX error number, given an NT status code.

Arguments:

    status    - an NT status code

Return Value:

    the corresponding POSIX error number

--*/

{
    switch (status) {
    case STATUS_INSUFFICIENT_RESOURCES:
        return(ENOSR);

    case STATUS_INVALID_PARAMETER:
        return(EINVAL);

    case STATUS_NO_SUCH_DEVICE:
        return(ENXIO);

    case STATUS_INVALID_NETWORK_RESPONSE:
        return(ENETDOWN);

    case STATUS_NETWORK_BUSY:
        return(EBUSY);

    case STATUS_ACCESS_DENIED:
        return(EACCES);

    default:
        return(EINVAL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\openstrm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    openstrm.c

Abstract:

    This module implements the STREAMS APIs, s_open() and OpenStream().

Author:

    Sam Patton (sampa)          November, 1991
    Eric Chin (ericc)           July 17, 1992

Revision History:


--*/
#include "common.h"




HANDLE
s_open(
    IN char *path,
    IN int oflag,
    IN int ignored
    )

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    char Buffer[sizeof(FILE_FULL_EA_INFORMATION) + NORMAL_STREAM_EA_LENGTH + 1];
    NTSTATUS Status;

    RtlInitString(&name_string, path);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    EaBuffer = (PFILE_FULL_EA_INFORMATION) Buffer;

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = NORMAL_STREAM_EA_LENGTH;
    EaBuffer->EaValueLength = 0;

    RtlMoveMemory(
        EaBuffer->EaName,
        NormalStreamEA,
        NORMAL_STREAM_EA_LENGTH + 1);

    Status =
    NtCreateFile(
        &StreamHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        EaBuffer,
        sizeof(FILE_FULL_EA_INFORMATION) - 1 +
            EaBuffer->EaNameLength + 1);

    RtlFreeUnicodeString(&uc_name_string);

    if (Status != STATUS_SUCCESS) {
        SetLastError(MapNtToPosixStatus(Status));
        return(INVALID_HANDLE_VALUE);
    } else {
        return(StreamHandle);
    }

} // s_open



HANDLE
OpenStream(
    IN char *AdapterName
    )

/*++

Routine Description:

    This function is used by the TCP/IP Utilities to open STREAMS drivers.

    It was exported by the winstrm.dll included in the July, 1992 PDC
    release.  Hence, it will continue to be exported by winstrm.dll.

Arguments:

    AdapterName - path of the STREAMS driver

Return Value:

    An NT handle, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    return( s_open(AdapterName, 2, 0) );

} // OpenStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\s_getmsg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_getmsg.c

Abstract:

    This module implements the STREAMS api, getmsg().

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror

--*/
#include "common.h"




int
getmsg(
    IN HANDLE               fd,
    IN OUT struct strbuf   *ctrlptr OPTIONAL,
    IN OUT struct strbuf   *dataptr OPTIONAL,
    IN OUT int             *flagsp
    )

/*++

Routine Description:

    This procedure is called to receive a STREAMS message.

Arguments:

    fd        - NT file handle
    ctrlptr   - pointer to the control portion of the STREAMS message
    dataptr   - pointer to the data portion of the STREAMS message
    flagsp    - pointer to the flags argument, which may be RS_HIPRI

Return Value:

    0, MORECTL and/or MOREDATA bits set if successful, -1 otherwise.

--*/
{
    char *tmp;
    int chunksz;
    NTSTATUS status;
    PSTRM_ARGS_OUT oparm;
    IO_STATUS_BLOCK iosb;
    PGETMSG_ARGS_INOUT chunk;
    int retval;

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //  typedef struct _GETMSG_ARGS_INOUT_ {
    //      int             a_retval;           //  ignored for input
    //      long            a_flags;            //  0 or RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      char            a_stuff[1];         //  a_ctlbuf.buf  (optional)
    //                                          //  a_databuf.buf (optional)
    //  } GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;
    //
    //
    chunksz = sizeof(GETMSG_ARGS_INOUT) - 1 +
                ((ctrlptr && (ctrlptr->maxlen > 0)) ? ctrlptr->maxlen : 0) +
                ((dataptr && (dataptr->maxlen > 0)) ? dataptr->maxlen : 0);

    if (!(chunk = (PGETMSG_ARGS_INOUT) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }
    chunk->a_flags = (long) *flagsp;

    memset(&(chunk->a_ctlbuf), 0, 2 * sizeof(struct strbuf));

    if (ctrlptr) {
        chunk->a_ctlbuf = *ctrlptr;             // structure copy
    }

    if (dataptr) {
        chunk->a_databuf = *dataptr;            // structure copy
    }

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_GETMSG,                   // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (status != STATUS_SUCCESS) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

//
// sampa
//

#if 0
    if (status == STATUS_PENDING)
        {
        TimeOut.LowPart = 30L;  // 30 second
        TimeOut.HighPart = 0L;
        TimeOut = RtlExtendedIntegerMultiply(TimeOut, 1000000L);
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
        if (status != STATUS_SUCCESS) {
            SetLastError(MapNtToPosixStatus(status));
            LocalFree((HANDLE) chunk);
            return(-1);
            }
        }
#endif

    //
    // if there was an error, the return parameters from the Stream Head
    // Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    //
    oparm = (PSTRM_ARGS_OUT) chunk;

    if (oparm->a_retval == -1) {
        SetLastError(oparm->a_errno);
        retval = oparm->a_retval;
        LocalFree(chunk);
        return(retval);
    }

    // otherwise, the return parameters from the Stream Head Driver are laid
    // out as:
    //
    //  typedef struct _GETMSG_ARGS_INOUT_ {
    //      int             a_retval;           //  ignored for input
    //      long            a_flags;            //  0 or RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      char            a_stuff[1];         //  a_ctlbuf.buf  (optional)
    //                                          //  a_databuf.buf (optional)
    //  } GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;
    //
    //
    *flagsp = chunk->a_flags;
    tmp     = chunk->a_stuff;

    if (ctrlptr) {
        ctrlptr->len = chunk->a_ctlbuf.len;

        if (ctrlptr->len > 0) {
            assert(ctrlptr->len <= ctrlptr->maxlen);
            memcpy(ctrlptr->buf, tmp, ctrlptr->len);
            tmp += ctrlptr->len;
        }
    }

    if (dataptr) {
        dataptr->len = chunk->a_databuf.len;

        if (dataptr->len > 0) {
            assert(dataptr->len <= dataptr->maxlen);
            memcpy(dataptr->buf, tmp, dataptr->len);
        }
    }

    retval = chunk->a_retval;
    LocalFree(chunk);
    return(retval);

} // getmsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\sys\sh_put.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sh_put.c

Abstract:

    This source file contains those functions of the Stream Head Driver that
    deal with sending messages down a stream.

    It is based on the SpiderSTREAMS source, stremul\msgsrvr.c.

Author:

    Eric Chin (ericc)           August 16, 1991

Revision History:

Notes:

   The write error state of a stream is represented by ms->e_werror.  Once
   set, this is never reset.  This corresponds to the STREAMS semantics as
   defined by AT&T.  Once a user is notified of a write error on a stream,
   about the only recourse is to close the stream.

--*/
#include "sh_inc.h"



/*
 * Private Functions
 */
STATIC VOID
cancel_put(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

STATIC NTSTATUS
do_putmsg(
    IN PIRP             irp,
    IN BOOLEAN          from_queue,
    IN int             *spl_levelp,
    OUT BOOLEAN        *pmore
    );

STATIC queue_t *
handle_to_queue (
    IN HANDLE   handle
    );




NTSTATUS
SHDispFdInsert(
    IN PIRP                 irp,
    IN PIO_STACK_LOCATION   irpsp
    )

/*++

Routine Description:

    This routine is called to put a message down a stream.  It is based on
    the SpiderStreams emulator's msgserver() routine.

    This routine merely peels open the IRP, checks the putmsg() arguments
    for consistency, locks the appropriate stream, and then calls
    do_putmsg(), which does the bulk of the work.

Arguments:

    irp       - pointer to the IRP representing this request
    irpsp     - pointer to the IRP stack location for this request

Return Value:

    An NT status code.  Whatever the return value, this function will arrange
    for the IRP to be completed.

--*/

{
    int spl_level;
    queue_t *iq = NULL;
    PSTREAM_ENDPOINT ms;
    PPUTMSG_ARGS_IN inbuf;
    struct strbuf *ctrlptr, *dataptr;

    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                            METHOD_BUFFERED);
    ms = (STREAM_ENDPOINT *) irpsp->FileObject->FsContext;

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength <
                                                sizeof(PUTMSG_ARGS_IN) - 1) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispFdInsert(%lx) insufficient nbytes = %lx\n",
                    irp, irpsp->Parameters.DeviceIoControl.InputBufferLength));
        }
        shortreply(irp, STATUS_INVALID_PARAMETER, 0);
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // the caller marshalled the input arguments contiguously thus:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  I_FDINSERT
    //      long            a_flags;            //  0 | RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      HANDLE          a_insert.i_fildes;  //  (required)
    //      int             a_offset;           //  (required)
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (required)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    // When the message has no data part, the caller must have set
    // a_databuf.len = -1 !!
    //
    //
    inbuf   = (PPUTMSG_ARGS_IN) irp->AssociatedIrp.SystemBuffer;
    ctrlptr = &(inbuf->a_ctlbuf);
    dataptr = &(inbuf->a_databuf);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispFdInsert(flags, clen, dlen = %d, %lx, %lx)\n",
                                inbuf->a_flags, ctrlptr->len, dataptr->len));
    }

    if (((inbuf->a_flags != 0) && (inbuf->a_flags != RS_HIPRI)) ||
         (ctrlptr->len <= 0)) {
            SHpGenReply(irp, -1, EINVAL);
            return(STATUS_SUCCESS);
    }

    if ((inbuf->a_offset < 0) ||
        (inbuf->a_offset % sizeof(char *)) ||
        (ctrlptr->len < (signed) (inbuf->a_offset + sizeof(char *)))) {
            SHpGenReply(irp, -1, EINVAL);
            return(STATUS_SUCCESS);
    }
    if (inbuf->a_insert.i_fildes &&
        (inbuf->a_insert.i_fildes != INVALID_HANDLE_VALUE)) {
            iq = handle_to_queue(inbuf->a_insert.i_fildes);
    }
    if (!iq) {
        SHpGenReply(irp, -1, EINVAL);
        return(STATUS_SUCCESS);
    }
    inbuf->a_insert.i_targetq = iq;             // this is a union !!

    //
    // if no data part is to be sent, specify it unambiguously for
    // irptomp()'s sake,
    //
    if (dataptr->len == 0) {
        dataptr->len = -1;
    }

    spl_level  = lock_strm(ms->e_strm);

    if (shrange(ms->e_strm, ctrlptr->len, dataptr->len) < 0) {
        unlock_strm(ms->e_strm, spl_level);
        SHpGenReply(irp, -1, ERANGE);
        return(STATUS_SUCCESS);
    }

    /*
     * do_putmsg() has, or will arrange to, complete the IRP.
     */
    do_putmsg(irp, FALSE, &spl_level, NULL);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispFdInsert(ms = %lx) completed ok\n", ms));
    }
    return(STATUS_PENDING);

} // SHDispFdInsert




NTSTATUS
SHDispPutMsg(
    IN PIRP                 irp,
    IN PIO_STACK_LOCATION   irpsp
    )

/*++

Routine Description:

    This routine is called to put a message down a stream.  It is based on
    the SpiderStreams emulator's msgserver() routine.

    This routine merely peels open the IRP, checks the putmsg() arguments
    for consistency, locks the appropriate stream, and then calls
    do_putmsg(), which does the bulk of the work.

Arguments:

    irp       - pointer to the IRP representing this request
    irpsp     - pointer to the IRP stack location for this request

Return Value:

    An NT status code.  Whatever the return value, this function will arrange
    for the IRP to be completed.

--*/

{
    int spl_level;
    PSTREAM_ENDPOINT ms;
    PPUTMSG_ARGS_IN inbuf;
    struct strbuf *ctrlptr, *dataptr;

    ASSERT((irpsp->Parameters.DeviceIoControl.IoControlCode & 0x3) ==
                                                            METHOD_BUFFERED);
    ms = (STREAM_ENDPOINT *) irpsp->FileObject->FsContext;

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength <
                                                sizeof(PUTMSG_ARGS_IN) - 1) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: SHDispPutMsg(%lx) insufficient nbytes = %lx\n",
                    irp, irpsp->Parameters.DeviceIoControl.InputBufferLength));
        }
        shortreply(irp, STATUS_INVALID_PARAMETER, 0);
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // the caller marshalled the input arguments contiguously thus:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  0
    //      long            a_flags;            //  0 | RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      HANDLE          a_fildes;           //  -1
    //      int             a_offset;           //  0
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (optional)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    // When the message has no control part, the caller must have set
    // a_ctlbuf.len = -1 !!  Ditto for a_databuf.len.
    //
    //
    inbuf   = (PPUTMSG_ARGS_IN) irp->AssociatedIrp.SystemBuffer;
    ctrlptr = &(inbuf->a_ctlbuf);
    dataptr = &(inbuf->a_databuf);

    ASSERT(inbuf->a_insert.i_fildes == INVALID_HANDLE_VALUE);
    inbuf->a_insert.i_targetq = NULL;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispPutMsg(flags, clen, dlen = %d, %lx, %lx)\n",
                                inbuf->a_flags, ctrlptr->len, dataptr->len));
    }
    switch (inbuf->a_flags) {
    case 0:
        if ((ctrlptr->len < 0) && (dataptr->len < 0)) {
            SHpGenReply(irp, 0, 0);
            return(STATUS_SUCCESS);
        }
        break;

    case RS_HIPRI:
        if (ctrlptr->len >= 0) {
            break;
        }
        /* fall through */

    default:
        SHpGenReply(irp, -1, EINVAL);
        return(STATUS_SUCCESS);
    }
    spl_level  = lock_strm(ms->e_strm);

    /*
     * ms->e_wropt may be changed by ioctl(I_SWROPT).  However, the current
     * state of ms->e_wropt applies to this put operation.
     */
    if ((ctrlptr->len <= 0) &&
        (dataptr->len <= 0) &&
       !(ms->e_wropt & SNDZERO)) {

            unlock_strm(ms->e_strm, spl_level);
            SHpGenReply(irp, 0, 0);
            return(STATUS_SUCCESS);
    }

    if (shrange(ms->e_strm, ctrlptr->len, dataptr->len) < 0) {
        unlock_strm(ms->e_strm, spl_level);
        SHpGenReply(irp, -1, ERANGE);
        return(STATUS_SUCCESS);
    }

    /*
     * do_putmsg() has, or will arrange to, complete the IRP.
     */
    do_putmsg(irp, FALSE, &spl_level, NULL);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: SHDispPutMsg(ms = %lx) completed ok\n", ms));
    }
    return(STATUS_PENDING);

} // SHDispPutMsg




STATIC VOID
cancel_put(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    )

/*++

Routine Description:

    This routine is called when an put operation on a stream is cancelled.

    It must release the cancel spinlock before returning !!  The caller
    has already acquired the cancel spinlock.  ref: IoCancelIrp().

Arguments:

    device    - pointer to the device object
    irp       - pointer to the irp of this request

Return Value:

    none.

--*/

{
    int spl_level;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;
    PSTREAM_ENDPOINT ms;
    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(irp);

    ASSERT(device == (PDEVICE_OBJECT) StreamDevice);
    ASSERT(irpsp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    ASSERT(irpsp->Parameters.DeviceIoControl.IoControlCode ==
                                                        IOCTL_STREAMS_PUTMSG);
    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: cancel_put(irp = %lx) entered\n", irp));
    }
    IoSetCancelRoutine(irp, NULL);              /* unnecessary, but cheap */
    IoReleaseCancelSpinLock(irp->CancelIrql);

    ms        = (PSTREAM_ENDPOINT) irpsp->FileObject->FsContext;
    spl_level = lock_strm(ms->e_strm);

    for (tmp = ms->e_writers.Flink; tmp != &ms->e_writers; tmp = tmp->Flink) {

        item = CONTAINING_RECORD(tmp,
                                WAITING_IRP,
                                w_list);

        if (irp != item->w_irp) {
            continue;
        }
        RemoveEntryList(&(item->w_list));

        unlock_strm(ms->e_strm, spl_level);
        ExFreePool(item);

        shortreply(irp, STATUS_CANCELLED, 0);

        IF_STRMDBG(CALL) {
            STRMTRACE(("SHEAD: cancel_put(irp = %lx) cancelled ok\n", irp));
        }
        return;
    }
    unlock_strm(ms->e_strm, spl_level);

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: cancel_put(irp = %lx) not found\n", irp));
    }

} // cancel_put



STATIC NTSTATUS
do_putmsg(
    IN PIRP             irp,
    IN BOOLEAN          from_queue,
    IN int             *spl_levelp,
    OUT BOOLEAN        *pmore OPTIONAL
    )

/*++

Routine Description:

    This function is called to put a message down a stream.  It either
    completes the irp or chains it to ms->e_writers.   In any case,
    once this function is called, it will arrange for the IRP to be
    completed.

    Call this function with the stream locked !!!

    This function is based on the SpiderStreams emulator's function, do_req().

Arguments:

    irp             - pointer to the IRP representing this request
    from_queue      - TRUE if this is an IRP just unchained from ms->e_writers
    spl_levelp      - pointer to the interrupt priority level at which the
                        stream was locked
    pmore           - if not the stream is not flow-controlled when this
                        function returns, this will be TRUE.  Otherwise, it
                        will be set to false.

    *pmore is basically set to the value of !canput():

    This is to accommodate the logic in shwsrv(), the primary caller of this
    function.  shwsrv() is most interested in the state of stream's write
    queue: should it call this function again ?

Return Value:

    an NT status code.


--*/

{
    mblk_t *mp;
    queue_t *iq;
    NTSTATUS status;
    int MyErrno, flags;
    STREAM_ENDPOINT *ms;
    PPUTMSG_ARGS_IN inbuf;
    PIO_STACK_LOCATION irpsp;
    struct strbuf *ctrlptr, *dataptr;


    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: do_putmsg(irp = %lx) entered\n", irp));
    }
    irpsp = IoGetCurrentIrpStackLocation(irp);
    ms    = (STREAM_ENDPOINT *) irpsp->FileObject->FsContext;

    //
    // this was already verified by SHDispFdInsert() or SHDispPutMsg().
    //
    ASSERT(irpsp->Parameters.DeviceIoControl.InputBufferLength >=
                                                sizeof(PUTMSG_ARGS_IN) - 1);

    //
    // the caller marshalled the input arguments contiguously thus:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  I_FDINSERT or 0
    //      long            a_flags;            //  0 or RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      struct queue   *a_insert.i_targetq; //  (optional)
    //      int             a_offset;           //  (optional)
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (optional)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    // When the message has no control part, the caller must have set
    // ctrlbuf->len = -1 !!  Ditto for databuf->len.
    //
    inbuf   = (PPUTMSG_ARGS_IN) irp->AssociatedIrp.SystemBuffer;
    flags   = inbuf->a_flags;
    ctrlptr = &(inbuf->a_ctlbuf);
    dataptr = &(inbuf->a_databuf);

    IF_STRMDBG(VERBOSE) {
        STRMTRACE(("SHEAD: do_putmsg(flags, clen, dlen = %d, %lx, %lx)\n",
                                        flags, ctrlptr->len, dataptr->len));
    }

    if (pmore) {
        *pmore = TRUE;
    }

    if (ms->e_werror) {
        MyErrno = ms->e_werror;
    }
    else if (ms->e_linked) {
        MyErrno = EINVAL;
    }
    else {
        MyErrno = 0;
    }

    if (MyErrno) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: do_putmsg(%lx) error = %d\n", ms, MyErrno));
        }
        unlock_strm(ms->e_strm, *spl_levelp);

        SHpGenReply(irp, -1, MyErrno);
        return(STATUS_SUCCESS);
    }


    //
    // if downstream flow control is being exerted, enqueue this request in
    // the waiting list of writers.
    //
    // High-priority messages are not subject to flow control.
    //
    // check whether this stream is nonblocking !!!
    //
    //
    if ((flags != RS_HIPRI) &&
       (!IsListEmpty( &ms->e_writers ) && !from_queue) ||
         shblocked(ms->e_strm)) {

        IF_STRMDBG(VERBOSE) {
            STRMTRACE((
            "SHEAD: do_putmsg(irp = %lx) flow-ctrl, (!%x && !%x) || %x\n", irp,
            IsListEmpty( &ms->e_writers ), from_queue, shblocked(ms->e_strm)));
        }
        if (pmore) {
            *pmore = FALSE;
        }
        IoMarkIrpPending(irp);

        unlock_strm(ms->e_strm, *spl_levelp);

        IoAcquireCancelSpinLock(&irp->CancelIrql);

        if (irp->Cancel) {
            IoReleaseCancelSpinLock(irp->CancelIrql);
            shortreply(irp, STATUS_CANCELLED, 0);
            return(STATUS_CANCELLED);
        }

        *spl_levelp = lock_strm(ms->e_strm);

        status = SHAddPendingIrp(
                     &(ms->e_writers),
                     from_queue,
                     irp,
                     do_putmsg);

        unlock_strm(ms->e_strm, *spl_levelp);

        if (status != STATUS_SUCCESS) {
            IoReleaseCancelSpinLock(irp->CancelIrql);
            shortreply(irp, status, 0);
            return(status);
        }

        IoSetCancelRoutine(irp, cancel_put);
        IoReleaseCancelSpinLock(irp->CancelIrql);

        return(STATUS_PENDING);
    }

    mp = irptomp(irp, BPRI_LO, ctrlptr->len, dataptr->len, inbuf->a_stuff);

    if (!mp) {
        unlock_strm(ms->e_strm, *spl_levelp);
        shortreply(irp, STATUS_NO_MEMORY, 0);
        return(STATUS_NO_MEMORY);
    }

    //
    // Both SHDispFdInsert() and SHDispPutMsg() verified that if RS_HIPRI
    // was set, a control part exists.
    //
    if (flags == RS_HIPRI) {
        ASSERT(mp->b_datap->db_type == M_PROTO);
        mp->b_datap->db_type = M_PCPROTO;
    }

    //
    // The stream of a_insert.i_targetq should be locked in
    // SHDispFdInsert(), and unlocked after the shput() ?
    //
    if (inbuf->a_insert.i_targetq) {

        iq = inbuf->a_insert.i_targetq;

        //
        // Spider's do_req() has the line below before the while loop:
        //
        //      iq = WR(iq);
        //
        // This is incorrect because:
        //
        // a) iq already points to the write queue,
        // b) it causes iq to be traversed upstream, instead of downstream.
        //
        while (iq->q_next) {
            iq = iq->q_next;
        }
        * ((queue_t **) (mp->b_rptr + inbuf->a_offset)) = RD(iq);
    }

    //
    // since irptomp() made a copy, we can complete the putmsg() now.
    //
    SHpGenReply(irp, 0, 0);

    //
    // shput() does the unlock_strm(ms->e_strm) for us.
    //
    shput(ms->e_strm, mp, 0, spl_levelp);


    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: do_putmsg(irp = %lx) completed ok\n", irp));
    }
    return(STATUS_SUCCESS);

} // do_putmsg



STATIC queue_t *
handle_to_queue (
    IN HANDLE   handle
    )

/*++

Routine Description:

    This routine returns a pointer to a queue structure, given the NT handle
    of its stream.  It is based on the SpiderStreams Emulator function,
    fd_to_queue().

    Do not call this function at DISPATCH_LEVEL !!  ObReferenceObjectByHandle()
    must be called from either LOW_LEVEL or APC_LEVEL.

Arguments:

    handle  -  handle relevant only in the current process' context

Return Value:

    pointer to the queue structure associated with that handle


--*/

{
    NTSTATUS status;
    STREAM_ENDPOINT *ms;
    PFILE_OBJECT pfileobj;

    IF_STRMDBG(CALL) {
        STRMTRACE(("SHEAD: handle_to_queue(%lx) \n", handle));
    }
    status = ObReferenceObjectByHandle(
                    handle,                 // Handle
                    FILE_READ_DATA,         // DesiredAccess
                   *IoFileObjectType,       // ObjectType
                    KernelMode,             // AccessMode
                    (PVOID *) &pfileobj,    // *object
                    NULL                    // HandleInformation
                    );

    if (!NT_SUCCESS(status) ||
        !((STREAM_ENDPOINT *) pfileobj->FsContext) ||
        !((STREAM_ENDPOINT *) pfileobj->FsContext)->e_strm) {
            return((queue_t *) NULL);
    }
    ms = (STREAM_ENDPOINT *) pfileobj->FsContext;
    ObDereferenceObject(pfileobj);

    return(ms->e_strm->str_sq->q_next);

} // handle_to_queue



void
shwsrv(
    IN struct msg_strm *ms
    )

/*++

Routine Description:

    This function is called from two places: from the Stream Head's write
    service procedure, headwsrv(), and when the Stream Head driver's
    bufcall() and esbbcall() are triggered.

    It is based on the SpiderStreams function of the same name.

Arguments:

    ms  -  pointer to the stream endpoint

Return Value:

    none.


--*/

{
    PIRP irp;
    int spl_level;
    BOOLEAN carryon;
    PLIST_ENTRY tmp;
    PWAITING_IRP item;
    START_FUNCTION function;
    PTPI_OBJECT ObjectPtr;
    PTPI_CONNECTION_OBJECT ConnectionPtr;

    //
    // ensure that the stream has not gone away.
    //
    if ( !(ms->e_strm) ) {
        IF_STRMDBG(TERSE) {
            STRMTRACE(("SHEAD: shwsrv(%lx) called on null stream\n", ms));
        }
        return;
    }
    spl_level = lock_strm(ms->e_strm);

    //
    // handle anyone waiting to put a message down this stream.
    //
    while (!IsListEmpty( &(ms->e_writers) )) {

        tmp  = RemoveHeadList( &(ms->e_writers) );
        item = CONTAINING_RECORD(tmp,
                                    WAITING_IRP,
                                    w_list);

        irp      = item->w_irp;
        function = item->w_function;
        ExFreePool(item);

        carryon = TRUE;

        (void) (*function)(irp, TRUE, &spl_level, &carryon);

        if (!carryon) {
           return;
        }
        spl_level = lock_strm(ms->e_strm);
    }

    if (ms->e_strm_flags & POLLOUT) {
        ms->e_strm_flags &= ~POLLOUT;

        KeReleaseSemaphore(
            &Poll_fired,                    // semaphore
            SEMAPHORE_INCREMENT,            // priority increment
            1,                              // adjustment
            FALSE                           // wait
        );
    }

    //
    // If this is a TdiStream and it has become unblocked, I need to do a
    // SEND_POSSIBLE indication to the user.
    //

    if ((ObjectPtr = ms->TdiStreamPtr) &&
        (ObjectPtr->Tag == TPI_CONNECTION_OBJECT_TYPE)) {

        ConnectionPtr = &ObjectPtr->Object.TpiConnection;

        //
        // The Blocked flag is always accessed under the StreamLock
        //

        if (ConnectionPtr->Blocked) {
            ConnectionPtr->Blocked = FALSE;
            SHTdiEventSendPossible(ObjectPtr);
        }
    }

    unlock_strm(ms->e_strm, spl_level);

} // shwsrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\s_ioctl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_ioctl.c

Abstract:

    This module implements the s_ioctl() operation used by the
    socket library.

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror
--*/
#include "common.h"



//
// BUGBUG: Remove this structure when eric implements
//         neither I/O. Right now, it is needed because sockets allocates
//         the space for this structure in an ioctl call.
//

/*
 *  IOCTL structure - this structure is the format of the M_IOCTL message type.
 */
struct iocblk {
        int             ioc_cmd;        /* ioctl command type */
        unsigned short  ioc_uid;        /* effective uid of user */
        unsigned short  ioc_gid;        /* effective gid of user */
        unsigned int    ioc_id;         /* ioctl id */
        unsigned int    ioc_count;      /* count of bytes in data field */
        int             ioc_error;      /* error code */
        int             ioc_rval;       /* return value  */
};


//
// BUGBUG:
// The max amount of data that any module in the stream can return in an
// M_IOCACK message should probably be queried from the Stream Head driver.
//
#define         MAX_DATA_AMOUNT     0x1000




//
// Declaration of Local Functions
//
static int
s_debug(
    IN HANDLE               fd,
    IN OUT struct strdebug *dbgbufp
    );

static int
s_fdinsert(
    IN HANDLE               fd,
    IN struct strfdinsert  *iblk
    );

static int
s_link(
    IN HANDLE               fd,
    IN HANDLE               fd2
    );

static int
s_push(
    IN HANDLE               fd,
    IN char                *name
    );

static int
s_sioctl(
    IN HANDLE               fd,
    IN OUT struct strioctl *iocp
    );

static int
s_unlink(
    IN HANDLE   fd,
    IN int      muxid
    );






int
s_ioctl(
    IN HANDLE               fd,
    IN int                  cmd,
    IN OUT void            *arg OPTIONAL
    )

/*++

Routine Description:

    This procedure is called to perform a STREAMS ioctl() on a stream
    as defined in streamio(7) of the Unix Programmer's Guide: STREAMS.

Arguments:

    fd        - NT file handle
    command   - ioctl command code
    arg       - command-dependent arg, usually a pointer to some structure

Return Value:

    0 if successful, -1 otherwise.

--*/
{
    switch (cmd) {
        case I_STR:
            return(s_sioctl(fd, (struct strioctl *) arg));

        case I_DEBUG:
            return(s_debug(fd, (struct strdebug *) arg));

        case I_FDINSERT:
            return(s_fdinsert(fd, (struct strfdinsert *) arg));

        case I_PUSH:
            return(s_push(fd, (char *) arg));

        case I_LINK:
            return(s_link(fd, (HANDLE) arg));

        case I_UNLINK:
            return(s_unlink(fd, (int) ((ULONG_PTR)arg)));

        default:
            SetLastError(EINVAL);
            return(-1);
    }
}



static int
s_debug(
    IN HANDLE               fd,
    IN OUT struct strdebug *dbgbufp
    )

/*++

Routine Description:

    This procedure performs an I_DEBUG ioctl command on a stream.

Arguments:

    fd        - NT file handle
    dbgbufp   - pointer to a strdebug structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    char *tmp;
    char *chunk;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    if (dbgbufp == NULL) {
        SetLastError(EINVAL);
        return(-1);
    }
    chunksz = sizeof(int) + sizeof(struct strdebug);

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int               s_code;   // I_DEBUG
    //              struct strdebug   dbgbuf;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    * ((int *) chunk) = I_DEBUG;
    tmp               = chunk + sizeof(int);

    memcpy(tmp, dbgbufp, sizeof(struct strdebug));

    status = NtDeviceIoControlFile(
        fd,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        LocalFree((HANDLE) chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      int return value        (required)
    //      int errno;              (required)
    //
    retval = * (int *) chunk;

    if (retval == -1) {
        SetLastError(* (int *) (chunk + sizeof(int)));
    }
    LocalFree((HANDLE) chunk);
    return(retval);
}



int
s_fdinsert(
    IN HANDLE               fd,
    IN struct strfdinsert  *iblk
    )

/*++

Routine Description:

    This function performs an ioctl(I_FDINSERT) on a stream, which is a
    special form of putmsg().

    This function is synchronous, in the NT sense: it blocks until the API
    completes.

Arguments:

    fd        - NT file handle
    iblk      - pointer to a strfdinsert structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    char *tmp;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;
    PSTRM_ARGS_OUT oparm;
    PPUTMSG_ARGS_IN chunk;

    if (!iblk) {
        SetLastError(EINVAL);
        return(-1);
    }
    if (iblk->ctlbuf.len <= 0) {
        SetLastError(ERANGE);
        return(-1);
    }

    //
    // iblk->databuf.len may be -1, to indicate no data buffer.
    //
    chunksz = sizeof(PUTMSG_ARGS_IN) - 1 +
                        iblk->ctlbuf.len + max(iblk->databuf.len, 0);

    if (!(chunk = (PPUTMSG_ARGS_IN) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk.  However, for
    // commonality with putmsg(), we rearrange the strfdinsert structure
    // as below:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  I_FDINSERT
    //      long            a_flags;            //  0 | RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      HANDLE          a_insert.i_fildes;  //  (required)
    //      int             a_offset;           //  (optional)
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (required)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    //
    chunk->a_iocode          = I_FDINSERT;
    chunk->a_flags           = iblk->flags;
    chunk->a_ctlbuf          = iblk->ctlbuf;    // structure copy
    chunk->a_databuf         = iblk->databuf;   // structure copy
    chunk->a_insert.i_fildes = iblk->fildes;
    chunk->a_offset          = iblk->offset;

    tmp = (char *) chunk->a_stuff;

    assert(iblk->ctlbuf.len > 0);
    memcpy(tmp, iblk->ctlbuf.buf, iblk->ctlbuf.len);
    tmp += iblk->ctlbuf.len;

    if (iblk->databuf.len > 0) {
        memcpy(tmp, iblk->databuf.buf, iblk->databuf.len);
    }

    ASSERT(chunksz >= sizeof(STRM_ARGS_OUT));

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (!NT_SUCCESS(status)) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the return parameters from the Stream Head Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    //
    oparm  = (PSTRM_ARGS_OUT) chunk;
    retval = oparm->a_retval;

    if (retval == -1) {
        SetLastError(oparm->a_errno);
    }
    LocalFree(chunk);
    return(retval);

} // s_fdinsert



static int
s_link(
    IN HANDLE               fd,
    IN HANDLE               fd2
    )

/*++

Routine Description:

    This procedure performs an I_LINK ioctl command on a stream.

Arguments:

    fd        - NT file handle to upstream driver
    fd2       - NT file handle to downstream driver

Return Value:

    multiplexor id number, or -1 if unsuccessful

--*/
{
    char *chunk;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    chunksz = sizeof(int) + sizeof(HANDLE);

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_LINK
    //
    //              union {
    //                  HANDLE l_fd2;
    //              } s_link;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    * ((int *) chunk)               = I_LINK;
    * (PHANDLE) ((int *) chunk + 1) = fd2;

    status = NtDeviceIoControlFile(
        fd,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        LocalFree((HANDLE) chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_LINK
    //
    //              union {
    //                  HANDLE l_fd2;
    //              } s_link;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    if ((retval = * (int *) chunk) == -1) {
        SetLastError(* (int *) (chunk + sizeof(int)));
    }
    LocalFree((HANDLE) chunk);
    return(retval);
}



static int
s_push(
    IN HANDLE               fd,
    IN char                *name
    )

/*++

Routine Description:

    This procedure performs an I_LINK ioctl command on a stream.

Arguments:

    fd        - NT file handle to stream
    name      - name of STREAMS module to be pushed

Return Value:

    0 if successful, -1 otherwise

--*/
{
    char *chunk;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    chunksz = (int)(max(2 * sizeof(int), sizeof(int) + strlen(name) + 1));

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_PUSH
    //
    //              union {
    //                  char p_name[1];
    //              } s_push;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    * ((int *) chunk) = I_PUSH;
    strcpy(chunk + sizeof(int), name);

    status = NtDeviceIoControlFile(
        fd,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        LocalFree((HANDLE) chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_LINK
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    if ((retval = * (int *) chunk) == -1) {
        SetLastError(* (int *) (chunk + sizeof(int)));
    }
    LocalFree((HANDLE) chunk);
    return(retval);
}



static int
s_sioctl(
    IN HANDLE               fd,
    IN OUT struct strioctl *iocp
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;
    PISTR_ARGS_INOUT chunk;

    union outparms {
        ISTR_ARGS_INOUT    o_ok;
        STRM_ARGS_OUT      o_bad;
    } *oparm;

    if (!iocp || (iocp->ic_len < 0)) {
        SetLastError(EINVAL);
        return(-1);
    }
    chunksz = sizeof(ISTR_ARGS_INOUT) + max(iocp->ic_len, MAX_DATA_AMOUNT);
    chunk   = (PISTR_ARGS_INOUT) LocalAlloc(LMEM_FIXED, chunksz);

    if (!chunk) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //  typedef struct _ISTR_ARGS_INOUT {           // ioctl(I_STR)
    //      int                 a_iocode;           //  I_STR
    //      struct strioctl     a_strio;            //  (required)
    //      int                 a_unused[2];        //  (required) BUGBUG
    //      char                a_stuff[1];         //  (optional)
    //
    //  } ISTR_ARGS_INOUT, *PISTR_ARGS_INOUT;
    //
    //
    // An optimizing compiler will warn that the assertion below contains
    // unreachable code.  Ignore the warning.
    //
    assert((char *) chunk->a_stuff - (char *) &(chunk->a_strio) >=
                                                        sizeof(struct iocblk));

    chunk->a_iocode = I_STR;
    memcpy(&(chunk->a_strio), iocp, sizeof(struct strioctl));

    if (iocp->ic_len >= 0) {
        memcpy(&(chunk->a_stuff), iocp->ic_dp, iocp->ic_len);
    }

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize


    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (!NT_SUCCESS(status)) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // if there was an error, the return parameters from the Stream Head
    // Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    //
    oparm  = (union outparms *) chunk;
    retval = oparm->o_bad.a_retval;

    if (retval == -1) {
        SetLastError(oparm->o_bad.a_errno);
        LocalFree(chunk);
        return(retval);
    }

    //
    // if there wasn't an error, the return parameters from the Stream Head
    // Driver are laid out as:
    //
    //  typedef struct _ISTR_ARGS_INOUT {           // ioctl(I_STR)
    //      int                 a_iocode;           //  return value
    //      struct strioctl     a_strio;            //  (required)
    //      int                 a_unused[2];
    //      char                a_stuff[1];         //  (optional)
    //
    //  } ISTR_ARGS_INOUT, *PISTR_ARGS_INOUT;
    //
    // However, a_iocode now holds the return value.
    //
    //
    if (iocp && iocp->ic_dp) {
        iocp->ic_len = oparm->o_ok.a_strio.ic_len;

        if (iocp->ic_len >= 0) {
            memcpy(iocp->ic_dp, oparm->o_ok.a_stuff, iocp->ic_len);
        }
    }
    LocalFree(chunk);
    return(retval);

} // s_sioctl




static int
s_unlink(
    IN HANDLE   fd,
    IN int      muxid
    )

/*++

Routine Description:

    This procedure performs an I_UNLINK ioctl command on a stream.

Arguments:

    fd        - NT file handle to upstream driver
    muxid     - STREAMS multiplexor id of the lower stream

Return Value:

    0 on success, or -1 on failure

--*/
{
    int chunk[2];
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_UNLINK
    //
    //              union {
    //                  int l_muxid;
    //              } s_unlink;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    chunk[0] = I_UNLINK;
    chunk[1] = muxid;
    chunksz  = sizeof(chunk);

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_UNLINK
    //
    //              union {
    //                  HANDLE l_fd2;
    //              } s_link;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    if ((retval = chunk[0]) == -1) {
        SetLastError(chunk[1]);
    }
    return(retval);

} // s_unlink
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\w_perror.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    w_perror.c

Abstract:

    This module implements the WSA_perror() operation used by the
    p_error function. This is a temporary workaround for beta.
    This will be replaced by NLS support for the final product.

Author:

    John Ballard (jballard)           June 15, 1992

Revision History:

    Ronald Meijer (ronaldm) NLS Enabled         Nov 26, 1992

--*/

#include <stdio.h>
#include <winsock.h>

#include "nlstxt.h"

#define MAX_MSGTABLE 255

HMODULE hWinStrm = NULL;

int WSA_perror(
char *yourmsg,
int lerrno)
{
    WCHAR perrW[MAX_MSGTABLE+1];
    CHAR perr[MAX_MSGTABLE+1];
    unsigned msglen;
    unsigned usMsgNum;

    switch (lerrno) {
        case WSAENAMETOOLONG:
            usMsgNum = IDS_WSAENAMETOOLONG;
            break;
        case WSASYSNOTREADY:
            usMsgNum = IDS_WSASYSNOTREADY;
            break;
        case WSAVERNOTSUPPORTED:
            usMsgNum = IDS_WSAVERNOTSUPPORTED;
            break;
        case WSAESHUTDOWN:
            usMsgNum = IDS_WSAESHUTDOWN;
            break;
        case WSAEINTR:
            usMsgNum = IDS_WSAEINTR;
            break;
        case WSAHOST_NOT_FOUND:
            usMsgNum = IDS_WSAHOST_NOT_FOUND;
            break;
        case WSATRY_AGAIN:
            usMsgNum = IDS_WSATRY_AGAIN;
            break;
        case WSANO_RECOVERY:
            usMsgNum = IDS_WSANO_RECOVERY;
            break;
        case WSANO_DATA:
            usMsgNum = IDS_WSANO_DATA;
            break;
        case WSAEBADF:
            usMsgNum = IDS_WSAEBADF;
            break;
        case WSAEWOULDBLOCK:
            usMsgNum = IDS_WSAEWOULDBLOCK;
            break;
        case WSAEINPROGRESS:
            usMsgNum = IDS_WSAEINPROGRESS;
            break;
        case WSAEALREADY:
            usMsgNum = IDS_WSAEALREADY;
            break;
        case WSAEFAULT:
            usMsgNum = IDS_WSAEFAULT;
            break;
        case WSAEDESTADDRREQ:
            usMsgNum = IDS_WSAEDESTADDRREQ;
            break;
        case WSAEMSGSIZE:
            usMsgNum = IDS_WSAEMSGSIZE;
            break;
        case WSAEPFNOSUPPORT:
            usMsgNum = IDS_WSAEPFNOSUPPORT;
            break;
        case WSAENOTEMPTY:
            usMsgNum = IDS_WSAENOTEMPTY;
            break;
        case WSAEPROCLIM:
            usMsgNum = IDS_WSAEPROCLIM;
            break;
        case WSAEUSERS:
            usMsgNum = IDS_WSAEUSERS;
            break;
        case WSAEDQUOT:
            usMsgNum = IDS_WSAEDQUOT;
            break;
        case WSAESTALE:
            usMsgNum = IDS_WSAESTALE;
            break;
        case WSAEINVAL:
            usMsgNum = IDS_WSAEINVAL;
            break;
        case WSAEMFILE:
            usMsgNum = IDS_WSAEMFILE;
            break;
        case WSAELOOP:
            usMsgNum = IDS_WSAELOOP;
            break;
        case WSAEREMOTE:
            usMsgNum = IDS_WSAEREMOTE;
            break;
        case WSAENOTSOCK:
            usMsgNum = IDS_WSAENOTSOCK;
            break;
        case WSAEADDRNOTAVAIL:
            usMsgNum = IDS_WSAEADDRNOTAVAIL;
            break;
        case WSAEADDRINUSE:
            usMsgNum = IDS_WSAEADDRINUSE;
            break;
        case WSAEAFNOSUPPORT:
            usMsgNum = IDS_WSAEAFNOSUPPORT;
            break;
        case WSAESOCKTNOSUPPORT:
            usMsgNum = IDS_WSAESOCKTNOSUPPORT;
            break;
        case WSAEPROTONOSUPPORT:
            usMsgNum = IDS_WSAEPROTONOSUPPORT;
            break;
        case WSAENOBUFS:
            usMsgNum = IDS_WSAENOBUFS;
            break;
        case WSAETIMEDOUT:
            usMsgNum = IDS_WSAETIMEDOUT;
            break;
        case WSAEISCONN:
            usMsgNum = IDS_WSAEISCONN;
            break;
        case WSAENOTCONN:
            usMsgNum = IDS_WSAENOTCONN;
            break;
        case WSAENOPROTOOPT:
            usMsgNum = IDS_WSAENOPROTOOPT;
            break;
        case WSAECONNRESET:
            usMsgNum = IDS_WSAECONNRESET;
            break;
        case WSAECONNABORTED:
            usMsgNum = IDS_WSAECONNABORTED;
            break;
        case WSAENETDOWN:
            usMsgNum = IDS_WSAENETDOWN;
            break;
        case WSAENETRESET:
            usMsgNum = IDS_WSAENETRESET;
            break;
        case WSAECONNREFUSED:
            usMsgNum = IDS_WSAECONNREFUSED;
            break;
        case WSAEHOSTDOWN:
            usMsgNum = IDS_WSAEHOSTDOWN;
            break;
        case WSAEHOSTUNREACH:
            usMsgNum = IDS_WSAEHOSTUNREACH;
            break;
        case WSAEPROTOTYPE:
            usMsgNum = IDS_WSAEPROTOTYPE;
            break;
        case WSAEOPNOTSUPP:
            usMsgNum = IDS_WSAEOPNOTSUPP;
            break;
        case WSAENETUNREACH:
            usMsgNum = IDS_WSAENETUNREACH;
            break;
        case WSAETOOMANYREFS:
            usMsgNum = IDS_WSAETOOMANYREFS;
            break;
        default:
            return(0);
    }

    if (hWinStrm == NULL)
	hWinStrm = GetModuleHandle( "winstrm" );

    if (!(msglen = FormatMessageW(
		       FORMAT_MESSAGE_FROM_HMODULE,
		       (LPVOID)hWinStrm,
		       usMsgNum,
		       0L,
		       perrW,
		       MAX_MSGTABLE,
		       NULL)))
        return(0);

    WideCharToMultiByte(CP_OEMCP,
                        0,
                        perrW,
                        -1,
                        perr,
                        sizeof(perr),
                        NULL,
                        NULL);
    
    fprintf(stderr, "-> %s:%s\n", yourmsg, perr);
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\s_perror.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    s_perror.c

Abstract:

    This module implements the s_perror() operation used by the
    tcp/ip utilities. This is a temporary workaround for beta.
    This will be replaced by NLS support for the final product.

Author:

    John Ballard (jballard)           June 15, 1992

Revision History:

    Ronald Meijer (ronaldm) NLS Enabled 	Nov 26, 1992

--*/

#include <stdio.h>
#include <crt\errno.h>
#include <sock_err.h>

#include <winsock.h>
#include "nlstxt.h"
#define MAX_MSGTABLE 255

extern HMODULE hWinStrm;

extern int WSA_perror(
char *yourmsg,
int lerrno);

void
s_perror(
char *yourmsg,
int lerrno)
{
    WCHAR perrW[MAX_MSGTABLE+1];
    CHAR perr[MAX_MSGTABLE+1];
    unsigned msglen;
    unsigned usMsgNum;

    switch (lerrno) {
//        case EZERO:
//            perr = "Error 0";
//            break;
        case EPERM:
	    usMsgNum = IDS_EPERM ;
            break;
        case ENOENT:
	    usMsgNum = IDS_ENOENT ;
            break;
        case ESRCH:
	    usMsgNum = IDS_ESRCH ;
            break;
        case EINTR:
	    usMsgNum = IDS_EINTR ;
            break;
        case EIO:
	    usMsgNum = IDS_EIO ;
            break;
        case ENXIO:
	    usMsgNum = IDS_ENXIO ;
            break;
        case E2BIG:
	    usMsgNum = IDS_E2BIG ;
            break;
        case ENOEXEC:
	    usMsgNum = IDS_ENOEXEC ;
            break;
        case EBADF:
	    usMsgNum = IDS_EBADF ;
            break;
        case ECHILD:
	    usMsgNum = IDS_ECHILD ;
            break;
        case EAGAIN:
	    usMsgNum = IDS_EAGAIN ;
            break;
        case ENOMEM:
	    usMsgNum = IDS_ENOMEM ;
            break;
        case EACCES:
	    usMsgNum = IDS_EACCES ;
            break;
        case EFAULT:
	    usMsgNum = IDS_EFAULT ;
            break;
//        case ENOTBLK:
//	      perr = "Block device required";
//            break;
        case EBUSY:
	    usMsgNum = IDS_EBUSY ;
            break;
        case EEXIST:
	    usMsgNum = IDS_EEXIST ;
            break;
        case EXDEV:
	    usMsgNum = IDS_EXDEV ;
            break;
        case ENODEV:
	    usMsgNum = IDS_ENODEV ;
            break;
        case ENOTDIR:
	    usMsgNum = IDS_ENOTDIR ;
            break;
        case EISDIR:
	    usMsgNum = IDS_EISDIR ;
            break;
        case EINVAL:
	    usMsgNum = IDS_EINVAL ;
            break;
        case ENFILE:
	    usMsgNum = IDS_ENFILE ;
            break;
        case EMFILE:
	    usMsgNum = IDS_EMFILE ;
            break;
        case ENOTTY:
	    usMsgNum = IDS_EMFILE ;
            break;
//        case ETXTBSY:
//	      perr = "Text file busy";
//            break;
        case EFBIG:
	    usMsgNum = IDS_EFBIG ;
            break;
        case ENOSPC:
	    usMsgNum = IDS_ENOSPC ;
            break;
        case ESPIPE:
	    usMsgNum = IDS_ESPIPE ;
            break;
        case EROFS:
	    usMsgNum = IDS_EROFS ;
            break;
        case EMLINK:
	    usMsgNum = IDS_EMLINK ;
            break;
        case EPIPE:
	    usMsgNum = IDS_EPIPE ;
            break;
        case EDOM:
	    usMsgNum = IDS_EDOM ;
            break;
        case ERANGE:
	    usMsgNum = IDS_ERANGE ;
            break;
//        case EUCLEAN:
//	      perr = "File system not clean";
//            break;
        case EDEADLK:
	    usMsgNum = IDS_EDEADLK ;
            break;
        case ENOMSG:
	    usMsgNum = IDS_ENOMSG ;
            break;
        case EIDRM:
	    usMsgNum = IDS_EIDRM ;
            break;
        case ECHRNG:
	    usMsgNum = IDS_ECHRNG ;
            break;
        case EL2NSYNC:
	    usMsgNum = IDS_EL2NSYNC ;
            break;
        case EL3HLT:
	    usMsgNum = IDS_EL3HLT ;
            break;
        case EL3RST:
	    usMsgNum = IDS_EL3RST ;
            break;
        case ELNRNG:
	    usMsgNum = IDS_ELNRNG ;
            break;
        case EUNATCH:
	    usMsgNum = IDS_EUNATCH ;
            break;
        case ENOCSI:
	    usMsgNum = IDS_ENOCSI ;
            break;
        case EL2HLT:
	    usMsgNum = IDS_EL2HLT ;
            break;
        case EBADE:
	    usMsgNum = IDS_EBADE ;
            break;
        case EBADR:
	    usMsgNum = IDS_EBADR ;
            break;
        case EXFULL:
	    usMsgNum = IDS_EXFULL ;
            break;
        case ENOANO:
	    usMsgNum = IDS_ENOANO ;
            break;
        case EBADRQC:
	    usMsgNum = IDS_EBADRQC ;
            break;
        case EBADSLT:
	    usMsgNum = IDS_EBADSLT ;
            break;
        case EBFONT:
	    usMsgNum = IDS_EBFONT ;
            break;
        case ENOSTR:
	    usMsgNum = IDS_ENOSTR ;
            break;
        case ENODATA:
	    usMsgNum = IDS_ENODATA ;
            break;
        case ETIME:
	    usMsgNum = IDS_ETIME ;
            break;
        case ENOSR:
	    usMsgNum = IDS_ENOSR ;
            break;
        case ENONET:
	    usMsgNum = IDS_ENONET ;
            break;
        case ENOPKG:
	    usMsgNum = IDS_ENOPKG ;
            break;
        case EREMOTE:
	    usMsgNum = IDS_EREMOTE ;
            break;
        case ENOLINK:
	    usMsgNum = IDS_ENOLINK ;
            break;
        case EADV:
	    usMsgNum = IDS_EADV ;
            break;
        case ESRMNT:
	    usMsgNum = IDS_ESRMNT ;
            break;
        case ECOMM:
	    usMsgNum = IDS_ECOMM ;
            break;
        case EPROTO:
	    usMsgNum = IDS_EPROTO ;
            break;
        case EMULTIHOP:
	    usMsgNum = IDS_EMULTIHOP ;
            break;
        case ELBIN:
	    usMsgNum = IDS_ELBIN ;
            break;
        case EDOTDOT:
	    usMsgNum = IDS_EDOTDOT ;
            break;
        case EBADMSG:
	    usMsgNum = IDS_EBADMSG ;
            break;
        case ENOTUNIQ:
	    usMsgNum = IDS_ENOTUNIQ ;
            break;
        case EREMCHG:
	    usMsgNum = IDS_EREMCHG ;
            break;
        case ELIBACC:
	    usMsgNum = IDS_ELIBACC;
            break;
        case ELIBBAD:
	    usMsgNum = IDS_ELIBBAD ;
            break;
        case ELIBSCN:
	    usMsgNum = IDS_ELIBSCN ;
            break;
        case ELIBMAX:
	    usMsgNum = IDS_ELIBMAX ;
            break;
        case ELIBEXEC:
	    usMsgNum = IDS_ELIBEXEC ;
            break;
        case ENOTSOCK:
	    usMsgNum = IDS_ENOTSOCK ;
            break;
        case EADDRNOTAVAIL:
	    usMsgNum = IDS_EADDRNOTAVAIL ;
            break;
        case EADDRINUSE:
	    usMsgNum = IDS_EADDRINUSE ;
            break;
        case EAFNOSUPPORT:
	    usMsgNum = IDS_EAFNOSUPPORT ;
            break;
        case ESOCKTNOSUPPORT:
	    usMsgNum = IDS_ESOCKTNOSUPPORT ;
            break;
        case EPROTONOSUPPORT:
	    usMsgNum = IDS_EPROTONOSUPPORT ;
            break;
        case ENOBUFS:
	    usMsgNum = IDS_ENOBUFS ;
            break;
        case ETIMEDOUT:
	    usMsgNum = IDS_ETIMEDOUT ;
            break;
        case EISCONN:
	    usMsgNum = IDS_EISCONN ;
            break;
        case ENOTCONN:
	    usMsgNum = IDS_ENOTCONN ;
            break;
        case ENOPROTOOPT:
	    usMsgNum = IDS_ENOPROTOOPT ;
            break;
        case ECONNRESET:
	    usMsgNum = IDS_ECONNRESET ;
            break;
        case ECONNABORT:
	    usMsgNum = IDS_ECONNABORT ;
            break;
        case ENETDOWN:
	    usMsgNum = IDS_ENETDOWN ;
            break;
        case ECONNREFUSED:
	    usMsgNum = IDS_ECONNREFUSED ;
            break;
        case EHOSTUNREACH:
	    usMsgNum = IDS_EHOSTUNREACH ;
            break;
        case EPROTOTYPE:
	    usMsgNum = IDS_EPROTOTYPE ;
            break;
        case EOPNOTSUPP:
	    usMsgNum = IDS_EOPNOTSUPP ;
            break;
        case ESUBNET:
	    usMsgNum = IDS_ESUBNET ;
            break;
        case ENETNOLNK:
	    usMsgNum = IDS_ENETNOLNK ;
            break;
        case EBADIOCTL:
	    usMsgNum = IDS_EBADIOCTL ;
            break;
        case ERESOURCE:
	    usMsgNum = IDS_ERESOURCE ;
            break;
        case EPROTUNR:
	    usMsgNum = IDS_EPROTUNR ;
            break;
        case EPORTUNR:
	    usMsgNum = IDS_EPORTUNR ;
            break;
        case ENETUNR:
	    usMsgNum = IDS_ENETUNR ;
            break;
        case EPACKET:
	    usMsgNum = IDS_EPACKET ;
            break;
        case ETYPEREG:
	    usMsgNum = IDS_ETYPEREG ;
            break;
        case ENOTINIT:
	    usMsgNum = IDS_ENOTINIT ;
            break;
        default:
            if (WSA_perror(yourmsg, lerrno)) {
                return;
            }
	    usMsgNum = IDS_UNKNOWN ;
            break;
    }

    if (hWinStrm == NULL)
	hWinStrm = GetModuleHandle( "winstrm" );

    if (!(msglen = FormatMessageW(
		       FORMAT_MESSAGE_FROM_HMODULE,
		       (LPVOID)hWinStrm,
		       usMsgNum,
		       0L,
		       perrW,
		       MAX_MSGTABLE,
		       NULL)))
	return;

    WideCharToMultiByte(CP_OEMCP,
                        0,
                        perrW,
                        -1,
                        perr,
                        sizeof(perr),
                        NULL,
                        NULL);

    fprintf(stderr, "> %s:%s\n", yourmsg, perr);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\s_poll.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_poll.c

Abstract:

    This module implements the STREAMS api, poll()

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror

--*/
#include "common.h"


/*
 * BUGBUG
 * Confirm that the following is a sane number.
 */
#define MAX_FDS             NPOLLFILE           /* max handles to poll */




int
poll(
    IN OUT struct pollfd   *fds     OPTIONAL,
    IN unsigned int         nfds,
    IN int                  timeout
    )

/*++

Routine Description:

    This procedure is called to poll a set of stream descriptors.

Arguments:

    fds       - pointer to a array of poll structures
    nfds      - number of poll structures pointed to by fds
    timeout   - 0, INFTIM (-1), or timeout in milliseconds.

Return Value:

    no of stream descriptors selected, or -1 if failure.

--*/

{
    char *chunk;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    int chunksz, selected;
    struct pollfd *overlay;
    HANDLE hijack = INVALID_HANDLE_VALUE;

    if (!fds || (nfds <= 0) || (nfds > MAX_FDS)) {
        SetLastError(EINVAL);
        return(-1);
    }

    /*
     * hijack a handle to the Stream Head driver.
     *
     * BUGBUG:
     * In Unix, the user can set pollfd.fd to less than 0 to indicate that
     * the entry should be ignored.  On NT, that isn't possible:
     * INVALID_HANDLE_VALUE must be used.
     */
    for (overlay = fds; overlay < &fds[nfds]; overlay++) {
        if (overlay->fd != INVALID_HANDLE_VALUE) {
            hijack = overlay->fd;
            break;
        }
    }
    if (hijack == INVALID_HANDLE_VALUE) {
        SetLastError(EINVAL);
        return(-1);
    }

    chunksz = sizeof(nfds) + nfds * sizeof(*fds) + sizeof(timeout);

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(EAGAIN);
        return(-1);
    }

    /*
     * marshall the arguments into one contiguous chunk, laid out as:
     *
     *      nfds                    (required)
     *      timeout                 (required)
     *      struct fds[nfds]        (required)
     */
    * ((size_t *) chunk)             = nfds;
    * (int *) (chunk + sizeof(nfds)) = timeout;
    overlay                          = (struct pollfd *) (chunk +
                                            sizeof(nfds) + sizeof(timeout));

    memcpy(overlay, fds, nfds * sizeof(*fds));

    status = NtDeviceIoControlFile(
        hijack,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_POLL,                     // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            hijack,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        SetLastError(MapNtToPosixStatus(status));
        LocalFree((HANDLE) chunk);
        return(-1);
    }

    /*
     * the Stream Head Driver marshalled the return parameters into one
     * contiguous chunk, laid out as:
     *
     *      return value            (required)
     *      errno                   (required)
     *      struct fds[nfds]        (required)
     */
    if ((selected = * (int *) chunk) == -1) {
        SetLastError(* (int *) (chunk + sizeof(nfds)));
        LocalFree((HANDLE) chunk);
        return(selected);
    }
    overlay = (struct pollfd *) (chunk + sizeof(nfds) + sizeof(timeout));

    while (nfds--) {
        fds[nfds].revents = overlay[nfds].revents;
    }
    LocalFree((HANDLE) chunk);
    return(selected);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\streams\winstrm\s_putmsg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_putmsg.c

Abstract:

    This module implements the STREAMS APIs, ioctl(I_FDINSERT) and
    putmsg().

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror

--*/
#include "common.h"


int
putmsg(
    IN HANDLE           fd,
    IN struct strbuf   *ctrlptr OPTIONAL,
    IN struct strbuf   *dataptr OPTIONAL,
    IN int              flags
    )

/*++

Routine Description:

    This function is called to send a STREAMS message downstream.

    This function is synchronous, in the NT sense: it blocks until the API
    completes.

Arguments:

    fd        - NT file handle
    ctrlptr   - pointer to the control portion of the STREAMS message
    dataptr   - pointer to the data portion of the STREAMS message
    flags     - 0 or RS_HIPRI

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    char *tmp;
    int chunksz;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    PSTRM_ARGS_OUT oparm;
    PPUTMSG_ARGS_IN chunk;
    int retval;


    //
    // marshall the arguments into one contiguous chunk.  However, for
    // commonality with ioctl(I_FDINSERT), we arrange the input arguments
    // as below:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  0
    //      long            a_flags;            //  0 | RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      HANDLE          a_insert.i_fildes;  //  -1
    //      int             a_offset;           //  0
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (optional)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    //
    chunksz = sizeof(PUTMSG_ARGS_IN) - 1 +
                ((ctrlptr && (ctrlptr->len > 0)) ? ctrlptr->len : 0) +
                ((dataptr && (dataptr->len > 0)) ? dataptr->len : 0);

    if (!(chunk = (PPUTMSG_ARGS_IN) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }
    chunk->a_iocode = 0;
    chunk->a_flags  = (long) flags;

    tmp = (char *) chunk->a_stuff;

    if (ctrlptr && ctrlptr->buf && (ctrlptr->len >= 0)) {
        chunk->a_ctlbuf = *ctrlptr;                         // structure copy

        memcpy(tmp, ctrlptr->buf, ctrlptr->len);
        tmp += ctrlptr->len;
    }
    else {
        chunk->a_ctlbuf.len = -1;
    }

    if (dataptr && dataptr->buf && (dataptr->len >= 0)) {
        chunk->a_databuf = *dataptr;                        // structure copy

        memcpy(tmp, dataptr->buf, dataptr->len);
        tmp += dataptr->len;
    }
    else {
        chunk->a_databuf.len = -1;
    }
    chunk->a_insert.i_fildes = INVALID_HANDLE_VALUE;
    chunk->a_offset          = 0;

    ASSERT(chunksz >= sizeof(STRM_ARGS_OUT));

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_PUTMSG,                   // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (!NT_SUCCESS(status)) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the return parameters from the Stream Head Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    oparm  = (PSTRM_ARGS_OUT) chunk;

    if (oparm->a_retval == -1) {
        SetLastError(oparm->a_errno);
    }
    retval = oparm->a_retval;
    LocalFree(chunk);
    return(retval);

} // putmsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\admin\dll\tsec.h ===
#include <windows.h>
#include "tapiclnt.h"

#define SZTELEPHONYKEY          L"\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony"

#define SZINIFILE               L"..\\TAPI\\TSEC.INI"
#define SZLINES                 L"LINES"
#define SZPHONES                L"PHONES"
#define SZEMPTYSTRING           L""
#define MAXDEVICESTRINGLEN      1000
#define TSECCLIENT_KEY          ((DWORD) 'ilCT')


typedef struct _MYCLIENT
{
    DWORD                   dwKey;
    LPWSTR                  pszUserName;
    LPWSTR                  pszDomainName;
    LPTAPIPERMANENTID       pLineDeviceMap;
    DWORD                   dwNumLines;
    LPTAPIPERMANENTID       pPhoneDeviceMap;
    DWORD                   dwNumPhones;
    HTAPICLIENT             htClient;
    LIST_ENTRY              ListEntry;

} MYCLIENT, * PMYCLIENT;



#if DBG
DWORD gdwDebugLevel = 0;
#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
       IN DWORD  dwDbgLevel,
       IN PUCHAR DbgMessage,
       IN ...
      );

#else
#define DBGOUT(arg)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\admin\setup\admin.c ===
#include <windows.h>
#include <stdio.h>
#include <lm.h>
#include "resource.h"
#include <tapi.h>

#if MEMPHIS
#else
#include "ntsecapi.h"
#endif

HINSTANCE       ghInstance;
HWND            ghWnd;
BOOLEAN         gfQuietMode = FALSE;
DWORD           gdwNoDSQuery = 0;
DWORD           gdwConnectionOrientedOnly = 0;


#if MEMPHIS
#else
const TCHAR gszProductType[] = TEXT("ProductType");
const TCHAR gszProductTypeServer[] = TEXT("ServerNT");
const TCHAR gszProductTypeLanmanNt[] = TEXT("LANMANNT");
const TCHAR gszRegKeyNTServer[] = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");
#endif


const TCHAR gszRegKeyProviders[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers");
const TCHAR gszRegKeyTelephony[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");
const TCHAR gszProviderID[] = TEXT("ProviderID");
const TCHAR gszNumProviders[] = TEXT("NumProviders");
const TCHAR gszNextProviderID[] = TEXT("NextProviderID");
const TCHAR gszProviderFilename[] = TEXT("ProviderFilename");
const TCHAR gszRemoteSP[] = TEXT("RemoteSP.TSP");
const TCHAR gszProvider[] = TEXT("Provider");
const TCHAR gszServer[] = TEXT("Server");
const TCHAR gszNumServers[] = TEXT("NumServers");
const TCHAR gszConnectionOrientedOnly[] = TEXT("ConnectionOrientedOnly");
const TCHAR gszNoDSQuery[] = TEXT("NoDSQuery");

#define MAXERRORTEXTLEN         512

TCHAR gszTapiAdminSetup[MAXERRORTEXTLEN];

LPTSTR glpszFullName = NULL;
LPTSTR glpszPassword= NULL;
LPTSTR glpszMapper = NULL;
LPTSTR glpszDllList = NULL;
LPTSTR glpszRemoteServer = NULL;

BOOL
CALLBACK
DlgProc(
        HWND hwndDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam 
       );

#if MEMPHIS
#else
BOOL
IsAdministrator(
               );

BOOL
DoServer(
         LPTSTR lpszServerLine
        );
#endif


BOOL
DoClient(
         LPTSTR lpszClientLine
        );


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
UINT TAPIstrlen( const TCHAR *p )
{
    UINT nLength = 0;
    
    while ( *p )
    {
        nLength++;
        p++;
    }
    
    return nLength;
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
void TAPIstrcat( TCHAR *p1,  const TCHAR *p2 )
{
    while ( *p1 )
    {
        p1++;
    }
    
    while ( *p2 )
    {
        *p1 = *p2;
        p1++;
        p2++;
    }
    
    return;
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
void
ErrorStr(
         int iMsg
        )
{
    TCHAR       szError[MAXERRORTEXTLEN];

    
    if ( !gfQuietMode )
    {
        if (LoadString(
                       ghInstance,
                       iMsg,
                       szError,
                       MAXERRORTEXTLEN
                      ))
        {
        
            MessageBox(
                       NULL,
                       szError,
                       gszTapiAdminSetup,
                       MB_OK
                      );
        }
    }
    
}

void
ShowHelp()
{
    TCHAR           szError[MAXERRORTEXTLEN];
    LPTSTR          szBuffer;

    if (gfQuietMode)
    {
        return;
    }
    
    szBuffer = (LPTSTR)GlobalAlloc(
                                   GPTR,
                                   11 * MAXERRORTEXTLEN * sizeof(TCHAR)
                                  );

    if (!szBuffer)
    {
        return;
    }

    LoadString(
                   ghInstance,
                   iszHelp0,
                   szBuffer,
                   MAXERRORTEXTLEN
                  );
                  
    if (LoadString(
                   ghInstance,
                   iszHelp1,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp2,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp3,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp4,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp5,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp6,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp7,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp8,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp9,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }

    if (LoadString(
                   ghInstance,
                   iszHelp10,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }

    LoadString(
               ghInstance,
               iszHelpTitle,
               szError,
               MAXERRORTEXTLEN
              );

    MessageBox(
               NULL,
               szBuffer,
               szError,
               MB_OK
              );

    GlobalFree (szBuffer);
}
               
LPTSTR
GetNextString(
              LPTSTR lpszIn
             )
{
    static LPTSTR      lpszLine;
    LPTSTR             lpszReturn = NULL;

    if (lpszIn)
        lpszLine = lpszIn;
    
    while (*lpszLine && (*lpszLine == L' ' || *lpszLine == L'\t'))
           lpszLine++;

    if (!*lpszLine)
        return NULL;

    lpszReturn = lpszLine;
    
    while (*lpszLine && (*lpszLine != L' ' && *lpszLine != L'\t'))
           lpszLine++;


    if (*lpszLine)
    {
        *lpszLine = '\0';
        lpszLine++;
    }

    return lpszReturn;
}


BOOL
ParseCommandLine(
                 LPTSTR lpszCommandLine
                )
{
    BOOL    bRet = FALSE;

    //
    //  Skip the first segment which is the executable itself
    //  it is either in double quotes or a string until a white
    //  space
    //
    
    if (*lpszCommandLine == TEXT('\"'))
    {
        ++lpszCommandLine;
        while (*lpszCommandLine &&
            *lpszCommandLine != TEXT('\"'))
        {
            ++lpszCommandLine;
        }
        if (*lpszCommandLine == TEXT('\"'))
        {
            ++lpszCommandLine;
        }
    }
    else
    {
        while (
            *lpszCommandLine  &&
            *lpszCommandLine != TEXT(' ') &&
            *lpszCommandLine != TEXT('\t') &&
            *lpszCommandLine != 0x0a &&
            *lpszCommandLine != 0x0d)
        {
            ++lpszCommandLine;
        }
    }

    while (*lpszCommandLine)
    {
        //
        //  Search for / or - as the start of option
        //
        while (*lpszCommandLine == TEXT(' ') ||
            *lpszCommandLine == TEXT('\t') ||
            *lpszCommandLine == 0x0a ||
            *lpszCommandLine == 0x0d)
        {
            lpszCommandLine++;
        }

        if (*lpszCommandLine != TEXT('/') &&
            *lpszCommandLine != TEXT('-'))
        {
            break;
        }
        ++lpszCommandLine;
        
        if ( (L'r' == *lpszCommandLine) ||
             (L'R' == *lpszCommandLine)
           )
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                gdwNoDSQuery = (DWORD) TRUE;
            }
            else
            {
                break;
            }
        }
        else if ( (L'q' == *lpszCommandLine) ||
            (L'Q' == *lpszCommandLine))
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                gfQuietMode = TRUE;
            }
            else
            {
                break;
            }
        }
        else if ((L'x' == *lpszCommandLine) ||
            (L'X' == *lpszCommandLine))
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                gdwConnectionOrientedOnly = 1;
            }
            else
            {
                break;
            }
        }
        else if ((L'c' == *lpszCommandLine) ||
            (L'C' == *lpszCommandLine))
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                bRet = DoClient(++lpszCommandLine);
            }
            break;
        }
        else
        {
            break;
        }
    }

    return bRet;
}


int WINAPI WinMain (HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     lpszCmdLine,
                    int       nCmdShow)
{
    LPTSTR lpszCommandLine;

    ghInstance = GetModuleHandle( NULL );

    LoadString(
               ghInstance,
               iszTapiAdminSetup,
               gszTapiAdminSetup,
               MAXERRORTEXTLEN
              );
    
#if MEMPHIS
#else
    if (!IsAdministrator())
    {
        ErrorStr(iszMustBeAdmin);

        return 1;
    }
#endif

    lpszCommandLine = GetCommandLine();

    if (!lpszCommandLine)
    {
        return 2;
    }

    if (!(ParseCommandLine(
                           lpszCommandLine
                          )))
    {
        ShowHelp();
    }

    return 0;
}



#if MEMPHIS
#else


BOOL
IsServer()
{
    HKEY    hKey;
    DWORD   dwDataSize;
    DWORD   dwDataType;
    TCHAR   szProductType[64];


    // check to see if this is running on NT Server
    // if so, enable the telephony server stuff
    if (ERROR_SUCCESS !=
        RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyNTServer,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                ))
    {
        return FALSE;
    }

    dwDataSize = 64;
    RegQueryValueEx(
                    hKey,
                    gszProductType,
                    0,
                    &dwDataType,
                    (LPBYTE) szProductType,
                    &dwDataSize
                   );

    RegCloseKey(
                hKey
               );

    if ((!lstrcmpi(
                  szProductType,
                  gszProductTypeServer
                 ))
        ||
        (!lstrcmpi(
                   szProductType,
                   gszProductTypeLanmanNt
                  )))
            
    {
        return TRUE;
    }

    ErrorStr(iszNotRunningServer);

    return FALSE;
}

////////////////////////////////////////////////////////////////////
//
//  Set the disableserver key to true
//
BOOL
DisableServer()
{
    HKEY        hKeyTelephony, hKey;
    DWORD       dw;

    if ((RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszRegKeyTelephony,
                      0,
                      KEY_ALL_ACCESS,
                      &hKeyTelephony
                     ) != ERROR_SUCCESS) ||
        
        (RegCreateKeyEx(
                        hKeyTelephony,
                        TEXT("Server"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS))
    {
        return FALSE;
    }
        
    
    dw=1;
    
    if (RegSetValueEx(
                      hKey,
                      TEXT("DisableSharing"),
                      0,
                      REG_DWORD,
                      (LPBYTE)&dw,
                      sizeof(dw)
                     ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    RegCloseKey(hKey);
    RegCloseKey(hKeyTelephony);

    return TRUE;
}

//////////////////////////////////////////////////////////
//
// Determine if the currently logged on person is an admin
//
BOOL
IsAdministrator(
    )
{
    PSID                        psidAdministrators;
    BOOL                        bResult = FALSE;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;


    if (AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            ))
    {
        CheckTokenMembership (NULL, psidAdministrators, &bResult);

        FreeSid (psidAdministrators);
    }

    return bResult;
}


////////////////////////////////////////////////////////////////////
//
//  Determine the name of 'Administrators' group
//
BOOL LookupAdministratorsAlias( 
                               LPWSTR Name,
                               PDWORD cchName
                              )

{ 
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(
                                &sia,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0,
                                &pSid
                               ))
    {
        bSuccess = LookupAccountSidW(
                                     NULL,
                                     pSid,
                                     Name,
                                     cchName,
                                     DomainName,
                                     &cchDomainName,
                                     &snu
                                    );

        FreeSid(pSid);
    }

    return bSuccess;

} 

////////////////////////////////////////////////////////////////////
//
//  Determine if the person specified is an administrator
//
BOOL
IsUserAdministrator(
                    LPTSTR lpszFullName
                   )
{
    DWORD                     dwRead, dwTotal, x;
    NET_API_STATUS            nas;
    LPLOCALGROUP_USERS_INFO_0 pGroups = NULL;
    LPWSTR                    lpszNewFullName;
#define MAXADMINLEN     256
    WCHAR                     szAdministrators[MAXADMINLEN];


#ifndef UNICODE

    DWORD           dwSize;

    dwSize = (TAPIstrlen( lpszFullName ) + 1) * sizeof( WCHAR );

    if (!(lpszNewFullName = (LPWSTR) GlobalAlloc (GPTR, dwSize)))
    {
        return FALSE;
    }

    MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        lpszFullName,
                        -1,
                        lpszNewFullName,
                        dwSize
                       );
#else
    
    lpszNewFullName = lpszFullName;
    
#endif

    // First, get the name of the 'Administrators' group.
    // Normally, this will be Administrators, but the use
    // can change it (also, it will be different for foreign
    // versions of NT)
    dwTotal = sizeof(szAdministrators)/sizeof(WCHAR); // reuse dwTotal
    if (!(LookupAdministratorsAlias(
                                    szAdministrators,
                                    &dwTotal
                                   )))
    {
        return FALSE;
    }

    // Next, get all the groups the user is part of
    // (directly OR indirectly) and see if administrators
    // is among them.
#define MAX_PREFERRED_LEN 4096*2        // 2 pages (or 1 on alpha)
    nas = NetUserGetLocalGroups (
                                 NULL,                  // server
                                 lpszNewFullName,       // user name
                                 0,                     // level
                                 LG_INCLUDE_INDIRECT,   // flags
                                 (PBYTE*)&pGroups,      // output buffer
                                 MAX_PREFERRED_LEN,     // preferred maximum length
                                 &dwRead,               // entries read
                                 &dwTotal               // total entries
                                );

    if (NERR_Success != nas)
    {
        return FALSE;
    }

    for (x = 0; x < dwRead; x++)
    {
        if (lstrcmpiW(
                      pGroups[x].lgrui0_name,
                      szAdministrators
                     ) == 0)
        {
            break;
        }
    }
    NetApiBufferFree ((PVOID)pGroups);
    if (x < dwRead)
    {
        return TRUE;
    }

    ErrorStr(iszUserNotAdmin);

    return FALSE;
          
}

/////////////////////////////////////////////////////////////////////
//
//  Write out server registry keys
//
BOOL
WriteRegistryKeys(
                  LPTSTR    lpszMapper,
                  LPTSTR    lpszDlls
                 )
{
    HKEY        hKeyTelephony, hKey;
    DWORD       dw;

    if ((RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKeyTelephony
                     ) != ERROR_SUCCESS) ||

        (RegCreateKeyEx(
                        hKeyTelephony,
                        TEXT("Server"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS)
       )
    {
        return FALSE;
    }

    dw=0;
    
    if ((RegSetValueEx(
                  hKey,
                  TEXT("DisableSharing"),
                  0,
                  REG_DWORD,
                  (LPBYTE)&dw,
                  sizeof(dw)
                 ) != ERROR_SUCCESS) ||

        (RegSetValueEx(
                       hKey,
                       TEXT("MapperDll"),
                       0,
                       REG_SZ,
//                       (LPBYTE)lpszMapper,
                       (LPBYTE)TEXT("TSEC.DLL"),
//                       (TAPIstrlen(lpszMapper)+1)*sizeof(TCHAR)
                       (TAPIstrlen(TEXT("TSEC.DLL"))+1)*sizeof(TCHAR)
                      ) != ERROR_SUCCESS))
    {
        RegCloseKey(hKey);
        RegCloseKey(hKeyTelephony);

        return FALSE;
    }
    
    if (lpszDlls)
    {
        if (RegSetValueEx(
                          hKey,
                          TEXT("ManagementDlls"),
                          0,
                          REG_SZ,
                          (LPBYTE)lpszDlls,
                          (TAPIstrlen(lpszDlls)+1)*sizeof(TCHAR)
                         ) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            RegCloseKey(hKeyTelephony);
            
            return FALSE;
        }
    }
    else
    {
        RegDeleteValue(
                       hKey,
                       TEXT("ManagementDlls")
                      );
    }
                       
    
    RegCloseKey(hKey);
    RegCloseKey(hKeyTelephony);

    return TRUE;
}


//////////////////////////////////////////////////////////////////
//
// Set server setting for the tapisrv service
//
BOOL
DoServiceStuff(
               LPTSTR   lpszName,
               LPTSTR   lpszPassword,
               BOOL     bServer
              )
{
    SC_HANDLE           sch, sc_tapisrv;
    BOOL                bReturn = TRUE;
    
    if (!(sch = OpenSCManager(
                              NULL,
                              NULL,
                              SC_MANAGER_ENUMERATE_SERVICE
                             )))
    {
        return FALSE;
    }


    if (!(sc_tapisrv = OpenService(
                                   sch,
                                   TEXT("TAPISRV"),
                                   SERVICE_CHANGE_CONFIG
                                  )))
    {
        CloseHandle(sch);
        
        ErrorStr(iszOpenServiceFailed);
        return FALSE;
    }

    // this sets tapisrv to start as auto, not manual
    // and set the log on as person to be the name/password passed in
    if (!(ChangeServiceConfig(
                              sc_tapisrv,
                              SERVICE_WIN32_OWN_PROCESS,
                              bServer?SERVICE_AUTO_START:SERVICE_DEMAND_START,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              lpszName,
                              (lpszPassword ? lpszPassword : TEXT("")),
                              NULL
                             )))
     {
        bReturn = FALSE;
     }


    CloseServiceHandle(sc_tapisrv);
    CloseServiceHandle(sch);

    return bReturn;
}

  
 
NTSTATUS
OpenPolicy(
           LPWSTR ServerName,          // machine to open policy on (Unicode)
           DWORD DesiredAccess,        // desired access to policy
           PLSA_HANDLE PolicyHandle    // resultant policy handle
          );
 
BOOL
GetAccountSid(
              LPTSTR SystemName,          // where to lookup account
              LPTSTR AccountName,         // account of interest
              PSID *Sid                   // resultant buffer containing SID
             ); 
NTSTATUS
SetPrivilegeOnAccount(
                      LSA_HANDLE PolicyHandle,    // open policy handle
                      PSID AccountSid,            // SID to grant privilege to
                      LPWSTR PrivilegeName,       // privilege to grant (Unicode)
                      BOOL bEnable                // enable or disable
                     );

void
InitLsaString(
              PLSA_UNICODE_STRING LsaString, // destination
              LPWSTR String                  // source (Unicode)
             );
 
/////////////////////////////////////////////////////
//
// grant the person the right to Log On As A Service
//
BOOL
DoRight(
        LPTSTR   AccountName,
        LPWSTR   Right,
        BOOL     bEnable
       )
{
    LSA_HANDLE      PolicyHandle;
    PSID            pSid;
    NTSTATUS        Status;
    BOOL            bReturn = FALSE;
    WCHAR           wComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD           dwSize = MAX_COMPUTERNAME_LENGTH+1;


    
    GetComputerNameW(
                     wComputerName,
                     &dwSize
                    );
    //
    // Open the policy on the target machine.
    //
    if((Status=OpenPolicy(
                wComputerName,      // target machine
                POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                &PolicyHandle       // resultant policy handle
                )) != ERROR_SUCCESS)
    {
        ErrorStr(iszOpenPolicyFailed);
        return FALSE;
    }
 
    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
                     NULL,       // default lookup logic
                     AccountName,// account to obtain SID
                     &pSid       // buffer to allocate to contain resultant SID
                    ))
    {
        PLSA_UNICODE_STRING          rights;
        DWORD           dwcount = 0;
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.
 
        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //

        LsaEnumerateAccountRights(
                                  PolicyHandle,
                                  pSid,
                                  &rights,
                                  &dwcount
                                 );
        if((Status=SetPrivilegeOnAccount(
                                         PolicyHandle,           // policy handle
                                         pSid,                   // SID to grant privilege
                                         Right,//L"SeServiceLogonRight", // Unicode privilege
                                         bEnable                    // enable the privilege
                                        )) == ERROR_SUCCESS)
        {
            bReturn = TRUE;
        }
        else
        {
            ErrorStr(iszSetPrivilegeOnAccount);
        }
        
    }
 
    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);
 
    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) GlobalFree(pSid);
 
    return bReturn;
}
 
void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;
 
    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }
 
    StringLength = TAPIstrlen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}
 
NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
 
    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
 
    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPTSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }
 
    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                         Server,
                         &ObjectAttributes,
                         DesiredAccess,
                         PolicyHandle
                        );
}
 
/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.
 
If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)
 
If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.
 
Scott Field (sfield)    12-Jul-95
--*/
 
BOOL
GetAccountSid(
    LPTSTR SystemName,
    LPTSTR AccountName,
    PSID *Sid
    )
{
    LPTSTR ReferencedDomain=NULL;
    DWORD cbSid=1000;    // initial allocation attempt
    DWORD cbReferencedDomain=256; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=TRUE; // assume this function will fail
 
    //
    // initial memory allocations
    //
    if((*Sid=GlobalAlloc(
                         GPTR,
                         cbSid
                        )) == NULL)
    {
        bSuccess = FALSE;
        goto failure;
    }
 
    if((ReferencedDomain=GlobalAlloc(
                                     GPTR,
                                     cbReferencedDomain
                                    )) == NULL)
    {
        bSuccess = FALSE;
        goto failure;
    }

 
    //
    // Obtain the SID of the specified account on the specified system.
    //
    if (!LookupAccountName(
                           SystemName,         // machine to lookup account on
                           AccountName,        // account to lookup
                           *Sid,               // SID of interest
                           &cbSid,             // size of SID
                           ReferencedDomain,   // domain account was found on
                           &cbReferencedDomain,
                           &peUse
                          ))
    {
                bSuccess = FALSE;
                goto failure;
    } 

failure:
    
    if (ReferencedDomain)
    {
        GlobalFree(ReferencedDomain);
    }
 
    if(!bSuccess)
    {
        if(*Sid != NULL)
        {
            GlobalFree(*Sid);
            *Sid = NULL;
        }
    }

 
 
    return bSuccess;
}
 
NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;
 
    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);
 
    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}


BOOL
DisableServerStuff()
{
    HKEY        hKeyTelephony;
    
    if (!IsServer())
    {
        return FALSE;
    }

    if ((RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszRegKeyTelephony,
                      0,
                      KEY_ALL_ACCESS,
                      &hKeyTelephony
                     ) != ERROR_SUCCESS) ||
        (RegDeleteKey(
                      hKeyTelephony,
                      TEXT("Server")
                     ) != ERROR_SUCCESS)
       )
    {
        return FALSE;
    }

    if (!(DoServiceStuff(
                         TEXT("LocalSystem"),
                         TEXT(""),
                         FALSE
                        )))
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
DoServer(
         LPTSTR lpszServerLine
        )
{
    if (!(glpszFullName = GetNextString(
                                         lpszServerLine
                                        )))
    {
        return FALSE;
    }

    if (!(lstrcmpi(
                   glpszFullName,
                   TEXT("/d")
                  )))
    {
        if (!(DisableServerStuff()))
        {
            ErrorStr(iszServerDisabledFailure);
            return FALSE;
        }

        ErrorStr(iszServerDisabled);

        return TRUE;
    }

    // dow we want a password?
    if (!(lstrcmpi(
                   glpszFullName,
                   TEXT("/n")
                  )))
    {
        // NO!
        glpszFullName = GetNextString(
                                      NULL
                                     );
        glpszPassword = NULL;
    }
    else
    {
        // yes - get the password
        if (!(glpszPassword = GetNextString(
                                            NULL
                                           )))
        {
            ErrorStr(iszNoPasswordSupplied);
            ErrorStr(iszServerSetupFailure);
            return FALSE;
        }
    }

//    if (!(glpszMapper = GetNextString(
//                                      NULL
//                                     )))
//    {
//        ErrorStr(iszNoMapperSupplied);
//        ErrorStr(iszServerSetupFailure);
//        return FALSE;
//    }

    // dll list is not mandatory
    glpszDllList = GetNextString(
                                 NULL
                                );

    if (!IsServer())
    {
        return FALSE;
    }

    if (!IsUserAdministrator(
                             glpszFullName
                            )
       )
    {
        ErrorStr(iszUserNotAnAdmin);
        goto exit_now;
    }

    if (!DoRight(
                 glpszFullName,
                 L"SeServiceLogonRight",
                 TRUE
                ))
    {
        goto exit_now;
    }


    if (!WriteRegistryKeys(
                           glpszMapper,
                           glpszDllList
                          ))
    {
        ErrorStr(iszRegWriteFailed);
        goto exit_now;
    }

    if (!DoServiceStuff(
                        glpszFullName,
                        glpszPassword,
                        TRUE
                       ))
    {
        goto exit_now;
    }

    ErrorStr(iszServerSetup);

    return TRUE;

exit_now:

    ErrorStr(iszServerSetupFailure);
    return FALSE;
}

#endif


#define MAX_KEY_LENGTH 256
DWORD RegDeleteKeyNT(HKEY hStartKey , LPCTSTR pKeyName )
{
  DWORD   dwRtn, dwSubKeyLength;
  LPTSTR  pSubKey = NULL;
  TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
  HKEY    hKey;

  // Do not allow NULL or empty key name
  if ( pKeyName &&  lstrlen(pKeyName))
  {
     if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
        0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
     {
        while (dwRtn == ERROR_SUCCESS )
        {
           dwSubKeyLength = MAX_KEY_LENGTH;
           dwRtn=RegEnumKeyEx(
                          hKey,
                          0,       // always index zero
                          szSubKey,
                          &dwSubKeyLength,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                        );

           if(dwRtn == ERROR_NO_MORE_ITEMS)
           {
              dwRtn = RegDeleteKey(hStartKey, pKeyName);
              break;
           }
           else if(dwRtn == ERROR_SUCCESS)
              dwRtn=RegDeleteKeyNT(hKey, szSubKey);
        }
        RegCloseKey(hKey);
        // Do not save return code because error
        // has already occurred
     }
  }
  else
     dwRtn = ERROR_BADKEY;

  return dwRtn;
}

BOOL
RemoveRemoteSP()
{
    HKEY        hKeyProviders, hKeyTelephony;
    DWORD       dwSize, dwCount, dwID, dwType, dwNumProviders ;
    TCHAR       szBuffer[256], szProviderName[256];
            
            
    // open providers key
    if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyProviders,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyProviders
                ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // open telephony key
    if (RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     gszRegKeyTelephony,
                     0,
                     KEY_ALL_ACCESS,
                     &hKeyTelephony
                    ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwSize = sizeof (DWORD);

    // get current num providers
    if (RegQueryValueEx(
                      hKeyProviders,
                      gszNumProviders,
                      NULL,
                      &dwType,
                      (LPBYTE)&dwNumProviders,
                      &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //check to see if remotesp is already installed
    //loop through all providers and compare filename
    for (dwCount = 0; dwCount < dwNumProviders; dwCount++)
    {
        wsprintf(
                 szBuffer,
                 TEXT("%s%d"),
                 gszProviderFilename,
                 dwCount
                );

        dwSize = 256;
        
        if (RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)szProviderName,
                            &dwSize) != ERROR_SUCCESS)
        {
            continue;
        }

        // this is remotesp
        if (!lstrcmpi(
                      szProviderName,
                      gszRemoteSP
                     ))
        {

            
            wsprintf(
                     szBuffer,
                     TEXT("%s%d"),
                     gszProviderID,
                     dwCount
                    );

            dwSize = sizeof(DWORD);
            
            RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwID,
                            &dwSize
                           );
            return (lineRemoveProvider (dwID, NULL) == S_OK);
        }
    }

    if (dwCount == dwNumProviders)
    {
        return FALSE;
    }

    return TRUE;
}
               
BOOL
WriteRemoteSPKeys(
                  LPTSTR lpszRemoteServer
                 )
{
    HKEY        hKeyProviders, hKeyTelephony = NULL, hKey;
    DWORD       dwSize, dwType, dwNumProviders, dwNextProviderID,
                dwDisp, dwCount, i;
    TCHAR       szBuffer[256], szProviderName[256]; 
#ifdef NEVER
    BOOL        fAlreadyExists = FALSE;
#endif


    // open providers key
    if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyProviders,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyProviders
                ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwSize = sizeof (DWORD);

    // get current num providers
    if (RegQueryValueEx(
                      hKeyProviders,
                      gszNumProviders,
                      NULL,
                      &dwType,
                      (LPBYTE)&dwNumProviders,
                      &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //check to see if remotesp is already installed
    //loop through all providers and compare filename

    for (dwCount = 0; dwCount < dwNumProviders; dwCount++)
    {
        wsprintf(
                 szBuffer,
                 TEXT("%s%d"),
                 gszProviderFilename,
                 dwCount
                );

        dwSize = 256;
        
        if (RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)szProviderName,
                            &dwSize) != ERROR_SUCCESS)
        {
            continue;
        }

        if (!lstrcmpi(
                      szProviderName,
                      gszRemoteSP
                     ))
        {
            // if there's a match, return TRUE
            wsprintf(
                     szBuffer,
                     TEXT("%s%d"),
                     gszProviderID,
                     dwCount
                    );

            dwSize = sizeof(DWORD);
            
            RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwNextProviderID,
                            &dwSize
                           );

            //  first remove the provider
            if (lineRemoveProvider (dwNextProviderID, NULL))
            {
                RegCloseKey (hKeyProviders);
                return FALSE;
            }

            if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyTelephony,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyTelephony
                ) != ERROR_SUCCESS)
            {
                return FALSE;
            }
            
            wsprintf(
                szBuffer,
                TEXT("%s%d"),
                gszProvider,
                dwNextProviderID
                );

#if MEMPHIS
            RegDeleteKey(
                hKeyTelephony,
                szBuffer
                );
#else
            RegDeleteKeyNT(
                hKeyTelephony,
                szBuffer
                );
#endif

#ifdef NEVER
            wsprintf(
                     szBuffer,
                     TEXT("%s%d"),
                     gszProvider,
                     dwNextProviderID
                    );

            // open telephony key
            if (RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             gszRegKeyTelephony,
                             0,
                             KEY_ALL_ACCESS,
                             &hKeyTelephony
                            ) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            fAlreadyExists = TRUE;
            goto createProviderNKey;
#endif
        }
    }

    dwSize = sizeof (DWORD);

    // get next provider id
    if (RegQueryValueEx(
                        hKeyProviders,
                        gszNextProviderID,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwNextProviderID,
                        &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }


#ifdef NEVER
    // make the filename id
    wsprintf(szBuffer, TEXT("%s%d"), gszProviderFilename, dwNumProviders);

    // set the filename
    if (RegSetValueEx(
                      hKeyProviders,
                      szBuffer,
                      0,
                      REG_SZ,
                      (LPBYTE)gszRemoteSP,
                      (TAPIstrlen(gszRemoteSP)+1) * sizeof(TCHAR)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // make the provideid id
    wsprintf(szBuffer, TEXT("%s%d"), gszProviderID, dwNumProviders);

    // set the providerid id
    if (RegSetValueEx(
                      hKeyProviders,
                      szBuffer,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwNextProviderID,
                      sizeof(DWORD)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // inc next provider id
    dwNextProviderID++;

    // set it
    if (RegSetValueEx(
                      hKeyProviders,
                      gszNextProviderID,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwNextProviderID,
                      sizeof(DWORD)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // inc num providers
    dwNumProviders++;

    // set it
    if (RegSetValueEx(
                      hKeyProviders,
                      gszNumProviders,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwNumProviders,
                      sizeof(DWORD)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // close this one
    RegCloseKey(hKeyProviders);
#endif  //  NEVER

    // open telephony key
    if ((hKeyTelephony == NULL) && (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyTelephony,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyTelephony
                ) != ERROR_SUCCESS))
    {
        return FALSE;
    }

    // make the provider# key
    wsprintf(szBuffer, TEXT("%s%d"), gszProvider, dwNextProviderID);

#if NEVER
createProviderNKey:

    //
    // First nuke the existing key to clear out all the old values,
    // the recreate it & add the new values
    //
    
#if MEMPHIS
    RegDeleteKey (hKeyTelephony, szBuffer);
#else
    RegDeleteKeyNT (hKeyTelephony, szBuffer);
#endif
#endif

    if (RegCreateKeyEx(
                       hKeyTelephony,
                       szBuffer,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       NULL,
                       &hKey,
                       &dwDisp
                      ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyTelephony);

        return FALSE;
    }

    for (i = 0; lpszRemoteServer; i++)
    {
        wsprintf (szBuffer, TEXT("%s%d"), gszServer, i);

        if (RegSetValueEx(
                hKey,
                szBuffer,
                0,
                REG_SZ,
                (LPBYTE) lpszRemoteServer,
                (TAPIstrlen (lpszRemoteServer) + 1) * sizeof(TCHAR)

                ) != ERROR_SUCCESS)
        {
            RegCloseKey (hKey);
            RegCloseKey (hKeyProviders);

            return FALSE;
        }

        lpszRemoteServer = GetNextString (NULL);
    }

    if (RegSetValueEx(
            hKey,
            gszNumServers,
            0,
            REG_DWORD,
            (LPBYTE) &i,
            sizeof (i)

            ) != ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
        RegCloseKey (hKeyProviders);

        return FALSE;
    }

    // set the ConnectionOrientedOnly value appropriately

    if (RegSetValueEx(
            hKey,
            gszConnectionOrientedOnly,
            0,
            REG_DWORD,
            (LPBYTE) &gdwConnectionOrientedOnly,
            sizeof(DWORD)

            ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //  Set NoDSQuery value appropriately
    if (RegSetValueEx(
            hKey,
            gszNoDSQuery,
            0,
            REG_DWORD,
            (LPBYTE) &gdwNoDSQuery,
            sizeof(DWORD)

            ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //
    //  Add the new remotesp.tsp
    //
    lineAddProvider (gszRemoteSP, NULL, &dwNextProviderID);

    RegCloseKey (hKey);
    RegCloseKey (hKeyProviders);
    RegCloseKey(hKeyTelephony);
    
    return TRUE;
}



BOOL
DoClient(
         LPTSTR lpszClientLine
        )
{
    HANDLE  hProvidersMutex = NULL;
    BOOL    bRet = FALSE;

    glpszRemoteServer = GetNextString(
                                      lpszClientLine
                                     );

    if (!glpszRemoteServer)
    {
        goto ExitHere;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        ErrorStr(iszCreateMutexFailed);
        goto ExitHere;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);
    
    if (!lstrcmpi(
                  glpszRemoteServer,
                  TEXT("/d")
                 ))
    {
        if (!RemoveRemoteSP())
        {
            ErrorStr(iszClientDisabledFailure);
            goto ExitHere;
        }
        else
        {
            ErrorStr(iszClientDisabled);

            bRet = TRUE;
            goto ExitHere;
        }
    }
        

    if (!WriteRemoteSPKeys(
                           glpszRemoteServer
                          ))
    {
        ErrorStr(iszClientSetupFailure);
        goto ExitHere;
    }
    else
    {
        bRet = TRUE;
    }

    ErrorStr(iszClientSetup);

ExitHere:

    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\admin\setup\resource.h ===
//
#define IDD_DIALOG1                     101
#define IDC_NAME                        1000
#define IDC_PASSWORD                    1001
#define IDC_DISABLE                     1002
#define IDC_MAPPER                      1003
#define IDC_DLLS                        1004
#define IDC_DOMAIN                      1005
#define IDC_STATIC                      -1

#define iszMustBeAdmin                  4000
#define iszNotRunningServer             4001
#define iszRegOpenKeyFailed             4002
#define iszRegSetValueFailed            4003
#define iszOpenThreadTokenFailed        4004
#define iszGetTokenInfoFailed           4005
#define iszAllocateAndInitializeSidFailed   4006
#define iszUserNotAdmin                 4007
#define iszOpenSCManagerFailed          4009
#define iszServerDisabled               4011
#define iszServerSetup                  4012
#define iszNotClient                    4013
#define iszClientDisabled               4014
#define iszClientSetup                  4015
#define iszTapiAdminSetup               4016
#define iszChangeServerConfigFailed     4017
#define iszHelp0                        4018
#define iszHelp1                        4019
#define iszHelp2                        4020
#define iszHelp3                        4021
#define iszHelp4                        4022
#define iszHelp5                        4023
#define iszHelp6                        4024
#define iszHelp7                        4025
#define iszHelp8                        4026
#define iszHelp9                        4027
#define iszHelp10                       4028
#define iszHelpTitle                    4029
#define iszServerDisabledFailure        4030
#define iszServerSetupFailure           4031
#define iszClientDisabledFailure        4032
#define iszClientSetupFailure           4033
#define iszNoPasswordSupplied           4034
#define iszNoMapperSupplied             4035
#define iszUserNotAnAdmin				4036
#define iszOpenPolicyFailed  			4037
#define iszSetPrivilegeOnAccount		4038
#define iszRegWriteFailed				4039
#define iszOpenServiceFailed			4040
#define iszCreateMutexFailed            4041
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\admin\dll\tsec.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    tsec.c

Abstract:

    A sample administration DLL

Author:



Revision History:

--*/


#include <windows.h>
#include <tapi.h>
#include <tapclntp.h>  // private\inc\tapclntp.h
#include <tlnklist.h>
#include "tsec.h"

HINSTANCE               ghInst;
LIST_ENTRY              gClientListHead;
CRITICAL_SECTION        gCritSec;
DEVICECHANGECALLBACK    glpfnLineChangeCallback = NULL;
DEVICECHANGECALLBACK    glpfnPhoneChangeCallback = NULL;


void
FreeClient(
    PMYCLIENT pClient
    );

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG
        gdwDebugLevel = 0;
#endif

        DBGOUT((2, "DLL_PROCESS_ATTACH"));

        ghInst = hDLL;

        InitializeCriticalSection (&gCritSec);

        InitializeListHead (&gClientListHead);

        break;
    }
    case DLL_PROCESS_DETACH:
    {
         PMYCLIENT  pClient;


        //
        // Clean up client list (no need to enter crit sec since
        // process detaching)
        //

        while (!IsListEmpty (&gClientListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList (&gClientListHead);


            pClient = CONTAINING_RECORD (pEntry, MYCLIENT, ListEntry);

            FreeClient(pClient);
        }

        DeleteCriticalSection (&gCritSec);

        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;

    } // switch

    return TRUE;
}


void
FreeClient(
    PMYCLIENT pClient
    )
{
    GlobalFree (pClient->pszUserName);
    GlobalFree (pClient->pszDomainName);
    GlobalFree (pClient->pLineDeviceMap);
    GlobalFree (pClient->pPhoneDeviceMap);

    GlobalFree (pClient);

}


LONG
GetAndParseAMapping(
    LPCWSTR             pszFullName,
    LPCWSTR             pszType,
    LPTAPIPERMANENTID  *ppDevices,
    LPDWORD             pdwDevices
    )
{
    LPWSTR      pszDevices = NULL, pszHold1, pszHold2;
    DWORD       dwSize, dwReturn, dwDevices;
    DWORD       dwPermanentDeviceID;
    BOOL        bBreak = FALSE;


    dwSize = MAXDEVICESTRINGLEN;


    // get the string

    do
    {
        if (pszDevices != NULL)
        {
            dwSize *= 2;

            GlobalFree (pszDevices);
        }

        pszDevices = (LPWSTR) GlobalAlloc (GPTR, dwSize * sizeof(WCHAR));

        if (!pszDevices)
        {
            return LINEERR_NOMEM;
        }

        dwReturn = GetPrivateProfileString(
            pszFullName,
            pszType,
            SZEMPTYSTRING,
            pszDevices,
            dwSize,
            SZINIFILE
            );

        if (dwReturn == 0)
        {
            // valid case.  the user has no
            // devices, so just return 0

            GlobalFree(pszDevices);

            *pdwDevices = 0;
            *ppDevices = NULL;

            return 0;
        }

    } while (dwReturn == (dwSize - 1));


    // parse the string
    //
    // the string looks line px, x, py, y,pz, z where x,y and z are
    // tapi permanent device IDs, and px, py, and pz are the
    // permanent provider IDs for the corresponding devices.

    pszHold1 = pszDevices;
    dwDevices = 0;

    // first, count the ,s so we know how many devices there are

    while (*pszHold1 != L'\0')
    {
        if (*pszHold1 == L',')
        {
            dwDevices++;
        }
        pszHold1++;
    }

    dwDevices++;

    dwDevices /= 2;

    // alloc line mapping, this is freed later

    *ppDevices = (LPTAPIPERMANENTID) GlobalAlloc(
        GPTR,
        dwDevices * sizeof ( TAPIPERMANENTID )
        );

    if (!*ppDevices)
    {
        GlobalFree (pszDevices);
        return LINEERR_NOMEM;
    }


    pszHold1 = pszHold2 = pszDevices;
    dwDevices = 0;

    // go through string

    while (TRUE)
    {

        // wait for ,

        while ((*pszHold2 != L'\0') && *pszHold2 != L',')
        {
            pszHold2++;
        }

        if (*pszHold2 == L',')
            *pszHold2 = L'\0';
        else
        {
            bBreak = TRUE;
        }

        // save the id

        (*ppDevices)[dwDevices].dwProviderID = _wtol(pszHold1);

        // if we hit the end, break out
        // note here that this is an unmatched provider id
        // but we have inc'ed the dwdevices, so this element will be ignored

        if (bBreak)
        {
            break;
        }

        pszHold2++;
        pszHold1 = pszHold2;

        // wait for ,

        while ((*pszHold2 != L'\0') && *pszHold2 != L',')
        {
            pszHold2++;
        }

        if (*pszHold2 == L',')
        {
            *pszHold2 = L'\0';
        }
        else
        {
            bBreak = TRUE;
        }

        // save the id

        (*ppDevices)[dwDevices].dwDeviceID = _wtol(pszHold1);

        dwDevices++;

        // if we hit the end, break out

        if (bBreak)
        {
            break;
        }

        pszHold2++;
        pszHold1 = pszHold2;
    }


    *pdwDevices = dwDevices;

    GlobalFree(pszDevices);

    return 0;   // success
}


LONG
GetMappings(
    LPCWSTR             pszDomainName,
    LPCWSTR             pszUserName,
    LPTAPIPERMANENTID  *ppLineMapping,
    LPDWORD             pdwLines,
    LPTAPIPERMANENTID  *ppPhoneMapping,
    LPDWORD             pdwPhones
    )
{
    LPWSTR      pszFullName;
    DWORD       dwSize;
    LONG        lResult;


    // put the username and domain name together
    // for a full name:  domain\user
    // in the " + 2"  1 is for \ and 1 is for null terminator

    pszFullName = (LPWSTR)GlobalAlloc(
        GPTR,
        ( lstrlen(pszDomainName) + lstrlen(pszUserName) + 2 ) * sizeof(WCHAR)
        );

    if (!pszFullName)
    {
        return LINEERR_NOMEM;
    }

    // put them together

    wsprintf(
        pszFullName,
        L"%s\\%s",
        pszDomainName,
        pszUserName
        );

    if (lResult = GetAndParseAMapping(
            pszFullName,
            SZLINES,
            ppLineMapping,
            pdwLines
            ))
    {
        GlobalFree(pszFullName);
        return lResult;
    }

    if (lResult = GetAndParseAMapping(
            pszFullName,
            SZPHONES,
            ppPhoneMapping,
            pdwPhones
            ))
    {
        GlobalFree (*ppLineMapping);
        GlobalFree (pszFullName);
        return lResult;
    }

    GlobalFree(pszFullName);

    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_Load(
    LPDWORD                 pdwAPIVersion,
    DEVICECHANGECALLBACK    lpfnLineChangeCallback,
    DEVICECHANGECALLBACK    lpfnPhoneChangeCallback,
    DWORD                   Reserved
    )
{
    if (*pdwAPIVersion > TAPI_CURRENT_VERSION)
    {
        *pdwAPIVersion = TAPI_CURRENT_VERSION;
    }

    glpfnLineChangeCallback = lpfnLineChangeCallback;
    glpfnPhoneChangeCallback = lpfnPhoneChangeCallback;

    return 0;
}


void
CLIENTAPI
TAPICLIENT_Free(
    void
    )
{
    return;
}


LONG
CLIENTAPI
TAPICLIENT_ClientInitialize(
    LPCWSTR             pszDomainName,
    LPCWSTR             pszUserName,
    LPCWSTR             pszMachineName,
    LPHMANAGEMENTCLIENT phmClient
    )
{
    PMYCLIENT           pNewClient;
    LPTAPIPERMANENTID   pLineMapping, pPhoneMapping;
    DWORD               dwNumLines, dwNumPhones;
    LONG                lResult;


    // first, get the device mappings
    // if this fails, most likely the user
    // has access to no lines

    if (lResult = GetMappings(
            pszDomainName,
            pszUserName,
            &pLineMapping,
            &dwNumLines,
            &pPhoneMapping,
            &dwNumPhones
            ))
    {
        return lResult;
    }

    // alloc a client structure

    pNewClient = (PMYCLIENT) GlobalAlloc (GPTR, sizeof(MYCLIENT));

    if (!pNewClient)
    {
        return LINEERR_NOMEM;
    }

    // alloc space for the name

    pNewClient->pszUserName = (LPWSTR) GlobalAlloc(
        GPTR,
        (lstrlen(pszUserName) + 1) * sizeof(WCHAR)
        );
    if (!pNewClient->pszUserName)
    {
        GlobalFree(pNewClient);
        return LINEERR_NOMEM;
    }

    pNewClient->pszDomainName = (LPWSTR) GlobalAlloc(
        GPTR,
        (lstrlen(pszDomainName) +1) * sizeof(WCHAR)
        );
    if (!pNewClient->pszDomainName)
    {
        GlobalFree(pNewClient->pszUserName);
        GlobalFree(pNewClient);
        return LINEERR_NOMEM;
    }

    // initialize stuff

    lstrcpy (pNewClient->pszUserName, pszUserName);

    lstrcpy (pNewClient->pszDomainName, pszDomainName);

    pNewClient->pLineDeviceMap = pLineMapping;
    pNewClient->pPhoneDeviceMap = pPhoneMapping;
    pNewClient->dwNumLines = dwNumLines;
    pNewClient->dwNumPhones = dwNumPhones;
    pNewClient->dwKey = TSECCLIENT_KEY;

    // insert into list of clients

    EnterCriticalSection (&gCritSec);

    InsertHeadList (&gClientListHead, &pNewClient->ListEntry);

    LeaveCriticalSection (&gCritSec);

    // give TAPI the hmClient

    *phmClient = (HMANAGEMENTCLIENT)pNewClient;

    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_ClientShutdown(
    HMANAGEMENTCLIENT   hmClient
    )
{
    PMYCLIENT   pClient;


    pClient = (PMYCLIENT) hmClient;

    EnterCriticalSection (&gCritSec);

    try
    {
        if (pClient->dwKey == TSECCLIENT_KEY)
        {
            pClient->dwKey = 0;
            RemoveEntryList (&pClient->ListEntry);
        }
        else
        {
            pClient = NULL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pClient = NULL;
    }

    LeaveCriticalSection (&gCritSec);

    if (pClient)
    {
        FreeClient (pClient);
    }

    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_GetDeviceAccess(
    HMANAGEMENTCLIENT   hmClient,
    HTAPICLIENT         htClient,
    LPTAPIPERMANENTID   pLineDeviceMap,
    PDWORD              pdwLineDevices,
    LPTAPIPERMANENTID   pPhoneDeviceMap,
    PDWORD              pdwPhoneDevices
    )
{
    LONG        lResult;
    PMYCLIENT   pClient = (PMYCLIENT) hmClient;


    EnterCriticalSection (&gCritSec);

    try
    {
        if (pClient->dwKey != TSECCLIENT_KEY)
        {
            pClient = NULL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pClient = NULL;
    }

    if (pClient)
    {
        // would need to critical section this stuff
        // if we added devices dynamically

        if (*pdwLineDevices < pClient->dwNumLines)
        {
            *pdwLineDevices = pClient->dwNumLines;

            lResult = LINEERR_STRUCTURETOOSMALL;
            goto LeaveCritSec;
        }

        CopyMemory(
            pLineDeviceMap,
            pClient->pLineDeviceMap,
            pClient->dwNumLines * sizeof( TAPIPERMANENTID )
            );

        *pdwLineDevices = pClient->dwNumLines;

        if (*pdwPhoneDevices < pClient->dwNumPhones)
        {
            *pdwPhoneDevices = pClient->dwNumPhones;

            lResult = LINEERR_STRUCTURETOOSMALL;
            goto LeaveCritSec;
        }

        CopyMemory(
            pPhoneDeviceMap,
            pClient->pPhoneDeviceMap,
            pClient->dwNumPhones * sizeof( TAPIPERMANENTID )
            );

        *pdwPhoneDevices = pClient->dwNumPhones;

        pClient->htClient = htClient;

        lResult = 0;
    }
    else
    {
        lResult = LINEERR_INVALPOINTER;
    }

LeaveCritSec:

    LeaveCriticalSection (&gCritSec);

    return lResult;
}


LONG
CLIENTAPI
TAPICLIENT_LineAddToConference(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPLINECALLINFO      lpConsultCallCallInfo
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineBlindTransfer(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPWSTR              lpszDestAddress,
    LPDWORD             lpdwSize,
    LPDWORD             pdwCountryCodeOut
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineConfigDialog(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPCWSTR             lpszDeviceClass
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineDial(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               Reserved,
    LPWSTR              lpszDestAddressIn,
    LPDWORD             pdwSize,
    LPDWORD             pdwCountyCode
   )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineForward(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPLINEFORWARDLIST   lpFowardListIn,
    LPDWORD             pdwSize,
    LPLINECALLPARAMS    lpCallParamsIn,
    LPDWORD             pdwParamsSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineGenerateDigits(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               Reserved,
    LPCWSTR             lpszDigits
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineMakeCall(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwReserved,
    LPWSTR              lpszDestAddress,
    LPDWORD             pdwSize,
    LPDWORD             pdwCountryCode,
    LPLINECALLPARAMS    lpCallParams,
    LPDWORD             pdwCallParamsSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineOpen(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    lpCallParamsIn,
    LPDWORD             pdwParamsSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineRedirect(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPWSTR              lpszDestAddress,
    LPDWORD             pdwSize,
    LPDWORD             pdwCountryCode
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallData(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPVOID              lpCallData,
    LPDWORD             pdwSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallParams(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    lpDialParams
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallPrivilege(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwCallPrivilege
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallTreatment(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwCallTreatment
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCurrentLocation(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPDWORD             dwLocation
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetDevConfig(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPVOID              lpDevConfig,
    LPDWORD             pdwSize,
    LPCWSTR             lpszDeviceClass
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetLineDevStatus(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetMediaControl(
    HMANAGEMENTCLIENT           hmClient,
    LPTAPIPERMANENTID           pID,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallstateList,
    DWORD                       dwCallstateNumEntries
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetMediaMode(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwMediaModes
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetTerminal(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    BOOL                bEnable
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetTollList(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPCWSTR             lpszAddressIn,
    DWORD               dwTollListOption
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_PhoneConfigDialog(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPCWSTR             lpszDeviceClass
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_PhoneOpen(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwPrivilege
    )
{
    return LINEERR_OPERATIONFAILED;
}



#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[128] = "TSEC: ";
        va_list ap;


        va_start(ap, lpszFormat);
        wvsprintfA (&buf[6], lpszFormat, ap);
        lstrcatA (buf, "\n");
        OutputDebugStringA (buf);
        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapitna\general.h ===
#define FLAG_AUTOLAUNCH               0x00000001
#define FLAG_AUTOLOCATIONID           0x00000002
#define FLAG_PROMPTAUTOLOCATIONID     0x00000004
#define FLAG_ANNOUNCEAUTOLOCATIONID   0x00000008
#define FLAG_UPDATEONSTARTUP          0x00000010

BOOL
CALLBACK
GeneralDlgProc(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );


#define MAX_CONFIGPROFILES 4

#define IDC_STATIC                      -1


#define IDD_GENERAL                     114



//WARNING GENERAL.C _ASSUMES_ that the defines for the profile comboboxes are
//sequential
#define IDCS_DL_PROFILETEXT              5017
#define IDCB_DL_PROFILE1                 5018
#define IDCB_DL_PROFILE2                 5019
#define IDCB_DL_PROFILE3                 5020
#define IDCB_DL_PROFILE4                 5021

//WARNING GENERAL.C _ASSUMES_ that the defines for the profile texts are
//sequential
#define IDCS_DL_PROFILE1                 5024
#define IDCS_DL_PROFILE2                 5025
#define IDCS_DL_PROFILE3                 5026
#define IDCS_DL_PROFILE4                 5027


#define IDCK_DL_LAUNCHTAPITNA               6012
#define IDCK_DL_AUTOLOCATIONID              6013
#define IDCK_DL_PROMPTAUTOLOCATIONID        6014
#define IDCK_DL_ANNOUNCEAUTOLOCATIONID      6015
#define IDCK_DL_UPDATEONSTARTUP             6018

#define IDCS_DL_PROMPTAUTOLOCATIONID        6016
#define IDCS_DL_ANNOUNCEAUTOLOCATIONID         6017
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapitna\client.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    client.h

Abstract:

    Header file for tapi client module

Author:

    Dan Knudson (DanKn)    01-Apr-1994

Revision History:

--*/


#define TAPI_VERSION1_0           0x00010003
#define TAPI_VERSION1_4           0x00010004
#define TAPI_VERSION2_0           0x00020000
#define TAPI_VERSION2_1           0x00020001
#define TAPI_VERSION2_2           0x00020002
#define TAPI_VERSION3_0           0x00030000
#define TAPI_VERSION_CURRENT      TAPI_VERSION3_0

#define NUM_ARGS_MASK             0x0000000f

#define LINE_FUNC                 0x00000010
#define PHONE_FUNC                0x00000020
#define TAPI_FUNC                 0x00000000

#define ASYNC                     0x00000040
#define SYNC                      0x00000000

#define INITDATA_KEY              ((DWORD) 'INIT')
#define TPROXYREQUESTHEADER_KEY   ((DWORD) 'REQH')

#define WM_ASYNCEVENT             (WM_USER+111)

#define DEF_NUM_EVENT_BUFFER_ENTRIES    16

#define TAPI_SUCCESS                    0
#define TAPI_NO_DATA                    -1
#define MAX_TAPI_FUNC_ARGS              13

#define REMOVEPROVIDER                  0
#define CONFIGPROVIDER                  1
#define ADDPROVIDER                     2
#define TAPI16BITSUCCESS                -2

#define INITIAL_CLIENT_THREAD_BUF_SIZE  512
#define WM_TAPI16_CALLBACKMSG           (WM_USER+101)

#define IsOnlyOneBitSetInDWORD(dw) (dw && !(((DWORD)dw) & (((DWORD)dw) - 1)))

#define AllCallSelect                \
    (LINECALLSELECT_CALL           | \
    LINECALLSELECT_ADDRESS         | \
    LINECALLSELECT_LINE)

#define AllDigitModes                \
    (LINEDIGITMODE_PULSE           | \
    LINEDIGITMODE_DTMF             | \
    LINEDIGITMODE_DTMFEND)

#define AllForwardModes              \
    (LINEFORWARDMODE_UNCOND        | \
    LINEFORWARDMODE_UNCONDINTERNAL | \
    LINEFORWARDMODE_UNCONDEXTERNAL | \
    LINEFORWARDMODE_UNCONDSPECIFIC | \
    LINEFORWARDMODE_BUSY           | \
    LINEFORWARDMODE_BUSYINTERNAL   | \
    LINEFORWARDMODE_BUSYEXTERNAL   | \
    LINEFORWARDMODE_BUSYSPECIFIC   | \
    LINEFORWARDMODE_NOANSW         | \
    LINEFORWARDMODE_NOANSWINTERNAL | \
    LINEFORWARDMODE_NOANSWEXTERNAL | \
    LINEFORWARDMODE_NOANSWSPECIFIC | \
    LINEFORWARDMODE_BUSYNA         | \
    LINEFORWARDMODE_BUSYNAINTERNAL | \
    LINEFORWARDMODE_BUSYNAEXTERNAL | \
    LINEFORWARDMODE_BUSYNASPECIFIC)

#define AllTerminalModes             \
    (LINETERMMODE_BUTTONS          | \
    LINETERMMODE_LAMPS             | \
    LINETERMMODE_DISPLAY           | \
    LINETERMMODE_RINGER            | \
    LINETERMMODE_HOOKSWITCH        | \
    LINETERMMODE_MEDIATOLINE       | \
    LINETERMMODE_MEDIAFROMLINE     | \
    LINETERMMODE_MEDIABIDIRECT)

#define AllToneModes                 \
    (LINETONEMODE_CUSTOM           | \
    LINETONEMODE_RINGBACK          | \
    LINETONEMODE_BUSY              | \
    LINETONEMODE_BEEP              | \
    LINETONEMODE_BILLING)

#define AllHookSwitchDevs            \
    (PHONEHOOKSWITCHDEV_HANDSET    | \
    PHONEHOOKSWITCHDEV_SPEAKER     | \
    PHONEHOOKSWITCHDEV_HEADSET)

#define AllHookSwitchModes           \
    (PHONEHOOKSWITCHMODE_ONHOOK    | \
    PHONEHOOKSWITCHMODE_MIC        | \
    PHONEHOOKSWITCHMODE_SPEAKER    | \
    PHONEHOOKSWITCHMODE_MICSPEAKER)

#define AllLampModes                 \
    (PHONELAMPMODE_BROKENFLUTTER   | \
    PHONELAMPMODE_FLASH            | \
    PHONELAMPMODE_FLUTTER          | \
    PHONELAMPMODE_OFF              | \
    PHONELAMPMODE_STEADY           | \
    PHONELAMPMODE_WINK             | \
    PHONELAMPMODE_DUMMY)

#define AllMediaModes                \
    (LINEMEDIAMODE_UNKNOWN         | \
    LINEMEDIAMODE_INTERACTIVEVOICE | \
    LINEMEDIAMODE_AUTOMATEDVOICE   | \
    LINEMEDIAMODE_DIGITALDATA      | \
    LINEMEDIAMODE_G3FAX            | \
    LINEMEDIAMODE_G4FAX            | \
    LINEMEDIAMODE_DATAMODEM        | \
    LINEMEDIAMODE_TELETEX          | \
    LINEMEDIAMODE_VIDEOTEX         | \
    LINEMEDIAMODE_TELEX            | \
    LINEMEDIAMODE_MIXED            | \
    LINEMEDIAMODE_TDD              | \
    LINEMEDIAMODE_ADSI             | \
    LINEMEDIAMODE_VOICEVIEW        | \
    LINEMEDIAMODE_VIDEO)


typedef enum
{
    xGetAsyncEvents,
    xGetUIDllName,
    xUIDLLCallback,
    xFreeDialogInstance,

    lAccept,
    lAddToConference,
    lAgentSpecific,
    lAnswer,
    lBlindTransfer,
    lClose,
    lCompleteCall,
    lCompleteTransfer,
//    lConditionalMediaDetection,  //remotesp
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
    lDrop,
    lForward,
    lGatherDigits,
    lGenerateDigits,
    lGenerateTone,
    lGetAddressCaps,
    lGetAddressID,
    lGetAddressStatus,
    lGetAgentActivityList,
    lGetAgentCaps,
    lGetAgentGroupList,
    lGetAgentStatus,
    lGetAppPriority,
    lGetCallAddressID,          // remotesp only
    lGetCallInfo,
    lGetCallStatus,
    lGetConfRelatedCalls,
    lGetCountry,
    lGetDevCaps,
    lGetDevConfig,
    lGetIcon,
    lGetID,
    lGetLineDevStatus,
    lGetNewCalls,
    lGetNumAddressIDs,          // remotesp only
    lGetNumRings,
    lGetProviderList,
    lGetRequest,
    lGetStatusMessages,
//In TAPI32.DLL now:    lGetTranslateCaps,
    lHandoff,
    lHold,
    lInitialize,
    lMakeCall,
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
    lPark,
    lPickup,
    lPrepareAddToConference,
    lProxyMessage,
    lProxyResponse,
    lRedirect,
    lRegisterRequestRecipient,
    lReleaseUserUserInfo,
    lRemoveFromConference,
    lSecureCall,
//    lSelectExtVersion,
    lSendUserUserInfo,
    lSetAgentActivity,
    lSetAgentGroup,
    lSetAgentState,
    lSetAppPriority,
    lSetAppSpecific,
    lSetCallData,
    lSetCallParams,
    lSetCallPrivilege,
    lSetCallQualityOfService,
    lSetCallTreatment,
//In TAPI32.DLL now:    lSetCurrentLocation,
    lSetDefaultMediaDetection,  // remotesp only
    lSetDevConfig,
    lSetLineDevStatus,
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
//In TAPI32.DLL now:    lSetTollList,
    lSetupConference,
    lSetupTransfer,
    lShutdown,
    lSwapHold,
//In TAPI32.DLL now:    lTranslateAddress,
    lUncompleteCall,
    lUnhold,
    lUnpark,

    pClose,
    pDevSpecific,
    pGetButtonInfo,
    pGetData,
    pGetDevCaps,
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetID,
    pGetIcon,
    pGetLamp,
    pGetRing,
    pGetStatus,
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
//    pSelectExtVersion,      // remotesp
    pSetButtonInfo,
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

//In TAPI32.DLL now:    tGetLocationInfo,
    tRequestDrop,
    tRequestMakeCall,
    tRequestMediaCall,
//    tMarkLineEvent,
    tReadLocations,
    tWriteLocations,
    tAllocNewID,
    tPerformance,
    lConditionalMediaDetection,  //remotesp
    lSelectExtVersion,
    pSelectExtVersion,      // remotesp
//    lOpenInt,
//    lShutdownInt,

    //
    // Ordinals for tapi 2.1 ended here.  the lOpenInt & lShutdownInt
    // were Win95 local-machine-only hacks which have since been removed
    //

    xNegotiateAPIVersionForAllDevices, // remotesp

    mGetAvailableProviders,
    mGetLineInfo,
    mGetPhoneInfo,
    mGetServerConfig,
    mSetLineInfo,
    mSetPhoneInfo,
    mSetServerConfig,

    //
    // Ordinals for 2.1 update (nt4 sp4) ended here.
    //

    lMSPIdentify,
    lReceiveMSPData,

    lGetCallHubTracking,
    lGetCallIDs,
    lGetHubRelatedCalls,
    lSetCallHubTracking,
    xPrivateFactoryIdentify,
    lDevSpecificEx,
    lCreateAgent,
    lCreateAgentSession,
    lGetAgentInfo,
    lGetAgentSessionInfo,
    lGetAgentSessionList,
    lGetQueueInfo,
    lGetGroupList,
    lGetQueueList,
    lSetAgentMeasurementPeriod,
    lSetAgentSessionState,
    lSetQueueMeasurementPeriod,
    lSetAgentStateEx,
    lGetProxyStatus,
    lCreateMSPInstance,
    lCloseMSPInstance,

    //
    // The following is always the last one in the list
    //

    xLastFunc

} FUNC_TYPE;



typedef struct _CLIENT_THREAD_INFO
{
    LIST_ENTRY  TlsList;

    LPBYTE      pBuf;

    DWORD       dwBufSize;

} CLIENT_THREAD_INFO, *PCLIENT_THREAD_INFO;


typedef struct _TAPI32_MSG
{
    //
    // The following union is used:
    //
    //   1. by requests from client to server to specify a function type
    //   2. by acks from server to client to specify a return value
    //   3. by async msgs from server to client to specify msg type
    //

    union
    {
        DWORD       Req_Func;

        LONG_PTR    Ack_ReturnValue;

        DWORD       Msg_Type;

    } u;


    //
    // The following...
    //

    ULONG_PTR       hRpcClientInst;


    //
    // Function paramters
    //

    ULONG_PTR       Params[MAX_TAPI_FUNC_ARGS];

} TAPI32_MSG, *PTAPI32_MSG;


typedef struct _ASYNCEVENTMSG
{
    ULONG_PTR               TotalSize;
    ULONG_PTR               InitContext;
    ULONG_PTR               pfnPostProcessProc;
    ULONG_PTR               hDevice;

    ULONG_PTR               Msg;
    ULONG_PTR               OpenContext;
    ULONG_PTR               Param1;
    ULONG_PTR               Param2;

    ULONG_PTR               Param3;
    ULONG_PTR               Param4;

} ASYNCEVENTMSG, *PASYNCEVENTMSG;


typedef void (PASCAL *POSTPROCESSPROC)(PASYNCEVENTMSG pMsg);


typedef struct _ASYNC_EVENT_PARAMS
{
    DWORD                   hDevice;
    DWORD                   dwMsg;
    ULONG_PTR               dwCallbackInstance;
    ULONG_PTR               dwParam1;

    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;

} ASYNC_EVENT_PARAMS, *PASYNC_EVENT_PARAMS;


typedef LONG (PASCAL *TUISPIPROC)();


typedef struct _UITHREADDATA
{
    HTAPIDIALOGINSTANCE     htDlgInst;
    HINSTANCE               hUIDll;
    HANDLE                  hThread;
    HANDLE                  hEvent;

    LPVOID                  pParams;
    DWORD                   dwSize;
    TUISPIPROC              pfnTUISPI_providerGenericDialog;
    TUISPIPROC              pfnTUISPI_providerGenericDialogData;

    struct _UITHREADDATA   *pPrev;
    struct _UITHREADDATA   *pNext;

} UITHREADDATA, *PUITHREADDATA;


typedef struct _PROXYREQUESTHEADER
{
    DWORD                   dwKey;

    DWORD                   dwInstance;

} PROXYREQUESTHEADER, *PPROXYREQUESTHEADER;


#if DBG
extern char    gszDebug[];
#endif
//extern const char    gszLocation[];
//extern const char    gszLocations[];
extern const char    gszCurrentLocation[];
extern const CHAR    gszNullString[];


#if DBG
#define ClientAlloc( __size__ ) ClientAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

#else
#define ClientAlloc( __size__ ) ClientAllocReal( __size__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize
    );

#endif
    
SIZE_T
WINAPI
ClientSize(
    LPVOID  lp
    );

void
WINAPI
ClientFree(
    LPVOID  lp
    );



LONG
WINAPI
MarkLineEvent(
    DWORD           dwApiVersion,
    DWORD           ptLine,
    DWORD           ptLineClientToExclude,
    DWORD           dwMsg,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwParam3
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapitna\privateold.h ===
extern HINSTANCE ghUIInst;
//extern const WCHAR     gszCardKeyW[];

//***************************************************************************
//***************************************************************************
//***************************************************************************
void AllocNewID( HKEY MainKey, LPDWORD lpdw );
void PASCAL WideStringToNotSoWideString( LPBYTE lpBase, LPDWORD lpdwThing );
PWSTR PASCAL MultiToWide( LPCSTR  lpStr );
PWSTR PASCAL NotSoWideStringToWideString( LPCSTR lpStr, DWORD dwLength );



//***************************************************************************
//***************************************************************************
//***************************************************************************
typedef enum
{
    Dword,
    lpDword,
    hXxxApp,
    hXxxApp_NULLOK,
//    lpsz,
    lpszW,
    lpGet_SizeToFollow,
    lpSet_SizeToFollow,
    lpSet_Struct,
    lpGet_Struct,
    Size,
    Hwnd

} ARG_TYPE;


typedef struct _FUNC_ARGS
{
    DWORD               Flags;

    ULONG_PTR           Args[MAX_TAPI_FUNC_ARGS];

    BYTE                ArgTypes[MAX_TAPI_FUNC_ARGS];

} FUNC_ARGS, *PFUNC_ARGS;


typedef struct _UI_REQUEST_THREAD_PARAMS
{
    BOOL                bRequestCompleted;

    PFUNC_ARGS          pFuncArgs;

    LONG                lResult;

} UI_REQUEST_THREAD_PARAMS, *PUI_REQUEST_THREAD_PARAMS;


typedef struct _INIT_DATA
{
    DWORD               dwKey;

    DWORD               dwInitOptions;

    union
    {
        HWND            hwnd;

        HANDLE          hEvent;

        HANDLE          hCompletionPort;
    };

    union
    {
        LINECALLBACK    lpfnCallback;

        DWORD           dwCompletionKey;
    };

    HLINEAPP            hXxxApp;

    BOOL                bPendingAsyncEventMsg;

    DWORD               dwNumTotalEntries;

    DWORD               dwNumUsedEntries;

    PASYNC_EVENT_PARAMS pEventBuffer;

    PASYNC_EVENT_PARAMS pValidEntry;

    PASYNC_EVENT_PARAMS pFreeEntry;

    DWORD               dwNumLines;

    BOOL                bLine;

    DWORD               dwThreadID;

} INIT_DATA, *PINIT_DATA;



#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

DWORD   gdwDebugLevel;

#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    );

#else

#define DBGOUT(arg)

#define DOFUNC(arg1,arg2) DoFunc(arg1)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapitna\general.c ===
#include <windows.h>
#include <windowsx.h>

#if WINNT
#else
#include <help.h>
#endif

#include "tchar.h"
#include "prsht.h"

//#define TAPI_API_VERSION  0x00020000
#define TAPI_API_VERSION  0x00010004
#define TAPI_CURRENT_VERSION 0x00010004

#include "tapi.h"

#undef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#include "tspi.h"
#undef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00010004

#include "clientr.h"
#include "client.h"
#include "privateold.h"

#include "general.h"



#if DBG
#define InternalDebugOut(_x_) DbgPrt _x_
garbage;
#else
#define InternalDebugOut(_x_)
#endif


//***************************************************************************

TCHAR gszCurrentProfileKey[] = "System\\CurrentControlSet\\Control\\Telephony";
TCHAR gszStaticProfileKey[]  = "Config\\%04d\\System\\CurrentControlSet\\Control\\Telephony";
TCHAR gszAutoLaunchKey[]     = "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";
TCHAR gszAutoLaunchValue[]   = "AutoLaunchFlags";
TCHAR gszAutoLocationID[]    = "AutoLocationID";


UINT  gnNumConfigProfiles = 0;
DWORD gdwConfigProfiles[MAX_CONFIGPROFILES];



//***************************************************************************
//***************************************************************************
//***************************************************************************
//Purpose: Gets the appropriately sized translate caps structure
//         from TAPI.  Return TRUE if successful


#define LOCATION_GROW   4


BOOL GetTranslateCaps(
    LPLINETRANSLATECAPS FAR * pptc)
{
    LONG lineErr;
    LPLINETRANSLATECAPS ptc;
    DWORD cbSize;

    cbSize = sizeof(*ptc) * LOCATION_GROW + 200;
    ptc = (LPLINETRANSLATECAPS)GlobalAllocPtr(GPTR, cbSize);
    if (ptc)
        {
        // Get the translate devcaps
        ptc->dwTotalSize = cbSize;
        lineErr = lineGetTranslateCaps (0, TAPI_API_VERSION, ptc);
        if (LINEERR_STRUCTURETOOSMALL == lineErr ||
            ptc->dwNeededSize > ptc->dwTotalSize)
            {
            // Provided structure was too small, resize and try again
            cbSize = ptc->dwNeededSize;
            GlobalFreePtr(ptc);
            ptc = (LPLINETRANSLATECAPS)GlobalAllocPtr(GPTR, cbSize);
            if (ptc)
                {
                ptc->dwTotalSize = cbSize;
                lineErr = lineGetTranslateCaps (0, TAPI_API_VERSION, ptc);
                if (0 != lineErr)
                    {
                    // Failure
                    GlobalFreePtr(ptc);
                    ptc = NULL;
                    }
                }
            }
        else if (0 != lineErr)
            {
            // Failure
            GlobalFreePtr(ptc);
            ptc = NULL;
            }
        }

    *pptc = ptc;

    return NULL != *pptc;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
//
// WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  
// Returns 1 if a problem, 0 if no problem
// Code below assumes that this function ONLY returns 0 or 1 (but I think
// it would be confusing to have the rettype be BOOL, since we want a
// return of '1' on a problem...)
//
LONG FillConfigProfileBox( HWND hWnd,
                           DWORD dwControl,
                           LPLINETRANSLATECAPS ptc)
{
   UINT n;
   DWORD nProfileNumberZ;
   WPARAM wIndex;
   LINELOCATIONENTRY *ple;
   HKEY hKey;
   TCHAR szValueName[40];
   TCHAR buf[256];
   DWORD dwType;
   DWORD dwDataSize;
   LPSTR lpstrProfileLocation = NULL;
   LONG  lResult;


   //
   // Get the zero-based Config Profile Number
   //
   nProfileNumberZ = dwControl - IDCB_DL_PROFILE1;


   //
   // Get the profile's name.  If this fails, we assume we've run out
   // of configs
   //
   RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   "System\\CurrentControlSet\\Control\\IDConfigDB",
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );

   wsprintf( szValueName, "FriendlyName%04d", nProfileNumberZ + 1);

   dwDataSize = sizeof(buf);

   lResult = RegQueryValueEx(
                              hKey,
                              szValueName,
                              0,
                              &dwType,
                              buf,
                              &dwDataSize
                            );

   RegCloseKey( hKey );


   //
   // Did we find a name for it?
   //
   if ( ERROR_SUCCESS != lResult )
   {
      return (1);
   }

   //
   // Put whatever we found into the field
   //
   SendMessage( GetDlgItem( hWnd, IDCS_DL_PROFILE1 + nProfileNumberZ ),
                WM_SETTEXT,
                0,
                (LPARAM)&buf
              );


   //
   // Read what location ID is currently specified for this profile
   //
   wsprintf( buf, gszStaticProfileKey, nProfileNumberZ + 1);

   RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   buf,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );

   dwDataSize = sizeof(DWORD);

   lResult = RegQueryValueEx(
                           hKey,
                           gszAutoLocationID,
                           0,
                           &dwType,
                           (LPBYTE)&gdwConfigProfiles[ nProfileNumberZ ],
                           &dwDataSize
                         );

   RegCloseKey( hKey );


   //
   // If there's no value (maybe it's the first run), use current location
   //
   if (lResult != ERROR_SUCCESS)
   {
      gdwConfigProfiles[nProfileNumberZ] = ptc->dwCurrentLocationID;
   }


   for (n=0; n<ptc->dwNumLocations; n++)
   {
      ple = (LINELOCATIONENTRY*) ((LPSTR)ptc + ptc->dwLocationListOffset);

      wIndex = SendMessage( GetDlgItem(hWnd, dwControl),
                   CB_ADDSTRING,
                   0,
                   (LPARAM)((LPSTR)ptc + ple[n].dwLocationNameOffset));

      SendMessage( GetDlgItem( hWnd, dwControl),
                   CB_SETITEMDATA,
                   wIndex,
                   ple[n].dwPermanentLocationID
                 );


//{
////   UINT temp;
//
//   wsprintf( buf, "prof=%d loop=%d   s=%s  dw=%ld seek=%ld",
//                   nProfileNumberZ,
//                   n,
//                   (LPARAM)((LPSTR)ptc + ple[n].dwLocationNameOffset),
//                   (DWORD)ple[n].dwPermanentLocationID,
//                   (DWORD)gdwConfigProfiles[nProfileNumberZ]);
//
//   MessageBox(GetFocus(), buf, "", MB_OK);
//}


      //
      // If this location is the one this profile wants, select it
      //
      if ( gdwConfigProfiles[nProfileNumberZ] == ple[n].dwPermanentLocationID )
      {
//MessageBox(GetFocus(), "Found profile locationID", "", MB_OK);

         lpstrProfileLocation = (LPSTR)((LPSTR)ptc + ple[n].dwLocationNameOffset);
      }

   }


//{
////   UINT temp;
//
//   wsprintf( buf, "profile=%ld loop=%ld   s=%s",
//                   (DWORD)nProfileNumberZ,
//                   (DWORD)n,
//                   (LPARAM)((LPSTR)ptc + ple[n].dwLocationNameOffset));
//   MessageBox(GetFocus(), buf, "", MB_OK);
//}


   SendMessage( GetDlgItem( hWnd, dwControl),
                CB_SELECTSTRING,
                (WPARAM)-1,
                (LPARAM)lpstrProfileLocation
              );


   return ERROR_SUCCESS;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL
CALLBACK
GeneralDlgProc(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static DWORD aIds[] = {
        0, 0
    };

    UINT n;
    LONG lResult;
    HKEY hKey;
    static DWORD dwType;
    static DWORD dwDataSize;

    static DWORD dwTapiTNAFlags = 0;
// these values are in GENERAL.H
//       #define FLAG_AUTOLAUNCH            0x00000001
//       #define FLAG_AUTOLOCATIONID        0x00000002
//       #define FLAG_PROMPTAUTOLOCATIONID  0x00000004
//       #define FLAG_ANNOUNCEAUTOLOCATIONID   0x00000008

    LPLINETRANSLATECAPS ptc;



    switch (msg)
    {
       case WM_INITDIALOG:
       {

          GetTranslateCaps(&ptc);
          //BUGBUG What if this fails?


//BUGBUG If the number of hardware configs == 1, don't bother showing these
          //
          // Fill up the Hardware config boxes
          //

          if ( ptc )
          {
             lResult = ERROR_SUCCESS;

             for (
                   n=0;
                   (n<MAX_CONFIGPROFILES) && (ERROR_SUCCESS == lResult);
                   n++
                 )
             {
                lResult = FillConfigProfileBox( hWnd,
                                                IDCB_DL_PROFILE1 + n,
                                                ptc );
             }

             gnNumConfigProfiles = n - lResult;

             GlobalFreePtr( ptc );
          }


          //
          // Now go disable all the stuff not being used
          // 
          for ( n=gnNumConfigProfiles; n<MAX_CONFIGPROFILES; n++)
          {
             ShowWindow( GetDlgItem( hWnd, IDCB_DL_PROFILE1 + n),
                         SW_HIDE
                       );
             ShowWindow( GetDlgItem( hWnd, IDCS_DL_PROFILE1 + n),
                         SW_HIDE
                       );
          }


          //
          // Get the TapiTNA flags
          //

          lResult = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszAutoLaunchKey,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey
                    );


          dwDataSize = sizeof(dwTapiTNAFlags);

          lResult = RegQueryValueEx(
                                     hKey,
                                     gszAutoLaunchValue,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwTapiTNAFlags,
                                     &dwDataSize
                                   );

          RegCloseKey( hKey );


          //
          // Now check the boxes as appropriate
          //

          if ( dwTapiTNAFlags & FLAG_AUTOLAUNCH )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_LAUNCHTAPITNA,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_AUTOLOCATIONID )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_AUTOLOCATIONID,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_UPDATEONSTARTUP )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_UPDATEONSTARTUP,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_PROMPTAUTOLOCATIONID )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_PROMPTAUTOLOCATIONID,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_ANNOUNCEAUTOLOCATIONID )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_ANNOUNCEAUTOLOCATIONID,
                             TRUE
                           );
          }


          //
          // Disable the two checkboxes dependent on this one,
          // but keep the settings
          //
          if ( dwTapiTNAFlags & FLAG_AUTOLOCATIONID )
          {
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                           TRUE
                         );
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                           TRUE
                         );
          }
          else
          {
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                           FALSE
                         );
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                           FALSE
                         );
          }


       }
       break;


       // Process clicks on controls after Context Help mode selected
       case WM_HELP:
           InternalDebugOut((50, "  WM_HELP in LocDefineDlg"));
           WinHelp (((LPHELPINFO) lParam)->hItemHandle, "windows.hlp", HELP_WM_HELP, 
                                           (ULONG_PTR)(LPSTR) aIds);
           break;


       // Process right-clicks on controls            
       case WM_CONTEXTMENU:
           InternalDebugOut((50, "  WM_CONTEXT_MENU in LocationsDlgProc"));
           WinHelp ((HWND) wParam, "windows.hlp", HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID) aIds);
           break;


       case WM_NOTIFY:
       {
          LPNMHDR lpnm = (LPNMHDR)lParam;

          switch ( lpnm->code )
          {

             case PSN_APPLY: /* case IDOK */
             {
                DWORD dwDisposition;   // Don't really care about this...


                InternalDebugOut((0, "  PSN_APPLY - General"));

                if ( ((LPPSHNOTIFY)lpnm)->lParam )
                   InternalDebugOut((0, "     (actually, it was the OK button)"));


                //
                // Write out the new flags
                //

                lResult = RegCreateKeyEx(
                                          HKEY_LOCAL_MACHINE,
                                          gszAutoLaunchKey,
                                          0,
                                          "", //Class?  Who cares?
                                          REG_OPTION_NON_VOLATILE,
                                          KEY_ALL_ACCESS,
                                          NULL,
                                          &hKey,
                                          &dwDisposition
                                        );


                if (ERROR_SUCCESS == lResult)
                {
                    lResult = RegSetValueEx(
                                              hKey,
                                              gszAutoLaunchValue,
                                              0,
                                              dwType,
                                              (LPBYTE)&dwTapiTNAFlags,
                                              dwDataSize
                                            );

                    RegCloseKey( hKey );
                }




                for ( n=0;  n < gnNumConfigProfiles; n++)
                {
                   DWORD dwTemp;
                   TCHAR szKeyName[128];


                   wsprintf ( szKeyName, gszStaticProfileKey, n+1);

                   RegCreateKeyEx(
                                   HKEY_LOCAL_MACHINE,
                                   szKeyName,
                                   0,
                                   "",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hKey,
                                   &dwTemp
                                 );

                   RegSetValueEx(
                                    hKey,
                                    gszAutoLocationID,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)&gdwConfigProfiles[n],
                                    sizeof(DWORD)
                               );

                   RegCloseKey( hKey );

                }

                break;
             }


             case  PSN_RESET:        /* case IDCANCEL: */
                InternalDebugOut((0, "  PSN_RESET - General"));
                break;


#if DBG     
             case PSN_SETACTIVE:
                InternalDebugOut((0, "  PSN_SETACTIVE - General"));
                break;


             case PSN_KILLACTIVE:
                InternalDebugOut((0, "  PSN_KILLACTIVE - General"));
                break;

#endif

          }
       }
       break;


       case WM_COMMAND:
       {
          switch (LOWORD(wParam))
          {

             case IDCB_DL_PROFILE1:
             case IDCB_DL_PROFILE2:
             case IDCB_DL_PROFILE3:
             case IDCB_DL_PROFILE4:
             {

                //
                // Only process if something is changing
                //
                switch  HIWORD(wParam)
                {
                   case  CBN_SELCHANGE:
                   {
                      LRESULT m;


                      gdwConfigProfiles[LOWORD(wParam) - IDCB_DL_PROFILE1] =
                            n = (UINT) SendMessage( GetDlgItem( hWnd, LOWORD(wParam)),
                                         CB_GETITEMDATA,
                                       ( m= SendMessage(
                                                      GetDlgItem( hWnd,
                                                                  LOWORD(wParam)),
                                                      CB_GETCURSEL,
                                                      0,
                                                      0
                                                    ) ) ,
                                         0
                                       );

//{
//   TCHAR Buffer[256];
//   wsprintf( Buffer, "wParam=0x%08lx lParam=0x%08lx data=0x%08lx m=0x%08lx",
//                     (DWORD)wParam,
//                     (DWORD)lParam,
//                     (DWORD)n,
//                     (DWORD)m
//           );
//   MessageBox(GetFocus(), Buffer, "", MB_OK);
//}

                      //
                      // Activate the APPLY button if not already done
                      //
                      PropSheet_Changed(GetParent(hWnd), hWnd);
                   }
                }
             }
             break;


             case IDCK_DL_LAUNCHTAPITNA:
             {
                dwTapiTNAFlags ^= FLAG_AUTOLAUNCH;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_AUTOLOCATIONID:
             {
                dwTapiTNAFlags ^= FLAG_AUTOLOCATIONID;

                //
                // Disable the two checkboxes dependent on this one,
                // but keep the settings
                //
                if ( dwTapiTNAFlags & FLAG_AUTOLOCATIONID )
                {
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                                 TRUE
                               );
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                                 TRUE
                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_PROMPTAUTOLOCATIONID),
//                                 TRUE
//                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_ANNOUNCEAUTOLOCATIONID),
//                                 TRUE
//                               );
                }
                else
                {
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                                 FALSE
                               );
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                                 FALSE
                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_PROMPTAUTOLOCATIONID),
//                                 FALSE
//                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_ANNOUNCEAUTOLOCATIONID),
//                                 FALSE
//                               );
                }


                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_PROMPTAUTOLOCATIONID:
             {
                dwTapiTNAFlags ^= FLAG_PROMPTAUTOLOCATIONID;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_UPDATEONSTARTUP:
             {
                dwTapiTNAFlags ^= FLAG_UPDATEONSTARTUP;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_ANNOUNCEAUTOLOCATIONID:
             {
                dwTapiTNAFlags ^= FLAG_ANNOUNCEAUTOLOCATIONID;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             default:
             {
             }
             break;

          }
       }
       break;


       default:
       break;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapitna\tapitna.c ===
/****************************************************************************

    PROGRAM:  Telephony Location Manager

    PURPOSE:

    FUNCTIONS:

****************************************************************************/

#define STRICT

#include "windows.h"
#include "windowsx.h"
#include "shellapi.h"
#include "prsht.h"
#include "dbt.h"
//#include "stdio.h"

#if WINNT
#else
#include "pbt.h"
#endif

#include "tapi.h"
#include "tapitna.h"

#include "clientr.h"
#include "general.h"


#if DBG
#define DBGOUT(arg) DbgPrt arg
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PTCHAR DbgMessage,
    IN ...
    );
#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)
#else
#define DBGOUT(arg)
#define DOFUNC(arg1,arg2) DoFunc(arg1)
#endif




int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, int );
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message,
                              WPARAM wParam, LPARAM lParam);
static BOOL InitApplication( void );
static BOOL InitInstance( void );


static HINSTANCE ghInst;
static HWND   ghWnd;            /* handle to main window */

static const TCHAR gszConfigMe[] = TEXT("ConfigMe");


LPDWORD lpdwLocationIDs = NULL;
TCHAR buf[356];
TCHAR buf2[356];
int i;


//***************************************************************************
//***************************************************************************
//***************************************************************************

//#define TAPI_API_VERSION  0x00020000
#define TAPI_API_VERSION  0x00010004



//***************************************************************************

extern TCHAR gszCurrentProfileKey[];
extern TCHAR gszStaticProfileKey[];
extern TCHAR gszAutoLaunchKey[];
extern TCHAR gszAutoLaunchValue[];
extern TCHAR gszAutoLocationID[];


extern BOOL GetTranslateCaps( LPLINETRANSLATECAPS FAR * pptc);

//***************************************************************************


// Need to keep tapi initialized so that we can get
// location id changes from Xlate dialog (or lineSetCurrentLocation()...)

HLINEAPP ghLineApp = 0;
//DWORD    gdwTapiAPIVersion = 0;


//***************************************************************************

//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL MachineHasMultipleHWProfiles()
{
   DWORD dwDataSize;
   DWORD dwDataType;
   HKEY  hKey;
   LONG  lResult;


   //
   // Try to get the friendly name for profile #2.  If
   // this fails, that means we only have one config,
   // so there's no point in confusing the user with
   // hotdocking options they can't use...
   //
   lResult = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB"),
                  0,
                  KEY_READ,
                  &hKey
                  );

   if (ERROR_SUCCESS == lResult)
   {
       dwDataSize = sizeof(buf);

       lResult = RegQueryValueEx(
                                  hKey,
                                  TEXT("FriendlyName0002"),
                                  0,
                                  &dwDataType,
                                  (LPBYTE)buf,
                                  &dwDataSize
                               );

       RegCloseKey( hKey );
   }


   return ( ERROR_SUCCESS == lResult);
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG SaveNewLocation( DWORD dwNewLocation )
{
   HKEY hKey;
   DWORD dwTemp;
   LONG lResult;


   //
   // Ok, the user wants to change the location
   //
   DBGOUT((0, TEXT("SaveNewLocation...")));
   {
      //
      // Update the AutoLocationID entry in the current
      // profile config
      //
      lResult = RegCreateKeyEx(
                     HKEY_CURRENT_CONFIG,
                     gszCurrentProfileKey,
                     0,
                     TEXT(""),
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS,
                     NULL,
                     &hKey,
                     &dwTemp
                  );

      if ( 0 == lResult )
      {
         lResult = RegSetValueEx(
                        hKey,
                        gszAutoLocationID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNewLocation,
                        sizeof(DWORD)
                     );

         RegCloseKey( hKey );
      }
   }



   return lResult;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID PASCAL TapiCallbackProc( DWORD hDevice, DWORD dwMsg, DWORD dwCallbackInstance,
                  DWORD dwParam1, DWORD dwParam2, DWORD dwParam3 )
{
   TCHAR buf[256];


//{
//char buf[100];
//wsprintf(buf, "dwMsg=0x%08lx  dwParam1=0x%08lx  dwParam2=0x%08lx  dwParam3=0x%08lx",
//               dwMsg, dwParam1, dwParam2, dwParam3 );
//MessageBox(GetFocus(), buf, "LINEDEVSTATE", MB_OK);
//}


//
// Since we don't bother doing a negotiate (like, cause if there are no
// devices, we _can't_, so why bother at all?), we use the 1.4 cheat of
// looking at dwParam2 and dwParam3 on a REINIT for the real dwMsg and
// dwParam1
//


   if (
         (dwMsg == LINE_LINEDEVSTATE)
       &&
         (dwParam1 == LINEDEVSTATE_REINIT)
      )
   {

      if (
         (dwParam2 == LINE_LINEDEVSTATE)
       &&
         (dwParam3 == LINEDEVSTATE_TRANSLATECHANGE)
      )
      {
         LPLINETRANSLATECAPS ptc;

DBGOUT((0,TEXT("XlateChange!!")));

         if ( GetTranslateCaps(&ptc) )
         {
            SaveNewLocation( ptc->dwCurrentLocationID );
            GlobalFreePtr(ptc);
         }
      }
      else
      if (
         (dwParam2 == 0)
       &&
         (dwParam3 == 0)
      )
      {
         LONG lResult=1;
         UINT nTooManyTries;
         DWORD dwNumDevs;

DBGOUT((0,TEXT("Reinit!!")));

         lineShutdown( ghLineApp );

         LoadString( ghInst,
                     IDS_CAPTION,
                     buf,
                     sizeof(buf) );


         for ( nTooManyTries=0;
               (nTooManyTries<500) && (lResult != 0);
               nTooManyTries++)
         {
            Sleep(1000);
            lResult = lineInitialize( &ghLineApp,
                                       ghInst,
                                       // use the MainWndProc as the callback
                                       // cause we're gonna ignore all of the
                                       // messages anyway...
                                       (LINECALLBACK) TapiCallbackProc,
                                       (LPCSTR) buf,
                                       &dwNumDevs
                                    );
         }
      }

   }

}



//***************************************************************************
//***************************************************************************
//***************************************************************************
void ChangeTapiLocation( UINT nCallersFlag )
{
   HKEY hKey;
   DWORD dwNewLocationID;
   DWORD dwSize = sizeof(dwNewLocationID);
   DWORD dwType;
   DWORD dwMyFlags = 0;
   LONG  lResult;


   //
   // read our flags
   //

   lResult = RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   gszAutoLaunchKey,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );



   if (ERROR_SUCCESS == lResult)
   {
       RegQueryValueEx(
                        hKey,
                        TEXT("AutoLaunchFlags"),
                        0,
                        &dwType,
                        (LPBYTE)&dwMyFlags,
                        &dwSize
                      );

       RegCloseKey( hKey );
   }


   //
   // If the user doesn't want to get involved, 
   // let's get out now.
   //
   if ( 0 == (dwMyFlags & nCallersFlag) )
   {
      return;
   }


   lResult = RegOpenKeyEx(
                   HKEY_CURRENT_CONFIG,
                   gszCurrentProfileKey,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );


   if ( ERROR_SUCCESS == lResult )
   {
      dwSize = sizeof(dwNewLocationID);
      
      lResult = RegQueryValueEx(
                                  hKey,
                                  gszAutoLocationID,
                                  0,
                                  &dwType,
                                  (LPBYTE)&dwNewLocationID,
                                  &dwSize
                               );

   }
#if DBG
   else
   {
MessageBox( GetFocus(), TEXT("...and there's no key"), TEXT("Config changed"), MB_OK);
   }
#endif


   //
   // Did we find the key\value?
   //
   if ( ERROR_SUCCESS == lResult )
   {
      LONG  lTranslateCapsResult;
      LPLINETRANSLATECAPS ptc;


      //
      // Ok, the user wants to change the location
      //
      lTranslateCapsResult = GetTranslateCaps(&ptc);


      //
      // If the location to be set to is the same as the
      // current, do nothing.
      //
      if ( ptc &&
           ptc->dwCurrentLocationID != dwNewLocationID )
      {
         //
         // Check flag - should we confirm with user?
         //
         if ( dwMyFlags & FLAG_PROMPTAUTOLOCATIONID )
         {
         }


         DBGOUT((0, TEXT("ChangeLocation...")));
         lineSetCurrentLocation( ghLineApp, dwNewLocationID );


DBGOUT((0,TEXT("Done.")));


         //
         // Should we tell the user what we've done?
         //
         if ( dwMyFlags & FLAG_ANNOUNCEAUTOLOCATIONID )
         {
            LPTSTR pstrOldLocation = NULL;
            LPTSTR pstrNewLocation = NULL;


//FEATUREFEATURE Tell the user from what location and to what location

            if ( lTranslateCapsResult )
            {
                DWORD i;
                LPLINELOCATIONENTRY ple;
                DWORD dwCurLocID = ptc->dwCurrentLocationID;
                DWORD dwNumLocations = ptc->dwNumLocations;


                //
                // Allocate an array of DWORDs.  This will allow us
                // to map the menuID to the TAPI perm provider ID.
                //
                lpdwLocationIDs = GlobalAllocPtr( GMEM_FIXED, sizeof(DWORD)*dwNumLocations );


                //
                // Put each location in the menu.  When we hit the
                // "current" location, put a check next to it.
                //

                ple = (LPLINELOCATIONENTRY)((LPBYTE)ptc + ptc->dwLocationListOffset);

                for (i = 0; i < dwNumLocations; i++, ple++)
                {

                    if (ptc->dwCurrentLocationID ==
                        ple->dwPermanentLocationID)
                    {
                       pstrOldLocation = (LPTSTR)((LPBYTE)ptc + 
                                        ple->dwLocationNameOffset);
                    }

                    if (dwNewLocationID ==
                        ple->dwPermanentLocationID)
                    {
                       pstrNewLocation = (LPTSTR)((LPBYTE)ptc + 
                                        ple->dwLocationNameOffset);
                    }

                }

            }


            //
            // If the location has since been deleted, we should
            // say something about it.
            //

            if (
                  (NULL == pstrOldLocation)
                ||
                  (NULL == pstrNewLocation)
               )
            {
               LoadString( ghInst,
                           IDS_CANTFINDLOCATIONID,
                           buf2,
                           sizeof(buf2) );

               wsprintf( buf,
                         buf2,
                         dwNewLocationID
                       );
            }
            else
            {
               LoadString( ghInst,
                           IDS_LOCATIONCHANGED,
                           buf2,
                           sizeof(buf2) );

               wsprintf( buf,
                         buf2,
                         pstrOldLocation,
                         pstrNewLocation );

            }

            // We're done using buf2, so reuse it.
            LoadString( ghInst,
                        IDS_CAPTION,
                        buf2,
                        sizeof(buf2) );

            MessageBox(
                        NULL, //GetFocus(),
                        buf,
                        buf2, //  caption
                        MB_OK
                      );

         }

         GlobalFreePtr(ptc);
      }

   }
   else
   {
#if DBG
MessageBox( GetFocus(), TEXT("...and there's no key (or value)"), TEXT("Config changed"), MB_OK);
#endif

   }
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
PTSTR SkipSpaces( PTSTR const ptStr )
{
   PTSTR pStr = ptStr;
   while ( *pStr && (*pStr == ' ' ) )
   {
      pStr++;
   }

   return pStr;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPSTR lpCmdLine,  int nCmdShow)
    {
    MSG msg;
//    int nResult = 1;
//    UINT nSwitchLen;
    TCHAR *pCommandLine;
    TCHAR *pCommandLineSave;
//    TCHAR *pLastStart;
    DWORD dwParmLocationID;
    LONG  lResult;
    BOOL  fDieNow = FALSE;
    DWORD dwCommandLineLength;
    TCHAR buf[256];


    DBGOUT((0, TEXT("Main...")));
         
    ghInst = GetModuleHandle(0);


    if (InitApplication() == 0)
    {
        return (FALSE);
    }

    if (InitInstance() == 0)
    {
        return (FALSE);
    }


    {
       DWORD dwNumDevs;

       LoadString( ghInst,
                   IDS_CAPTION,
                   buf,
                   sizeof(buf) );

       //
       // We initialize TAPI and we never shutdown (except to reinit) so
       // we get notifications if someone changes the location from
       // the Dialing Properties dialog.
       //
       lineInitialize( &ghLineApp,
                       ghInst,
                       // use the MainWndProc as the callback
                       // cause we're gonna ignore all of the
                       // messages anyway...
                       (LINECALLBACK) TapiCallbackProc,
                       (LPCSTR) buf,
                       &dwNumDevs
                     );

    }


//----------------------
//    //
//    // If the user wants it, startup in the config dialog
//    // But we'll only do this if there is more than one HW config...
//    //
//    if ( MachineHasMultipleHWProfiles() )
//    {
//       //
//       // (We do a bunch of stuff "manually" here so we don't have to 
//       // drag in the entire MSVCRT20 for this one function...)
//       //
//       nSwitchLen = lstrlen(gszConfigMe);
//
//       //
//       // 'pLastStart' is the last possible char the string could start on
//       //
//       pLastStart = pCommandLine + 1 + (lstrlen(pCommandLine) - nSwitchLen);
//
//       for ( ; pCommandLine < pLastStart; pCommandLine++)
//       {
//          //
//          // Do a hack so we can use lstrcmpi
//          //
//          TCHAR c;
//
//          c = pCommandLine[nSwitchLen];
//          pCommandLine[nSwitchLen] = '\0';
//         
//          nResult = lstrcmpi( (LPSTR)pCommandLine, gszConfigMe );
//
//          pCommandLine[nSwitchLen] = c;
//
//          if (0 == nResult)
//          {
//             break;
//          }
//       }
//
//       //
//       // Did we find our string?
//       //
//       if ( 0 == nResult )
//       {
//          PostMessage(ghWnd, WM_COMMAND, IDM_PROPERTIES, 0);
//       }
//    }
//----------------------


    dwCommandLineLength = (lstrlen( GetCommandLine() ) + 1) * sizeof(TCHAR);

    pCommandLine = LocalAlloc( LPTR, dwCommandLineLength );
    pCommandLineSave = pCommandLine;  // We'll need this later to free it...

    lstrcpy( pCommandLine, GetCommandLine() );

    while ( *pCommandLine )
    {
       //
       // Is this an arg?
       //
       if (
             ('-' == *pCommandLine)
           ||
             ('/' == *pCommandLine)
          )
       {
          TCHAR c;

          //
          // Figger out what the arg is
          //

          pCommandLine = SkipSpaces( pCommandLine + 1 );


          //
          // Just looking?
          //
          if (
                ('?' == *pCommandLine)
              ||
                ('H' == *pCommandLine)
              ||
                ('h' == *pCommandLine)
             )
          {
             LoadString( ghInst,
                         IDS_HELP,
                         buf,
                         sizeof(buf) );

             LoadString( ghInst,
                         IDS_CAPTION,
                         buf2,
                         sizeof(buf2) );

             MessageBox(GetFocus(), buf, buf2, MB_OK);
//             MessageBox(NULL, buf, buf2, MB_OK);


             //
             // Ok, now that we're leaving, we can shut this down...
             //
             fDieNow = TRUE;
          }


          //
          // Is this a location die-now request?
          //
          if (
                ('X' == *pCommandLine)
              ||
                ('x' == *pCommandLine)
             )
          {
             fDieNow = TRUE;
          }


          //
          // Is this a location ID?
          //
          if (
                ('I' == *pCommandLine)
              ||
                ('i' == *pCommandLine)
             )
          {
             pCommandLine = SkipSpaces( pCommandLine + 1 );


             dwParmLocationID = 0;

             //
             // get digits
             //
             while (
                      (*pCommandLine >= '0')
                    &&
                      (*pCommandLine <= '9')
                   )
             {
                dwParmLocationID = ( dwParmLocationID * 10 ) + 
                                   (*pCommandLine - '0');

                pCommandLine++;
             }

             //
             // Now set the current location to the ID we just gathered
             //
             lResult = lineSetCurrentLocation( ghLineApp, dwParmLocationID );
   
             if ( 0 == lResult )
                 lResult = SaveNewLocation( dwParmLocationID );
                 
             if ( 0 != lResult )
             {
                LoadString( ghInst,
                            IDS_CANTFINDLOCATIONID,
                            buf2,
                            sizeof(buf2) );

                wsprintf( buf, buf2, dwParmLocationID);

                LoadString( ghInst,
                            IDS_CAPTION,
                            buf2,
                            sizeof(buf2) );

                //
                // Messagebox to tell the user what happened
                //
                MessageBox(
                           NULL,
                           buf,
                           buf2,
                           MB_OK | MB_ICONERROR
                          );
             }
          }


          //
          // Is this a location name?
          //
          if (
                ('N' == *pCommandLine)
              ||
                ('n' == *pCommandLine)
             )
          {
             LPLINETRANSLATECAPS ptc;
             PTSTR pszMyString;
             PTSTR pszMyStringPointer;

             pCommandLine = SkipSpaces( pCommandLine + 1 );

             //
             // We'll never need more than the entire command line's len...
             // (and that's better than some arbitraty large number)
             //
             pszMyString = LocalAlloc( LPTR, dwCommandLineLength );
             if (pszMyString == NULL)
             {
                return (FALSE);
             }

             pszMyStringPointer = pszMyString;

             pCommandLine = SkipSpaces( pCommandLine );

             while (
                      (*pCommandLine != '\0')
                    &&
                      (*pCommandLine != '/')
                    &&
                      (*pCommandLine != '-')
                   )
             {
                //
                // add this char to the string
                //
                *pszMyStringPointer = *pCommandLine;

                pszMyStringPointer++;
                pCommandLine++;
             }

             //
             // First, get back to the last char
             //
             pszMyStringPointer--;

             //
             // Now chop off any trailing spaces
             //
             while (
                      (' ' == *pszMyStringPointer)
                    &&
                      (pszMyStringPointer > pszMyString )
                   )
             {
                pszMyStringPointer--;
             }

             //
             // Set the end of the string to be the last non-space in the name
             //
             *(pszMyStringPointer + 1) = '\0';


             if (GetTranslateCaps(&ptc))
             {
                 DWORD i;
                 LPLINELOCATIONENTRY ple;
                 DWORD dwCurLocID = ptc->dwCurrentLocationID;
                 DWORD dwNumLocations = ptc->dwNumLocations;

DBGOUT((0, TEXT("There seem to be %ld locations - ptc=0x%08lx"), dwNumLocations,
                                      ptc));

                 //
                 // See if we can find the string...
                 //

                 ple = (LPLINELOCATIONENTRY)((LPBYTE)ptc + ptc->dwLocationListOffset);

                 for (i = 0; i < dwNumLocations; i++, ple++)
                 {

DBGOUT((0, TEXT("Location #%ld is [%s] at 0x%08lx"),
              i, 
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset),
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset) ));

                     if ( 0 == lstrcmpi( (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset),
                                    pszMyString
                                  )
                        )
                     {
                        dwParmLocationID = ple->dwPermanentLocationID;
                        break;
                     }
                 }


                 //
                 // Did we run the list without finding a match?
                 //
                 if ( i == dwNumLocations )
                 {
                    LoadString( ghInst,
                                IDS_CANTFINDLOCATIONNAME,
                                buf2,
                                sizeof(buf2) );

                    wsprintf( buf, buf2, pszMyString );

                    LoadString( ghInst,
                                IDS_CAPTION,
                                buf2,
                                sizeof(buf2) );

                    //
                    // Messagebox to tell the user what happened
                    //
                    MessageBox(
                               NULL,
                               buf,
                               buf2,
                               MB_OK | MB_ICONERROR
                              );

                     lResult = LINEERR_INVALLOCATION;
                  }
                  else
                  {
                      lResult = lineSetCurrentLocation( ghLineApp, dwParmLocationID );
                       
                      if ( 0 == lResult )
                          lResult = SaveNewLocation( dwParmLocationID );
                  }

                  GlobalFreePtr(ptc);

                  LocalFree( pszMyString );

             }

          }



          //
          // Is this parm "ConfigMe" ?
          //
          c = pCommandLine[ lstrlen( gszConfigMe ) ];

          if ( 0 == lstrcmpi( pCommandLine, gszConfigMe ) )
          {
             //
             // Found this arg.
             //

             //
             // If the user wants it, startup in the config dialog
             // But we'll only do this if there is more than one HW config...
             //
             if ( MachineHasMultipleHWProfiles() )
             {
                PostMessage( ghWnd, WM_COMMAND, IDM_PROPERTIES, 0 );
             }

             //
             // In either case, get past this arg
             //
             pCommandLine[ lstrlen( gszConfigMe ) ] = c;

             pCommandLine += lstrlen( gszConfigMe );
          }

       }
       else
       {
          pCommandLine++;
       }
    }


    LocalFree( pCommandLineSave );


    //
    // Go see if we should auto-update the TAPI location on startup
    //
    ChangeTapiLocation( FLAG_UPDATEONSTARTUP );

    //
    // Should we quit before we start?
    //
    if ( fDieNow )
    {
       DestroyWindow( ghWnd );
    }


    while (GetMessage(&msg, 0, 0, 0) != 0)
    {
       TranslateMessage(&msg);
       DispatchMessage(&msg);
    }


    //
    // Ok, now that we're leaving, we can shut this down...
    lineShutdown( ghLineApp );


    return ((int) msg.wParam);
    }


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

static BOOL InitApplication( void )
    {
    WNDCLASS  wc;

    wc.style          = 0;
    wc.lpfnWndProc    = MainWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = ghInst;
    wc.hIcon          = NULL;
    wc.hCursor        = NULL;
    wc.hbrBackground  = NULL;
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = TEXT("TLOCMGR_WINCLSS");

    return (RegisterClass(&wc));
    }


//***************************************************************************
//***************************************************************************
//***************************************************************************
static BOOL InitInstance( void )
    {
    ghWnd = CreateWindow(
             TEXT("TLOCMGR_WINCLSS"),
             NULL,
             WS_OVERLAPPED | WS_MINIMIZE,
             CW_USEDEFAULT,
             CW_USEDEFAULT,
             CW_USEDEFAULT,
             CW_USEDEFAULT,
             0,
             0,
             ghInst,
             0 );

    if (ghWnd == 0 )
    {
        return ( FALSE );
    }


    ShowWindow(ghWnd, SW_HIDE);


#if WINNT
#else
    RegisterServiceProcess( 0, RSP_SIMPLE_SERVICE);
#endif


    return (TRUE);
    }



//***************************************************************************
//***************************************************************************
//***************************************************************************
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message,
                              WPARAM wParam, LPARAM lParam)
{
    HICON hIcon;
    static DWORD dwCurrentChoice = 0;
    DWORD i;


    static NOTIFYICONDATA nid = {
                           sizeof(NOTIFYICONDATA),
                           0, //hWnd,
                           IDI_TAPITNAICON,
                           NIF_ICON | NIF_MESSAGE | NIF_TIP,
                           WM_USER+0x42,
                           0, //hIcon,
                           0 //pCaption
                        };


    switch ( message )
    {

#if WINNT
        case WM_POWER:
        {
           if (
                 (PWR_SUSPENDRESUME == LOWORD(wParam))
               ||
                 (PWR_CRITICALRESUME == LOWORD(wParam))
              )
           {
DBGOUT((0, TEXT("Power resume(normal or critical)")));
              ChangeTapiLocation( FLAG_UPDATEONSTARTUP );
           }
        }
        break;
#else
        case WM_POWERBROADCAST:
        {
           if (
                 (PBT_APMRESUMESUSPEND == wParam)
               ||
                 (PBT_APMRESUMESTANDBY == wParam)
               ||
                 (PBT_APMRESUMECRITICAL == wParam)
              )
           {
DBGOUT((0, TEXT("Power resume(normal or critical)")));
              ChangeTapiLocation( FLAG_UPDATEONSTARTUP );
           }
        }
        break;
#endif


        case WM_DEVICECHANGE:
        {
           switch (wParam)
           {

//              case DBT_DEVICEARRIVAL:
//MessageBox( GetFocus(), "DBT_DEVICEARRIVAL", "WM_DEVICECHANGE", MB_OK);
//                   break;
//
//              case DBT_DEVICEREMOVECOMPLETE:
//MessageBox( GetFocus(), "DBT_DEVICEREMOVECOMPLETE", "WM_DEVICECHANGE", MB_OK);
//                   break;
//
//              case DBT_MONITORCHANGE:
//MessageBox( GetFocus(), "DBT_MONITORCHANGE", "WM_DEVICECHANGE", MB_OK);
////                   lParam = new resolution   LOWORD=x  HIWORD=y
//                   break;



              case DBT_CONFIGCHANGED:
              {
DBGOUT((0, TEXT("DBG_CONFIGCHANGED")));
                 ChangeTapiLocation( FLAG_AUTOLOCATIONID );
              }
              break;

           }
        }
        break;



        case WM_SETTINGCHANGE:
        {
           //
           // Is it something we're interested in?
           //
//           if ( SPI_SETICONMETRICS == wParam )
           {
//              hIcon = LoadImage(ghInst,
//                                MAKEINTRESOURCE(IDI_TAPITNAICON),
//                                IMAGE_ICON,
//                                GetSystemMetrics(SM_CXSMICON),
//                                GetSystemMetrics(SM_CYSMICON),
//                                0);

              hIcon = LoadImage(ghInst,
                                MAKEINTRESOURCE(IDI_TAPITNAICON),
                                IMAGE_ICON,
                                0,
                                0,
                                0);

              Shell_NotifyIcon( NIM_MODIFY, &nid );

              return 0;
           }
//           else
//           {
//              return (DefWindowProc(hWnd, message, wParam, lParam));
//           }

        }
//        break;


        case WM_CREATE:
        {
           //
           // Well, we're not gonna create a window, but we can do other
           // stuff...
           //

           LoadString (ghInst, IDS_CAPTION, nid.szTip, sizeof (nid.szTip));

//           hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_TAPITNAICON) );
           hIcon = LoadImage(ghInst,
                             MAKEINTRESOURCE(IDI_TAPITNAICON),
                             IMAGE_ICON,
                                0,
                                0,
//                             GetSystemMetrics(SM_CXSMICON),
//                             GetSystemMetrics(SM_CYSMICON),
                             0);
//                                 IMAGE_ICON, 32, 32, 0);
//                                 IMAGE_ICON, 16, 16, 0);



           nid.hWnd  = hWnd;
           nid.hIcon = hIcon;


//           fResult = 
           Shell_NotifyIcon( NIM_ADD, &nid );


        }
        break;



        case WM_USER+0x42:
        {

           switch ( lParam )
           {
              case WM_LBUTTONDOWN:
              {
                 switch ( wParam )
                 {
                    case IDI_TAPITNAICON:
                    {
                       //
                       // User is left clicking on our icon.
                       //
                       PostMessage(hWnd, WM_COMMAND, IDM_LOCATIONMENU, 0L);
                    }
                    break;


                    default:
                    break;
                 }
              }
              break;



              case WM_LBUTTONDBLCLK:
              {
                 PostMessage(hWnd, WM_COMMAND, IDM_DIALINGPROPERTIES, 0L);
              }
              break;



              case WM_RBUTTONDOWN:
              {
                 switch ( wParam )
                 {
                    case IDI_TAPITNAICON:
                    {
                       //
                       // User is right clicking on our icon.  Now what?
                       //
                       //MessageBox(GetFocus(), "RCLICK", "RCLICK", MB_OK);
                       PostMessage(hWnd, WM_COMMAND, IDM_CONTEXTMENU, 0L);
                    }
                    break;


                    default:
                    break;
                 }
              }
              break;


              default:
              break;

           }
        }
        break;



        case WM_COMMAND:
            switch ( wParam )
            {

                case IDM_ABOUT:
                {
                   LoadString(ghInst, IDS_CAPTION, buf, sizeof(buf));
                   LoadString(ghInst, IDS_ABOUTTEXT, buf2, sizeof(buf2));
                   hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_TAPITNAICON) );
                   return ShellAbout(hWnd, buf, buf2, hIcon);
                }
                break;



                case IDM_CONTEXTMENU:
                {
                    HMENU popup;
                    HMENU subpopup;
                    POINT mousepos;
                    
                    popup = LoadMenu(ghInst,MAKEINTRESOURCE(IDR_RBUTTONMENU));

                    if(popup)
                    {
                       //
                       // So?  Is there more than one config?
                       //
                       if ( !MachineHasMultipleHWProfiles() )
                       {
                          //
                          // Nope, remove the hotdock options.  :-(
                          //
                          RemoveMenu( popup,
                                      IDM_PROPERTIES,
                                      MF_BYCOMMAND
                                    );
                       }


                       subpopup = GetSubMenu(popup, 0);

                       if (subpopup)
                       {
                           SetMenuDefaultItem(subpopup,IDM_DIALINGPROPERTIES,FALSE);

                           if(GetCursorPos(&mousepos))
                           {
                              SetForegroundWindow(ghWnd);
                              ShowWindow(ghWnd, SW_HIDE);
                              TrackPopupMenuEx( subpopup,
                                                TPM_LEFTALIGN |
                                                    TPM_LEFTBUTTON |
                                                    TPM_RIGHTBUTTON,
                                                mousepos.x,
                                                mousepos.y,
                                                ghWnd,
                                                NULL
                                              );
                           }

                           RemoveMenu(popup, 0, MF_BYPOSITION);
                           DestroyMenu(subpopup);
                       }

                       DestroyMenu(popup);
                    }
                        
                }
                break;


                case IDM_LOCATIONMENU:
                {
                    HMENU fakepopup = NULL;
                    POINT mousepos;
                    LPLINETRANSLATECAPS ptc;
                    UINT nPrefixSize;


                    fakepopup = CreatePopupMenu();


                    nPrefixSize = LoadString( ghInst,
                                IDS_SELECTNEWLOCATION,
                                buf,
                                sizeof(buf) );

//                    AppendMenu( fakepopup,
//                                MF_BYPOSITION | MF_STRING | MF_DISABLED, // | MF_GRAYED,
//                                0,
//                                buf
//                              );
//
//                    AppendMenu( fakepopup,
//                                MF_BYPOSITION | MF_STRING | MF_SEPARATOR,
//                                0,
//                                0
//                              );



                    if (GetTranslateCaps(&ptc))
                    {
                        LPLINELOCATIONENTRY ple;
                        DWORD dwCurLocID = ptc->dwCurrentLocationID;
                        DWORD dwNumLocations = ptc->dwNumLocations;

DBGOUT((0, TEXT("There seem to be %ld locations - ptc=0x%08lx"), dwNumLocations,
                                      ptc));

                        //
                        // Allocate an array of DWORDs.  This will allow us
                        // to map the menuID to the TAPI perm provider ID.
                        //
                        lpdwLocationIDs = GlobalAllocPtr( GMEM_FIXED, sizeof(DWORD)*dwNumLocations );


                        //
                        // Put each location in the menu.  When we hit the
                        // "current" location, put a check next to it.
                        //

                        ple = (LPLINELOCATIONENTRY)((LPBYTE)ptc + ptc->dwLocationListOffset);

                        for (i = 0; i < dwNumLocations; i++, ple++)
                        {

                            lpdwLocationIDs[i] = ple->dwPermanentLocationID;

                            //
                            // Now make a proper displayable string
                            lstrcpy( &buf[nPrefixSize],
                                     (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset)
                                   );

                            AppendMenu( fakepopup,
                                        MF_BYPOSITION |
                                           MF_STRING |
                                           MF_ENABLED |
                                           ((dwCurLocID == ple->dwPermanentLocationID) ?
                                              MF_CHECKED : 0),
                                        IDM_LOCATION0+i,
                                        buf
                                      );

DBGOUT((0, TEXT("Location #%ld is [%s] at 0x%08lx"),
              i, 
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset),
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset) ));

                            if (dwCurLocID == ple->dwPermanentLocationID)
                            {
                               dwCurrentChoice = IDM_LOCATION0+i;
                            }
                        }


                        GlobalFreePtr(ptc);
                    }
else
{
   DBGOUT((0, TEXT("Gettranscaps failed")));
}


                    if (fakepopup)
                    {
//                       SetMenuDefaultItem(fakepopup,0,MF_BYPOSITION);
                       GetCursorPos(&mousepos);
                       SetForegroundWindow(ghWnd);
    ShowWindow(ghWnd, SW_HIDE);
                       TrackPopupMenu(fakepopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON , mousepos.x, mousepos.y-20, 0, ghWnd, NULL);

                       DestroyMenu(fakepopup);
                    }



//                    {
//                       subpopup = GetSubMenu(fakepopup, 0);
//
//           //put a check next to the current location
//
//                       SetMenuDefaultItem(subpopup,0,MF_BYPOSITION);
//                       if(GetCursorPos(&mousepos))
//                       {
//                          SetForegroundWindow(ghWnd);
//                          TrackPopupMenuEx(subpopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON ,mousepos.x,mousepos.y,ghWnd,NULL);
//                       }
//                       RemoveMenu(popup, 0, MF_BYPOSITION);
//                       DestroyMenu(fakepopup);
//                       DestroyMenu(popup);
//                       DestroyMenu(subpopup);
//                    }

                }
                break;



                case IDM_DIALINGPROPERTIES:
                {
                      {

                      lineTranslateDialog(ghLineApp, 0, TAPI_API_VERSION, ghWnd, NULL);
ShowWindow( ghWnd, SW_HIDE );

//                      lineTranslateDialog(ghLineApp, 0, TAPI_API_VERSION, GetFocus(), NULL);

                      }
                }
                break;



                case IDM_PROPERTIES:
                {

#ifdef NASHVILLE_BUILD_FLAG

                   // Should we just hack into the TAPI dialing properties?

#else
                   HPROPSHEETPAGE  rPages[1];
                   PROPSHEETPAGE   psp;
                   PROPSHEETHEADER psh;


                   //
                   // Let's configure TAPITNA
                   //
                   psh.dwSize      = sizeof(psh);
                   psh.dwFlags     = PSH_DEFAULT;  //PSH_NOAPPLYNOW;
                   psh.hwndParent  = GetFocus(); //NULL; //hwnd;
                   psh.hInstance   = ghInst;
                   LoadString(ghInst, IDS_CAPTION, buf, sizeof(buf)/sizeof(TCHAR));
                   psh.pszCaption  = buf;
                   psh.nPages      = 0;
                   psh.nStartPage  = 0;
                   psh.phpage      = rPages;

                   psp.dwSize      = sizeof(psp);
                   psp.dwFlags     = PSP_DEFAULT;
                   psp.hInstance   = ghInst;
                   psp.pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
                   psp.pfnDlgProc  = (DLGPROC) GeneralDlgProc;

                   psp.lParam      = 0;

                   psh.phpage[psh.nPages] = CreatePropertySheetPage (&psp);

                   if (psh.phpage[psh.nPages])
                   {                  
                      psh.nPages++;
                   }

                   PropertySheet (&psh);
#endif

                }
                break;


//                case IDM_OTHERMENUITEM:
//                {
//                }
//                break;


                case IDM_LAUNCHDIALER:
                {
                   ShellExecute( ghWnd,
                                 NULL,
                                 TEXT("Dialer.exe"),
                                 NULL,
                                 NULL,
                                 SW_SHOWDEFAULT);
                }
                break;


                case IDM_CLOSEIT:
                {
                   DestroyWindow(ghWnd);
                }
                break;


                default:
                {
                   //
                   // Ok, we actually have to do work in this default.
                   // If the user has the location menu open and selects one,
                   // we deal with it here (instead of having 100 case
                   // statements).  This is the limitation: 100 locations is
                   // the max we put up with (would that many even display?).
                   //
                   if ( 
                         (wParam >= IDM_LOCATION0)
                       &&
                         (wParam <= IDM_LOCATION0 + 100)
                      )
                   {

                      //
                      // Ok, set this to be the new current location
                      //
// there's a bug in TAPI - either the docs or the code, but the following
// _should_ work but doesn't...
//                      lineSetCurrentLocation(NULL, currentlocation);


                      //
                      // If the user is selecting the same location,
                      // do nothing.
                      //
                      if ( dwCurrentChoice == wParam )
                      {
                      }
                      else
                      {
                         i = lineSetCurrentLocation( ghLineApp,
                                                     lpdwLocationIDs[wParam-IDM_LOCATION0] );
                          
                         if ( 0 == i )
                            SaveNewLocation( lpdwLocationIDs[wParam-IDM_LOCATION0] );
                      }

                      GlobalFreePtr( lpdwLocationIDs );
                      
                      return( TRUE );
                      
                   }
                   else
                   {
                      return (DefWindowProc(hWnd, message, wParam, lParam));
                   }

                }
                break;

            }
            break;


        case WM_DESTROY:
            Shell_NotifyIcon( NIM_DELETE, &nid );
            PostQuitMessage(0);
            break;

#if WINNT
#else
        case WM_ENDSESSION:
            if (wParam) {
                RegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE);
                DestroyWindow(hWnd);
            }
#endif


        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return (FALSE);
}


//{
//char buf[100];
//wsprintf(buf, "GetActiveWindwow() = 0x%08lx", (DWORD) GetActiveWindow());
//OutputDebugString(buf);
//}
//{
//char buf[60];
//wsprintf (buf, "fResult = 0x%08lx",
//                fResult);
//MessageBox(GetFocus(), buf, "", MB_OK);
//}






#if DBG


#include "stdarg.h"
#include "stdio.h"


VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PTCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = 0;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        TCHAR    buf[256] = TEXT("TLOCMGR: ");
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[8],
                  lpszFormat,
                  ap
                  );

        lstrcat(buf, TEXT("\n"));

        OutputDebugString(buf);

        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapiupr\location.h ===
#include "loc_comn.h"

extern PLOCATION gLocationList;
extern PLOCATION gpCurrentLocation;
extern UINT gnNumLocations;
extern UINT gnCurrentLocationID;

//***************************************************************************
//***************************************************************************
//***************************************************************************

LONG PASCAL GetLocationIndexFromID( UINT nID, PLOCATION pCallersList, UINT nCallersNumLocations );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapitna\tapitna.h ===
#if !defined(tapitna_h)
#define tapitna_h

#define IDM_CONTEXTMENU 203
#define IDM_DIALINGPROPERTIES    204
#define IDM_OTHERMENUITEM        205
#define IDM_LOCATIONMENU         206
#define IDM_LAUNCHDIALER         207
#define IDM_CLOSEIT              208
#define IDM_ABOUT                209
#define IDM_PROPERTIES           210


//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   

//This value is a base.  A menu is dynamically created with as many menuitems
//as there are locations.  The menuid starts with IDM_LOCATION0 and is
//incremented for each.  So, don't use any values above 700 (for how many?).

#define IDM_LOCATION0   700

//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   


#define IDS_CAPTION               401
#define IDS_SELECTNEWLOCATION     402
#define IDS_ABOUTTEXT             403
#define IDS_LOCATIONCHANGED       404
#define ALTDATA                   405
#define IDS_CANTFINDLOCATIONID    406
#define IDS_CANTFINDLOCATIONNAME  407
#define IDS_HELP                  408


#define IDI_TAPITNAICON  501


#define IDR_RBUTTONMENU 601



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapiupr\loc_comn.h ===
#ifdef PARTIAL_UNICODE

#define  __TTEXT(quote) quote
#define  TAPISendDlgItemMessage  SendDlgItemMessage
#define  TAPIRegQueryValueExW    TAPIRegQueryValueExW
#define  TAPIRegSetValueExW      TAPIRegSetValueExW
#define  TAPILoadStringW         TAPILoadStringW
#define  TAPICHAR                char

#define TAPIRegDeleteValueW RegDeleteValueA

LONG TAPIRegQueryValueExW(
                           HKEY hKey,
                           const CHAR *SectionName,
                           LPDWORD lpdwReserved,
                           LPDWORD lpType,
                           LPBYTE  lpData,
                           LPDWORD lpcbData
                          );

LONG TAPIRegSetValueExW(
                         HKEY    hKey,
                         const CHAR    *SectionName,
                         DWORD   dwReserved,
                         DWORD   dwType,
                         LPBYTE  lpData,
                         DWORD   cbData
                        );

LONG TAPIRegEnumValueW(
                       HKEY         hKey,
                       DWORD        dwIndex,
                       TAPICHAR     *lpName,
                       LPDWORD      lpcbName,
                       LPDWORD      lpdwReserved,
                       LPDWORD      lpwdType,
                       LPBYTE       lpData,
                       LPDWORD      lpcbData
                      );

int TAPILoadStringW(
                HINSTANCE hInst,
                UINT      uID,
                PWSTR     pBuffer,
                int       nBufferMax
               );

HINSTANCE TAPILoadLibraryW(
                PWSTR     pszLibraryW
               );

BOOL WINAPI TAPIIsBadStringPtrW( LPCWSTR lpsz, UINT cchMax );


#else
#define  __TTEXT(quote) L##quote
#define  TAPISendDlgItemMessage  SendDlgItemMessageW
#define  TAPIRegDeleteValueW     RegDeleteValueW
#define  TAPIRegQueryValueExW    RegQueryValueExW
#define  TAPIRegSetValueExW      RegSetValueExW
#define  TAPIRegEnumValueW       RegEnumValueW
#define  TAPILoadStringW         LoadStringW
#define  TAPILoadLibraryW        LoadLibraryW
#define  TAPIIsBadStringPtrW     IsBadStringPtrW
#define  TAPICHAR                WCHAR
#endif

#define TAPITEXT(quote) __TTEXT(quote)

//***************************************************************************
typedef struct {

        DWORD dwID;

#define MAXLEN_NAME                96
        WCHAR NameW[MAXLEN_NAME];

#define MAXLEN_AREACODE            16
        WCHAR AreaCodeW[MAXLEN_AREACODE];

        DWORD dwCountryID;
//PERFORMANCE KEEP CountryCode here - reduce # calls to readcountries

#define MAXLEN_OUTSIDEACCESS       16
        WCHAR OutsideAccessW[MAXLEN_OUTSIDEACCESS];
// There is one instance where code assumes outside & ld are same size
// (the code that reads in the text from the control)

#define MAXLEN_LONGDISTANCEACCESS  16
        WCHAR LongDistanceAccessW[MAXLEN_LONGDISTANCEACCESS];

        DWORD dwFlags;
             #define LOCATION_USETONEDIALING        0x00000001
             #define LOCATION_USECALLINGCARD        0x00000002
             #define LOCATION_HASCALLWAITING        0x00000004
             #define LOCATION_ALWAYSINCLUDEAREACODE 0x00000008

        DWORD dwCallingCard;

#define MAXLEN_DISABLECALLWAITING  16
        WCHAR DisableCallWaitingW[MAXLEN_DISABLECALLWAITING];

//
// When dialing some area codes adjacent to the current area code, the
// LD prefix does not need to (or can not) be added
#define MAXLEN_NOPREFIXAREACODES (400)
        DWORD NoPrefixAreaCodesCount;
        DWORD NoPrefixAreaCodes[ MAXLEN_NOPREFIXAREACODES ];

        DWORD NoPrefixAreaCodesExceptions[ MAXLEN_NOPREFIXAREACODES ];

//
// Allow all prefixes to be toll. (Yes, even 911.)  String is "xxx,"
#define MAXLEN_TOLLLIST     (1000*4 + 1)
        WCHAR TollListW[MAXLEN_TOLLLIST];

       } LOCATION, *PLOCATION;

//***************************************************************************
//***************************************************************************
//***************************************************************************
#define CHANGEDFLAGS_CURLOCATIONCHANGED      0x00000001
#define CHANGEDFLAGS_REALCHANGE              0x00000002
#define CHANGEDFLAGS_TOLLLIST                0x00000004


//***************************************************************************
//***************************************************************************
//***************************************************************************
//
// These bits decide which params TAPISRV will check on READLOCATION and
// WRITELOCATION operations
//
#define CHECKPARMS_DWHLINEAPP         1
#define CHECKPARMS_DWDEVICEID         2
#define CHECKPARMS_DWAPIVERSION       4

//***************************************************************************
//***************************************************************************
//***************************************************************************
#define DWTOTALSIZE  0
#define DWNEEDEDSIZE 1
#define DWUSEDSIZE   2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\resource.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    resource.h

NOTE from Testing: 
  If these values are changed, it will very likely break test automation. Please advise the test
  team if these values are altered. (peterje)

Abstract:

    Resource header file for the TAPI Browser util

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TB.RC
//
#define IDR_MENU1                       101
#define IDD_DIALOG1                     102
#define IDD_DIALOG2                     103
#define IDD_DIALOG3                     104
#define IDD_DIALOG4                     105
#define IDD_DIALOG5                     106
#define IDD_DIALOG6                     107
#define IDI_ICON1                       108
#define IDR_ACCELERATOR1                109
#define IDC_LIST1                       1000
#define IDC_LIST2                       1001
#define IDC_COMBO1                      1002
#define IDC_EDIT1                       1003
#define IDC_CLEAR                       1004
#define IDC_STATIC1                     1005
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010
#define IDC_BUTTON6                     1011
#define IDC_BUTTON7                     1012
#define IDC_BUTTON8                     1013
#define IDC_BUTTON9                     1014
#define IDC_BUTTON10                    1015
#define IDC_BUTTON11                    1016
#define IDC_BUTTON12                    1017
#define IDC_BUTTON13                    1018
#define IDC_BUTTON14                    1019
#define IDC_BUTTON15                    1020
#define IDC_BUTTON16                    1021
#define IDC_BUTTON17                    1022
#define IDC_BUTTON18                    1023
#define IDC_TB_HELP                     1024
#define IDC_F1HELP                      1025
#define IDC_PREVCTRL                    1026
#define IDC_NEXTCTRL                    1027
#define IDC_ENTER                       1028
#define IDM_DEFAULTVALUES               40001
#define IDM_ABOUT                       40002
#define IDM_USINGTB                     40003
#define IDM_DUMPPARAMS                  40004
#define IDM_LOGSTRUCTDWORD              40005
#define IDM_LOGSTRUCTALLFIELD           40006
#define IDM_LOGSTRUCTNONZEROFIELD       40007
#define IDM_LOGSTRUCTNONE               40008
#define IDM_USERBUTTONS                 40009
#define IDM_LOGFILE                     40010
#define IDM_CLEAR                       40011
#define IDM_PARAMS                      40012
#define IDM_EXIT                        40013
#define IDM_TAPIHLP                     40014
#define IDM_TSPIHLP                     40015
#define IDM_NUKEIDLEMONITORCALLS        40016
#define IDM_NUKEIDLEOWNEDCALLS          40017
#define IDM_TIMESTAMP                   40018
#define IDM_NOHANDLECHK                 40019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\tb.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    tb.h

Abstract:

    Header file for the TAPI Browser util

Author:

    Dan Knudson (DanKn)    23-Aug-1994

Revision History:

--*/


#include <windows.h>
#include <tapi.h>

#if INTERNAL_3_0
#include <tapimmc.h>
#endif


//
// Symbolic constants
//

#define DS_NONZEROFIELDS            0x00000001
#define DS_ZEROFIELDS               0x00000002
#define DS_BYTEDUMP                 0x00000004

#define WT_LINEAPP                  1
#define WT_LINE                     2
#define WT_CALL                     3
#define WT_PHONEAPP                 4
#define WT_PHONE                    5

#define PT_DWORD                    1
#define PT_FLAGS                    2
#define PT_POINTER                  3
#define PT_STRING                   4
#define PT_CALLPARAMS               5
#define PT_FORWARDLIST              6
#define PT_ORDINAL                  7

#define FT_DWORD                    1
#define FT_FLAGS                    2
#define FT_ORD                      3
#define FT_SIZE                     4
#define FT_OFFSET                   5

#define MAX_STRING_PARAM_SIZE       96

#define MAX_USER_BUTTONS            6

#define MAX_USER_BUTTON_TEXT_SIZE   8

#define MAX_LINEFORWARD_ENTRIES     5

#define TABSIZE 4

#if TAPI_2_0
#define LAST_LINEERR                LINEERR_DIALVOICEDETECT
#else
#define LAST_LINEERR                LINEERR_NOMULTIPLEINSTANCE
#endif


//
//
//

typedef LONG (WINAPI *PFN1)(ULONG_PTR);
typedef LONG (WINAPI *PFN2)(ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN3)(ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN4)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN5)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR);
typedef LONG (WINAPI *PFN6)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN7)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN8)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN9)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR);
typedef LONG (WINAPI *PFN10)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN12)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);


typedef struct _MYWIDGET
{
    DWORD       dwType;

    struct _MYWIDGET   *pNext;

} MYWIDGET, *PMYWIDGET;


typedef struct _MYLINEAPP
{
    MYWIDGET    Widget;

    HLINEAPP    hLineApp;

} MYLINEAPP, *PMYLINEAPP;


typedef struct _MYLINE
{
    MYWIDGET    Widget;

    HLINE       hLine;

    HLINEAPP    hLineApp;

    DWORD       dwDevID;

    DWORD       dwPrivileges;

    DWORD       dwMediaModes;

    DWORD       dwAPIVersion;

    PMYLINEAPP  pLineApp;

} MYLINE, *PMYLINE;


typedef struct _MYCALL
{
    MYWIDGET    Widget;

    HCALL       hCall;

    DWORD       dwCallState;

    LONG        lMakeCallReqID;

    LONG        lDropReqID;

    DWORD       dwCompletionID;

    DWORD       dwNumGatheredDigits;

    char        *lpsGatheredDigits;

    PMYLINE     pLine;

    BOOL        bMonitor;

} MYCALL, *PMYCALL;


typedef struct _MYPHONEAPP
{
    MYWIDGET    Widget;

    HPHONEAPP   hPhoneApp;

} MYPHONEAPP, *PMYPHONEAPP;


typedef struct _MYPHONE
{
    MYWIDGET    Widget;

    HPHONE      hPhone;

    HPHONEAPP   hPhoneApp;

    DWORD       dwDevID;

    DWORD       dwPrivilege;

    DWORD       dwAPIVersion;

    PMYPHONEAPP pPhoneApp;

} MYPHONE, *PMYPHONE;


typedef struct _LOOKUP
{
    DWORD       dwVal;

    char        lpszVal[20];

} LOOKUP, *PLOOKUP;


typedef enum
{
    lAccept,
#if TAPI_1_1
    lAddProvider,
#if TAPI_2_0
    lAddProviderW,
#endif
#endif
    lAddToConference,
#if TAPI_2_0
    lAgentSpecific,
#endif
    lAnswer,
    lBlindTransfer,
#if TAPI_2_0
    lBlindTransferW,
#endif
    lClose,
    lCompleteCall,
    lCompleteTransfer,
    lConfigDialog,
#if TAPI_2_0
    lConfigDialogW,
#endif
#if TAPI_1_1
    lConfigDialogEdit,
#if TAPI_2_0
    lConfigDialogEditW,
#endif
    lConfigProvider,
#endif
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
#if TAPI_2_0
    lDialW,
#endif
    lDrop,
    lForward,
#if TAPI_2_0
    lForwardW,
#endif
    lGatherDigits,
#if TAPI_2_0
    lGatherDigitsW,
#endif
    lGenerateDigits,
#if TAPI_2_0
    lGenerateDigitsW,
#endif
    lGenerateTone,
    lGetAddressCaps,
#if TAPI_2_0
    lGetAddressCapsW,
#endif
    lGetAddressID,
#if TAPI_2_0
    lGetAddressIDW,
#endif
    lGetAddressStatus,
#if TAPI_2_0
    lGetAddressStatusW,
    lGetAgentActivityList,
    lGetAgentActivityListW,
    lGetAgentCaps,
    lGetAgentGroupList,
    lGetAgentStatus,
#endif
#if TAPI_1_1
    lGetAppPriority,
#if TAPI_2_0
    lGetAppPriorityW,
#endif
#endif
    lGetCallInfo,
#if TAPI_2_0
    lGetCallInfoW,
#endif
    lGetCallStatus,
    lGetConfRelatedCalls,
#if TAPI_1_1
    lGetCountry,
#if TAPI_2_0
    lGetCountryW,
#endif
#endif
    lGetDevCaps,
#if TAPI_2_0
    lGetDevCapsW,
#endif
    lGetDevConfig,
#if TAPI_2_0
    lGetDevConfigW,
#endif
    lGetIcon,
#if TAPI_2_0
    lGetIconW,
#endif
    lGetID,
#if TAPI_2_0
    lGetIDW,
#endif
    lGetLineDevStatus,
#if TAPI_2_0
    lGetLineDevStatusW,
    lGetMessage,
#endif
    lGetNewCalls,
    lGetNumRings,
#if TAPI_1_1
    lGetProviderList,
#if TAPI_2_0
    lGetProviderListW,
#endif
#endif
    lGetRequest,
#if TAPI_2_0
    lGetRequestW,
#endif
    lGetStatusMessages,
    lGetTranslateCaps,
#if TAPI_2_0
    lGetTranslateCapsW,
#endif
    lHandoff,
#if TAPI_2_0
    lHandoffW,
#endif
    lHold,
    lInitialize,
#if TAPI_2_0
    lInitializeEx,
    lInitializeExW,
#endif
    lMakeCall,
#if TAPI_2_0
    lMakeCallW,
#endif
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
#if TAPI_2_0
    lOpenW,
#endif
    lPark,
#if TAPI_2_0
    lParkW,
#endif
    lPickup,
#if TAPI_2_0
    lPickupW,
#endif
    lPrepareAddToConference,
#if TAPI_2_0
    lPrepareAddToConferenceW,
    lProxyMessage,
    lProxyResponse,
#endif
    lRedirect,
#if TAPI_2_0
    lRedirectW,
#endif
    lRegisterRequestRecipient,
#if TAPI_1_1
    lReleaseUserUserInfo,
#endif
    lRemoveFromConference,
#if TAPI_1_1
    lRemoveProvider,
#endif
    lSecureCall,
    lSendUserUserInfo,
#if TAPI_2_0
    lSetAgentActivity,
    lSetAgentGroup,
    lSetAgentState,
#endif
#if TAPI_1_1
    lSetAppPriority,
#if TAPI_2_0
    lSetAppPriorityW,
#endif
#endif
    lSetAppSpecific,
#if TAPI_2_0
    lSetCallData,
#endif
    lSetCallParams,
    lSetCallPrivilege,
#if TAPI_2_0
    lSetCallQualityOfService,
    lSetCallTreatment,
#endif
    lSetCurrentLocation,
    lSetDevConfig,
#if TAPI_2_0
    lSetDevConfigW,
    lSetLineDevStatus,
#endif
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
    lSetTollList,
#if TAPI_2_0
    lSetTollListW,
#endif
    lSetupConference,
#if TAPI_2_0
    lSetupConferenceW,
#endif
    lSetupTransfer,
#if TAPI_2_0
    lSetupTransferW,
#endif
    lShutdown,
    lSwapHold,
    lTranslateAddress,
#if TAPI_2_0
    lTranslateAddressW,
#endif
#if TAPI_1_1
    lTranslateDialog,
#if TAPI_2_0
    lTranslateDialogW,
#endif
#endif
    lUncompleteCall,
    lUnhold,
    lUnpark,
#if TAPI_2_0
    lUnparkW,
#endif

#if INTERNAL_3_0
    mmcAddProvider,
    mmcConfigProvider,
    mmcGetAvailableProviders,
    mmcGetLineInfo,
    mmcGetLineStatus,
    mmcGetPhoneInfo,
    mmcGetPhoneStatus,
    mmcGetProviderList,
    mmcGetServerConfig,
    mmcInitialize,
    mmcRemoveProvider,
    mmcSetLineInfo,
    mmcSetPhoneInfo,
    mmcSetServerConfig,
    mmcShutdown,
#endif

    pClose,
    pConfigDialog,
#if TAPI_2_0
    pConfigDialogW,
#endif
    pDevSpecific,
    pGetButtonInfo,
#if TAPI_2_0
    pGetButtonInfoW,
#endif
    pGetData,
    pGetDevCaps,
#if TAPI_2_0
    pGetDevCapsW,
#endif
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetIcon,
#if TAPI_2_0
    pGetIconW,
#endif
    pGetID,
#if TAPI_2_0
    pGetIDW,
#endif
    pGetLamp,
#if TAPI_2_0
    pGetMessage,
#endif
    pGetRing,
    pGetStatus,
#if TAPI_2_0
    pGetStatusW,
#endif
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
#if TAPI_2_0
    pInitializeEx,
    pInitializeExW,
#endif
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
    pSetButtonInfo,
#if TAPI_2_0
    pSetButtonInfoW,
#endif
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

    tGetLocationInfo,
#if TAPI_2_0
    tGetLocationInfoW,
#endif
    tRequestDrop,
    tRequestMakeCall,
#if TAPI_2_0
    tRequestMakeCallW,
#endif
    tRequestMediaCall,
#if TAPI_2_0
    tRequestMediaCallW,
#endif

    OpenAllLines,
    OpenAllPhones,
    CloseHandl,
    DumpBuffer,
#if (INTERNAL_VER >= 0x20000)
    iNewLocationW,
#endif

    MiscBegin,

    DefValues,
    lCallParams,
    lForwardList

} FUNC_INDEX;


typedef struct _FUNC_PARAM
{
    char far        *szName;

    DWORD           dwType;

    ULONG_PTR       dwValue;

    union
    {
        LPVOID      pLookup;

        char far    *buf;

        LPVOID      ptr;

        ULONG_PTR   dwDefValue;

    } u;

} FUNC_PARAM, *PFUNC_PARAM;


typedef struct _FUNC_PARAM_HEADER
{
    DWORD       dwNumParams;

    FUNC_INDEX  FuncIndex;

    PFUNC_PARAM aParams;

    union
    {
        PFN1    pfn1;
        PFN2    pfn2;
        PFN3    pfn3;
        PFN4    pfn4;
        PFN5    pfn5;
        PFN6    pfn6;
        PFN7    pfn7;
        PFN8    pfn8;
        PFN9    pfn9;
        PFN10   pfn10;
        PFN12   pfn12;

    } u;

} FUNC_PARAM_HEADER, *PFUNC_PARAM_HEADER;


typedef struct _STRUCT_FIELD
{
    char far    *szName;

    DWORD       dwType;

    DWORD       dwValue;

    LPVOID      pLookup;

} STRUCT_FIELD, *PSTRUCT_FIELD;


typedef struct _STRUCT_FIELD_HEADER
{
    LPVOID      pStruct;

    char far    *szName;

    DWORD       dwNumFields;

    PSTRUCT_FIELD   aFields;

} STRUCT_FIELD_HEADER, *PSTRUCT_FIELD_HEADER;


//
// Func prototypes
//

INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

void
FAR
ShowStr(
    LPCSTR format,
    ...
    );

void
ShowBytes(
    DWORD   dwSize,
    LPVOID  lp,
    DWORD   dwNumTabs
    );

VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

INT_PTR
CALLBACK
ParamsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
IconDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
IsLineAppSelected(
    void
    );

BOOL
IsLineSelected(
    void
    );

BOOL
IsCallSelected(
    void
    );

BOOL
IsTwoCallsSelected(
    void
    );

BOOL
IsPhoneAppSelected(
    void
    );

BOOL
IsPhoneSelected(
    void
    );

LONG
DoFunc(
    PFUNC_PARAM_HEADER pHeader
    );

INT_PTR
LetUserMungeParams(
    PFUNC_PARAM_HEADER pParamsHeader
    );

void
ShowLineFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

void
FuncDriver(
    FUNC_INDEX funcIndex
    );

void
UpdateWidgetList(
    void
    );

void
InsertWidgetInList(
    PMYWIDGET pNewWidget,
    PMYWIDGET pWidgetInsertBefore
    );

BOOL
RemoveWidgetFromList(
    PMYWIDGET pWidgetToRemove
    );

PMYLINEAPP
AllocLineApp(
    void
    );

PMYLINEAPP
GetLineApp(
    HLINEAPP hLineApp
    );

VOID
FreeLineApp(
    PMYLINEAPP pLineApp
    );

PMYLINE
AllocLine(
    PMYLINEAPP pLineApp
    );

PMYLINE
GetLine(
    HLINE hLine
    );

VOID
FreeLine(
    PMYLINE pLine
    );

PMYCALL
AllocCall(
    PMYLINE pLine
    );

PMYCALL
GetCall(
    HCALL hCall
    );

VOID
FreeCall(
    PMYCALL pCall
    );

VOID
MoveCallToLine(
    PMYCALL pCall,
    HLINE hLine
    );

PMYPHONEAPP
AllocPhoneApp(
    void
    );

PMYPHONEAPP
GetPhoneApp(
    HPHONEAPP hPhoneApp
    );

VOID
FreePhoneApp(
    PMYPHONEAPP pPhoneApp
    );

PMYPHONE
AllocPhone(
    PMYPHONEAPP pPhoneApp
    );

PMYPHONE
GetPhone(
    HPHONE hPhone
    );

VOID
FreePhone(
    PMYPHONE pPhone
    );

int
GetWidgetIndex(
    PMYWIDGET pWidget
    );

void
SelectWidget(
    PMYWIDGET pWidget
    );

void
UpdateResults(
    BOOL bBegin
    );

INT_PTR
CALLBACK
UserButtonsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

void
ErrorAlert(
    void
    );

//
// Macros
//

#define CHK_LINEAPP_SELECTED()                      \
        if (!IsLineAppSelected())                   \
        {                                           \
            break;                                  \
        }

#define CHK_LINE_SELECTED()                         \
        if (!IsLineSelected())                      \
        {                                           \
            break;                                  \
        }

#define CHK_CALL_SELECTED()                         \
        if (!IsCallSelected())                      \
        {                                           \
            break;                                  \
        }

#define CHK_TWO_CALLS_SELECTED()                    \
        if (!IsTwoCallsSelected())                  \
        {                                           \
            break;                                  \
        }

#define CHK_PHONEAPP_SELECTED()                     \
        if (!IsPhoneAppSelected())                  \
        {                                           \
            break;                                  \
        }

#define CHK_PHONE_SELECTED()                        \
        if (!IsPhoneSelected())                     \
        {                                           \
            break;                                  \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tapiupr\tapiupr.c ===
#define STRICT

#include <windows.h>
#include <windowsx.h>

#include "location.h"



#if DBG

#define DBGOUT(arg) DbgPrt arg

void
DbgPrt(
    DWORD  dwDbgLevel,
    PSTR DbgMessage,
    ...
    );

#else

#define DBGOUT(_x_)
#endif




const TCHAR gszName[]               = "Name";
const TCHAR gszID[]                 = "ID";
const TCHAR gszAreaCode[]           = "AreaCode";
const TCHAR gszCountry[]            = "Country";
const TCHAR gszOutsideAccess[]      = "OutsideAccess";
const TCHAR gszLongDistanceAccess[] = "LongDistanceAccess";
const TCHAR gszFlags[]              = "Flags";
const TCHAR gszCallingCard[]        = "CallingCard";
const TCHAR gszDisableCallWaiting[] = "DisableCallWaiting";
const TCHAR gszTollList[]           = "TollList";
//const TCHAR gszNumLocations[]       = "NumLocations";
//const TCHAR gszCurrLocation[]       = "CurrLocation";
//const TCHAR gszNextLocationID[]     = "NextLocationID";

const TCHAR gszCard[]               = "Card";
const TCHAR gszPin[]                = "Pin";
const TCHAR gszCards[]              = "Cards";
//const TCHAR gszNumCards[]           = "NumCards";
//const TCHAR gszCurrCard[]           = "CurrCard";
const TCHAR gszLocalRule[]          = "LocalRule";
const TCHAR gszLDRule[]             = "LDRule";
const TCHAR gszInternationalRule[]  = "InternationalRule";

const TCHAR gszNumEntries[]         = "NumEntries";
const TCHAR gszCurrentID[]          = "CurrentID";
const TCHAR gszNextID[]             = "NextID";


const TCHAR gszEmpty[]     =  "";

const TCHAR gszLocations[] =  "Locations";
const TCHAR gszLocation[]  =  "Location";
const TCHAR gszCurrentLocation[] = "CurrentLocation";


const TCHAR gszHandoffPriorities[] = "HandoffPriorities";

const TCHAR gszProviders[] = "Providers";
const TCHAR gszProvider[]  = "Provider%d";

const TCHAR gszTelephonIni[] =  "Telephon.ini";


const TCHAR gszTelephony[]    = "Software\\Microsoft\\Windows\\"
                                "CurrentVersion\\Telephony";



       const CHAR *gaszMediaModes[] =
       {
           "",
           "unknown",
           "interactivevoice",
           "automatedvoice",
           "datamodem",
           "g3fax",
           "tdd",
           "g4fax",
           "digitaldata",
           "teletex",
           "videotex",
           "telex",
           "mixed",
           "adsi",
           "voiceview",
           NULL
       };
       
       const CHAR    *gszRequestMakeCallW = "RequestMakeCall";
       const CHAR    *gszRequestMediaCallW = "RequestMediaCall";
       const CHAR    *gszRegKeyHandoffPriorities = "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities";
       const CHAR    *gszRegKeyHandoffPrioritiesMediaModes = "MediaModes";
       


void FixPriorityList(HKEY hKeyHandoffPriorities,
                     LPCSTR pszListName);

void FixMediaModesPriorityLists();

#pragma check_stack ( off )

//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL ParseSomething( LPCSTR pFormat, LPCSTR pInputString, LPVOID pOutputPtr )
{
   BYTE c;
   LPBYTE pOutput = (LPBYTE)pOutputPtr;
   LPBYTE pInput = (LPBYTE)pInputString;


   while ( (c = *pFormat) && *pInput )
   {
#if DBG
DBGOUT((11, "Inputstring[%s]\r\n   Format[%s]\r\n",
              pInput, pFormat));
#endif

      switch ( c )
      {
         case 'n':
         {
            DWORD dwValue = 0;
            BYTE bDigit;

            //
            // Parse value from the string
            //
            while ( ((bDigit = *pInput) != '\0') && bDigit != ',' )
            {
               dwValue = (dwValue * 10) + ( bDigit - '0' );
#if DBG
DBGOUT((11, "val of bDigit=%d dwValue=%ld\r\n", (int)bDigit, dwValue));
#endif

               bDigit = *(++pInput);
            }

            *(LPDWORD)pOutput = dwValue;

            pOutput += sizeof(DWORD);

         }
         break;


         case 's':
         {
            //
            // If the caller is looking for a string, the first char
            // MUST be a quotes.  So, just step past it.
            //
            pInput++;

            //
            // Ok, _now_ we're into the meat of the string (if there _is_
            // any...)
            //

            while ( *pInput != '\0' && *pInput != '"' )
            {
               *pOutput = *pInput;
               pOutput++;
               pInput++;
            }

            //
            // Don't forget to put a cap on that thing.
            //
            *pOutput = '\0';
            pOutput++;

            // The input should now be at a ->"<-  if it's not, the ini
            // file was hosed, and I'm not fixing it.
            // So, we step past it, and we're done
            //
            if ( *pInput == '"' )
            {
               pInput++;
            }

         }
         break;


      }

      //
      // Step past the comma...
      //
      //
      if ( *pInput == ',' )
      {
         pInput++;
      }

      pFormat++;
   }

   return TRUE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
//VOID __cdecl main( void )
void __cdecl main( void )
{

   DWORD dw;
   DWORD dwNumEntries;
   DWORD dwCurrentID;
   DWORD dwNextID;

   DWORD dwSize;
   DWORD dwType;
   DWORD dwValue;

   DWORD dwArray[10];
   BYTE  *bBigArray;
   BYTE  *Buffer;
   LPBYTE  pSource;

   HKEY  hKey3;
   HKEY  hKey2;
   HKEY  hKey;
   DWORD dwDisposition;

#define BUFFER_SIZE (5120)

   bBigArray = LocalAlloc( LPTR, BUFFER_SIZE );

   if ( !bBigArray )
   {
       return;
   }

   Buffer = LocalAlloc( LPTR, BUFFER_SIZE ); //Might needs tons of room for tolllist

   if ( !Buffer )
   {
       return;
   }

   dw = GetPrivateProfileString(
                               gszCards,
                               gszCards,
                               gszEmpty,
                               Buffer,
                               BUFFER_SIZE,
                               gszTelephonIni
                             );


   //
   // Is there an existing AND valid TELEPHON.INI file?
   // There would HAVE TO be at least one card.  The SYSTEM cards cannot
   // be deleted, only hidden.
   //
   if ( 0 != dw )
   {



//[Cards]
//Cards=23,23
//Card0=0,"None (Direct Dial)","","","","",1
//Card1=1,"AT&T Direct Dial via 10ATT1","","G","102881FG","10288011EFG",1
#define CARD_INI_ID         (0)
#define CARD_INI_NAME       (1)
#define CARD_INI_SNUMBER    (2)
#define CARD_INI_SARULE     (3)
#define CARD_INI_LDRULE     (4)
#define CARD_INI_INTNLRULE  (5)
#define CARD_INI_HIDDEN     (6)


#define PC_INI_ID           (0)
#define PC_INI_NEXTID       (1)
#define PC_INI_NAME         (2)
#define PC_INI_SARULE       (3)
#define PC_INI_LDRULE       (4)
#define PC_INI_INTNLRULE    (5)


      //
      // Move CARDS entries to registry
      //



      ParseSomething( "nn", Buffer, &dwArray);

      dwNumEntries = dwArray[0];
      dwNextID = dwArray[1];


      RegCreateKeyEx(
                      HKEY_CURRENT_USER,
                      gszTelephony,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey3,
                      &dwDisposition
                    );

      RegCreateKeyEx(
                      hKey3,
                      gszCards,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey2,
                      &dwDisposition
                    );

      //
      // Don't wipe out an existing card section
      //
      dwSize = sizeof(dwValue);

      dw = RegQueryValueEx(
                     hKey2,
                     gszNumEntries,
                     0,
                     &dwType,
                     (LPBYTE)&dwValue,
                     &dwSize
                   );

      if ( 0 != dw )
      {

         RegSetValueEx(
                        hKey2,
                        gszNumEntries,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNumEntries,
                        sizeof(DWORD)
                     );

         RegSetValueEx(
                        hKey2,
                        gszNextID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNextID,
                        sizeof(DWORD)
                     );



         for ( dw=0; dw<dwNumEntries; dw++ )
         {
            TCHAR Temp[18];

            wsprintf(Temp, "%s%d", gszCard, dw);

            //
            // Create the key for this Card
            //
            RegCreateKeyEx(
                           hKey2,
                           Temp,
                           0,
                           "",   //Class?  What class?
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           0,
                           &hKey,
                           &dwDisposition
                        );


            GetPrivateProfileString(
                                    gszCards,
                                    Temp,
                                    gszEmpty,
                                    Buffer,
                                    BUFFER_SIZE,
                                    gszTelephonIni
                                 );

            ParseSomething("nsssssn", Buffer, bBigArray);


            pSource = bBigArray;

            RegSetValueEx(
                           hKey,
                           gszID,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);

            RegSetValueEx(
                           hKey,
                           gszName,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszPin,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszLocalRule,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszLDRule,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszInternationalRule,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszFlags,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            RegCloseKey( hKey );
         }

      }

      RegCloseKey( hKey2 );
      RegCloseKey( hKey3 );


//---------------------------------------------------------------------------



      GetPrivateProfileString(
                               gszLocations,
                               gszCurrentLocation,
                               gszEmpty,
                               Buffer,
                               BUFFER_SIZE,
                               gszTelephonIni
                             );

      ParseSomething( "nn", Buffer, &dwArray);

      dwCurrentID = dwArray[0];


      GetPrivateProfileString(
                               gszLocations,
                               gszLocations,
                               gszEmpty,
                               Buffer,
                               BUFFER_SIZE,
                               gszTelephonIni
                             );

      ParseSomething( "nn", Buffer, &dwArray);

      dwNumEntries = dwArray[0];
      dwNextID = dwArray[1];


      RegCreateKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszTelephony,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey3,
                      &dwDisposition
                    );


      RegCreateKeyEx(
                      hKey3,
                      gszLocations,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey2,
                      &dwDisposition
                    );




      //
      // Don't wipe out an existing card section
      //
      dwSize = sizeof(dwValue);

      dw = RegQueryValueEx(
                     hKey2,
                     gszNumEntries,
                     0,
                     &dwType,
                     (LPBYTE)&dwValue,
                     &dwSize
                   );

      if ( 0 != dw )
      {

         RegSetValueEx(
                        hKey2,
                        gszCurrentID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwCurrentID,
                        sizeof(DWORD)
                     );

         RegSetValueEx(
                        hKey2,
                        gszNumEntries,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNumEntries,
                        sizeof(DWORD)
                     );

         RegSetValueEx(
                        hKey2,
                        gszNextID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNextID,
                        sizeof(DWORD)
                     );



         for ( dw=0; dw<dwNumEntries; dw++ )
         {
            TCHAR Temp[18];
            DWORD dwFlags = 0;

            wsprintf(Temp, "%s%d", gszLocation, dw);

            //
            // Create the key for this Location
            //
            RegCreateKeyEx(
                           hKey2,
                           Temp,
                           0,
                           "",   //Class?  What class?
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           0,
                           &hKey,
                           &dwDisposition
                        );



            GetPrivateProfileString(
                                    gszLocations,
                                    Temp,
                                    gszEmpty,
                                    Buffer,
                                    BUFFER_SIZE,
                                    gszTelephonIni
                                 );

            ParseSomething("nssssnnnnsns", Buffer, bBigArray);
//NOTE if this is upgrade over 3.1, the last 2 fields don't exist



//[Locations]
//CurrentLocation=1,2
//Locations=3,4
//Location0=0,"Work","9","9","206",1,0,0,1,"",0,""
//Location1=3,"RoadHouse","","","215",1,0,0,0,"",0,""
//Location2=1,"Home","","","206",1,0,0,0,"",0," "
//  Positions in ini file entries for locations,cards,countries
//  NOTE: dialing rules are in same positions for locations and cards!

//#define LOC_INI_ID            (0)
//#define   LOC_INI_NAME        (1)
//#define   LOC_INI_LPREFIX     (2)
//#define LOC_INI_LDPREFIX  (3)
//#define   LOC_INI_AREACODE    (4)
//#define   LOC_INI_COUNTRYCODE (5)
//#define   LOC_INI_CARDID      (6)
//#define LOC_INI_CARDHINT  (7)
//#define   LOC_INI_INSERTAC    (8)
//#define   LOC_INI_TOLLLIST    (9)
//
//#define   LOC_INI_PULSE       (10)
//#define   LOC_INI_CALLWAITING (11)


            pSource = bBigArray;

            RegSetValueEx(
                           hKey,
                           gszID,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);

            RegSetValueEx(
                           hKey,
                           gszName,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszOutsideAccess,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszLongDistanceAccess,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszAreaCode,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszCountry,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            //
            // If the callingcard == 0, it means this location does not
            // use a calling card.
            //
            if ( *(LPDWORD)pSource != 0 )
            {
               dwFlags |= LOCATION_USECALLINGCARD;
            }

            RegSetValueEx(
                           hKey,
                           gszCallingCard,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            pSource += sizeof(DWORD);
            pSource += sizeof(DWORD);


            RegSetValueEx(
                           hKey,
                           gszTollList,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            //
            // pSource is currently pointing to the old dwFlags.  However,
            // the only flag that was used was bit 1 which indicated
            // tone dialing.  As luck (yeah, right) would have it, we
            // use bit 1 to indicate tone dialing as well.
            //
            dwFlags |= !((*(LPDWORD)pSource) & 1);

            pSource += sizeof(DWORD);

            //
            // Is there a disablecallwaiting string
            //
            dwFlags |= ( lstrlen( pSource ) == 0 ) ?
                                                   0 :
                                                   LOCATION_HASCALLWAITING;

            RegSetValueEx(
                           hKey,
                           gszDisableCallWaiting,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;


            RegSetValueEx(
                           hKey,
                           gszFlags,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwFlags,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            RegCloseKey( hKey );
         }

      }



      //
      // Q: How do we update COUNTRY OVERRIDES?
      // A: We don't.  We assume we've corrected everything by now...
      //


//      RegCloseKey( hKey );
      RegCloseKey( hKey2 );
      RegCloseKey( hKey3 );

   }
   

   {
       int      i;
       HKEY     hKeyHandoffPriorities;
       if (RegOpenKeyEx(
                        HKEY_CURRENT_USER,
                        gszRegKeyHandoffPriorities,
                        0,
                        KEY_ALL_ACCESS,
                        &hKeyHandoffPriorities

                       ) == ERROR_SUCCESS)
       {


           for (i = 1; gaszMediaModes[i] != NULL; i++)
           {
               FixPriorityList(
                               hKeyHandoffPriorities,
                               (LPCSTR)gaszMediaModes[i]
                              );
           }

           FixPriorityList(
                           hKeyHandoffPriorities,
                           (LPCSTR)gszRequestMakeCallW
                          );

           FixPriorityList(
                           hKeyHandoffPriorities,
                           (LPCSTR)gszRequestMediaCallW
                          );


           RegCloseKey (hKeyHandoffPriorities);

       }
   }
         
   FixMediaModesPriorityLists();

#ifdef TAPI_NT
   {
      //----------------------------------------------------------------------
      //----------------------------------------------------------------------
      //----------------------------------------------------------------------
      //
      // Now we discuss someone who is upgrading from beta 2 to RTM.  They have
      // "EVERYONE:FULL CONTROL" access on the LOCATIONS key.  Let's change that
      // to have the same security as the TELEPHONY key.
      //
      
      SECURITY_INFORMATION SecInf;
      PSECURITY_DESCRIPTOR pSecDesc;
      DWORD                cbSecDesc = 65535;
      
      
      pSecDesc = LocalAlloc( LPTR, cbSecDesc );
      if ( pSecDesc )
      {
         
      
      
         RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         gszTelephony,
                         0,
                         KEY_ALL_ACCESS,
                         &hKey
                       );

         RegCreateKeyEx(
                         hKey,
                         gszLocations,
                         0,
                         "",   //Class?  What class?
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         0,
                         &hKey2,
                         &dwDisposition
                       );
                       
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            OWNER_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            OWNER_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            GROUP_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            GROUP_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            DACL_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            DACL_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            SACL_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            SACL_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
   
         RegCloseKey( hKey );
         RegCloseKey( hKey2);
         
         
         LocalFree( pSecDesc );
      }
   }                          
#endif

   LocalFree( bBigArray );
   LocalFree( Buffer );

   return;
}

void FixPriorityList(HKEY hKeyHandoffPriorities,
                     LPCSTR pszListName)
{
    DWORD   dwType, dwNumBytes;
    LPSTR  pszPriorityList, pszHold;

    if (RegQueryValueEx(
            hKeyHandoffPriorities,
            pszListName,
            NULL,
            &dwType,
            NULL,
            &dwNumBytes
                        ) == ERROR_SUCCESS &&

        (dwNumBytes != 0))
    {
        pszPriorityList = (LPSTR) GlobalAlloc ( GPTR, dwNumBytes );

        if (pszPriorityList)
        {
            pszHold = pszPriorityList;
            
            if ( RegQueryValueEx(
                    hKeyHandoffPriorities,
                    pszListName,
                    NULL,
                    &dwType,
                    (LPBYTE)(pszPriorityList),
                    &dwNumBytes

                                 ) == ERROR_SUCCESS)
            {
                while (*pszPriorityList != '\0')
                {
                    if (*pszPriorityList == ',')
                    {
                        *pszPriorityList = '"';
                    }

                    pszPriorityList++;
                }

                pszPriorityList = pszHold;

                RegSetValueEx(
                               hKeyHandoffPriorities,
                               pszListName,
                               0,
                               REG_SZ,
                               (LPBYTE)pszPriorityList,
                               (lstrlen(pszPriorityList) + 1) * sizeof(CHAR));
            }

            GlobalFree(pszPriorityList);
        }
    }

}


void FixMediaModesPriorityLists()
{
    HKEY     hKeyHandoffPriorities;
    HKEY     hKeyMediaModes;
    DWORD    dwDisp;

    // open the handoff priorities key
    if (RegOpenKeyEx(
                     HKEY_CURRENT_USER,
                     gszRegKeyHandoffPriorities,
                     0,
                     KEY_ALL_ACCESS,
                     &hKeyHandoffPriorities

                    ) == ERROR_SUCCESS)
    {
        if (RegOpenKeyEx(
                         hKeyHandoffPriorities,
                         gszRegKeyHandoffPrioritiesMediaModes,
                         0,
                         KEY_ALL_ACCESS,
                         &hKeyMediaModes
                        ) == ERROR_SUCCESS)
        {
            // key already exists, so don't do anything
            RegCloseKey( hKeyHandoffPriorities );
            RegCloseKey( hKeyMediaModes );

            return;
        }
        
        // create the mediamodes priority key
        if (RegCreateKeyEx(
                           hKeyHandoffPriorities,
                           gszRegKeyHandoffPrioritiesMediaModes,
                           0,
                           "",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKeyMediaModes,
                           &dwDisp
                           ) == ERROR_SUCCESS)
        {
            // go through all the
            // media modes

            int i;
            int j = 2; //LINEMEDIAMODE_UNKNOWN;
            for (i = 1; gaszMediaModes[i] != NULL; i++)
            {
                CHAR    szName[64];
                LPSTR   pszPriorityList;
                DWORD   dwNumBytes, dwType;

                // query for the priority list
                if ( (RegQueryValueEx(
                                      hKeyHandoffPriorities,
                                      gaszMediaModes[i],
                                      NULL,
                                      &dwType,
                                      NULL,
                                      &dwNumBytes
                                     ) == ERROR_SUCCESS) && (dwNumBytes != 0))
                {
                    pszPriorityList = (LPSTR) GlobalAlloc ( GPTR, dwNumBytes );

                    if (NULL != pszPriorityList)
                    {
                        if ( RegQueryValueEx(
                                             hKeyHandoffPriorities,
                                             gaszMediaModes[i],
                                             NULL,
                                             &dwType,
                                             (LPBYTE)(pszPriorityList),
                                             &dwNumBytes
                                            ) == ERROR_SUCCESS)
                        {

                            // if it exists, write out the new one
                            wsprintf(szName, "%d", j);
                            RegSetValueEx(
                                          hKeyMediaModes,
                                          szName,
                                          0,
                                          REG_SZ,
                                          pszPriorityList,
                                          lstrlen(pszPriorityList)+1
                                         );

                            // delete the old one
                            RegDeleteValue(
                                           hKeyHandoffPriorities,
                                           gaszMediaModes[i]
                                          );
                        }

                        GlobalFree( pszPriorityList );
                    }
                }

                j<<=1; // shift to next media mode

            }

            RegCloseKey(hKeyMediaModes);
        }

        RegCloseKey(hKeyHandoffPriorities);
    }
}

#if DBG


#include "stdarg.h"
#include "stdio.h"


VOID
DbgPrt(
    DWORD  dwDbgLevel,
    PSTR   lpszFormat,
    ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = 0;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[256] = "TAPIUPR: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[8],
                  lpszFormat,
                  ap
                  );

        lstrcat (buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\tb.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    tb.c

Abstract:

    API wrapper code for the TAPI Browser util.  Contains the big switch
    statement for all the supported Telephony API's, & various support funcs.

Author:

    Dan Knudson (DanKn)    23-Aug-1994

Revision History:

--*/


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include "tb.h"
#include "vars.h"
#include "resource.h"


char szdwDeviceID[]   = "dwDeviceID";
char szdwSize[]       = "dwSize";
char szhCall[]        = "hCall";
char szhLine[]        = "hLine";
char szhLineApp[]     = "hLineApp";
char szhPhone[]       = "hPhone";
char szlpCallParams[] = "lpCallParams";

char szlphCall[]         = "lphCall";
char szlpParams[]        = "lpParams";
char szhwndOwner[]       = "hwndOwner";
char szdwAddressID[]     = "dwAddressID";
char szlpszAppName[]     = "lpszAppName";
char szdwAPIVersion[]    = "APIVersion";
char szlphConsultCall[]  = "lphConsultCall";
char szlpszDeviceClass[] = "lpszDeviceClass";
char szlpszDestAddress[] = "lpszDestAddress";
char szlpsUserUserInfo[] = "lpsUserUserInfo";
char szlpszFriendlyAppName[] = "lpszFriendlyAppName";


DWORD NullWidget[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


void
FuncDriver2(
    FUNC_INDEX funcIndex
    );


void
ErrorAlert(
    void
    )
{
    //
    // We used to do MessageBeep(-1) when user hit an error, but
    // in NT bug #160090 MessageBeep will hang on HP Vectra boxes.
    // So the MessageBeep's were replaced with this func, which
    // simply flashes the window text.
    //

    SetWindowText (ghwndMain, "        Error!");
    Sleep (250);
    SetWindowText (ghwndMain, "Tapi Browser");
}


LPWSTR
PASCAL
My_lstrcpyW(
    WCHAR   *pString1,
    WCHAR   *pString2
    )
{
    //
    // lstrcpyW isn't supported on win95 (at least up to osr2)
    // so we'll use our own func
    //

    WCHAR *p = pString1;


    for (; (*p = *pString2); p++, pString2++);
    return pString1;
}


char *
PASCAL
GetTimeStamp(
    void
    )
{
    static char szEmptyString[] = "", szTimeStamp[32];
    SYSTEMTIME  systemTime;


    if (!bTimeStamp)
    {
        return szEmptyString;
    }

    GetLocalTime (&systemTime);

    wsprintf(
        szTimeStamp,
        "%d:%d.%d.%d : ",
        (DWORD) systemTime.wHour,
        (DWORD) systemTime.wMinute,
        (DWORD) systemTime.wSecond,
        (DWORD) systemTime.wMilliseconds
        );

    return szTimeStamp;
}


void
ShowLineFuncResult(
    LPSTR   lpFuncName,
    LONG    lResult
    )
{
    char   *pszTimeStamp = GetTimeStamp();


    if (lResult > 0)
    {
        ShowStr ("%s%s returned x%lx", pszTimeStamp, lpFuncName, lResult);
    }
    else if (lResult != 0 &&
             ((DWORD) lResult < LINEERR_ALLOCATED ||
             (DWORD) lResult > LAST_LINEERR))
    {
        ErrorAlert();

        ShowStr(
            "%s%s returned inval err code (x%lx)",
            pszTimeStamp,
            lpFuncName,
            lResult
            );
    }
    else
    {
        if (lResult < 0)
        {
            ErrorAlert();
        }

        ShowStr(
            "%s%s returned %s%s",
            pszTimeStamp,
            lpFuncName,
            (lResult ? "LINEERR_" : ""), // ...to shrink aszLineErrs array
            aszLineErrs[LOWORD(lResult)]
            );
    }
}


void
ShowPhoneFuncResult(
    LPSTR   lpFuncName,
    LONG    lResult
    )
{
    char *pszTimeStamp = GetTimeStamp();


    if (lResult > 0)
    {
        ShowStr ("%s%s returned x%lx", pszTimeStamp, lpFuncName, lResult);
    }
    else if (lResult != 0 &&
             ((DWORD) lResult < PHONEERR_ALLOCATED ||
             (DWORD) lResult > PHONEERR_REINIT))
    {
        ErrorAlert();

        ShowStr(
            "%s%s returned inval err code (x%lx)",
            pszTimeStamp,
            lpFuncName,
            lResult
            );
    }
    else
    {
        if (lResult < 0)
        {
            ErrorAlert();
        }

        ShowStr(
            "%s%s returned %s%s",
            pszTimeStamp,
            lpFuncName,
            (lResult ? "PHONEERR_" : ""), // ...to shrink aszPhoneErrs array
            aszPhoneErrs[LOWORD(lResult)]
            );
    }
}


void
ShowTapiFuncResult(
    LPSTR   lpFuncName,
    LONG    lResult
    )
{
    char *pszTimeStamp = GetTimeStamp();


    if ((lResult > 0) || (lResult < TAPIERR_INVALPOINTER))
    {
        ShowStr(
            "%s%s returned inval err code (x%lx)",
            pszTimeStamp,
            lpFuncName,
            lResult
            );
    }
    else
    {
        lResult = (~lResult) + 1;

        if (lResult > 0)
        {
            ErrorAlert();
        }

        ShowStr(
            "%s%s returned %s%s",
            pszTimeStamp,
            lpFuncName,
            (lResult ? "TAPIERR_" : ""), // ...to shrink aszTapiErrs array
            aszTapiErrs[lResult]
            );
    }
}


void
UpdateResults(
    BOOL bBegin
    )
{
    //
    // In order to maximize speed, minimize flash, & have the
    // latest info in the edit control scrolled into view we
    // shrink the window down and hide it. Later, when all the
    // text has been inserted in the edit control, we show
    // the window (since window must be visible in order to
    // scroll caret into view), then tell it to scroll the caret
    // (at this point the window is still 1x1 so the painting
    // overhead is 0), and finally restore the control to it's
    // full size. In doing so we have zero flash and only 1 real
    // complete paint. Also put up the hourglass for warm fuzzies.
    //

    static RECT    rect;
    static HCURSOR hCurSave;
    static int     iNumBegins = 0;


    if (bBegin)
    {
        iNumBegins++;

        if (iNumBegins > 1)
        {
            return;
        }

        hCurSave = SetCursor (LoadCursor ((HINSTANCE)NULL, IDC_WAIT));
        GetWindowRect (ghwndEdit, &rect);
        SetWindowPos(
            ghwndEdit,
            (HWND) NULL,
            0,
            0,
            1,
            1,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW |
                SWP_NOZORDER | SWP_HIDEWINDOW
            );
    }
    else
    {
        iNumBegins--;

        if (iNumBegins > 0)
        {
            return;
        }

        //
        // Do control restoration as described above
        //

        ShowWindow (ghwndEdit, SW_SHOW);
#ifdef WIN32
        SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
#else
        SendMessage(
            ghwndEdit,
            EM_SETSEL,
            (WPARAM)0,
            (LPARAM) MAKELONG(0xfffd,0xfffe)
            );
#endif
        SetWindowPos(
            ghwndEdit,
            (HWND) NULL,
            0,
            0,
            rect.right - rect.left,
            rect.bottom - rect.top,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
            );
        SetCursor (hCurSave);
    }
}


void
ShowModBytes(
    DWORD               dwSize,
    unsigned char far  *lpc,
    char               *pszTab,
    char               *buf
    )
{
    DWORD   dwSize2 = dwSize, i, j, k;


    strcpy (buf, pszTab);

    k = strlen (buf);

    for (i = 8; i < 36; i += 9)
    {
        buf[k + i] = ' ';

        for (j = 2; j < 9; j += 2)
        {
            char buf2[8] = "xx";

            if (dwSize2)
            {
                sprintf (buf2, "%02x", (int) (*lpc));
                dwSize2--;
            }

            buf[k + i - j]     = buf2[0];
            buf[k + i - j + 1] = buf2[1];

            lpc++;
        }
    }

    k += 37;

    buf[k - 1] = ' ';

    lpc -= 16;

    for (i = 0; i < dwSize; i++)
    {
        buf[k + i] = aAscii[*(lpc+i)];
    }

    buf[k + i] = 0;

    ShowStr (buf);
}


void
ShowBytes(
    DWORD   dwSize,
    LPVOID  lp,
    DWORD   dwNumTabs
    )
{
    char    tabBuf[17] = "";
    char    buf[80];
    DWORD   i, j, k, dwNumDWORDs, dwMod4 = (DWORD) (((ULONG_PTR) lp) & 3);
    LPDWORD lpdw;
    unsigned char far *lpc = (unsigned char far *) lp;


    UpdateResults (TRUE);


    for (i = 0; i < dwNumTabs; i++)
    {
        strcat (tabBuf, szTab);
    }


    //
    // Special case for unaligned pointers (will fault on ppc/mips)
    //

    if (dwMod4)
    {
        DWORD   dwNumUnalignedBytes = 4 - dwMod4,
                dwNumBytesToShow = (dwNumUnalignedBytes > dwSize ?
                    dwSize : dwNumUnalignedBytes);


        ShowModBytes (dwNumBytesToShow, lpc, tabBuf, buf);
        lpc += dwNumUnalignedBytes;
        lpdw = (LPDWORD) lpc;
        dwSize -= dwNumBytesToShow;
    }
    else
    {
        lpdw = (LPDWORD) lp;
    }


    //
    // Dump full lines of four DWORDs in hex & corresponding ASCII
    //

    if (dwSize >= (4*sizeof(DWORD)))
    {
        dwNumDWORDs = dwSize / 4; // adjust from numBytes to num DWORDs

        for (i = 0; i < (dwNumDWORDs - (dwNumDWORDs%4)); i += 4)
        {
            sprintf (
                buf,
                "%s%08lx %08lx %08lx %08lx  ",
                tabBuf,
                *lpdw,
                *(lpdw+1),
                *(lpdw+2),
                *(lpdw+3)
                );

            k = strlen (buf);

            for (j = 0; j < 16; j++)
            {
                buf[k + j] = aAscii[*(lpc + j)];
            }

            buf[k + j] = 0;

            ShowStr (buf);
            lpdw += 4;
            lpc += 16;
        }
    }


    //
    // Special case for remaining bytes to dump (0 < n < 16)
    //

    if ((dwSize %= 16))
    {
        ShowModBytes (dwSize, lpc, tabBuf, buf);
    }


    UpdateResults (FALSE);
}


void
ShowStructByDWORDs(
    LPVOID  lp
    )
{

    if (dwDumpStructsFlags & DS_BYTEDUMP)
    {
        //
        // Cast lp as DWORD, then add 2 to point to where a
        // dwUsedSize field is in a TAPI struct
        //

        ShowBytes (*(((LPDWORD) lp) + 2), lp, 0);
    }
}


void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    )
{
    static char far *aszCommonFields[] =
    {
        "dwTotalSize",
        "dwNeededSize",
        "dwUsedSize"
    };
    DWORD i, j;
    char far *buf = malloc (256);


    UpdateResults (TRUE);

    ShowStr (pHeader->szName);

    if (!bSubStructure)
    {
        LPDWORD lpdw =  (LPDWORD) pHeader->pStruct;


        for (i = 0; i < 3; i++)
        {
            ShowStr ("%s%s=x%lx", szTab, aszCommonFields[i], *lpdw);
            lpdw++;
        }
    }

    for (i = 0; i < pHeader->dwNumFields; i++)
    {
        if ((pHeader->aFields[i].dwValue == 0) &&
            !(dwDumpStructsFlags & DS_ZEROFIELDS))
        {
            continue;
        }

        sprintf(
            buf,
            "%s%s=x%lx",
            szTab,
            pHeader->aFields[i].szName,
            pHeader->aFields[i].dwValue
            );

        switch (pHeader->aFields[i].dwType)
        {
        case FT_DWORD:

            ShowStr (buf);
            break;

        case FT_FLAGS:
        {
            PLOOKUP pLookup = pHeader->aFields[i].pLookup;


            strcat (buf, ", ");

            for(
                j = 0;
                pHeader->aFields[i].dwValue, pLookup[j].dwVal != 0xffffffff;
                j++
                )
            {
                if (pHeader->aFields[i].dwValue & pLookup[j].dwVal)
                {
                    if (buf[0] == 0)
                    {
                        sprintf (buf, "%s%s", szTab, szTab);
                    }

                    strcat (buf, pLookup[j].lpszVal);
                    strcat (buf, " ");
                    pHeader->aFields[i].dwValue =
                        pHeader->aFields[i].dwValue & ~pLookup[j].dwVal;

                    if (strlen (buf) > 50)
                    {
                        //
                        // We don't want strings getting so long that
                        // they're going offscreen, so break them up.
                        //

                        ShowStr (buf);
                        buf[0] = 0;
                    }
                }
            }

            if (pHeader->aFields[i].dwValue)
            {
                strcat (buf, "<unknown flag(s)>");
            }

            if (buf[0])
            {
                ShowStr (buf);
            }

            break;
        }
        case FT_ORD:
        {
            PLOOKUP pLookup = pHeader->aFields[i].pLookup;


            strcat (buf, ", ");

            for(
                j = 0;
                pLookup[j].dwVal != 0xffffffff;
                j++
                )
            {
                if (pHeader->aFields[i].dwValue == pLookup[j].dwVal)
                {
                    strcat (buf, pLookup[j].lpszVal);
                    break;
                }
            }

            if (pLookup[j].dwVal == 0xffffffff)
            {
                strcpy (buf, "<unknown ordinal>");
            }

            ShowStr (buf);
            break;
        }
        case FT_SIZE:

            ShowStr (buf);
            break;

        case FT_OFFSET:

            ShowStr (buf);

            if (IsBadReadPtr(
                    ((char far *) pHeader->pStruct) +
                        pHeader->aFields[i].dwValue,
                    (UINT)pHeader->aFields[i-1].dwValue
                    ))
            {
                ShowStr ("<size/offset pair yields bad pointer>");
            }
            else
            {
                ShowBytes(
                    pHeader->aFields[i-1].dwValue,
                    ((char far *) pHeader->pStruct) +
                        pHeader->aFields[i].dwValue,
                    2
                    );
            }

            break;
        }
    }

    free (buf);

    UpdateResults (FALSE);
}


void
ShowVARSTRING(
    LPVARSTRING lpVarString
    )
{
    if (dwDumpStructsFlags & DS_NONZEROFIELDS)
    {
        STRUCT_FIELD fields[] =
        {
            { "dwStringFormat", FT_ORD,     lpVarString->dwStringFormat, aStringFormats },
            { "dwStringSize",   FT_SIZE,    lpVarString->dwStringSize, NULL },
            { "dwStringOffset", FT_OFFSET,  lpVarString->dwStringOffset, NULL }

        };
        STRUCT_FIELD_HEADER fieldHeader =
        {
            lpVarString,
            "VARSTRING",
            3,
            fields
        };

        ShowStructByField (&fieldHeader, FALSE);
    }
}


INT_PTR
LetUserMungeParams(
    PFUNC_PARAM_HEADER pParamsHeader
    )
{
    if (!bShowParams)
    {
        return TRUE;
    }

    return (DialogBoxParam(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
        ghwndMain,
        (DLGPROC) ParamsDlgProc,
        (LPARAM) pParamsHeader
        ));
}


void
DumpParams(
    PFUNC_PARAM_HEADER pHeader
    )
{
    if (bTimeStamp || bDumpParams)
    {
        char   *pszTimeStamp = GetTimeStamp();


        UpdateResults (TRUE);

        ShowStr(
            "%sCalling %s",
            pszTimeStamp,
            aFuncNames[pHeader->FuncIndex]
            );

        if (bDumpParams)
        {
            DWORD   i;


            for (i = 0; i < pHeader->dwNumParams; i++)
            {
                ShowStr(
                    "    %s=x%lx",
                    pHeader->aParams[i].szName,
                    pHeader->aParams[i].dwValue
                    );
            }

        }

        UpdateResults (FALSE);
    }
}


void
PASCAL
MakeWideString(
    LPVOID pString
    )
{
    if (!IsBadStringPtr ((LPCSTR) pString, 0xffffffff))
    {
        int    len = strlen ((char *) pString) + 1;
        WCHAR  buf[MAX_STRING_PARAM_SIZE/2];


        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            (LPCSTR) pString,
            (len > MAX_STRING_PARAM_SIZE/2 ? MAX_STRING_PARAM_SIZE/2 - 1 : -1),
            buf,
            MAX_STRING_PARAM_SIZE/2
            );

        buf[MAX_STRING_PARAM_SIZE/2 - 1] = 0;

        My_lstrcpyW ((WCHAR *) pString, buf);
    }
}


LONG
DoFunc(
    PFUNC_PARAM_HEADER pHeader
    )
{
    LONG    lResult;


    if (!LetUserMungeParams (pHeader))
    {
       return 0xffffffff;
    }

#if TAPI_2_0

    //
    // Convert any unicode string params as appropriate
    //

    if (gbWideStringParams)
    {
        DWORD       dwNumParams = pHeader->dwNumParams, i;
        PFUNC_PARAM pParam = pHeader->aParams;


        for (i = 0; i < dwNumParams; i++)
        {
            if (pParam->dwType == PT_STRING)
            {
                MakeWideString ((LPVOID) pParam->dwValue);
            }

            pParam++;
        }
    }

#endif

    DumpParams (pHeader);

    switch (pHeader->dwNumParams)
    {
    case 1:

        lResult = (*pHeader->u.pfn1)(
            pHeader->aParams[0].dwValue
            );
        break;

    case 2:

        lResult = (*pHeader->u.pfn2)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue
            );
        break;

    case 3:

        lResult = (*pHeader->u.pfn3)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue
            );
        break;

    case 4:

        lResult = (*pHeader->u.pfn4)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue
            );
        break;

    case 5:

        lResult = (*pHeader->u.pfn5)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue
            );
        break;

    case 6:

        lResult = (*pHeader->u.pfn6)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue
            );
        break;

    case 7:

        lResult = (*pHeader->u.pfn7)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue
            );
        break;

    case 8:

        lResult = (*pHeader->u.pfn8)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue
            );
        break;

    case 9:

        lResult = (*pHeader->u.pfn9)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue,
            pHeader->aParams[8].dwValue
            );
        break;

    case 10:

        lResult = (*pHeader->u.pfn10)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue,
            pHeader->aParams[8].dwValue,
            pHeader->aParams[9].dwValue
            );
        break;

    default: // case 12:

        lResult = (*pHeader->u.pfn12)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue,
            pHeader->aParams[8].dwValue,
            pHeader->aParams[9].dwValue,
            pHeader->aParams[10].dwValue,
            pHeader->aParams[11].dwValue
            );
        break;
    }

    if (pHeader->FuncIndex < pClose)
    {
        ShowLineFuncResult (aFuncNames[pHeader->FuncIndex], lResult);
    }
    else if (pHeader->FuncIndex < tGetLocationInfo)
    {
        ShowPhoneFuncResult (aFuncNames[pHeader->FuncIndex], lResult);
    }
    else
    {
        ShowTapiFuncResult (aFuncNames[pHeader->FuncIndex], lResult);
    }

    return lResult;
}


BOOL
IsLineAppSelected(
    void
    )
{
    if (!pLineAppSel)
    {
        if (gbDisableHandleChecking)
        {
            pLineAppSel = (PMYLINEAPP) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select an hLineApp", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsLineSelected(
    void
    )
{
    if (!pLineSel)
    {
        if (gbDisableHandleChecking)
        {
            pLineSel = (PMYLINE) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a Line", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsCallSelected(
    void
    )
{
    if (!pCallSel)
    {
        if (gbDisableHandleChecking)
        {
            pCallSel = (PMYCALL) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a Call", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsTwoCallsSelected(
    void
    )
{
    if (!pCallSel || !pCallSel2)
    {
        if (gbDisableHandleChecking)
        {
            if (!pCallSel)
            {
                pCallSel = (PMYCALL) NullWidget;
            }

            pCallSel2 = (PMYCALL) NullWidget;
        }
        else
        {
            MessageBox(
                ghwndMain,
                "Select a Call (must have at least two calls on same line)",
                "",
                MB_OK
                );
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsPhoneAppSelected(
    void
    )
{
    if (!pPhoneAppSel)
    {
        if (gbDisableHandleChecking)
        {
            pPhoneAppSel = (PMYPHONEAPP) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a PhoneApp", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsPhoneSelected(
    void
    )
{
    if (!pPhoneSel)
    {
        if (gbDisableHandleChecking)
        {
            pPhoneSel = (PMYPHONE) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a Phone", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


//
// We get a slough of C4113 (func param lists differed) warnings down below
// in the initialization of FUNC_PARAM_HEADER structs as a result of the
// real func prototypes having params that are pointers rather than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4113)

//#pragma code_seg ("myseg")

void
FuncDriver(
    FUNC_INDEX funcIndex
    )
{
    int     i;
    LONG    lResult;


#if TAPI_2_0

    //
    // Determine if we're doing a ascii or a unicode op
    //

    gbWideStringParams =
        ((aFuncNames[funcIndex])[strlen (aFuncNames[funcIndex]) - 1] == 'W' ?
            TRUE : FALSE);

#endif

    switch (funcIndex)
    {
    case lAccept:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING, (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineAccept };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lAddToConference:
    {
        FUNC_PARAM params[] =
        {
            { "hConfCall",       PT_DWORD, (ULONG_PTR) 0, NULL },
            { "hConsultCall",    PT_DWORD, (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineAddToConference };


        CHK_TWO_CALLS_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) pCallSel2->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lAgentSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,                      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,                PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwAgentExtensionIDIndex",    PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,                   PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,                     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineAgentSpecific };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
#endif
    case lAnswer:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING, (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineAnswer };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lBlindTransfer:
#if TAPI_2_0
    case lBlindTransferW:
#endif
    {
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { "dwCountryCode",      PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lBlindTransfer ?
                (PFN3) lineBlindTransfer : (PFN3) lineBlindTransferW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineBlindTransfer };
#endif



        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lClose:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineClose };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc(&paramsHeader)) == 0)
        {
            FreeLine (GetLine((HLINE) params[0].dwValue));
        }

        break;
    }
    case lCompleteCall:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,   0, NULL },
            { "lpdwCompletionID",   PT_POINTER, 0, NULL },
            { "dwCompletionMode",   PT_FLAGS,   LINECALLCOMPLMODE_CAMPON, aCallComplModes },
            { "dwMessageID",        PT_DWORD,   0, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineCompleteCall };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) &pCallSel->dwCompletionID;

// BUGBUG if user chgs hCall the wrong &pCallSel->dwCompletionID filled in

        DoFunc(&paramsHeader);

        break;
    }
    case lCompleteTransfer:
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   0, NULL },
            { "hConsultCall",   PT_DWORD,   0, NULL },
            { "lphConfCall",    PT_POINTER, 0, NULL },
            { "dwTransferMode", PT_ORDINAL, LINETRANSFERMODE_TRANSFER, aTransferModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineCompleteTransfer };


        CHK_TWO_CALLS_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) pCallSel2->hCall;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // First make sure we're created the call under the right line,
            // and if not move it to the right place in the widgets list
            //

            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);

            if (lineGetCallInfo ((HCALL) params[0].dwValue, &callInfo) == 0)
            {
                if (callInfo.hLine != pLineSel->hLine)
                {
                    MoveCallToLine (pNewCall, callInfo.hLine);
                }
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lConfigDialog:
#if TAPI_2_0
    case lConfigDialogW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,       PT_DWORD, dwDefLineDeviceID, NULL },
            { szhwndOwner,        PT_DWORD, (ULONG_PTR) ghwndMain, NULL },
            { szlpszDeviceClass,  PT_STRING, (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lConfigDialog ?
                (PFN3) lineConfigDialog : (PFN3) lineConfigDialogW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineConfigDialog };
#endif


        CHK_LINEAPP_SELECTED()

        strcpy (szDeviceClass, szDefLineDeviceClass);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineConfigDialog(
            params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPCSTR) params[2].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case lDeallocateCall:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineDeallocateCall };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            FreeCall (GetCall((HCALL) params[0].dwValue));
        }

        break;
    }
    case lDevSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,           PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineDevSpecific };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
        }

        memset (pBigBuf, 0, (size_t) dwBigBufSize);

        DoFunc (&paramsHeader);

        break;
    }
    case lDevSpecificFeature:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
//            { "dwFeature",          PT_???, 0, aPhoneButtonFunctions },
            { "dwFeature",          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,           PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineDevSpecificFeature };


        // BUGBUG need another PT_ type for constants for dwFeature param

        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);

        DoFunc (&paramsHeader);

        break;
    }
    case lDial:
#if TAPI_2_0
    case lDialW:
#endif
    {
        char szAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szAddress, szAddress },
            { "dwCountryCode",      PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lDial ?
                (PFN3) lineDial : (PFN3) lineDialW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineDial };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szAddress, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lDrop:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING, (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineDrop };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        // assert (lResult != 0);

        if (gbDeallocateCall && (lResult > 0))
        {
            PMYCALL pCall = GetCall ((HCALL) params[0].dwValue);

            dwNumPendingDrops++;
            pCall->lDropReqID = lResult;
        }

        break;
    }
    case lForward:
#if TAPI_2_0
    case lForwardW:
#endif
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,        0, NULL },
            { "bAllAddresses",      PT_DWORD,        1, NULL },
            { szdwAddressID,        PT_DWORD,        0, NULL },
            { "lpForwardList",      PT_FORWARDLIST,  0, NULL },
            { "dwNumRingsNoAnswer", PT_DWORD,        5, NULL },
            { szlphConsultCall,     PT_POINTER,      0, NULL },
            { szlpCallParams,       PT_CALLPARAMS,   0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (funcIndex == lForward ?
                (PFN7) lineForward : (PFN7) lineForwardW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineForward };
#endif
        LPLINEFORWARDLIST lpForwardList;
        DWORD   dwTotalSize = sizeof(LINEFORWARDLIST) +
                    MAX_LINEFORWARD_ENTRIES *
                    (sizeof(LINEFORWARD) + 2*MAX_STRING_PARAM_SIZE);


        CHK_LINE_SELECTED()


        if (!(lpForwardList = malloc (dwTotalSize)))
        {
            ErrorAlert();
            ShowStr ("error alloc'ing data structure");
            break;
        }

        memset (lpForwardList, 0, dwTotalSize);

        lpForwardList->dwTotalSize  = dwTotalSize;
        lpForwardList->dwNumEntries = 0;

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            free (lpForwardList);
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[3].dwValue =
        params[3].u.dwDefValue = (ULONG_PTR) lpForwardList;
        params[5].dwValue =
        params[5].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) > 0)
        {
            if (params[0].dwValue != (ULONG_PTR) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        free (lpForwardList);

        break;
    }
    case lGatherDigits:
#if TAPI_2_0
    case lGatherDigitsW:
#endif
    {
        char *buf;
        char szTermDigits[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { szhCall,                  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwDigitModes",           PT_FLAGS,   (ULONG_PTR) LINEDIGITMODE_DTMF, aDigitModes },
            { "lpsDigits",              PT_POINTER, (ULONG_PTR) 0, NULL },
            { "dwNumDigits",            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpszTerminationDigits",  PT_STRING,  (ULONG_PTR) szTermDigits, szTermDigits },
            { "dwFirstDigitTimeout",    PT_DWORD,   (ULONG_PTR) 0x8000, NULL },
            { "dwInterDigitTimeout",    PT_DWORD,   (ULONG_PTR) 0x8000, NULL },
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (funcIndex == lGatherDigits ?
                (PFN7) lineGatherDigits : (PFN7) lineGatherDigitsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineGatherDigits };
#endif

        CHK_CALL_SELECTED()

        #define DEF_NUM_GATHERED_DIGITS 64

        if (!(buf = (char *) malloc ((DEF_NUM_GATHERED_DIGITS + 1) * 2)))
        {
            ShowStr ("failed to allocate memory");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) buf;
        params[3].dwValue = DEF_NUM_GATHERED_DIGITS;

        memset (buf, 0, DEF_NUM_GATHERED_DIGITS * 2);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        if (params[0].dwValue != (DWORD) pCallSel->hCall)
        {
            pCallSel = GetCall ((HCALL) params[0].dwValue);
        }

        if (params[2].dwValue == (ULONG_PTR) buf &&
            params[3].dwValue > DEF_NUM_GATHERED_DIGITS)
        {
            if (MessageBox(
                    ghwndMain,
                    "Do you want to allocate a larger GatherDigits buffer?" \
                        "(Not doing so may cause undefined app behavior.)",
                    "Warning: lineGatherDigits",
                    MB_YESNO
                    ) == IDYES)
            {
                free (buf);

                // Note: we get weird errors in malloc when specifying a
                //       size > 0xffffff00, so special case

                if (params[3].dwValue > 0x10000)
                {
                    ShowStr ("sorry, too many digits.");
                    break;
                }

                buf = (char *) malloc ((size_t) (params[3].dwValue + 1) * 2);

                if (!(params[2].dwValue = (ULONG_PTR) buf))
                {
                    ShowStr ("failed to allocate memory");
                    break;
                }

                memset (buf, 0, (size_t) params[3].dwValue * 2);
            }
        }

        if (pCallSel->lpsGatheredDigits && params[2].dwValue)
        {
            if (MessageBox(
                    ghwndMain,
                    "GatherDigits already in progress on this hCall; if you" \
                        "continue previous digits buffer may be discarded" \
                        "without being freed",
                    "Warning: lineGatherDigits",
                    MB_OKCANCEL

                    ) == IDCANCEL)
            {
                if (buf)
                {
                    free (buf);
                }
                break;
            }
        }

        DumpParams (&paramsHeader);

#if TAPI_2_0
        if (funcIndex == lGatherDigits)
        {
            lResult = lineGatherDigits(
                (HCALL) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPSTR) params[2].dwValue,
                (DWORD) params[3].dwValue,
                (LPCSTR) params[4].dwValue,
                (DWORD) params[5].dwValue,
                (DWORD) params[6].dwValue
                );
        }
        else
        {
            MakeWideString (szTermDigits);

            lResult = lineGatherDigitsW(
                (HCALL) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPWSTR) params[2].dwValue,
                (DWORD) params[3].dwValue,
                (LPCWSTR) params[4].dwValue,
                (DWORD) params[5].dwValue,
                (DWORD) params[6].dwValue
                );
        }
#else
        lResult = lineGatherDigits(
            (HCALL) params[0].dwValue,
            params[1].dwValue,
            (LPSTR) params[2].dwValue,
            params[3].dwValue,
            (LPCSTR) params[4].dwValue,
            params[5].dwValue,
            params[6].dwValue
            );

#endif
        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult) // FAILURE
        {
            if (buf)
            {
                free (buf);
            }
        }
        else // SUCCESS
        {
            if (pCallSel->lpsGatheredDigits)
            {
                //free (pCallSel->lpsGatheredDigits);
            }

            pCallSel->lpsGatheredDigits   = (char *) params[2].dwValue;
            pCallSel->dwNumGatheredDigits = (DWORD) params[3].dwValue;
#if TAPI_2_0
            if (funcIndex == lGatherDigitsW)
            {
                pCallSel->dwNumGatheredDigits *= 2;
            }
#endif
        }

        break;
    }
    case lGenerateDigits:
#if TAPI_2_0
    case lGenerateDigitsW:
#endif
    {
        char szDigits[MAX_STRING_PARAM_SIZE] = "123";
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,  (ULONG_PTR) 0, NULL },
            { "dwDigitMode",    PT_FLAGS,  (ULONG_PTR) LINEDIGITMODE_DTMF, aDigitModes },
            { "lpszDigits",     PT_STRING, (ULONG_PTR) szDigits, szDigits },
            { "dwDuration",     PT_DWORD,  (ULONG_PTR) 0, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lGenerateDigits ?
                (PFN4) lineGenerateDigits :  (PFN4) lineGenerateDigitsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineGenerateDigits };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lGenerateTone:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,         PT_DWORD,    (ULONG_PTR) 0, NULL },
            { "dwToneMode",    PT_FLAGS,    (ULONG_PTR) LINETONEMODE_CUSTOM, aToneModes },
            { "dwDuration",    PT_DWORD,    (ULONG_PTR) 0, NULL },
            { "dwNumTones",    PT_DWORD,    (ULONG_PTR) 1, NULL },
            { "lpTones",       PT_POINTER,  (ULONG_PTR) pBigBuf, pBigBuf }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGenerateTone };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lGetAddressCaps:
#if TAPI_2_0
    case lGetAddressCapsW:
#endif
    {
        LPLINEADDRESSCAPS lpAddrCaps = (LPLINEADDRESSCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "dwExtVersion",   PT_DWORD,   (ULONG_PTR) dwDefLineExtVersion, NULL },
            { "lpAddressCaps",  PT_POINTER, (ULONG_PTR) lpAddrCaps, lpAddrCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lGetAddressCaps ?
                (PFN6) lineGetAddressCaps : (PFN6) lineGetAddressCapsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineGetAddressCaps };
#endif

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpAddrCaps, 0, (size_t) dwBigBufSize);

        lpAddrCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpAddrCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwLineDeviceID",                 FT_DWORD,   lpAddrCaps->dwLineDeviceID, NULL },
                    { "dwAddressSize",                  FT_SIZE,    lpAddrCaps->dwAddressSize, NULL },
                    { "dwAddressOffset",                FT_OFFSET,  lpAddrCaps->dwAddressOffset, NULL },
                    { "dwDevSpecificSize",              FT_SIZE,    lpAddrCaps->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",            FT_OFFSET,  lpAddrCaps->dwDevSpecificOffset, NULL },
                    { "dwAddressSharing",               FT_FLAGS,   lpAddrCaps->dwAddressSharing, aAddressSharing },
                    { "dwAddressStates",                FT_FLAGS,   lpAddrCaps->dwAddressStates, aAddressStates },
                    { "dwCallInfoStates",               FT_FLAGS,   lpAddrCaps->dwCallInfoStates, aCallInfoStates },
                    { "dwCallerIDFlags",                FT_FLAGS,   lpAddrCaps->dwCallerIDFlags, aCallerIDFlags },
                    { "dwCalledIDFlags",                FT_FLAGS,   lpAddrCaps->dwCalledIDFlags, aCallerIDFlags },
                    { "dwConnectedIDFlags",             FT_FLAGS,   lpAddrCaps->dwConnectedIDFlags, aCallerIDFlags },
                    { "dwRedirectionIDFlags",           FT_FLAGS,   lpAddrCaps->dwRedirectionIDFlags, aCallerIDFlags },
                    { "dwRedirectingIDFlags",           FT_FLAGS,   lpAddrCaps->dwRedirectingIDFlags, aCallerIDFlags },
                    { "dwCallStates",                   FT_FLAGS,   lpAddrCaps->dwCallStates, aCallStates },
                    { "dwDialToneModes",                FT_FLAGS,   lpAddrCaps->dwDialToneModes, aDialToneModes },
                    { "dwBusyModes",                    FT_FLAGS,   lpAddrCaps->dwBusyModes, aBusyModes },
                    { "dwSpecialInfo",                  FT_FLAGS,   lpAddrCaps->dwSpecialInfo, aSpecialInfo },
                    { "dwDisconnectModes",              FT_FLAGS,   lpAddrCaps->dwDisconnectModes, aDisconnectModes },
                    { "dwMaxNumActiveCalls",            FT_DWORD,   lpAddrCaps->dwMaxNumActiveCalls, NULL },
                    { "dwMaxNumOnHoldCalls",            FT_DWORD,   lpAddrCaps->dwMaxNumOnHoldCalls, NULL },
                    { "dwMaxNumOnHoldPendingCalls",     FT_DWORD,   lpAddrCaps->dwMaxNumOnHoldPendingCalls, NULL },
                    { "dwMaxNumConference",             FT_DWORD,   lpAddrCaps->dwMaxNumConference, NULL },
                    { "dwMaxNumTransConf",              FT_DWORD,   lpAddrCaps->dwMaxNumTransConf, NULL },
                    { "dwAddrCapFlags",                 FT_FLAGS,   lpAddrCaps->dwAddrCapFlags, aAddressCapFlags },
                    { "dwCallFeatures",                 FT_FLAGS,   lpAddrCaps->dwCallFeatures, aCallFeatures },
                    { "dwRemoveFromConfCaps",           FT_ORD,     lpAddrCaps->dwRemoveFromConfCaps, aRemoveFromConfCaps },
                    { "dwRemoveFromConfState",          FT_FLAGS,   lpAddrCaps->dwRemoveFromConfState, aCallStates },
                    { "dwTransferModes",                FT_FLAGS,   lpAddrCaps->dwTransferModes, aTransferModes },
                    { "dwParkModes",                    FT_FLAGS,   lpAddrCaps->dwParkModes, aParkModes },
                    { "dwForwardModes",                 FT_FLAGS,   lpAddrCaps->dwForwardModes, aForwardModes },
                    { "dwMaxForwardEntries",            FT_DWORD,   lpAddrCaps->dwMaxForwardEntries, NULL },
                    { "dwMaxSpecificEntries",           FT_DWORD,   lpAddrCaps->dwMaxSpecificEntries, NULL },
                    { "dwMinFwdNumRings",               FT_DWORD,   lpAddrCaps->dwMinFwdNumRings, NULL },
                    { "dwMaxFwdNumRings",               FT_DWORD,   lpAddrCaps->dwMaxFwdNumRings, NULL },
                    { "dwMaxCallCompletions",           FT_DWORD,   lpAddrCaps->dwMaxCallCompletions, NULL },
                    { "dwCallCompletionConds",          FT_FLAGS,   lpAddrCaps->dwCallCompletionConds, aCallComplConds },
                    { "dwCallCompletionModes",          FT_FLAGS,   lpAddrCaps->dwCallCompletionModes, aCallComplModes },
                    { "dwNumCompletionMessages",        FT_DWORD,   lpAddrCaps->dwNumCompletionMessages, NULL },
                    { "dwCompletionMsgTextEntrySize",   FT_DWORD,   lpAddrCaps->dwCompletionMsgTextEntrySize, NULL },
                    { "dwCompletionMsgTextSize",        FT_SIZE,    lpAddrCaps->dwCompletionMsgTextSize, NULL },
                    { "dwCompletionMsgTextOffset",      FT_OFFSET,  lpAddrCaps->dwCompletionMsgTextOffset, NULL }
#if TAPI_1_1
                     ,
                    { "dwAddressFeatures",              FT_FLAGS,   0, aAddressFeatures }
#if TAPI_2_0
                     ,
                    { "dwPredictiveAutoTransferStates", FT_FLAGS,   0, aCallStates },
                    { "dwNumCallTreatments",            FT_DWORD,   0, NULL },
                    { "dwCallTreatmentListSize",        FT_SIZE,    0, NULL },
                    { "dwCallTreatmentListOffset",      FT_OFFSET,  0, NULL },
                    { "dwDeviceClassesSize",            FT_SIZE,    0, NULL },
                    { "dwDeviceClassesOffset",          FT_OFFSET,  0, NULL },
                    { "dwMaxCallDataSize",              FT_DWORD,   0, NULL },
                    { "dwCallFeatures2",                FT_FLAGS,   0, aCallFeatures2 },
                    { "dwMaxNoAnswerTimeout",           FT_DWORD,   0, NULL },
                    { "dwConnectedModes",               FT_FLAGS,   0, aConnectedModes },
                    { "dwOfferingModes",                FT_FLAGS,   0, aOfferingModes },
                    { "dwAvailableMediaModes",          FT_FLAGS,   0, aMediaModes }
#endif
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpAddrCaps, "LINEADDRESSCAPS", 0, fields
                };


                if (params[3].dwValue == 0x10003)
                {
                    //
                    // Only show ver 1.0 params
                    //

                    fieldHeader.dwNumFields = 41;
                }
#if TAPI_1_1
                else if (params[3].dwValue == 0x10004)
                {
                    //
                    // Only show <= ver 1.4 params
                    //

                    fieldHeader.dwNumFields = 42;

                    fields[41].dwValue = lpAddrCaps->dwAddressFeatures;
                }
#if TAPI_2_0
                else
                {
                    //
                    // Only show <= ver 2.0 params
                    //

                    fieldHeader.dwNumFields = 54;

                    fields[41].dwValue = lpAddrCaps->dwAddressFeatures;
                    fields[42].dwValue = lpAddrCaps->dwPredictiveAutoTransferStates;
                    fields[43].dwValue = lpAddrCaps->dwNumCallTreatments;
                    fields[44].dwValue = lpAddrCaps->dwCallTreatmentListSize;
                    fields[45].dwValue = lpAddrCaps->dwCallTreatmentListOffset;
                    fields[46].dwValue = lpAddrCaps->dwDeviceClassesSize;
                    fields[47].dwValue = lpAddrCaps->dwDeviceClassesOffset;
                    fields[48].dwValue = lpAddrCaps->dwMaxCallDataSize;
                    fields[49].dwValue = lpAddrCaps->dwCallFeatures2;
                    fields[50].dwValue = lpAddrCaps->dwMaxNoAnswerTimeout;
                    fields[51].dwValue = lpAddrCaps->dwConnectedModes;
                    fields[52].dwValue = lpAddrCaps->dwOfferingModes;
                    fields[53].dwValue = lpAddrCaps->dwAvailableMediaModes;
                }
#endif
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetAddressID:
#if TAPI_2_0
    case lGetAddressIDW:
#endif
    {
        DWORD dwAddressID;
        char  szAddress[MAX_STRING_PARAM_SIZE] = "0";
        LPLINEADDRESSCAPS lpAddrCaps = (LPLINEADDRESSCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwAddressID",  PT_POINTER, (ULONG_PTR) &dwAddressID, &dwAddressID },
            { "dwAddressMode",  PT_FLAGS,   (ULONG_PTR) LINEADDRESSMODE_DIALABLEADDR, aAddressModes },
            { "lpsAddress",     PT_STRING,  (ULONG_PTR) szAddress, szAddress },
            { szdwSize,         PT_DWORD,   (ULONG_PTR) 2, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lGetAddressID ?
                (PFN5) lineGetAddressID : (PFN5) lineGetAddressIDW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGetAddressID };
#endif

        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%s%s=x%lx", szTab, szdwAddressID, dwAddressID);
        }

        break;
    }
    case lGetAddressStatus:
#if TAPI_2_0
    case lGetAddressStatusW:
#endif
    {
        LPLINEADDRESSSTATUS lpAddrStatus = (LPLINEADDRESSSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAddressCaps",  PT_POINTER, (ULONG_PTR) lpAddrStatus, lpAddrStatus }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetAddressStatus ?
                (PFN3) lineGetAddressStatus : (PFN3) lineGetAddressStatusW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetAddressStatus };
#endif


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpAddrStatus, 0, (size_t) dwBigBufSize);
        lpAddrStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpAddrStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwNumInUse",             FT_DWORD,   lpAddrStatus->dwNumInUse, NULL },
                    { "dwNumActiveCalls",       FT_DWORD,   lpAddrStatus->dwNumActiveCalls, NULL },
                    { "dwNumOnHoldCalls",       FT_DWORD,   lpAddrStatus->dwNumOnHoldCalls, NULL },
                    { "dwNumOnHoldPendCalls",   FT_DWORD,   lpAddrStatus->dwNumOnHoldPendCalls, NULL },
                    { "dwAddressFeatures",      FT_FLAGS,   lpAddrStatus->dwAddressFeatures, aAddressFeatures },
                    { "dwNumRingsNoAnswer",     FT_DWORD,   lpAddrStatus->dwNumRingsNoAnswer, NULL },
                    { "dwForwardNumEntries",    FT_DWORD,   lpAddrStatus->dwForwardNumEntries, NULL },
                    { "dwForwardSize",          FT_SIZE,    lpAddrStatus->dwForwardSize, NULL },
                    { "dwForwardOffset",        FT_OFFSET,  lpAddrStatus->dwForwardOffset, NULL },
                    { "dwTerminalModesSize",    FT_SIZE,    lpAddrStatus->dwTerminalModesSize, NULL },
                    { "dwTerminalModesOffset",  FT_OFFSET,  lpAddrStatus->dwTerminalModesOffset, NULL },
                    { "dwDevSpecificSize",      FT_SIZE,    lpAddrStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpAddrStatus->dwDevSpecificOffset, NULL }
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpAddrStatus,
                    "LINEADDRESSSTATUS",
                    13,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
#if TAPI_2_0
    case lGetAgentActivityList:
    case lGetAgentActivityListW:
    {
        LPLINEAGENTACTIVITYLIST lpActivityList = (LPLINEAGENTACTIVITYLIST)
                                    pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,                  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,            PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentActivityList",    PT_POINTER, (ULONG_PTR) lpActivityList, lpActivityList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetAgentActivityList ?
                (PFN3) lineGetAgentActivityList :
                (PFN3) lineGetAgentActivityListW) };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpActivityList, 0, (size_t) dwBigBufSize);
        lpActivityList->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent activity list on successful async completion

        break;
    }
    case lGetAgentCaps:
    {
        LPLINEAGENTCAPS lpAgentCaps = (LPLINEAGENTCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpAgentCaps",    PT_POINTER, (ULONG_PTR) lpAgentCaps, lpAgentCaps }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGetAgentCaps };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpAgentCaps, 0, (size_t) dwBigBufSize);
        lpAgentCaps->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent caps on successful async completion

        break;
    }
    case lGetAgentGroupList:
    {
        LPLINEAGENTGROUPLIST    lpGroupList = (LPLINEAGENTGROUPLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentGroupList",   PT_POINTER, (ULONG_PTR) lpGroupList, lpGroupList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetAgentGroupList };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpGroupList, 0, (size_t) dwBigBufSize);
        lpGroupList->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent group list on successful async completion

        break;
    }
    case lGetAgentStatus:
    {
        LPLINEAGENTSTATUS   lpStatus = (LPLINEAGENTSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentStatus",  PT_POINTER, (ULONG_PTR) lpStatus, lpStatus }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetAgentStatus };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpStatus, 0, (size_t) dwBigBufSize);
        lpStatus->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent status on successful async completion

        break;
    }
#endif
    case lGetCallInfo:
#if TAPI_2_0
    case lGetCallInfoW:
#endif
    {
        LPLINECALLINFO lpCallInfo = (LPLINECALLINFO) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallInfo", PT_POINTER, (ULONG_PTR) lpCallInfo, lpCallInfo }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == lGetCallInfo ?
                (PFN2) lineGetCallInfo : (PFN2) lineGetCallInfoW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetCallInfo };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpCallInfo, 0x5a, (size_t) dwBigBufSize);
        lpCallInfo->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallInfo);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { szhLine,                      FT_DWORD,   (DWORD)lpCallInfo->hLine, NULL },
                    { "dwLineDeviceID",             FT_DWORD,   lpCallInfo->dwLineDeviceID, NULL },
                    { szdwAddressID,                FT_DWORD,   lpCallInfo->dwAddressID, NULL },
                    { "dwBearerMode",               FT_FLAGS,   lpCallInfo->dwBearerMode, aBearerModes },
                    { "dwRate",                     FT_DWORD,   lpCallInfo->dwRate, NULL },
                    { "dwMediaMode",                FT_FLAGS,   lpCallInfo->dwMediaMode, aMediaModes },
                    { "dwAppSpecific",              FT_DWORD,   lpCallInfo->dwAppSpecific, NULL },
                    { "dwCallID",                   FT_DWORD,   lpCallInfo->dwCallID, NULL },
                    { "dwRelatedCallID",            FT_DWORD,   lpCallInfo->dwRelatedCallID, NULL },
                    { "dwCallParamFlags",           FT_FLAGS,   lpCallInfo->dwCallParamFlags, aCallParamFlags },
                    { "dwCallStates",               FT_FLAGS,   lpCallInfo->dwCallStates, aCallStates },
                    { "dwMonitorDigitModes",        FT_FLAGS,   lpCallInfo->dwMonitorDigitModes, aDigitModes },
                    { "dwMonitorMediaModes",        FT_FLAGS,   lpCallInfo->dwMonitorMediaModes, aMediaModes },
                    { "DialParams.dwDialPause",         FT_DWORD,   lpCallInfo->DialParams.dwDialPause, NULL },
                    { "DialParams.dwDialSpeed",         FT_DWORD,   lpCallInfo->DialParams.dwDialSpeed, NULL },
                    { "DialParams.dwDigitDuration",     FT_DWORD,   lpCallInfo->DialParams.dwDigitDuration, NULL },
                    { "DialParams.dwWaitForDialtone",   FT_DWORD,   lpCallInfo->DialParams.dwWaitForDialtone, NULL },
                    { "dwOrigin",                   FT_FLAGS,   lpCallInfo->dwOrigin, aCallOrigins },
                    { "dwReason",                   FT_FLAGS,   lpCallInfo->dwReason, aCallReasons },
                    { "dwCompletionID",             FT_DWORD,   lpCallInfo->dwCompletionID, NULL },
                    { "dwNumOwners",                FT_DWORD,   lpCallInfo->dwNumOwners, NULL },
                    { "dwNumMonitors",              FT_DWORD,   lpCallInfo->dwNumMonitors, NULL },
                    { "dwCountryCode",              FT_DWORD,   lpCallInfo->dwCountryCode, NULL },
                    { "dwTrunk",                    FT_DWORD,   lpCallInfo->dwTrunk, NULL },
                    { "dwCallerIDFlags",            FT_FLAGS,   lpCallInfo->dwCallerIDFlags, aCallerIDFlags },
                    { "dwCallerIDSize",             FT_SIZE,    lpCallInfo->dwCallerIDSize, NULL },
                    { "dwCallerIDOffset",           FT_OFFSET,  lpCallInfo->dwCallerIDOffset, NULL },
                    { "dwCallerIDNameSize",         FT_SIZE,    lpCallInfo->dwCallerIDNameSize, NULL },
                    { "dwCallerIDNameOffset",       FT_OFFSET,  lpCallInfo->dwCallerIDNameOffset, NULL },
                    { "dwCalledIDFlags",            FT_FLAGS,   lpCallInfo->dwCalledIDFlags, aCallerIDFlags },
                    { "dwCalledIDSize",             FT_SIZE,    lpCallInfo->dwCalledIDSize, NULL },
                    { "dwCalledIDOffset",           FT_OFFSET,  lpCallInfo->dwCalledIDOffset, NULL },
                    { "dwCalledIDNameSize",         FT_SIZE,    lpCallInfo->dwCalledIDNameSize, NULL },
                    { "dwCalledIDNameOffset",       FT_OFFSET,  lpCallInfo->dwCalledIDNameOffset, NULL },
                    { "dwConnectedIDFlags",         FT_FLAGS,   lpCallInfo->dwConnectedIDFlags, aCallerIDFlags },
                    { "dwConnectedIDSize",          FT_SIZE,    lpCallInfo->dwConnectedIDSize, NULL },
                    { "dwConnectedIDOffset",        FT_OFFSET,  lpCallInfo->dwConnectedIDOffset, NULL },
                    { "dwConnectedIDNameSize",      FT_SIZE,    lpCallInfo->dwConnectedIDNameSize, NULL },
                    { "dwConnectedIDNameOffset",    FT_OFFSET,  lpCallInfo->dwConnectedIDNameOffset, NULL },
                    { "dwRedirectionIDFlags",       FT_FLAGS,   lpCallInfo->dwRedirectionIDFlags, aCallerIDFlags },
                    { "dwRedirectionIDSize",        FT_SIZE,    lpCallInfo->dwRedirectionIDSize, NULL },
                    { "dwRedirectionIDOffset",      FT_OFFSET,  lpCallInfo->dwRedirectionIDOffset, NULL },
                    { "dwRedirectionIDNameSize",    FT_SIZE,    lpCallInfo->dwRedirectionIDNameSize, NULL },
                    { "dwRedirectionIDNameOffset",  FT_OFFSET,  lpCallInfo->dwRedirectionIDNameOffset, NULL },
                    { "dwRedirectingIDFlags",       FT_FLAGS,   lpCallInfo->dwRedirectingIDFlags, aCallerIDFlags },
                    { "dwRedirectingIDSize",        FT_SIZE,    lpCallInfo->dwRedirectingIDSize, NULL },
                    { "dwRedirectingIDOffset",      FT_OFFSET,  lpCallInfo->dwRedirectingIDOffset, NULL },
                    { "dwRedirectingIDNameSize",    FT_SIZE,    lpCallInfo->dwRedirectingIDNameSize, NULL },
                    { "dwRedirectingIDNameOffset",  FT_OFFSET,  lpCallInfo->dwRedirectingIDNameOffset, NULL },
                    { "dwAppNameSize",              FT_SIZE,    lpCallInfo->dwAppNameSize, NULL },
                    { "dwAppNameOffset",            FT_OFFSET,  lpCallInfo->dwAppNameOffset, NULL },
                    { "dwDisplayableAddressSize",   FT_SIZE,    lpCallInfo->dwDisplayableAddressSize, NULL },
                    { "dwDisplayableAddressOffset", FT_OFFSET,  lpCallInfo->dwDisplayableAddressOffset, NULL },
                    { "dwCalledPartySize",          FT_SIZE,    lpCallInfo->dwCalledPartySize, NULL },
                    { "dwCalledPartyOffset",        FT_OFFSET,  lpCallInfo->dwCalledPartyOffset, NULL },
                    { "dwCommentSize",              FT_SIZE,    lpCallInfo->dwCommentSize, NULL },
                    { "dwCommentOffset",            FT_OFFSET,  lpCallInfo->dwCommentOffset, NULL },
                    { "dwDisplaySize",              FT_SIZE,    lpCallInfo->dwDisplaySize, NULL },
                    { "dwDisplayOffset",            FT_OFFSET,  lpCallInfo->dwDisplayOffset, NULL },
                    { "dwUserUserInfoSize",         FT_SIZE,    lpCallInfo->dwUserUserInfoSize, NULL },
                    { "dwUserUserInfoOffset",       FT_OFFSET,  lpCallInfo->dwUserUserInfoOffset, NULL },
                    { "dwHighLevelCompSize",        FT_SIZE,    lpCallInfo->dwHighLevelCompSize, NULL },
                    { "dwHighLevelCompOffset",      FT_OFFSET,  lpCallInfo->dwHighLevelCompOffset, NULL },
                    { "dwLowLevelCompSize",         FT_SIZE,    lpCallInfo->dwLowLevelCompSize, NULL },
                    { "dwLowLevelCompOffset",       FT_OFFSET,  lpCallInfo->dwLowLevelCompOffset, NULL },
                    { "dwChargingInfoSize",         FT_SIZE,    lpCallInfo->dwChargingInfoSize, NULL },
                    { "dwChargingInfoOffset",       FT_OFFSET,  lpCallInfo->dwChargingInfoOffset, NULL },
                    { "dwTerminalModesSize",        FT_SIZE,    lpCallInfo->dwTerminalModesSize, NULL },
                    { "dwTerminalModesOffset",      FT_OFFSET,  lpCallInfo->dwTerminalModesOffset, NULL },
                    { "dwDevSpecificSize",          FT_SIZE,    lpCallInfo->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",        FT_OFFSET,  lpCallInfo->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwCallTreatment",            FT_DWORD,   0, NULL },
                    { "dwCallDataSize",             FT_SIZE,    0, NULL },
                    { "dwCallDataOffset",           FT_OFFSET,  0, NULL },
                    { "dwSendingFlowspecSize",      FT_SIZE,    0, NULL },
                    { "dwSendingFlowspecOffset",    FT_OFFSET,  0, NULL },
                    { "dwReceivingFlowspecSize",    FT_SIZE,    0, NULL },
                    { "dwReceivingFlowspecOffset",  FT_OFFSET,  0, NULL }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallInfo, "LINECALLINFO", 0, fields
                };


                if (pLineSel->dwAPIVersion < 0x00020000)
                {
                    //
                    // Only show ver 1.0 params
                    //

                    fieldHeader.dwNumFields = 71;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 78;

                    fields[71].dwValue = lpCallInfo->dwCallTreatment;
                    fields[72].dwValue = lpCallInfo->dwCallDataSize;
                    fields[73].dwValue = lpCallInfo->dwCallDataOffset;
                    fields[74].dwValue = lpCallInfo->dwSendingFlowspecSize;
                    fields[75].dwValue = lpCallInfo->dwSendingFlowspecOffset;
                    fields[76].dwValue = lpCallInfo->dwReceivingFlowspecSize;
                    fields[77].dwValue = lpCallInfo->dwReceivingFlowspecOffset;
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetCallStatus:
    {
        LPLINECALLSTATUS lpCallStatus = (LPLINECALLSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallStatus",   PT_POINTER, (ULONG_PTR) lpCallStatus, lpCallStatus }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetCallStatus };
        DWORD   dwAPIVersion;


        CHK_CALL_SELECTED()

        dwAPIVersion = pLineSel->dwAPIVersion;

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpCallStatus, 0, (size_t) dwBigBufSize);
        lpCallStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwCallState",            FT_FLAGS,   lpCallStatus->dwCallState, aCallStates },
                    { "dwCallStateMode",        FT_FLAGS,   lpCallStatus->dwCallStateMode, NULL },
                    { "dwCallPrivilege",        FT_FLAGS,   lpCallStatus->dwCallPrivilege, aCallPrivileges },
                    { "dwCallFeatures",         FT_FLAGS,   lpCallStatus->dwCallFeatures, aCallFeatures },
                    { "dwDevSpecificSize",      FT_SIZE,    lpCallStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpCallStatus->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwCallFeatures2",        FT_FLAGS,   0, aCallFeatures2 },
                    { "tStateEntryTime[0]",     FT_DWORD,   0, NULL },
                    { "tStateEntryTime[1]",     FT_DWORD,   0, NULL },
                    { "tStateEntryTime[2]",     FT_DWORD,   0, NULL },
                    { "tStateEntryTime[3]",     FT_DWORD,   0, NULL }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallStatus, "LINECALLSTATUS", 0, fields
                };


                switch (lpCallStatus->dwCallState)
                {
                case LINECALLSTATE_DIALTONE:

                    fields[1].pLookup = aDialToneModes;
                    break;

                case LINECALLSTATE_BUSY:

                    fields[1].pLookup = aBusyModes;
                    break;

                case LINECALLSTATE_SPECIALINFO:

                    fields[1].pLookup = aSpecialInfo;
                    break;

                case LINECALLSTATE_DISCONNECTED:

                    fields[1].pLookup = aDisconnectModes;
                    break;

                default:

                    fields[1].dwType = FT_DWORD;
                    break;
                }

                if (dwAPIVersion < 0x00020000)
                {
                    fieldHeader.dwNumFields = 6;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 11;

                    fields[6].dwValue  = lpCallStatus->dwCallFeatures2;
                    fields[7].dwValue  = *((LPDWORD) &lpCallStatus->tStateEntryTime);
                    fields[8].dwValue  = *(((LPDWORD) &lpCallStatus->tStateEntryTime) + 1);
                    fields[9].dwValue  = *(((LPDWORD) &lpCallStatus->tStateEntryTime) + 2);
                    fields[10].dwValue = *(((LPDWORD) &lpCallStatus->tStateEntryTime) + 3);
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetConfRelatedCalls:
    {
        LPLINECALLLIST lpCallList = (LPLINECALLLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallList", PT_POINTER, (ULONG_PTR) lpCallList, lpCallList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetConfRelatedCalls };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpCallList, 0, (size_t) dwBigBufSize);
        lpCallList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwCallsNumEntries",  FT_DWORD,   lpCallList->dwCallsNumEntries, NULL },
                    { "dwCallsSize",        FT_SIZE,    lpCallList->dwCallsSize, NULL },
                    { "dwCallsOffset",      FT_OFFSET,  lpCallList->dwCallsOffset, NULL }

                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallList,
                    "LINECALLLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetDevCaps:
#if TAPI_2_0
    case lGetDevCapsW:
#endif
    {
        LPLINEDEVCAPS lpDevCaps = (LPLINEDEVCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "dwExtVersion",   PT_DWORD,   (ULONG_PTR) dwDefLineExtVersion, NULL },
            { "lpLineDevCaps",  PT_POINTER, (ULONG_PTR) lpDevCaps, lpDevCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lGetDevCaps ?
                (PFN5) lineGetDevCaps : (PFN5) lineGetDevCapsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGetDevCaps };
#endif

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpDevCaps, 0, (size_t) dwBigBufSize);
        lpDevCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwProviderInfoSize",             FT_SIZE,    lpDevCaps->dwProviderInfoSize, NULL },
                    { "dwProviderInfoOffset",           FT_OFFSET,  lpDevCaps->dwProviderInfoOffset, NULL },
                    { "dwSwitchInfoSize",               FT_SIZE,    lpDevCaps->dwSwitchInfoSize, NULL },
                    { "dwSwitchInfoOffset",             FT_OFFSET,  lpDevCaps->dwSwitchInfoOffset, NULL },
                    { "dwPermanentLineID",              FT_DWORD,   lpDevCaps->dwPermanentLineID, NULL },
                    { "dwLineNameSize",                 FT_SIZE,    lpDevCaps->dwLineNameSize, NULL },
                    { "dwLineNameOffset",               FT_OFFSET,  lpDevCaps->dwLineNameOffset, NULL },
                    { "dwStringFormat",                 FT_ORD,     lpDevCaps->dwStringFormat, aStringFormats },
                    { "dwAddressModes",                 FT_FLAGS,   lpDevCaps->dwAddressModes, aAddressModes },
                    { "dwNumAddresses",                 FT_DWORD,   lpDevCaps->dwNumAddresses, NULL },
                    { "dwBearerModes",                  FT_FLAGS,   lpDevCaps->dwBearerModes, aBearerModes },
                    { "dwMaxRate",                      FT_DWORD,   lpDevCaps->dwMaxRate, NULL },
                    { "dwMediaModes",                   FT_FLAGS,   lpDevCaps->dwMediaModes, aMediaModes },
                    { "dwGenerateToneModes",            FT_FLAGS,   lpDevCaps->dwGenerateToneModes, aToneModes },
                    { "dwGenerateToneMaxNumFreq",       FT_DWORD,   lpDevCaps->dwGenerateToneMaxNumFreq, NULL },
                    { "dwGenerateDigitModes",           FT_FLAGS,   lpDevCaps->dwGenerateDigitModes, aDigitModes },
                    { "dwMonitorToneMaxNumFreq",        FT_DWORD,   lpDevCaps->dwMonitorToneMaxNumFreq, NULL },
                    { "dwMonitorToneMaxNumEntries",     FT_DWORD,   lpDevCaps->dwMonitorToneMaxNumEntries, NULL },
                    { "dwMonitorDigitModes",            FT_FLAGS,   lpDevCaps->dwMonitorDigitModes, aDigitModes },
                    { "dwGatherDigitsMinTimeout",       FT_DWORD,   lpDevCaps->dwGatherDigitsMinTimeout, NULL },
                    { "dwGatherDigitsMaxTimeout",       FT_DWORD,   lpDevCaps->dwGatherDigitsMaxTimeout, NULL },
                    { "dwMedCtlDigitMaxListSize",       FT_DWORD,   lpDevCaps->dwMedCtlDigitMaxListSize, NULL },
                    { "dwMedCtlMediaMaxListSize",       FT_DWORD,   lpDevCaps->dwMedCtlMediaMaxListSize, NULL },
                    { "dwMedCtlToneMaxListSize",        FT_DWORD,   lpDevCaps->dwMedCtlToneMaxListSize, NULL },
                    { "dwMedCtlCallStateMaxListSize",   FT_DWORD,   lpDevCaps->dwMedCtlCallStateMaxListSize, NULL },
                    { "dwDevCapFlags",                  FT_FLAGS,   lpDevCaps->dwDevCapFlags, aDevCapsFlags },
                    { "dwMaxNumActiveCalls",            FT_DWORD,   lpDevCaps->dwMaxNumActiveCalls, NULL },
                    { "dwAnswerMode",                   FT_FLAGS,   lpDevCaps->dwAnswerMode, aAnswerModes },
                    { "dwRingModes",                    FT_DWORD,   lpDevCaps->dwRingModes, NULL },
                    { "dwLineStates",                   FT_FLAGS,   lpDevCaps->dwLineStates, aLineStates },
                    { "dwUUIAcceptSize",                FT_DWORD,   lpDevCaps->dwUUIAcceptSize, NULL },
                    { "dwUUIAnswerSize",                FT_DWORD,   lpDevCaps->dwUUIAnswerSize, NULL },
                    { "dwUUIMakeCallSize",              FT_DWORD,   lpDevCaps->dwUUIMakeCallSize, NULL },
                    { "dwUUIDropSize",                  FT_DWORD,   lpDevCaps->dwUUIDropSize, NULL },
                    { "dwUUISendUserUserInfoSize",      FT_DWORD,   lpDevCaps->dwUUISendUserUserInfoSize, NULL },
                    { "dwUUICallInfoSize",              FT_DWORD,   lpDevCaps->dwUUICallInfoSize, NULL },
                    { "MinDialParams.dwDialPause",          FT_DWORD,   lpDevCaps->MinDialParams.dwDialPause, NULL },
                    { "MinDialParams.dwDialSpeed",          FT_DWORD,   lpDevCaps->MinDialParams.dwDialSpeed, NULL },
                    { "MinDialParams.dwDigitDuration",      FT_DWORD,   lpDevCaps->MinDialParams.dwDigitDuration, NULL },
                    { "MinDialParams.dwWaitForDialtone",    FT_DWORD,   lpDevCaps->MinDialParams.dwWaitForDialtone, NULL },
                    { "MaxDialParams.dwDialPause",          FT_DWORD,   lpDevCaps->MaxDialParams.dwDialPause, NULL },
                    { "MaxDialParams.dwDialSpeed",          FT_DWORD,   lpDevCaps->MaxDialParams.dwDialSpeed, NULL },
                    { "MaxDialParams.dwDigitDuration",      FT_DWORD,   lpDevCaps->MaxDialParams.dwDigitDuration, NULL },
                    { "MaxDialParams.dwWaitForDialtone",    FT_DWORD,   lpDevCaps->MaxDialParams.dwWaitForDialtone, NULL },
                    { "DefDialParams.dwDialPause",          FT_DWORD,   lpDevCaps->DefaultDialParams.dwDialPause, NULL },
                    { "DefDialParams.dwDialSpeed",          FT_DWORD,   lpDevCaps->DefaultDialParams.dwDialSpeed, NULL },
                    { "DefDialParams.dwDigitDuration",      FT_DWORD,   lpDevCaps->DefaultDialParams.dwDigitDuration, NULL },
                    { "DefDialParams.dwWaitForDialtone",    FT_DWORD,   lpDevCaps->DefaultDialParams.dwWaitForDialtone, NULL },
                    { "dwNumTerminals",                 FT_DWORD,   lpDevCaps->dwNumTerminals, NULL },
                    { "dwTerminalCapsSize",             FT_SIZE,    lpDevCaps->dwTerminalCapsSize, NULL },
                    { "dwTerminalCapsOffset",           FT_OFFSET,  lpDevCaps->dwTerminalCapsOffset, NULL },
                    { "dwTerminalTextEntrySize",        FT_DWORD,   lpDevCaps->dwTerminalTextEntrySize, NULL },
                    { "dwTerminalTextSize",             FT_SIZE,    lpDevCaps->dwTerminalTextSize, NULL },
                    { "dwTerminalTextOffset",           FT_OFFSET,  lpDevCaps->dwTerminalTextOffset, NULL },
                    { "dwDevSpecificSize",              FT_SIZE,    lpDevCaps->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",            FT_OFFSET,  lpDevCaps->dwDevSpecificOffset, NULL }
#if TAPI_1_1
                     ,
                    { "dwLineFeatures",                 FT_FLAGS,   0, aLineFeatures }
#if TAPI_2_0
                     ,
                    { "dwSettableDevStatus",            FT_FLAGS,   0, aLineDevStatusFlags },
                    { "dwDeviceClassesSize",            FT_SIZE,    0, NULL },
                    { "dwDeviceClassesOffset",          FT_OFFSET,  0, NULL }
#if TAPI_2_2
                     ,
                    { "PermanentLineGuid(Size)",        FT_SIZE,    sizeof (lpDevCaps->PermanentLineGuid), NULL },
                    { "PermanentLineGuid(Offset)",      FT_OFFSET,  ((LPBYTE) &lpDevCaps->PermanentLineGuid) - ((LPBYTE) lpDevCaps), NULL }
#endif
#endif
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpDevCaps, "LINEDEVCAPS", 0, fields
                };

                if (params[2].dwValue == 0x10003)
                {
                    //
                    // Only show ver 1.0 params
                    //

                    fieldHeader.dwNumFields = 56;
                }
#if TAPI_1_1
                else if (params[2].dwValue == 0x10004)
                {
                    //
                    // Only show <= ver 1.1 params
                    //

                    fieldHeader.dwNumFields = 57;

                    fields[56].dwValue = lpDevCaps->dwLineFeatures;
                }
#if TAPI_2_0
                else
                {
                    //
                    // Only show <= ver 2.0 params
                    //

                    fieldHeader.dwNumFields = 60;

                    fields[56].dwValue = lpDevCaps->dwLineFeatures;
                    fields[57].dwValue = lpDevCaps->dwSettableDevStatus;
                    fields[58].dwValue = lpDevCaps->dwDeviceClassesSize;
                    fields[59].dwValue = lpDevCaps->dwDeviceClassesOffset;
#if TAPI_2_2
                    if (params[2].dwValue >= 0x20002)
                    {
                        fieldHeader.dwNumFields += 2;
                    }
#endif
                }
#endif
#endif

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetDevConfig:
#if TAPI_2_0
    case lGetDevConfigW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpDevConfig = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { "lpDeviceConfig",     PT_POINTER, (ULONG_PTR) lpDevConfig, lpDevConfig },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetDevConfig ?
                (PFN3) lineGetDevConfig : (PFN3) lineGetDevConfigW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetDevConfig };
#endif

        memset (lpDevConfig, 0, (size_t) dwBigBufSize);
        lpDevConfig->dwTotalSize = dwBigBufSize;

        strcpy (szDeviceClass, szDefLineDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevConfig);

            ShowVARSTRING (lpDevConfig);
        }

        break;
    }
    case lGetIcon:
#if TAPI_2_0
    case lGetIconW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE] = "";
        HICON hIcon;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lphIcon",            PT_POINTER, (ULONG_PTR) &hIcon, &hIcon }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetIcon ?
                (PFN3) lineGetIcon : (PFN3) lineGetIconW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetIcon };
#endif

        strcpy (szDeviceClass, szDefLineDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            DialogBoxParam (
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG5),
                (HWND) ghwndMain,
                (DLGPROC) IconDlgProc,
                (LPARAM) hIcon
                );
        }

        break;
    }
    case lGetID:
#if TAPI_2_0
    case lGetIDW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpDevID = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwSelect",           PT_ORDINAL, (ULONG_PTR) LINECALLSELECT_LINE, aCallSelects },
            { "lpDeviceID",         PT_POINTER, (ULONG_PTR) lpDevID, lpDevID },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lGetID ?
                (PFN6) lineGetID : (PFN6) lineGetIDW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineGetID };
#endif


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
            params[3].dwValue = LINECALLSELECT_CALL;
        }
        else
        {
            params[3].dwValue = LINECALLSELECT_LINE;
        }

        memset (lpDevID, 0, (size_t) dwBigBufSize);
        lpDevID->dwTotalSize = dwBigBufSize;

        strcpy (szDeviceClass, szDefLineDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevID);

            ShowVARSTRING (lpDevID);
        }

        break;
    }
    case lGetLineDevStatus:
#if TAPI_2_0
    case lGetLineDevStatusW:
#endif
    {
        LPLINEDEVSTATUS lpDevStatus = (LPLINEDEVSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpLineDevStatus",    PT_POINTER, (ULONG_PTR) lpDevStatus, lpDevStatus }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == lGetLineDevStatus ?
                (PFN2) lineGetLineDevStatus : (PFN2) lineGetLineDevStatusW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetLineDevStatus };
#endif
        DWORD   dwAPIVersion;


        CHK_LINE_SELECTED()

        dwAPIVersion = pLineSel->dwAPIVersion;

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpDevStatus, 0, (size_t) dwBigBufSize);
        lpDevStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwNumOpens",             FT_DWORD,   lpDevStatus->dwNumOpens, NULL },
                    { "dwOpenMediaModes",       FT_FLAGS,   lpDevStatus->dwOpenMediaModes, aMediaModes },
                    { "dwNumActiveCalls",       FT_DWORD,   lpDevStatus->dwNumActiveCalls, NULL },
                    { "dwNumOnHoldCalls",       FT_DWORD,   lpDevStatus->dwNumOnHoldCalls, NULL },
                    { "dwNumOnHoldPendCalls",   FT_DWORD,   lpDevStatus->dwNumOnHoldPendCalls, NULL },
                    { "dwLineFeatures",         FT_FLAGS,   lpDevStatus->dwLineFeatures, aLineFeatures },
                    { "dwNumCallCompletions",   FT_DWORD,   lpDevStatus->dwNumCallCompletions, NULL },
                    { "dwRingMode",             FT_DWORD,   lpDevStatus->dwRingMode, NULL },
                    { "dwSignalLevel",          FT_DWORD,   lpDevStatus->dwSignalLevel, NULL },
                    { "dwBatteryLevel",         FT_DWORD,   lpDevStatus->dwBatteryLevel, NULL },
                    { "dwRoamMode",             FT_FLAGS,   lpDevStatus->dwRoamMode, aLineRoamModes },
                    { "dwDevStatusFlags",       FT_FLAGS,   lpDevStatus->dwDevStatusFlags, aLineDevStatusFlags },
                    { "dwTerminalModesSize",    FT_SIZE,    lpDevStatus->dwTerminalModesSize, NULL },
                    { "dwTerminalModesOffset",  FT_OFFSET,  lpDevStatus->dwTerminalModesOffset, NULL },
                    { "dwDevSpecificSize",      FT_SIZE,    lpDevStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpDevStatus->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwAvailableMediaModes",  FT_FLAGS,   0, aMediaModes },
                    { "dwAppInfoSize",          FT_DWORD,   0, NULL },
                    { "dwAppInfoOffset",        FT_DWORD,   0, NULL }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpDevStatus, "LINEDEVSTATUS", 0, fields
                };

                if (dwAPIVersion < 0x00020000)
                {
                    fieldHeader.dwNumFields = 16;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 19;

                    fields[16].dwValue = lpDevStatus->dwAvailableMediaModes;
                    fields[17].dwValue = lpDevStatus->dwAppInfoSize;
                    fields[18].dwValue = lpDevStatus->dwAppInfoOffset;
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);

#if TAPI_2_0
                if (dwAPIVersion >= 0x00020000 && lpDevStatus->dwAppInfoSize)
                {
                    char            szAppInfoN[16];
                    DWORD           i;
                    LPLINEAPPINFO   pAppInfo;
                    STRUCT_FIELD    fields[] =
                    {
                        { "dwMachineNameSize",      FT_SIZE,    0, NULL },
                        { "dwMachineNameOffset",    FT_OFFSET,  0, NULL },
                        { "dwUserNameSize",         FT_SIZE,    0, NULL },
                        { "dwUserNameOffset",       FT_OFFSET,  0, NULL },
                        { "dwModuleFilenameSize",   FT_SIZE,    0, NULL },
                        { "dwModuleFilenameOffset", FT_OFFSET,  0, NULL },
                        { "dwFriendlyNameSize",     FT_SIZE,    0, NULL },
                        { "dwFriendlyNameOffset",   FT_OFFSET,  0, NULL },
                        { "dwMediaModes",           FT_FLAGS,   0, aMediaModes },
                        { "dwAddressID",            FT_DWORD,   0, NULL },
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpDevStatus, szAppInfoN, 10, fields
                    };


                    pAppInfo = (LPLINEAPPINFO) (((LPBYTE) lpDevStatus) +
                        lpDevStatus->dwAppInfoOffset);

                    for (i = 0; i < lpDevStatus->dwNumOpens; i++)
                    {
                        wsprintf (szAppInfoN, "APPINFO[%d]", i);

                        fields[0].dwValue = pAppInfo->dwMachineNameSize;
                        fields[1].dwValue = pAppInfo->dwMachineNameOffset;
                        fields[2].dwValue = pAppInfo->dwUserNameSize;
                        fields[3].dwValue = pAppInfo->dwUserNameOffset;
                        fields[4].dwValue = pAppInfo->dwModuleFilenameSize;
                        fields[5].dwValue = pAppInfo->dwModuleFilenameOffset;
                        fields[6].dwValue = pAppInfo->dwFriendlyNameSize;
                        fields[7].dwValue = pAppInfo->dwFriendlyNameOffset;
                        fields[8].dwValue = pAppInfo->dwMediaModes;;
                        fields[9].dwValue = pAppInfo->dwAddressID;

                        ShowStructByField (&fieldHeader, TRUE);

                        pAppInfo++;
                    }
                }
#endif
            }
        }

        break;
    }
#if TAPI_2_0
    case lGetMessage:
    {
        LINEMESSAGE msg;
        FUNC_PARAM params[] =
        {
            { szhLineApp,   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpMessage",  PT_POINTER, (ULONG_PTR) &msg, &msg },
            { "dwTimeout",  PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

//        // Max timeout of 10 seconds (don't want to hang app & excite user)
//        // unless the user wants INFINITE
//
//        if ( 0xffffffff != params[2].dwValue )
//        {
//            if ( params[2].dwValue > 10000 )
//            {
//                params[2].dwValue = 10000;
//            }
//        }
        

        DumpParams (&paramsHeader);

        lResult = lineGetMessage(
            (HLINEAPP)      params[0].dwValue,
            (LPLINEMESSAGE) params[1].dwValue,
            (DWORD)         params[2].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            tapiCallback(
                msg.hDevice,
                msg.dwMessageID,
                msg.dwCallbackInstance,
                msg.dwParam1,
                msg.dwParam2,
                msg.dwParam3
                );
        }

        break;
    }
#endif
    case lGetNewCalls:
    {
        LPLINECALLLIST lpCallList = (LPLINECALLLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "dwSelect",       PT_ORDINAL, (ULONG_PTR) LINECALLSELECT_LINE, aCallSelects },
            { "lpCallList",     PT_POINTER, (ULONG_PTR) lpCallList, lpCallList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineGetNewCalls };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpCallList, 0, (size_t) dwBigBufSize);
        lpCallList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwCallsNumEntries",  FT_DWORD,   lpCallList->dwCallsNumEntries, NULL },
                    { "dwCallsSize",        FT_SIZE,    lpCallList->dwCallsSize, NULL },
                    { "dwCallsOffset",      FT_OFFSET,  lpCallList->dwCallsOffset, NULL }

                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallList,
                    "LINECALLLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }


            //
            // If there are any hCalls returned in this struct we want
            // to add them to the widget list
            //

            if (lpCallList->dwCallsNumEntries)
            {
                PMYLINE pLine = GetLine ((HLINE) params[0].dwValue);
                LPHCALL lphCall = (LPHCALL)
                    (((LPBYTE) lpCallList) + lpCallList->dwCallsOffset);


                for (i = 0; i < (int) lpCallList->dwCallsNumEntries; i++)
                {
                    PMYCALL pNewCall = AllocCall (pLine);
                    LINECALLSTATUS callStatus;


                    if (pNewCall)
                    {
                        pNewCall->hCall    = *lphCall;
                        pNewCall->bMonitor = TRUE;
                        lphCall++;

                        memset (&callStatus, 0, sizeof(LINECALLSTATUS));
                        callStatus.dwTotalSize = sizeof(LINECALLSTATUS);

                        if (lineGetCallStatus (pNewCall->hCall, &callStatus)
                                == 0)
                        {
                            //
                            // Special case chk for bNukeIdleMonitorCalls
                            //

                            if ((callStatus.dwCallState
                                    == LINECALLSTATE_IDLE) &&
                                bNukeIdleMonitorCalls &&
                                (callStatus.dwCallPrivilege
                                    == LINECALLPRIVILEGE_MONITOR))
                            {
                                if ((lResult = lineDeallocateCall(
                                        (HCALL) pNewCall->hCall)) == 0)
                                {
                                    ShowStr(
                                        "Monitored call x%lx deallocated " \
                                            "on IDLE",
                                        pNewCall->hCall
                                        );

                                    FreeCall (pNewCall);
                                }
                                else
                                {
                                    ShowStr(
                                        "lineDeallocateCall failed (x%lx) to" \
                                            " free idle monitored call x%lx",
                                        lResult,
                                        pNewCall->hCall
                                        );

                                    pNewCall->dwCallState = callStatus.dwCallState;
                                }
                            }
                            else
                            {
                                pNewCall->dwCallState = callStatus.dwCallState;
                            }
                        }
                        else
                        {
                            pNewCall->dwCallState = LINECALLSTATE_UNKNOWN;
                        }
                    }
                }

                UpdateWidgetList();
            }
        }

        break;
    }
    case lGetNumRings:
    {
        DWORD dwNumRings;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpdwNumRings",   PT_POINTER, (ULONG_PTR) &dwNumRings, &dwNumRings }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetNumRings };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%snum rings = x%lx", szTab, dwNumRings);
        }

        break;
    }
    case lGetRequest:
#if TAPI_2_0
    case lGetRequestW:
#endif
    {
#if TAPI_2_0
        LINEREQMEDIACALLW   reqXxxCall;
#else
        LINEREQMEDIACALL    reqXxxCall;
#endif
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRequestMode",      PT_ORDINAL, (ULONG_PTR) LINEREQUESTMODE_MAKECALL, aRequestModes },
            { "lpRequestBuffer",    PT_POINTER, (ULONG_PTR) &reqXxxCall, &reqXxxCall }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetRequest ?
                (PFN3) lineGetRequest : (PFN3) lineGetRequestW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetRequest };
#endif

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (&reqXxxCall, 0, sizeof (reqXxxCall));

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            if (params[1].dwValue == LINEREQUESTMODE_MAKECALL)
            {
#if TAPI_2_0
                if (gbWideStringParams)
                {
                    LPLINEREQMAKECALLW  lpReqMakeCall = (LPLINEREQMAKECALLW)
                                            &reqXxxCall;


                    ShowStr ("%sszDestAddress=%ws", szTab, lpReqMakeCall->szDestAddress);
                    ShowStr ("%sszAppName=%ws",     szTab, lpReqMakeCall->szAppName);
                    ShowStr ("%sszCalledParty=%ws", szTab, lpReqMakeCall->szCalledParty);
                    ShowStr ("%sszComment=%ws",     szTab, lpReqMakeCall->szComment);
                }
                else
                {
                    LPLINEREQMAKECALL   lpReqMakeCall = (LPLINEREQMAKECALL)
                                            &reqXxxCall;

                    ShowStr ("%sszDestAddress=%s", szTab, lpReqMakeCall->szDestAddress);
                    ShowStr ("%sszAppName=%s",     szTab, lpReqMakeCall->szAppName);
                    ShowStr ("%sszCalledParty=%s", szTab, lpReqMakeCall->szCalledParty);
                    ShowStr ("%sszComment=%s",     szTab, lpReqMakeCall->szComment);
                }
#else
                LPLINEREQMAKECALL   lpReqMakeCall = (LPLINEREQMAKECALL)
                                        &reqXxxCall;


                ShowStr ("%sszDestAddress=%s", szTab, lpReqMakeCall->szDestAddress);
                ShowStr ("%sszAppName=%s",     szTab, lpReqMakeCall->szAppName);
                ShowStr ("%sszCalledParty=%s", szTab, lpReqMakeCall->szCalledParty);
                ShowStr ("%sszComment=%s",     szTab, lpReqMakeCall->szComment);
#endif
            }
            else
            {
                //
                // NOTE: lineGetRequest(MEDIACALL) is a NOOP for win32,
                //       so we don't have to sweat differing sizes for
                //       HWND & WPARAM in the struct
                //

                LPLINEREQMEDIACALL  lpReqMediaCall = (LPLINEREQMEDIACALL)
                                        &reqXxxCall;


                ShowStr ("%shWnd=x%x",         szTab, lpReqMediaCall->hWnd);
                ShowStr ("%swRequestID=x%x",   szTab, lpReqMediaCall->wRequestID);
                ShowStr ("%sszDeviceClass=%s", szTab, lpReqMediaCall->szDeviceClass);
                ShowStr ("%sdwSize=x%lx",      szTab, lpReqMediaCall->dwSize);
                ShowStr ("%sdwSecure=x%lx",    szTab, lpReqMediaCall->dwSecure);
                ShowStr ("%sszDestAddress=%s", szTab, lpReqMediaCall->szDestAddress);
                ShowStr ("%sszAppName=%s",     szTab, lpReqMediaCall->szAppName);
                ShowStr ("%sszCalledParty=%s", szTab, lpReqMediaCall->szCalledParty);
                ShowStr ("%sszComment=%s",     szTab, lpReqMediaCall->szComment);
            }
        }

        break;
    }
    case lGetStatusMessages:
    {
        DWORD aFlags[2];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwLineStates",     PT_POINTER, (ULONG_PTR) &aFlags[0], &aFlags[0] },
            { "lpdwAddressStates",  PT_POINTER, (ULONG_PTR) &aFlags[1], &aFlags[1] }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetStatusMessages };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            STRUCT_FIELD fields[] =
            {
                { "dwLineStates",       FT_FLAGS,   aFlags[0], aLineStates },
                { "dwAddressStates",    FT_FLAGS,   aFlags[1], aAddressStates }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                aFlags,
                "",
                2,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);
        }

        break;
    }
    case lGetTranslateCaps:
#if TAPI_2_0
    case lGetTranslateCapsW:
#endif
    {
        LPLINETRANSLATECAPS lpTranslateCaps = (LPLINETRANSLATECAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpTranslateCaps",    PT_POINTER, (ULONG_PTR) lpTranslateCaps, lpTranslateCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetTranslateCaps ?
                (PFN3) lineGetTranslateCaps : (PFN3) lineGetTranslateCapsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetTranslateCaps };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        memset (lpTranslateCaps, 0, (size_t) dwBigBufSize);
        lpTranslateCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpTranslateCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                DWORD i;
                LPLINECARDENTRY lpCardEntry;
                LPLINELOCATIONENTRY lpLocationEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumLocations",           FT_DWORD,   lpTranslateCaps->dwNumLocations, NULL },
                    { "dwLocationListSize",       FT_DWORD,   lpTranslateCaps->dwLocationListSize, NULL },
                    { "dwLocationListOffset",     FT_DWORD,   lpTranslateCaps->dwLocationListOffset, NULL },
                    { "dwCurrentLocationID",      FT_DWORD,   lpTranslateCaps->dwCurrentLocationID, NULL },
                    { "dwNumCards",               FT_DWORD,   lpTranslateCaps->dwNumCards, NULL },
                    { "dwCardListSize",           FT_DWORD,   lpTranslateCaps->dwCardListSize, NULL },
                    { "dwCardListOffset",         FT_DWORD,   lpTranslateCaps->dwCardListOffset, NULL },
                    { "dwCurrentPreferredCardID", FT_DWORD,   lpTranslateCaps->dwCurrentPreferredCardID, NULL }
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpTranslateCaps,
                    "LINETRANSLATECAPS",
                    8,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpLocationEntry = (LPLINELOCATIONENTRY)
                    (((LPBYTE) lpTranslateCaps) +
                        lpTranslateCaps->dwLocationListOffset);

                for (i = 0; i < lpTranslateCaps->dwNumLocations; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentLocationID",          FT_DWORD,  lpLocationEntry->dwPermanentLocationID, NULL },
                        { "dwLocationNameSize",             FT_SIZE,   lpLocationEntry->dwLocationNameSize, NULL },
                        { "dwLocationNameOffset",           FT_OFFSET, lpLocationEntry->dwLocationNameOffset, NULL },
                        { "dwCountryCode",                  FT_DWORD,  lpLocationEntry->dwCountryCode, NULL },
                        { "dwCityCodeSize",                 FT_SIZE,   lpLocationEntry->dwCityCodeSize, NULL },
                        { "dwCityCodeOffset",               FT_OFFSET, lpLocationEntry->dwCityCodeOffset, NULL },
                        { "dwPreferredCardID",              FT_DWORD,  lpLocationEntry->dwPreferredCardID, NULL }
#if TAPI_1_1
                         ,
                        { "dwLocalAccessCodeSize",          FT_SIZE,    lpLocationEntry->dwLocalAccessCodeSize, NULL },
                        { "dwLocalAccessCodeOffset",        FT_OFFSET,  lpLocationEntry->dwLocalAccessCodeOffset, NULL },
                        { "dwLongDistanceAccessCodeSize",   FT_SIZE,    lpLocationEntry->dwLongDistanceAccessCodeSize, NULL },
                        { "dwLongDistanceAccessCodeOffset", FT_OFFSET,  lpLocationEntry->dwLongDistanceAccessCodeOffset, NULL },
                        { "dwTollPrefixListSize",           FT_SIZE,    lpLocationEntry->dwTollPrefixListSize, NULL },
                        { "dwTollPrefixListOffset",         FT_OFFSET,  lpLocationEntry->dwTollPrefixListOffset, NULL },
                        { "dwCountryID",                    FT_DWORD,   lpLocationEntry->dwCountryID, NULL },
                        { "dwOptions",                      FT_FLAGS,   lpLocationEntry->dwOptions, aLocationOptions },
                        { "dwCancelCallWaitingSize",        FT_SIZE,    lpLocationEntry->dwCancelCallWaitingSize, NULL },
                        { "dwCancelCallWaitingOffset",      FT_OFFSET,  lpLocationEntry->dwCancelCallWaitingOffset, NULL }
#endif
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpTranslateCaps, // size,offset relative to lpXlatCaps
                        buf,
#if TAPI_1_1
                        17,
#else
                        7,
#endif
                        fields
                    };


                    sprintf (buf, "LINELOCATIONENTRY[%ld]", i);

                    lpLocationEntry++;
#if TAPI_1_1
                    if (params[1].dwValue == 0x10003)
                    {
                        //
                        // Only show ver 1.0 params & munge ptr to
                        // compensate for for smaller struct size
                        //

                        fieldHeader.dwNumFields = 7;
                        lpLocationEntry = (LPLINELOCATIONENTRY)
                            (((LPBYTE) lpLocationEntry) - 10*sizeof(DWORD));

                    }
#endif
                    ShowStructByField (&fieldHeader, TRUE);

                }

                lpCardEntry = (LPLINECARDENTRY)
                    (((LPBYTE) lpTranslateCaps) +
                        lpTranslateCaps->dwCardListOffset);

                for (i = 0; i < lpTranslateCaps->dwNumCards; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentCardID",          FT_DWORD,   lpCardEntry->dwPermanentCardID, NULL },
                        { "dwCardNameSize",             FT_SIZE,    lpCardEntry->dwCardNameSize, NULL },
                        { "dwCardNameOffset",           FT_OFFSET,  lpCardEntry->dwCardNameOffset, NULL }
#if TAPI_1_1
                         ,
                        { "dwCardNumberDigits",         FT_DWORD,   lpCardEntry->dwCardNumberDigits, NULL },
                        { "dwSameAreaRuleSize",         FT_SIZE,    lpCardEntry->dwSameAreaRuleSize, NULL },
                        { "dwSameAreaRuleOffset",       FT_OFFSET,  lpCardEntry->dwSameAreaRuleOffset, NULL },
                        { "dwLongDistanceRuleSize",     FT_SIZE,    lpCardEntry->dwLongDistanceRuleSize, NULL },
                        { "dwLongDistanceRuleOffset",   FT_OFFSET,  lpCardEntry->dwLongDistanceRuleOffset, NULL },
                        { "dwInternationalRuleSize",    FT_SIZE,    lpCardEntry->dwInternationalRuleSize, NULL },
                        { "dwInternationalRuleOffset",  FT_OFFSET,  lpCardEntry->dwInternationalRuleOffset, NULL },
                        { "dwOptions",                  FT_FLAGS,   lpCardEntry->dwOptions, aCardOptions }
#endif
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpTranslateCaps, // size,offset relative to lpXlatCaps
                        buf,
#if TAPI_1_1
                        11,
#else
                        3,
#endif
                        fields
                    };


                    sprintf (buf, "LINECARDENTRY[%ld]", i);

                    lpCardEntry++;
#if TAPI_1_1
                    if (params[1].dwValue == 0x10003)
                    {
                        //
                        // Only show ver 1.0 params & munge ptr to
                        // compensate for for smaller struct size
                        //

                        fieldHeader.dwNumFields = 3;
                        lpCardEntry = (LPLINECARDENTRY)
                            (((LPBYTE) lpCardEntry) - 8*sizeof(DWORD));

                    }
#endif
                    ShowStructByField (&fieldHeader, TRUE);
                }
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case lHandoff:
#if TAPI_2_0
    case lHandoffW:
#endif
    {
        char szFilename[MAX_STRING_PARAM_SIZE] = "tb20.exe";
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpszFileName",   PT_STRING,  (ULONG_PTR) szFilename, szFilename },
            { "dwMediaMode",    PT_FLAGS,   (ULONG_PTR) dwDefMediaMode, aMediaModes }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lHandoff ?
                (PFN3) lineHandoff : (PFN3) lineHandoffW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineHandoff };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lHold:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineHold };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lInitialize:
    {
        PMYLINEAPP pNewLineApp;
        char szAppName[MAX_STRING_PARAM_SIZE];
        DWORD dwNumLineDevs;
        FUNC_PARAM params[] =
        {
            { "lphLineApp",     PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszAppName,    PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumLineDevs, &dwNumLineDevs }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineInitialize };


        if (!(pNewLineApp = AllocLineApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewLineApp->hLineApp;

        strcpy (szAppName, szDefAppName);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HINSTANCEs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreeLineApp (pNewLineApp);

            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineInitialize(
            (LPHLINEAPP)   params[0].dwValue,
            (HINSTANCE)    params[1].dwValue,
            (LINECALLBACK) params[2].dwValue,
            (LPCSTR)       params[3].dwValue,
            (LPDWORD)      params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        if (lResult == 0)
        {
            ShowStr ("%snum line devs = %ld", szTab, dwNumLineDevs);
            //SendMessage (ghwndLineApps, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            gdwNumLineDevs = dwNumLineDevs;
            SelectWidget ((PMYWIDGET) pNewLineApp);
        }
        else
        {
            FreeLineApp (pNewLineApp);
        }

        break;
    }
#if TAPI_2_0
    case lInitializeEx:
    case lInitializeExW:
    {
        char                    szAppName[MAX_STRING_PARAM_SIZE];
        DWORD                   dwNumLineDevs, dwAPIVersion;
        PMYLINEAPP              pNewLineApp;
        LINEINITIALIZEEXPARAMS  initExParams;
        FUNC_PARAM params[] =
        {
            { "lphLineApp",     PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszFriendlyAppName, PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumLineDevs, &dwNumLineDevs },
            { "lpdwAPIVersion", PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "  ->dwAPIVersion",PT_ORDINAL,(ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpInitExParams", PT_POINTER, (ULONG_PTR) &initExParams, &initExParams },
            { "  ->dwOptions",  PT_FLAGS,   (ULONG_PTR) LINEINITIALIZEEXOPTION_USECOMPLETIONPORT, aLineInitExOptions }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, NULL };


        if (!(pNewLineApp = AllocLineApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewLineApp->hLineApp;

        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreeLineApp (pNewLineApp);

            break;
        }

        initExParams.dwTotalSize = sizeof (LINEINITIALIZEEXPARAMS);
        initExParams.dwOptions = (DWORD) params[8].dwValue;
        initExParams.Handles.hCompletionPort = ghCompletionPort;

        dwAPIVersion = (DWORD) params[6].dwValue;

        DumpParams (&paramsHeader);

        if (funcIndex == lInitializeEx)
        {
            lResult = lineInitializeEx(
                (LPHLINEAPP)                params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (LINECALLBACK)              params[2].dwValue,
                (LPCSTR)                    params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPLINEINITIALIZEEXPARAMS)  params[7].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[3].dwValue);

            lResult = lineInitializeExW(
                (LPHLINEAPP)                params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (LINECALLBACK)              params[2].dwValue,
                (LPCWSTR)                   params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPLINEINITIALIZEEXPARAMS)  params[7].dwValue
                );
        }

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%snum line devs = %ld", szTab, dwNumLineDevs);

            if (params[7].dwValue != 0  &&
                (initExParams.dwOptions & 3) ==
                    LINEINITIALIZEEXOPTION_USEEVENT)
            {
                ShowStr(
                    "hLineApp x%x was created with the\r\n" \
                        "USEEVENT option, so you must use\r\n" \
                        "lineGetMessage to retrieve messages.",
                    pNewLineApp->hLineApp
                    );
            }

            //SendMessage (ghwndLineApps, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            gdwNumLineDevs = dwNumLineDevs;
            SelectWidget ((PMYWIDGET) pNewLineApp);
        }
        else
        {
            FreeLineApp (pNewLineApp);
        }

        break;
    }
#endif
    case lMakeCall:
#if TAPI_2_0
    case lMakeCallW:
#endif
    {
        PMYCALL pNewCall;
        char szAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,       (ULONG_PTR) 0, NULL },
            { szlphCall,            PT_POINTER,     (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING,      (ULONG_PTR) szAddress, szAddress },
            { "dwCountryCode",      PT_DWORD,       (ULONG_PTR) dwDefCountryCode, NULL },
            { szlpCallParams,       PT_CALLPARAMS,  (ULONG_PTR) 0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lMakeCall ?
                (PFN5) lineMakeCall : (PFN5) lineMakeCallW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineMakeCall };
#endif

        CHK_LINE_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        strcpy (szAddress, szDefDestAddress);

        if ((lResult = DoFunc (&paramsHeader)) > 0)
        {
            if (params[0].dwValue != (DWORD) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lMonitorDigits:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwDigitModes",   PT_FLAGS, LINEDIGITMODE_DTMF, aDigitModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineMonitorDigits };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lMonitorMedia:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwMediaModes",   PT_FLAGS, dwDefMediaMode, aMediaModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineMonitorMedia };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lMonitorTones:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpToneList",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "dwNumEntries",   PT_DWORD,   (ULONG_PTR) 1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineMonitorTones };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lNegotiateAPIVersion:
    {
        DWORD dwAPIVersion;
        LINEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { "dwAPILowVersion",    PT_DWORD,   (ULONG_PTR) 0x00010000, aAPIVersions },
            { "dwAPIHighVersion",   PT_DWORD,   (ULONG_PTR) 0x10000000, aAPIVersions },
            { "lpdwAPIVersion",     PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineNegotiateAPIVersion };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%s%s=x%lx", szTab, szdwAPIVersion, dwAPIVersion);
            ShowStr(
                "%sextID.ID0=x%lx, .ID1=x%lx, .ID2=x%lx, .ID3=x%lx, ",
                szTab,
                extID.dwExtensionID0,
                extID.dwExtensionID1,
                extID.dwExtensionID2,
                extID.dwExtensionID3
                );
        }

        break;
    }
    case lNegotiateExtVersion:
    {
        DWORD dwExtVersion;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "dwExtLowVersion",    PT_DWORD,   (ULONG_PTR) 0x00000000, NULL },
            { "dwExtHighVersion",   PT_DWORD,   (ULONG_PTR) 0x80000000, NULL },
            { "lpdwExtVersion",     PT_POINTER, (ULONG_PTR) &dwExtVersion, &dwExtVersion }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineNegotiateExtVersion };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwExtVersion=x%lx", szTab, dwExtVersion);
        }

        break;
    }
    default:

        FuncDriver2 (funcIndex);
        break;
    }

    gbWideStringParams = FALSE;
}

//#pragma code_seg ()

#pragma warning (default:4113)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\vars.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    vars.h

Abstract:

    Header file for the TAPI Browser util globals

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


#ifdef WIN32
#define my_far
#else
#define my_far _far
#endif

extern PMYWIDGET   aWidgets;

extern FILE        *hLogFile;
extern HANDLE      ghInst;
extern HWND        ghwndMain, ghwndEdit, ghwndList1, ghwndList2;
extern BOOL        bShowParams;
extern BOOL        gbDeallocateCall;
extern BOOL        gbDisableHandleChecking;
extern LPVOID      pBigBuf;
extern DWORD       dwBigBufSize;
extern DWORD       dwNumPendingMakeCalls;
extern DWORD       dwNumPendingDrops;
extern DWORD       gdwNumLineDevs;
extern DWORD       gdwNumPhoneDevs;
extern BOOL        bDumpParams;
extern BOOL        bTimeStamp;
extern DWORD       bNukeIdleMonitorCalls;
extern DWORD       bNukeIdleOwnedCalls;
extern DWORD       dwDumpStructsFlags;

extern LPLINECALLPARAMS    lpCallParams;

#if TAPI_2_0
extern BOOL                gbWideStringParams;
extern LPLINECALLPARAMS    lpCallParamsW;
#endif

extern DWORD       aUserButtonFuncs[MAX_USER_BUTTONS];
extern char        aUserButtonsText[MAX_USER_BUTTONS][MAX_USER_BUTTON_TEXT_SIZE];

extern PMYLINEAPP  pLineAppSel;
extern PMYLINE     pLineSel;
extern PMYCALL     pCallSel, pCallSel2;
extern PMYPHONEAPP pPhoneAppSel;
extern PMYPHONE    pPhoneSel;

extern char my_far szDefAppName[];
extern char my_far szDefUserUserInfo[];
extern char my_far szDefDestAddress[];
extern char my_far szDefLineDeviceClass[];
extern char my_far szDefPhoneDeviceClass[];

extern char far   *lpszDefAppName;
extern char far   *lpszDefUserUserInfo;
extern char far   *lpszDefDestAddress;
extern char far   *lpszDefLineDeviceClass;
extern char far   *lpszDefPhoneDeviceClass;

extern char my_far szTab[];
extern char my_far szCurrVer[];

// help extern char my_far szTapiHlp[];
// help extern char my_far szTspiHlp[];

extern DWORD       dwDefAddressID;
extern DWORD       dwDefLineAPIVersion;
extern DWORD       dwDefBearerMode;
extern DWORD       dwDefCountryCode;
extern DWORD       dwDefLineDeviceID;
extern DWORD       dwDefLineExtVersion;
extern DWORD       dwDefMediaMode;
extern DWORD       dwDefLinePrivilege;
extern DWORD       dwDefPhoneAPIVersion;
extern DWORD       dwDefPhoneDeviceID;
extern DWORD       dwDefPhoneExtVersion;
extern DWORD       dwDefPhonePrivilege;

#if TAPI_2_0
extern HANDLE      ghCompletionPort;
#endif

extern char aAscii[];

extern LOOKUP my_far aButtonFunctions[];
extern LOOKUP my_far aButtonModes[];
extern LOOKUP my_far aButtonStates[];
extern LOOKUP my_far aHookSwitchDevs[];
extern LOOKUP my_far aHookSwitchModes[];
extern LOOKUP my_far aLampModes[];
extern LOOKUP my_far aPhonePrivileges[];
extern LOOKUP my_far aPhoneStatusFlags[];
extern LOOKUP my_far aPhoneStates[];

extern LOOKUP my_far aStringFormats[];
extern LOOKUP my_far aAddressCapFlags[];
extern LOOKUP my_far aAddressFeatures[];
extern LOOKUP my_far aAgentStates[];
extern LOOKUP my_far aAgentStatus[];
extern LOOKUP my_far aAddressModes[];
extern LOOKUP my_far aAddressSharing[];
extern LOOKUP my_far aAddressStates[];
extern LOOKUP my_far aAnswerModes[];
extern LOOKUP my_far aAPIVersions[];
extern LOOKUP my_far aBearerModes[];
extern LOOKUP my_far aBusyModes[];
extern LOOKUP my_far aCallComplConds[];
extern LOOKUP my_far aCallComplModes[];
extern LOOKUP my_far aCallerIDFlags[];
extern LOOKUP my_far aCallFeatures[];
extern LOOKUP my_far aCallFeatures2[];
extern LOOKUP my_far aCallInfoStates[];
extern LOOKUP my_far aCallOrigins[];
extern LOOKUP my_far aCallParamFlags[];
extern LOOKUP my_far aCallPrivileges[];
extern LOOKUP my_far aCallReasons[];
extern LOOKUP my_far aCallSelects[];
extern LOOKUP my_far aCallStates[];
extern LOOKUP my_far aCallTreatments[];
extern LOOKUP my_far aCardOptions[];
extern LOOKUP my_far aConnectedModes[];
extern LOOKUP my_far aDevCapsFlags[];
extern LOOKUP my_far aDialToneModes[];
extern LOOKUP my_far aDigitModes[];
extern LOOKUP my_far aDisconnectModes[];
extern LOOKUP my_far aForwardModes[];
extern LOOKUP my_far aGatherTerms[];
extern LOOKUP my_far aGenerateTerms[];
extern LOOKUP my_far aLineInitExOptions[];
extern LOOKUP my_far aPhoneInitExOptions[];
extern LOOKUP my_far aLineDevStatusFlags[];
extern LOOKUP my_far aLineFeatures[];
extern LOOKUP my_far aLineOpenOptions[];
extern LOOKUP my_far aLineRoamModes[];
extern LOOKUP my_far aLineStates[];
extern LOOKUP my_far aLocationOptions[];
extern LOOKUP my_far aMediaControls[];
extern LOOKUP my_far aMediaModes[];
extern LOOKUP my_far aOfferingModes[];
extern LOOKUP my_far aParkModes[];
extern LOOKUP my_far aProxyRequests[];
extern LOOKUP my_far aRemoveFromConfCaps[];
extern LOOKUP my_far aRequestModes[];
extern LOOKUP my_far aRequestModes2[];
extern LOOKUP my_far aSpecialInfo[];
extern LOOKUP my_far aTerminalModes[];
extern LOOKUP my_far aTollListOptions[];
extern LOOKUP my_far aToneModes[];
extern LOOKUP my_far aTransferModes[];
extern LOOKUP my_far aTranslateOptions[];
extern LOOKUP my_far aTranslateResults[];

#if INTERNAL_3_0
extern LOOKUP my_far aServerConfigFlags[];
extern LOOKUP my_far aAvailableProviderOptions[];
#endif

#if TAPI_2_0
extern LOOKUP my_far aPhoneFeatures[];
#endif

extern char *aszLineErrs[];

extern char *aszPhoneErrs[];
extern char *aszTapiErrs[];

extern char *aFuncNames[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\tb2.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    tb2.c

Abstract:

    API wrapper code for the TAPI Browser util.  Contains the big switch
    statement for all the supported Telephony API's, & various support funcs.

Author:

    Dan Knudson (DanKn)    18-Aug-1995

Revision History:

--*/


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include "tb.h"
#include "vars.h"
#include "resource.h"


extern char szdwDeviceID[];
extern char szdwSize[];
extern char szhCall[];
extern char szhLine[];
extern char szhLineApp[];
extern char szhPhone[];
extern char szlpCallParams[];

extern char szlphCall[];
extern char szlpParams[];
extern char szhwndOwner[];
extern char szdwAddressID[];
extern char szlpszAppName[];
extern char szdwAPIVersion[];
extern char szlphConsultCall[];
extern char szlpszDeviceClass[];
extern char szlpszDestAddress[];
extern char szlpsUserUserInfo[];
extern char szlpszFriendlyAppName[];

char szhMmcApp[]   = "hMmcApp";
char szhPhoneApp[] = "hPhoneApp";
char szdwProviderID[] = "dwProviderID";


void
ShowStructByDWORDs(
    LPVOID  lp
    );

void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    );

void
DumpParams(
    PFUNC_PARAM_HEADER pHeader
    );

void
ShowPhoneFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

void
ShowVARSTRING(
    LPVARSTRING lpVarString
    );

void
ShowTapiFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

VOID
UpdateWidgetListCall(
    PMYCALL pCall
    );

LPWSTR
PASCAL
My_lstrcpyW(
    WCHAR   *pString1,
    WCHAR   *pString2
    );

void
PASCAL
MakeWideString(
    LPVOID pString
    );

#if (INTERNAL_VER >= 0x20000)
DWORD
APIENTRY
internalNewLocationW(
    IN WCHAR* pszName
    );
#endif


void
ShowWidgetList(
    BOOL bShow
    )
{
    static RECT    rect;
    static int     iNumHides = 0;


    if (!bShow)
    {
        iNumHides++;

        if (iNumHides > 1)
        {
            return;
        }

        GetWindowRect (ghwndList1, &rect);

        SetWindowPos(
            ghwndList1,
            (HWND) NULL,
            0,
            0,
            1,
            1,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW |
                SWP_NOZORDER | SWP_HIDEWINDOW
            );
    }
    else
    {
        iNumHides--;

        if (iNumHides > 0)
        {
            return;
        }

        //
        // Do control restoration
        //

        ShowWindow (ghwndList1, SW_SHOW);

        SetWindowPos(
            ghwndList1,
            (HWND) NULL,
            0,
            0,
            rect.right - rect.left,
            rect.bottom - rect.top,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
            );
    }
}


//
// We get a slough of C4113 (func param lists differed) warnings down below
// in the initialization of FUNC_PARAM_HEADER structs as a result of the
// real func prototypes having params that are pointers rather than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4113)

void
FuncDriver2(
    FUNC_INDEX funcIndex
    )
{
    LONG    lResult;
    DWORD   i;


    switch (funcIndex)
    {
    case lOpen:
#if TAPI_2_0
    case lOpenW:
#endif
    {
        PMYLINE pNewLine;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,       0, NULL },
            { szdwDeviceID,         PT_DWORD,       dwDefLineDeviceID, NULL },
            { "lphLine",            PT_POINTER,     0, NULL },
            { szdwAPIVersion,       PT_ORDINAL,     dwDefLineAPIVersion, aAPIVersions },
            { "dwExtVersion",       PT_DWORD,       dwDefLineExtVersion, NULL },
            { "dwCallbackInstance", PT_DWORD,       0, NULL },
            { "dwPrivileges",       PT_FLAGS,       dwDefLinePrivilege, aLineOpenOptions },
            { "dwMediaModes",       PT_FLAGS,       dwDefMediaMode, aMediaModes },
            { szlpCallParams,       PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, (funcIndex == lOpen ?
                (PFN9) lineOpen : (PFN9) lineOpenW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, (PFN9) lineOpen };
#endif

        CHK_LINEAPP_SELECTED()

        if (!(pNewLine = AllocLine (pLineAppSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewLine->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            if ((HLINEAPP) params[0].dwValue != pLineAppSel->hLineApp)
            {
                //
                // User has switched line apps on us we need to recreate
                // the line data structure under a different line app
                //

                PMYLINE pNewLine2 =
                    AllocLine (GetLineApp((HLINEAPP)params[0].dwValue));

                if (pNewLine2)
                {
                    pNewLine2->hLine = pNewLine->hLine;

                    FreeLine (pNewLine);

                    pNewLine = pNewLine2;
                }
                else
                {
                    // BUGBUG show error: couldn't alloc a new line struct

                    lineClose (pNewLine->hLine);
                    FreeLine  (pNewLine);
                    break;
                }
            }


            //
            // Save info about this line that we can display
            //

            pNewLine->hLineApp     = (HLINEAPP) params[0].dwValue;
            pNewLine->dwDevID      = (DWORD) params[1].dwValue;
            pNewLine->dwAPIVersion = (DWORD) params[3].dwValue;
            pNewLine->dwPrivileges = (DWORD) params[6].dwValue;
            pNewLine->dwMediaModes = (DWORD) params[7].dwValue;

            //SendMessage (ghwndLines, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            SelectWidget ((PMYWIDGET) pNewLine);
        }
        else
        {
            FreeLine (pNewLine);
        }

        break;
    }
    case lPark:
#if TAPI_2_0
    case lParkW:
#endif
    {
        char szDirAddress[MAX_STRING_PARAM_SIZE] = "";
        LPVARSTRING lpNonDirAddress = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwParkMode",       PT_ORDINAL, (ULONG_PTR) LINEPARKMODE_DIRECTED, aParkModes },
            { "lpszDirAddress",   PT_STRING,  (ULONG_PTR) szDirAddress, szDirAddress },
            { "lpNonDirAddress",  PT_POINTER, (ULONG_PTR) lpNonDirAddress, lpNonDirAddress }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lPark ?
                (PFN4) linePark : (PFN4) lineParkW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) linePark };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpNonDirAddress, 0, (size_t) dwBigBufSize);
        lpNonDirAddress->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lPickup:
#if TAPI_2_0
    case lPickupW:
#endif
    {
        PMYCALL pNewCall;
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        char szGroupID[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szlphCall,            PT_POINTER, (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING,  (ULONG_PTR) szDestAddress, szDestAddress },
            { "lpszGroupID",        PT_STRING,  (ULONG_PTR) szGroupID, szGroupID }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lPickup ?
                (PFN5) linePickup : (PFN5) linePickupW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) linePickup };
#endif


        CHK_LINE_SELECTED()


        //
        // Find a free entry in the call array
        //

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            if (params[0].dwValue != (DWORD) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lPrepareAddToConference:
#if TAPI_2_0
    case lPrepareAddToConferenceW:
#endif
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { "hConfCall",          PT_DWORD,       0, NULL },
            { szlphConsultCall,     PT_POINTER,     0, NULL },
            { szlpCallParams,       PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lPrepareAddToConference ?
                (PFN3) linePrepareAddToConference : (PFN3) linePrepareAddToConferenceW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) linePrepareAddToConference };
#endif

        CHK_CALL_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // First make sure we're created the call under the right line,
            // and if not move it to the right place in the widgets list
            //

            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);

            if (lineGetCallInfo ((HCALL) params[0].dwValue, &callInfo) == 0)
            {
                if (callInfo.hLine != pLineSel->hLine)
                {
                    MoveCallToLine (pNewCall, callInfo.hLine);
                }
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
#if TAPI_2_0
    case lProxyMessage:
    {
        static LOOKUP aValidProxyMsgs[] =
        {
            { LINE_AGENTSPECIFIC    ,"AGENTSPECIFIC"    },
            { LINE_AGENTSTATUS      ,"AGENTSTATUS"      },
            { 0xffffffff            ,""                 }
        };

        FUNC_PARAM params[] =
        {
            { szhLine,      PT_DWORD,   0, NULL },
            { szhCall,      PT_DWORD,   0, NULL },
            { "dwMsg",      PT_ORDINAL, LINE_AGENTSTATUS, aValidProxyMsgs },
            { "dwParam1",   PT_DWORD,   0, NULL },
            { "dwParam2",   PT_FLAGS,   0, aAgentStatus },
            { "dwParam3",   PT_ORDINAL, 0, aAgentStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineProxyMessage };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[1].dwValue = (ULONG_PTR) pCallSel->hCall;
        }

        DoFunc (&paramsHeader);

        break;
    }
    case lProxyResponse:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   0, NULL },
            { "lpProxyBuffer",  PT_DWORD,   0, NULL },
            { "dwResult",       PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineProxyResponse };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lRedirect:
#if TAPI_2_0
    case lRedirectW:
#endif
    {
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { "dwCountryCode",      PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lRedirect ?
                (PFN3) lineRedirect : (PFN3) lineRedirectW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineRedirect };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lRegisterRequestRecipient:
    {
        FUNC_PARAM params[] =
        {
            { szhLineApp,               PT_DWORD,  0, NULL },
            { "dwRegistrationInstance", PT_DWORD,  0, NULL },
            { "dwRequestMode",          PT_FLAGS,  LINEREQUESTMODE_MAKECALL, aRequestModes2 },
            { "bEnable",                PT_DWORD,  1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineRegisterRequestRecipient };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lRemoveFromConference:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineRemoveFromConference };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSecureCall:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineSecureCall };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSendUserUserInfo:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING,  (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSendUserUserInfo };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lSetAgentActivity:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD, 0, NULL },
            { szdwAddressID,    PT_DWORD, 0, NULL },
            { "dwActivityID",   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetAgentActivity };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
    case lSetAgentGroup:
    {
        LPLINEAGENTGROUPLIST    lpGroupList = (LPLINEAGENTGROUPLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentGroupList",   PT_POINTER, (ULONG_PTR) lpGroupList, lpGroupList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetAgentGroup };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

// BUGBUG SetAgentGRp: allow user to fill in agent group list

        memset (lpGroupList, 0, (size_t) dwBigBufSize);
        lpGroupList->dwTotalSize = dwBigBufSize;

        DoFunc (&paramsHeader);

        break;
    }
    case lSetAgentState:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   0, NULL },
            { szdwAddressID,        PT_DWORD,   0, NULL },
            { "dwAgentState",       PT_FLAGS,   0, aAgentStates },
            { "dwNextAgentState",   PT_FLAGS,   0, aAgentStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineSetAgentState };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetAppSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwAppSpecific",  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetAppSpecific };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lSetCallData:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallData", PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetCallData };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetCallParams:
    {
        LINEDIALPARAMS dialParams;
        FUNC_PARAM params[] =
        {
            { szhCall,                  PT_DWORD,   0, NULL },
            { "dwBearerMode",           PT_FLAGS,   dwDefBearerMode, aBearerModes },
            { "dwMinRate",              PT_DWORD,   3100, NULL },
            { "dwMaxRate",              PT_DWORD,   3100, NULL },
            { "lpDialParams",           PT_POINTER, 0, &dialParams },
            { "  ->dwDialPause",        PT_DWORD,   0, NULL },
            { "  ->dwDialSpeed",        PT_DWORD,   0, NULL },
            { "  ->dwDigitDuration",    PT_DWORD,   0, NULL },
            { "  ->dwWaitForDialtone",  PT_DWORD,   0, NULL }

        };
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, NULL };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        dialParams.dwDialPause       = (DWORD) params[5].dwValue;
        dialParams.dwDialSpeed       = (DWORD) params[6].dwValue;
        dialParams.dwDigitDuration   = (DWORD) params[7].dwValue;
        dialParams.dwWaitForDialtone = (DWORD) params[8].dwValue;

        lResult = lineSetCallParams(
            (HCALL) params[0].dwValue,
            (DWORD) params[1].dwValue,
            (DWORD) params[2].dwValue,
            (DWORD) params[3].dwValue,
            (LPLINEDIALPARAMS) params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case lSetCallPrivilege:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,   0, NULL },
            { "dwCallPrivilege",    PT_ORDINAL, LINECALLPRIVILEGE_OWNER, aCallPrivileges }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetCallPrivilege };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            if (params[0].dwValue == (ULONG_PTR) pCallSel->hCall)
            {
                pCallSel->bMonitor =  (params[0].dwValue ==
                    LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                UpdateWidgetListCall (pCallSel);
            }
            else
            {
                PMYCALL pCall;


                if ((pCall = GetCall ((HCALL) params[0].dwValue)))
                {
                    pCall->bMonitor =  (params[0].dwValue ==
                        LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                    UpdateWidgetListCall (pCall);
                }
            }
        }

        break;
    }
#if TAPI_2_0
    case lSetCallQualityOfService:
    {
        char szSendingFlowspec[MAX_STRING_PARAM_SIZE] = "123";
        char szReceivingFlowspec[MAX_STRING_PARAM_SIZE] = "321";
        FUNC_PARAM params[] =
        {
            { szhCall,                  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpSendingFlowspec",      PT_STRING,  (ULONG_PTR) szSendingFlowspec, szSendingFlowspec },
            { "dwSendingFlowspecSize",  PT_DWORD,   (ULONG_PTR) 4, 0 },
            { "lpReceivingFlowspec",    PT_STRING,  (ULONG_PTR) szReceivingFlowspec, szReceivingFlowspec },
            { "dwReceivingFlowspecSize",PT_DWORD,   (ULONG_PTR) 4, 0 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineSetCallQualityOfService };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        DoFunc (&paramsHeader);

        break;
    }
    case lSetCallTreatment:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   0, NULL },
            { "dwTreatment",PT_ORDINAL, LINECALLTREATMENT_SILENCE, aCallTreatments }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetCallTreatment };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetCurrentLocation:
    {
        FUNC_PARAM params[] =
        {
            { szhLineApp,   PT_DWORD, 0, NULL },
            { "dwLocation", PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetCurrentLocation };


        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetDevConfig:
#if TAPI_2_0
    case lSetDevConfigW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        char szErrorMsg[] = "Bad config info in buffer";
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpDeviceConfig",     PT_POINTER, (ULONG_PTR) 0, NULL },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass },
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lSetDevConfig ?
                (PFN4) lineSetDevConfig : (PFN4) lineSetDevConfigW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineSetDevConfig };
#endif

        //
        // Check to see if there's existing config info in the global buffer
        // (not a foolproof check, but good enough)
        //

        ShowStr ("Call lineGetDevConfig before calling lineSetDevConfig");

        if (dwBigBufSize >= sizeof (VARSTRING))
        {
            DWORD       dwMaxDataSize = dwBigBufSize - sizeof (VARSTRING);
            LPVARSTRING pVarString = (LPVARSTRING) pBigBuf;


            if (pVarString->dwStringSize > dwMaxDataSize ||

                (pVarString->dwStringSize != 0 &&
                    (pVarString->dwStringOffset < sizeof (VARSTRING) ||
                    pVarString->dwStringOffset >
                        (dwBigBufSize - pVarString->dwStringSize))))
            {
                ShowStr (szErrorMsg);
                break;
            }

            params[1].dwValue      =
            params[1].u.dwDefValue = (ULONG_PTR)
                ((LPBYTE) pBigBuf + pVarString->dwStringOffset);
            params[2].dwValue      =
            params[2].u.dwDefValue = pVarString->dwStringSize;
        }
        else
        {
            ShowStr (szErrorMsg);
            break;
        }

        strcpy (szDeviceClass, szDefLineDeviceClass);

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lSetLineDevStatus:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   0, NULL },
            { "dwStatusToChange",   PT_FLAGS,   0, aLineDevStatusFlags },
            { "fStatus",            PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetLineDevStatus };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetMediaControl:
    {
        LINEMEDIACONTROLDIGIT       aDigits[1];
        LINEMEDIACONTROLMEDIA       aMedias[1];
        LINEMEDIACONTROLTONE        aTones[1];
        LINEMEDIACONTROLCALLSTATE   aCallSts[1];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwSelect",           PT_ORDINAL, (ULONG_PTR) 0, aCallSelects },

            { "lpDigitList",        PT_POINTER, (ULONG_PTR) aDigits, aDigits },
            { "  ->dwDigit",        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwDigitModes",   PT_FLAGS,   (ULONG_PTR) 0, aDigitModes },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwDigitNumEntries",  PT_DWORD,   (ULONG_PTR) 0, NULL },

            { "lpMediaList",        PT_POINTER, (ULONG_PTR) aMedias, aMedias },
            { "  ->dwMediaModes",   PT_FLAGS,   (ULONG_PTR) 0, aMediaModes },
            { "  ->dwDuration",     PT_DWORD,   (ULONG_PTR) 0, 0 },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwMediaNumEntries",  PT_DWORD,   (ULONG_PTR) 0, NULL },

            { "lpToneList",         PT_POINTER, (ULONG_PTR) aTones, aTones },
            { "  ->dwAppSpecific",  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwDuration",     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwFrequency1",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwFrequency2",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwFrequency3",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwToneNumEntries",   PT_DWORD,   (ULONG_PTR) 0, NULL },

            { "lpCallStateList",    PT_POINTER, (ULONG_PTR) aCallSts, aCallSts },
            { "  ->dwCallStates",   PT_FLAGS,   (ULONG_PTR) 0, aCallStates },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwCallStateNumEntries", PT_DWORD,(ULONG_PTR)  0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 26, funcIndex, params, (PFN12) lineSetMediaControl };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
            params[3].dwValue = LINECALLSELECT_CALL;
        }
        else
        {
            params[3].dwValue =  LINECALLSELECT_LINE;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            DumpParams (&paramsHeader);

            lResult = lineSetMediaControl(
                (HLINE)                       params[0].dwValue,
                (DWORD)                       params[1].dwValue,
                (HCALL)                       params[2].dwValue,
                (DWORD)                       params[3].dwValue,
                (LPLINEMEDIACONTROLDIGIT)     params[4].dwValue,
                (DWORD)                       params[8].dwValue,
                (LPLINEMEDIACONTROLMEDIA)     params[9].dwValue,
                (DWORD)                       params[13].dwValue,
                (LPLINEMEDIACONTROLTONE)      params[14].dwValue,
                (DWORD)                       params[21].dwValue,
                (LPLINEMEDIACONTROLCALLSTATE) params[22].dwValue,
                (DWORD)                       params[25].dwValue
                );

            ShowLineFuncResult (aFuncNames[funcIndex], lResult);
        }

        break;
    }
    case lSetMediaMode:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwMediaModes",   PT_FLAGS, dwDefMediaMode, aMediaModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetMediaMode };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetNumRings:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD, 0, NULL },
            { szdwAddressID,    PT_DWORD, dwDefAddressID, NULL },
            { "dwNumRings",     PT_DWORD, 5, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetNumRings };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetStatusMessages:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD, 0, NULL },
            { "dwLineStates",       PT_FLAGS, 0, aLineStates },
            { "dwAddressStates",    PT_FLAGS, 0, aAddressStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetStatusMessages };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetTerminal:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   0, NULL },
            { szdwAddressID,        PT_DWORD,   dwDefAddressID, NULL },
            { szhCall,              PT_DWORD,   0, NULL },
            { "dwSelect",           PT_ORDINAL, LINECALLSELECT_LINE, aCallSelects },
            { "dwTerminalModes",    PT_FLAGS,   LINETERMMODE_BUTTONS, aTerminalModes },
            { "dwTerminalID",       PT_DWORD,   0, NULL },
            { "bEnable",            PT_DWORD,   0, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineSetTerminal };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
        }

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetTollList:
#if TAPI_2_0
    case lSetTollListW:
#endif
    {
        char szAddressIn[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { "lpszAddressIn",      PT_STRING,  (ULONG_PTR) szAddressIn, szAddressIn },
            { "dwTollListOption",   PT_FLAGS,   (ULONG_PTR) LINETOLLLISTOPTION_ADD, aTollListOptions }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lSetTollList ?
                (PFN4) lineSetTollList : (PFN4) lineSetTollListW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineSetTollList };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        strcpy (szAddressIn, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetupConference:
#if TAPI_2_0
    case lSetupConferenceW:
#endif
    {
        PMYCALL pNewCall, pNewCall2;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,       0, NULL },
            { szhLine,          PT_DWORD,       0, NULL },
            { "lphConfCall",    PT_POINTER,     0, NULL },
            { szlphConsultCall, PT_POINTER,     0, NULL },
            { "dwNumParties",   PT_DWORD,       3, NULL },
            { szlpCallParams,   PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lSetupConference ?
                (PFN6) lineSetupConference : (PFN6) lineSetupConferenceW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineSetupConference };
#endif

        CHK_LINE_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        if (!(pNewCall2 = AllocCall (pLineSel)))
        {
            FreeCall (pNewCall);
            break;
        }

        params[0].dwValue = (ULONG_PTR) (pCallSel ? pCallSel->hCall : 0);
        params[1].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;
        params[3].dwValue =
        params[3].u.dwDefValue = (ULONG_PTR) &pNewCall2->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // Note that the hLine param is ignored if the hCall is non-NULL
            //

            if (params[0].dwValue)
            {
                if (!pCallSel ||
                    (params[0].dwValue != (ULONG_PTR) pCallSel->hCall))
                {
                    //
                    // Get the assoc pLine, if it's diff need to move new calls
                    //

                    PMYWIDGET pWidget = aWidgets;
                    PMYLINE   pLine = (PMYLINE) NULL;


                    while (1)
                    {
                        if ((pWidget->dwType == WT_CALL) &&
                            (params[0].dwValue == (ULONG_PTR)
                                ((PMYCALL)pWidget)->hCall))
                        {
                            break;
                        }
                        else if (pWidget->dwType == WT_LINE)
                        {
                            pLine = (PMYLINE) pWidget;
                        }

                        pWidget = pWidget->pNext;
                    }

                    if (pLine != pLineSel)
                    {
                        MoveCallToLine (pNewCall, pLine->hLine);
                        MoveCallToLine (pNewCall2, pLine->hLine);
                    }
                }
            }
            else if (params[1].dwValue != (ULONG_PTR) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[1].dwValue);
                MoveCallToLine (pNewCall2, (HLINE) params[1].dwValue);
            }

            pNewCall->lMakeCallReqID  =
            pNewCall2->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls += 2;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
            FreeCall (pNewCall2);
        }

        break;
    }
    case lSetupTransfer:
#if TAPI_2_0
    case lSetupTransferW:
#endif
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,       0, NULL },
            { szlphConsultCall, PT_POINTER,     0, NULL },
            { szlpCallParams,   PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lSetupTransfer ?
                (PFN3) lineSetupTransfer : (PFN3) lineSetupTransferW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetupTransfer };
#endif

        CHK_CALL_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // First make sure we're created the call under the right line,
            // and if not move it to the right place in the widgets list
            //

            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);

            if (lineGetCallInfo ((HCALL) params[0].dwValue, &callInfo) == 0)
            {
                if (callInfo.hLine != pLineSel->hLine)
                {
                    MoveCallToLine (pNewCall, callInfo.hLine);
                }
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lShutdown:
    {
        FUNC_PARAM params[] =
        {
            { szhLineApp,   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineShutdown };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        if (lResult == 0)
        {
            ShowWidgetList (FALSE);
            FreeLineApp (GetLineApp((HLINEAPP) params[0].dwValue));
            ShowWidgetList (TRUE);
        }

        break;
    }
    case lSwapHold:
    {
        FUNC_PARAM params[] =
        {
            { "hActiveCall",    PT_DWORD, 0, NULL },
            { "hHeldCall",      PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSwapHold };


        CHK_TWO_CALLS_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) pCallSel2->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lTranslateAddress:
#if TAPI_2_0
    case lTranslateAddressW:
#endif
    {
        char szAddressIn[MAX_STRING_PARAM_SIZE];
        LPLINETRANSLATEOUTPUT lpXlatOutput = (LPLINETRANSLATEOUTPUT) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpszAddressIn",      PT_STRING,  (ULONG_PTR) szAddressIn, szAddressIn },
            { "dwCard",             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwTranslateOptions", PT_FLAGS,   (ULONG_PTR) LINETRANSLATEOPTION_CARDOVERRIDE, aTranslateOptions },
            { "lpTranslateOutput",  PT_POINTER, (ULONG_PTR) lpXlatOutput, lpXlatOutput }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (funcIndex == lTranslateAddress ?
                (PFN7) lineTranslateAddress : (PFN7) lineTranslateAddressW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineTranslateAddress };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }
        else
        {
            params[0].dwValue = 0;
        }

        memset (lpXlatOutput, 0, (size_t) dwBigBufSize);
        lpXlatOutput->dwTotalSize = dwBigBufSize;

        strcpy (szAddressIn, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        if (lResult == 0)
        {
            ShowStructByDWORDs (lpXlatOutput);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwDialableStringSize",       FT_SIZE,    lpXlatOutput->dwDialableStringSize, NULL },
                    { "dwDialableStringOffset",     FT_OFFSET,  lpXlatOutput->dwDialableStringOffset, NULL },
                    { "dwDisplayableStringSize",    FT_SIZE,    lpXlatOutput->dwDisplayableStringSize, NULL },
                    { "dwDisplayableStringOffset",  FT_OFFSET,  lpXlatOutput->dwDisplayableStringOffset, NULL },
                    { "dwCurrentCountry",           FT_DWORD,   lpXlatOutput->dwCurrentCountry, NULL },
                    { "dwDestCountry",              FT_DWORD,   lpXlatOutput->dwDestCountry, NULL },
                    { "dwTranslateResults",         FT_FLAGS,   lpXlatOutput->dwTranslateResults, aTranslateResults },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpXlatOutput,
                    "LINETRANSLATEOUTPUT",
                    7,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lUncompleteCall:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD, 0, NULL },
            { "dwCompletionID", PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineUncompleteCall };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lUnhold:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineUnhold };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lUnpark:
#if TAPI_2_0
    case lUnparkW:
#endif
    {
        PMYCALL pNewCall;
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szlphCall,            PT_POINTER, (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING,  (ULONG_PTR) szDestAddress, szDestAddress }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lUnpark ?
                (PFN4) lineUnpark : (PFN4) lineUnparkW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineUnpark };
#endif

        CHK_LINE_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            if (params[0].dwValue != (ULONG_PTR) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
#if TAPI_1_1
    case lAddProvider:
#if TAPI_2_0
    case lAddProviderW:
#endif
    {
#if TAPI_2_0
        char szProviderFilename[MAX_STRING_PARAM_SIZE] = "esp32.tsp";
#else
        char szProviderFilename[MAX_STRING_PARAM_SIZE] = "esp.tsp";
#endif
        DWORD dwPermanentProviderID;
        FUNC_PARAM params[] =
        {
            { "lpszProviderFilename",       PT_STRING,  (ULONG_PTR) szProviderFilename, szProviderFilename },
            { szhwndOwner,                  PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { "lpdwPermanentProviderID",    PT_POINTER, (ULONG_PTR) &dwPermanentProviderID, &dwPermanentProviderID }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lAddProvider ?
                (PFN3) lineAddProvider : (PFN3) lineAddProviderW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineAddProvider };
#endif

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineAddProvider(
            (LPCSTR) params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPDWORD) params[2].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%sdwPermanentProviderID = x%lx", szTab, dwPermanentProviderID);
        }
#endif
        break;
    }
    case lConfigDialogEdit:
#if TAPI_2_0
    case lConfigDialogEditW:
#endif
    {
        char        szDeviceClass[MAX_STRING_PARAM_SIZE];
        char        szDeviceConfigIn[MAX_STRING_PARAM_SIZE] = "";
        char        szErrorMsg[] = "Bad config info in buffer";
        LPBYTE      pDataIn;
        LPVARSTRING lpDeviceConfigOut = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,           PT_DWORD,     (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szhwndOwner,            PT_DWORD,     (ULONG_PTR) ghwndMain, NULL },
            { szlpszDeviceClass,      PT_STRING,    (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lpDeviceConfigIn",     PT_POINTER,   (ULONG_PTR) 0, NULL },
            { szdwSize,               PT_DWORD,     (ULONG_PTR) 0, NULL },
            { "lpDeviceConfigOut",    PT_POINTER,   (ULONG_PTR) lpDeviceConfigOut, lpDeviceConfigOut }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lConfigDialogEdit ?
                (PFN6) lineConfigDialogEdit : (PFN6) lineConfigDialogEditW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineConfigDialogEdit };
#endif

        //
        // Check to see if there's existing config info in the global buffer
        // (not a foolproof check, but good enough), and if so alloc an
        // intermediate  buffer to use for config in data & copy the
        // existing data over
        //

        ShowStr ("Call lineGetDevConfig before calling lineConfigDialogEdit");

        if (dwBigBufSize >= sizeof (VARSTRING))
        {
            DWORD       dwMaxDataSize = dwBigBufSize - sizeof (VARSTRING);
            LPVARSTRING pVarString = (LPVARSTRING) pBigBuf;


            if (pVarString->dwStringSize > dwMaxDataSize ||

                (pVarString->dwStringSize != 0 &&
                    (pVarString->dwStringOffset < sizeof (VARSTRING) ||
                    pVarString->dwStringOffset >
                        (dwBigBufSize - pVarString->dwStringSize))))
            {
                ShowStr (szErrorMsg);
                break;
            }

            pDataIn = malloc (pVarString->dwStringSize);

            memcpy(
                pDataIn,
                (LPBYTE) pBigBuf + pVarString->dwStringOffset,
                pVarString->dwStringSize
                );

            params[3].dwValue      =
            params[3].u.dwDefValue = (ULONG_PTR) pDataIn;
        }
        else
        {
            ShowStr (szErrorMsg);
            break;
        }

        strcpy (szDeviceClass, szDefLineDeviceClass);

        memset (lpDeviceConfigOut, 0, (size_t) dwBigBufSize);

        lpDeviceConfigOut->dwTotalSize = dwBigBufSize;

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineConfigDialogEdit(
            params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPCSTR) params[2].dwValue,
            (LPVOID) params[3].dwValue,
            params[4].dwValue,
            (LPVARSTRING) params[5].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        if (lResult == 0)
        {
            ShowStructByDWORDs (lpDeviceConfigOut);

            ShowVARSTRING (lpDeviceConfigOut);
        }

        free (pDataIn);

        break;
    }
    case lConfigProvider:
    {
        FUNC_PARAM params[] =
        {
            { szhwndOwner,              PT_DWORD, (ULONG_PTR) ghwndMain, NULL },
            { "dwPermanentProviderID",  PT_DWORD, (ULONG_PTR) 2, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineConfigProvider };


#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineConfigProvider(
            (HWND) params[0].dwValue,
            params[1].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case lGetAppPriority:
#if TAPI_2_0
    case lGetAppPriorityW:
#endif
    {
        DWORD dwPriority;
        LINEEXTENSIONID extID;
        char szAppName[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpExtName = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szlpszAppName,        PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "dwMediaMode",        PT_FLAGS,   (ULONG_PTR) dwDefMediaMode, aMediaModes },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID },
            { "  ->dwExtensionID0", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID1", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID2", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID3", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRequestMode",      PT_FLAGS,   (ULONG_PTR) LINEREQUESTMODE_MAKECALL, aRequestModes },
            { "lpExtensionName",    PT_POINTER, (ULONG_PTR) lpExtName, lpExtName },
            { "lpdwPriority",       PT_POINTER, (ULONG_PTR) &dwPriority, &dwPriority }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, NULL };


        memset (lpExtName, 0, (size_t) dwBigBufSize);
        lpExtName->dwTotalSize = dwBigBufSize;

        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        extID.dwExtensionID0 = (DWORD) params[3].dwValue;
        extID.dwExtensionID1 = (DWORD) params[4].dwValue;
        extID.dwExtensionID2 = (DWORD) params[5].dwValue;
        extID.dwExtensionID3 = (DWORD) params[6].dwValue;

#if TAPI_2_0
        if (funcIndex == lGetAppPriority)
        {
            lResult = lineGetAppPriority(
                (LPCSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPVARSTRING) params[8].dwValue,
                (LPDWORD) params[9].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[0].dwValue);

            lResult = lineGetAppPriorityW(
                (LPCWSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPVARSTRING) params[8].dwValue,
                (LPDWORD) params[9].dwValue
                );
        }
#else
        lResult = lineGetAppPriority(
            (LPCSTR) params[0].dwValue,
            params[1].dwValue,
            (LPLINEEXTENSIONID) params[2].dwValue,
            params[7].dwValue,
            (LPVARSTRING) params[8].dwValue,
            (LPDWORD) params[9].dwValue
            );
#endif
        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%sdwPriority = x%lx", szTab, dwPriority);
            ShowStructByDWORDs (lpExtName);
        }

        break;
    }
    case lGetCountry:
#if TAPI_2_0
    case lGetCountryW:
#endif
    {
        LPLINECOUNTRYLIST lpCountryList = (LPLINECOUNTRYLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { "dwCountryID",       PT_DWORD,    (ULONG_PTR) 1, NULL },
            { szdwAPIVersion,      PT_ORDINAL,  (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpLineCountryList", PT_POINTER,  (ULONG_PTR) lpCountryList, lpCountryList }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetCountry ?
                (PFN3) lineGetCountry : (PFN3) lineGetCountryW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetCountry };
#endif

        memset (lpCountryList, 0, (size_t) dwBigBufSize);
        lpCountryList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpCountryList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPLINECOUNTRYENTRY lpCountryEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumCountries",         FT_DWORD,   lpCountryList->dwNumCountries, NULL },
                    { "dwCountryListSize",      FT_DWORD,   lpCountryList->dwCountryListSize, NULL },
                    { "dwCountryListOffset",    FT_DWORD,   lpCountryList->dwCountryListOffset, NULL }

                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCountryList,
                    "LINECOUNTRYLIST",
                    3,
                    fields
                };


                ShowStructByField (&fieldHeader, FALSE);

                lpCountryEntry = (LPLINECOUNTRYENTRY)
                    (((LPBYTE)lpCountryList) +
                        lpCountryList->dwCountryListOffset);

                for (i = 0; i < lpCountryList->dwNumCountries; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwCountryID",                FT_DWORD,   lpCountryEntry->dwCountryID, NULL },
                        { "dwCountryCode",              FT_DWORD,   lpCountryEntry->dwCountryCode, NULL },
                        { "dwNextCountryID",            FT_DWORD,   lpCountryEntry->dwNextCountryID, NULL },
                        { "dwCountryNameSize",          FT_SIZE,    lpCountryEntry->dwCountryNameSize, NULL },
                        { "dwCountryNameOffset",        FT_OFFSET,  lpCountryEntry->dwCountryNameOffset, NULL },
                        { "dwSameAreaRuleSize",         FT_SIZE,    lpCountryEntry->dwSameAreaRuleSize, NULL },
                        { "dwSameAreaRuleOffset",       FT_OFFSET,  lpCountryEntry->dwSameAreaRuleOffset, NULL },
                        { "dwLongDistanceRuleSize",     FT_SIZE,    lpCountryEntry->dwLongDistanceRuleSize, NULL },
                        { "dwLongDistanceRuleOffset",   FT_OFFSET,  lpCountryEntry->dwLongDistanceRuleOffset, NULL },
                        { "dwInternationalRuleSize",    FT_SIZE,    lpCountryEntry->dwInternationalRuleSize, NULL },
                        { "dwInternationalRuleOffset",  FT_OFFSET,  lpCountryEntry->dwInternationalRuleOffset, NULL }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpCountryList, // size,offset relative to ctrylist
                        buf,
                        11,
                        fields
                    };


                    sprintf (buf, "LINECOUNTRYENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpCountryEntry++;
                }
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case lGetProviderList:
#if TAPI_2_0
    case lGetProviderListW:
#endif
    {
        LPLINEPROVIDERLIST lpProviderList = (LPLINEPROVIDERLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpProviderList", PT_POINTER, (ULONG_PTR) lpProviderList, lpProviderList }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == lGetProviderList ?
                (PFN3) lineGetProviderList : (PFN3) lineGetProviderListW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN3) lineGetProviderList };
#endif

        memset (lpProviderList, 0, (size_t) dwBigBufSize);
        lpProviderList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpProviderList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPLINEPROVIDERENTRY lpProviderEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumProviders",         FT_DWORD,   lpProviderList->dwNumProviders, NULL },
                    { "dwProviderListSize",     FT_DWORD,   lpProviderList->dwProviderListSize, NULL },
                    { "dwProviderListOffset",   FT_DWORD,   lpProviderList->dwProviderListOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpProviderList,
                    "LINEPROVIDERLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpProviderEntry = (LPLINEPROVIDERENTRY)
                    (((LPBYTE) lpProviderList) +
                        lpProviderList->dwProviderListOffset);

                for (i = 0; i < lpProviderList->dwNumProviders; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentProviderID",      FT_DWORD,   lpProviderEntry->dwPermanentProviderID, NULL },
                        { "dwProviderFilenameSize",     FT_SIZE,    lpProviderEntry->dwProviderFilenameSize, NULL },
                        { "dwProviderFilenameOffset",   FT_OFFSET,  lpProviderEntry->dwProviderFilenameOffset, NULL }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpProviderList, // size,offset relative to ctrylist
                        buf,
                        3,
                        fields
                    };


                    sprintf (buf, "LINEPROVIDERENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpProviderEntry++;
                }

            }

            UpdateResults (FALSE);
        }

        break;
    }
    case lReleaseUserUserInfo:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineReleaseUserUserInfo };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lRemoveProvider:
    {
        FUNC_PARAM params[] =
        {
            { "dwPermanentProviderID",  PT_DWORD,   (ULONG_PTR) 2, NULL },
            { szhwndOwner,              PT_DWORD,   (ULONG_PTR) ghwndMain, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineRemoveProvider };


#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineRemoveProvider(
            params[0].dwValue,
            (HWND) params[1].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case lSetAppPriority:
#if TAPI_2_0
    case lSetAppPriorityW:
#endif
    {
        char szAppName[MAX_STRING_PARAM_SIZE];
        char szExtName[MAX_STRING_PARAM_SIZE] = "";
        LINEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { szlpszAppName,        PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "dwMediaMode",        PT_FLAGS,   (ULONG_PTR) dwDefMediaMode, aMediaModes },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID },
            { "  ->dwExtensionID0", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID1", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID2", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID3", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRequestMode",      PT_FLAGS,   (ULONG_PTR) LINEREQUESTMODE_MAKECALL, aRequestModes },
            { "lpszExtensionName",  PT_STRING,  (ULONG_PTR) szExtName, szExtName },
            { "dwPriority",         PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, NULL };


        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        extID.dwExtensionID0 = (DWORD) params[3].dwValue;
        extID.dwExtensionID1 = (DWORD) params[4].dwValue;
        extID.dwExtensionID2 = (DWORD) params[5].dwValue;
        extID.dwExtensionID3 = (DWORD) params[6].dwValue;

#if TAPI_2_0
        if (funcIndex == lSetAppPriority)
        {
            lResult = lineSetAppPriority(
                (LPCSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPCSTR) params[8].dwValue,
                (DWORD) params[9].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[0].dwValue);

            lResult = lineSetAppPriorityW(
                (LPCWSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPCWSTR) params[8].dwValue,
                (DWORD) params[9].dwValue
                );
        }
#else
        lResult = lineSetAppPriority(
            (LPCSTR) params[0].dwValue,
            params[1].dwValue,
            (LPLINEEXTENSIONID) params[2].dwValue,
            params[7].dwValue,
            (LPCSTR) params[8].dwValue,
            params[9].dwValue
            );
#endif
        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case lTranslateDialog:
#if TAPI_2_0
    case lTranslateDialogW:
#endif
    {
        char szAddressIn[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { szhwndOwner,      PT_DWORD,   (ULONG_PTR) ghwndMain, 0 },
            { "lpszAddressIn",  PT_STRING,  (ULONG_PTR) szAddressIn, szAddressIn }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lTranslateDialog ?
                (PFN5) lineTranslateDialog : (PFN5) lineTranslateDialogW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineTranslateDialog };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        strcpy (szAddressIn, szDefDestAddress);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineTranslateDialog(
            (HLINEAPP) params[0].dwValue,
            params[1].dwValue,
            params[2].dwValue,
            (HWND) params[3].dwValue,
            (LPCSTR) params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
#endif // TAPI_1_1

#if INTERNAL_3_0

    case mmcAddProvider:
    {
        char szProviderFilename[MAX_STRING_PARAM_SIZE] = "";
        DWORD dwPermanentProviderID;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,                    PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { "lpszProviderFilename",       PT_STRING,  (ULONG_PTR) szProviderFilename, szProviderFilename },
            { szhwndOwner,                  PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { "lpdwPermanentProviderID",    PT_POINTER, (ULONG_PTR) &dwPermanentProviderID, &dwPermanentProviderID }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) MMCAddProvider };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr(
                "%sdwPermanentProviderID = x%lx",
                szTab,
                dwPermanentProviderID
                );
        }

        break;
    }
    case mmcConfigProvider:
    {
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { szhwndOwner,      PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { szdwProviderID,   PT_DWORD,   (ULONG_PTR) 2, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) MMCConfigProvider };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case mmcGetAvailableProviders:
    {
        LPAVAILABLEPROVIDERLIST lpList = (LPAVAILABLEPROVIDERLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpProviderList", PT_POINTER, (ULONG_PTR) lpList, lpList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, MMCGetAvailableProviders };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpList, 0, (size_t) dwBigBufSize);
        lpList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPAVAILABLEPROVIDERENTRY    lpEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumProviderListEntries",   FT_DWORD,   lpList->dwNumProviderListEntries, NULL },
                    { "dwProviderListSize",         FT_DWORD,   lpList->dwProviderListSize, NULL },
                    { "dwProviderListOffset",       FT_DWORD,   lpList->dwProviderListOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpList,
                    "AVAILABLEPROVIDERLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpEntry = (LPAVAILABLEPROVIDERENTRY)
                    (((LPBYTE) lpList) + lpList->dwProviderListOffset);

                for (i = 0; i < lpList->dwNumProviderListEntries; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwFileNameSize",         FT_SIZE,    lpEntry->dwFileNameSize, NULL },
                        { "dwFileNameOffset",       FT_OFFSET,  lpEntry->dwFileNameOffset, NULL },
                        { "dwFriendlyNameSize",     FT_SIZE,    lpEntry->dwFriendlyNameSize, NULL },
                        { "dwFriendlyNameOffset",   FT_OFFSET,  lpEntry->dwFriendlyNameOffset, NULL },
                        { "dwOptions",              FT_FLAGS,   lpEntry->dwOptions, aAvailableProviderOptions }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpList, // size,offset relative to list
                        buf,
                        5,
                        fields
                    };


                    sprintf (buf, "AVAILABLEPROVIDERENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpEntry++;
                }
            }

            UpdateResults (FALSE);
        }
        break;
    }
    case mmcGetLineInfo:
    case mmcGetPhoneInfo:
    {
        LPDEVICEINFOLIST pList = (LPDEVICEINFOLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,    PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { "lpInfoList", PT_POINTER, (ULONG_PTR) pList, pList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == mmcGetLineInfo ?
                (PFN5) MMCGetLineInfo : (PFN5) MMCGetPhoneInfo) };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pList, 0, (size_t) dwBigBufSize);
        pList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            LPDEVICEINFO    pInfo = (LPDEVICEINFO) (((LPBYTE)
                              pList) + pList->dwDeviceInfoOffset);


            UpdateResults (TRUE);

            ShowStructByDWORDs (pList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwNumDevInfoEntries",    FT_DWORD,   pList->dwNumDeviceInfoEntries, NULL },
                    { "dwDevInfoSize",          FT_SIZE,    pList->dwDeviceInfoSize, NULL },
                    { "dwDevInfoOffset",        FT_OFFSET,  pList->dwDeviceInfoOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    pList, "DEVICEINFOLIST", 3, fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                for (i = 0; i < pList->dwNumDeviceInfoEntries; i++, pInfo++)
                {
                    char szDevInfoN[16];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentDevID",           FT_DWORD,   pInfo->dwPermanentDeviceID, NULL },
                        { szdwProviderID,               FT_DWORD,   pInfo->dwProviderID, NULL },
                        { "dwDevNameSize",              FT_SIZE,    pInfo->dwDeviceNameSize, NULL },
                        { "dwDevNameOffset",            FT_OFFSET,  pInfo->dwDeviceNameOffset, NULL },
                        { "dwDomainUserNamesSize",      FT_SIZE,    pInfo->dwDomainUserNamesSize, NULL },
                        { "dwDomainUserNamesOffset",    FT_OFFSET,  pInfo->dwDomainUserNamesOffset, NULL },
                        { "dwFriendlyUserNamesSize",    FT_SIZE,    pInfo->dwFriendlyUserNamesSize, NULL },
                        { "dwFriendlyUserNamesOffset",  FT_OFFSET,  pInfo->dwFriendlyUserNamesOffset, NULL },
                        { "dwAddressesSize",            FT_SIZE,    pInfo->dwAddressesSize, NULL },
                        { "dwAddressesOffset",          FT_OFFSET,  pInfo->dwAddressesOffset, NULL },
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        pList,
                        szDevInfoN,
                        (funcIndex == mmcGetLineInfo ? 10 : 8),
                        fields
                    };

                    wsprintf (szDevInfoN, "DEVICEINFO[%d]", i);

                    ShowStructByField (&fieldHeader, TRUE);
                }
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case mmcGetLineStatus:
    case mmcGetPhoneStatus:
    {
        LPVARSTRING pStatus = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szhwndOwner,          PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { "dwStatusLevel",      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwProviderID,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwPermanentDevID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpStatusBuffer",     PT_POINTER, (ULONG_PTR) pStatus, pStatus }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == mmcGetLineStatus ?
                (PFN6) MMCGetLineStatus : (PFN6) MMCGetPhoneStatus) };

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pStatus, 0, (size_t) dwBigBufSize);
        pStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (pStatus);

            ShowVARSTRING (pStatus);
        }
        break;
    }
    case mmcGetProviderList:
    {
        LPLINEPROVIDERLIST lpList = (LPLINEPROVIDERLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpProviderList", PT_POINTER, (ULONG_PTR) lpList, lpList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, MMCGetProviderList };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpList, 0, (size_t) dwBigBufSize);
        lpList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPLINEPROVIDERENTRY lpEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumProviders",         FT_DWORD,   lpList->dwNumProviders, NULL },
                    { "dwProviderListSize",     FT_DWORD,   lpList->dwProviderListSize, NULL },
                    { "dwProviderListOffset",   FT_DWORD,   lpList->dwProviderListOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpList,
                    "LINEPROVIDERLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpEntry = (LPLINEPROVIDERENTRY)
                    (((LPBYTE) lpList) + lpList->dwProviderListOffset);

                for (i = 0; i < lpList->dwNumProviders; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentProviderID",      FT_DWORD,   lpEntry->dwPermanentProviderID, NULL },
                        { "dwProviderFilenameSize",     FT_SIZE,    lpEntry->dwProviderFilenameSize, NULL },
                        { "dwProviderFilenameOffset",   FT_OFFSET,  lpEntry->dwProviderFilenameOffset, NULL }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpList, // size,offset relative to list
                        buf,
                        3,
                        fields
                    };


                    sprintf (buf, "LINEPROVIDERENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpEntry++;
                }
            }

            UpdateResults (FALSE);
        }
        break;
    }
    case mmcGetServerConfig:
    {
        LPTAPISERVERCONFIG  pConfig = (LPTAPISERVERCONFIG) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,    PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpConfig",   PT_POINTER, (ULONG_PTR) pConfig, pConfig }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, MMCGetServerConfig };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pConfig, 0, (size_t) dwBigBufSize);
        pConfig->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (pConfig);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwFlags",                FT_FLAGS,   pConfig->dwFlags, aServerConfigFlags },
                    { "dwDomainNameSize",       FT_SIZE,    pConfig->dwDomainNameSize, NULL },
                    { "dwDomainNameOffset",     FT_OFFSET,  pConfig->dwDomainNameOffset, NULL },
                    { "dwUserNameSize",         FT_SIZE,    pConfig->dwUserNameSize, NULL },
                    { "dwUserNameOffset",       FT_OFFSET,  pConfig->dwUserNameOffset, NULL },
                    { "dwPasswordSize",         FT_SIZE,    pConfig->dwPasswordSize, NULL },
                    { "dwPasswordOffset",       FT_OFFSET,  pConfig->dwPasswordOffset, NULL },
                    { "dwAdministratorsSize",   FT_SIZE,    pConfig->dwAdministratorsSize, NULL },
                    { "dwAdministratorsOffset", FT_OFFSET,  pConfig->dwAdministratorsOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    pConfig,
                    "TAPISERVERCONFIG",
                    9,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case mmcInitialize:
    {
        PMYLINEAPP pNewLineApp;
        char szComputerName[MAX_STRING_PARAM_SIZE];
        DWORD dwAPIVersion, dwLength;
        FUNC_PARAM params[] =
        {
            { "lpszComputerName",   PT_STRING,  (ULONG_PTR) szComputerName, szComputerName },
            { "lphLineApp",         PT_POINTER, (ULONG_PTR) 0, NULL },
            { "lpdwAPIVersion",     PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "  ->dwAPIVersion",   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "hInstance",          PT_DWORD,   (ULONG_PTR) NULL, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (!(pNewLineApp = AllocLineApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewLineApp->hLineApp;

        dwLength = sizeof (szComputerName);
        GetComputerName (szComputerName, &dwLength);

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreeLineApp (pNewLineApp);

            break;
        }

        MakeWideString (szComputerName);

        dwAPIVersion = params[3].dwValue;

        DumpParams (&paramsHeader);

        lResult = MMCInitialize(
            (LPCWSTR)   params[0].dwValue,
            (LPHMMCAPP) params[1].dwValue,
            (LPDWORD)   params[2].dwValue,
            (HANDLE)    params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            UpdateWidgetList();
            SelectWidget ((PMYWIDGET) pNewLineApp);
        }
        else
        {
            FreeLineApp (pNewLineApp);
        }

        break;
    }
    case mmcRemoveProvider:
    {
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { szhwndOwner,      PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { szdwProviderID,   PT_DWORD,   (ULONG_PTR) 2, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) MMCRemoveProvider };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case mmcSetLineInfo:
    case mmcSetPhoneInfo:
    {
        char    szDomainUser0[MAX_STRING_PARAM_SIZE] = "",
                szDomainUser1[MAX_STRING_PARAM_SIZE] = "",
                szFriendlyUser0[MAX_STRING_PARAM_SIZE] = "",
                szFriendlyUser1[MAX_STRING_PARAM_SIZE] = "";
        DWORD   dwSize;
        LPDEVICEINFO        pInfo;
        LPDEVICEINFOLIST    pList = (LPDEVICEINFOLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpInfoList",         PT_POINTER, (ULONG_PTR) pList, pList },
            { "  ->dwPermDevID",    PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwProviderID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->DomainUser0",    PT_STRING,  (ULONG_PTR) szDomainUser0, szDomainUser0 },
            { "  ->DomainUser1",    PT_STRING,  (ULONG_PTR) szDomainUser1, szDomainUser1 },
            { "  ->FriendlyUser0",  PT_STRING,  (ULONG_PTR) szFriendlyUser0, szFriendlyUser0 },
            { "  ->FriendlyUser1",  PT_STRING,  (ULONG_PTR) szFriendlyUser1, szFriendlyUser1 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 8, funcIndex, params, NULL };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pList, 0, (size_t) dwBigBufSize);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        pList->dwTotalSize = sizeof (*pList) + sizeof (DEVICEINFO);

        pList->dwNumDeviceInfoEntries = 1;
        pList->dwDeviceInfoSize       = sizeof (DEVICEINFO);
        pList->dwDeviceInfoOffset     = sizeof (*pList);

        pInfo = (LPDEVICEINFO) (pList + 1);

        pInfo->dwPermanentDeviceID = params[2].dwValue;
        pInfo->dwProviderID        = params[3].dwValue;

        MakeWideString (szDomainUser0);
        MakeWideString (szDomainUser1);
        MakeWideString (szFriendlyUser0);
        MakeWideString (szFriendlyUser1);

        if (params[3].dwValue  &&
            (dwSize = wcslen ((WCHAR *) szDomainUser0)))
        {
            //
            //
            //

            wcscpy(
                (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                (WCHAR *)  szDomainUser0
                );

            dwSize++;
            dwSize *= sizeof (WCHAR);

            pInfo->dwDomainUserNamesSize   = dwSize;
            pInfo->dwDomainUserNamesOffset = pList->dwTotalSize;

            pList->dwTotalSize += dwSize;

            if (params[4].dwValue  &&
                (dwSize = wcslen ((WCHAR *) szDomainUser1)))
            {
                wcscpy(
                    (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                    (WCHAR *)  szDomainUser1
                    );

                dwSize++;
                dwSize *= sizeof (WCHAR);

                pInfo->dwDomainUserNamesSize += dwSize;

                pList->dwTotalSize += dwSize;
            }

            *((WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize)) =
                L'\0';

            pInfo->dwDomainUserNamesSize += sizeof (WCHAR);

            pList->dwTotalSize += sizeof (WCHAR);


            //
            //
            //

            dwSize = (wcslen ((WCHAR *) szFriendlyUser0) + 1) * sizeof (WCHAR);

            wcscpy(
                (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                (WCHAR *)  szFriendlyUser0
                );

            pInfo->dwFriendlyUserNamesSize   = dwSize;
            pInfo->dwFriendlyUserNamesOffset = pList->dwTotalSize;

            pList->dwTotalSize += dwSize;

            if (params[4].dwValue  &&
                (dwSize = wcslen ((WCHAR *) szFriendlyUser1)))
            {
                wcscpy(
                    (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                    (WCHAR *)  szFriendlyUser1
                    );

                dwSize++;
                dwSize *= sizeof (WCHAR);

                pInfo->dwFriendlyUserNamesSize += dwSize;

                pList->dwTotalSize += dwSize;
            }

            *((WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize)) =
                L'\0';

            pInfo->dwFriendlyUserNamesSize += sizeof (WCHAR);

            pList->dwTotalSize += sizeof (WCHAR);
        }

        DumpParams (&paramsHeader);

        if (funcIndex == mmcSetLineInfo)
        {
            lResult = MMCSetLineInfo(
                (HMMCAPP)           params[0].dwValue,
                (LPDEVICEINFOLIST)  params[1].dwValue
                );
        }
        else
        {
            lResult = MMCSetPhoneInfo(
                (HMMCAPP)           params[0].dwValue,
                (LPDEVICEINFOLIST)  params[1].dwValue
                );
        }

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case mmcSetServerConfig:
    {
        char    szDomain[MAX_STRING_PARAM_SIZE] = "",
                szUser[MAX_STRING_PARAM_SIZE] = "",
                szPassword[MAX_STRING_PARAM_SIZE] = "",
                szAdmin0[MAX_STRING_PARAM_SIZE] = "",
                szAdmin1[MAX_STRING_PARAM_SIZE] = "";
        LPTAPISERVERCONFIG  pConfig = (LPTAPISERVERCONFIG) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpConfig",       PT_POINTER, (ULONG_PTR) pConfig, pConfig },
            { "  ->dwFlags",    PT_FLAGS,   (ULONG_PTR) 0, aServerConfigFlags },
            { "  ->DomainName", PT_STRING,  (ULONG_PTR) szDomain, szDomain },
            { "  ->UserName",   PT_STRING,  (ULONG_PTR) szUser, szUser },
            { "  ->Password",   PT_STRING,  (ULONG_PTR) szPassword, szPassword },
            { "  ->Admin0",     PT_STRING,  (ULONG_PTR) szAdmin0, szAdmin0 },
            { "  ->Admin1",     PT_STRING,  (ULONG_PTR) szAdmin1, szAdmin1 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 8, funcIndex, params, NULL };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pConfig, 0, (size_t) dwBigBufSize);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        pConfig->dwTotalSize = sizeof (*pConfig);

        pConfig->dwFlags = params[2].dwValue;

        if (pConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETACCOUNT)
        {
            MakeWideString (szDomain);
            MakeWideString (szUser);
            MakeWideString (szPassword);

            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szDomain
                );

            pConfig->dwDomainNameOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwDomainNameSize =
                    (wcslen ((WCHAR *) szDomain) + 1) * sizeof (WCHAR));

            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szUser
                );

            pConfig->dwUserNameOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwUserNameSize =
                    (wcslen ((WCHAR *) szUser) + 1) * sizeof (WCHAR));

            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szPassword
                );

            pConfig->dwPasswordOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwPasswordSize =
                    (wcslen ((WCHAR *) szPassword) + 1) * sizeof (WCHAR));
        }

        MakeWideString (szAdmin0);
        MakeWideString (szAdmin1);

        if ((pConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS) &&
            params[6].dwValue  &&
            wcslen ((WCHAR *) szAdmin0))
        {
            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szAdmin0
                );

            pConfig->dwAdministratorsOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwAdministratorsSize =
                    (wcslen ((WCHAR *) szAdmin0) + 1) * sizeof (WCHAR));

            if (params[7].dwValue  &&  wcslen ((WCHAR *) szAdmin1))
            {
                DWORD   dwSize;

                wcscpy(
                    (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                    (WCHAR *) szAdmin1
                    );

                dwSize = (wcslen ((WCHAR *) szAdmin1) + 1) * sizeof (WCHAR);

                pConfig->dwAdministratorsSize += dwSize;

                pConfig->dwTotalSize += dwSize;
            }

            *((WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize)) = L'\0';

            pConfig->dwAdministratorsSize += sizeof (WCHAR);

            pConfig->dwTotalSize += sizeof (WCHAR);
        }

        DumpParams (&paramsHeader);

        lResult = MMCSetServerConfig(
            (HMMCAPP)               params[0].dwValue,
            (LPTAPISERVERCONFIG)    params[1].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case mmcShutdown:
    {
        FUNC_PARAM params[] =
        {
            { szhMmcApp,   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) MMCShutdown };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        if (lResult == 0)
        {
            ShowWidgetList (FALSE);
            FreeLineApp (GetLineApp((HLINEAPP) params[0].dwValue));
            ShowWidgetList (TRUE);
        }

        break;
    }

#endif // INTERNAL_3_0

    case pClose:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) phoneClose };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if ((lResult = DoFunc(&paramsHeader)) == 0)
        {
            FreePhone (GetPhone((HPHONE) params[0].dwValue));

            // Try to auto select the next valid hPhone in the list
        }

        break;
    }
    case pConfigDialog:
#if TAPI_2_0
    case pConfigDialogW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,       PT_DWORD, (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szhwndOwner,        PT_DWORD, (ULONG_PTR) ghwndMain, NULL },
            { szlpszDeviceClass,  PT_STRING,(ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pConfigDialog ?
                (PFN3) phoneConfigDialog : (PFN3) phoneConfigDialogW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneConfigDialog };
#endif

        CHK_PHONEAPP_SELECTED()

        strcpy (szDeviceClass, szDefPhoneDeviceClass);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = phoneConfigDialog(
            params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPCSTR) params[2].dwValue
            );

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case pDevSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,   PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneDevSpecific };


        CHK_PHONE_SELECTED()

        memset (pBigBuf, 0, (size_t) dwBigBufSize);

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        DoFunc (&paramsHeader);

        break;
    }
    case pGetButtonInfo:
#if TAPI_2_0
    case pGetButtonInfoW:
#endif
    {
        LPPHONEBUTTONINFO lpButtonInfo = (LPPHONEBUTTONINFO) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,           PT_DWORD,     (ULONG_PTR) 0, NULL },
            { "dwButtonLampID",   PT_DWORD,     (ULONG_PTR) 0, NULL },
            { "lpButtonInfo",     PT_POINTER,   (ULONG_PTR) lpButtonInfo, lpButtonInfo }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pGetButtonInfo ?
                (PFN3) phoneGetButtonInfo : (PFN3) phoneGetButtonInfoW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetButtonInfo };
#endif

        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);
        lpButtonInfo->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpButtonInfo);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwButtonMode",           FT_FLAGS,   lpButtonInfo->dwButtonMode, aButtonModes },
                    { "dwButtonFunction",       FT_ORD,     lpButtonInfo->dwButtonFunction, aButtonFunctions },
                    { "dwButtonTextSize",       FT_SIZE,    lpButtonInfo->dwButtonTextSize, NULL },
                    { "dwButtonTextOffset",     FT_OFFSET,  lpButtonInfo->dwButtonTextOffset, NULL },
                    { "dwDevSpecificSize",      FT_SIZE,    lpButtonInfo->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpButtonInfo->dwDevSpecificOffset, NULL }
#if TAPI_1_1
                     ,
                    { "dwButtonState",          FT_FLAGS,   lpButtonInfo->dwButtonState, aButtonStates }
#endif


                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpButtonInfo,
                    "PHONEBUTTONINFO",
#if TAPI_1_1
                    7,
#else
                    6,
#endif
                    fields
                };

#if TAPI_1_1

                // BUGBUG only show v1.0 fields if APIver == 0x10003
                //        fieldHeader.dwNumFields--;
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case pGetData:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwDataID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpData",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) (dwBigBufSize > 64 ? 64 : dwBigBufSize), 0}
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneGetData };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowBytes(
                (dwBigBufSize > (DWORD) params[3].dwValue ?
                    (DWORD) params[3].dwValue : dwBigBufSize),
                pBigBuf,
                0
                );
        }

        break;
    }
    case pGetDevCaps:
#if TAPI_2_0
    case pGetDevCapsW:
#endif
    {
        LPPHONECAPS lpDevCaps = (LPPHONECAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
            { "dwExtVersion",   PT_DWORD,   (ULONG_PTR) dwDefPhoneExtVersion, NULL },
            { "lpPhoneDevCaps", PT_POINTER, (ULONG_PTR) lpDevCaps, lpDevCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == pGetDevCaps ?
                (PFN5) phoneGetDevCaps : (PFN5) phoneGetDevCapsW ) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) phoneGetDevCaps };
#endif

        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        memset (lpDevCaps, 0, (size_t) dwBigBufSize);
        lpDevCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwProviderInfoSize",         FT_SIZE,    lpDevCaps->dwProviderInfoSize, NULL },
                    { "dwProviderInfoOffset",       FT_OFFSET,  lpDevCaps->dwProviderInfoOffset, NULL },
                    { "dwPhoneInfoSize",            FT_SIZE,    lpDevCaps->dwPhoneInfoSize, NULL },
                    { "dwPhoneInfoOffset",          FT_OFFSET,  lpDevCaps->dwPhoneInfoOffset, NULL },
                    { "dwPermanentPhoneID",         FT_DWORD,   lpDevCaps->dwPermanentPhoneID, NULL },
                    { "dwPhoneNameSize",            FT_SIZE,    lpDevCaps->dwPhoneNameSize, NULL },
                    { "dwPhoneNameOffset",          FT_OFFSET,  lpDevCaps->dwPhoneNameOffset, NULL },
                    { "dwStringFormat",             FT_ORD,     lpDevCaps->dwStringFormat, aStringFormats },
                    { "dwPhoneStates",              FT_FLAGS,   lpDevCaps->dwPhoneStates, aPhoneStates },
                    { "dwHookSwitchDevs",           FT_FLAGS,   lpDevCaps->dwHookSwitchDevs, aHookSwitchDevs },
                    { "dwHandsetHookSwitchModes",   FT_FLAGS,   lpDevCaps->dwHandsetHookSwitchModes, aHookSwitchModes },
                    { "dwSpeakerHookSwitchModes",   FT_FLAGS,   lpDevCaps->dwSpeakerHookSwitchModes, aHookSwitchModes },
                    { "dwHeadsetHookSwitchModes",   FT_FLAGS,   lpDevCaps->dwHeadsetHookSwitchModes, aHookSwitchModes },
                    { "dwVolumeFlags",              FT_FLAGS,   lpDevCaps->dwVolumeFlags, aHookSwitchDevs },
                    { "dwGainFlags",                FT_FLAGS,   lpDevCaps->dwGainFlags, aHookSwitchDevs },
                    { "dwDisplayNumRows",           FT_DWORD,   lpDevCaps->dwDisplayNumRows, NULL },
                    { "dwDisplayNumColumns",        FT_DWORD,   lpDevCaps->dwDisplayNumColumns, NULL },
                    { "dwNumRingModes",             FT_DWORD,   lpDevCaps->dwNumRingModes, NULL },
                    { "dwNumButtonLamps",           FT_DWORD,   lpDevCaps->dwNumButtonLamps, NULL },
                    { "dwButtonModesSize",          FT_SIZE,    lpDevCaps->dwButtonModesSize, NULL },
                    { "dwButtonModesOffset",        FT_OFFSET,  lpDevCaps->dwButtonModesOffset, NULL },
                    { "dwButtonFunctionsSize",      FT_SIZE,    lpDevCaps->dwButtonFunctionsSize, NULL },
                    { "dwButtonFunctionsOffset",    FT_OFFSET,  lpDevCaps->dwButtonFunctionsOffset, NULL },
                    { "dwLampModesSize",            FT_SIZE,    lpDevCaps->dwLampModesSize, NULL },
                    { "dwLampModesOffset",          FT_OFFSET,  lpDevCaps->dwLampModesOffset, NULL },
                    { "dwNumSetData",               FT_DWORD,   lpDevCaps->dwNumSetData, NULL },
                    { "dwSetDataSize",              FT_SIZE,    lpDevCaps->dwSetDataSize, NULL },
                    { "dwSetDataOffset",            FT_OFFSET,  lpDevCaps->dwSetDataOffset, NULL },
                    { "dwNumGetData",               FT_DWORD,   lpDevCaps->dwNumGetData, NULL },
                    { "dwGetDataSize",              FT_SIZE,    lpDevCaps->dwGetDataSize, NULL },
                    { "dwGetDataOffset",            FT_OFFSET,  lpDevCaps->dwGetDataOffset, NULL },
                    { "dwDevSpecificSize",          FT_SIZE,    lpDevCaps->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",        FT_OFFSET,  lpDevCaps->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwDeviceClassesSize",        FT_SIZE,    0, NULL },
                    { "dwDeviceClassesOffset",      FT_OFFSET,  0, NULL },
                    { "dwPhoneFeatures",            FT_FLAGS,   0, aPhoneFeatures },
                    { "dwSettableHandsetHookSwitchModes",   FT_FLAGS,   0, aHookSwitchModes },
                    { "dwSettableSpeakerHookSwitchModes",   FT_FLAGS,   0, aHookSwitchModes },
                    { "dwSettableHeadsetHookSwitchModes",   FT_FLAGS,   0, aHookSwitchModes },
                    { "dwMonitoredHandsetHookSwitchModes",  FT_FLAGS,   0, aHookSwitchModes },
                    { "dwMonitoredSpeakerHookSwitchModes",  FT_FLAGS,   0, aHookSwitchModes },
                    { "dwMonitoredHeadsetHookSwitchModes",  FT_FLAGS,   0, aHookSwitchModes }
#if TAPI_2_2
                     ,
                    { "PermanentPhoneGuid(Size)",   FT_SIZE,    sizeof (lpDevCaps->PermanentPhoneGuid), NULL },
                    { "PermanentPhoneGuid(Offset)", FT_OFFSET,  ((LPBYTE) &lpDevCaps->PermanentPhoneGuid) - ((LPBYTE) lpDevCaps), NULL }
#endif
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpDevCaps, "PHONECAPS", 0, fields
                };


                if (params[2].dwValue < 0x00020000)
                {
                    fieldHeader.dwNumFields = 33;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 42;

                    fields[33].dwValue = lpDevCaps->dwDeviceClassesSize;
                    fields[34].dwValue = lpDevCaps->dwDeviceClassesOffset;
                    fields[35].dwValue = lpDevCaps->dwPhoneFeatures;
                    fields[36].dwValue = lpDevCaps->dwSettableHandsetHookSwitchModes;
                    fields[37].dwValue = lpDevCaps->dwSettableSpeakerHookSwitchModes;
                    fields[38].dwValue = lpDevCaps->dwSettableHeadsetHookSwitchModes;
                    fields[39].dwValue = lpDevCaps->dwMonitoredHandsetHookSwitchModes;
                    fields[40].dwValue = lpDevCaps->dwMonitoredSpeakerHookSwitchModes;
                    fields[41].dwValue = lpDevCaps->dwMonitoredHeadsetHookSwitchModes;
#if TAPI_2_2
                    if (params[2].dwValue >= 0x20002)
                    {
                        fieldHeader.dwNumFields += 2;
                    }
#endif
                }
#endif

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case pGetDisplay:
    {
        LPVARSTRING lpDisplay = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpDisplay",  PT_POINTER, (ULONG_PTR) lpDisplay, lpDisplay }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) phoneGetDisplay };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);
        lpDisplay->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDisplay);

            ShowVARSTRING (lpDisplay);
        }

        break;
    }
    case pGetGain:
    {
        DWORD dwGain;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, (ULONG_PTR) PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "lpdwGain",           PT_POINTER, (ULONG_PTR) &dwGain, &dwGain }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetGain };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwGain=x%lx", szTab, dwGain);
        }

        break;
    }
    case pGetHookSwitch:
    {
        DWORD dwHookSwitchDevs;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwHookSwitchDevs", PT_POINTER, (ULONG_PTR) &dwHookSwitchDevs, &dwHookSwitchDevs },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) phoneGetHookSwitch };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            char szDevsOnHook[32] = "";
            char szDevsOffHook[32] = "";

            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HANDSET)
            {
                strcat (szDevsOffHook, "HANDSET ");
            }
            else
            {
                strcat (szDevsOnHook, "HANDSET ");
            }

            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER)
            {
                strcat (szDevsOffHook, "SPEAKER ");
            }
            else
            {
                strcat (szDevsOnHook, "SPEAKER ");
            }

            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HEADSET)
            {
                strcat (szDevsOffHook, "HEADSET");
            }
            else
            {
                strcat (szDevsOnHook, "HEADSET");
            }

            ShowStr ("%sOn hook : %s", szTab, szDevsOnHook);
            ShowStr ("%sOff hook: %s", szTab, szDevsOffHook);
        }

        break;
    }
    case pGetIcon:
#if TAPI_2_0
    case pGetIconW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        HICON hIcon;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lphIcon",            PT_POINTER, (ULONG_PTR) &hIcon, &hIcon }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pGetIcon ?
                (PFN3) phoneGetIcon : (PFN3) phoneGetIconW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetIcon };
#endif

        strcpy (szDeviceClass, szDefPhoneDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            DialogBoxParam (
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG5),
                (HWND) ghwndMain,
                (DLGPROC) IconDlgProc,
                (LPARAM) hIcon
                );
        }

        break;
    }
    case pGetID:
#if TAPI_2_0
    case pGetIDW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpDevID = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpDeviceID",         PT_POINTER, (ULONG_PTR) lpDevID, lpDevID },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pGetID ?
                (PFN3) phoneGetID : (PFN3) phoneGetIDW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetID };
#endif

        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (lpDevID, 0, (size_t) dwBigBufSize);
        lpDevID->dwTotalSize = dwBigBufSize;

        strcpy (szDeviceClass, szDefPhoneDeviceClass);

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStructByDWORDs (lpDevID);

            ShowVARSTRING (lpDevID);
        }

        break;
    }
    case pGetLamp:
    {
        DWORD dwLampMode;
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwButtonLampID", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwLampMode",   PT_POINTER, (ULONG_PTR) &dwLampMode, &dwLampMode }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetLamp };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            for (i = 0; aLampModes[i].dwVal != 0xffffffff; i++)
            {
                if (dwLampMode == aLampModes[i].dwVal)
                {
                    ShowStr ("%slamp mode = %s", szTab, aLampModes[i].lpszVal);
                    break;
                }
            }

            if (aLampModes[i].dwVal == 0xffffffff)
            {
                ShowStr ("%sdwLampMode=%xlx (invalid)", szTab, dwLampMode);
            }
        }

        break;
    }
#if TAPI_2_0
    case pGetMessage:
    {
        PHONEMESSAGE msg;
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpMessage",  PT_POINTER, (ULONG_PTR) &msg, &msg },
            { "dwTimeout",  PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        // Max timeout of 2 seconds (don't want to hang app & excite user)

        params[2].dwValue = (params[2].dwValue > 2000 ?
            2000 : params[2].dwValue);

        DumpParams (&paramsHeader);

        lResult = phoneGetMessage(
            (HPHONEAPP)      params[0].dwValue,
            (LPPHONEMESSAGE) params[1].dwValue,
            (DWORD)          params[2].dwValue
            );

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            tapiCallback(
                msg.hDevice,
                msg.dwMessageID,
                msg.dwCallbackInstance,
                msg.dwParam1,
                msg.dwParam2,
                msg.dwParam3
                );
        }

        break;
    }
#endif
    case pGetRing:
    {
        DWORD dwRingMode, dwVolume;
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwRingMode",   PT_POINTER, (ULONG_PTR) &dwRingMode, &dwRingMode },
            { "lpdwVolume",     PT_POINTER, (ULONG_PTR) &dwVolume, &dwVolume }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetRing };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr(
                "%sdwRingMode=x%lx, dwVolume=x%lx",
                szTab,
                dwRingMode,
                dwVolume
                );
        }

        break;
    }
    case pGetStatus:
#if TAPI_2_0
    case pGetStatusW:
#endif
    {
        LPPHONESTATUS lpPhoneStatus = (LPPHONESTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpPhoneStatus",  PT_POINTER, (ULONG_PTR) lpPhoneStatus, lpPhoneStatus }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == pGetStatus ?
                (PFN2) phoneGetStatus : (PFN2) phoneGetStatusW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) phoneGetStatus };
#endif
        DWORD   dwAPIVersion;


        CHK_PHONE_SELECTED()

        dwAPIVersion = pPhoneSel->dwAPIVersion;

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);
        lpPhoneStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpPhoneStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwStatusFlags",              FT_FLAGS,   lpPhoneStatus->dwStatusFlags, aPhoneStatusFlags },
                    { "dwNumOwners",                FT_DWORD,   lpPhoneStatus->dwNumOwners, NULL },
                    { "dwNumMonitors",              FT_DWORD,   lpPhoneStatus->dwNumMonitors, NULL },
                    { "dwRingMode",                 FT_DWORD,   lpPhoneStatus->dwRingMode, NULL },
                    { "dwRingVolume",               FT_DWORD,   lpPhoneStatus->dwRingVolume, NULL },
                    { "dwHandsetHookSwitchMode",    FT_FLAGS,   lpPhoneStatus->dwHandsetHookSwitchMode, aHookSwitchModes },
                    { "dwHandsetVolume",            FT_DWORD,   lpPhoneStatus->dwHandsetVolume, NULL },
                    { "dwHandsetGain",              FT_DWORD,   lpPhoneStatus->dwHandsetGain, NULL },
                    { "dwSpeakerHookSwitchMode",    FT_FLAGS,   lpPhoneStatus->dwSpeakerHookSwitchMode, aHookSwitchModes },
                    { "dwSpeakerVolume",            FT_DWORD,   lpPhoneStatus->dwSpeakerVolume, NULL },
                    { "dwSpeakerGain",              FT_DWORD,   lpPhoneStatus->dwSpeakerGain, NULL },
                    { "dwHeadsetHookSwitchMode",    FT_FLAGS,   lpPhoneStatus->dwHeadsetHookSwitchMode, aHookSwitchModes },
                    { "dwHeadsetVolume",            FT_DWORD,   lpPhoneStatus->dwHeadsetVolume, NULL },
                    { "dwHeadsetGain",              FT_DWORD,   lpPhoneStatus->dwHeadsetGain, NULL },
                    { "dwDisplaySize",              FT_SIZE,    lpPhoneStatus->dwDisplaySize, NULL },
                    { "dwDisplayOffset",            FT_OFFSET,  lpPhoneStatus->dwDisplayOffset, NULL },
                    { "dwLampModesSize",            FT_SIZE,    lpPhoneStatus->dwLampModesSize, NULL },
                    { "dwLampModesOffset",          FT_OFFSET,  lpPhoneStatus->dwLampModesOffset, NULL },
                    { "dwOwnerNameSize",            FT_SIZE,    lpPhoneStatus->dwOwnerNameSize, NULL },
                    { "dwOwnerNameOffset",          FT_OFFSET,  lpPhoneStatus->dwOwnerNameOffset, NULL },
                    { "dwDevSpecificSize",          FT_SIZE,    lpPhoneStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",        FT_OFFSET,  lpPhoneStatus->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwPhoneFeatures",            FT_FLAGS,   0, aPhoneFeatures }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpPhoneStatus, "PHONESTATUS", 0, fields
                };


                if (dwAPIVersion < 0x00020000)
                {
                    fieldHeader.dwNumFields = 22;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 23;

                    fields[22].dwValue = lpPhoneStatus->dwPhoneFeatures;
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case pGetStatusMessages:
    {
        DWORD aFlags[3];
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwPhoneStates",    PT_POINTER, (ULONG_PTR) &aFlags[0], &aFlags[0] },
            { "lpdwButtonModes",    PT_POINTER, (ULONG_PTR) &aFlags[1], &aFlags[1] },
            { "lpdwButtonStates",   PT_POINTER, (ULONG_PTR) &aFlags[2], &aFlags[2] }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneGetStatusMessages };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            STRUCT_FIELD fields[] =
            {
                { "dwPhoneStates",  FT_FLAGS,   aFlags[0], aPhoneStates },
                { "dwButtonModes",  FT_FLAGS,   aFlags[1], aButtonModes },
                { "dwButtonStates", FT_FLAGS,   aFlags[2], aButtonStates }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                aFlags,
                "",
                3,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);
        }

        break;
    }
    case pGetVolume:
    {
        DWORD dwVolume;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, (ULONG_PTR) PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "lpdwVolume",         PT_POINTER, (ULONG_PTR) &dwVolume, &dwVolume }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetVolume };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwVolume=x%lx", szTab, dwVolume);
        }

        break;
    }
    case pInitialize:
    {
        DWORD dwNumDevs;
        PMYPHONEAPP pNewPhoneApp;
        char szAppName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "lphPhoneApp",    PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszAppName,    PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumDevs, &dwNumDevs }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) phoneInitialize };


        if (!(pNewPhoneApp = AllocPhoneApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewPhoneApp->hPhoneApp;

        strcpy (szAppName, szDefAppName);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HINSTANCEs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreePhoneApp (pNewPhoneApp);
            break;
        }

        DumpParams (&paramsHeader);

        lResult = phoneInitialize(
            (LPHPHONEAPP)   params[0].dwValue,
            (HINSTANCE)     params[1].dwValue,
            (PHONECALLBACK) params[2].dwValue,
            (LPCSTR)        params[3].dwValue,
            (LPDWORD)       params[4].dwValue
            );

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);
#endif // WIN32
        if (lResult == 0)
        {
            ShowStr ("%snum phone devs=%ld", szTab, dwNumDevs);
            UpdateWidgetList();
            gdwNumPhoneDevs = dwNumDevs;
            SelectWidget ((PMYWIDGET) pNewPhoneApp);
        }
        else
        {
            FreePhoneApp (pNewPhoneApp);
        }

        break;
    }
#if TAPI_2_0
    case pInitializeEx:
    case pInitializeExW:
    {
        char                    szAppName[MAX_STRING_PARAM_SIZE];
        DWORD                   dwNumDevs, dwAPIVersion;
        PMYPHONEAPP             pNewPhoneApp;
        PHONEINITIALIZEEXPARAMS initExParams;
        FUNC_PARAM params[] =
        {
            { "lphPhoneApp",    PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszFriendlyAppName,PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumDevs, &dwNumDevs },
            { "lpdwAPIVersion", PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "  ->dwAPIVersion",PT_ORDINAL,(ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
            { "lpInitExParams", PT_POINTER, (ULONG_PTR) &initExParams, &initExParams },
            { "  ->dwOptions",  PT_ORDINAL, (ULONG_PTR) PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT, aPhoneInitExOptions }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, NULL };


        if (!(pNewPhoneApp = AllocPhoneApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewPhoneApp->hPhoneApp;

        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreePhoneApp (pNewPhoneApp);

            break;
        }

        initExParams.dwTotalSize = sizeof (PHONEINITIALIZEEXPARAMS);
        initExParams.dwOptions = (DWORD) params[8].dwValue;
        initExParams.Handles.hCompletionPort = ghCompletionPort;

        dwAPIVersion = (DWORD) params[6].dwValue;

        DumpParams (&paramsHeader);

        if (funcIndex == pInitializeEx)
        {
            lResult = phoneInitializeEx(
                (LPHPHONEAPP)               params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (PHONECALLBACK)             params[2].dwValue,
                (LPCSTR)                    params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPPHONEINITIALIZEEXPARAMS) params[7].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[3].dwValue);

            lResult = phoneInitializeExW(
                (LPHPHONEAPP)               params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (PHONECALLBACK)             params[2].dwValue,
                (LPCWSTR)                   params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPPHONEINITIALIZEEXPARAMS) params[7].dwValue
                );
        }

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%snum phone devs = %ld", szTab, dwNumDevs);

            if (params[7].dwValue != 0  &&
                (initExParams.dwOptions & 3) ==
                    PHONEINITIALIZEEXOPTION_USEEVENT)
            {
                ShowStr(
                    "hPhoneApp x%x was created with the\r\n" \
                        "USEEVENT option, so you must use\r\n" \
                        "phoneGetMessage to retrieve messages.",
                    pNewPhoneApp->hPhoneApp
                    );
            }


            //SendMessage (ghwndLineApps, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            gdwNumPhoneDevs = dwNumDevs;
            SelectWidget ((PMYWIDGET) pNewPhoneApp);
        }
        else
        {
            FreePhoneApp (pNewPhoneApp);
        }

        break;
    }
#endif
    case pOpen:
    {
        PMYPHONE pNewPhone;
        FUNC_PARAM params[] =
        {
            { "hPhoneApp",          PT_DWORD,   0, NULL },
            { szdwDeviceID,         PT_DWORD,   dwDefPhoneDeviceID, NULL },
            { "lphPhone",           PT_POINTER, 0, NULL },
            { szdwAPIVersion,       PT_ORDINAL, dwDefPhoneAPIVersion, aAPIVersions },
            { "dwExtVersion",       PT_DWORD,   dwDefPhoneExtVersion, NULL },
            { "dwCallbackInstance", PT_DWORD,   0, NULL },
            { "dwPrivilege",        PT_ORDINAL, dwDefPhonePrivilege, aPhonePrivileges }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) phoneOpen };


        CHK_PHONEAPP_SELECTED()

        if (!(pNewPhone = AllocPhone(pPhoneAppSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewPhone->hPhone;

        if ((lResult = DoFunc(&paramsHeader)) == 0)
        {
            if ((HPHONEAPP) params[0].dwValue != pPhoneAppSel->hPhoneApp)
            {
                //
                // User has switched phone apps on us we need to recreate
                // the phone data structure under a different phone app
                //

                PMYPHONE pNewPhone2 =
                    AllocPhone (GetPhoneApp((HPHONEAPP)params[0].dwValue));

                if (pNewPhone2)
                {
                    pNewPhone2->hPhone = pNewPhone->hPhone;

                    FreePhone (pNewPhone);

                    pNewPhone = pNewPhone2;
                }
                else
                {
                    // BUGBUG show error: couldn't alloc a new phone struct

                    phoneClose (pNewPhone->hPhone);
                    FreePhone (pNewPhone);
                    break;
                }
            }


            //
            // Save info about this phone that we can display later
            //

            pNewPhone->hPhoneApp    = (HPHONEAPP) params[0].dwValue;
            pNewPhone->dwDevID      = (DWORD) params[1].dwValue;
            pNewPhone->dwAPIVersion = (DWORD) params[3].dwValue;
            pNewPhone->dwPrivilege  = (DWORD) params[6].dwValue;

            UpdateWidgetList();
            SelectWidget ((PMYWIDGET) pNewPhone);
        }
        else
        {
            FreePhone (pNewPhone);
        }

        break;
    }
    case pNegotiateAPIVersion:
    {
        DWORD dwAPIVersion;
        PHONEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { "hPhoneApp",          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { "dwAPILowVersion",    PT_DWORD,   (ULONG_PTR) 0x00010000, aAPIVersions },
            { "dwAPIHighVersion",   PT_DWORD,   (ULONG_PTR) 0x10000000, aAPIVersions },
            { "lpdwAPIVersion",     PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) phoneNegotiateAPIVersion };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%s%s=x%lx", szTab, szdwAPIVersion, dwAPIVersion);
            ShowStr(
                "%sextID.ID0=x%lx, .ID1=x%lx, .ID2=x%lx, .ID3=x%lx, ",
                szTab,
                extID.dwExtensionID0,
                extID.dwExtensionID1,
                extID.dwExtensionID2,
                extID.dwExtensionID3
                );
        }

        break;
    }
    case pNegotiateExtVersion:
    {
        DWORD dwExtVersion;
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
            { "dwExtLowVersion",    PT_DWORD,   (ULONG_PTR) 0x00000000, NULL },
            { "dwExtHighVersion",   PT_DWORD,   (ULONG_PTR) 0x80000000, NULL },
            { "lpdwExtVersion",     PT_POINTER, (ULONG_PTR) &dwExtVersion, &dwExtVersion }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) phoneNegotiateExtVersion };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwExtVersion=x%lx", szTab, dwExtVersion);
        }

        break;
    }
    case pSetButtonInfo:
#if TAPI_2_0
    case pSetButtonInfoW:
#endif
    {
        char szButtonText[MAX_STRING_PARAM_SIZE] = "button text";
        char szDevSpecific[MAX_STRING_PARAM_SIZE] = "dev specific info";
        LPPHONEBUTTONINFO lpButtonInfo = (LPPHONEBUTTONINFO) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,                 PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwButtonLampID",         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpData",                 PT_POINTER, (ULONG_PTR) lpButtonInfo, lpButtonInfo },
            { "  ->dwButtonMode",       PT_FLAGS,   (ULONG_PTR) PHONEBUTTONMODE_CALL,  aButtonModes },
            { "  ->dwButtonFunction",   PT_DWORD,   (ULONG_PTR) 0, NULL },
//            { "  ->dwButtonFunction",  PT_???,   , aButtonFunctions },
            { "  ->ButtonText",         PT_STRING,  (ULONG_PTR) szButtonText,  szButtonText },
            { "  ->DevSpecific",        PT_STRING,  (ULONG_PTR) szDevSpecific, szDevSpecific },
#if TAPI_1_1
            { "  ->dwButtonState",      PT_FLAGS,   (ULONG_PTR) 0,  aButtonStates }
#endif
        };
        FUNC_PARAM_HEADER paramsHeader =
#if TAPI_1_1
            { 8, funcIndex, params, NULL };
#else
            { 7, funcIndex, params, NULL };
#endif
        DWORD dwFixedStructSize = sizeof(PHONEBUTTONINFO), dwLength;


        // BUGBUG need a PT_ type to specify constants (ords?) for ->dwButtonFunction

        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;


        //
        // Note: the dwButtonState field in PHONEBUTTONINFO is only valid
        // in 1.4+.  It'll be ignored for phones opened w/ ver 1.3.
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        memset (lpButtonInfo, 0, (size_t) dwBigBufSize);

        if (dwBigBufSize >= 4)
        {
            lpButtonInfo->dwTotalSize = dwBigBufSize;

            if (dwBigBufSize >= 0x24) // sizeof(PHONEBUTTONINFO) in ver 0x10003
            {
                lpButtonInfo->dwButtonMode     = (DWORD) params[3].dwValue;
                lpButtonInfo->dwButtonFunction = (DWORD) params[4].dwValue;

                if ((params[5].dwValue == (ULONG_PTR) szButtonText) &&
                    (dwLength = (DWORD) strlen (szButtonText)) &&
                    (dwBigBufSize >= (dwFixedStructSize + dwLength + 1)))
                {
                    lpButtonInfo->dwButtonTextSize   = dwLength + 1;
                    lpButtonInfo->dwButtonTextOffset = dwFixedStructSize;
#if TAPI_2_0
                    if (gbWideStringParams)
                    {
                        lpButtonInfo->dwButtonTextSize *= sizeof (WCHAR);

                        MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            (LPCSTR) szButtonText,
                            -1,
                            (LPWSTR) (((char far *) lpButtonInfo) +
                                dwFixedStructSize),
                            MAX_STRING_PARAM_SIZE / 2
                            );
                    }
                    else
                    {
                        strcpy(
                            ((char far *) lpButtonInfo) + dwFixedStructSize,
                            szButtonText
                            );
                    }
#else
                    strcpy(
                        ((char far *) lpButtonInfo) + dwFixedStructSize,
                        szButtonText
                        );
#endif
                }

                if ((params[6].dwValue == (ULONG_PTR) szDevSpecific) &&
                    (dwLength = (DWORD) strlen (szDevSpecific)) &&
                    (dwBigBufSize >= (dwFixedStructSize + dwLength + 1 +
                        lpButtonInfo->dwButtonTextSize)))
                {
                    lpButtonInfo->dwDevSpecificSize   = dwLength + 1;
                    lpButtonInfo->dwDevSpecificOffset = dwFixedStructSize +
                        lpButtonInfo->dwButtonTextSize;
#if TAPI_2_0
                    if (gbWideStringParams)
                    {
                        lpButtonInfo->dwDevSpecificSize *= sizeof (WCHAR);

                        MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            (LPCSTR) szDevSpecific,
                            -1,
                            (LPWSTR) (((char far *) lpButtonInfo) +
                                lpButtonInfo->dwDevSpecificOffset),
                            MAX_STRING_PARAM_SIZE / 2
                            );
                    }
                    else
                    {
                        strcpy(
                            ((char far *) lpButtonInfo) +
                                lpButtonInfo->dwDevSpecificOffset,
                            szDevSpecific
                            );
                    }
#else
                    strcpy(
                        ((char far *) lpButtonInfo) +
                            lpButtonInfo->dwDevSpecificOffset,
                        szDevSpecific
                        );
#endif
                }
#if TAPI_1_1
                if (dwBigBufSize >= dwFixedStructSize)
                {
                    lpButtonInfo->dwButtonState = (DWORD) params[7].dwValue;
                }
#endif
            }
        }

#if TAPI_2_0
        if (funcIndex == pSetButtonInfo)
        {
            lResult = phoneSetButtonInfo(
                (HPHONE) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPPHONEBUTTONINFO) params[2].dwValue
                );
        }
        else
        {
            lResult = phoneSetButtonInfoW(
                (HPHONE) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPPHONEBUTTONINFO) params[2].dwValue
                );
        }
#else
        lResult = phoneSetButtonInfo(
            (HPHONE) params[0].dwValue,
            params[1].dwValue,
            (LPPHONEBUTTONINFO) params[2].dwValue
            );
#endif
        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case pSetData:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwDataID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpData",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneSetData };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        DoFunc (&paramsHeader);

        break;
    }
    case pSetDisplay:
    {
        char szDisplay[MAX_STRING_PARAM_SIZE] = "123";
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRow",      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwColumn",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpsDisplay", PT_STRING,  (ULONG_PTR) szDisplay, szDisplay },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) 3, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) phoneSetDisplay };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetGain:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "dwGain",             PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetGain };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetHookSwitch:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   0, NULL },
            { "dwHookSwitchDevs",   PT_FLAGS,   PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "dwHookSwitchMode",   PT_ORDINAL, PHONEHOOKSWITCHMODE_ONHOOK, aHookSwitchModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetHookSwitch };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetLamp:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   0, NULL },
            { "dwButtonLampID", PT_DWORD,   0, NULL },
            { "dwLampMode",     PT_ORDINAL, PHONELAMPMODE_OFF, aLampModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetLamp };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetRing:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD, 0, NULL },
            { "dwRingMode", PT_DWORD, 0, NULL },
            { "dwVolume",   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetRing };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetStatusMessages:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD, 0, NULL },
            { "dwPhoneStates",  PT_FLAGS, 0, aPhoneStates },
            { "dwButtonModes",  PT_FLAGS, 0, aButtonModes },
            { "dwButtonStates", PT_FLAGS, 0, aButtonStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneSetStatusMessages };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetVolume:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "dwVolume",           PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetVolume };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pShutdown:
    {
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) phoneShutdown };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowWidgetList (FALSE);
            FreePhoneApp (GetPhoneApp((HPHONEAPP) params[0].dwValue));
            ShowWidgetList (TRUE);
        }

        break;
    }
    case tGetLocationInfo:
#if TAPI_2_0
    case tGetLocationInfoW:
#endif
    {
        char szCountryCode[MAX_STRING_PARAM_SIZE] = "";
        char szCityCode[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { "lpszCountryCode",    PT_POINTER, (ULONG_PTR) szCountryCode, szCountryCode },
            { "lpszCityCode",       PT_POINTER, (ULONG_PTR) szCityCode, szCityCode }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == tGetLocationInfo ?
                (PFN2) tapiGetLocationInfo : (PFN2) tapiGetLocationInfoW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) tapiGetLocationInfo };
#endif

        if (DoFunc (&paramsHeader) == 0)
        {
#if TAPI_2_0
            ShowStr(
                (gbWideStringParams ? "%s*lpszCountryCode='%ws'" :
                    "%s*lpszCountryCode='%s'"),
                szTab,
                szCountryCode
                );

            ShowStr(
                (gbWideStringParams ? "%s*lpszCityCode='%ws'" :
                    "%s*lpszCityCode='%s'"),
                szTab,
                szCityCode
                );
#else
            ShowStr ("%s*lpszCountryCode='%s'", szTab, szCountryCode);
            ShowStr ("%s*lpszCityCode='%s'", szTab, szCityCode);
#endif
        }

        break;
    }
    case tRequestDrop:
    {
        FUNC_PARAM params[] =
        {
            { "hWnd",       PT_DWORD,   (ULONG_PTR) ghwndMain, 0 },
            { "wRequestID", PT_DWORD,   (ULONG_PTR) 0, 0 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) tapiRequestDrop };

#ifdef WIN32
        DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs & WPARAMs are 16 bits, so we've to hard
        //       code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = tapiRequestDrop(
            (HWND) params[0].dwValue,
            (WPARAM) params[1].dwValue
            );

        ShowTapiFuncResult (aFuncNames[funcIndex], lResult);
#endif // WIN32
        break;
    }
    case tRequestMakeCall:
#if TAPI_2_0
    case tRequestMakeCallW:
#endif
    {
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        char szAppName[MAX_STRING_PARAM_SIZE];
        char szCalledParty[MAX_STRING_PARAM_SIZE] = "";
        char szComment[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { szlpszAppName,        PT_STRING, (ULONG_PTR) szAppName, szAppName },
            { "lpszCalledParty",    PT_STRING, (ULONG_PTR) szCalledParty, szCalledParty },
            { "lpszComment",        PT_STRING, (ULONG_PTR) szComment, szComment }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == tRequestMakeCall ?
                (PFN4) tapiRequestMakeCall : (PFN4) tapiRequestMakeCallW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) tapiRequestMakeCall };
#endif

        strcpy (szDestAddress, szDefDestAddress);
        strcpy (szAppName, szDefAppName);

        DoFunc (&paramsHeader);

        break;
    }
    case tRequestMediaCall:
#if TAPI_2_0
    case tRequestMediaCallW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        char szDevID[MAX_STRING_PARAM_SIZE] = "0";
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        char szAppName[MAX_STRING_PARAM_SIZE];
        char szCalledParty[MAX_STRING_PARAM_SIZE] = "";
        char szComment[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { "hWnd",               PT_DWORD,  (ULONG_PTR) ghwndMain, 0 },
            { "wRequestID",         PT_DWORD,  (ULONG_PTR) 0, 0 },
            { szlpszDeviceClass,    PT_STRING, (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lpDeviceID",         PT_STRING, (ULONG_PTR) szDevID, szDevID },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) 0, 0 },
            { "dwSecure",           PT_DWORD,  (ULONG_PTR) 0, 0 },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { szlpszAppName,        PT_STRING, (ULONG_PTR) szAppName, szAppName },
            { "lpszCalledParty",    PT_STRING, (ULONG_PTR) szCalledParty, szCalledParty },
            { "lpszComment",        PT_STRING, (ULONG_PTR) szComment, szComment }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, (funcIndex == tRequestMediaCall ?
                (PFN10) tapiRequestMediaCall : (PFN10) tapiRequestMediaCallW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, (PFN10) tapiRequestMediaCall };
#endif

        strcpy (szDeviceClass, szDefLineDeviceClass); // BUGBUG szDefTapiDeviceClass);
        strcpy (szDestAddress, szDefDestAddress);
        strcpy (szAppName, szDefAppName);

#ifdef WIN32
        DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs & WPARAMs are 16 bits, so we've to hard
        //       code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = tapiRequestMediaCall(
            (HWND) params[0].dwValue,
            (WPARAM) params[1].dwValue,
            (LPCSTR) params[2].dwValue,
            (LPCSTR) params[3].dwValue,
            params[4].dwValue,
            params[5].dwValue,
            (LPCSTR) params[6].dwValue,
            (LPCSTR) params[7].dwValue,
            (LPCSTR) params[8].dwValue,
            (LPCSTR) params[9].dwValue
            );

        ShowTapiFuncResult (aFuncNames[funcIndex], lResult);
#endif // WIN32
        break;
    }
    case OpenAllLines:
    {
        DWORD dwDefLineDeviceIDSav = dwDefLineDeviceID;


        CHK_LINEAPP_SELECTED()

        UpdateResults (TRUE);
        ShowWidgetList (FALSE);

        for(
            dwDefLineDeviceID = 0;
            dwDefLineDeviceID < gdwNumLineDevs;
            dwDefLineDeviceID++
            )
        {
            FuncDriver (lOpen);
        }

        UpdateResults (FALSE);
        ShowWidgetList (TRUE);

        dwDefLineDeviceID = dwDefLineDeviceIDSav;

        break;
    }
    case OpenAllPhones:
    {
        DWORD dwDefPhoneDeviceIDSav = dwDefPhoneDeviceID;


        CHK_PHONEAPP_SELECTED()

        UpdateResults (TRUE);
        ShowWidgetList (FALSE);

        for(
            dwDefPhoneDeviceID = 0;
            dwDefPhoneDeviceID < gdwNumPhoneDevs;
            dwDefPhoneDeviceID++
            )
        {
            FuncDriver (pOpen);
        }

        UpdateResults (FALSE);
        ShowWidgetList (TRUE);

        dwDefPhoneDeviceID = dwDefPhoneDeviceIDSav;

        break;
    }
    case CloseHandl:
    {
#ifdef WIN32
        FUNC_PARAM params[] =
        {
            { "hObject",  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        if (CloseHandle ((HANDLE) params[0].dwValue))
        {
            ShowStr ("Handle x%lx closed", params[0].dwValue);
        }
        else
        {
            ShowStr ("CloseHandle failed, err=%lx", GetLastError());
        }
#else
        FUNC_PARAM params[] =
        {
            { "idCommDev",  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        if (CloseComm ((int) params[0].dwValue) == 0)
        {
            ShowStr ("Comm dev x%lx closed", params[0].dwValue);
        }
        else
        {
            ShowStr ("CloseComm() failed");
        }
#endif

        break;
    }
    case DumpBuffer:

        ShowStr ("Buffer contents:");

        ShowBytes(
            (dwBigBufSize > 256 ? 256 : dwBigBufSize),
            pBigBuf,
            1
            );

        break;

#if (INTERNAL_VER >= 0x20000)

    case iNewLocationW:
    {
        char szNewLocName[MAX_STRING_PARAM_SIZE] = "NewLocN";
        LINEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { "lpszNewLocName", PT_STRING,  (ULONG_PTR) szNewLocName, szNewLocName}
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        MakeWideString ((LPVOID) szNewLocName);

        lResult = internalNewLocationW(
            (WCHAR *) params[0].dwValue
            );

        break;
    }

#endif

    default:

        ErrorAlert();
        break;
    }
}

#pragma warning (default:4113)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\ui.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    ui.c

Abstract:

    Contains UI support for TAPI Browser util.

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


#include "tb.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <malloc.h>
#include <time.h>
#include <commdlg.h>
#include "resource.h"
#include "vars.h"


extern char szdwSize[];
extern char szdwAddressID[];


HWND    hwndEdit2;
HFONT   ghFixedFont;
char    gszEnterAs[32];

BYTE aHex[] =
{
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,
    255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
};

char *
PASCAL
GetTimeStamp(
    void
    );

void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    );

void
CompletionPortThread(
    LPVOID  pParams
    );


int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{
    MSG     msg;
    HWND    hwnd;
    HACCEL  hAccel;

    {
        DWORD d = 0x76543210;


        wsprintf(
            gszEnterAs,
            "Ex: enter x%x as %02x%02x%02x%02x",
            d,
            *((LPBYTE) &d),
            *(((LPBYTE) &d) + 1),
            *(((LPBYTE) &d) + 2),
            *(((LPBYTE) &d) + 3)
            );
    }

    ghInst = hInstance;

    hwnd = CreateDialog(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG1),
        (HWND)NULL,
        (DLGPROC) MainWndProc
        );

    hwndEdit2 = CreateWindow ("edit", "", 0, 0, 0, 0, 0, NULL, NULL, ghInst, NULL);

    if (!hwndEdit2)
    {
        MessageBox (NULL, "err creating edit ctl", "", MB_OK);
    }

    hAccel = LoadAccelerators(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDR_ACCELERATOR1)
        );

#if TAPI_2_0

    if ((ghCompletionPort = CreateIoCompletionPort(
            INVALID_HANDLE_VALUE,
            NULL,
            0,
            0
            )))
    {
        DWORD   dwTID;
        HANDLE  hThread;


        if ((hThread = CreateThread(
                (LPSECURITY_ATTRIBUTES) NULL,
                0,
                (LPTHREAD_START_ROUTINE) CompletionPortThread,
                NULL,
                0,
                &dwTID
                )))
        {
            CloseHandle (hThread);
        }
        else
        {
            ShowStr(
                "CreateThread(CompletionPortThread) failed, err=%d",
                GetLastError()
                );
        }
    }
    else
    {
        ShowStr ("CreateIoCompletionPort failed, err=%d", GetLastError());
    }

#endif

    ghFixedFont = CreateFont(
        13, 8, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 49, "Courier"
        );

    while (GetMessage (&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator (hwnd, hAccel, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }

    DestroyWindow (hwndEdit2);

    return 0;
}


void
CompletionPortThread(
    LPVOID  pParams
    )
{
    DWORD           dwNumBytesTransfered;
    ULONG_PTR       completionKey;
    LPLINEMESSAGE   pMsg;


    while (GetQueuedCompletionStatus(
                ghCompletionPort,
                &dwNumBytesTransfered,
                &completionKey,
                (LPOVERLAPPED *) &pMsg,
                INFINITE
                ))
    {
        if (pMsg)
        {
            tapiCallback(
                pMsg->hDevice,
                pMsg->dwMessageID,
                pMsg->dwCallbackInstance,
                pMsg->dwParam1,
                pMsg->dwParam2,
                pMsg->dwParam3
                );

            LocalFree (pMsg);
        }
        else
        {
            break;
        }
    }
}


void
GetCurrentSelections(
    void
    )
{
    LRESULT   lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    PMYWIDGET pWidget = aWidgets;


    //
    // Init all pXxxSel ptrs to NULL
    //

    pLineAppSel  = (PMYLINEAPP) NULL;
    pLineSel     = (PMYLINE) NULL;
    pCallSel     =
    pCallSel2    = (PMYCALL) NULL;
    pPhoneAppSel = (PMYPHONEAPP) NULL;
    pPhoneSel    = (PMYPHONE) NULL;


    if (lSel != LB_ERR)
    {
        //
        // Find the selected widget & set globals appropriately
        //

        pWidget = (PMYWIDGET) SendMessage(
            ghwndList1,
            LB_GETITEMDATA,
            (WPARAM) lSel,
            0
            );

        switch (pWidget->dwType)
        {
        case WT_LINEAPP:

            pLineAppSel = (PMYLINEAPP) pWidget;
            break;

        case WT_LINE:

            pLineSel    = (PMYLINE) pWidget;
            pLineAppSel = pLineSel->pLineApp;
            break;

        case WT_CALL:

            pCallSel    = (PMYCALL) pWidget;
            pLineSel    = pCallSel->pLine;
            pLineAppSel = pCallSel->pLine->pLineApp;

            if (pWidget->pNext && (pWidget->pNext->dwType == WT_CALL))
            {
                pCallSel2 = (PMYCALL) pWidget->pNext;
            }
            else if ((((PMYWIDGET)pLineSel)->pNext != pWidget) &&
                     (((PMYWIDGET)pLineSel)->pNext->dwType == WT_CALL))
            {
                pCallSel2 =  (PMYCALL) (((PMYWIDGET)pLineSel)->pNext);
            }

            break;

        case WT_PHONEAPP:

            pPhoneAppSel = (PMYPHONEAPP) pWidget;
            break;

        case WT_PHONE:

            pPhoneSel    = (PMYPHONE) pWidget;
            pPhoneAppSel = pPhoneSel->pPhoneApp;
            break;
        }
    }


    //
    // The following is an attempt to up the usability level a little bit.
    // Most folks are going to be messing around with 1 lineapp/line/call
    // at a time, and it'd end up being a real PITA for them to have to
    // select a widget each time (and it's fairly obvious which widget
    // are referring to).  So we're going to try to make some intelligent
    // decisions in case they haven't selected a widget... (Obviously this
    // could be cleaned up a bit, like maybe maintaining dwNumXxx as
    // globals rather than walking the list each time.)
    //

    {
        DWORD       dwNumLineApps = 0, dwNumLines = 0, dwNumCalls = 0,
                    dwNumPhoneApps = 0, dwNumPhones = 0;
        PMYPHONEAPP pPhoneApp = NULL;


        pWidget = aWidgets;

        while (pWidget)
        {
            switch (pWidget->dwType)
            {
            case WT_LINEAPP:

                dwNumLineApps++;
                break;

            case WT_LINE:

                dwNumLines++;
                break;

            case WT_CALL:

                dwNumCalls++;
                break;

            case WT_PHONEAPP:

                dwNumPhoneApps++;

                if (dwNumPhoneApps == 1)
                {
                    pPhoneApp = (PMYPHONEAPP) pWidget;
                }

                break;

            case WT_PHONE:

                dwNumPhones++;
                break;
            }

            pWidget = pWidget->pNext;
        }

        if (dwNumLineApps == 1)
        {
            pLineAppSel = (PMYLINEAPP) aWidgets;

            if (dwNumLines == 1)
            {
                pLineSel = (PMYLINE) pLineAppSel->Widget.pNext;

                if (dwNumCalls == 1)
                {
                    pCallSel = (PMYCALL) pLineSel->Widget.pNext;
                }
            }
        }

        if (dwNumPhoneApps == 1)
        {
            pPhoneAppSel = (PMYPHONEAPP) pPhoneApp;

            if (dwNumPhones == 1)
            {
                pPhoneSel = (PMYPHONE) pPhoneAppSel->Widget.pNext;
            }
        }
    }
}

/* help
VOID
MyWinHelp(
    HWND  hwndOwner,
    BOOL  bTapiHlp,
    UINT  uiCommand,
    DWORD dwData
    )
{
    char *lpszHelpFile = (bTapiHlp ? szTapiHlp : szTspiHlp);


    if (lpszHelpFile[0] == 0 || _access (lpszHelpFile, 0))
    {
        //
        // Prompt user for helpfile path
        //

        OPENFILENAME ofn;
        char szDirName[256] = ".\\";
        char szFile[256] = "tapi.hlp\0";
        char szFileTitle[256] = "";
        char szFilter[] = "Telephony API Help\0tapi.hlp\0\0";


        if (MessageBox(
                hwndOwner,
                "Help file not found- do you want to specify a new help file?",
                "Warning",
                MB_YESNO
                ) == IDNO)
        {
            return;
        }

        if (!bTapiHlp)
        {
            szFile[1] = 's';
            szFilter[10] = 'S';
            szFilter[20] = 's';
        }

        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = hwndOwner;
        ofn.lpstrFilter       = szFilter;
        ofn.lpstrCustomFilter = (LPSTR) NULL;
        ofn.nMaxCustFilter    = 0L;
        ofn.nFilterIndex      = 1;
        ofn.lpstrFile         = szFile;
        ofn.nMaxFile          = sizeof(szFile);
        ofn.lpstrFileTitle    = szFileTitle;
        ofn.nMaxFileTitle     = sizeof(szFileTitle);
        ofn.lpstrInitialDir   = szDirName;
        ofn.lpstrTitle        = (LPSTR) NULL;
        ofn.Flags             = 0L;
        ofn.nFileOffset       = 0;
        ofn.nFileExtension    = 0;
        ofn.lpstrDefExt       = "HLP";

        if (!GetOpenFileName(&ofn))
        {
            return;
        }

        strcpy (lpszHelpFile, szFile);
    }

    if (!WinHelp (ghwndMain, (LPCSTR) lpszHelpFile, uiCommand, dwData))
    {
        lpszHelpFile[0] = 0;
    }
}
*/

INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HICON  hIcon;
    static HMENU  hMenu;
    static int    icyButton, icyBorder;
    static HFONT  hFont, hFont2;

    int  i;

    static LONG cxList1, cxList2, cxWnd, xCapture, cxVScroll, lCaptureFlags = 0;
    static int cyWnd;

    typedef struct _XXX
    {
        DWORD   dwMenuID;

        DWORD   dwFlags;

    } XXX, *PXXX;

    static XXX aXxx[] =
    {
        { IDM_LOGSTRUCTDWORD        ,DS_BYTEDUMP },
        { IDM_LOGSTRUCTALLFIELD     ,DS_NONZEROFIELDS|DS_ZEROFIELDS },
        { IDM_LOGSTRUCTNONZEROFIELD ,DS_NONZEROFIELDS },
        { IDM_LOGSTRUCTNONE         ,0 }
    };

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        RECT rect;
        char buf[64];


        ghwndMain  = hwnd;
        ghwndList1 = GetDlgItem (hwnd, IDC_LIST1);
        ghwndList2 = GetDlgItem (hwnd, IDC_LIST2);
        ghwndEdit  = GetDlgItem (hwnd, IDC_EDIT1);
        hMenu      = GetMenu (hwnd);
        hIcon      = LoadIcon (ghInst, MAKEINTRESOURCE(IDI_ICON1));

        icyBorder = GetSystemMetrics (SM_CYFRAME);
        cxVScroll = 2*GetSystemMetrics (SM_CXVSCROLL);

        GetWindowRect (GetDlgItem (hwnd, IDC_BUTTON1), &rect);
        icyButton = (rect.bottom - rect.top) + icyBorder + 3;

        for (i = 0; aFuncNames[i]; i++)
        {
            SendMessage(
                ghwndList2,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) aFuncNames[i]
                );
        }

        SendMessage (ghwndList2, LB_SETCURSEL, (WPARAM) lInitialize, 0);


#ifdef WIN32
        SetWindowText (hwnd, "TAPI32 Browser");
#else
        SetWindowText (hwnd, "TAPI16 Browser");
#endif

        //
        // Read in defaults from ini file
        //

        {
            typedef struct _DEF_VALUE
            {
                char far *lpszEntry;
                char far *lpszDefValue;
                LPVOID   lp;

            } DEF_VALUE;

            DEF_VALUE aDefVals[] =
            {
                { "BufSize",            "1000", &dwBigBufSize },
                { "AddressID",          "0", &dwDefAddressID },
#if TAPI_2_0
                { "20LineAPIVersion",   "20000", &dwDefLineAPIVersion },
#else
#if TAPI_1_1
                { "14LineAPIVersion",   "10004", &dwDefLineAPIVersion },
#else
                { "13LineAPIVersion",   "10003", &dwDefLineAPIVersion },
#endif
#endif
                { "BearerMode",         "1", &dwDefBearerMode },
                { "CountryCode",        "0", &dwDefCountryCode },
                { "LineDeviceID",       "0", &dwDefLineDeviceID },
                { "LineExtVersion",     "0", &dwDefLineExtVersion },
                { "MediaMode",         "10", &dwDefMediaMode },        // DATAMODEM
                { "LinePrivilege",      "1", &dwDefLinePrivilege },    // NONE (dialout only)
#if TAPI_2_0
                { "20PhoneAPIVersion",  "20000", &dwDefPhoneAPIVersion },
#else
#if TAPI_1_1
                { "14PhoneAPIVersion",  "10004", &dwDefPhoneAPIVersion },
#else
                { "13PhoneAPIVersion",  "10003", &dwDefPhoneAPIVersion },
#endif
#endif
                { "PhoneDeviceID",      "0", &dwDefPhoneDeviceID },
                { "PhoneExtVersion",    "0", &dwDefPhoneExtVersion },
                { "PhonePrivilege",     "2", &dwDefPhonePrivilege },   // OWNER
#if TAPI_2_0
                { "20UserButton1",      "500", aUserButtonFuncs },
                { "20UserButton2",      "500", aUserButtonFuncs + 1 },
                { "20UserButton3",      "500", aUserButtonFuncs + 2 },
                { "20UserButton4",      "500", aUserButtonFuncs + 3 },
                { "20UserButton5",      "500", aUserButtonFuncs + 4 },
                { "20UserButton6",      "500", aUserButtonFuncs + 5 },
#else
#if TAPI_1_1
                { "14UserButton1",      "500", aUserButtonFuncs },
                { "14UserButton2",      "500", aUserButtonFuncs + 1 },
                { "14UserButton3",      "500", aUserButtonFuncs + 2 },
                { "14UserButton4",      "500", aUserButtonFuncs + 3 },
                { "14UserButton5",      "500", aUserButtonFuncs + 4 },
                { "14UserButton6",      "500", aUserButtonFuncs + 5 },
#else
                { "13UserButton1",      "500", aUserButtonFuncs },
                { "13UserButton2",      "500", aUserButtonFuncs + 1 },
                { "13UserButton3",      "500", aUserButtonFuncs + 2 },
                { "13UserButton4",      "500", aUserButtonFuncs + 3 },
                { "13UserButton5",      "500", aUserButtonFuncs + 4 },
                { "13UserButton6",      "500", aUserButtonFuncs + 5 },
#endif
#endif
                { "TimeStamp",          "0", &bTimeStamp },
                { "NukeIdleMonitorCalls",   "1", &bNukeIdleMonitorCalls },
                { "NukeIdleOwnedCalls",     "0", &bNukeIdleOwnedCalls },
                { "DisableHandleChecking", "0", &gbDisableHandleChecking },
                { "DumpStructsFlags",   "1",   &dwDumpStructsFlags },
                { NULL, NULL, NULL },
                { "UserUserInfo",       "my user user info", szDefUserUserInfo },
                { "DestAddress",        "55555", szDefDestAddress },
                { "LineDeviceClass",    "tapi/line", szDefLineDeviceClass },
                { "PhoneDeviceClass",   "tapi/phone", szDefPhoneDeviceClass },
                { "AppName",            "Tapi Browser", szDefAppName },
                { NULL, NULL, NULL },
#if TAPI_2_0
                { "20UserButton1Text",  "", &aUserButtonsText[0] },
                { "20UserButton2Text",  "", &aUserButtonsText[1] },
                { "20UserButton3Text",  "", &aUserButtonsText[2] },
                { "20UserButton4Text",  "", &aUserButtonsText[3] },
                { "20UserButton5Text",  "", &aUserButtonsText[4] },
                { "20UserButton6Text",  "", &aUserButtonsText[5] },
#else
#if TAPI_1_1
                { "14UserButton1Text",  "", &aUserButtonsText[0] },
                { "14UserButton2Text",  "", &aUserButtonsText[1] },
                { "14UserButton3Text",  "", &aUserButtonsText[2] },
                { "14UserButton4Text",  "", &aUserButtonsText[3] },
                { "14UserButton5Text",  "", &aUserButtonsText[4] },
                { "14UserButton6Text",  "", &aUserButtonsText[5] },
#else
                { "13UserButton1Text",  "", &aUserButtonsText[0] },
                { "13UserButton2Text",  "", &aUserButtonsText[1] },
                { "13UserButton3Text",  "", &aUserButtonsText[2] },
                { "13UserButton4Text",  "", &aUserButtonsText[3] },
                { "13UserButton5Text",  "", &aUserButtonsText[4] },
                { "13UserButton6Text",  "", &aUserButtonsText[5] },
#endif
#endif
                { NULL, NULL, NULL }
            };

            int i, j;

            #define MYSECTION "Tapi Browser"


            for (i = 0; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    buf,
                    15
                    );

                sscanf (buf, "%lx", aDefVals[i].lp);
            }

            i++;

            for (; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    (LPSTR) aDefVals[i].lp,
                    MAX_STRING_PARAM_SIZE - 1
                    );
            }

            i++;

            for (j = i; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    (LPSTR) aDefVals[i].lp,
                    MAX_USER_BUTTON_TEXT_SIZE - 1
                    );

                SetDlgItemText(
                    hwnd,
                    IDC_BUTTON13 + (i - j),
                    (LPCSTR)aDefVals[i].lp
                    );
            }

            lpszDefAppName          = szDefAppName;
            lpszDefUserUserInfo     = szDefUserUserInfo;
            lpszDefDestAddress      = szDefDestAddress;
            lpszDefLineDeviceClass  = szDefLineDeviceClass;
            lpszDefPhoneDeviceClass = szDefPhoneDeviceClass;

            if (GetProfileString (
                    MYSECTION,
                    "Version",
                    "",
                    buf,
                    15
                    ) == 0 || (strcmp (buf, szCurrVer)))
            {
                //
                // If here assume this is first time user had started
                // TB, so post a msg that will automatically bring up
                // the hlp dlg
                //

                PostMessage (hwnd, WM_COMMAND, IDM_USINGTB, 0);
            }

// help            GetProfileString (MYSECTION, "TapiHlpPath", "", szTapiHlp, 256);
// help            GetProfileString (MYSECTION, "TspiHlpPath", "", szTspiHlp, 256);
        }

        pBigBuf = malloc ((size_t)dwBigBufSize);

        {
            //HFONT hFontMenu = SendMessage (hMenu, WM_GETFONT, 0, 0);

            hFont = CreateFont(
                13, 5, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 34, "MS Sans Serif"
                );
            hFont2 = CreateFont(
                13, 8, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 49, "Courier"
                );

            for (i = 0; i < 18; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_BUTTON1 + i,
                    WM_SETFONT,
                    (WPARAM) hFont,
                    0
                    );
            }

            SendMessage (ghwndList1, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndList2, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndEdit, WM_SETFONT, (WPARAM) hFont2, 0);
        }

        GetProfileString(
            MYSECTION,
            "ControlRatios",
            "20, 20, 100",
            buf,
            63
            );

        sscanf (buf, "%ld,%ld,%ld", &cxList2, &cxList1, &cxWnd);

        GetProfileString(
            MYSECTION,
            "Position",
            "max",
            buf,
            63
            );

        if (strcmp (buf, "max") == 0)
        {
            ShowWindow (hwnd, SW_SHOWMAXIMIZED);
        }
        else
        {
            int left = 100, top = 100, right = 600, bottom = 400;


            sscanf (buf, "%d,%d,%d,%d", &left, &top, &right, &bottom);


            //
            // Check to see if wnd pos is wacky, if so reset to reasonable vals
            //

            if (left < 0 ||
                left >= (GetSystemMetrics (SM_CXSCREEN) - 32) ||
                top < 0 ||
                top >= (GetSystemMetrics (SM_CYSCREEN) - 32))
            {
                left = top = 100;
                right = 600;
                bottom = 400;
            }

            SetWindowPos(
                hwnd,
                HWND_TOP,
                left,
                top,
                right - left,
                bottom - top,
                SWP_SHOWWINDOW
                );

            GetClientRect (hwnd, &rect);

            SendMessage(
                hwnd,
                WM_SIZE,
                0,
                MAKELONG((rect.right-rect.left),(rect.bottom-rect.top))
                );

            ShowWindow (hwnd, SW_SHOW);
        }

        for (i = 0; aXxx[i].dwFlags != dwDumpStructsFlags; i++);

        CheckMenuItem (hMenu, aXxx[i].dwMenuID, MF_BYCOMMAND | MF_CHECKED);

        CheckMenuItem(
            hMenu,
            IDM_TIMESTAMP,
            MF_BYCOMMAND | (bTimeStamp ? MF_CHECKED : MF_UNCHECKED)
            );

        CheckMenuItem(
            hMenu,
            IDM_NUKEIDLEMONITORCALLS,
            MF_BYCOMMAND | (bNukeIdleMonitorCalls ? MF_CHECKED : MF_UNCHECKED)
            );

        CheckMenuItem(
            hMenu,
            IDM_NUKEIDLEOWNEDCALLS,
            MF_BYCOMMAND | (bNukeIdleOwnedCalls ? MF_CHECKED : MF_UNCHECKED)
            );

        CheckMenuItem(
            hMenu,
            IDM_NOHANDLECHK,
            MF_BYCOMMAND | (gbDisableHandleChecking ? MF_CHECKED : MF_UNCHECKED)
            );

        //
        // Alloc & init the global call params
        //

#if TAPI_2_0

        lpCallParamsW = NULL;

init_call_params:

#endif
        {
#if TAPI_2_0
            size_t callParamsSize =
                sizeof(LINECALLPARAMS) + 15 * MAX_STRING_PARAM_SIZE;
#else
            size_t callParamsSize =
                sizeof(LINECALLPARAMS) + 8 * MAX_STRING_PARAM_SIZE;
#endif

            if ((lpCallParams = (LPLINECALLPARAMS) malloc (callParamsSize)))
            {
                LPDWORD lpdwXxxOffset = &lpCallParams->dwOrigAddressOffset;


                memset (lpCallParams, 0, callParamsSize);

                lpCallParams->dwTotalSize   = (DWORD) callParamsSize;
                lpCallParams->dwBearerMode  = LINEBEARERMODE_VOICE;
                lpCallParams->dwMinRate     = 3100;
                lpCallParams->dwMaxRate     = 3100;
                lpCallParams->dwMediaMode   = LINEMEDIAMODE_INTERACTIVEVOICE;
                lpCallParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;

                for (i = 0; i < 8; i++)
                {
                    *(lpdwXxxOffset + 2*i) =
                        sizeof(LINECALLPARAMS) + i*MAX_STRING_PARAM_SIZE;
                }
#if TAPI_2_0
                {
                    LPDWORD pdwProxyRequests = (LPDWORD)
                                (((LPBYTE) lpCallParams) +
                                lpCallParams->dwDevSpecificOffset);


                    for (i = 0; i < 8; i++)
                    {
                        *(pdwProxyRequests + i) = i +
                            LINEPROXYREQUEST_SETAGENTGROUP;
                    }
                }

                lpdwXxxOffset = &lpCallParams->dwTargetAddressOffset;

                for (i = 0; i < 6; i++)
                {
                    *(lpdwXxxOffset + 2 * i) =
                        sizeof(LINECALLPARAMS) + (8+i)*MAX_STRING_PARAM_SIZE;
                }

                lpCallParams->dwCallingPartyIDOffset    =
                    sizeof(LINECALLPARAMS) + 14 * MAX_STRING_PARAM_SIZE;

                if (!lpCallParamsW)
                {
                    lpCallParamsW = lpCallParams;
                    goto init_call_params;
                }
#endif
            }
            else
            {
                // BUGBUG
            }
        }

        break;
    }
    case WM_COMMAND:
    {
        FUNC_INDEX funcIndex;
        BOOL bShowParamsSave = bShowParams;

        switch (LOWORD(wParam))
        {
        case IDC_EDIT1:

#ifdef WIN32
            if (HIWORD(wParam) == EN_CHANGE)
#else
            if (HIWORD(lParam) == EN_CHANGE)
#endif
            {
                //
                // Watch to see if the edit control is full, & if so
                // purge the top half of the text to make room for more
                //

                int length = GetWindowTextLength (ghwndEdit);


                if (length > 29998)
                {
#ifdef WIN32
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM) 0,
                        (LPARAM) 10000
                        );
#else
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM) 1,
                        (LPARAM) MAKELONG (0, 10000)
                        );
#endif

                    SendMessage(
                        ghwndEdit,
                        EM_REPLACESEL,
                        0,
                        (LPARAM) (char far *) ""
                        );

#ifdef WIN32
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)0xfffffffd,
                        (LPARAM)0xfffffffe
                        );
#else
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)1,
                        (LPARAM) MAKELONG (0xfffd, 0xfffe)
                        );
#endif
                }
            }
            break;

        case IDC_BUTTON1:

            funcIndex = lInitialize;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON2:

            funcIndex = lShutdown;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON3:

            funcIndex = lOpen;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON4:

            funcIndex = lClose;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON5:

            funcIndex = lMakeCall;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON6:

            GetCurrentSelections();

            if (pCallSel && (pCallSel->dwCallState == LINECALLSTATE_IDLE))
            {
                funcIndex = lDeallocateCall;
            }
            else
            {
                funcIndex = lDrop;
                gbDeallocateCall = TRUE;
            }

            FuncDriver (funcIndex);
            gbDeallocateCall = FALSE;
            break;

        case IDC_BUTTON7:

            funcIndex = pInitialize;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON8:

            funcIndex = pShutdown;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON9:

            funcIndex = pOpen;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON10:

            funcIndex = pClose;

IDC_BUTTON10_callFuncDriver:

            //
            // Want to make the "hot buttons" as simple as possible, so
            // turn off the show params flag, then call FuncDriver, and
            // finally restore the flag
            //

            GetCurrentSelections ();
            FuncDriver (funcIndex);
            break;

        case IDC_BUTTON11:
        case IDM_CLEAR:

            SetWindowText (ghwndEdit, "");
            break;


        case IDM_PARAMS:
        case IDC_BUTTON12:

            bShowParams = (bShowParams ? FALSE : TRUE);

            if (bShowParams)
            {
                CheckMenuItem(
                    hMenu,
                    IDM_PARAMS,
                    MF_BYCOMMAND | MF_CHECKED
                    );

                CheckDlgButton (hwnd, IDC_BUTTON12, 1);
            }
            else
            {
                CheckMenuItem(
                    hMenu,
                    IDM_PARAMS,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );

                CheckDlgButton (hwnd, IDC_BUTTON12, 0);
            }

            break;

        case IDC_BUTTON13:
        case IDC_BUTTON14:
        case IDC_BUTTON15:
        case IDC_BUTTON16:
        case IDC_BUTTON17:
        case IDC_BUTTON18:
        {
            DWORD i = (DWORD) (LOWORD(wParam)) - IDC_BUTTON13;


            if (aUserButtonFuncs[i] >= MiscBegin)
            {
                //
                // Hot button func id is bogus, so bring
                // up hot button init dlg
                //

                DialogBoxParam(
                    ghInst,
                    (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                    (HWND) hwnd,
                    (DLGPROC) UserButtonsDlgProc,
                    (LPARAM) &i
                    );
            }
            else
            {
                //
                // Invoke the user button's corresponding func
                //

                GetCurrentSelections ();
                FuncDriver ((FUNC_INDEX) aUserButtonFuncs[i]);
            }

            break;
        }
/* help        case IDC_F1HELP:

            if ((GetFocus() == ghwndEdit) &&
                SendMessage (ghwndEdit, EM_GETSEL, 0, 0))
            {
                //
                // Display help for the selected text in the edit ctrl
                //

                char buf[32];


                //
                // Copy the selected text in the edit ctrl to our
                // temp edit control, then query the temp edit ctrl's
                // text (this seems to be the easiest way to get the
                // selected text)
                //

                SendMessage (ghwndEdit, WM_COPY, 0, 0);
                SetWindowText (hwndEdit2, "");
                SendMessage (hwndEdit2, WM_PASTE, 0, 0);


                //
                // In the interest of getting an exact match on a
                // helpfile key strip off any trailing spaces
                //

                GetWindowText (hwndEdit2, buf, 32);
                buf[31] = 0;
                for (i = 0; i < 32; i++)
                {
                    if (buf[i] == ' ')
                    {
                        buf[i] = 0;
                        break;
                    }
                }

                MyWinHelp (hwnd, TRUE, HELP_PARTIALKEY, buf);
            }
            else
            {
                //
                // Display help for the currently selected func
                //

                FUNC_INDEX funcIndex = (FUNC_INDEX)
                    SendMessage (ghwndList2, LB_GETCURSEL, 0, 0);


                MyWinHelp (hwnd, TRUE, HELP_PARTIALKEY, aFuncNames[funcIndex]);
            }

            break;
*/
        case IDC_PREVCTRL:
        {
            HWND hwndPrev = GetNextWindow (GetFocus (), GW_HWNDPREV);

            if (!hwndPrev)
            {
                hwndPrev = ghwndList2;
            }

            SetFocus (hwndPrev);
            break;
        }
        case IDC_NEXTCTRL:
        {
            HWND hwndNext = GetNextWindow (GetFocus (), GW_HWNDNEXT);

            if (!hwndNext)
            {
                hwndNext = GetDlgItem (hwnd, IDC_BUTTON12);
            }

            SetFocus (hwndNext);
            break;
        }
        case IDC_ENTER:
        {
            if (GetFocus() != ghwndEdit)
            {
                GetCurrentSelections ();
                FuncDriver(
                    (FUNC_INDEX)SendMessage(
                        ghwndList2,
                        LB_GETCURSEL,
                        0,
                        0
                        ));
            }
            else
            {
                // Send the edit ctrl a cr/lf
            }

            break;
        }
        case IDC_LIST1:

#ifdef WIN32
            switch (HIWORD(wParam))
#else
            switch (HIWORD(lParam))
#endif
            {
            case LBN_DBLCLK:
            {
                LRESULT lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
                PMYWIDGET pWidget;


                pWidget = (PMYWIDGET) SendMessage(
                    ghwndList1,
                    LB_GETITEMDATA,
                    (WPARAM) lSel,
                    0
                    );

                if ((pWidget->dwType == WT_LINEAPP)
                    || (pWidget->dwType == WT_PHONEAPP)
                    )
                {
                    break;
                }

                bShowParams = FALSE;

                UpdateResults (TRUE);

                switch (pWidget->dwType)
                {
                case WT_LINE:
                {
                    DWORD dwDefLineDeviceIDSave = dwDefLineDeviceID;
                    PMYLINE pLine = (PMYLINE) pWidget;


                    dwDefLineDeviceID = pLine->dwDevID;

                    pLineAppSel = GetLineApp (pLine->hLineApp);
                    pLineSel = pLine;

                    FuncDriver (lGetDevCaps);
                    FuncDriver (lGetLineDevStatus);

                    dwDefLineDeviceID = dwDefLineDeviceIDSave;
                    break;
                }
                case WT_CALL:
                {
                    PMYCALL pCall = (PMYCALL) pWidget;


                    pCallSel = pCall;
                    pLineSel = pCall->pLine;

                    FuncDriver (lGetCallInfo);
                    FuncDriver (lGetCallStatus);

                    break;
                }
                case WT_PHONE:
                {
                    DWORD dwDefPhoneDeviceIDSave = dwDefPhoneDeviceID;
                    PMYPHONE pPhone = (PMYPHONE) pWidget;


                    dwDefPhoneDeviceID = pPhone->dwDevID;

                    pPhoneAppSel = GetPhoneApp (pPhone->hPhoneApp);
                    pPhoneSel = pPhone;

                    FuncDriver (pGetDevCaps);
                    FuncDriver (pGetStatus);

                    dwDefPhoneDeviceID = dwDefPhoneDeviceIDSave;
                    break;
                }
                }

                UpdateResults (FALSE);

                bShowParams = bShowParamsSave;

                break;
            }
            } // switch

            break;

        case IDC_LIST2:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_DBLCLK)
#else
            if (HIWORD(lParam) == LBN_DBLCLK)
#endif
            {
                GetCurrentSelections ();
                FuncDriver(
                    (FUNC_INDEX)SendMessage(
                        ghwndList2,
                        LB_GETCURSEL,
                        0,
                        0
                        ));
            }

            break;

        case IDM_EXIT:
        {
            PostMessage (hwnd, WM_CLOSE, 0, 0);
            break;
        }
        case IDM_DEFAULTVALUES:
        {
            char szTmpAppName[MAX_STRING_PARAM_SIZE];
            char szTmpUserUserInfo[MAX_STRING_PARAM_SIZE];
            char szTmpDestAddress[MAX_STRING_PARAM_SIZE];
            char szTmpLineDeviceClass[MAX_STRING_PARAM_SIZE];
            char szTmpPhoneDeviceClass[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "Buffer size",            PT_DWORD,  (ULONG_PTR) dwBigBufSize, NULL },
                { "lpszAppName",            PT_STRING, (ULONG_PTR) lpszDefAppName, szTmpAppName },

                { "line: dwAddressID",      PT_DWORD,  (ULONG_PTR) dwDefAddressID, NULL },
                { "line: dwAPIVersion",     PT_ORDINAL,(ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
                { "line: dwBearerMode",     PT_FLAGS,  (ULONG_PTR) dwDefBearerMode, aBearerModes },
                { "line: dwCountryCode",    PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL },
                { "line: dwDeviceID",       PT_DWORD,  (ULONG_PTR) dwDefLineDeviceID, NULL },
                { "line: dwExtVersion",     PT_DWORD,  (ULONG_PTR) dwDefLineExtVersion, NULL },
                { "line: dwMediaMode",      PT_FLAGS,  (ULONG_PTR) dwDefMediaMode, aMediaModes },
                { "line: dwPrivileges",     PT_FLAGS,  (ULONG_PTR) dwDefLinePrivilege, aLineOpenOptions },
                { "line: lpsUserUserInfo",  PT_STRING, (ULONG_PTR) lpszDefUserUserInfo, szTmpUserUserInfo },
                { "line: lpszDestAddress",  PT_STRING, (ULONG_PTR) lpszDefDestAddress, szTmpDestAddress },
                { "line: lpszDeviceClass",  PT_STRING, (ULONG_PTR) lpszDefLineDeviceClass, szTmpLineDeviceClass },
                { "phone: dwAPIVersion",    PT_ORDINAL,(ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
                { "phone: dwDeviceID",      PT_DWORD,  (ULONG_PTR) dwDefPhoneDeviceID, NULL },
                { "phone: dwExtVersion",    PT_DWORD,  (ULONG_PTR) dwDefPhoneExtVersion, NULL },
                { "phone: dwPrivilege",     PT_FLAGS,  (ULONG_PTR) dwDefPhonePrivilege, aPhonePrivileges },
                { "phone: lpszDeviceClass", PT_STRING, (ULONG_PTR) lpszDefPhoneDeviceClass, szTmpPhoneDeviceClass }
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 18, DefValues, params, NULL };
            BOOL bShowParamsSave = bShowParams;

            bShowParams = TRUE;

            strcpy (szTmpAppName, szDefAppName);
            strcpy (szTmpUserUserInfo, szDefUserUserInfo);
            strcpy (szTmpDestAddress, szDefDestAddress);
            strcpy (szTmpLineDeviceClass, szDefLineDeviceClass);
            strcpy (szTmpPhoneDeviceClass, szDefPhoneDeviceClass);

            if (LetUserMungeParams (&paramsHeader))
            {
                if (params[0].dwValue != dwBigBufSize)
                {
                    LPVOID pTmpBigBuf = malloc ((size_t) params[0].dwValue);

                    if (pTmpBigBuf)
                    {
                        free (pBigBuf);
                        pBigBuf = pTmpBigBuf;
                        dwBigBufSize = (DWORD) params[0].dwValue;
                    }
                }

                strcpy (szDefAppName, szTmpAppName);

                dwDefAddressID      = (DWORD) params[2].dwValue;
                dwDefLineAPIVersion = (DWORD) params[3].dwValue;
                dwDefBearerMode     = (DWORD) params[4].dwValue;
                dwDefCountryCode    = (DWORD) params[5].dwValue;
                dwDefLineDeviceID   = (DWORD) params[6].dwValue;
                dwDefLineExtVersion = (DWORD) params[7].dwValue;
                dwDefMediaMode      = (DWORD) params[8].dwValue;
                dwDefLinePrivilege  = (DWORD) params[9].dwValue;

                strcpy (szDefUserUserInfo, szTmpUserUserInfo);
                strcpy (szDefDestAddress, szTmpDestAddress);
                strcpy (szDefLineDeviceClass, szTmpLineDeviceClass);

                dwDefPhoneAPIVersion = (DWORD) params[13].dwValue;
                dwDefPhoneDeviceID   = (DWORD) params[14].dwValue;
                dwDefPhoneExtVersion = (DWORD) params[15].dwValue;
                dwDefPhonePrivilege  = (DWORD) params[16].dwValue;

                strcpy (szDefPhoneDeviceClass, szTmpPhoneDeviceClass);

                if (params[1].dwValue && (params[1].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefAppName = szDefAppName;
                }
                else
                {
                    lpszDefAppName = (char far *) params[1].dwValue;
                }

                if (params[10].dwValue &&
                    (params[10].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefUserUserInfo = szDefUserUserInfo;
                }
                else
                {
                    lpszDefUserUserInfo = (char far *) params[10].dwValue;
                }

                if (params[11].dwValue &&
                    (params[11].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefDestAddress = szDefDestAddress;
                }
                else
                {
                    lpszDefDestAddress = (char far *) params[11].dwValue;
                }

                if (params[12].dwValue &&
                    (params[12].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefLineDeviceClass  = szDefLineDeviceClass;
                }
                else
                {
                    lpszDefLineDeviceClass  = (char far *) params[12].dwValue;
                }

                if (params[17].dwValue &&
                    (params[17].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefPhoneDeviceClass = szDefPhoneDeviceClass;
                }
                else
                {
                    lpszDefPhoneDeviceClass = (char far *) params[17].dwValue;
                }
            }

            bShowParams = bShowParamsSave;

            break;
        }
        case IDM_USERBUTTONS:

            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                (HWND) hwnd,
                (DLGPROC) UserButtonsDlgProc,
                (LPARAM) NULL
                );

            break;

        case IDM_DUMPPARAMS:

            bDumpParams = (bDumpParams ? FALSE : TRUE);

            CheckMenuItem(
                hMenu,
                IDM_DUMPPARAMS,
                MF_BYCOMMAND | (bDumpParams ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_LOGSTRUCTDWORD:
        case IDM_LOGSTRUCTALLFIELD:
        case IDM_LOGSTRUCTNONZEROFIELD:
        case IDM_LOGSTRUCTNONE:

            for (i = 0; aXxx[i].dwFlags != dwDumpStructsFlags; i++);

            CheckMenuItem(
                hMenu,
                aXxx[i].dwMenuID,
                MF_BYCOMMAND | MF_UNCHECKED
                );

            for (i = 0; aXxx[i].dwMenuID != LOWORD(wParam); i++);

            CheckMenuItem(
                hMenu,
                aXxx[i].dwMenuID,
                MF_BYCOMMAND | MF_CHECKED
                );

            dwDumpStructsFlags = aXxx[i].dwFlags;

            break;

        case IDM_TIMESTAMP:

            bTimeStamp = (bTimeStamp ? FALSE : TRUE);

            CheckMenuItem(
                hMenu,
                IDM_TIMESTAMP,
                MF_BYCOMMAND | (bTimeStamp ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_LOGFILE:
        {
            if (hLogFile)
            {
                fclose (hLogFile);
                hLogFile = (FILE *) NULL;
                CheckMenuItem(
                    hMenu,
                    IDM_LOGFILE,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );
            }
            else
            {
                OPENFILENAME ofn;
                char szDirName[256] = ".\\";
                char szFile[256] = "tb.log\0";
                char szFileTitle[256] = "";
                static char *szFilter =
                    "Log files (*.log)\0*.log\0All files (*.*)\0*.*\0\0";


                ofn.lStructSize       = sizeof(OPENFILENAME);
                ofn.hwndOwner         = hwnd;
                ofn.lpstrFilter       = szFilter;
                ofn.lpstrCustomFilter = (LPSTR) NULL;
                ofn.nMaxCustFilter    = 0L;
                ofn.nFilterIndex      = 1;
                ofn.lpstrFile         = szFile;
                ofn.nMaxFile          = sizeof(szFile);
                ofn.lpstrFileTitle    = szFileTitle;
                ofn.nMaxFileTitle     = sizeof(szFileTitle);
                ofn.lpstrInitialDir   = szDirName;
                ofn.lpstrTitle        = (LPSTR) NULL;
                ofn.Flags             = 0L;
                ofn.nFileOffset       = 0;
                ofn.nFileExtension    = 0;
                ofn.lpstrDefExt       = "LOG";

                if (!GetOpenFileName(&ofn))
                {
                    return 0L;
                }

                if ((hLogFile = fopen (szFile, "at")) == (FILE *) NULL)
                {
                    MessageBox(
                        hwnd,
                        "Error creating log file",
#ifdef WIN32
                        "TB32.EXE",
#else
                        "TB.EXE",
#endif
                        MB_OK
                        );
                }
                else
                {
                    struct tm *newtime;
                    time_t aclock;


                    time (&aclock);
                    newtime = localtime (&aclock);
                    fprintf(
                        hLogFile,
                        "\n---Log opened: %s\n",
                        asctime (newtime)
                        );

                    CheckMenuItem(
                        hMenu,
                        IDM_LOGFILE,
                        MF_BYCOMMAND | MF_CHECKED
                        );
                }
            }
            break;
        }
        case IDM_USINGTB:
        {
            static char szUsingTB[] =

                "ABSTRACT:\r\n"                                         \
                "    TB (TAPI Browser) is an application that\r\n"      \
                "allows a user to interactively call into the\r\n"      \
                "Windows Telephony interface and inspect all\r\n"       \
                "returned information. The following versions\r\n"      \
                "of TB are available:\r\n\r\n"                          \
                "    TB13.EXE: 16-bit app, TAPI v1.0\r\n"               \
                "    TB14.EXE: 32-bit app, <= TAPI v1.4\r\n"            \
                "    TB20.EXE: 32-bit app, <= TAPI v2.0\r\n"            \

                "\r\n"                                                  \
                "GETTING STARTED:\r\n"                                  \
                "1. Press the 'LAp+' button to initialize TAPI \r\n"    \
                "2. Press the 'Line+' button to open a line device\r\n" \
                "3. Press the 'Call+' button to make a call\r\n"        \
                "*  Pressing the 'LAp-' button will shutdown TAPI\r\n"  \

                "\r\n"                                                  \
                "MORE INFO:\r\n"                                        \
                "*  Double-clicking on one of the items in the\r\n"     \
                "functions listbox (far left) will invoke that \r\n"    \
                "function. Check the 'Params' checkbox to enable\r\n"   \
                "parameter modification.\r\n"                           \
                "*  Choose 'Options/Default values...' to modify\r\n"   \
                "default parameter values (address,device ID, etc).\r\n"\
                "*  Choose 'Options/Record log file' to save all\r\n"   \
                "output to a file.\r\n"                                 \
                "*  All parameter values in hexadecimal unless\r\n"     \
                "specified (strings displayed by contents, not \r\n"    \
                "pointer value).\r\n"                                   \
                "*  All 'Xxx+' and 'Xxx-' buttons are essentially \r\n" \
                "hot-links to items in the functions listbox.\r\n"      \
                "*  Choose 'Options/User buttons...' or press\r\n"      \
                "one of the buttons on right side of toolbar to\r\n"    \
                "create a personal hot-link between a button and a\r\n" \
                "particular function.\r\n"                              \

                "\r\n"                                                  \
                "  *  Note: Selecting a API version parameter value\r\n"\
                "which is newer than that for which TB application\r\n" \
                "is targeted will result in erroneous dumps of some\r\n"\
                "structures (e.g. specifying an API version of\r\n"     \
                "0x10004 and calling lineGetTranslateCaps in TB13).\r\n";

            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG6),
                (HWND)hwnd,
                (DLGPROC) AboutDlgProc,
                (LPARAM) szUsingTB
                );

            break;
        }
// help        case IDM_TAPIHLP:
// help
// help            MyWinHelp (hwnd, TRUE, HELP_CONTENTS, 0);
// help            break;

// help        case IDM_TSPIHLP:
// help
// help            MyWinHelp (hwnd, FALSE, HELP_CONTENTS, 0);
// help            break;

        case IDM_NUKEIDLEMONITORCALLS:

            bNukeIdleMonitorCalls = (bNukeIdleMonitorCalls ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NUKEIDLEMONITORCALLS,
                MF_BYCOMMAND |
                    (bNukeIdleMonitorCalls ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_NUKEIDLEOWNEDCALLS:

            bNukeIdleOwnedCalls = (bNukeIdleOwnedCalls ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NUKEIDLEOWNEDCALLS,
                MF_BYCOMMAND |
                    (bNukeIdleOwnedCalls ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_NOHANDLECHK:

            gbDisableHandleChecking = (gbDisableHandleChecking ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NOHANDLECHK,
                MF_BYCOMMAND |
                    (gbDisableHandleChecking ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_ABOUT:
        {
            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG4),
                (HWND)hwnd,
                (DLGPROC) AboutDlgProc,
                0
                );

            break;
        }
        } // switch

        break;
    }
#ifdef WIN32
    case WM_CTLCOLORBTN:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_BTN)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif

    case WM_MOUSEMOVE:
    {
        LONG x = (LONG)((short)LOWORD(lParam));
        int y = (int)((short)HIWORD(lParam));


        if ((y > icyButton) || lCaptureFlags)
        {
            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE(IDC_SIZEWE)));
        }

        if (lCaptureFlags == 1)
        {
            int cxList2New;


            x = (x > (cxList1 + cxList2 - cxVScroll) ?
                    (cxList1 + cxList2 - cxVScroll) : x);
            x = (x < cxVScroll ? cxVScroll : x);

            cxList2New = (int) (cxList2 + x - xCapture);

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton,
                cxList2New,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                cxList2New + icyBorder,
                icyButton,
                (int) (cxList1 - (x - xCapture)),
                cyWnd,
                SWP_SHOWWINDOW
                );
        }
        else if (lCaptureFlags == 2)
        {
            int cxList1New;


            x = (x < (cxList2 + cxVScroll) ?  (cxList2 + cxVScroll) : x);
            x = (x > (cxWnd - cxVScroll) ?  (cxWnd - cxVScroll) : x);

            cxList1New = (int) (cxList1 + x - xCapture);

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton,
                cxList1New,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) (cxList1New + cxList2) + 2*icyBorder,
                icyButton,
                (int)cxWnd - (cxList1New + (int)cxList2 + 2*icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );
        }

        break;
    }
    case WM_LBUTTONDOWN:
    {
        if ((int)((short)HIWORD(lParam)) > icyButton)
        {
            xCapture = (LONG)LOWORD(lParam);

            SetCapture (hwnd);

            lCaptureFlags = ((xCapture < cxList1 + cxList2) ? 1 : 2);
        }

        break;
    }
    case WM_LBUTTONUP:
    {
        if (lCaptureFlags)
        {
            POINT p;
            LONG  x;
            RECT  rect = { 0, icyButton, 2000, 2000 };

            GetCursorPos (&p);
            MapWindowPoints (HWND_DESKTOP, hwnd, &p, 1);
            x = (LONG) p.x;

            ReleaseCapture();

            if (lCaptureFlags == 1)
            {
                x = (x < cxVScroll ? cxVScroll : x);
                x = (x > (cxList1 + cxList2 - cxVScroll) ?
                    (cxList1 + cxList2 - cxVScroll) : x);

                cxList2 = cxList2 + (x - xCapture);
                cxList1 = cxList1 - (x - xCapture);

                rect.right = (int) (cxList1 + cxList2) + icyBorder;
            }
            else
            {
                x = (x < (cxList2 + cxVScroll) ?
                    (cxList2 + cxVScroll) : x);
                x = (x > (cxWnd - cxVScroll) ?
                    (cxWnd - cxVScroll) : x);

                cxList1 = cxList1 + (x - xCapture);

                rect.left = (int)cxList2 + icyBorder;
            }

            lCaptureFlags = 0;

            InvalidateRect (hwnd, &rect, TRUE);
        }

        break;
    }
    case WM_SIZE:
    {
        if (wParam != SIZE_MINIMIZED)
        {
            LONG width = (LONG)LOWORD(lParam);


            //
            // Adjust globals based on new size
            //

            cxWnd = (cxWnd ? cxWnd : 1); // avoid div by 0

            cxList1 = (cxList1 * width) / cxWnd;
            cxList2 = (cxList2 * width) / cxWnd;
            cxWnd = width;
            cyWnd = ((int)HIWORD(lParam)) - icyButton;


            //
            // Now reposition the child windows
            //

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton,
                (int) cxList2,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton,
                (int) cxList1,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) (cxList1 + cxList2) + 2*icyBorder,
                icyButton,
                (int)width - ((int)(cxList1 + cxList2) + 2*icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );

            InvalidateRect (hwnd, NULL, TRUE);
        }

        break;
    }
    case WM_PAINT:
    {
        PAINTSTRUCT ps;


        BeginPaint (hwnd, &ps);

        if (IsIconic (hwnd))
        {
            DrawIcon (ps.hdc, 0, 0, hIcon);
        }
        else
        {
            FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
#ifdef WIN32
            MoveToEx (ps.hdc, 0, 0, NULL);
#else
            MoveTo (ps.hdc, 0, 0);
#endif
            LineTo (ps.hdc, 5000, 0);

#ifdef WIN32
            MoveToEx (ps.hdc, 0, icyButton - 4, NULL);
#else
            MoveTo (ps.hdc, 0, icyButton - 4);
#endif
            LineTo (ps.hdc, 5000, icyButton - 4);
        }

        EndPaint (hwnd, &ps);

        break;
    }
    case WM_CLOSE:
    {
        BOOL bAutoShutdown = FALSE;
        RECT rect;


        //
        // Save defaults in ini file
        //

        {
            char buf[32];
            typedef struct _DEF_VALUE2
            {
                char far    *lpszEntry;
                ULONG_PTR   dwValue;

            } DEF_VALUE2;

            DEF_VALUE2 aDefVals[] =
            {
                { "BufSize",            dwBigBufSize },
                { "AddressID",          dwDefAddressID },
#if TAPI_2_0
                { "20LineAPIVersion",   dwDefLineAPIVersion },
#else
#if TAPI_1_1
                { "14LineAPIVersion",   dwDefLineAPIVersion },
#else
                { "13LineAPIVersion",   dwDefLineAPIVersion },
#endif
#endif
                { "BearerMode",         dwDefBearerMode },
                { "CountryCode",        dwDefCountryCode },
                { "LineDeviceID",       dwDefLineDeviceID },
                { "LineExtVersion",     dwDefLineExtVersion },
                { "MediaMode",          dwDefMediaMode },
                { "LinePrivilege",      dwDefLinePrivilege },
#if TAPI_2_0
                { "20PhoneAPIVersion",  dwDefPhoneAPIVersion },
#else
#if TAPI_1_1
                { "14PhoneAPIVersion",  dwDefPhoneAPIVersion },
#else
                { "13PhoneAPIVersion",  dwDefPhoneAPIVersion },
#endif
#endif
                { "PhoneDeviceID",      dwDefPhoneDeviceID },
                { "PhoneExtVersion",    dwDefPhoneExtVersion },
                { "PhonePrivilege",     dwDefPhonePrivilege },
#if TAPI_2_0
                { "20UserButton1",      aUserButtonFuncs[0] },
                { "20UserButton2",      aUserButtonFuncs[1] },
                { "20UserButton3",      aUserButtonFuncs[2] },
                { "20UserButton4",      aUserButtonFuncs[3] },
                { "20UserButton5",      aUserButtonFuncs[4] },
                { "20UserButton6",      aUserButtonFuncs[5] },
#else
#if TAPI_1_1
                { "14UserButton1",      aUserButtonFuncs[0] },
                { "14UserButton2",      aUserButtonFuncs[1] },
                { "14UserButton3",      aUserButtonFuncs[2] },
                { "14UserButton4",      aUserButtonFuncs[3] },
                { "14UserButton5",      aUserButtonFuncs[4] },
                { "14UserButton6",      aUserButtonFuncs[5] },
#else
                { "13UserButton1",      aUserButtonFuncs[0] },
                { "13UserButton2",      aUserButtonFuncs[1] },
                { "13UserButton3",      aUserButtonFuncs[2] },
                { "13UserButton4",      aUserButtonFuncs[3] },
                { "13UserButton5",      aUserButtonFuncs[4] },
                { "13UserButton6",      aUserButtonFuncs[5] },
#endif
#endif
                { "TimeStamp",          bTimeStamp },
                { "NukeIdleMonitorCalls",  bNukeIdleMonitorCalls },
                { "NukeIdleOwnedCalls",    bNukeIdleOwnedCalls },
                { "DisableHandleChecking", gbDisableHandleChecking },
                { "DumpStructsFlags",   dwDumpStructsFlags },
                { NULL, 0 },
                { "Version",            (ULONG_PTR) szCurrVer },
                { "UserUserInfo",       (ULONG_PTR) szDefUserUserInfo },
                { "DestAddress",        (ULONG_PTR) szDefDestAddress },
                { "LineDeviceClass",    (ULONG_PTR) szDefLineDeviceClass },
                { "PhoneDeviceClass",   (ULONG_PTR) szDefPhoneDeviceClass },
                { "AppName",            (ULONG_PTR) szDefAppName },
#if TAPI_2_0
                { "20UserButton1Text",  (ULONG_PTR) &aUserButtonsText[0] },
                { "20UserButton2Text",  (ULONG_PTR) &aUserButtonsText[1] },
                { "20UserButton3Text",  (ULONG_PTR) &aUserButtonsText[2] },
                { "20UserButton4Text",  (ULONG_PTR) &aUserButtonsText[3] },
                { "20UserButton5Text",  (ULONG_PTR) &aUserButtonsText[4] },
                { "20UserButton6Text",  (ULONG_PTR) &aUserButtonsText[5] },
#else
#if TAPI_1_1
                { "14UserButton1Text",  (ULONG_PTR) &aUserButtonsText[0] },
                { "14UserButton2Text",  (ULONG_PTR) &aUserButtonsText[1] },
                { "14UserButton3Text",  (ULONG_PTR) &aUserButtonsText[2] },
                { "14UserButton4Text",  (ULONG_PTR) &aUserButtonsText[3] },
                { "14UserButton5Text",  (ULONG_PTR) &aUserButtonsText[4] },
                { "14UserButton6Text",  (ULONG_PTR) &aUserButtonsText[5] },
#else
                { "13UserButton1Text",  (ULONG_PTR) &aUserButtonsText[0] },
                { "13UserButton2Text",  (ULONG_PTR) &aUserButtonsText[1] },
                { "13UserButton3Text",  (ULONG_PTR) &aUserButtonsText[2] },
                { "13UserButton4Text",  (ULONG_PTR) &aUserButtonsText[3] },
                { "13UserButton5Text",  (ULONG_PTR) &aUserButtonsText[4] },
                { "13UserButton6Text",  (ULONG_PTR) &aUserButtonsText[5] },
#endif
#endif
// help                { "TapiHlpPath",        (ULONG_PTR) szTapiHlp },
// help                { "TspiHlpPath",        (ULONG_PTR) szTspiHlp },
                { NULL, 0 }
            };

            int i;

            for (i = 0; aDefVals[i].lpszEntry; i++)
            {
                sprintf (buf, "%lx", aDefVals[i].dwValue);

                WriteProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    buf
                    );
            }

            i++;

            for (; aDefVals[i].lpszEntry; i++)
            {
                WriteProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    (LPCSTR) aDefVals[i].dwValue
                    );
            }


            //
            // Save the window dimensions (if iconic then don't bother)
            //

            if (!IsIconic (hwnd))
            {
                if (IsZoomed (hwnd))
                {
                    strcpy (buf, "max");
                }
                else
                {
                    GetWindowRect (hwnd, &rect);

                    sprintf(
                        buf,
                        "%d,%d,%d,%d",
                        rect.left,
                        rect.top,
                        rect.right,
                        rect.bottom
                        );
                }

                WriteProfileString(
                    MYSECTION,
                    "Position",
                    (LPCSTR) buf
                    );

                sprintf (buf, "%ld,%ld,%ld", cxList2, cxList1, cxWnd);

                WriteProfileString(
                    MYSECTION,
                    "ControlRatios",
                    (LPCSTR) buf
                    );
            }
        }



        //
        // Give user chance to auto-shutdown any active line/phone apps
        //

        if (aWidgets)
        {
            if (MessageBox(
                    hwnd,
                    "Shutdown all hLineApps/hPhoneApps? (recommended)",
                    "Tapi Browser closing",
                    MB_YESNO
                    ) == IDNO)
            {
                goto WM_CLOSE_freeBigBuf;
            }

            bShowParams = FALSE;

            while (aWidgets)
            {
                PMYWIDGET pWidgetToClose = aWidgets;


                if (aWidgets->dwType == WT_LINEAPP)
                {
                    pLineAppSel = (PMYLINEAPP) aWidgets;
                    FuncDriver (lShutdown);
                }
                else if (aWidgets->dwType == WT_PHONEAPP)
                {
                    pPhoneAppSel = (PMYPHONEAPP) aWidgets;
                    FuncDriver (pShutdown);
                }

                if (pWidgetToClose == aWidgets)
                {
                    //
                    // The shutdown wasn't successful (or our list is
                    // messed up an it'd not a LINEAPP or PHONEAPP widget),
                    // so manually nuke this widget so we don't hang in
                    // this loop forever
                    //

                    RemoveWidgetFromList (pWidgetToClose);
                }
            }
        }

WM_CLOSE_freeBigBuf:

        if (hLogFile)
        {
            fclose (hLogFile);
        }
        DestroyIcon (hIcon);
        free (pBigBuf);
        free (lpCallParams);
//        if (aSelWidgets)
//        {
//            free (aSelWidgets);
//        }
//        if (aSelWidgetsPrev)
//        {
//            free (aSelWidgetsPrev);
//        }
        DeleteObject (hFont);
        DeleteObject (hFont2);
        PostQuitMessage (0);
        break;

    }
    } //switch

    return 0;
}


INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:

        if (lParam)
        {
            SetDlgItemText (hwnd, IDC_EDIT1, (LPCSTR) lParam);
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return 0;
}


void
FAR
ShowStr(
    LPCSTR format,
    ...
    )
{
    char buf[256];
    va_list ap;


    va_start(ap, format);
    wvsprintf (buf, format, ap);

    if (hLogFile)
    {
        fprintf (hLogFile, "%s\n", buf);
    }

    strcat (buf, "\r\n");


    //
    // Insert text at end
    //

#ifdef WIN32
    SendMessage (ghwndEdit, EM_SETSEL, (WPARAM)0xfffffffd, (LPARAM)0xfffffffe);
#else
    SendMessage(
        ghwndEdit,
        EM_SETSEL,
        (WPARAM)0,
        (LPARAM) MAKELONG(0xfffd,0xfffe)
        );
#endif

    SendMessage (ghwndEdit, EM_REPLACESEL, 0, (LPARAM) buf);


#ifdef WIN32

    //
    // Scroll to end of text
    //

    SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
#endif

    va_end(ap);
}


VOID
UpdateWidgetListCall(
    PMYCALL pCall
    )
{
    LONG    i;
    char    buf[64];
    LRESULT lSel;


    for (i = 0; aCallStates[i].dwVal != 0xffffffff; i++)
    {
        if (pCall->dwCallState == aCallStates[i].dwVal)
        {
            break;
        }
    }

    sprintf(
        buf,
        "    Call=x%lx %s %s",
        pCall->hCall,
        aCallStates[i].lpszVal,
        (pCall->bMonitor ? "Monitor" : "Owner")
        );

    i = (LONG) GetWidgetIndex ((PMYWIDGET) pCall);

    lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    SendMessage (ghwndList1, LB_DELETESTRING, (WPARAM) i, 0);
    SendMessage (ghwndList1, LB_INSERTSTRING, (WPARAM) i, (LPARAM) buf);
    SendMessage (ghwndList1, LB_SETITEMDATA, (WPARAM) i, (LPARAM) pCall);

    if (lSel == i)
    {
        SendMessage (ghwndList1, LB_SETCURSEL, (WPARAM) i, 0);
    }
}


VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    typedef struct _MSG_PARAMS
    {
        char    *lpszMsg;

        LPVOID  aParamFlagTables[3];

    } MSG_PARAMS, *PMSG_PARAMS;

    static MSG_PARAMS msgParams[] =
    {
        { "LINE_ADDRESSSTATE",       { NULL, aAddressStates, NULL } },
        { "LINE_CALLINFO",           { aCallInfoStates, NULL, NULL } },
        { "LINE_CALLSTATE",          { aCallStates, NULL, aCallPrivileges } },
        { "LINE_CLOSE",              { NULL, NULL, NULL } },
        { "LINE_DEVSPECIFIC",        { NULL, NULL, NULL } },
        { "LINE_DEVSPECIFICFEATURE", { NULL, NULL, NULL } },
        { "LINE_GATHERDIGITS",       { aGatherTerms, NULL, NULL } },
        { "LINE_GENERATE",           { aGenerateTerms, NULL, NULL } },
        { "LINE_LINEDEVSTATE",       { aLineStates, NULL, NULL } },
        { "LINE_MONITORDIGITS",      { NULL, aDigitModes, NULL } },
        { "LINE_MONITORMEDIA",       { aMediaModes, NULL, NULL } },
        { "LINE_MONITORTONE",        { NULL, NULL, NULL } },
        { "LINE_REPLY",              { NULL, NULL, NULL } },
        { "LINE_REQUEST",            { aRequestModes, NULL, NULL } }
         ,
        { "PHONE_BUTTON",            { NULL, aButtonModes, aButtonStates } },
        { "PHONE_CLOSE",             { NULL, NULL, NULL } },
        { "PHONE_DEVSPECIFIC",       { NULL, NULL, NULL } },
        { "PHONE_REPLY",             { NULL, NULL, NULL } },
        { "PHONE_STATE",             { aPhoneStates, NULL, NULL } }

#if TAPI_1_1
         ,
        { "LINE_CREATE",             { NULL, NULL, NULL } },
        { "PHONE_CREATE",            { NULL, NULL, NULL } }

#if TAPI_2_0
         ,
        { "LINE_AGENTSPECIFIC",      { NULL, NULL, NULL } },
        { "LINE_AGENTSTATUS",        { NULL, NULL, NULL } },
        { "LINE_APPNEWCALL",         { NULL, NULL, aCallPrivileges } },
        { "LINE_PROXYREQUEST",       { NULL, NULL, NULL } },
        { "LINE_REMOVE",             { NULL, NULL, NULL } },
        { "PHONE_REMOVE",            { NULL, NULL, NULL } }
#endif
#endif

    };
    int     i, j;
    LONG    lResult;


    UpdateResults (TRUE);

#if TAPI_1_1
#if TAPI_2_0
    if (dwMsg <= PHONE_REMOVE)
#else
    if (dwMsg <= PHONE_CREATE)
#endif
#else
    if (dwMsg <= PHONE_STATE)
#endif
    {
        ULONG_PTR   aParams[3] = { Param1, Param2, Param3 };


        {
            char *pszTimeStamp = GetTimeStamp();

            ShowStr(
                "%sreceived %s",
                pszTimeStamp,
                msgParams[dwMsg].lpszMsg
                );
        }

        ShowStr ("%sdevice=x%lx", szTab, hDevice);
        ShowStr ("%scbInst=x%lx", szTab, CallbackInstance);

        if (dwMsg == LINE_CALLSTATE)
        {
            msgParams[2].aParamFlagTables[1] = NULL;

            switch (Param1)
            {
            case LINECALLSTATE_BUSY:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aBusyModes;
                break;

            case LINECALLSTATE_DIALTONE:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aDialToneModes;
                break;

            case LINECALLSTATE_SPECIALINFO:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aSpecialInfo;
                break;

            case LINECALLSTATE_DISCONNECTED:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aDisconnectModes;
                break;

#if TAPI_1_1

            case LINECALLSTATE_CONNECTED:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aConnectedModes;
                break;

            case LINECALLSTATE_OFFERING:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aOfferingModes;
                break;

#endif // TAPI_1_1

            } // switch
        }

        else if (dwMsg == PHONE_STATE)
        {
            msgParams[18].aParamFlagTables[1] = NULL;

            switch (Param1)
            {
            case PHONESTATE_HANDSETHOOKSWITCH:
            case PHONESTATE_SPEAKERHOOKSWITCH:
            case PHONESTATE_HEADSETHOOKSWITCH:

                msgParams[18].aParamFlagTables[1] = aHookSwitchModes;
                break;

            } // switch
        }

        for (i = 0; i < 3; i++)
        {
            char buf[80];


            sprintf (buf, "%sparam%d=x%lx, ", szTab, i+1, aParams[i]);

            if (msgParams[dwMsg].aParamFlagTables[i])
            {
                PLOOKUP pLookup = (PLOOKUP)
                    msgParams[dwMsg].aParamFlagTables[i];


                for (j = 0; aParams[i], pLookup[j].dwVal != 0xffffffff; j++)
                {
                    if (aParams[i] & pLookup[j].dwVal)
                    {
                        if (buf[0] == 0)
                        {
                            sprintf (buf, "%s%s", szTab, szTab);
                        }

                        strcat (buf, pLookup[j].lpszVal);
                        strcat (buf, " ");
                        aParams[i] = aParams[i] &
                            ~((ULONG_PTR) pLookup[j].dwVal);

                        if (strlen (buf) > 50)
                        {
                            //
                            // We don't want strings getting so long that
                            // they're going offscreen, so break them up.
                            //

                            ShowStr (buf);
                            buf[0] = 0;
                        }
                    }
                }

                if (aParams[i])
                {
                    strcat (buf, "<unknown flag(s)>");
                }

            }

            if (buf[0])
            {
                ShowStr (buf);
            }
        }
    }
    else
    {
        ShowStr ("ERROR! callback received unknown msg=x%lx", dwMsg);
        ShowStr ("%shDev=x%lx,  cbInst=x%lx, p1=x%lx, p2=x%lx, p3=x%lx",
            szTab,
            hDevice,
            CallbackInstance,
            Param1,
            Param2,
            Param3
            );

        return;
    }

    UpdateResults (FALSE);

    switch (dwMsg)
    {
    case LINE_CALLSTATE:
    {
        PMYLINE pLine;
        PMYCALL pCall = GetCall ((HCALL) hDevice);


        //
        // If the call state is idle & we're in "nuke idle xxx calls"
        // mode then determine the privilege of this callto see if we
        // need to nuke it
        //

        if ((Param1 == LINECALLSTATE_IDLE) &&
            (bNukeIdleMonitorCalls || bNukeIdleOwnedCalls))
        {
            BOOL            bNukeCall = FALSE;
            LINECALLSTATUS  callStatus;


            callStatus.dwTotalSize = (DWORD) sizeof(LINECALLSTATUS);

            lResult = lineGetCallStatus ((HCALL) hDevice, &callStatus);

            ShowLineFuncResult ("lineGetCallStatus", lResult);

            if (lResult == 0)
            {
                if ((callStatus.dwCallPrivilege & LINECALLPRIVILEGE_OWNER))
                {
                    if (bNukeIdleOwnedCalls)
                    {
                        bNukeCall = TRUE;
                    }
                }
                else
                {
                    if (bNukeIdleMonitorCalls)
                    {
                        bNukeCall = TRUE;
                    }
                }
            }

            if (bNukeCall)
            {
                if ((lResult = lineDeallocateCall ((HCALL) hDevice)) == 0)
                {
                    ShowStr ("Call x%lx deallocated on IDLE", hDevice);

                    if (pCall)
                    {
                        FreeCall (pCall);
                    }

                    break;
                }
                else
                {
                    ShowLineFuncResult ("lineDeallocateCall", lResult);
                }
            }
        }


        //
        // Find call in the widget list, save the call state, &
        // update it's text in the widget list.
        //

        if (pCall)
        {
            //
            // If dwNumPendingDrops is non-zero, then user previously
            // pressed "Call-" button and we're waiting for a call to
            // go IDLE so we can deallocate it. Check to see if this
            // is the call we want to nuke. (Note: we used to nuke the
            // call when we got a successful REPLY msg back from the
            // drop request; the problem with that is some SPs complete
            // the drop request *before* they set the call state to
            // IDLE, and our call to lineDeallocateCall would fail
            // since TAPI won't let a call owner deallocate a call if
            // it's not IDLE.)
            //

            if (dwNumPendingDrops &&
                (Param1 == LINECALLSTATE_IDLE) &&
                pCall->lDropReqID)
            {
                dwNumPendingDrops--;

                ShowStr(
                    "Deallocating hCall x%lx " \
                        "(REPLY for requestID x%lx might be filtered)",
                    pCall->hCall,
                    pCall->lDropReqID
                    );

                lResult = lineDeallocateCall (pCall->hCall);

                ShowLineFuncResult ("lineDeallocateCall", lResult);

                if (lResult == 0)
                {
                    FreeCall (pCall);
                    break;
                }
                else
                {
                    pCall->lDropReqID = 0;
                }
            }

            pCall->dwCallState = (DWORD) Param1;
            UpdateWidgetListCall (pCall);
        }


        //
        // If here this is the first we've heard of this this call,
        // so find out which line it's on & create a call widget
        // for it
        //

        else if (Param3 != 0)
        {
            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);
            lResult = lineGetCallInfo ((HCALL)hDevice, &callInfo);

            ShowStr(
                "%slineGetCallInfo returned x%lx, hLine=x%lx",
                szTab,
                lResult,
                callInfo.hLine
                );

            if (lResult == 0)
            {
                if ((pLine = GetLine (callInfo.hLine)))
                {
                    if ((pCall = AllocCall (pLine)))
                    {
                        pCall->hCall       = (HCALL) hDevice;
                        pCall->dwCallState = (DWORD) Param1;
                        pCall->bMonitor    = (Param3 ==
                            LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                        UpdateWidgetListCall (pCall);
                    }
                }
            }
        }

        break;
    }
    case LINE_GATHERDIGITS:
    {
        PMYCALL pCall;


        if ((pCall = GetCall ((HCALL) hDevice)) && pCall->lpsGatheredDigits)
        {
            ShowStr ("%sGathered digits:", szTab);
            ShowBytes (pCall->dwNumGatheredDigits, pCall->lpsGatheredDigits, 2);
            free (pCall->lpsGatheredDigits);
            pCall->lpsGatheredDigits = NULL;
        }

        break;
    }
    case LINE_REPLY:

        if (dwNumPendingMakeCalls)
        {
            //
            // Check to see if this is a reply for a lineMakeCall request
            //

            PMYWIDGET pWidget = aWidgets;


            while (pWidget && (pWidget->dwType != WT_PHONEAPP))
            {
                if (pWidget->dwType == WT_CALL)
                {
                    PMYCALL pCall = (PMYCALL) pWidget;

                    if ((DWORD)pCall->lMakeCallReqID == Param1)
                    {
                        //
                        // The reply id matches the make call req id
                        //

                        dwNumPendingMakeCalls--;

                        if (Param2 || !pCall->hCall)
                        {
                            //
                            // Request error or no call created, so free
                            // up the struct & update the hCalls listbox
                            //

                            if (Param2 == 0)
                            {
                                ShowStr(
                                    "    NOTE: *lphCall==NULL, "\
                                        "freeing call data structure"
                                    );
                            }

                            pWidget = pWidget->pNext;

                            FreeCall (pCall);

                            continue;
                        }
                        else
                        {
                            //
                            // Reset this field so we don't run into
                            // problems later with another of the same
                            // request id
                            //

                            pCall->lMakeCallReqID = 0;

                            UpdateWidgetListCall (pCall);
                        }
                    }
                }

                pWidget = pWidget->pNext;
            }
        }

        if (Param2)
        {
            //
            // Dump the error in a readable format
            //

            if (Param2 > LAST_LINEERR)
            {
                ShowStr ("inval err code (x%lx)", Param2);
            }
            else
            {
                ShowStr(
                    "    %s%s",
                    "LINEERR_", // ...to shrink the aszLineErrs array
                    aszLineErrs[LOWORD(Param2)]
                    );
            }
        }

        break;

    case PHONE_REPLY:

        if (Param2)
        {
            //
            // Dump the error in a readable format
            //

            ErrorAlert();

            if (Param2 > PHONEERR_REINIT)
            {
                ShowStr ("inval err code (x%lx)", Param2);
            }
            else
            {
                ShowStr(
                    "    %s%s",
                    "PHONEERR_", // ...to shrink the aszPhoneErrs array
                    aszPhoneErrs[LOWORD(Param2)]
                    );
            }
        }

        break;

    case LINE_CLOSE:

        FreeLine (GetLine ((HLINE) hDevice));
        break;

    case PHONE_CLOSE:

        FreePhone (GetPhone ((HPHONE) hDevice));
        break;

#if TAPI_2_0

    case LINE_APPNEWCALL:
    {
        PMYLINE pLine;
        PMYCALL pCall;


        if ((pLine = GetLine ((HLINE) hDevice)))
        {
            if ((pCall = AllocCall (pLine)))
            {
                pCall->hCall       = (HCALL) Param2;
                pCall->dwCallState = LINECALLSTATE_UNKNOWN;
                pCall->bMonitor    = (Param3 ==
                    LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                UpdateWidgetListCall (pCall);
            }
        }

        break;
    }
    case LINE_PROXYREQUEST:
    {
        LPLINEPROXYREQUEST  pRequest = (LPLINEPROXYREQUEST) Param1;
        STRUCT_FIELD fields[] =
        {
            { szdwSize,                     FT_DWORD,   pRequest->dwSize, NULL },
            { "dwClientMachineNameSize",    FT_SIZE,    pRequest->dwClientMachineNameSize, NULL },
            { "dwClientMachineNameOffset",  FT_OFFSET,  pRequest->dwClientMachineNameOffset, NULL },
            { "dwClientUserNameSize",       FT_SIZE,    pRequest->dwClientUserNameSize, NULL },
            { "dwClientUserNameOffset",     FT_OFFSET,  pRequest->dwClientUserNameOffset, NULL },
            { "dwClientAppAPIVersion",      FT_DWORD,   pRequest->dwClientAppAPIVersion, NULL },
            { "dwRequestType",              FT_ORD,     pRequest->dwRequestType, aProxyRequests }
        };
        STRUCT_FIELD_HEADER fieldHeader =
        {
            pRequest,
            "LINEPROXYREQUEST",
            7,
            fields
        };


        ShowStructByField (&fieldHeader, TRUE);

        switch (pRequest->dwRequestType)
        {
        case LINEPROXYREQUEST_SETAGENTGROUP:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->SetAgentGroup.dwAddressID, NULL }

// BUGBUG LINE_PROXYREQUEST: dump agent grp list

            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "SetAgentGroup",
                1,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_SETAGENTSTATE:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,        FT_DWORD,   pRequest->SetAgentState.dwAddressID, NULL },
                { "dwAgentState",       FT_ORD,     pRequest->SetAgentState.dwAgentState, aAgentStates },
                { "dwNextAgentState",   FT_ORD,     pRequest->SetAgentState.dwNextAgentState, aAgentStates }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "SetAgentState",
                3,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_SETAGENTACTIVITY:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->SetAgentActivity.dwAddressID, NULL },
                { "dwActivityID",   FT_DWORD,   pRequest->SetAgentActivity.dwActivityID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "SetAgentActivity",
                2,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTCAPS:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentCaps.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentCaps",
                1,
                fields
            };


// BUGBUG LINE_PROXYREQUEST: fill in agent caps?

            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTSTATUS:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentStatus.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentStatus",
                1,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_AGENTSPECIFIC:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,                FT_DWORD,   (DWORD) pRequest->AgentSpecific.dwAddressID, NULL },
                { "dwAgentExtensionIDIndex",    FT_DWORD,   (DWORD) pRequest->AgentSpecific.dwAgentExtensionIDIndex, NULL },
                { szdwSize,                     FT_SIZE,    (DWORD) pRequest->AgentSpecific.dwSize, NULL },
                { "Params",                     FT_OFFSET,  (DWORD) (pRequest->AgentSpecific.Params - (LPBYTE) pRequest), NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "AgentSpecific",
                4,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentActivityList.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentActivityList",
                1,
                fields
            };


// BUGBUG LINE_PROXYREQUEST: fill in agent activity list?

            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTGROUPLIST:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentGroupList.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentGroupList",
                1,
                fields
            };


// BUGBUG LINE_PROXYREQUEST: fill in agent grp list?

            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        } // switch (pRequest->dwRequestType)

        break;
    }

#endif

    }
}


INT_PTR
CALLBACK
ParamsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD  i;

    typedef struct _DLG_INST_DATA
    {
        PFUNC_PARAM_HEADER  pParamsHeader;

        LRESULT             lLastSel;

        char                szComboText[MAX_STRING_PARAM_SIZE];

    } DLG_INST_DATA, *PDLG_INST_DATA;

    PDLG_INST_DATA  pDlgInstData = (PDLG_INST_DATA)
                        GetWindowLongPtr (hwnd, GWLP_USERDATA);

    static int icxList2, icyList2, icyEdit1;

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        //
        // Alloc a dlg instance data struct, init it, & save a ptr to it
        //

        pDlgInstData = (PDLG_INST_DATA) malloc (sizeof(DLG_INST_DATA));

        // BUGBUG if (!pDlgInstData)

        pDlgInstData->pParamsHeader = (PFUNC_PARAM_HEADER) lParam;
        pDlgInstData->lLastSel = -1;

        SetWindowLongPtr (hwnd, GWLP_USERDATA, (LONG_PTR) pDlgInstData);


        //
        // Stick all the param names in the listbox, & for each PT_DWORD
        // param save it's default value
        //

        for (i = 0; i < pDlgInstData->pParamsHeader->dwNumParams; i++)
        {
            SendDlgItemMessage(
                hwnd,
                IDC_LIST1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) pDlgInstData->pParamsHeader->aParams[i].szName
                );

            if (pDlgInstData->pParamsHeader->aParams[i].dwType == PT_DWORD)
            {
                pDlgInstData->pParamsHeader->aParams[i].u.dwDefValue =
                    pDlgInstData->pParamsHeader->aParams[i].dwValue;
            }
        }


        //
        // Set the dlg title as appropriate
        //

// help        if (pDlgInstData->pParamsHeader->FuncIndex == DefValues)
// help        {
// help            EnableWindow (GetDlgItem (hwnd, IDC_TB_HELP), FALSE);
// help        }

        SetWindowText(
            hwnd,
            aFuncNames[pDlgInstData->pParamsHeader->FuncIndex]
            );


        //
        // Limit the max text length for the combobox's edit field
        // (NOTE: A combobox ctrl actually has two child windows: a
        // edit ctrl & a listbox.  We need to get the hwnd of the
        // child edit ctrl & send it the LIMITTEXT msg.)
        //

        {
            HWND hwndChild =
                GetWindow (GetDlgItem (hwnd, IDC_COMBO1), GW_CHILD);


            while (hwndChild)
            {
                char buf[8];


                GetClassName (hwndChild, buf, 7);

                if (_stricmp (buf, "edit") == 0)
                {
                    break;
                }

                hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
            }

            SendMessage(
                hwndChild,
                EM_LIMITTEXT,
                (WPARAM) (gbWideStringParams ?
                    (MAX_STRING_PARAM_SIZE/2 - 1) : MAX_STRING_PARAM_SIZE - 1),
                0
                );
        }

        {
            RECT    rect;


            GetWindowRect (GetDlgItem (hwnd, IDC_LIST2), &rect);

            SetWindowPos(
                GetDlgItem (hwnd, IDC_LIST2),
                NULL,
                0,
                0,
                0,
                0,
                SWP_NOMOVE | SWP_NOZORDER
                );

            icxList2 = rect.right - rect.left;
            icyList2 = rect.bottom - rect.top;

            GetWindowRect (GetDlgItem (hwnd, 58), &rect);

            icyEdit1 = icyList2 - (rect.bottom - rect.top);
        }

        SendDlgItemMessage(
            hwnd,
            IDC_EDIT1,
            WM_SETFONT,
            (WPARAM) ghFixedFont,
            0
            );

        break;
    }
    case WM_COMMAND:
    {
        LRESULT             lLastSel      = pDlgInstData->lLastSel;
        char far           *lpszComboText = pDlgInstData->szComboText;
        PFUNC_PARAM_HEADER  pParamsHeader = pDlgInstData->pParamsHeader;


        switch (LOWORD(wParam))
        {
        case IDC_EDIT1:
        {
            if (HIWORD(wParam) == EN_CHANGE)
            {
                //
                // Don't allow the user to enter characters other than
                // 0-9, a-f, or A-F in the edit control (do this by
                // hiliting other letters and cutting them).
                //

                HWND    hwndEdit = GetDlgItem (hwnd, IDC_EDIT1);
                DWORD   dwLength, j;
                BYTE   *p;


                dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                if (dwLength  &&  (p = malloc (dwLength + 1)))
                {
                    GetWindowText (hwndEdit, p, dwLength + 1);

                    for (i = j = 0; i < dwLength ; i++, j++)
                    {
                        if (aHex[p[i]] == 255)
                        {
                            SendMessage(
                                hwndEdit,
                                EM_SETSEL,
                                (WPARAM) j,
                                (LPARAM) j + 1  // 0xfffffffe
                                );

                            SendMessage (hwndEdit, EM_REPLACESEL, 0, (LPARAM) "");
                            SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);

                            j--;
                        }
                    }

                    free (p);
                }
            }

            break;
        }
        case IDOK:

            if (lLastSel != -1)
            {
                //
                // Save val of currently selected param
                //

                char buf[MAX_STRING_PARAM_SIZE];


                i = GetDlgItemText (hwnd, IDC_COMBO1, buf, MAX_STRING_PARAM_SIZE-1);

                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_STRING:
                {
                    LRESULT lComboSel;


                    lComboSel = SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_GETCURSEL,
                        0,
                        0
                        );

                    if (lComboSel == 0) // "NULL pointer"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR) 0;
                    }
                    else if (lComboSel == 2) // "Invalid string pointer"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            -1;
                    }
                    else // "Valid string pointer"
                    {
                        strncpy(
                            pParamsHeader->aParams[lLastSel].u.buf,
                            buf,
                            MAX_STRING_PARAM_SIZE - 1
                            );

                        pParamsHeader->aParams[lLastSel].u.buf[MAX_STRING_PARAM_SIZE-1] = 0;

                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            pParamsHeader->aParams[lLastSel].u.buf;
                    }

                    break;
                }
                case PT_POINTER:
                {
                    //
                    // If there is any text in the "Buffer byte editor"
                    // window then retrieve it, convert it to hexadecimal,
                    // and copy it to the buffer
                    //

                    DWORD     dwLength;
                    BYTE     *p, *p2,
                             *pBuf = pParamsHeader->aParams[lLastSel].u.ptr;
                    HWND      hwndEdit = GetDlgItem (hwnd,IDC_EDIT1);


                    dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                    if (dwLength  &&  (p = malloc (dwLength + 1)))
                    {
                        GetWindowText (hwndEdit, p, dwLength + 1);
                        SetWindowText (hwndEdit, "");

                        p2 = p;

                        p[dwLength] = (BYTE) '0';
                        dwLength = (dwLength + 1) & 0xfffffffe;

                        for (i = 0; i < dwLength; i++, i++)
                        {
                            BYTE b;

                            b = aHex[*p] << 4;
                            p++;

                            b |= aHex[*p];
                            p++;

                            *pBuf = b;
                            pBuf++;
                        }

                        free (p2);
                    }

                    // fall thru to code below
                }
                case PT_DWORD:
                case PT_FLAGS:
                case PT_CALLPARAMS: // ??? BUGBUG
                case PT_FORWARDLIST: // ??? BUGBUG
                case PT_ORDINAL:
                {
                    if (!sscanf(
                            buf,
                            "%08lx",
                            &pParamsHeader->aParams[lLastSel].dwValue
                            ))
                    {
                        //
                        // Default to 0
                        //

                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }

                    break;
                }
                } // switch
            }

            free (pDlgInstData);
            EndDialog (hwnd, TRUE);
            break;

        case IDCANCEL:

            free (pDlgInstData);
            EndDialog (hwnd, FALSE);
            break;

// help        case IDC_TB_HELP:
// help
// help            MyWinHelp(
// help                hwnd,
// help                TRUE,
// help                HELP_PARTIALKEY,
// help                (DWORD) aFuncNames[pParamsHeader->FuncIndex]
// help                );
// help
// help            break;

        case IDC_LIST1:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                char buf[MAX_STRING_PARAM_SIZE] = "";
                LPCSTR lpstr = buf;
                LRESULT lSel =
                    SendDlgItemMessage (hwnd, IDC_LIST1, LB_GETCURSEL, 0, 0);


                if (lLastSel != -1)
                {
                    //
                    // Save the old param value
                    //

                    i = GetDlgItemText(
                        hwnd,
                        IDC_COMBO1,
                        buf,
                        MAX_STRING_PARAM_SIZE - 1
                        );

                    switch (pParamsHeader->aParams[lLastSel].dwType)
                    {
                    case PT_STRING:
                    {
                        LRESULT lComboSel;


                        lComboSel = SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_GETCURSEL,
                            0,
                            0
                            );

                        if (lComboSel == 0) // "NULL pointer"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR) 0;
                        }
                        else if (lComboSel == 2) // "Invalid string pointer"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR) -1;
                        }
                        else // "Valid string pointer" or no sel
                        {
                            strncpy(
                                pParamsHeader->aParams[lLastSel].u.buf,
                                buf,
                                MAX_STRING_PARAM_SIZE - 1
                                );

                            pParamsHeader->aParams[lLastSel].u.buf[MAX_STRING_PARAM_SIZE - 1] = 0;

                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR)
                                    pParamsHeader->aParams[lLastSel].u.buf;
                        }

                        break;
                    }
                    case PT_POINTER:
                    {
                        //
                        // If there is any text in the "Buffer byte editor"
                        // window then retrieve it, convert it to hexadecimal,
                        // and copy it to the buffer
                        //

                        DWORD     dwLength;
                        BYTE     *p, *p2,
                                 *pBuf = pParamsHeader->aParams[lLastSel].u.ptr;
                        HWND      hwndEdit = GetDlgItem (hwnd,IDC_EDIT1);


                        dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                        if (dwLength  &&  (p = malloc (dwLength + 1)))
                        {
                            GetWindowText (hwndEdit, p, dwLength + 1);
                            SetWindowText (hwndEdit, "");

                            p2 = p;

                            p[dwLength] = (BYTE) '0';
                            dwLength = (dwLength + 1) & 0xfffffffe;

                            for (i = 0; i < dwLength; i+= 2)
                            {
                                BYTE b;

                                b = aHex[*p] << 4;
                                p++;

                                b |= aHex[*p];
                                p++;

                                *pBuf = b;
                                pBuf++;
                            }

                            free (p2);
                        }

                        // fall thru to code below
                    }
                    case PT_DWORD:
                    case PT_FLAGS:
                    case PT_CALLPARAMS: // ??? BUGBUG
                    case PT_FORWARDLIST: // ??? BUGBUG
                    case PT_ORDINAL:
                    {
                        if (!sscanf(
                                buf,
                                "%08lx",
                                &pParamsHeader->aParams[lLastSel].dwValue
                                ))
                        {
                            //
                            // Default to 0
                            //

                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }

                        break;
                    }
                    } // switch
                }


                SendDlgItemMessage (hwnd, IDC_LIST2, LB_RESETCONTENT, 0, 0);
                SendDlgItemMessage (hwnd, IDC_COMBO1, CB_RESETCONTENT, 0, 0);

                {
                    int         icxL2 = 0, icyL2 = 0, icxE1 = 0, icyE1 = 0;
                    char FAR   *pszS1 = NULL, *pszS2 = NULL;
                    static char szBitFlags[] = "Bit flags:";
                    static char szOrdinalValues[] = "Ordinal values:";
                    static char szBufByteEdit[] =
                                    "Buffer byte editor (use 0-9, a-f, A-F)";

                    switch (pParamsHeader->aParams[lSel].dwType)
                    {
                    case PT_FLAGS:

                        icxL2 = icxList2;
                        icyL2 = icyList2;
                        pszS1 = szBitFlags;
                        break;

                    case PT_POINTER:

                        icxE1 = icxList2;
                        icyE1 = icyEdit1;;
                        pszS1 = szBufByteEdit;
                        pszS2 = gszEnterAs;
                        break;

                    case PT_ORDINAL:

                        icxL2 = icxList2;
                        icyL2 = icyList2;
                        pszS1 = szOrdinalValues;
                        break;

                    default:

                        break;
                    }

                    SetWindowPos(
                        GetDlgItem (hwnd, IDC_LIST2),
                        NULL,
                        0,
                        0,
                        icxL2,
                        icyL2,
                        SWP_NOMOVE | SWP_NOZORDER
                        );

                    SetWindowPos(
                        GetDlgItem (hwnd, IDC_EDIT1),
                        NULL,
                        0,
                        0,
                        icxE1,
                        icyE1,
                        SWP_NOMOVE | SWP_NOZORDER
                        );

                    SetDlgItemText (hwnd, 57, pszS1);
                    SetDlgItemText (hwnd, 58, pszS2);
                }

                switch (pParamsHeader->aParams[lSel].dwType)
                {
                case PT_STRING:
                {
                    char * aszOptions[] =
                    {
                        "NULL pointer",
                        "Valid string pointer",
                        "Invalid string pointer"
                    };


                    for (i = 0; i < 3; i++)
                    {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) aszOptions[i]
                            );
                    }

                    if (pParamsHeader->aParams[lSel].dwValue == 0)
                    {
                        i = 0;
                        buf[0] = 0;
                    }
                    else if (pParamsHeader->aParams[lSel].dwValue !=
                                (ULONG_PTR) -1)
                    {
                        i = 1;
                        lpstr = (LPCSTR) pParamsHeader->aParams[lSel].dwValue;
                    }
                    else
                    {
                        i = 2;
                        buf[0] = 0;
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_SETCURSEL,
                        (WPARAM) i,
                        0
                        );

                    break;
                }
                case PT_POINTER:
                case PT_CALLPARAMS: // ??? BUGBUG
                case PT_FORWARDLIST: // ??? BUGBUG
                {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "00000000"
                        );

                    sprintf(
                        buf,
                        "%08lx (valid pointer)",
                        pParamsHeader->aParams[lSel].u.dwDefValue
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) buf
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "ffffffff"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_DWORD:
                {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "0000000"
                        );

                    if (pParamsHeader->aParams[lSel].u.dwDefValue)
                    {
                        //
                        // Add the default val string to the combo
                        //

                        sprintf(
                            buf,
                            "%08lx",
                            pParamsHeader->aParams[lSel].u.dwDefValue
                            );

                        SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) buf
                            );
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "ffffffff"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_FLAGS:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].u.pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_LIST2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue &
                            pLookup[i].dwVal)
                        {
                            SendDlgItemMessage(
                                hwnd,
                                IDC_LIST2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "select none"
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "select all"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_ORDINAL:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    HWND hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].u.pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue ==
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    wsprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                } //switch

                SetDlgItemText (hwnd, IDC_COMBO1, lpstr);

                pDlgInstData->lLastSel = lSel;
            }
            break;

        case IDC_LIST2:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                PLOOKUP pLookup = (PLOOKUP)
                    pParamsHeader->aParams[lLastSel].u.pLookup;
                char buf[16];
                DWORD dwValue = 0;
                int far *ai;
                LONG    i;
                LRESULT lSelCount =
                    SendDlgItemMessage (hwnd, IDC_LIST2, LB_GETSELCOUNT, 0, 0);


                if (lSelCount)
                {
                    ai = (int far *) malloc ((size_t)lSelCount * sizeof(int));

                    SendDlgItemMessage(
                        hwnd,
                        IDC_LIST2,
                        LB_GETSELITEMS,
                        (WPARAM) lSelCount,
                        (LPARAM) ai
                        );

                    if (pParamsHeader->aParams[lLastSel].dwType == PT_FLAGS)
                    {
                        for (i = 0; i < lSelCount; i++)
                        {
                            dwValue |= pLookup[ai[i]].dwVal;
                        }
                    }
                    else // if (.dwType == PT_ORDINAL)
                    {
                        if (lSelCount == 1)
                        {
                            dwValue = pLookup[ai[0]].dwVal;
                        }
                        else if (lSelCount == 2)
                        {
                            //
                            // Figure out which item we need to de-select,
                            // since we're doing ords & only want 1 item
                            // selected at a time
                            //

                            GetDlgItemText (hwnd, IDC_COMBO1, buf, 16);

                            if (sscanf (buf, "%lx", &dwValue))
                            {
                                if (pLookup[ai[0]].dwVal == dwValue)
                                {
                                    SendDlgItemMessage(
                                        hwnd,
                                        IDC_LIST2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[0]
                                        );

                                    dwValue = pLookup[ai[1]].dwVal;
                                }
                                else
                                {
                                    SendDlgItemMessage(
                                        hwnd,
                                        IDC_LIST2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[1]
                                        );

                                    dwValue = pLookup[ai[0]].dwVal;
                                }
                            }
                            else
                            {
                                // BUGBUG de-select items???

                                dwValue = 0;
                            }
                        }
                    }

                    free (ai);
                }

                sprintf (buf, "%08lx", dwValue);
                SetDlgItemText (hwnd, IDC_COMBO1, buf);
            }
            break;

        case IDC_COMBO1:

#ifdef WIN32
            switch (HIWORD(wParam))
#else
            switch (HIWORD(lParam))
#endif
            {
            case CBN_SELCHANGE:
            {
                LRESULT lSel =
                    SendDlgItemMessage (hwnd, IDC_COMBO1, CB_GETCURSEL, 0, 0);


                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_POINTER:
                {
                    if (lSel == 1)
                    {
                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf(
                            lpszComboText,
                            "%08lx",
                            pParamsHeader->aParams[lLastSel].u.ptr
                            );

                        PostMessage (hwnd, WM_USER+55, 0, 0);
                    }

                    break;
                }
                case PT_FLAGS:
                {
                    BOOL bSelect = (lSel ? TRUE : FALSE);

                    SendDlgItemMessage(
                        hwnd,
                        IDC_LIST2,
                        LB_SETSEL,
                        (WPARAM) bSelect,
                        (LPARAM) -1
                        );

                    if (bSelect)
                    {
                        PLOOKUP pLookup = (PLOOKUP)
                                    pParamsHeader->aParams[lLastSel].u.pLookup;
                        DWORD   dwValue = 0;
                        int far *ai;
                        LONG    i;
                        LRESULT lSelCount =
                            SendDlgItemMessage (hwnd, IDC_LIST2, LB_GETSELCOUNT, 0, 0);


                        if (lSelCount)
                        {
                            ai = (int far *) malloc ((size_t)lSelCount * sizeof(int));

                            SendDlgItemMessage(
                                hwnd,
                                IDC_LIST2,
                                LB_GETSELITEMS,
                                (WPARAM) lSelCount,
                                (LPARAM) ai
                                );

                            for (i = 0; i < lSelCount; i++)
                            {
                                dwValue |= pLookup[ai[i]].dwVal;
                            }

                            free (ai);
                        }

                        sprintf (lpszComboText, "%08lx", dwValue);

                    }
                    else
                    {
                        strcpy (lpszComboText, "00000000");
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;
                }
                case PT_STRING:

                    if (lSel == 1)
                    {
                        strncpy(
                            lpszComboText,
                            pParamsHeader->aParams[lLastSel].u.buf,
                            MAX_STRING_PARAM_SIZE
                            );

                        lpszComboText[MAX_STRING_PARAM_SIZE-1] = 0;
                    }
                    else
                    {
                        lpszComboText[0] = 0;
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;

                case PT_DWORD:

                    break;

                case PT_CALLPARAMS:
                {
                    if (lSel == 1)
                    {
#if TAPI_2_0
                        LPLINECALLPARAMS lpCP = (gbWideStringParams ?
                                            lpCallParamsW : lpCallParams);
#else
                        LPLINECALLPARAMS lpCP = lpCallParams;
#endif
                        char *p = (char *) lpCP;

#if TAPI_2_0
                        char    asz[14][MAX_STRING_PARAM_SIZE];
                        LPDWORD pdwProxyRequests = (LPDWORD) (((LPBYTE) lpCP) +
                                    lpCP->dwDevSpecificOffset);
#else
                        char asz[7][MAX_STRING_PARAM_SIZE];
#endif
                        FUNC_PARAM params[] =
                        {
                            { "dwBearerMode",                   PT_FLAGS,  (ULONG_PTR) lpCP->dwBearerMode, aBearerModes },
                            { "dwMinRate",                      PT_DWORD,  (ULONG_PTR) lpCP->dwMinRate, NULL },
                            { "dwMaxRate",                      PT_DWORD,  (ULONG_PTR) lpCP->dwMaxRate, NULL },
                            { "dwMediaMode",                    PT_FLAGS,  (ULONG_PTR) lpCP->dwMediaMode, aMediaModes },
                            { "dwCallParamFlags",               PT_FLAGS,  (ULONG_PTR) lpCP->dwCallParamFlags, aCallParamFlags },
                            { "dwAddressMode",                  PT_ORDINAL,(ULONG_PTR) lpCP->dwAddressMode, aAddressModes },
                            { "dwAddressID",                    PT_DWORD,  (ULONG_PTR) lpCP->dwAddressID, NULL },
                            { "DIALPARAMS.dwDialPause",         PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwDialPause, NULL },
                            { "DIALPARAMS.dwDialSpeed",         PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwDialSpeed, NULL },
                            { "DIALPARAMS.dwDigitDuration",     PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwDigitDuration, NULL },
                            { "DIALPARAMS.dwWaitForDialtone",   PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwWaitForDialtone, NULL },
                            { "szOrigAddress",                  PT_STRING, (ULONG_PTR) asz[0], asz[0] },
                            { "szDisplayableAddress",           PT_STRING, (ULONG_PTR) asz[1], asz[1] },
                            { "szCalledParty",                  PT_STRING, (ULONG_PTR) asz[2], asz[2] },
                            { "szComment",                      PT_STRING, (ULONG_PTR) asz[3], asz[3] },
                            { "szUserUserInfo",                 PT_STRING, (ULONG_PTR) asz[4], asz[4] },
                            { "szHighLevelComp",                PT_STRING, (ULONG_PTR) asz[5], asz[5] },
                            { "szLowLevelComp",                 PT_STRING, (ULONG_PTR) asz[6], asz[6] }
#if TAPI_2_0
                             ,
                            { "dwPredictiveAutoTransferStates", PT_FLAGS,  (ULONG_PTR) lpCP->dwPredictiveAutoTransferStates, aCallStates },
                            { "szTargetAddress",                PT_STRING, (ULONG_PTR) asz[7], asz[7] },
                            { "szSendingFlowspec",              PT_STRING, (ULONG_PTR) asz[8], asz[8] },
                            { "szReceivingFlowspec",            PT_STRING, (ULONG_PTR) asz[9], asz[9] },
                            { "szDeviceClass",                  PT_STRING, (ULONG_PTR) asz[10], asz[10] },
                            { "szDeviceConfig",                 PT_STRING, (ULONG_PTR) asz[11], asz[11] },
                            { "szCallData",                     PT_STRING, (ULONG_PTR) asz[12], asz[12] },
                            { "dwNoAnswerTimeout",              PT_DWORD,  (ULONG_PTR) lpCP->dwNoAnswerTimeout, NULL },
                            { "szCallingPartyID",               PT_STRING, (ULONG_PTR) asz[13], asz[13] },
                            { "NumProxyRequests",               PT_DWORD,  (ULONG_PTR) lpCP->dwDevSpecificSize / 4, NULL },
                            { "  ProxyRequest1",                PT_ORDINAL,(ULONG_PTR) *pdwProxyRequests, aProxyRequests },
                            { "  ProxyRequest2",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 1), aProxyRequests },
                            { "  ProxyRequest3",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 2), aProxyRequests },
                            { "  ProxyRequest4",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 3), aProxyRequests },
                            { "  ProxyRequest5",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 4), aProxyRequests },
                            { "  ProxyRequest6",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 5), aProxyRequests },
                            { "  ProxyRequest7",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 6), aProxyRequests },
                            { "  ProxyRequest8",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 7), aProxyRequests }
#endif
                        };
                        FUNC_PARAM_HEADER paramsHeader =
                            { 0, lCallParams, params, NULL };
                        int     i;

                        LPDWORD apXxxSize[] =
                        {
                            &lpCP->dwOrigAddressSize,
                            &lpCP->dwDisplayableAddressSize,
                            &lpCP->dwCalledPartySize,
                            &lpCP->dwCommentSize,
                            &lpCP->dwUserUserInfoSize,
                            &lpCP->dwHighLevelCompSize,
                            &lpCP->dwLowLevelCompSize,
#if TAPI_2_0
                            &lpCP->dwTargetAddressSize,
                            &lpCP->dwSendingFlowspecSize,
                            &lpCP->dwReceivingFlowspecSize,
                            &lpCP->dwDeviceClassSize,
                            &lpCP->dwDeviceConfigSize,
                            &lpCP->dwCallDataSize,
                            &lpCP->dwCallingPartyIDSize,
#endif
                            NULL
                        };
                        static DWORD   dwAPIVersion, adwStrParamIndices[] =
                        {
                            11, 12, 13, 14, 15, 16, 17,
#if TAPI_2_0
                            19, 20, 21, 22, 23, 24, 26,
#endif
                            0
                        };



                        //
                        // Init the tmp string params
                        //

                        for (i = 0; apXxxSize[i]; i++)
                        {
                            if (*apXxxSize[i])
                            {
#if TAPI_2_0
                                if (gbWideStringParams)
                                {
                                    WideCharToMultiByte(
                                        CP_ACP,
                                        0,
                                        (LPCWSTR) (p + *(apXxxSize[i] + 1)),
                                        -1,
                                        asz[i],
                                        MAX_STRING_PARAM_SIZE,
                                        NULL,
                                        NULL
                                        );
                                }
                                else
                                {
                                    strcpy (asz[i], p + *(apXxxSize[i] + 1));
                                }
#else
                                strcpy (asz[i], p + *(apXxxSize[i] + 1));
#endif
                            }
                            else
                            {
                                asz[i][0] = 0;
                            }
                        }

                        if (pDlgInstData->pParamsHeader->FuncIndex == lOpen)
                        {
                            dwAPIVersion = (DWORD) pDlgInstData->
                                pParamsHeader->aParams[3].dwValue;
                        }
                        else
                        {
#if TAPI_2_0
                            dwAPIVersion = 0x00020000;
#else
                            dwAPIVersion = 0x00010004;
#endif
                        }

                        if (dwAPIVersion < 0x00020000)
                        {
                            paramsHeader.dwNumParams = 18;
                            apXxxSize[8] = NULL;
                        }
#if TAPI_2_0
                        else if (pDlgInstData->pParamsHeader->FuncIndex ==
                                    lOpen)
                        {
                            paramsHeader.dwNumParams = 36;
                        }
                        else
                        {
                            paramsHeader.dwNumParams = 27;
                        }
#endif
                        if (DialogBoxParam(
                                ghInst,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
                                hwnd,
                                (DLGPROC) ParamsDlgProc,
                                (LPARAM) &paramsHeader
                                ))
                        {
                            LPDWORD lpdwXxx = &lpCP->dwBearerMode;


                            //
                            // Save the DWORD params
                            //

                            for (i = 0; i < 11; i++)
                            {
                                *(lpdwXxx + i) = (DWORD) params[i].dwValue;
                            }
#if TAPI_2_0
                            if (paramsHeader.dwNumParams > 18)
                            {
                                lpCP->dwPredictiveAutoTransferStates = (DWORD)
                                    params[18].dwValue;
                                lpCP->dwNoAnswerTimeout = (DWORD)
                                    params[25].dwValue;

                                if (paramsHeader.dwNumParams > 27)
                                {
                                    lpCP->dwDevSpecificSize = (DWORD)
                                        (4 * params[27].dwValue);

                                    for (i = 0; i < 8; i++)
                                    {
                                        *(pdwProxyRequests + i) = (DWORD)
                                            params[28+i].dwValue;
                                    }
                                }
                            }
#endif

                            //
                            // Save the string params
                            //

                            for (i = 0; apXxxSize[i]; i++)
                            {
                                DWORD   length, index = adwStrParamIndices[i];


                                if (params[index].dwValue &&
                                    (params[index].dwValue != (ULONG_PTR) -1))
                                {
#if TAPI_2_0
                                    if (gbWideStringParams)
                                    {
                                        length = MultiByteToWideChar(
                                            CP_ACP,
                                            MB_PRECOMPOSED,
                                            (LPCSTR) asz[i],
                                            -1,
                                            (LPWSTR) (p + *(apXxxSize[i] + 1)),
                                                                     // offset
                                            MAX_STRING_PARAM_SIZE/2
                                            );

                                        length *= sizeof (WCHAR);
                                    }
                                    else
                                    {
                                        strcpy(
                                            p + *(apXxxSize[i] + 1), // offset
                                            asz[i]
                                            );

                                        length = (DWORD) strlen (asz[i]) + 1;
                                    }
#else
                                    strcpy(
                                        p + *(apXxxSize[i] + 1), // offset
                                        asz[i]
                                        );

                                    length = (DWORD) strlen (asz[i]) + 1;
#endif
                                }
                                else
                                {
                                    length = 0;
                                }

                                *apXxxSize[i] = length;
                            }
                        }

                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf (lpszComboText, "%08lx", lpCP);
                        PostMessage (hwnd, WM_USER+55, 0, 0);

                        pParamsHeader->aParams[lLastSel].dwValue =
                            (ULONG_PTR) lpCP;
                    }

                    break;
                }
                case PT_FORWARDLIST:
                {
                    if (lSel == 1)
                    {
                        char asz[MAX_LINEFORWARD_ENTRIES][2][MAX_STRING_PARAM_SIZE];
                        FUNC_PARAM params[] =
                        {
                            { "dwNumEntries",             PT_DWORD,  0, 0 },
                            { "[0].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[0].lpszCallerAddress",    PT_STRING, 0, asz[0][0] },
                            { "[0].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[0].lpszDestAddress",      PT_STRING, 0, asz[0][1] },
                            { "[1].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[1].lpszCallerAddress",    PT_STRING, 0, asz[1][0] },
                            { "[1].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[1].lpszDestAddress",      PT_STRING, 0, asz[1][1] },
                            { "[2].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[2].lpszCallerAddress",    PT_STRING, 0, asz[2][0] },
                            { "[2].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[2].lpszDestAddress",      PT_STRING, 0, asz[2][1] },
                            { "[3].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[3].lpszCallerAddress",    PT_STRING, 0, asz[3][0] },
                            { "[3].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[3].lpszDestAddress",      PT_STRING, 0, asz[3][1] },
                            { "[4].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[4].lpszCallerAddress",    PT_STRING, 0, asz[4][0] },
                            { "[4].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[4].lpszDestAddress",      PT_STRING, 0, asz[4][1] },

                        };
                        FUNC_PARAM_HEADER paramsHeader =
                            { 21, lForwardList, params, NULL };


                        memset(
                            asz,
                            0,
                            MAX_LINEFORWARD_ENTRIES*2*MAX_STRING_PARAM_SIZE
                            );

                        if (DialogBoxParam(
                                ghInst,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
                                hwnd,
                                (DLGPROC) ParamsDlgProc,
                                (LPARAM) &paramsHeader
                                ))
                        {

                            LPLINEFORWARDLIST lpForwardList =
                                (LPLINEFORWARDLIST)
                                    pParamsHeader->aParams[lLastSel].u.ptr;
                            LPLINEFORWARD lpEntry = lpForwardList->ForwardList;
                            DWORD dwNumEntriesToInit =
                                (params[0].dwValue > MAX_LINEFORWARD_ENTRIES ?
                                    MAX_LINEFORWARD_ENTRIES :
                                    (DWORD) params[0].dwValue);
                            DWORD i, dwFixedSize = sizeof(LINEFORWARDLIST) +
                                (MAX_LINEFORWARD_ENTRIES-1)*sizeof(LINEFORWARD);


                            lpForwardList->dwNumEntries = (DWORD)
                                params[0].dwValue;

                            for (i = 0; i < dwNumEntriesToInit; i++)
                            {
                                lpEntry->dwForwardMode = (DWORD)
                                    params[1 + 4*i].dwValue;

                                if (params[2 + 4*i].dwValue &&
                                    params[2 + 4*i].dwValue != (ULONG_PTR) -1)
                                {
                                    lpEntry->dwCallerAddressSize =
                                        strlen (asz[i][0]) + 1;

                                    lpEntry->dwCallerAddressOffset =
                                        dwFixedSize +
                                            2*i*MAX_STRING_PARAM_SIZE;
#if TAPI_2_0
                                    if (gbWideStringParams)
                                    {
                                        lpEntry->dwCallerAddressSize *=
                                            sizeof (WCHAR);

                                        MultiByteToWideChar(
                                            CP_ACP,
                                            MB_PRECOMPOSED,
                                            (LPCSTR) asz[i][0],
                                            -1,
                                            (LPWSTR) ((char *) lpForwardList +
                                                lpEntry->dwCallerAddressOffset),
                                            MAX_STRING_PARAM_SIZE / 2
                                            );
                                    }
                                    else
                                    {
                                        strcpy(
                                            (char *) lpForwardList +
                                                lpEntry->dwCallerAddressOffset,
                                            asz[i][0]
                                            );
                                    }
#else
                                    strcpy(
                                        (char *) lpForwardList +
                                            lpEntry->dwCallerAddressOffset,
                                        asz[i][0]
                                        );
#endif
                                }

                                lpEntry->dwDestCountryCode = (DWORD)
                                    params[3 + 4*i].dwValue;

                                if (params[4 + 4*i].dwValue &&
                                    params[4 + 4*i].dwValue != (ULONG_PTR) -1)
                                {
                                    lpEntry->dwDestAddressSize =
                                        strlen (asz[i][1]) + 1;

                                    lpEntry->dwDestAddressOffset =
                                        dwFixedSize +
                                            (2*i + 1)*MAX_STRING_PARAM_SIZE;

#if TAPI_2_0
                                    if (gbWideStringParams)
                                    {
                                        lpEntry->dwDestAddressSize *=
                                            sizeof (WCHAR);

                                        MultiByteToWideChar(
                                            CP_ACP,
                                            MB_PRECOMPOSED,
                                            (LPCSTR) asz[i][1],
                                            -1,
                                            (LPWSTR) ((char *) lpForwardList +
                                                lpEntry->dwDestAddressOffset),
                                            MAX_STRING_PARAM_SIZE / 2
                                            );
                                    }
                                    else
                                    {
                                        strcpy(
                                            (char *) lpForwardList +
                                                lpEntry->dwDestAddressOffset,
                                            asz[i][1]
                                            );
                                    }
#else
                                    strcpy(
                                        (char *) lpForwardList +
                                            lpEntry->dwDestAddressOffset,
                                        asz[i][1]
                                        );
#endif
                                }

                                lpEntry++;
                            }
                        }

                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf(
                            lpszComboText,
                            "%08lx",
                            pParamsHeader->aParams[lLastSel].u.ptr
                            );

                        PostMessage (hwnd, WM_USER+55, 0, 0);
                    }

                    break;
                }
                case PT_ORDINAL:

                    //
                    // The only option here is "select none"
                    //

                    strcpy (lpszComboText, "00000000");
                    PostMessage (hwnd, WM_USER+55, 0, 0);
                    break;

                } // switch

                break;
            }
            case CBN_EDITCHANGE:
            {
                //
                // If user entered text in the edit field then copy the
                // text to our buffer
                //

                if (pParamsHeader->aParams[lLastSel].dwType == PT_STRING)
                {
                    char buf[MAX_STRING_PARAM_SIZE];


                    GetDlgItemText(
                        hwnd,
                        IDC_COMBO1,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    strncpy(
                        pParamsHeader->aParams[lLastSel].u.buf,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    pParamsHeader->aParams[lLastSel].u.buf
                        [MAX_STRING_PARAM_SIZE-1] = 0;
                }
                break;
            }
            } // switch

        } // switch

        break;
    }
    case WM_USER+55:

        SetDlgItemText (hwnd, IDC_COMBO1, pDlgInstData->szComboText);
        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch

    return 0;
}


INT_PTR
CALLBACK
IconDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static HICON hIcon;

    switch (msg)
    {
    case WM_INITDIALOG:

        hIcon = (HICON) lParam;

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
#ifdef WIN32
        MoveToEx (ps.hdc, 6, 6, (LPPOINT) NULL);
#else
        MoveTo (ps.hdc, 6, 6);
#endif
        LineTo (ps.hdc, 42, 6);
        LineTo (ps.hdc, 42, 42);
        LineTo (ps.hdc, 6, 42);
        LineTo (ps.hdc, 6, 6);
        DrawIcon (ps.hdc, 8, 8, hIcon);
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return 0;
}


INT_PTR
CALLBACK
UserButtonsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static int iButtonIndex;

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        int i;
        char buf[32];

        if (lParam)
        {
            //
            // The dlg was invoked because someone pressed a user button
            // that was uninitialized, so only allow chgs on this button
            //

            iButtonIndex = *((int *) lParam);

            _itoa (iButtonIndex + 1, buf, 10);

            SendDlgItemMessage(
                hwnd,
                IDC_LIST1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) buf
                );
        }
        else
        {
            //
            // The dlg was invoked because the user chose a menuitem,
            // so allow chgs on all buttons
            //

            iButtonIndex = MAX_USER_BUTTONS;

            for (i = 1; i <= MAX_USER_BUTTONS; i++)
            {
                _itoa (i, buf, 10);

                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_INSERTSTRING,
                    (WPARAM) -1,
                    (LPARAM) buf
                    );
            }

        }

        SendDlgItemMessage(
            hwnd,
            IDC_LIST1,
            LB_SETCURSEL,
            (WPARAM) 0,
            0
            );

        for (i = 0; aFuncNames[i]; i++)
        {
            SendDlgItemMessage(
                hwnd,
                IDC_LIST2,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) aFuncNames[i]
                );
        }

        SendDlgItemMessage(
            hwnd,
            IDC_LIST2,
            LB_INSERTSTRING,
            (WPARAM) -1,
            (LPARAM) "<none>"
            );

        if (!lParam)
        {
#ifdef WIN32
            wParam = (WPARAM) MAKELONG (0, LBN_SELCHANGE);
#else
            lParam = (LPARAM) MAKELONG (0, LBN_SELCHANGE);
#endif
            goto IDC_LIST1_selchange;
        }

        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            LRESULT lFuncSel;


            lFuncSel = SendDlgItemMessage(hwnd, IDC_LIST2, LB_GETCURSEL, 0, 0);

            if (lFuncSel == LB_ERR)
            {
                MessageBox (hwnd, "Select a function", "", MB_OK);
                break;
            }

            if (iButtonIndex == MAX_USER_BUTTONS)
            {
                iButtonIndex = (int) SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_GETCURSEL,
                    0,
                    0
                    );
            }

            aUserButtonFuncs[iButtonIndex] = (DWORD) lFuncSel;

            if (lFuncSel == MiscBegin)
            {
                //
                // User selected "<none>" option so nullify string
                //

                aUserButtonsText[iButtonIndex][0] = 0;
            }
            else
            {
                GetDlgItemText(
                    hwnd,
                    IDC_EDIT1,
                    (LPSTR) &aUserButtonsText[iButtonIndex],
                    MAX_USER_BUTTON_TEXT_SIZE - 1
                    );

                aUserButtonsText[iButtonIndex][MAX_USER_BUTTON_TEXT_SIZE - 1] =
                    0;
            }

            SetDlgItemText(
                ghwndMain,
                IDC_BUTTON13 + iButtonIndex,
                (LPSTR) &aUserButtonsText[iButtonIndex]
                );

            // Fall thru to IDCANCEL code
        }
        case IDCANCEL:

            EndDialog (hwnd, FALSE);
            break;

        case IDC_LIST1:

IDC_LIST1_selchange:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                LRESULT lButtonSel =
                    SendDlgItemMessage(hwnd, IDC_LIST1, LB_GETCURSEL, 0, 0);


                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_SETCURSEL,
                    (WPARAM) aUserButtonFuncs[lButtonSel],
                    0
                    );

                SetDlgItemText(
                    hwnd,
                    IDC_EDIT1,
                    aUserButtonsText[lButtonSel]
                    );
            }
            break;

        } // switch

        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\error.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    error.h

Abstract:

    Header file for errors in this module

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#ifndef __ERROR_H__
#define __ERROR_H__

#include "tsecerr.h"

#define FACILITY_TSEC_CODE  0x100

#define HRESULT_FROM_TSEC(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_TSEC_CODE << 16) | 0x80000000)))

#define TSECERR_SUCCESS         HRESULT_FROM_TSEC(TSEC_SUCCESS)
#define TSECERR_NOMEM           HRESULT_FROM_TSEC(TSEC_NOMEM)
#define TSECERR_BADFILENAME     HRESULT_FROM_TSEC(TSEC_BADFILENAME)
#define TSECERR_FILENOTEXIST    HRESULT_FROM_TSEC(TSEC_FILENOTEXIST)
#define TSECERR_INVALFILEFORMAT HRESULT_FROM_TSEC(TSEC_INVALFILEFORMAT)
#define TSECERR_DEVLOCALONLY    HRESULT_FROM_TSEC(TSEC_DEVLOCALONLY)

#endif // error.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\ids.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    ids.cpp

Abstract:

    Source file module for string resource manipulation

Author:

    Elena Apreutesei (elenaap)    30-October-2000

Revision History:

--*/

#include "windows.h"
#include "util.h"

HMODULE CIds::m_hModule = NULL;

void CIds::GetModuleHnd (void)
{
    if (!m_hModule)
    {
        m_hModule = GetModuleHandle(NULL);
    }
}

void CIds::LoadIds (UINT resourceID)
{
    TCHAR szBuffer[ MAX_IDS_BUFFER_SIZE ];

    if (m_hModule != NULL &&
        LoadString (
            m_hModule,
            resourceID,
            szBuffer,
            MAX_IDS_BUFFER_SIZE - 1 ) > 0)
    {
        m_szString = new TCHAR [ _tcslen( szBuffer ) + 1 ];
        if ( m_szString )
        {
            _tcscpy( m_szString, szBuffer );
        }
    }
    else
    {
        m_szString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\widget.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    widget.c

Abstract:

    Widget creation/management/deletion support for TAPI Browser util.

Author:

    Dan Knudson (DanKn)    23-Aug-1994

Revision History:

--*/


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include "tb.h"
#include "vars.h"



void
UpdateWidgetList(
    void
    )
{
    int         i;
    LRESULT     lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    PMYWIDGET   pWidget = aWidgets, pSelWidget = (PMYWIDGET) NULL;


    if (lSel != LB_ERR)
    {
        pSelWidget = (PMYWIDGET) SendMessage(
            ghwndList1,
            LB_GETITEMDATA,
            (WPARAM) lSel,
            0
            );
    }

    SendMessage (ghwndList1, LB_RESETCONTENT, 0, 0);

    for (i = 0; pWidget; i++)
    {
        char buf[64];


        switch (pWidget->dwType)
        {
        case WT_LINEAPP:

            sprintf (buf, "LineApp=x%lx", ((PMYLINEAPP) pWidget)->hLineApp);
            break;

        case WT_LINE:
        {
            PMYLINE pLine = (PMYLINE) pWidget;


            sprintf(
                buf,
                "  Line=x%lx id=%ld ",
                pLine->hLine,
                pLine->dwDevID
                );

            if (pLine->dwPrivileges & LINECALLPRIVILEGE_NONE)
            {
                strcat (buf, "DialOut");
            }
            else
            {
                if (pLine->dwPrivileges & LINECALLPRIVILEGE_OWNER)
                {
                    strcat (buf, "DialInOut");
                }

                if (pLine->dwPrivileges & LINECALLPRIVILEGE_MONITOR)
                {
                    strcat (buf, " Monitor");
                }
            }

            if (pLine->dwPrivileges & LINEOPENOPTION_PROXY)
            {
                strcat (buf, " Proxy");
            }

            break;
        }
        case WT_CALL:
        {
            PMYCALL pCall = (PMYCALL) pWidget;


            if (pCall->hCall)
            {
                int i;

                for (i = 0; aCallStates[i].dwVal != 0xffffffff; i++)
                {
                    if (pCall->dwCallState == aCallStates[i].dwVal)
                    {
                        break;
                    }
                }

                sprintf(
                    buf,
                    "    Call=x%lx %s %s",
                    pCall->hCall,
                    aCallStates[i].lpszVal,
                    (pCall->bMonitor ? "Monitor" : "Owner")
                    );
            }
            else
            {
                strcpy (buf, "    <MakeCall reply pending>");
            }

            break;
        }
        case WT_PHONEAPP:

            sprintf (buf, "PhoneApp=x%lx", ((PMYPHONEAPP) pWidget)->hPhoneApp);
            break;

        case WT_PHONE:

            sprintf(
                buf,
                "  Phone=x%lx id=%ld",
                ((PMYPHONE) pWidget)->hPhone,
                ((PMYPHONE) pWidget)->dwDevID
                );

            break;
        }

        SendMessage (ghwndList1, LB_INSERTSTRING, (WPARAM) -1, (LPARAM) buf);
        SendMessage (ghwndList1, LB_SETITEMDATA, (WPARAM) i, (LPARAM) pWidget);

        pWidget = pWidget->pNext;
    }


    //
    // Restore selection if appropriate
    //

    if ((lSel != LB_ERR) && ((lSel = (LONG) GetWidgetIndex (pSelWidget)) >= 0))
    {
        SendMessage (ghwndList1, LB_SETCURSEL, (WPARAM) lSel, 0);
    }
}


void
InsertWidgetInList(
    PMYWIDGET pNewWidget,
    PMYWIDGET pWidgetInsertBefore
    )
{
    pNewWidget->pNext = pWidgetInsertBefore;

    if ((aWidgets == NULL) || (pWidgetInsertBefore == aWidgets))
    {
        aWidgets = pNewWidget;
    }
    else
    {
        PMYWIDGET pPrevWidget = aWidgets;


        while (pPrevWidget->pNext &&
               (pPrevWidget->pNext != pWidgetInsertBefore))
        {
            pPrevWidget = pPrevWidget->pNext;
        }

        pPrevWidget->pNext = pNewWidget;
    }

    UpdateWidgetList();
}


BOOL
RemoveWidgetFromList(
    PMYWIDGET pWidgetToRemove
    )
{
    if (aWidgets == NULL)
    {
        goto RemoveWidgetFromList_error;
    }

    if (pWidgetToRemove == aWidgets)
    {
        aWidgets = pWidgetToRemove->pNext;
    }
    else
    {
        PMYWIDGET pPrevWidget = aWidgets;


        while (pPrevWidget->pNext && (pPrevWidget->pNext != pWidgetToRemove))
        {
            pPrevWidget = pPrevWidget->pNext;
        }

        if (pPrevWidget->pNext == NULL)
        {
            goto RemoveWidgetFromList_error;
        }

        pPrevWidget->pNext = pWidgetToRemove->pNext;
    }

    free (pWidgetToRemove);

    UpdateWidgetList();

    return TRUE;

RemoveWidgetFromList_error:

    ShowStr ("Error: pWidget x%lx not found in list", pWidgetToRemove);

    return FALSE;
}


PMYLINEAPP
AllocLineApp(
    void
    )
{
    PMYLINEAPP pNewLineApp = (PMYLINEAPP) malloc (sizeof(MYLINEAPP));


    if (pNewLineApp)
    {
        PMYWIDGET pWidget = aWidgets;


        memset (pNewLineApp, 0, sizeof(MYLINEAPP));
        pNewLineApp->Widget.dwType = WT_LINEAPP;


        //
        // Insert new line app after all existing line apps, lines, & calls,
        // and before any existing phone apps
        //

        while (pWidget && (pWidget->dwType != WT_PHONEAPP))
        {
            // assert (pWidget->dwType != WT_PHONE)

            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewLineApp, pWidget);
    }

    return pNewLineApp;
}


PMYLINEAPP
GetLineApp(
    HLINEAPP hLineApp
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_LINEAPP)
        {
            PMYLINEAPP pLineApp = (PMYLINEAPP) pWidget;


            if (pLineApp->hLineApp == hLineApp)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYLINEAPP) pWidget);
}


VOID
FreeLineApp(
    PMYLINEAPP pLineApp
    )
{
    PMYWIDGET pWidget = pLineApp->Widget.pNext;


    // BUGBUG chk validity of pLineApp

    if (RemoveWidgetFromList ((PMYWIDGET) pLineApp))
    {
        while (pWidget &&
               (pWidget->dwType != WT_LINEAPP) &&
               (pWidget->dwType != WT_PHONEAPP))
        {
            PMYWIDGET pWidget2 = pWidget->pNext;


            // assert (pWidget->dwType != WT_PHONE)

            RemoveWidgetFromList (pWidget);
            pWidget = pWidget2;
        }
    }
}


PMYLINE
AllocLine(
    PMYLINEAPP pLineApp
    )
{
    PMYLINE pNewLine = (PMYLINE) malloc (sizeof(MYLINE));


    if (pNewLine)
    {
        PMYWIDGET pWidget = (PMYWIDGET) pLineApp->Widget.pNext;


        memset (pNewLine, 0, sizeof(MYLINE));
        pNewLine->Widget.dwType = WT_LINE;
        pNewLine->pLineApp = pLineApp;


        //
        // Insert new line after all existing lines & calls on specfied
        // line app, but before the next line app or phone app
        //

        while (pWidget &&
               (pWidget->dwType != WT_LINEAPP) &&
               (pWidget->dwType != WT_PHONEAPP))
        {
            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewLine, pWidget);
    }

    return pNewLine;
}


PMYLINE
GetLine(
    HLINE hLine
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_LINE)
        {
            PMYLINE pLine = (PMYLINE) pWidget;


            if (pLine->hLine == hLine)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYLINE) pWidget);
}


VOID
FreeLine(
    PMYLINE pLine
    )
{
    PMYWIDGET pWidget = pLine->Widget.pNext;


    if (RemoveWidgetFromList ((PMYWIDGET) pLine))
    {
        while (pWidget &&
               (pWidget->dwType == WT_CALL))
        {
            PMYWIDGET pWidget2 = pWidget->pNext;


            RemoveWidgetFromList (pWidget);
            pWidget = pWidget2;
        }
    }
}


PMYCALL
AllocCall(
    PMYLINE pLine
    )
{
    PMYCALL pNewCall = (PMYCALL) malloc (sizeof(MYCALL));


    if (pNewCall)
    {
        PMYWIDGET pWidget = (PMYWIDGET) pLine->Widget.pNext;


        memset (pNewCall, 0, sizeof(MYCALL));
        pNewCall->Widget.dwType = WT_CALL;
        pNewCall->pLine = pLine;

        //
        // Insert new call after all existing calls on specified line,
        // and before the next line, line app, or phone app
        //

        while (pWidget && (pWidget->dwType == WT_CALL))
        {
            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewCall, pWidget);
    }

    return pNewCall;
}


PMYCALL
GetCall(
    HCALL hCall
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_CALL)
        {
            PMYCALL pCall = (PMYCALL) pWidget;


            if (pCall->hCall == hCall)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYCALL) pWidget);
}


VOID
FreeCall(
    PMYCALL pCall
    )
{
    // BUGBUG chk validity of pCall

    RemoveWidgetFromList ((PMYWIDGET) pCall);
}


VOID
MoveCallToLine(
    PMYCALL pCall,
    HLINE hLine
    )
{
    //
    // This func gets called when a user has invoked an op that requires
    // creating a call, and we did an AllocCall() based on the currently
    // selected line/calls, but in the call params dlg the user overrode
    // the default hLine/hCall, and so we need to move the call widget
    // in the global list from under the orig specified line widget to
    // the line widget corresponding to the specified "hLine". (Note that
    // this is not a simple matter of free-ing & realloc-ing another call,
    // since TAPI saved the &pCall->hCall.)
    //

    PMYWIDGET pWidget = aWidgets;


    //
    // Remove call widget from the global list
    //

    while (pWidget->pNext != (PMYWIDGET) pCall)
    {
        pWidget = pWidget->pNext;
    }

    pWidget->pNext = pCall->Widget.pNext;


    //
    // Find the right place to insert it in list, then insert it
    //

    pWidget = (PMYWIDGET) GetLine (hLine);

    pCall->pLine = (PMYLINE) pWidget;

    while (pWidget->pNext && (pWidget->pNext->dwType == WT_CALL))
    {
        pWidget = pWidget->pNext;
    }

    pCall->Widget.pNext = pWidget->pNext;
    pWidget->pNext = (PMYWIDGET) pCall;

    UpdateWidgetList();
}


PMYPHONEAPP
AllocPhoneApp(
    void
    )
{
    PMYPHONEAPP pNewPhoneApp = (PMYPHONEAPP) malloc (sizeof(MYPHONEAPP));


    if (pNewPhoneApp)
    {
        PMYWIDGET pWidget = aWidgets;


        memset (pNewPhoneApp, 0, sizeof(MYPHONEAPP));
        pNewPhoneApp->Widget.dwType = WT_PHONEAPP;


        //
        // Insert new phone app at end of list
        //

        InsertWidgetInList ((PMYWIDGET) pNewPhoneApp, (PMYWIDGET) NULL);
    }

    return pNewPhoneApp;
}


PMYPHONEAPP
GetPhoneApp(
    HPHONEAPP hPhoneApp
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_PHONEAPP)
        {
            PMYPHONEAPP pPhoneApp = (PMYPHONEAPP) pWidget;


            if (pPhoneApp->hPhoneApp == hPhoneApp)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYPHONEAPP) pWidget);
}


VOID
FreePhoneApp(
    PMYPHONEAPP pPhoneApp
    )
{
    PMYWIDGET pWidget = pPhoneApp->Widget.pNext;


    if (RemoveWidgetFromList ((PMYWIDGET) pPhoneApp))
    {
        while (pWidget && (pWidget->dwType == WT_PHONE))
        {
            PMYWIDGET pWidget2 = pWidget->pNext;


            RemoveWidgetFromList (pWidget);
            pWidget = pWidget2;
        }
    }
}


PMYPHONE
AllocPhone(
    PMYPHONEAPP pPhoneApp
    )
{
    PMYPHONE pNewPhone = (PMYPHONE) malloc (sizeof(MYPHONE));


    if (pNewPhone)
    {
        PMYWIDGET pWidget = (PMYWIDGET) pPhoneApp->Widget.pNext;


        memset (pNewPhone, 0, sizeof(MYPHONE));
        pNewPhone->Widget.dwType = WT_PHONE;
        pNewPhone->pPhoneApp = pPhoneApp;


        //
        // Insert new phone after all phones on the specified phone app,
        // and before the next phone app
        //

        while (pWidget && (pWidget->dwType == WT_PHONE))
        {
            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewPhone, pWidget);
    }

    return pNewPhone;
}


PMYPHONE
GetPhone(
    HPHONE hPhone
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_PHONE)
        {
            PMYPHONE pPhone = (PMYPHONE) pWidget;


            if (pPhone->hPhone == hPhone)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYPHONE) pWidget);
}


VOID
FreePhone(
    PMYPHONE pPhone
    )
{
    RemoveWidgetFromList ((PMYWIDGET) pPhone);
}


int
GetWidgetIndex(
    PMYWIDGET pWidget
    )
{
    int i;
    PMYWIDGET pWidget2 = aWidgets;


    for (i = 0; (pWidget2 && (pWidget != pWidget2)); i++)
    {
        pWidget2 = pWidget2->pNext;
    }

    if (!pWidget2)
    {
        i = -1;
    }

    return i;
}


void
SelectWidget(
    PMYWIDGET pWidget
    )
{
    int i;
    PMYWIDGET pWidget2 = aWidgets;


    for (i = 0; pWidget2; i++)
    {
        if (pWidget == pWidget2)
        {
            SendMessage (ghwndList1, LB_SETCURSEL, (WPARAM) i, 0);
            break;
        }

        pWidget2 = pWidget2->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tb\vars.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    vars.c

Abstract:

    Globals for TAPI Browser util.

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


#include <stdio.h>
#include "tb.h"

#ifdef WIN32
#define my_far
#else
#define my_far _far
#endif


PMYWIDGET   aWidgets = (PMYWIDGET) NULL;

FILE        *hLogFile = (FILE *) NULL;
HANDLE      ghInst;
HWND        ghwndMain, ghwndEdit, ghwndList1, ghwndList2;
BOOL        bShowParams = FALSE;
BOOL        gbDeallocateCall = FALSE;
BOOL        gbDisableHandleChecking;
LPVOID      pBigBuf;
DWORD       dwBigBufSize;
DWORD       dwNumPendingMakeCalls = 0;
DWORD       dwNumPendingDrops = 0;
DWORD       gdwNumLineDevs = 0;
DWORD       gdwNumPhoneDevs = 0;
BOOL        bDumpParams = FALSE;
BOOL        bTimeStamp;
DWORD       bNukeIdleMonitorCalls;
DWORD       bNukeIdleOwnedCalls;
DWORD       dwDumpStructsFlags;

LPLINECALLPARAMS    lpCallParams;

#if TAPI_2_0
BOOL        gbWideStringParams = FALSE;
LPLINECALLPARAMS    lpCallParamsW;
#endif

DWORD       aUserButtonFuncs[MAX_USER_BUTTONS];
char        aUserButtonsText[MAX_USER_BUTTONS][MAX_USER_BUTTON_TEXT_SIZE];

PMYLINEAPP  pLineAppSel;
PMYLINE     pLineSel;
PMYCALL     pCallSel, pCallSel2;
PMYPHONEAPP pPhoneAppSel;
PMYPHONE    pPhoneSel;

char my_far szDefAppName[MAX_STRING_PARAM_SIZE];
char my_far szDefUserUserInfo[MAX_STRING_PARAM_SIZE];
char my_far szDefDestAddress[MAX_STRING_PARAM_SIZE];
char my_far szDefLineDeviceClass[MAX_STRING_PARAM_SIZE];
char my_far szDefPhoneDeviceClass[MAX_STRING_PARAM_SIZE];

char far   *lpszDefAppName;
char far   *lpszDefUserUserInfo;
char far   *lpszDefDestAddress;
char far   *lpszDefLineDeviceClass;
char far   *lpszDefPhoneDeviceClass;

char my_far szTab[] = "  ";
char my_far szCurrVer[] = "1.1";


// help char my_far szTapiHlp[256] = "";
// help char my_far szTspiHlp[256] = "";

DWORD       dwDefAddressID;
DWORD       dwDefLineAPIVersion;
DWORD       dwDefBearerMode;
DWORD       dwDefCountryCode;
DWORD       dwDefLineDeviceID;
DWORD       dwDefLineExtVersion;
DWORD       dwDefMediaMode;
DWORD       dwDefLinePrivilege;
DWORD       dwDefPhoneAPIVersion;
DWORD       dwDefPhoneDeviceID;
DWORD       dwDefPhoneExtVersion;
DWORD       dwDefPhonePrivilege;

#if TAPI_2_0
HANDLE      ghCompletionPort;
#endif

char aAscii[] =
{
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126, 46,

     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46
};



LOOKUP my_far aAddressCapFlags[] =
{
    { LINEADDRCAPFLAGS_FWDNUMRINGS      ,"FWDNUMRINGS"      },
    { LINEADDRCAPFLAGS_PICKUPGROUPID    ,"PICKUPGROUPID"    },
    { LINEADDRCAPFLAGS_SECURE           ,"SECURE"           },
    { LINEADDRCAPFLAGS_BLOCKIDDEFAULT   ,"BLOCKIDDEFAULT"   },
    { LINEADDRCAPFLAGS_BLOCKIDOVERRIDE  ,"BLOCKIDOVERRIDE"  },
    { LINEADDRCAPFLAGS_DIALED           ,"DIALED"           },
    { LINEADDRCAPFLAGS_ORIGOFFHOOK      ,"ORIGOFFHOOK"      },
    { LINEADDRCAPFLAGS_DESTOFFHOOK      ,"DESTOFFHOOK"      },
    { LINEADDRCAPFLAGS_FWDCONSULT       ,"FWDCONSULT"       },
    { LINEADDRCAPFLAGS_SETUPCONFNULL    ,"SETUPCONFNULL"    },
    { LINEADDRCAPFLAGS_AUTORECONNECT    ,"AUTORECONNECT"    },
    { LINEADDRCAPFLAGS_COMPLETIONID     ,"COMPLETIONID"     },
    { LINEADDRCAPFLAGS_TRANSFERHELD     ,"TRANSFERHELD"     },
    { LINEADDRCAPFLAGS_TRANSFERMAKE     ,"TRANSFERMAKE"     },
    { LINEADDRCAPFLAGS_CONFERENCEHELD   ,"CONFERENCEHELD"   },
    { LINEADDRCAPFLAGS_CONFERENCEMAKE   ,"CONFERENCEMAKE"   },
    { LINEADDRCAPFLAGS_PARTIALDIAL      ,"PARTIALDIAL"      },
    { LINEADDRCAPFLAGS_FWDSTATUSVALID   ,"FWDSTATUSVALID"   },
    { LINEADDRCAPFLAGS_FWDINTEXTADDR    ,"FWDINTEXTADDR"    },
    { LINEADDRCAPFLAGS_FWDBUSYNAADDR    ,"FWDBUSYNAADDR"    },
    { LINEADDRCAPFLAGS_ACCEPTTOALERT    ,"ACCEPTTOALERT"    },
    { LINEADDRCAPFLAGS_CONFDROP         ,"CONFDROP"         },
    { LINEADDRCAPFLAGS_PICKUPCALLWAIT   ,"PICKUPCALLWAIT"   },
#if TAPI_2_0
    { LINEADDRCAPFLAGS_PREDICTIVEDIALER ,"PREDICTIVEDIALER" },
    { LINEADDRCAPFLAGS_QUEUE            ,"QUEUE"            },
    { LINEADDRCAPFLAGS_ROUTEPOINT       ,"ROUTEPOINT"       },
    { LINEADDRCAPFLAGS_HOLDMAKESNEW     ,"HOLDMAKESNEW"     },
    { LINEADDRCAPFLAGS_NOINTERNALCALLS  ,"NOINTERNALCALLS"  },
    { LINEADDRCAPFLAGS_NOEXTERNALCALLS  ,"NOEXTERNALCALLS"  },
    { LINEADDRCAPFLAGS_SETCALLINGID     ,"SETCALLINGID"     },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressModes[] =
{
    { LINEADDRESSMODE_ADDRESSID         ,"ADDRESSID"        },
    { LINEADDRESSMODE_DIALABLEADDR      ,"DIALABLEADDR"     },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressSharing[] =
{
    { LINEADDRESSSHARING_PRIVATE        ,"PRIVATE"          },
    { LINEADDRESSSHARING_BRIDGEDEXCL    ,"BRIDGEDEXCL"      },
    { LINEADDRESSSHARING_BRIDGEDNEW     ,"BRIDGEDNEW"       },
    { LINEADDRESSSHARING_BRIDGEDSHARED  ,"BRIDGEDSHARED"    },
    { LINEADDRESSSHARING_MONITORED      ,"MONITORED"        },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER            ,"OTHER"            },
    { LINEADDRESSSTATE_DEVSPECIFIC      ,"DEVSPECIFIC"      },
    { LINEADDRESSSTATE_INUSEZERO        ,"INUSEZERO"        },
    { LINEADDRESSSTATE_INUSEONE         ,"INUSEONE"         },
    { LINEADDRESSSTATE_INUSEMANY        ,"INUSEMANY"        },
    { LINEADDRESSSTATE_NUMCALLS         ,"NUMCALLS"         },
    { LINEADDRESSSTATE_FORWARD          ,"FORWARD"          },
    { LINEADDRESSSTATE_TERMINALS        ,"TERMINALS"        },
#if TAPI_1_1
    { LINEADDRESSSTATE_CAPSCHANGE       ,"CAPSCHANGE"       },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressFeatures[] =
{
    { LINEADDRFEATURE_FORWARD           ,"FORWARD"          },
    { LINEADDRFEATURE_MAKECALL          ,"MAKECALL"         },
    { LINEADDRFEATURE_PICKUP            ,"PICKUP"           },
    { LINEADDRFEATURE_SETMEDIACONTROL   ,"SETMEDIACONTROL"  },
    { LINEADDRFEATURE_SETTERMINAL       ,"SETTERMINAL"      },
    { LINEADDRFEATURE_SETUPCONF         ,"SETUPCONF"        },
    { LINEADDRFEATURE_UNCOMPLETECALL    ,"UNCOMPLETECALL"   },
    { LINEADDRFEATURE_UNPARK            ,"UNPARK"           },
#if TAPI_2_0
    { LINEADDRFEATURE_PICKUPHELD        ,"PICKUPHELD   "    },
    { LINEADDRFEATURE_PICKUPGROUP       ,"PICKUPGROUP  "    },
    { LINEADDRFEATURE_PICKUPDIRECT      ,"PICKUPDIRECT "    },
    { LINEADDRFEATURE_PICKUPWAITING     ,"PICKUPWAITING"    },
    { LINEADDRFEATURE_FORWARDFWD        ,"FORWARDFWD   "    },
    { LINEADDRFEATURE_FORWARDDND        ,"FORWARDDND   "    },
#endif
    { 0xffffffff                        ,""                 }
};

#ifdef TAPI_2_0
LOOKUP my_far aAgentStates[] =
{
    { LINEAGENTSTATE_LOGGEDOFF          ,"LOGGEDOFF"        },
    { LINEAGENTSTATE_NOTREADY           ,"NOTREADY"         },
    { LINEAGENTSTATE_READY              ,"READY"            },
    { LINEAGENTSTATE_BUSYACD            ,"BUSYACD"          },
    { LINEAGENTSTATE_BUSYINCOMING       ,"BUSYINCOMING"     },
    { LINEAGENTSTATE_BUSYOUTBOUND       ,"BUSYOUTBOUND"     },
    { LINEAGENTSTATE_BUSYOTHER          ,"BUSYOTHER"        },
    { LINEAGENTSTATE_WORKINGAFTERCALL   ,"WORKINGAFTERCALL" },
    { LINEAGENTSTATE_UNKNOWN            ,"UNKNOWN"          },
    { LINEAGENTSTATE_UNAVAIL            ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAgentStatus[] =
{
    { LINEAGENTSTATUS_GROUP             ,"GROUP"            },
    { LINEAGENTSTATUS_STATE             ,"STATE"            },
    { LINEAGENTSTATUS_NEXTSTATE         ,"NEXTSTATE"        },
    { LINEAGENTSTATUS_ACTIVITY          ,"ACTIVITY"         },
    { LINEAGENTSTATUS_ACTIVITYLIST      ,"ACTIVITYLIST"     },
    { LINEAGENTSTATUS_GROUPLIST         ,"GROUPLIST"        },
    { LINEAGENTSTATUS_CAPSCHANGE        ,"CAPSCHANGE"       },
    { LINEAGENTSTATUS_VALIDSTATES       ,"VALIDSTATES"      },
    { LINEAGENTSTATUS_VALIDNEXTSTATES   ,"VALIDNEXTSTATES"  },
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aAnswerModes[] =
{
    { LINEANSWERMODE_NONE               ,"NONE"             },
    { LINEANSWERMODE_DROP               ,"DROP"             },
    { LINEANSWERMODE_HOLD               ,"HOLD"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAPIVersions[] =
{
    { 0x00010003                        ,"TAPI 1.0"         },
#if TAPI_1_1
    { 0x00010004                        ,"TAPI 1.4"         },
#if TAPI_2_0
    { 0x00020000                        ,"TAPI 2.0"         },
#if TAPI_2_1
    { 0x00020001                        ,"TAPI 2.1"         },
#if TAPI_2_2
    { 0x00020002                        ,"TAPI 2.2"         },
#endif
#endif
#endif
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aBearerModes[] =
{
    { LINEBEARERMODE_VOICE              ,"VOICE"            },
    { LINEBEARERMODE_SPEECH             ,"SPEECH"           },
    { LINEBEARERMODE_MULTIUSE           ,"MULTIUSE"         },
    { LINEBEARERMODE_DATA               ,"DATA"             },
    { LINEBEARERMODE_ALTSPEECHDATA      ,"ALTSPEECHDATA"    },
    { LINEBEARERMODE_NONCALLSIGNALING   ,"NONCALLSIGNALING" },
#if TAPI_1_1
    { LINEBEARERMODE_PASSTHROUGH        ,"PASSTHROUGH"      },
#if TAPI_2_0
    { LINEBEARERMODE_RESTRICTEDDATA     ,"RESTRICTEDDATA"   },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aBusyModes[] =
{
    { LINEBUSYMODE_STATION              ,"STATION"          },
    { LINEBUSYMODE_TRUNK                ,"TRUNK"            },
    { LINEBUSYMODE_UNKNOWN              ,"UNKNOWN"          },
    { LINEBUSYMODE_UNAVAIL              ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallComplConds[] =
{
    { LINECALLCOMPLCOND_BUSY            ,"BUSY"             },
    { LINECALLCOMPLCOND_NOANSWER        ,"NOANSWER"         },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallComplModes[] =
{
    { LINECALLCOMPLMODE_CAMPON          ,"CAMPON"           },
    { LINECALLCOMPLMODE_CALLBACK        ,"CALLBACK"         },
    { LINECALLCOMPLMODE_INTRUDE         ,"INTRUDE"          },
    { LINECALLCOMPLMODE_MESSAGE         ,"MESSAGE"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallFeatures[] =
{
    { LINECALLFEATURE_ACCEPT            ,"ACCEPT"           },
    { LINECALLFEATURE_ADDTOCONF         ,"ADDTOCONF"        },
    { LINECALLFEATURE_ANSWER            ,"ANSWER"           },
    { LINECALLFEATURE_BLINDTRANSFER     ,"BLINDTRANSFER"    },
    { LINECALLFEATURE_COMPLETECALL      ,"COMPLETECALL"     },
    { LINECALLFEATURE_COMPLETETRANSF    ,"COMPLETETRANSF"   },
    { LINECALLFEATURE_DIAL              ,"DIAL"             },
    { LINECALLFEATURE_DROP              ,"DROP"             },
    { LINECALLFEATURE_GATHERDIGITS      ,"GATHERDIGITS"     },
    { LINECALLFEATURE_GENERATEDIGITS    ,"GENERATEDIGITS"   },
    { LINECALLFEATURE_GENERATETONE      ,"GENERATETONE"     },
    { LINECALLFEATURE_HOLD              ,"HOLD"             },
    { LINECALLFEATURE_MONITORDIGITS     ,"MONITORDIGITS"    },
    { LINECALLFEATURE_MONITORMEDIA      ,"MONITORMEDIA"     },
    { LINECALLFEATURE_MONITORTONES      ,"MONITORTONES"     },
    { LINECALLFEATURE_PARK              ,"PARK"             },
    { LINECALLFEATURE_PREPAREADDCONF    ,"PREPAREADDCONF"   },
    { LINECALLFEATURE_REDIRECT          ,"REDIRECT"         },
    { LINECALLFEATURE_REMOVEFROMCONF    ,"REMOVEFROMCONF"   },
    { LINECALLFEATURE_SECURECALL        ,"SECURECALL"       },
    { LINECALLFEATURE_SENDUSERUSER      ,"SENDUSERUSER"     },
    { LINECALLFEATURE_SETCALLPARAMS     ,"SETCALLPARAMS"    },
    { LINECALLFEATURE_SETMEDIACONTROL   ,"SETMEDIACONTROL"  },
    { LINECALLFEATURE_SETTERMINAL       ,"SETTERMINAL"      },
    { LINECALLFEATURE_SETUPCONF         ,"SETUPCONF"        },
    { LINECALLFEATURE_SETUPTRANSFER     ,"SETUPTRANSFER"    },
    { LINECALLFEATURE_SWAPHOLD          ,"SWAPHOLD"         },
    { LINECALLFEATURE_UNHOLD            ,"UNHOLD"           },
#if TAPI_1_1
    { LINECALLFEATURE_RELEASEUSERUSERINFO   ,"RELEASEUSERUSERINFO"  },
#if TAPI_2_0
    { LINECALLFEATURE_SETTREATMENT      ,"SETTREATMENT"     },
    { LINECALLFEATURE_SETQOS            ,"SETQOS"           },
    { LINECALLFEATURE_SETCALLDATA       ,"SETCALLDATA"      },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aCallFeatures2[] =
{
    { LINECALLFEATURE2_NOHOLDCONFERENCE ,"NOHOLDCONFERENCE" },
    { LINECALLFEATURE2_ONESTEPTRANSFER  ,"ONESTEPTRANSFER " },
    { LINECALLFEATURE2_COMPLCAMPON      ,"COMPLCAMPON"      },
    { LINECALLFEATURE2_COMPLCALLBACK    ,"COMPLCALLBACK"    },
    { LINECALLFEATURE2_COMPLINTRUDE     ,"COMPLINTRUDE"     },
    { LINECALLFEATURE2_COMPLMESSAGE     ,"COMPLMESSAGE"     },
    { LINECALLFEATURE2_TRANSFERNORM     ,"TRANSFERNORM"     },
    { LINECALLFEATURE2_TRANSFERCONF     ,"TRANSFERCONF"     },
    { LINECALLFEATURE2_PARKDIRECT       ,"PARKDIRECT"       },
    { LINECALLFEATURE2_PARKNONDIRECT    ,"PARKNONDIRECT"    },

    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER           ,"OTHER"            },
    { LINECALLINFOSTATE_DEVSPECIFIC     ,"DEVSPECIFIC"      },
    { LINECALLINFOSTATE_BEARERMODE      ,"BEARERMODE"       },
    { LINECALLINFOSTATE_RATE            ,"RATE"             },
    { LINECALLINFOSTATE_MEDIAMODE       ,"MEDIAMODE"        },
    { LINECALLINFOSTATE_APPSPECIFIC     ,"APPSPECIFIC"      },
    { LINECALLINFOSTATE_CALLID          ,"CALLID"           },
    { LINECALLINFOSTATE_RELATEDCALLID   ,"RELATEDCALLID"    },
    { LINECALLINFOSTATE_ORIGIN          ,"ORIGIN"           },
    { LINECALLINFOSTATE_REASON          ,"REASON"           },
    { LINECALLINFOSTATE_COMPLETIONID    ,"COMPLETIONID"     },
    { LINECALLINFOSTATE_NUMOWNERINCR    ,"NUMOWNERINCR"     },
    { LINECALLINFOSTATE_NUMOWNERDECR    ,"NUMOWNERDECR"     },
    { LINECALLINFOSTATE_NUMMONITORS     ,"NUMMONITORS"      },
    { LINECALLINFOSTATE_TRUNK           ,"TRUNK"            },
    { LINECALLINFOSTATE_CALLERID        ,"CALLERID"         },
    { LINECALLINFOSTATE_CALLEDID        ,"CALLEDID"         },
    { LINECALLINFOSTATE_CONNECTEDID     ,"CONNECTEDID"      },
    { LINECALLINFOSTATE_REDIRECTIONID   ,"REDIRECTIONID"    },
    { LINECALLINFOSTATE_REDIRECTINGID   ,"REDIRECTINGID"    },
    { LINECALLINFOSTATE_DISPLAY         ,"DISPLAY"          },
    { LINECALLINFOSTATE_USERUSERINFO    ,"USERUSERINFO"     },
    { LINECALLINFOSTATE_HIGHLEVELCOMP   ,"HIGHLEVELCOMP"    },
    { LINECALLINFOSTATE_LOWLEVELCOMP    ,"LOWLEVELCOMP"     },
    { LINECALLINFOSTATE_CHARGINGINFO    ,"CHARGINGINFO"     },
    { LINECALLINFOSTATE_TERMINAL        ,"TERMINAL"         },
    { LINECALLINFOSTATE_DIALPARAMS      ,"DIALPARAMS"       },
    { LINECALLINFOSTATE_MONITORMODES    ,"MONITORMODES"     },
#if TAPI_2_0
    { LINECALLINFOSTATE_TREATMENT       ,"TREATMENT"        },
    { LINECALLINFOSTATE_QOS             ,"QOS"              },
    { LINECALLINFOSTATE_CALLDATA        ,"CALLDATA"         },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallOrigins[] =
{
    { LINECALLORIGIN_OUTBOUND           ,"OUTBOUND"         },
    { LINECALLORIGIN_INTERNAL           ,"INTERNAL"         },
    { LINECALLORIGIN_EXTERNAL           ,"EXTERNAL"         },
    { LINECALLORIGIN_UNKNOWN            ,"UNKNOWN"          },
    { LINECALLORIGIN_UNAVAIL            ,"UNAVAIL"          },
    { LINECALLORIGIN_CONFERENCE         ,"CONFERENCE"       },
#if TAPI_1_1
    { LINECALLORIGIN_INBOUND            ,"INBOUND"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallParamFlags[] =
{
    { LINECALLPARAMFLAGS_SECURE         ,"SECURE"           },
    { LINECALLPARAMFLAGS_IDLE           ,"IDLE"             },
    { LINECALLPARAMFLAGS_BLOCKID        ,"BLOCKID"          },
    { LINECALLPARAMFLAGS_ORIGOFFHOOK    ,"ORIGOFFHOOK"      },
    { LINECALLPARAMFLAGS_DESTOFFHOOK    ,"DESTOFFHOOK"      },
#if TAPI_2_0
    { LINECALLPARAMFLAGS_NOHOLDCONFERENCE   ,"NOHOLDCONFERENCE" },
    { LINECALLPARAMFLAGS_PREDICTIVEDIAL ,"PREDICTIVEDIAL"   },
    { LINECALLPARAMFLAGS_ONESTEPTRANSFER,"ONESTEPTRANSFER"  },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallerIDFlags[] =
{
    { LINECALLPARTYID_BLOCKED           ,"BLOCKED"          },
    { LINECALLPARTYID_OUTOFAREA         ,"OUTOFAREA"        },
    { LINECALLPARTYID_NAME              ,"NAME"             },
    { LINECALLPARTYID_ADDRESS           ,"ADDRESS"          },
    { LINECALLPARTYID_PARTIAL           ,"PARTIAL"          },
    { LINECALLPARTYID_UNKNOWN           ,"UNKNOWN"          },
    { LINECALLPARTYID_UNAVAIL           ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallPrivileges[] =
{
    { LINECALLPRIVILEGE_NONE            ,"NONE"             },
    { LINECALLPRIVILEGE_MONITOR         ,"MONITOR"          },
    { LINECALLPRIVILEGE_OWNER           ,"OWNER"            },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallReasons[] =
{
    { LINECALLREASON_DIRECT             ,"DIRECT"           },
    { LINECALLREASON_FWDBUSY            ,"FWDBUSY"          },
    { LINECALLREASON_FWDNOANSWER        ,"FWDNOANSWER"      },
    { LINECALLREASON_FWDUNCOND          ,"FWDUNCOND"        },
    { LINECALLREASON_PICKUP             ,"PICKUP"           },
    { LINECALLREASON_UNPARK             ,"UNPARK"           },
    { LINECALLREASON_REDIRECT           ,"REDIRECT"         },
    { LINECALLREASON_CALLCOMPLETION     ,"CALLCOMPLETION"   },
    { LINECALLREASON_TRANSFER           ,"TRANSFER"         },
    { LINECALLREASON_REMINDER           ,"REMINDER"         },
    { LINECALLREASON_UNKNOWN            ,"UNKNOWN"          },
    { LINECALLREASON_UNAVAIL            ,"UNAVAIL"          },
#if TAPI_1_1
    { LINECALLREASON_INTRUDE            ,"INTRUDE"          },
    { LINECALLREASON_PARKED             ,"PARKED"           },
#if TAPI_2_0
    { LINECALLREASON_CAMPEDON           ,"CAMPEDON"         },
    { LINECALLREASON_ROUTEREQUEST       ,"ROUTEREQUEST"     },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallSelects[] =
{
    { LINECALLSELECT_LINE               ,"LINE"             },
    { LINECALLSELECT_ADDRESS            ,"ADDRESS"          },
    { LINECALLSELECT_CALL               ,"CALL"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallStates[] =
{
    { LINECALLSTATE_IDLE                ,"IDLE"             },
    { LINECALLSTATE_OFFERING            ,"OFFERING"         },
    { LINECALLSTATE_ACCEPTED            ,"ACCEPTED"         },
    { LINECALLSTATE_DIALTONE            ,"DIALTONE"         },
    { LINECALLSTATE_DIALING             ,"DIALING"          },
    { LINECALLSTATE_RINGBACK            ,"RINGBACK"         },
    { LINECALLSTATE_BUSY                ,"BUSY"             },
    { LINECALLSTATE_SPECIALINFO         ,"SPECIALINFO"      },
    { LINECALLSTATE_CONNECTED           ,"CONNECTED"        },
    { LINECALLSTATE_PROCEEDING          ,"PROCEEDING"       },
    { LINECALLSTATE_ONHOLD              ,"ONHOLD"           },
    { LINECALLSTATE_CONFERENCED         ,"CONFERENCED"      },
    { LINECALLSTATE_ONHOLDPENDCONF      ,"ONHOLDPENDCONF"   },
    { LINECALLSTATE_ONHOLDPENDTRANSFER  ,"ONHOLDPENDTRANSFER" },
    { LINECALLSTATE_DISCONNECTED        ,"DISCONNECTED"     },
    { LINECALLSTATE_UNKNOWN             ,"UNKNOWN"          },
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aCallTreatments[] =
{
    { LINECALLTREATMENT_SILENCE         ,"SILENCE"          },
    { LINECALLTREATMENT_RINGBACK        ,"RINGBACK"         },
    { LINECALLTREATMENT_BUSY            ,"BUSY"             },
    { LINECALLTREATMENT_MUSIC           ,"MUSIC"            },
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aCardOptions[] =
{
#if TAPI_1_1
    { LINECARDOPTION_PREDEFINED         ,"PREDEFINED"       },
    { LINECARDOPTION_HIDDEN             ,"HIDDEN"           },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aConnectedModes[] =
{
#if TAPI_1_1
    { LINECONNECTEDMODE_ACTIVE          ,"ACTIVE"           },
    { LINECONNECTEDMODE_INACTIVE        ,"INACTIVE"         },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDevCapsFlags[] =
{
    { LINEDEVCAPFLAGS_CROSSADDRCONF     ,"CROSSADDRCONF"    },
    { LINEDEVCAPFLAGS_HIGHLEVCOMP       ,"HIGHLEVCOMP"      },
    { LINEDEVCAPFLAGS_LOWLEVCOMP        ,"LOWLEVCOMP"       },
    { LINEDEVCAPFLAGS_MEDIACONTROL      ,"MEDIACONTROL"     },
    { LINEDEVCAPFLAGS_MULTIPLEADDR      ,"MULTIPLEADDR"     },
    { LINEDEVCAPFLAGS_CLOSEDROP         ,"CLOSEDROP"        },
    { LINEDEVCAPFLAGS_DIALBILLING       ,"DIALBILLING"      },
    { LINEDEVCAPFLAGS_DIALQUIET         ,"DIALQUIET"        },
    { LINEDEVCAPFLAGS_DIALDIALTONE      ,"DIALDIALTONE"     },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLineDevStatusFlags[] =
{
    { LINEDEVSTATUSFLAGS_CONNECTED      ,"CONNECTED"        },
    { LINEDEVSTATUSFLAGS_MSGWAIT        ,"MSGWAIT"          },
    { LINEDEVSTATUSFLAGS_INSERVICE      ,"INSERVICE"        },
    { LINEDEVSTATUSFLAGS_LOCKED         ,"LOCKED"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDialToneModes[] =
{
    { LINEDIALTONEMODE_NORMAL           ,"NORMAL"           },
    { LINEDIALTONEMODE_SPECIAL          ,"SPECIAL"          },
    { LINEDIALTONEMODE_INTERNAL         ,"INTERNAL"         },
    { LINEDIALTONEMODE_EXTERNAL         ,"EXTERNAL"         },
    { LINEDIALTONEMODE_UNKNOWN          ,"UNKNOWN"          },
    { LINEDIALTONEMODE_UNAVAIL          ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDigitModes[] =
{
    { LINEDIGITMODE_PULSE               ,"PULSE"            },
    { LINEDIGITMODE_DTMF                ,"DTMF"             },
    { LINEDIGITMODE_DTMFEND             ,"DTMFEND"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDisconnectModes[] =
{
    { LINEDISCONNECTMODE_NORMAL         ,"NORMAL"           },
    { LINEDISCONNECTMODE_UNKNOWN        ,"UNKNOWN"          },
    { LINEDISCONNECTMODE_REJECT         ,"REJECT"           },
    { LINEDISCONNECTMODE_PICKUP         ,"PICKUP"           },
    { LINEDISCONNECTMODE_FORWARDED      ,"FORWARDED"        },
    { LINEDISCONNECTMODE_BUSY           ,"BUSY"             },
    { LINEDISCONNECTMODE_NOANSWER       ,"NOANSWER"         },
    { LINEDISCONNECTMODE_BADADDRESS     ,"BADADDRESS"       },
    { LINEDISCONNECTMODE_UNREACHABLE    ,"UNREACHABLE"      },
    { LINEDISCONNECTMODE_CONGESTION     ,"CONGESTION"       },
    { LINEDISCONNECTMODE_INCOMPATIBLE   ,"INCOMPATIBLE"     },
    { LINEDISCONNECTMODE_UNAVAIL        ,"UNAVAIL"          },
#if TAPI_1_1
    { LINEDISCONNECTMODE_NODIALTONE     ,"NODIALTONE"       },
#if TAPI_2_0
    { LINEDISCONNECTMODE_NUMBERCHANGED  ,"NUMBERCHANGED"    },
    { LINEDISCONNECTMODE_OUTOFORDER     ,"OUTOFORDER"       },
    { LINEDISCONNECTMODE_TEMPFAILURE    ,"TEMPFAILURE"      },
    { LINEDISCONNECTMODE_QOSUNAVAIL     ,"QOSUNAVAIL"       },
    { LINEDISCONNECTMODE_BLOCKED        ,"BLOCKED"          },
    { LINEDISCONNECTMODE_DONOTDISTURB   ,"DONOTDISTURB"     },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aLineInitExOptions[] =
{
    { LINEINITIALIZEEXOPTION_USEHIDDENWINDOW
                                        ,"USEHIDDENWINDOW"  },
    { LINEINITIALIZEEXOPTION_USEEVENT   ,"USEEVENT"         },
    { LINEINITIALIZEEXOPTION_USECOMPLETIONPORT
                                        ,"USECOMPLETIONPORT"},
    { 0xffffffff                        ,""                 }
};
#endif

#if TAPI_2_0
LOOKUP my_far aPhoneInitExOptions[] =
{
    { PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW
                                        ,"USEHIDDENWINDOW"  },
    { PHONEINITIALIZEEXOPTION_USEEVENT   ,"USEEVENT"         },
    { PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT
                                        ,"USECOMPLETIONPORT"},
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aLineFeatures[] =
{
    { LINEFEATURE_DEVSPECIFIC           ,"DEVSPECIFIC"      },
    { LINEFEATURE_DEVSPECIFICFEAT       ,"DEVSPECIFICFEAT"  },
    { LINEFEATURE_FORWARD               ,"FORWARD"          },
    { LINEFEATURE_MAKECALL              ,"MAKECALL"         },
    { LINEFEATURE_SETMEDIACONTROL       ,"SETMEDIACONTROL"  },
    { LINEFEATURE_SETTERMINAL           ,"SETTERMINAL"      },
#if TAPI_2_0
    { LINEFEATURE_SETDEVSTATUS          ,"SETDEVSTATUS"     },
    { LINEFEATURE_FORWARDFWD            ,"FORWARDFWD"       },
    { LINEFEATURE_FORWARDDND            ,"FORWARDDND"       },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aForwardModes[] =
{
    { LINEFORWARDMODE_UNCOND            ,"UNCOND"           },
    { LINEFORWARDMODE_UNCONDINTERNAL    ,"UNCONDINTERNAL"   },
    { LINEFORWARDMODE_UNCONDEXTERNAL    ,"UNCONDEXTERNAL"   },
    { LINEFORWARDMODE_UNCONDSPECIFIC    ,"UNCONDSPECIFIC"   },
    { LINEFORWARDMODE_BUSY              ,"BUSY"             },
    { LINEFORWARDMODE_BUSYINTERNAL      ,"BUSYINTERNAL"     },
    { LINEFORWARDMODE_BUSYEXTERNAL      ,"BUSYEXTERNAL"     },
    { LINEFORWARDMODE_BUSYSPECIFIC      ,"BUSYSPECIFIC"     },
    { LINEFORWARDMODE_NOANSW            ,"NOANSW"           },
    { LINEFORWARDMODE_NOANSWINTERNAL    ,"NOANSWINTERNAL"   },
    { LINEFORWARDMODE_NOANSWEXTERNAL    ,"NOANSWEXTERNAL"   },
    { LINEFORWARDMODE_NOANSWSPECIFIC    ,"NOANSWSPECIFIC"   },
    { LINEFORWARDMODE_BUSYNA            ,"BUSYNA"           },
    { LINEFORWARDMODE_BUSYNAINTERNAL    ,"BUSYNAINTERNAL"   },
    { LINEFORWARDMODE_BUSYNAEXTERNAL    ,"BUSYNAEXTERNAL"   },
    { LINEFORWARDMODE_BUSYNASPECIFIC    ,"BUSYNASPECIFIC"   },
#if TAPI_1_1
    { LINEFORWARDMODE_UNKNOWN           ,"UNKNOWN"          },
    { LINEFORWARDMODE_UNAVAIL           ,"UNAVAIL"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aGatherTerms[] =
{
    { LINEGATHERTERM_BUFFERFULL         ,"BUFFERFULL"       },
    { LINEGATHERTERM_TERMDIGIT          ,"TERMDIGIT"        },
    { LINEGATHERTERM_FIRSTTIMEOUT       ,"FIRSTTIMEOUT"     },
    { LINEGATHERTERM_INTERTIMEOUT       ,"INTERTIMEOUT"     },
    { LINEGATHERTERM_CANCEL             ,"CANCEL"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aGenerateTerms[] =
{
    { LINEGENERATETERM_DONE             ,"DONE"             },
    { LINEGENERATETERM_CANCEL           ,"CANCEL"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP aLineOpenOptions[] =
{
    { LINECALLPRIVILEGE_NONE            ,"NONE"             },
    { LINECALLPRIVILEGE_MONITOR         ,"MONITOR"          },
    { LINECALLPRIVILEGE_OWNER           ,"OWNER"            },
#if TAPI_2_0
    { LINEOPENOPTION_PROXY              ,"PROXY"            },
    { LINEOPENOPTION_SINGLEADDRESS      ,"SINGLEADDRESS"    },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLineRoamModes[] =
{
    { LINEROAMMODE_UNKNOWN              ,"UNKNOWN"          },
    { LINEROAMMODE_UNAVAIL              ,"UNAVAIL"          },
    { LINEROAMMODE_HOME                 ,"HOME"             },
    { LINEROAMMODE_ROAMA                ,"ROAMA"            },
    { LINEROAMMODE_ROAMB                ,"ROAMB"            },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLineStates[] =
{
    { LINEDEVSTATE_OTHER                ,"OTHER"            },
    { LINEDEVSTATE_RINGING              ,"RINGING"          },
    { LINEDEVSTATE_CONNECTED            ,"CONNECTED"        },
    { LINEDEVSTATE_DISCONNECTED         ,"DISCONNECTED"     },
    { LINEDEVSTATE_MSGWAITON            ,"MSGWAITON"        },
    { LINEDEVSTATE_MSGWAITOFF           ,"MSGWAITOFF"       },
    { LINEDEVSTATE_INSERVICE            ,"INSERVICE"        },
    { LINEDEVSTATE_OUTOFSERVICE         ,"OUTOFSERVICE"     },
    { LINEDEVSTATE_MAINTENANCE          ,"MAINTENANCE"      },
    { LINEDEVSTATE_OPEN                 ,"OPEN"             },
    { LINEDEVSTATE_CLOSE                ,"CLOSE"            },
    { LINEDEVSTATE_NUMCALLS             ,"NUMCALLS"         },
    { LINEDEVSTATE_NUMCOMPLETIONS       ,"NUMCOMPLETIONS"   },
    { LINEDEVSTATE_TERMINALS            ,"TERMINALS"        },
    { LINEDEVSTATE_ROAMMODE             ,"ROAMMODE"         },
    { LINEDEVSTATE_BATTERY              ,"BATTERY"          },
    { LINEDEVSTATE_SIGNAL               ,"SIGNAL"           },
    { LINEDEVSTATE_DEVSPECIFIC          ,"DEVSPECIFIC"      },
    { LINEDEVSTATE_REINIT               ,"REINIT"           },
    { LINEDEVSTATE_LOCK                 ,"LOCK"             },
#if TAPI_1_1
    { LINEDEVSTATE_CAPSCHANGE           ,"CAPSCHANGE"       },
    { LINEDEVSTATE_CONFIGCHANGE         ,"CONFIGCHANGE"     },
    { LINEDEVSTATE_TRANSLATECHANGE      ,"TRANSLATECHANGE"  },
    { LINEDEVSTATE_COMPLCANCEL          ,"COMPLCANCEL"      },
    { LINEDEVSTATE_REMOVED              ,"REMOVED"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLocationOptions[] =
{
#if TAPI_1_1
    { LINELOCATIONOPTION_PULSEDIAL      ,"PULSEDIAL"        },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN             ,"UNKNOWN"          },
    { LINEMEDIAMODE_INTERACTIVEVOICE    ,"INTERACTIVEVOICE" },
    { LINEMEDIAMODE_AUTOMATEDVOICE      ,"AUTOMATEDVOICE"   },
    { LINEMEDIAMODE_DATAMODEM           ,"DATAMODEM"        },
    { LINEMEDIAMODE_G3FAX               ,"G3FAX"            },
    { LINEMEDIAMODE_TDD                 ,"TDD"              },
    { LINEMEDIAMODE_G4FAX               ,"G4FAX"            },
    { LINEMEDIAMODE_DIGITALDATA         ,"DIGITALDATA"      },
    { LINEMEDIAMODE_TELETEX             ,"TELETEX"          },
    { LINEMEDIAMODE_VIDEOTEX            ,"VIDEOTEX"         },
    { LINEMEDIAMODE_TELEX               ,"TELEX"            },
    { LINEMEDIAMODE_MIXED               ,"MIXED"            },
    { LINEMEDIAMODE_ADSI                ,"ADSI"             },
#if TAPI_1_1
    { LINEMEDIAMODE_VOICEVIEW           ,"VOICEVIEW"        },
#endif
#if TAPI_2_1
    { LINEMEDIAMODE_VIDEO               ,"VIDEO"            },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aMediaControls[] =
{
    { LINEMEDIACONTROL_NONE             ,"NONE"             },
    { LINEMEDIACONTROL_START            ,"START"            },
    { LINEMEDIACONTROL_RESET            ,"RESET"            },
    { LINEMEDIACONTROL_PAUSE            ,"PAUSE"            },
    { LINEMEDIACONTROL_RESUME           ,"RESUME"           },
    { LINEMEDIACONTROL_RATEUP           ,"RATEUP"           },
    { LINEMEDIACONTROL_RATEDOWN         ,"RATEDOWN"         },
    { LINEMEDIACONTROL_RATENORMAL       ,"RATENORMAL"       },
    { LINEMEDIACONTROL_VOLUMEUP         ,"VOLUMEUP"         },
    { LINEMEDIACONTROL_VOLUMEDOWN       ,"VOLUMEDOWN"       },
    { LINEMEDIACONTROL_VOLUMENORMAL     ,"VOLUMENORMAL"     },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aOfferingModes[] =
{
#if TAPI_1_1
    { LINEOFFERINGMODE_ACTIVE           ,"ACTIVE"           },
    { LINEOFFERINGMODE_INACTIVE         ,"INACTIVE"         },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aParkModes[] =
{
    { LINEPARKMODE_DIRECTED             ,"DIRECTED"         },
    { LINEPARKMODE_NONDIRECTED          ,"NONDIRECTED"      },
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aProxyRequests[] =
{
    { LINEPROXYREQUEST_SETAGENTGROUP        ,"SETAGENTGROUP"        },
    { LINEPROXYREQUEST_SETAGENTSTATE        ,"SETAGENTSTATE"        },
    { LINEPROXYREQUEST_SETAGENTACTIVITY     ,"SETAGENTACTIVITY"     },
    { LINEPROXYREQUEST_GETAGENTCAPS         ,"GETAGENTCAPS"         },
    { LINEPROXYREQUEST_GETAGENTSTATUS       ,"GETAGENTSTATUS"       },
    { LINEPROXYREQUEST_AGENTSPECIFIC        ,"AGENTSPECIFIC"        },
    { LINEPROXYREQUEST_GETAGENTACTIVITYLIST ,"GETAGENTACTIVITYLIST" },
    { LINEPROXYREQUEST_GETAGENTGROUPLIST    ,"GETAGENTGROUPLIST"    },
    { 0xffffffff                            ,""                     }
};
#endif

LOOKUP my_far aRemoveFromConfCaps[] =
{
    { LINEREMOVEFROMCONF_NONE           ,"NONE"             },
    { LINEREMOVEFROMCONF_LAST           ,"LAST"             },
    { LINEREMOVEFROMCONF_ANY            ,"ANY"              },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aRequestModes[] =
{
    { LINEREQUESTMODE_MAKECALL          ,"MAKECALL"         },
    { LINEREQUESTMODE_MEDIACALL         ,"MEDIACALL"        },
    { LINEREQUESTMODE_DROP              ,"DROP"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aRequestModes2[] =
{
    { LINEREQUESTMODE_MAKECALL          ,"MAKECALL"         },
    { LINEREQUESTMODE_MEDIACALL         ,"MEDIACALL"        },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aSpecialInfo[] =
{
    { LINESPECIALINFO_NOCIRCUIT         ,"NOCIRCUIT"        },
    { LINESPECIALINFO_CUSTIRREG         ,"CUSTIRREG"        },
    { LINESPECIALINFO_REORDER           ,"REORDER"          },
    { LINESPECIALINFO_UNKNOWN           ,"UNKNOWN"          },
    { LINESPECIALINFO_UNAVAIL           ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS              ,"BUTTONS"          },
    { LINETERMMODE_LAMPS                ,"LAMPS"            },
    { LINETERMMODE_DISPLAY              ,"DISPLAY"          },
    { LINETERMMODE_RINGER               ,"RINGER"           },
    { LINETERMMODE_HOOKSWITCH           ,"HOOKSWITCH"       },
    { LINETERMMODE_MEDIATOLINE          ,"MEDIATOLINE"      },
    { LINETERMMODE_MEDIAFROMLINE        ,"MEDIAFROMLINE"    },
    { LINETERMMODE_MEDIABIDIRECT        ,"MEDIABIDIRECT"    },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTollListOptions[] =
{
    { LINETOLLLISTOPTION_ADD            ,"ADD"              },
    { LINETOLLLISTOPTION_REMOVE         ,"REMOVE"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aToneModes[] =
{
    { LINETONEMODE_CUSTOM               ,"CUSTOM"           },
    { LINETONEMODE_RINGBACK             ,"RINGBACK"         },
    { LINETONEMODE_BUSY                 ,"BUSY"             },
    { LINETONEMODE_BEEP                 ,"BEEP"             },
    { LINETONEMODE_BILLING              ,"BILLING"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER         ,"TRANSFER"         },
    { LINETRANSFERMODE_CONFERENCE       ,"CONFERENCE"       },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTranslateOptions[] =
{
    { LINETRANSLATEOPTION_CARDOVERRIDE  ,"CARDOVERRIDE"     },
#if TAPI_1_1
    { LINETRANSLATEOPTION_CANCELCALLWAITING ,"CANCELCALLWAITING" },
    { LINETRANSLATEOPTION_FORCELOCAL    ,"FORCELOCAL" },
    { LINETRANSLATEOPTION_FORCELD       ,"FORCELD" },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTranslateResults[] =
{
    { LINETRANSLATERESULT_CANONICAL     ,"CANONICAL"        },
    { LINETRANSLATERESULT_INTERNATIONAL ,"INTERNATIONAL"    },
    { LINETRANSLATERESULT_LONGDISTANCE  ,"LONGDISTANCE"     },
    { LINETRANSLATERESULT_LOCAL         ,"LOCAL"            },
    { LINETRANSLATERESULT_INTOLLLIST    ,"INTOLLLIST"       },
    { LINETRANSLATERESULT_NOTINTOLLLIST ,"NOTINTOLLLIST"    },
    { LINETRANSLATERESULT_DIALBILLING   ,"DIALBILLING"      },
    { LINETRANSLATERESULT_DIALQUIET     ,"DIALQUIET"        },
    { LINETRANSLATERESULT_DIALDIALTONE  ,"DIALDIALTONE"     },
    { LINETRANSLATERESULT_DIALPROMPT    ,"DIALPROMPT"       },
#if TAPI_2_0
    { LINETRANSLATERESULT_VOICEDETECT   ,"VOICEDETECT"      },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aButtonFunctions[] =
{
    { PHONEBUTTONFUNCTION_UNKNOWN       ,"UNKNOWN"          },
    { PHONEBUTTONFUNCTION_CONFERENCE    ,"CONFERENCE"       },
    { PHONEBUTTONFUNCTION_TRANSFER      ,"TRANSFER"         },
    { PHONEBUTTONFUNCTION_DROP          ,"DROP"             },
    { PHONEBUTTONFUNCTION_HOLD          ,"HOLD"             },
    { PHONEBUTTONFUNCTION_RECALL        ,"RECALL"           },
    { PHONEBUTTONFUNCTION_DISCONNECT    ,"DISCONNECT"       },
    { PHONEBUTTONFUNCTION_CONNECT       ,"CONNECT"          },
    { PHONEBUTTONFUNCTION_MSGWAITON     ,"MSGWAITON"        },
    { PHONEBUTTONFUNCTION_MSGWAITOFF    ,"MSGWAITOFF"       },
    { PHONEBUTTONFUNCTION_SELECTRING    ,"SELECTRING"       },
    { PHONEBUTTONFUNCTION_ABBREVDIAL    ,"ABBREVDIAL"       },
    { PHONEBUTTONFUNCTION_FORWARD       ,"FORWARD"          },
    { PHONEBUTTONFUNCTION_PICKUP        ,"PICKUP"           },
    { PHONEBUTTONFUNCTION_RINGAGAIN     ,"RINGAGAIN"        },
    { PHONEBUTTONFUNCTION_PARK          ,"PARK"             },
    { PHONEBUTTONFUNCTION_REJECT        ,"REJECT"           },
    { PHONEBUTTONFUNCTION_REDIRECT      ,"REDIRECT"         },
    { PHONEBUTTONFUNCTION_MUTE          ,"MUTE"             },
    { PHONEBUTTONFUNCTION_VOLUMEUP      ,"VOLUMEUP"         },
    { PHONEBUTTONFUNCTION_VOLUMEDOWN    ,"VOLUMEDOWN"       },
    { PHONEBUTTONFUNCTION_SPEAKERON     ,"SPEAKERON"        },
    { PHONEBUTTONFUNCTION_SPEAKEROFF    ,"SPEAKEROFF"       },
    { PHONEBUTTONFUNCTION_FLASH         ,"FLASH"            },
    { PHONEBUTTONFUNCTION_DATAON        ,"DATAON"           },
    { PHONEBUTTONFUNCTION_DATAOFF       ,"DATAOFF"          },
    { PHONEBUTTONFUNCTION_DONOTDISTURB  ,"DONOTDISTURB"     },
    { PHONEBUTTONFUNCTION_INTERCOM      ,"INTERCOM"         },
    { PHONEBUTTONFUNCTION_BRIDGEDAPP    ,"BRIDGEDAPP"       },
    { PHONEBUTTONFUNCTION_BUSY          ,"BUSY"             },
    { PHONEBUTTONFUNCTION_CALLAPP       ,"CALLAPP"          },
    { PHONEBUTTONFUNCTION_DATETIME      ,"DATETIME"         },
    { PHONEBUTTONFUNCTION_DIRECTORY     ,"DIRECTORY"        },
    { PHONEBUTTONFUNCTION_COVER         ,"COVER"            },
    { PHONEBUTTONFUNCTION_CALLID        ,"CALLID"           },
    { PHONEBUTTONFUNCTION_LASTNUM       ,"LASTNUM"          },
    { PHONEBUTTONFUNCTION_NIGHTSRV      ,"NIGHTSRV"         },
    { PHONEBUTTONFUNCTION_SENDCALLS     ,"SENDCALLS"        },
    { PHONEBUTTONFUNCTION_MSGINDICATOR  ,"MSGINDICATOR"     },
    { PHONEBUTTONFUNCTION_REPDIAL       ,"REPDIAL"          },
    { PHONEBUTTONFUNCTION_SETREPDIAL    ,"SETREPDIAL"       },
    { PHONEBUTTONFUNCTION_SYSTEMSPEED   ,"SYSTEMSPEED"      },
    { PHONEBUTTONFUNCTION_STATIONSPEED  ,"STATIONSPEED"     },
    { PHONEBUTTONFUNCTION_CAMPON        ,"CAMPON"           },
    { PHONEBUTTONFUNCTION_SAVEREPEAT    ,"SAVEREPEAT"       },
    { PHONEBUTTONFUNCTION_QUEUECALL     ,"QUEUECALL"        },
    { PHONEBUTTONFUNCTION_NONE          ,"NONE"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY             ,"DUMMY"            },
    { PHONEBUTTONMODE_CALL              ,"CALL"             },
    { PHONEBUTTONMODE_FEATURE           ,"FEATURE"          },
    { PHONEBUTTONMODE_KEYPAD            ,"KEYPAD"           },
    { PHONEBUTTONMODE_LOCAL             ,"LOCAL"            },
    { PHONEBUTTONMODE_DISPLAY           ,"DISPLAY"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP               ,"UP"               },
    { PHONEBUTTONSTATE_DOWN             ,"DOWN"             },
#if TAPI_1_1
    { PHONEBUTTONSTATE_UNKNOWN          ,"UNKNOWN"          },
    { PHONEBUTTONSTATE_UNAVAIL          ,"UNAVAIL"          },
#endif
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aPhoneFeatures[] =
{
    { PHONEFEATURE_GETBUTTONINFO        ,"GETBUTTONINFO"    },
    { PHONEFEATURE_GETDATA              ,"GETDATA"          },
    { PHONEFEATURE_GETDISPLAY           ,"GETDISPLAY"       },
    { PHONEFEATURE_GETGAINHANDSET       ,"GETGAINHANDSET"   },
    { PHONEFEATURE_GETGAINSPEAKER       ,"GETGAINSPEAKER"   },
    { PHONEFEATURE_GETGAINHEADSET       ,"GETGAINHEADSET"   },
    { PHONEFEATURE_GETHOOKSWITCHHANDSET ,"GETHOOKSWITCHHANDSET" },
    { PHONEFEATURE_GETHOOKSWITCHSPEAKER ,"GETHOOKSWITCHSPEAKER" },
    { PHONEFEATURE_GETHOOKSWITCHHEADSET ,"GETHOOKSWITCHHEADSET" },
    { PHONEFEATURE_GETLAMP              ,"GETLAMP"          },
    { PHONEFEATURE_GETRING              ,"GETRING"          },
    { PHONEFEATURE_GETVOLUMEHANDSET     ,"GETVOLUMEHANDSET" },
    { PHONEFEATURE_GETVOLUMESPEAKER     ,"GETVOLUMESPEAKER" },
    { PHONEFEATURE_GETVOLUMEHEADSET     ,"GETVOLUMEHEADSET" },
    { PHONEFEATURE_SETBUTTONINFO        ,"SETBUTTONINFO"    },
    { PHONEFEATURE_SETDATA              ,"SETDATA"          },
    { PHONEFEATURE_SETDISPLAY           ,"SETDISPLAY"       },
    { PHONEFEATURE_SETGAINHANDSET       ,"SETGAINHANDSET"   },
    { PHONEFEATURE_SETGAINSPEAKER       ,"SETGAINSPEAKER"   },
    { PHONEFEATURE_SETGAINHEADSET       ,"SETGAINHEADSET"   },
    { PHONEFEATURE_SETHOOKSWITCHHANDSET ,"SETHOOKSWITCHHANDSET" },
    { PHONEFEATURE_SETHOOKSWITCHSPEAKER ,"SETHOOKSWITCHSPEAKER" },
    { PHONEFEATURE_SETHOOKSWITCHHEADSET ,"SETHOOKSWITCHHEADSET" },
    { PHONEFEATURE_SETLAMP              ,"SETLAMP"          },
    { PHONEFEATURE_SETRING              ,"SETRING"          },
    { PHONEFEATURE_SETVOLUMEHANDSET     ,"SETVOLUMEHANDSET" },
    { PHONEFEATURE_SETVOLUMESPEAKER     ,"SETVOLUMESPEAKER" },
    { PHONEFEATURE_SETVOLUMEHEADSET     ,"SETVOLUMEHEADSET" },
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET        ,"HANDSET"          },
    { PHONEHOOKSWITCHDEV_SPEAKER        ,"SPEAKER"          },
    { PHONEHOOKSWITCHDEV_HEADSET        ,"HEADSET"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK        ,"ONHOOK"           },
    { PHONEHOOKSWITCHMODE_MIC           ,"MIC"              },
    { PHONEHOOKSWITCHMODE_SPEAKER       ,"SPEAKER"          },
    { PHONEHOOKSWITCHMODE_MICSPEAKER    ,"MICSPEAKER"       },
    { PHONEHOOKSWITCHMODE_UNKNOWN       ,"UNKNOWN"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLampModes[] =
{
    { PHONELAMPMODE_DUMMY               ,"DUMMY"            },
    { PHONELAMPMODE_OFF                 ,"OFF"              },
    { PHONELAMPMODE_STEADY              ,"STEADY"           },
    { PHONELAMPMODE_WINK                ,"WINK"             },
    { PHONELAMPMODE_FLASH               ,"FLASH"            },
    { PHONELAMPMODE_FLUTTER             ,"FLUTTER"          },
    { PHONELAMPMODE_BROKENFLUTTER       ,"BROKENFLUTTER"    },
    { PHONELAMPMODE_UNKNOWN             ,"UNKNOWN"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aPhonePrivileges[] =
{
    { PHONEPRIVILEGE_MONITOR            ,"MONITOR"          },
    { PHONEPRIVILEGE_OWNER              ,"OWNER"            },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aPhoneStates[] =
{
    { PHONESTATE_OTHER                  ,"OTHER"            },
    { PHONESTATE_CONNECTED              ,"CONNECTED"        },
    { PHONESTATE_DISCONNECTED           ,"DISCONNECTED"     },
    { PHONESTATE_OWNER                  ,"OWNER"            },
    { PHONESTATE_MONITORS               ,"MONITORS"         },
    { PHONESTATE_DISPLAY                ,"DISPLAY"          },
    { PHONESTATE_LAMP                   ,"LAMP"             },
    { PHONESTATE_RINGMODE               ,"RINGMODE"         },
    { PHONESTATE_RINGVOLUME             ,"RINGVOLUME"       },
    { PHONESTATE_HANDSETHOOKSWITCH      ,"HANDSETHOOKSWITCH"},
    { PHONESTATE_HANDSETVOLUME          ,"HANDSETVOLUME"    },
    { PHONESTATE_HANDSETGAIN            ,"HANDSETGAIN"      },
    { PHONESTATE_SPEAKERHOOKSWITCH      ,"SPEAKERHOOKSWITCH"},
    { PHONESTATE_SPEAKERVOLUME          ,"SPEAKERVOLUME"    },
    { PHONESTATE_SPEAKERGAIN            ,"SPEAKERGAIN"      },
    { PHONESTATE_HEADSETHOOKSWITCH      ,"HEADSETHOOKSWITCH"},
    { PHONESTATE_HEADSETVOLUME          ,"HEADSETVOLUME"    },
    { PHONESTATE_HEADSETGAIN            ,"HEADSETGAIN"      },
    { PHONESTATE_SUSPEND                ,"SUSPEND"          },
    { PHONESTATE_RESUME                 ,"RESUME"           },
    { PHONESTATE_DEVSPECIFIC            ,"DEVSPECIFIC"      },
    { PHONESTATE_REINIT                 ,"REINIT"           },
#if TAPI_1_1
    { PHONESTATE_CAPSCHANGE             ,"CAPSCHANGE"       },
    { PHONESTATE_REMOVED                ,"REMOVED"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aPhoneStatusFlags[] =
{
    { PHONESTATUSFLAGS_CONNECTED        ,"CONNECTED"        },
    { PHONESTATUSFLAGS_SUSPENDED        ,"SUSPENDED"        },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aStringFormats[] =
{
    { STRINGFORMAT_ASCII                ,"ASCII"            },
    { STRINGFORMAT_DBCS                 ,"DBCS"             },
    { STRINGFORMAT_UNICODE              ,"UNICODE"          },
    { STRINGFORMAT_BINARY               ,"BINARY"           },
    { 0xffffffff                        ,""                 }
};

#if INTERNAL_3_0
LOOKUP my_far aServerConfigFlags[] =
{
    { TAPISERVERCONFIGFLAGS_ISSERVER              ,"ISSERVER"      },
    { TAPISERVERCONFIGFLAGS_ENABLESERVER          ,"ENABLESERVER"  },
    { TAPISERVERCONFIGFLAGS_SETACCOUNT            ,"SETACCOUNT"    },
    { TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS ,"SETTAPIADMINS" },
    { 0xffffffff                                  ,""              }
};

LOOKUP my_far aAvailableProviderOptions[] =
{
    { AVAILABLEPROVIDER_INSTALLABLE     ,"INSTALLABLE "     },
    { AVAILABLEPROVIDER_CONFIGURABLE    ,"CONFIGURABLE"     },
    { AVAILABLEPROVIDER_REMOVABLE       ,"REMOVABLE   "     },
    { 0xffffffff                        ,""                 }
};
#endif

char *aszLineErrs[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "BEARERMODEUNAVAIL",
    "inval err code (0x80000004)",      // 0x80000004 isn't valid err code
    "CALLUNAVAIL",
    "COMPLETIONOVERRUN",
    "CONFERENCEFULL",
    "DIALBILLING",
    "DIALDIALTONE",
    "DIALPROMPT",
    "DIALQUIET",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALADDRESS",                     // 0x80000010
    "INVALADDRESSID",
    "INVALADDRESSMODE",
    "INVALADDRESSSTATE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBEARERMODE",
    "INVALCALLCOMPLMODE",
    "INVALCALLHANDLE",
    "INVALCALLPARAMS",
    "INVALCALLPRIVILEGE",
    "INVALCALLSELECT",
    "INVALCALLSTATE",
    "INVALCALLSTATELIST",
    "INVALCARD",
    "INVALCOMPLETIONID",
    "INVALCONFCALLHANDLE",              // 0x80000020
    "INVALCONSULTCALLHANDLE",
    "INVALCOUNTRYCODE",
    "INVALDEVICECLASS",
    "INVALDEVICEHANDLE",
    "INVALDIALPARAMS",
    "INVALDIGITLIST",
    "INVALDIGITMODE",
    "INVALDIGITS",
    "INVALEXTVERSION",
    "INVALGROUPID",
    "INVALLINEHANDLE",
    "INVALLINESTATE",
    "INVALLOCATION",
    "INVALMEDIALIST",
    "INVALMEDIAMODE",
    "INVALMESSAGEID",                   // 0x80000030
    "inval err code (0x80000031)",      // 0x80000031 isn't valid err code
    "INVALPARAM",
    "INVALPARKID",
    "INVALPARKMODE",
    "INVALPOINTER",
    "INVALPRIVSELECT",
    "INVALRATE",
    "INVALREQUESTMODE",
    "INVALTERMINALID",
    "INVALTERMINALMODE",
    "INVALTIMEOUT",
    "INVALTONE",
    "INVALTONELIST",
    "INVALTONEMODE",
    "INVALTRANSFERMODE",
    "LINEMAPPERFAILED",                 // 0x80000040
    "NOCONFERENCE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOREQUEST",
    "NOTOWNER",
    "NOTREGISTERED",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "RATEUNAVAIL",
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",
    "STRUCTURETOOSMALL",
    "TARGETNOTFOUND",
    "TARGETSELF",
    "UNINITIALIZED",                    // 0x80000050
    "USERUSERINFOTOOBIG",
    "REINIT",
    "ADDRESSBLOCKED",
    "BILLINGREJECTED",
    "INVALFEATURE",
    "NOMULTIPLEINSTANCE"

#if TAPI_2_0
    ,
    "INVALAGENTID",
    "INVALAGENTGROUP",
    "INVALPASSWORD",
    "INVALAGENTSTATE",
    "INVALAGENTACTIVITY",
    "DIALVOICEDETECT"
#endif
};

char *aszPhoneErrs[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBUTTONLAMPID",
    "INVALBUTTONMODE",
    "INVALBUTTONSTATE",
    "INVALDATAID",
    "INVALDEVICECLASS",
    "INVALEXTVERSION",
    "INVALHOOKSWITCHDEV",
    "INVALHOOKSWITCHMODE",              // 0x90000010
    "INVALLAMPMODE",
    "INVALPARAM",
    "INVALPHONEHANDLE",
    "INVALPHONESTATE",
    "INVALPOINTER",
    "INVALPRIVILEGE",
    "INVALRINGMODE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOTOWNER",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "inval err code (0x9000001E)",      // 0x9000001e isn't valid err code
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",                   // 0x90000020
    "STRUCTURETOOSMALL",
    "UNINITIALIZED",
    "REINIT"
};

char *aszTapiErrs[] =
{
    "SUCCESS",
    "DROPPED",
    "NOREQUESTRECIPIENT",
    "REQUESTQUEUEFULL",
    "INVALDESTADDRESS",
    "INVALWINDOWHANDLE",
    "INVALDEVICECLASS",
    "INVALDEVICEID",
    "DEVICECLASSUNAVAIL",
    "DEVICEIDUNAVAIL",
    "DEVICEINUSE",
    "DESTBUSY",
    "DESTNOANSWER",
    "DESTUNAVAIL",
    "UNKNOWNWINHANDLE",
    "UNKNOWNREQUESTID",
    "REQUESTFAILED",
    "REQUESTCANCELLED",
    "INVALPOINTER"
};

char *aFuncNames[] =
{
    "lineAccept",
#if TAPI_1_1
    "lineAddProvider",
#if TAPI_2_0
    "lineAddProviderW",
#endif
#endif
    "lineAddToConference",
#if TAPI_2_0
    "lineAgentSpecific",
#endif
    "lineAnswer",
    "lineBlindTransfer",
#if TAPI_2_0
    "lineBlindTransferW",
#endif
    "lineClose",
    "lineCompleteCall",
    "lineCompleteTransfer",
    "lineConfigDialog",
#if TAPI_2_0
    "lineConfigDialogW",
#endif
#if TAPI_1_1
    "lineConfigDialogEdit",
#if TAPI_2_0
    "lineConfigDialogEditW",
#endif
    "lineConfigProvider",
#endif
    "lineDeallocateCall",
    "lineDevSpecific",
    "lineDevSpecificFeature",
    "lineDial",
#if TAPI_2_0
    "lineDialW",
#endif
    "lineDrop",
    "lineForward",
#if TAPI_2_0
    "lineForwardW",
#endif
    "lineGatherDigits",
#if TAPI_2_0
    "lineGatherDigitsW",
#endif
    "lineGenerateDigits",
#if TAPI_2_0
    "lineGenerateDigitsW",
#endif
    "lineGenerateTone",
    "lineGetAddressCaps",
#if TAPI_2_0
    "lineGetAddressCapsW",
#endif
    "lineGetAddressID",
#if TAPI_2_0
    "lineGetAddressIDW",
#endif
    "lineGetAddressStatus",
#if TAPI_2_0
    "lineGetAddressStatusW",
#endif
#if TAPI_2_0
    "lineGetAgentActivityList",
    "lineGetAgentActivityListW",
    "lineGetAgentCaps",
    "lineGetAgentGroupList",
    "lineGetAgentStatus",
#endif
#if TAPI_1_1
    "lineGetAppPriority",
#if TAPI_2_0
    "lineGetAppPriorityW",
#endif
#endif
    "lineGetCallInfo",
#if TAPI_2_0
    "lineGetCallInfoW",
#endif
    "lineGetCallStatus",
    "lineGetConfRelatedCalls",
#if TAPI_1_1
    "lineGetCountry",
#if TAPI_2_0
    "lineGetCountryW",
#endif
#endif
    "lineGetDevCaps",
#if TAPI_2_0
    "lineGetDevCapsW",
#endif
    "lineGetDevConfig",
#if TAPI_2_0
    "lineGetDevConfigW",
#endif
    "lineGetIcon",
#if TAPI_2_0
    "lineGetIconW",
#endif
    "lineGetID",
#if TAPI_2_0
    "lineGetIDW",
#endif
    "lineGetLineDevStatus",
#if TAPI_2_0
    "lineGetLineDevStatusW",
    "lineGetMessage",
#endif
    "lineGetNewCalls",
    "lineGetNumRings",
#if TAPI_1_1
    "lineGetProviderList",
#if TAPI_2_0
    "lineGetProviderListW",
#endif
#endif
    "lineGetRequest",
#if TAPI_2_0
    "lineGetRequestW",
#endif
    "lineGetStatusMessages",
    "lineGetTranslateCaps",
#if TAPI_2_0
    "lineGetTranslateCapsW",
#endif
    "lineHandoff",
#if TAPI_2_0
    "lineHandoffW",
#endif
    "lineHold",
    "lineInitialize",
#if TAPI_2_0
    "lineInitializeEx",
    "lineInitializeExW",
#endif
    "lineMakeCall",
#if TAPI_2_0
    "lineMakeCallW",
#endif
    "lineMonitorDigits",
    "lineMonitorMedia",
    "lineMonitorTones",
    "lineNegotiateAPIVersion",
    "lineNegotiateExtVersion",
    "lineOpen",
#if TAPI_2_0
    "lineOpenW",
#endif
    "linePark",
#if TAPI_2_0
    "lineParkW",
#endif
    "linePickup",
#if TAPI_2_0
    "linePickupW",
#endif
    "linePrepareAddToConference",
#if TAPI_2_0
    "linePrepareAddToConferenceW",
    "lineProxyMessage",
    "lineProxyResponse",
#endif
    "lineRedirect",
#if TAPI_2_0
    "lineRedirectW",
#endif
    "lineRegisterRequestRecipient",
#if TAPI_1_1
    "lineReleaseUserUserInfo",
#endif
    "lineRemoveFromConference",
#if TAPI_1_1
    "lineRemoveProvider",
#endif
    "lineSecureCall",
    "lineSendUserUserInfo",
#if TAPI_2_0
    "lineSetAgentActivity",
    "lineSetAgentGroup",
    "lineSetAgentState",
#endif
#if TAPI_1_1
    "lineSetAppPriority",
#if TAPI_2_0
    "lineSetAppPriorityW",
#endif
#endif
    "lineSetAppSpecific",
#if TAPI_2_0
    "lineSetCallData",
#endif
    "lineSetCallParams",
    "lineSetCallPrivilege",
#if TAPI_2_0
    "lineSetCallQualityOfService",
    "lineSetCallTreatment",
#endif
    "lineSetCurrentLocation",
    "lineSetDevConfig",
#if TAPI_2_0
    "lineSetDevConfigW",
    "lineSetLineDevStatus",
#endif
    "lineSetMediaControl",
    "lineSetMediaMode",
    "lineSetNumRings",
    "lineSetStatusMessages",
    "lineSetTerminal",
    "lineSetTollList",
#if TAPI_2_0
    "lineSetTollListW",
#endif
    "lineSetupConference",
#if TAPI_2_0
    "lineSetupConferenceW",
#endif
    "lineSetupTransfer",
#if TAPI_2_0
    "lineSetupTransferW",
#endif
    "lineShutdown",
    "lineSwapHold",
    "lineTranslateAddress",
#if TAPI_2_0
    "lineTranslateAddressW",
#endif
#if TAPI_1_1
    "lineTranslateDialog",
#if TAPI_2_0
    "lineTranslateDialogW",
#endif
#endif
    "lineUncompleteCall",
    "lineUnhold",
    "lineUnpark",
#if TAPI_2_0
    "lineUnparkW",
#endif

#if INTERNAL_3_0
    "MMCAddProviderW",
    "MMCConfigProviderW",
    "MMCGetAvailableProviders",
    "MMCGetLineInfoW",
    "MMCGetLineStatusW",
    "MMCGetPhoneInfoW",
    "MMCGetPhoneStatusW",
    "MMCGetProviderListW",
    "MMCGetServerConfigW",
    "MMCInitializeW",
    "MMCRemoveProviderW",
    "MMCSetLineInfoW",
    "MMCSetPhoneInfoW",
    "MMCSetServerConfigW",
    "MMCShutdownW",
#endif

    "phoneClose",
    "phoneConfigDialog",
#if TAPI_2_0
    "phoneConfigDialogW",
#endif
    "phoneDevSpecific",
    "phoneGetButtonInfo",
#if TAPI_2_0
    "phoneGetButtonInfoW",
#endif
    "phoneGetData",
    "phoneGetDevCaps",
#if TAPI_2_0
    "phoneGetDevCapsW",
#endif
    "phoneGetDisplay",
    "phoneGetGain",
    "phoneGetHookSwitch",
    "phoneGetIcon",
#if TAPI_2_0
    "phoneGetIconW",
#endif
    "phoneGetID",
#if TAPI_2_0
    "phoneGetIDW",
#endif
    "phoneGetLamp",
#if TAPI_2_0
    "phoneGetMessage",
#endif
    "phoneGetRing",
    "phoneGetStatus",
#if TAPI_2_0
    "phoneGetStatusW",
#endif
    "phoneGetStatusMessages",
    "phoneGetVolume",
    "phoneInitialize",
#if TAPI_2_0
    "phoneInitializeEx",
    "phoneInitializeExW",
#endif
    "phoneOpen",
    "phoneNegotiateAPIVersion",
    "phoneNegotiateExtVersion",
    "phoneSetButtonInfo",
#if TAPI_2_0
    "phoneSetButtonInfoW",
#endif
    "phoneSetData",
    "phoneSetDisplay",
    "phoneSetGain",
    "phoneSetHookSwitch",
    "phoneSetLamp",
    "phoneSetRing",
    "phoneSetStatusMessages",
    "phoneSetVolume",
    "phoneShutdown",

    "tapiGetLocationInfo",
#if TAPI_2_0
    "tapiGetLocationInfoW",
#endif
    "tapiRequestDrop",
    "tapiRequestMakeCall",
#if TAPI_2_0
    "tapiRequestMakeCallW",
#endif
    "tapiRequestMediaCall",
#if TAPI_2_0
    "tapiRequestMediaCallW",
#endif

    "Open all lines",
    "Open all phones",
    "Close handle (comm, etc)",
    "Dump buffer contents",
#if (INTERNAL_VER >= 0x20000)
    "internalNewLocationW",
#endif

    NULL,
    "Default values",
    "LINECALLPARAMS",
    "LINEFORWARDLIST",
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\mmcmgmt.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    mmcmgmt.cpp

Abstract:

    Source file module for MMC manipulation

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#include <stdio.h>
#include "windows.h"
#include "objbase.h"
#include "tapi.h"

#include "mmcmgmt.h"
#include "error.h"
#include "tchar.h"

///////////////////////////////////////////////////////////
//
//  CMMCManagement implementation
//
///////////////////////////////////////////////////////////

HRESULT CMMCManagement::GetMMCData ()
{
    HRESULT                 hr = S_OK;
    DWORD                   dwAPIVersion = TAPI_CURRENT_VERSION;
    DWORD                   dw, dw1, dw2;
    LPDEVICEINFO            pDeviceInfo;
    TAPISERVERCONFIG        cfg;
    LINEPROVIDERLIST        tapiProviderList = {0};
    LPLINEPROVIDERENTRY     pProvider;
    AVAILABLEPROVIDERLIST   tapiAvailProvList = {0};
    LPAVAILABLEPROVIDERLIST pAvailProvList = NULL;
    AVAILABLEPROVIDERENTRY  *pAvailProv;

    hr = MMCInitialize (
        NULL,           // Local computer
        &m_hMmc,        // HMMCAPP to return 
        &dwAPIVersion,  // API version
        NULL
    );
    if (FAILED(hr) || m_hMmc == NULL)
    {
        goto ExitHere;
    }

    //  Mark MMC to be busy
    cfg.dwTotalSize = sizeof(TAPISERVERCONFIG);
    hr = MMCGetServerConfig (m_hMmc, &cfg);
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    cfg.dwFlags |= TAPISERVERCONFIGFLAGS_LOCKMMCWRITE;
    hr = MMCSetServerConfig (m_hMmc, &cfg);
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    m_bMarkedBusy = TRUE;

    //  Get the DEVICEINFOLIST structure
    m_pDeviceInfoList = (LPDEVICEINFOLIST) new BYTE[sizeof(DEVICEINFOLIST)];
    if (m_pDeviceInfoList == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    m_pDeviceInfoList->dwTotalSize = sizeof(DEVICEINFOLIST);
    hr = MMCGetLineInfo (
        m_hMmc,
        m_pDeviceInfoList
        );
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    else if (m_pDeviceInfoList->dwNeededSize > m_pDeviceInfoList->dwTotalSize)
    {
        dw = m_pDeviceInfoList->dwNeededSize;
        delete [] m_pDeviceInfoList;
        m_pDeviceInfoList = (LPDEVICEINFOLIST) new BYTE[dw];
        if (m_pDeviceInfoList == NULL)
        {
            hr = TSECERR_NOMEM;
            goto ExitHere;
        }
        m_pDeviceInfoList->dwTotalSize = dw;
        hr = MMCGetLineInfo (
            m_hMmc,
            m_pDeviceInfoList
            );
        if (FAILED(hr))
        {
            goto ExitHere;
        }
    }
    if (m_pDeviceInfoList->dwNumDeviceInfoEntries == 0)
    {
        delete [] m_pDeviceInfoList;
        if (m_hMmc)
        {
            cfg.dwFlags &= (~TAPISERVERCONFIGFLAGS_LOCKMMCWRITE);
            cfg.dwFlags |= TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE;
            MMCSetServerConfig (m_hMmc, &cfg);
            m_bMarkedBusy = FALSE;
            MMCShutdown (m_hMmc);
            m_hMmc = NULL;
        }
        goto ExitHere;
    }

    //  Build the user name tuple
    m_pUserTuple = 
        new USERNAME_TUPLE[m_pDeviceInfoList->dwNumDeviceInfoEntries];
    if (m_pUserTuple == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    pDeviceInfo = (LPDEVICEINFO)(((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset);
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries; 
        ++dw, ++pDeviceInfo)
    {
        if (pDeviceInfo->dwDomainUserNamesSize == 0)
        {
            m_pUserTuple[dw].pDomainUserNames = NULL;
            m_pUserTuple[dw].pFriendlyUserNames = NULL;
        }
        else
        {
            m_pUserTuple[dw].pDomainUserNames = 
                (LPTSTR) new BYTE[pDeviceInfo->dwDomainUserNamesSize];
            m_pUserTuple[dw].pFriendlyUserNames =
                (LPTSTR) new BYTE[pDeviceInfo->dwFriendlyUserNamesSize];
            if (m_pUserTuple[dw].pDomainUserNames == NULL ||
                m_pUserTuple[dw].pFriendlyUserNames == NULL)
            {
                hr = TSECERR_NOMEM;
                goto ExitHere;
            }
            memcpy (
                m_pUserTuple[dw].pDomainUserNames,
                (((LPBYTE)m_pDeviceInfoList) + 
                    pDeviceInfo->dwDomainUserNamesOffset),
                pDeviceInfo->dwDomainUserNamesSize
                );
            memcpy (
                m_pUserTuple[dw].pFriendlyUserNames,
                (((LPBYTE)m_pDeviceInfoList) + 
                    pDeviceInfo->dwFriendlyUserNamesOffset),
                pDeviceInfo->dwFriendlyUserNamesSize
                );
        }
    }

    // Get the provider list
    tapiProviderList.dwTotalSize = sizeof(LINEPROVIDERLIST);
    hr = MMCGetProviderList( m_hMmc, &tapiProviderList);
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    m_pProviderList = (LPLINEPROVIDERLIST) new BYTE[tapiProviderList.dwNeededSize];
    if (NULL == m_pProviderList)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    memset(m_pProviderList, 0, tapiProviderList.dwNeededSize);
    m_pProviderList->dwTotalSize = tapiProviderList.dwNeededSize;

    hr = MMCGetProviderList( m_hMmc, m_pProviderList);
    if (FAILED(hr) || !m_pProviderList->dwNumProviders)
    {
        goto ExitHere;
    }

    // Get the available providers

    tapiAvailProvList.dwTotalSize = sizeof(LINEPROVIDERLIST);
    hr = MMCGetAvailableProviders (m_hMmc, &tapiAvailProvList);
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    pAvailProvList = (LPAVAILABLEPROVIDERLIST) new BYTE[tapiAvailProvList.dwNeededSize];
    if (NULL == pAvailProvList)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    memset(pAvailProvList, 0, tapiAvailProvList.dwNeededSize);
    pAvailProvList->dwTotalSize = tapiAvailProvList.dwNeededSize;

    hr = MMCGetAvailableProviders (m_hMmc, pAvailProvList);
    if (FAILED(hr) || !pAvailProvList->dwNumProviderListEntries)
    {
        delete [] pAvailProvList;
        goto ExitHere;
    }

    m_pProviderName = new LPTSTR[ m_pProviderList->dwNumProviders ];
    if (NULL == m_pProviderName)
    {
        hr = TSECERR_NOMEM;
        delete [] pAvailProvList;
        goto ExitHere;
    }
    memset(m_pProviderName, 0, m_pProviderList->dwNumProviders * sizeof (LPTSTR) );

    // find providers friendly name 
    LPTSTR szAvailProvFilename;
    LPTSTR szProviderFilename;
    LPTSTR szAvailProvFriendlyName;

    pProvider = (LPLINEPROVIDERENTRY) 
                    ((LPBYTE) m_pProviderList + m_pProviderList->dwProviderListOffset);

    for( dw1=0; dw1 < m_pProviderList->dwNumProviders; dw1++, pProvider++ )
    {
        szProviderFilename = 
            (LPTSTR) ((LPBYTE) m_pProviderList + pProvider->dwProviderFilenameOffset);

        for ( dw2=0; dw2 < pAvailProvList->dwNumProviderListEntries; dw2++ )
        {
            pAvailProv = (LPAVAILABLEPROVIDERENTRY) 
                        (( LPBYTE) pAvailProvList + pAvailProvList->dwProviderListOffset) + dw2;
            szAvailProvFilename = 
                (LPTSTR) ((LPBYTE) pAvailProvList + pAvailProv->dwFileNameOffset);
            if (_tcsicmp(szAvailProvFilename, szProviderFilename) == 0)
            {
                szAvailProvFriendlyName = 
                    (LPTSTR) ((LPBYTE) pAvailProvList + pAvailProv->dwFriendlyNameOffset);
                m_pProviderName[ dw1 ] = new TCHAR[ _tcslen( szAvailProvFriendlyName ) + 1 ];
                if (m_pProviderName[ dw1 ])
                {
                    _tcscpy( m_pProviderName[ dw1 ], szAvailProvFriendlyName );
                }
                break;
            }
        }
    }

    delete [] pAvailProvList;

ExitHere:
    if (FAILED(hr))
    {
        FreeMMCData ();
    }
    return hr;
}

HRESULT CMMCManagement::FreeMMCData ()
{
    DWORD       dw;
    
    if (m_pUserTuple && m_pDeviceInfoList)
    {
        for (dw = 0; 
            dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
            ++dw)
        {
            if (m_pUserTuple[dw].pDomainUserNames)
            {
                delete [] m_pUserTuple[dw].pDomainUserNames;
            }
            if (m_pUserTuple[dw].pFriendlyUserNames)
            {
                delete [] m_pUserTuple[dw].pFriendlyUserNames;
            }
        }
        delete [] m_pUserTuple;
        m_pUserTuple = NULL;
    }
    if (m_pDeviceInfoList)
    {
        delete [] m_pDeviceInfoList;
        m_pDeviceInfoList = NULL;
    }
    if (m_pProviderList)
    {
        delete [] m_pProviderList;
        m_pProviderList = NULL;
    }
    if (m_pProviderName)
    {
        for ( DWORD dw=0; dw < sizeof( m_pProviderName ) / sizeof(LPTSTR); dw++ )
        {
            if (m_pProviderName[ dw ])
            {
                delete [] m_pProviderName[ dw ];
            }
        }
        delete [] m_pProviderName;
    }

    if (m_bMarkedBusy && m_hMmc)
    {
        TAPISERVERCONFIG            cfg;
    
        cfg.dwTotalSize = sizeof(TAPISERVERCONFIG);
        if (S_OK == MMCGetServerConfig (m_hMmc, &cfg))
        {
            cfg.dwFlags |= TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE;
            MMCSetServerConfig (m_hMmc, &cfg);
        }
        m_bMarkedBusy = FALSE;
    }
    if (m_hMmc)
    {
        MMCShutdown (m_hMmc);
        m_hMmc = NULL;
    }

    return S_OK;
}

HRESULT CMMCManagement::RemoveLinesForUser (LPTSTR szDomainUser)
{
    HRESULT             hr = S_OK;
    LPDWORD             adwIndex = NULL;
    DWORD               dwNumEntries;
    DWORD               dw;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntriesForUser (szDomainUser, &adwIndex, &dwNumEntries);
    if (hr)
    {
        goto ExitHere;
    }
    for (dw = 0; dw < dwNumEntries; ++dw)
    {
        hr = RemoveEntryForUser (
            adwIndex[dw],
            szDomainUser
            );
        if(FAILED(hr))
        {
            goto ExitHere;
        }
    }

ExitHere:
    if (adwIndex)
    {
        delete [] adwIndex;
    }
    return hr;
}

HRESULT CMMCManagement::IsValidPID (
    DWORD   dwPermanentID
    )
{
    DWORD   dwEntry;

    return FindEntryFromPID (dwPermanentID, &dwEntry);
}

HRESULT CMMCManagement::IsValidAddress (
    LPTSTR  szAddr
    )
{
    DWORD   dwEntry;

    return FindEntryFromAddr (szAddr, &dwEntry);
}

HRESULT CMMCManagement::AddLinePIDForUser (
    DWORD dwPermanentID, 
    LPTSTR szDomainUser,
    LPTSTR szFriendlyName
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromPID (dwPermanentID, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = AddEntryForUser (dwEntry, szDomainUser, szFriendlyName);

ExitHere:
    return hr;
}

HRESULT CMMCManagement::AddLineAddrForUser (
    LPTSTR szAddr,
    LPTSTR szDomainUser,
    LPTSTR szFriendlyName
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromAddr (szAddr, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = AddEntryForUser (dwEntry, szDomainUser, szFriendlyName);

ExitHere:
    return hr;
}

HRESULT CMMCManagement::RemoveLinePIDForUser (
    DWORD dwPermanentID,
    LPTSTR szDomainUser
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromPID (dwPermanentID, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = RemoveEntryForUser (dwEntry, szDomainUser);

ExitHere:
    return hr;
}

HRESULT CMMCManagement::RemoveLineAddrForUser (
    LPTSTR szAddr,
    LPTSTR szDomainUser
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromAddr (szAddr, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = RemoveEntryForUser (dwEntry, szDomainUser);

ExitHere:
    return hr;
}

BOOL CMMCManagement::IsDeviceLocalOnly (DWORD dwProviderID, DWORD dwDeviceID)
{
    HRESULT             hr;
    DWORD               dwFlags, dwDev;

    if (m_pFuncGetDeviceFlags == NULL)
    {
        return TRUE;
    }

    hr = (*m_pFuncGetDeviceFlags)(
        m_hMmc,
        TRUE,
        dwProviderID,
        dwDeviceID,
        &dwFlags,
        &dwDev
        );
    if (hr || dwFlags & LINEDEVCAPFLAGS_LOCAL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


HRESULT CMMCManagement::FindEntryFromAddr (LPTSTR szAddr, DWORD * pdwIndex)
{
    HRESULT             hr = S_FALSE;
    DWORD               dw;
    LPDEVICEINFO        pDevInfo;
    LPTSTR              szAddr2;

    pDevInfo = (LPDEVICEINFO) (((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset);
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
        ++dw, ++pDevInfo)
    {
        szAddr2 = (LPTSTR)(((LPBYTE)m_pDeviceInfoList) +
            pDevInfo->dwAddressesOffset);
        while (*szAddr2)
        {
            if (_tcsicmp (szAddr, szAddr2) == 0)
            {
                if (IsDeviceLocalOnly (
                    pDevInfo->dwProviderID,
                    pDevInfo->dwPermanentDeviceID
                    ))
                {
                    hr = TSECERR_DEVLOCALONLY;
                }
                else
                {
                    hr = S_OK;
                    *pdwIndex = dw;
                }
                goto ExitHere;
            }
            szAddr2 += _tcslen (szAddr2) + 1;
        }
    }
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::FindEntryFromPID (DWORD dwPID, DWORD * pdwIndex)
{
    HRESULT             hr = S_FALSE;
    DWORD               dw;
    LPDEVICEINFO        pDevInfo;

    pDevInfo = (LPDEVICEINFO) (((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset);
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
        ++dw, ++pDevInfo)
    {
        if (dwPID == pDevInfo->dwPermanentDeviceID)
        {
            if (IsDeviceLocalOnly (
                pDevInfo->dwProviderID,
                pDevInfo->dwPermanentDeviceID
                ))
            {
                hr = TSECERR_DEVLOCALONLY;
            }
            else
            {
                *pdwIndex = dw;
                hr = S_OK;
            }
            goto ExitHere;
        }
    }
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::FindEntriesForUser (
    LPTSTR      szDomainUser, 
    LPDWORD     * padwIndex,
    DWORD       * pdwNumEntries
    )
{
    HRESULT             hr = S_OK;
    DWORD               dw;
    LPTSTR              szUsers;
    LPDWORD             adw;

    *padwIndex = NULL;
    *pdwNumEntries = 0;
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
        ++dw)
    {
        szUsers = m_pUserTuple[dw].pDomainUserNames;
        while (szUsers && *szUsers)
        {
            if (_tcsicmp (szDomainUser, szUsers) == 0)
            {
                hr = S_OK;
                adw = new DWORD[*pdwNumEntries + 1];
                if (adw == NULL)
                {
                    hr = TSECERR_NOMEM;
                    goto ExitHere;
                }
                if (*pdwNumEntries > 0)
                {
                    memcpy (adw, *padwIndex, sizeof(DWORD) * (*pdwNumEntries));
                }
                if (*padwIndex)
                {
                    delete [] (*padwIndex);
                }
                *padwIndex = adw;
                adw[*pdwNumEntries] = dw;
                *pdwNumEntries += 1;
            }
            szUsers += _tcslen (szUsers) + 1;
        }
    }
    
ExitHere:
    if (FAILED(hr))
    {
        *pdwNumEntries = 0;
        if (*padwIndex)
        {
            delete [] (*padwIndex);
        }
    }
    else if (*pdwNumEntries == 0)
    {
        hr = S_FALSE;
    }
    return hr;
}
    
HRESULT CMMCManagement::AddEntryForUser (
    DWORD   dwIndex,
    LPTSTR  szDomainUser,
    LPTSTR  szFriendlyName
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwSize, dw;
    LPTSTR              szUsers, szNewUsers = NULL, szNewFriendlyNames = NULL;

    if (dwIndex >= m_pDeviceInfoList->dwNumDeviceInfoEntries ||
        szDomainUser[0] == 0 ||
        szFriendlyName[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    //
    //  Add szDomainUser into the user tuple
    //

    //  Computer the existing domain user size and make sure
    //  this user is not there already
    dwSize = 0;
    szUsers = m_pUserTuple[dwIndex].pDomainUserNames;
    while (szUsers && *szUsers)
    {
        if (_tcsicmp (szDomainUser, szUsers) == 0)
        {
            goto ExitHere;
        }
        dw = _tcslen (szUsers) + 1;
        dwSize += dw;
        szUsers += dw;
    }
    
    //  Extra space for double zero terminating
    dw = _tcslen (szDomainUser);
    szNewUsers = new TCHAR[dwSize + dw + 2];
    if (szNewUsers == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  copy over the old domain users
    if (dwSize > 0)
    {
        memcpy (
            szNewUsers, 
            m_pUserTuple[dwIndex].pDomainUserNames, 
            dwSize * sizeof(TCHAR)
            );
    }

    //  Append the new domain user
    memcpy (
        szNewUsers + dwSize, 
        szDomainUser, 
        (dw + 1) * sizeof(TCHAR)
        );

    //  double zero terminate and assign the data
    szNewUsers[dwSize + dw + 1] = 0;

    //
    //  Add the szFriendlyName into the user tuple
    //

    //  Compute the existing friendly names size
    dwSize = 0;
    szUsers = m_pUserTuple[dwIndex].pFriendlyUserNames;
    while (szUsers && *szUsers)
    {
        dw = _tcslen (szUsers) + 1;
        dwSize += dw;
        szUsers += dw;
    }

    //  Extra space for double zero terminating
    dw = _tcslen (szFriendlyName);
    szNewFriendlyNames = new TCHAR[dwSize + dw + 2];
    if (szNewFriendlyNames == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  Copy over the old friendly names
    if (dwSize > 0)
    {
        memcpy (
            szNewFriendlyNames,
            m_pUserTuple[dwIndex].pFriendlyUserNames,
            dwSize * sizeof(TCHAR)
            );
    }

    //  Append the new friendly name
    memcpy (
        szNewFriendlyNames + dwSize,
        szFriendlyName,
        (dw + 1) * sizeof(TCHAR)
        );

    //  Double zero terminate the friend names
    szNewFriendlyNames[dwSize + dw + 1] = 0;

    //
    //  Everything is fine, set the new data in
    //
    if (m_pUserTuple[dwIndex].pDomainUserNames)
    {
        delete [] m_pUserTuple[dwIndex].pDomainUserNames;
    }
    m_pUserTuple[dwIndex].pDomainUserNames = szNewUsers;
    if (m_pUserTuple[dwIndex].pFriendlyUserNames)
    {
        delete [] m_pUserTuple[dwIndex].pFriendlyUserNames;
    }
    m_pUserTuple[dwIndex].pFriendlyUserNames = szNewFriendlyNames;
    
    //  Call WriteMMCEntry
    hr = WriteMMCEntry (dwIndex);
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::RemoveEntryForUser (
    DWORD   dwIndex,
    LPTSTR  szDomainUser
    )
{
    HRESULT             hr = S_OK;
    LPTSTR              szLoc, szUsers;
    DWORD               dwLoc, dw, dwSize;
    BOOL                bFound;

    if (dwIndex >= m_pDeviceInfoList->dwNumDeviceInfoEntries ||
        szDomainUser[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    
    //  Locate the domain user and its index in the array
    //  of domain users
    szUsers = m_pUserTuple[dwIndex].pDomainUserNames;
    dwLoc = 0;
    dwSize = 0;
    bFound = FALSE;
    while (szUsers && *szUsers)
    {
        dw = _tcslen (szUsers) + 1;
        if (bFound)
        {
            dwSize += dw;
        }
        else
        {
            if (_tcsicmp (szDomainUser, szUsers) == 0)
            {
                bFound = TRUE;
                szLoc = szUsers;
            }
            else
            {
                ++dwLoc;
            }
        }
        szUsers += dw;
    }
    if (!bFound)
    {
        goto ExitHere;
    }

    //  Move down the pszDomainUserNames
    if (dwSize > 0)
    {
        dw = _tcslen (szDomainUser);
        //  Memory copy includes the double zero terminator
        memmove (szLoc, szLoc + dw + 1, (dwSize + 1) * sizeof(TCHAR));
    }
    else
    {
        // The is the last item, simple double zero terminate
        *szLoc = 0;
    }

    //  Now find corresponding friendly name based on dwLoc
    szUsers = m_pUserTuple[dwIndex].pFriendlyUserNames;
    while (szUsers && *szUsers && dwLoc > 0)
    {
        --dwLoc;
        szUsers += _tcslen (szUsers) + 1;
    }
    //  bail if not exist, otherwise, remember the location
    if (szUsers == NULL || *szUsers == 0)
    {
        goto ExitHere;
    }
    szLoc = szUsers;
    //  Go to the next item
    szUsers += _tcslen (szUsers) + 1;
    //  This is the last item
    if (*szUsers == 0)
    {
        *szLoc = 0;
    }
    //  Otherwise compute the remaining size to move
    else
    {
        dwSize = 0;
        while (*szUsers)
        {
            dw = _tcslen (szUsers) + 1;
            dwSize += dw;
            szUsers += dw;
        }
        //  Compensate for the double zero terminating
        dwSize++;
        //  Do the memory move
        memmove (
            szLoc, 
            szLoc + _tcslen (szLoc) + 1,
            dwSize * sizeof(TCHAR)
            );
    }
    
    //  Call WriteMMCEntry
    hr = WriteMMCEntry (dwIndex);
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::WriteMMCEntry (DWORD dwIndex)
{
    HRESULT             hr = S_OK;
    DWORD               dwSize, dwSizeDU, dwSizeFU;
    LPUSERNAME_TUPLE    pUserTuple;
    LPTSTR              szUsers;
    DWORD               dw;
    LPDEVICEINFOLIST    pDevList = NULL;
    LPDEVICEINFO        pDevInfo, pDevInfoOld;
    LPBYTE              pDest;

    if (dwIndex >= m_pDeviceInfoList->dwNumDeviceInfoEntries)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    pUserTuple = m_pUserTuple + dwIndex;

    //  Computer domain user name size
    dwSizeDU = 0;
    if (pUserTuple->pDomainUserNames != NULL &&
        *pUserTuple->pDomainUserNames != 0)
    {
        szUsers = pUserTuple->pDomainUserNames;
        while (*szUsers)
        {
            dw = _tcslen (szUsers) + 1;
            szUsers += dw;
            dwSizeDU += dw;
        }
        dwSizeDU++; //  double zero terminator
    }

    //  Computer the friendly user name size
    dwSizeFU = 0;
    if (pUserTuple->pFriendlyUserNames != NULL &&
        *pUserTuple->pFriendlyUserNames != 0)
    {
        szUsers = pUserTuple->pFriendlyUserNames;
        while (*szUsers)
        {
            dw = _tcslen (szUsers) + 1;
            szUsers += dw;
            dwSizeFU += dw;
        }
        dwSizeFU++; //  double zero terminator
    }

    //  Computer the total size
    dwSize = sizeof(DEVICEINFOLIST) + sizeof(DEVICEINFO) + 
        (dwSizeDU + dwSizeFU) * sizeof(TCHAR);

    //  Allocate the structure
    pDevList = (LPDEVICEINFOLIST) new BYTE[dwSize];
    if (pDevList == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  Set the data member of DEVICEINFOLIST
    pDevList->dwTotalSize = dwSize;
    pDevList->dwNeededSize = dwSize;
    pDevList->dwUsedSize = dwSize;
    pDevList->dwNumDeviceInfoEntries = 1;
    pDevList->dwDeviceInfoSize = sizeof(DEVICEINFO);
    pDevList->dwDeviceInfoOffset = sizeof(DEVICEINFOLIST);

    //  Set the member of DEVICEINFO
    pDevInfo = (LPDEVICEINFO)(((LPBYTE)pDevList) + 
        pDevList->dwDeviceInfoOffset);
    pDevInfoOld = (LPDEVICEINFO)(((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset) + dwIndex;
    memset (pDevInfo, 0, sizeof(DEVICEINFO));
    
    pDevInfo->dwPermanentDeviceID = pDevInfoOld->dwPermanentDeviceID;
    pDevInfo->dwProviderID = pDevInfoOld->dwProviderID;

    if (dwSizeDU > 0)
    {
        pDevInfo->dwDomainUserNamesSize = dwSizeDU * sizeof(TCHAR);
        pDevInfo->dwDomainUserNamesOffset = 
            sizeof(DEVICEINFOLIST) + sizeof(DEVICEINFO);
        pDest = ((LPBYTE)pDevList) + pDevInfo->dwDomainUserNamesOffset;
        memcpy (
            pDest,
            pUserTuple->pDomainUserNames,
            dwSizeDU * sizeof(TCHAR)
            );
    }

    if (dwSizeFU)
    {
        pDevInfo->dwFriendlyUserNamesSize = dwSizeFU * sizeof(TCHAR);
        pDevInfo->dwFriendlyUserNamesOffset = 
            pDevInfo->dwDomainUserNamesOffset + dwSizeDU * sizeof(TCHAR);
        pDest = ((LPBYTE)pDevList) + pDevInfo->dwFriendlyUserNamesOffset;
        memcpy (
            pDest,
            pUserTuple->pFriendlyUserNames,
            dwSizeFU * sizeof(TCHAR)
            );
    }

    hr = MMCSetLineInfo (
        m_hMmc,
        pDevList
        );

ExitHere:
    if (pDevList)
    {
        delete [] pDevList;
    }
    return hr;
}

HRESULT CMMCManagement::DisplayMMCData ()
{
    HRESULT             hr = S_OK;
    LPDEVICEINFO        pDeviceInfo;
    DWORD *             pdwIndex = NULL;
    DWORD               dwProviderId;
    DWORD               dwAddressCount,dw1,dw2;
    LPLINEPROVIDERENTRY pProvider;
    LPTSTR              pUserName;
    LPTSTR              pAddress, 
                        pAddressFirst, 
                        pAddressLast;

    if ( !m_pDeviceInfoList || !m_pDeviceInfoList->dwNumDeviceInfoEntries )
    {
        CIds IdsNoDevices (IDS_NODEVICES);
        _tprintf ( IdsNoDevices.GetString () );
        return hr;
    }

    //
    // Build an index by provider ID
    //
    pdwIndex = new DWORD [ m_pDeviceInfoList->dwNumDeviceInfoEntries ];
    if ( !pdwIndex )
    {
        hr = TSECERR_NOMEM;
        return hr;
    }

    for ( dw1=0; dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries; dw1++ )
    {
        pdwIndex[ dw1 ] = dw1;
    }

    dw1 = 0;
    while ( dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries )
    {

        pDeviceInfo = (LPDEVICEINFO)((LPBYTE)m_pDeviceInfoList +
                    m_pDeviceInfoList->dwDeviceInfoOffset) + pdwIndex[ dw1 ];
        dwProviderId = pDeviceInfo->dwProviderID;
        dw1++;

        for ( dw2=dw1; dw2 < m_pDeviceInfoList->dwNumDeviceInfoEntries; dw2++ )
        {
            pDeviceInfo = (LPDEVICEINFO)((LPBYTE)m_pDeviceInfoList +
                    m_pDeviceInfoList->dwDeviceInfoOffset) + pdwIndex[ dw2 ];

            if ( dwProviderId == pDeviceInfo->dwProviderID )
            {
                DWORD   dwTemp  = pdwIndex[ dw2 ];
                pdwIndex[ dw2 ] = pdwIndex[ dw1 ];
                pdwIndex[ dw1 ] = dwTemp;
                dw1++;
            }
        }
    }

    //
    // Display the device list
    //
    dw1 = 0;
    while ( dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries )
    {
        pDeviceInfo = (LPDEVICEINFO)((LPBYTE)m_pDeviceInfoList +
                    m_pDeviceInfoList->dwDeviceInfoOffset) + pdwIndex[ dw1 ];
        dwProviderId = pDeviceInfo->dwProviderID;

        // find the provider entry
        pProvider = (LPLINEPROVIDERENTRY) ((LPBYTE) m_pProviderList + m_pProviderList->dwProviderListOffset);
        for( dw2=0; dw2 < m_pProviderList->dwNumProviders; dw2++, pProvider++ )
        {
            if ( dwProviderId == pProvider->dwPermanentProviderID )
            {
                break;
            }
        }

        // display the provider name
        if ( dw2 < m_pProviderList->dwNumProviders )
        {
            // provider entry found
            _tprintf( 
                _T("\n%s\n"), 
                m_pProviderName[ dw2 ] ? m_pProviderName[ dw2 ] : 
                    (LPTSTR)((LPBYTE) m_pProviderList + pProvider->dwProviderFilenameOffset)
                );
        }
        else 
        {
            CIds IdsProvider (IDS_PROVIDER);
            _tprintf( IdsProvider.GetString(), dwProviderId );
        }

        // list devices / users for this provider
        do
        {
            CIds IdsLine (IDS_LINE);
            CIds IdsPermanentID (IDS_PID);
            CIds IdsAddresses (IDS_ADDRESSES);

            _tprintf( IdsLine.GetString(), 
                (LPTSTR)((LPBYTE)m_pDeviceInfoList + pDeviceInfo->dwDeviceNameOffset));
            _tprintf( IdsPermanentID.GetString(), pDeviceInfo->dwPermanentDeviceID);
            if ( pDeviceInfo->dwFriendlyUserNamesSize )
            {
                CIds IdsUsers (IDS_USERS);
                _tprintf ( IdsUsers.GetString () );

                pUserName = (LPTSTR) (((LPBYTE) m_pDeviceInfoList) +
                    pDeviceInfo->dwFriendlyUserNamesOffset);
                while ( *pUserName != _T('\0') )
                {
                    _tprintf( _T("\t\t\t%s\n"), pUserName );
                    pUserName += _tcslen (pUserName) + 1;
                }
            }
            if ( pDeviceInfo->dwAddressesSize )
            {
                _tprintf( IdsAddresses.GetString() );
                pAddress = (LPTSTR) (((LPBYTE) m_pDeviceInfoList) +
                    pDeviceInfo->dwAddressesOffset);
                while ( *pAddress != _T('\0') )
                {
                    _tprintf( _T("\t\t\t%s\n"), pAddress );
                    pAddress += _tcslen (pAddress) + 1;
                }
            }

            dw1++;
            pDeviceInfo++;
        }
        while ( dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries &&
                pDeviceInfo->dwProviderID == dwProviderId );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\mmcmgmt.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    mmcmgmt.h

Abstract:

    Header file for MMC manipulation

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/

#ifndef __MMCMGMT_H__
#define __MMCMGMT_H__

#include "tapi.h"
#include "tapimmc.h"
#include "util.h"

typedef struct _USERNAME_TUPLE
{
    LPTSTR  pDomainUserNames;

    LPTSTR  pFriendlyUserNames;

} USERNAME_TUPLE, *LPUSERNAME_TUPLE;

typedef LONG (WINAPI * PMMCGETDEVICEFLAGS)(
    HMMCAPP             hMmcApp,
    BOOL                bLine,
    DWORD               dwProviderID,
    DWORD               dwPermanentDeviceID,
    DWORD               * pdwFlags,
    DWORD               * pdwDeviceID
    );

class CMMCManagement
{
public:
    CMMCManagement ()
    {
        HMODULE         hTapi32;
    
        m_pDeviceInfoList   = NULL;
        m_pUserTuple        = NULL;
        m_pProviderList     = NULL;
        m_pProviderName     = NULL;
        m_hMmc              = NULL;
        m_bMarkedBusy       = FALSE;

        hTapi32 = LoadLibrary (TEXT("tapi32.dll"));
        if (hTapi32)
        {
            m_pFuncGetDeviceFlags = (PMMCGETDEVICEFLAGS)GetProcAddress (
                hTapi32, 
                "MMCGetDeviceFlags"
                );
            FreeLibrary (hTapi32);
        }
        else
        {
            m_pFuncGetDeviceFlags = NULL;
        }
    }
    
    ~CMMCManagement ()
    {
        FreeMMCData ();
    }

    HRESULT GetMMCData ();
    HRESULT RemoveLinesForUser (LPTSTR szDomainUser);
    HRESULT IsValidPID (DWORD dwPermanentID);
    HRESULT IsValidAddress (LPTSTR szAddr);
    HRESULT AddLinePIDForUser (
        DWORD dwPermanentID, 
        LPTSTR szDomainUser,
        LPTSTR szFriendlyName
        );
    HRESULT AddLineAddrForUser (
        LPTSTR szAddr,
        LPTSTR szDomainUser,
        LPTSTR szFriendlyName
        );
    HRESULT RemoveLinePIDForUser (
        DWORD dwPermanentID,
        LPTSTR szDomainUser
        );
    HRESULT RemoveLineAddrForUser (
        LPTSTR szAddr,
        LPTSTR szDomainUser
        );

    HRESULT DisplayMMCData ();
    
    HRESULT FreeMMCData ();

private:
    
    HRESULT FindEntryFromAddr (LPTSTR szAddr, DWORD * pdwIndex);
    HRESULT FindEntryFromPID (DWORD dwPID, DWORD * pdwIndex);
    HRESULT FindEntriesForUser (
        LPTSTR      szDomainUser, 
        LPDWORD     * padwIndex,
        DWORD       * pdwNumEntries
        );
    
    HRESULT AddEntryForUser (
        DWORD   dwIndex,
        LPTSTR  szDomainUser,
        LPTSTR  szFriendlyName
        );
    HRESULT RemoveEntryForUser (
        DWORD   dwIndex,
        LPTSTR  szDomainUser
        );
    HRESULT WriteMMCEntry (DWORD dwIndex);
    BOOL IsDeviceLocalOnly (DWORD dwProviderID, DWORD dwDeviceID);

private:
    HMMCAPP             m_hMmc;
    BOOL                m_bMarkedBusy;
    DEVICEINFOLIST      * m_pDeviceInfoList;
    USERNAME_TUPLE      * m_pUserTuple;
    LINEPROVIDERLIST    * m_pProviderList;
    LPTSTR              * m_pProviderName;

    PMMCGETDEVICEFLAGS  m_pFuncGetDeviceFlags;
};

#endif // mmcmgmt.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\tsecimp.cpp ===
#include <windows.h>
#include <stdio.h>
#include "resource.h"
#include <tapi.h>
#include <objbase.h>
#include <activeds.h>
#include <lmerr.h>

#include "util.h"
#include "parser.h"
#include "mmcmgmt.h"

const TCHAR         gszUserDNFmt[] = TEXT("WinNT://%s/%s,user");

// Unicode to Unicode
void Convert (LPWSTR wszIn, LPWSTR * pwszOut)
{
    if (NULL == wszIn)
    {
        * pwszOut = NULL;
        return;
    }

    *pwszOut = new WCHAR [ wcslen (wszIn) + 1 ];
    if (*pwszOut)
    {
        wcscpy (*pwszOut, wszIn);
    }

    return;
}

// Ansi to Unicode
void Convert (LPSTR szIn, LPWSTR * pwszOut)
{
    if (NULL == szIn)
    {
        * pwszOut = NULL;
        return;
    }

    *pwszOut = new WCHAR [ strlen (szIn) + 1 ];
    if (*pwszOut)
    {
        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    szIn,
                    -1,
                    *pwszOut,
                    strlen (szIn) + 1
                    )
            )
        {
            // the conversion failed
            delete [] *pwszOut;
            *pwszOut = NULL;
        }
    }

    return;
}

void UnicodeToOEM (LPWSTR wszIn, LPSTR *pszOut)
{
    int iSize;

    if (NULL == wszIn)
    {
        * pszOut = NULL;
        return;
    }

    // get the required buffer size
    iSize = WideCharToMultiByte(
                CP_OEMCP,
                0,
                wszIn,
                -1,
                NULL,
                0,
                NULL,
                NULL
                );

    if (0 == iSize)
    {
        *pszOut = NULL;
    }
    else
    {
        *pszOut = new char [ iSize ];
        if (*pszOut)
        {
            if ( 0 == WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        wszIn,
                        -1,
                        *pszOut,
                        iSize,
                        NULL,
                        NULL
                        )
                 )
            {
                // the conversion failed
                delete [] *pszOut;
                *pszOut = NULL;
            }
        }
    }

    return;
}

int MessagePrint(
                 LPTSTR szText,
                 LPTSTR szTitle
                 )
{
    LPTSTR szOutput = NULL;
    LPWSTR wszOutput = NULL;
    LPSTR  szOemOutput = NULL;

    // make it one TCHAR string
    szOutput = new TCHAR [ _tcslen(szText) + _tcslen(szTitle) + 3 ];

    if (!szOutput)
        return -1;

    _stprintf ( szOutput, _T("%s\n%s\n"), szTitle, szText );
    
    // convert the string to unicode
    Convert (szOutput, &wszOutput);
    delete [] szOutput;

    if (!wszOutput)
        return -1;

    // convert to OEM for printing
    UnicodeToOEM (wszOutput, &szOemOutput);
    delete [] wszOutput;

    if (!szOemOutput)
        return -1;

    // now print
    printf ("%s", szOemOutput);
    delete [] szOemOutput;

    return 0;
}

int MessagePrintIds (
    int             idsText
    )
{
    CIds        IdsTitle (IDS_PRODUCTNAME);
    CIds        IdsText ( idsText );

    if ( IdsTitle.StringFound () && IdsText.StringFound () )
    {
        return MessagePrint (
                IdsText.GetString (),
                IdsTitle.GetString ()
                );
    }
    return 0;
}

//
//  Report an error resource string with one %s in it
//
void ReportSz1 (
    HANDLE      hLogFile,
    UINT        idsError,
    LPTSTR      szParam
    )
{
    TCHAR           szText[256];
    TCHAR           szBuf2[128];
    CIds            IdsError (idsError);
    CIds            IdsTitle (IDS_PRODUCTNAME);

    if ( IdsError.StringFound () && IdsTitle.StringFound () )
    {
        _tcsncpy (szBuf2, szParam, sizeof(szBuf2) / sizeof(TCHAR));
        szBuf2[sizeof(szBuf2) / sizeof(TCHAR) - 1] = 0;
        wsprintf (szText, IdsError.GetString (), szBuf2);
        if (hLogFile != NULL && hLogFile != INVALID_HANDLE_VALUE)
        {
            char    szAnsiBuf[256];
            DWORD   dwNumOfBytesWritten;
        
            WideCharToMultiByte (
                        CP_ACP,
                        0,
                        szText,
                        -1,
                        szAnsiBuf,
                        sizeof(szAnsiBuf),
                        NULL,
                        NULL
                        );
            lstrcatA (szAnsiBuf, "\n");
            WriteFile (
                        hLogFile,
                        szAnsiBuf,
                        lstrlenA (szAnsiBuf),
                        &dwNumOfBytesWritten,
                        NULL
                        );
        }
        else
        {
            MessagePrint (szText, IdsTitle.GetString ());
        }
    }
}

//
//  IsValidDomainUser
//      Check if a domain user like redmond\jonsmith specified in szDomainUser
//  is valid or not. returns S_FALSE if it is invalid, S_OK for valid user.
//
//  szFullName      ----    To return the user's full name
//  cch             ----    count of characters pointed to by szFullName
//
//  if szFullName is NULL or cch is zero, no full name is returned
//

HRESULT IsValidDomainUser (
    LPCTSTR szDomainUser,
    LPTSTR  szFullName,
    DWORD   cch
    )
{
    HRESULT             hr = S_OK;
    TCHAR               szDN[256];
    TCHAR               szDomain[256];
    LPTSTR              szSep;
    LPCTSTR             szUser;
    DWORD               dw;

    IADsUser            * pUser = NULL;
    BSTR                bstrFullName = NULL;

    //  Sanity check
    if (szDomainUser == NULL || szDomainUser[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    //
    //  Construct the user DN as <WINNT://domain/user,user>
    //
    szSep = _tcschr (szDomainUser, TEXT('\\'));
    if (szSep == NULL)
    {
        //  No '\' is given, assume a local user ,domain is local computer
        szUser = szDomainUser;
        dw = sizeof(szDomain)/sizeof(TCHAR);
        if (GetComputerName (szDomain, &dw) == 0)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
    }
    else
    {
        //  assume invalid domain name if longer than 255
        if (szSep - szDomainUser >= sizeof(szDomain)/sizeof(TCHAR))
        {
            hr = S_FALSE;
            goto ExitHere;
        }
        _tcsncpy (szDomain, szDomainUser, szSep - szDomainUser);
        szDomain[szSep - szDomainUser] = 0;
        szUser = szSep + 1;
    }
    if (_tcslen (gszUserDNFmt) + _tcslen (szDomain) + _tcslen (szUser) > 
        sizeof(szDN) / sizeof(TCHAR))
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    wsprintf (szDN, gszUserDNFmt, szDomain, szUser);

    //
    //  Try to bind to the user object
    //
    hr = ADsGetObject (szDN, IID_IADsUser, (void **)&pUser);
    if (FAILED(hr))
    {
        if (hr == E_ADS_INVALID_USER_OBJECT ||
            hr == E_ADS_UNKNOWN_OBJECT ||
            hr == E_ADS_BAD_PATHNAME ||
            HRESULT_CODE(hr) == NERR_UserNotFound)
        {
            hr = S_FALSE;   // The user does not exist
        }
        goto ExitHere;
    }

    //
    //  If the user exists, get its full name
    //
    if (cch > 0)
    {
        hr = pUser->get_FullName (&bstrFullName);
        szFullName[0] = 0;
        if (hr == S_OK)
        {
            _tcsncpy (szFullName, bstrFullName, cch);
            szFullName[cch - 1] = 0;
        }
    }

ExitHere:
    if (pUser)
    {
        pUser->Release();
    }
    if (bstrFullName)
    {
        SysFreeString (bstrFullName);
    }
    return hr;
}

LPTSTR AppendStringAndFree (LPTSTR szOld, LPTSTR szToAppend)
{
    LPTSTR      szNew;
    DWORD       dwLen;

    dwLen = ((szOld == NULL) ? 0 : _tcslen (szOld)) + _tcslen (szToAppend) + 1;
    szNew = new TCHAR[dwLen * sizeof(TCHAR)];
    if (szNew == NULL)
    {
        goto ExitHere;
    }

    if (szOld)
    {
        _tcscpy (szNew, szOld);
        _tcscat (szNew, szToAppend);
    }
    else
    {
        _tcscpy (szNew, szToAppend);
    }

ExitHere:
    if (szOld)
    {
        delete [] szOld;
    }
    return szNew;
}


void
TsecCommandLine::ParseCommandLine (LPTSTR szCommand)
{
    if (szCommand == NULL)
    {
        goto ExitHere;
    }

    //
    //  Skip the first segment which is the executable itself
    //
    if (*szCommand == TEXT('\"'))
    {
        ++szCommand;
        while (*szCommand &&
            *szCommand != TEXT('\"'))
        {
            ++szCommand;
        }
        if (*szCommand == TEXT('\"'))
        {
            ++szCommand;
        }
    }
    else
    {
        while (
            *szCommand  &&
            *szCommand != TEXT(' ') &&
            *szCommand != TEXT('\t') &&
            *szCommand != 0x0a &&
            *szCommand != 0x0d)
        {
            ++szCommand;
        }
    }

    while (*szCommand)
    {
        //
        //  Search for / or - as the start of option
        //
        while (*szCommand &&
           *szCommand != TEXT('/') &&
           *szCommand != TEXT('-')
          )
        {
            szCommand++;
        }

        if (*szCommand == 0)
        {
            break;
        }
        ++szCommand;

        //
        //  -h, -H, -? means help
        //
        if (*szCommand == TEXT('h') ||
            *szCommand == TEXT('H') ||
            *szCommand == TEXT('?'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fShowHelp = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -v or -V followed by white space means validating only
        //
        else if (*szCommand == TEXT('v') ||
            *szCommand == TEXT('V'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fValidateOnly = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -u, -U means to validate domain user account
        //
        else if (*szCommand == TEXT('u') ||
            *szCommand == TEXT('U'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fValidateDU = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -d or -D followed by white space means dump current configuration
        //
        else if (*szCommand == TEXT('d') ||
            *szCommand == TEXT('D'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fDumpConfig = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -f is followed by a xml file name
        //
        else if (*szCommand == TEXT('f') ||
            *szCommand == TEXT('F'))
        {
            ++szCommand;
            //  skip white spaces
            while (*szCommand != 0 && (
                *szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0d))
            {
                ++szCommand;
            }
            if (*szCommand == 0)
            {
                //  no file name specified for -f, error
                m_fError = TRUE;
            }
            else
            {
                LPTSTR      szBeg;
                int         cch;
        
                szBeg = szCommand;
                cch = 0;
                //  A quote means file name might contain space
                //  search until the matchint quote of end
                if (*szCommand == TEXT('\"'))
                {
                    ++szCommand;
                    while (*szCommand != 0 && 
                        *szCommand != TEXT('\"'))
                    {
                        ++szCommand;
                        ++cch;
                    }
                }
                else
                {
                    while (*szCommand != 0 &&
                        *szCommand != TEXT(' ') &&
                        *szCommand != TEXT('\t') &&
                        *szCommand != TEXT('\r') &&
                        *szCommand != TEXT('\n'))
                    {
                        ++szCommand;
                        ++cch;
                    }
                }
                if (cch == 0)
                {
                    m_fError = TRUE;
                }
                else
                {
                    m_szInFile = new TCHAR[cch+1];
                    if (m_szInFile != NULL)
                    {
                        memcpy (m_szInFile, szBeg, cch * sizeof(TCHAR));
                        m_szInFile[cch] = 0;
                    }
                }
            }
        }
        else if(*szCommand)
        {
            m_fError = TRUE;
            ++szCommand;
        }
    }

ExitHere:
    return;
}

int _cdecl wmain( void )
{
    HRESULT         hr = S_OK;
    BOOL            bUninit = FALSE;
    CXMLParser      parser;
    CXMLUser        * pCurUser = NULL, *pNextUser;
    CMMCManagement  * pMmc = NULL;
    BOOL            bNoMerge, bRemove, bPID;
    TCHAR           szBufDU[256];
    TCHAR           szBufFN[256];
    TCHAR           szBufAddr[128];
    DWORD           dwPID;
    HWND            hwndDump = NULL;
    HANDLE          hLogFile = INVALID_HANDLE_VALUE;
    BOOL            bRecordedError = FALSE, bValidUser;
    TsecCommandLine cmd (GetCommandLine ());

    CXMLLine        * pCurLine = NULL, * pNextLine;

    //
    //  Create a dump window so that tlist.exe will report a title
    //
    if (LoadString (
        GetModuleHandle(NULL),
        IDS_PRODUCTNAME,
        szBufFN,
        sizeof(szBufFN)/sizeof(TCHAR)))
    {
        hwndDump = CreateWindow (
            TEXT("STATIC"),
            szBufFN,
            0,
            0, 0, 0, 0,
            NULL,
            NULL,
            NULL,
            NULL
            );
    }

    //
    //  Check the command line options
    //
    if (cmd.FError ()                           || 
        cmd.FShowHelp ()                        || 
        !cmd.FDumpConfig () && !cmd.FHasFile () ||
        cmd.FDumpConfig () && cmd.FHasFile ()   ||
        ( cmd.FValidateOnly () || cmd.FValidateUser () ) && !cmd.FHasFile ()
       )
    {
        cmd.PrintUsage();
        goto ExitHere;
    }

    hr = CoInitializeEx (
        NULL,
        COINIT_MULTITHREADED 
        );
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    bUninit = TRUE;

    //
    //  Prepare the MMC component
    //
    pMmc = new CMMCManagement ();
    if (pMmc == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = pMmc->GetMMCData ();
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    //
    // Dump the current config if this option was present
    //
    if ( cmd.FDumpConfig() )
    {
        hr = pMmc->DisplayMMCData ();
            goto ExitHere;
    }

    //
    //  Set the XML file name and parse it, report error if any
    //
    
    hr = parser.SetXMLFile (cmd.GetInFileName ());
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    hr = parser.Parse ();
    //  Report parsing error if any
    if (hr == TSECERR_INVALFILEFORMAT)
    {
        hr = parser.ReportParsingError ();
        goto ExitHere;
    }
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    //
    //  Create the log file for reporting errors during
    //  MMC processing
    //
    hLogFile = CreateFile (
        _T("tsecimp.log"),
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }

    //
    //  Loop through each user and device, based on the user's
    //  request, add or remove lines
    //
    hr = parser.GetFirstUser (&pCurUser);
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    while (pCurUser != NULL)
    {
        if (FAILED(hr = pCurUser->GetDomainUser(
                szBufDU, sizeof(szBufDU)/sizeof(TCHAR))) ||
            FAILED(hr = pCurUser->GetFriendlyName(
                szBufFN, sizeof(szBufFN)/sizeof(TCHAR))))
        {
            goto ExitHere;
        }

        bValidUser = TRUE;

        if (cmd.FValidateUser())
        {
            hr = IsValidDomainUser(
                szBufDU, 
                szBufAddr,  //  Borrowing szBufAddr for returning full name
                sizeof(szBufAddr) / sizeof(TCHAR)
                );
            if (FAILED(hr))
            {
                goto ExitHere;
            }
            //  Not a valid domain user, report it
            if (hr == S_FALSE)
            {
                //  domain user <%s> is invalid
                ReportSz1 (hLogFile, IDS_INVALIDUSER, szBufDU);
                bRecordedError = TRUE;
                bValidUser = FALSE;
            }
            if (szBufFN[0] == 0)
            {
                if (szBufAddr[0] != 0)
                {
                    //  Got a friendly name from DS, use it
                    _tcscpy (szBufFN, szBufAddr);
                }
            }
        }
        //  Still got no friendly name? use the domain user name
        if (szBufFN[0] == 0)
        {
            _tcscpy (szBufFN, szBufDU);
        }
    
        hr = pCurUser->IsNoMerge (&bNoMerge);
        if (FAILED(hr))
        {
            goto ExitHere;
        }
        if (bNoMerge && !cmd.FValidateOnly())
        {
            hr = pMmc->RemoveLinesForUser(szBufDU);
            if (FAILED(hr))
            {
                goto ExitHere;
            }
        }

        //
        //  Loop through each line, add or remove the device
        //
        if (pCurLine)
        {
            delete pCurLine;
        }
        hr = pCurUser->GetFirstLine (&pCurLine);
        if (FAILED(hr))
        {
            goto ExitHere;
        }
        while (pCurLine != NULL)
        {
            if (FAILED(hr = pCurLine->IsRemove(&bRemove)) ||
                FAILED(hr = pCurLine->IsPermanentID(&bPID)))
            {
                goto ExitHere;
            }
            if (bPID)
            {
                hr = pCurLine->GetPermanentID(&dwPID);
            }
            else
            {
                hr = pCurLine->GetAddress(
                    szBufAddr, 
                    sizeof(szBufAddr)/sizeof(TCHAR)
                    );
            }
            if (FAILED(hr))
            {
                goto ExitHere;
            }

            if (!cmd.FValidateOnly() && bValidUser)
            {
                if (bRemove)
                {
                    if (bPID)
                    {
                        hr = pMmc->RemoveLinePIDForUser (
                            dwPID,
                            szBufDU
                            );
                    }
                    else
                    {
                        hr = pMmc->RemoveLineAddrForUser (
                            szBufAddr,
                            szBufDU
                            );
                    }
                }
                else
                {
                    if (bPID)
                    {
                        hr = pMmc->AddLinePIDForUser (
                            dwPID,
                            szBufDU,
                            szBufFN
                            );
                    }
                    else
                    {
                        hr = pMmc->AddLineAddrForUser (
                            szBufAddr,
                            szBufDU,
                            szBufFN
                            );
                    }
                }
            }
            else
            {
                if (bPID)
                {
                    hr = pMmc->IsValidPID (dwPID);
                }
                else
                {
                    hr = pMmc->IsValidAddress (szBufAddr);
                }
            }

            if( hr == S_FALSE || hr == TSECERR_DEVLOCALONLY)
            {
                //  An invalid permanent ID or address is given
                //  report the error and quit
                TCHAR           szText[256];
                CIds            IdsTitle (IDS_PRODUCTNAME);

                if ( IdsTitle.StringFound () )
                {
                    szText[0] = 0;

                    if (bPID)
                    {
                        CIds IdsError (TSECERR_DEVLOCALONLY ? IDS_LOCALONLYPID : IDS_INVALPID);
                    
                        if ( IdsError.StringFound () )
                        {
                            wsprintf (szText, IdsError.GetString (), dwPID);
                        }
                    }
                    else if (!bPID)
                    {   
                        CIds IdsError (TSECERR_DEVLOCALONLY ? IDS_LOCALONLYADDR : IDS_INVALADDR);

                        if ( IdsError.StringFound () )
                        {
                            wsprintf (szText, IdsError.GetString (), szBufAddr);
                        }
                    }
                    if (hLogFile != NULL && hLogFile != INVALID_HANDLE_VALUE)
                    {
                        char    szAnsiBuf[256];
                        DWORD   dwNumOfBytesWritten;

                        WideCharToMultiByte (
                            CP_ACP,
                            0,
                            szText,
                            -1,
                            szAnsiBuf,
                            sizeof(szAnsiBuf),
                            NULL,
                            NULL
                            );
                        lstrcatA (szAnsiBuf, "\n");
                        WriteFile (
                            hLogFile,
                            szAnsiBuf,
                            lstrlenA (szAnsiBuf),
                            &dwNumOfBytesWritten,
                            NULL
                            );
                    }
                    else
                    {
                        MessagePrint (szText, IdsTitle.GetString ());
                    }
                }
                bRecordedError = TRUE;
                hr = S_OK;
            }
            else if(FAILED(hr))
            {
                goto ExitHere;
            }
        
            hr = pCurLine->GetNextLine (&pNextLine);
            if (FAILED(hr))
            {
                goto ExitHere;
            }
            delete pCurLine;
            pCurLine = pNextLine;
        }

        hr = pCurUser->GetNextUser (&pNextUser);
        if (FAILED(hr))
        {
            goto ExitHere;
        }
        delete pCurUser;
        pCurUser = pNextUser;
    }

    //  If error happend, we aready exited, reset warnings
    hr = S_OK;
    //  We are done if we are asked to do validating only
    if (bRecordedError)
    {
        MessagePrintIds (IDS_HASERROR);
    }
    else if (cmd.FValidateOnly())
    {
        MessagePrintIds (IDS_VALIDSUCCESS);
    }
    else
    {
        MessagePrintIds (IDS_FINSUCCESS);
    }

ExitHere:

    //
    //  Report error if any here
    //
    if(FAILED(hr))
    {
        ReportError (NULL, hr);
    }

    if (hwndDump)
    {
        DestroyWindow (hwndDump);
    }

    if (hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hLogFile);
    }

    if (pCurLine)
    {
        delete pCurLine;
    }
    if (pCurUser)
    {
        delete pCurUser;
    }
    if (pMmc)
    {
        delete pMmc;
    }
    parser.Release();
    if (bUninit)
    {
        CoUninitialize ();
    }
    return 0;
}

void ReportError (
    HANDLE          hFile,
    HRESULT         hr
    )
{
    TCHAR       szTitle[128];
    TCHAR       szBuf[512];
    HINSTANCE   hModule = GetModuleHandle (NULL);

    if (LoadString (
        hModule,
        IDS_PRODUCTNAME,
        szTitle,
        sizeof(szTitle)/sizeof(TCHAR)
        ) == 0)
    {
        goto ExitHere;
    }
    
   //  Is this our own error
    if (HRESULT_FACILITY(hr) == FACILITY_TSEC_CODE)
    {
        if (FormatMessage (
            FORMAT_MESSAGE_FROM_HMODULE, 
            hModule, 
            HRESULT_CODE(hr),
            0,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR),
            NULL
            ) == 0)
        {
            goto ExitHere;
        }
    }
    //  Is this TAPI error?
    else if ((hr < 0 && hr > -100) || HRESULT_FACILITY(hr) == 0)
    {
        hModule = LoadLibrary (TEXT("TAPIUI.DLL"));
        if (hModule == NULL)
        {
            goto ExitHere;
        }
        if (FormatMessage (
            FORMAT_MESSAGE_FROM_HMODULE, 
            hModule, 
            TAPIERROR_FORMATMESSAGE(hr),
            0,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR),
            NULL
            ) == 0)
        {
            FreeLibrary (hModule);
            goto ExitHere;
        }
        FreeLibrary (hModule);
    }
    //  Assume system error
    else
    {
        if (FormatMessage (
            FORMAT_MESSAGE_FROM_SYSTEM, 
            NULL, 
            HRESULT_CODE(hr),
            0,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR),
            NULL
            ) == 0)
        {
            goto ExitHere;
        }
    }
    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE)
    {
        MessagePrint (szBuf, szTitle);
    }
    else
    {
        char    szAnsiBuf[1024];
        DWORD   dwNumOfBytesWritten;

        WideCharToMultiByte (
            CP_ACP,
            0,
            szBuf,
            -1,
            szAnsiBuf,
            sizeof(szAnsiBuf),
            NULL,
            NULL
            );
        lstrcatA (szAnsiBuf, "\n");
        WriteFile (
            hFile,
            szAnsiBuf,
            lstrlenA (szAnsiBuf),
            &dwNumOfBytesWritten,
            NULL
            );
    }

ExitHere:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\util.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Header file for utility functions / classes

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#ifndef __UTIL_H__
#define __UTIL_H__

#include "tchar.h"
#include "error.h"
#include "resource.h"

int MessagePrint(
    LPTSTR szText,
    LPTSTR szTitle
    );

int MessagePrintIds (
    int             idsText
    );

LPTSTR AppendStringAndFree (
    LPTSTR szOld, 
    LPTSTR szToAppend
    );

void ReportError (
    HANDLE  hFile,
    HRESULT hr
    );

class TsecCommandLine
{
public:
    //
    //  Constructor/destructor
    //
    TsecCommandLine (LPTSTR szCommand)
    {
        m_fShowHelp     = FALSE;
        m_fError        = FALSE;
        m_fValidateOnly = FALSE;
        m_fValidateDU   = FALSE;
        m_fDumpConfig   = FALSE;
        m_szInFile      = NULL;

        ParseCommandLine (szCommand);
    }
    
    ~TsecCommandLine ()
    {
        if (m_szInFile)
        {
            delete [] m_szInFile;
        }
    }

    BOOL FShowHelp ()
    {
        return m_fShowHelp;
    }

    BOOL FValidateOnly()
    {
        return m_fValidateOnly;
    }

    BOOL FError()
    {
        return m_fError;
    }

    BOOL FValidateUser ()
    {
        return m_fValidateDU;
    }

    BOOL FDumpConfig ()
    {
        return m_fDumpConfig;
    }

    BOOL FHasFile ()
    {
        return ((m_szInFile != NULL) && (*m_szInFile != 0));
    }

    LPCTSTR GetInFileName ()
    {
        return m_szInFile;
    }

    void PrintUsage()
    {
        MessagePrintIds (IDS_USAGE);
    }

private:
    void ParseCommandLine (LPTSTR szCommand);

private:
    BOOL        m_fShowHelp;
    BOOL        m_fValidateOnly;
    BOOL        m_fError;
    BOOL        m_fValidateDU;
    BOOL        m_fDumpConfig;
    LPTSTR      m_szInFile;
};

#define MAX_IDS_BUFFER_SIZE     512

class CIds
{
public:

    //
    //  Constructor/destructor
    //
    CIds (UINT resourceID)
    {
        GetModuleHnd ();
        LoadIds (resourceID);
    }
    
    ~CIds ()
    {
        if (m_szString)
        {
            delete [] m_szString;
        }
    }

    LPTSTR GetString (void)
    {
        return (m_szString ? m_szString : (LPTSTR) m_szEmptyString);
    }

    BOOL StringFound (void)
    {
        return (m_szString != NULL);
    }

private:

    void LoadIds (UINT resourceID);
    void GetModuleHnd (void);

private:

    LPTSTR              m_szString;

    static const TCHAR  m_szEmptyString[2];
    static HMODULE      m_hModule;

};

#endif // util.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\resource.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource header file for the TAPI security file importing

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/

#ifndef __TSECIMP_RESOURCE_H__
#define __TSECIMP_RESOURCE_H__

#define SCHEMARES                       300

#define IDD_MSGBOX                      100

#define IDC_MSGBOX_TEXT                 100

#define IDS_SECFILE_SCHEMA              1000
#define IDR_SCHEMA                      1001
#define IDS_PRODUCTNAME                 1002
#define IDS_USAGE                       1003
#define IDS_ERRORPOS                    1004
#define IDS_FINSUCCESS                  1005
#define IDS_VALIDSUCCESS                1006
#define IDS_INVALADDR                   1007
#define IDS_INVALPID                    1008
#define IDS_INVALIDUSER                 1009
#define IDS_LOCALONLYPID                1010
#define IDS_LOCALONLYADDR               1011
#define IDS_HASERROR                    1012
#define IDS_PROVIDER                    1013
#define IDS_LINE                        1014
#define IDS_ADDRESSES                   1015
#define IDS_NODEVICES                   1016
#define IDS_ERROR                       1017
#define IDS_USERS                       1018
#define IDS_PID                         1019

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\parser.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    parser.h

Abstract:

    Header file for parsing XML file

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/

#ifndef __PARSER_H__
#define __PARSER_H__

#include "windows.h"
#include "objbase.h"
#include "msxml.h"

class CXMLLine
{
public:
    CXMLLine (IXMLDOMNode * pNode)
    {
        m_pLineNode = pNode;
    }

    ~CXMLLine ()
    {
        if (m_pLineNode)
        {
            m_pLineNode->Release();
        }
    }

    HRESULT GetNextLine (CXMLLine ** ppLine);

    HRESULT GetAddress (LPTSTR szBuf, DWORD cch);
    HRESULT GetPermanentID (ULONG * pID);
    HRESULT IsPermanentID (BOOL *pb);
    HRESULT IsRemove (BOOL *pb);
    
private:
    IXMLDOMNode     * m_pLineNode;
};

class CXMLUser
{
public:
    CXMLUser (IXMLDOMNode * pNode)
    {
        m_pUserNode = pNode;
    }

    ~CXMLUser ()
    {
        if (m_pUserNode)
        {
            m_pUserNode->Release();
        }
    }

    HRESULT GetFirstLine (CXMLLine ** ppLine);
    
    HRESULT GetNextUser (CXMLUser **ppNextUser);

    HRESULT GetDomainUser (LPTSTR szBuf, DWORD cch);
    HRESULT GetFriendlyName (LPTSTR szBuf, DWORD cch);
    HRESULT IsNoMerge (BOOL *pb);
    
private:
    IXMLDOMNode     * m_pUserNode;
};

class CXMLParser 
{
public:

    //
    //  Constructors / destructors
    //
    
    CXMLParser (void);
    ~CXMLParser ();

    //
    //  Public functions
    //

    HRESULT SetXMLFile (LPCTSTR szFile);
    HRESULT GetXMLFile (LPTSTR szFile, DWORD cch);

    HRESULT Parse (void);
    HRESULT ReportParsingError ();

    void Release()
    {
        if (m_pDocInput)
        {
            m_pDocInput->Release();
            m_pDocInput = NULL;
        }
    }

    //
    //  User transversal
    //
    HRESULT GetFirstUser (CXMLUser ** ppUser);

protected:

private:
    HRESULT CreateTempFiles ();

private:
    BOOL            m_bInited;
    
    TCHAR           m_szXMLFile[MAX_PATH];
    IXMLDOMDocument * m_pDocInput;

    TCHAR           m_szTempSchema[MAX_PATH];
    TCHAR           m_szTempXML[MAX_PATH];
};

#endif // parser.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\parser.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    parser.cpp

Abstract:

    Source file module for parsing XML file

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#include "windows.h"
#include "objbase.h"
#include "msxml.h"

#include "error.h"
#include "parser.h"
#include "resource.h"
#include "tchar.h"
#include "util.h"

const TCHAR CIds::m_szEmptyString[2] = _T("");

void WINAPI FormatString (
    LPTSTR          szFmt,
    LPTSTR          szOutput,
    DWORD           cchOutput,
    ...
    )
{
    va_list             ap;

    va_start (ap, cchOutput);

    FormatMessage (
        FORMAT_MESSAGE_FROM_STRING,
        szFmt,
        0,
        0,
        szOutput,
        cchOutput,
        &ap
        );
 
    va_end (ap);
}

///////////////////////////////////////////////////////////
//
//  CXMLParser implementation
//
///////////////////////////////////////////////////////////

//
//  With the XML file provided by the user, we create a temporary file
//  with the format of
//      <TsecRoot xmlns="x-schema:file://c:\temp\Sche1111.tmp">
//          Original XML file goes here
//      </TsecRoot>
//  for validating with the schema
//
char       gszXMLHeader1[] = "<TsecRoot xmlns=\"x-schema:file://";
char       gszXMLHeader2[] = "\">\r\n";
char       gszXMLTail[] = "\r\n</TsecRoot>";

//
//  Constructor / Destructor
//

CXMLParser::CXMLParser (void)
{
    m_bInited = FALSE;
    m_szXMLFile[0] = 0;
    m_szTempSchema[0] = 0;
    m_szTempXML[0] = 0;
    m_pDocInput = NULL;
}

CXMLParser::~CXMLParser ()
{
    if (m_pDocInput)
        m_pDocInput->Release();
}

//
//  Public functions
//

HRESULT CXMLParser::SetXMLFile (LPCTSTR szFile)
{
    HRESULT     hr = S_OK;
    OFSTRUCT    ofs;
    HANDLE      hFile;

    if (szFile == NULL ||
        _tcslen(szFile) > sizeof(m_szXMLFile)/sizeof(TCHAR) - 1)
    {
        hr = TSECERR_BADFILENAME;
        goto ExitHere;
    }
    if ((hFile = CreateFile (
        szFile,
        0,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        )) == INVALID_HANDLE_VALUE)
    {
        hr = TSECERR_FILENOTEXIST;
        goto ExitHere;
    }
    else
    {
        CloseHandle (hFile);
    }
    _tcscpy (m_szXMLFile, szFile);

ExitHere:
    return hr;
}

HRESULT CXMLParser::GetXMLFile (LPTSTR szFile, DWORD cch)
{
    return E_NOTIMPL;
}

HRESULT CXMLParser::CreateTempFiles ()
{
    HRESULT             hr = S_OK;
    
    TCHAR               szTempPath[MAX_PATH];
    char                szAnsiFile[MAX_PATH * sizeof(TCHAR)];

    HINSTANCE           hModule;
    HRSRC               hRes;
    HGLOBAL             hSchema;
    LPVOID              lpSchema;
    DWORD               dwSchemaSize;

    HANDLE              hFileSchema = NULL;
    DWORD               dwBytesWritten;
    HANDLE              hFileXML = NULL;

    HANDLE              hFileUserXML = NULL;
    DWORD               dwBytesRead;

    TCHAR               szBuf[256];
    
    //
    //  Prepare temporary file path
    //
    if (GetTempPath (sizeof(szTempPath)/sizeof(TCHAR), szTempPath) == 0 ||
        GetTempFileName (
            szTempPath,
            TEXT("Schema"),
            0,
            m_szTempSchema
            ) == 0 ||
        GetTempFileName (
            szTempPath,
            TEXT("XML"),
            0,
            m_szTempXML
            ) == 0
        )
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //
    //  Prepare the temporary file containing the schema
    //

    //  Load the schema.xml resource
    hModule = GetModuleHandle (NULL);
    if (hModule == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    hRes = FindResource (
        hModule,
        MAKEINTRESOURCE(IDR_SCHEMA),
        MAKEINTRESOURCE(SCHEMARES)
        );
    if (hRes == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    hSchema = LoadResource (
        hModule,
        hRes);
    if (hSchema == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    lpSchema = LockResource (hSchema);
    if (lpSchema == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    dwSchemaSize = SizeofResource (hModule, hRes);
    if (dwSchemaSize == 0)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Copy schema.xml into the temporary file
    hFileSchema = CreateFile (
        m_szTempSchema,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS | TRUNCATE_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileSchema == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    if (!WriteFile (
        hFileSchema,
        lpSchema,
        dwSchemaSize,
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    CloseHandle (hFileSchema);
    hFileSchema = INVALID_HANDLE_VALUE;

	//
	//	Now create the temp file for the XML file to be parsed
	//
    hFileXML = CreateFile (
        m_szTempXML,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS | TRUNCATE_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileXML == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Write the XML header
    if (!WriteFile (
        hFileXML,
        gszXMLHeader1,
        lstrlenA(gszXMLHeader1),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
#ifdef UNICODE
    if (WideCharToMultiByte (
            CP_ACP,
            0,
            m_szTempSchema,
            -1,
            szAnsiFile,
            sizeof(szAnsiFile),
            NULL,
            NULL
            ) == 0)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
#else
    lstrcpy (szAnsiFile, m_szTempSchema);
#endif
    if (!WriteFile (
        hFileXML,
        szAnsiFile,
        lstrlenA (szAnsiFile),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    if (!WriteFile (
        hFileXML,
        gszXMLHeader2,
        lstrlenA(gszXMLHeader2),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Copy over the input XML file
    hFileUserXML = CreateFile (
        m_szXMLFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileUserXML == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    while (ReadFile (
        hFileUserXML,
        szBuf,
        sizeof(szBuf),
        &dwBytesRead,
        NULL) &&
        dwBytesRead > 0)
    {
        if (!WriteFile (
            hFileXML,
            szBuf,
            dwBytesRead,
            &dwBytesWritten,
            NULL
            ))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
    }
    CloseHandle (hFileUserXML);
    hFileUserXML = INVALID_HANDLE_VALUE;

    //  Write the XML tail
    if (!WriteFile (
        hFileXML,
        gszXMLTail,
        lstrlenA(gszXMLTail),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    
    CloseHandle (hFileXML);
    hFileXML = INVALID_HANDLE_VALUE;

ExitHere:
    if (FAILED (hr))
    {
        m_szTempSchema[0] = 0;
        m_szTempXML[0] = 0;
    }
    if (hFileSchema != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileSchema);
    }
    if (hFileXML != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileXML);
    }
    if (hFileUserXML != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileUserXML);
    }
    return hr;
}

HRESULT CXMLParser::ReportParsingError ()
{
    HRESULT             hr = S_OK;
    IXMLDOMParseError   * pError = NULL;
    long                lErrCode;
    long                lLineNum;
    long                lLinePos;
    BSTR                szReason = NULL;
    BSTR                szSrc =NULL;
    LPTSTR              szError = NULL;
    TCHAR               szBuf[256];
    TCHAR               szBuf2[256];
    HINSTANCE           hModule;
    CIds                IdsError (IDS_ERROR);

    //  Check to make sure we have a document to work on
    if (m_pDocInput == NULL)
    {
        goto ExitHere;
    }

    //  Make sure we do have an error to report
    hr = m_pDocInput->get_parseError (&pError);
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    hr = pError->get_errorCode (&lErrCode);
    if (FAILED (hr) || lErrCode == 0)
    {
        goto ExitHere;
    }

    //  Collect error information
    if (
        (hr = pError->get_line (&lLineNum)) != 0 ||
        (hr = pError->get_linepos (&lLinePos)) != 0 ||
        (hr = pError->get_reason (&szReason)) != 0 ||
        (hr = pError->get_srcText (&szSrc)) != 0)
    {
        goto ExitHere;
    }

    //  adjust line number because we added one line
    --lLineNum;

    //
    //  Format error report
    //
    //  The format is similar to the following
    //
    //      Invalid XML file format
    //
    //      Failure reason goes here
    //
    //      Line 2, Pos 12
    //
    //      Failure source goes here
    //      -----^
    //
    hModule = GetModuleHandle (NULL);
    if (hModule == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Get the text of "Invalid XML file format"
    if (FormatMessage (
        FORMAT_MESSAGE_FROM_HMODULE, 
        hModule, 
        TSEC_INVALFILEFORMAT,
        0,
        szBuf,
        sizeof(szBuf)/sizeof(TCHAR),
        NULL
        ) == 0)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    szError = AppendStringAndFree (szError, szBuf);

    //  Put in the failure reason
    if (szError == NULL ||
        ((szError = AppendStringAndFree (szError, TEXT("\r\n"))) == NULL) ||
        ((szError = AppendStringAndFree (szError, szReason)) == NULL) ||
        ((szError = AppendStringAndFree (szError, TEXT("\r\n"))) == NULL)
        )
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  Get the error position string
    if (LoadString (
            hModule,
            IDS_ERRORPOS,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR)
            ) == 0
        )
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    FormatString (
        szBuf,
        szBuf2,
        sizeof(szBuf2)/sizeof(TCHAR),
        lLineNum,
        lLinePos
        );
    
    //  Put error position text & error source text
    if (
        ((szError = AppendStringAndFree (szError, szBuf2)) == NULL) ||
        ((szError = AppendStringAndFree (szError, TEXT("\r\n\r\n"))) == NULL) ||
        ((szError = AppendStringAndFree (szError, szSrc)) == NULL)
        )
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  If the error position is not too large, put ----^ to intuitively point
    //  to the place error occurred
    if (lLinePos < sizeof(szBuf)/sizeof(TCHAR) - 1 && lLinePos > 0)
    {
        szBuf[lLinePos] = 0;
        szBuf[--lLinePos] = TEXT('^');
        while (lLinePos > 0)
        {
            szBuf[--lLinePos] = TEXT('-');
        }
        if (
            ((szError = AppendStringAndFree (szError, TEXT("\r\n"))) == NULL) ||
            ((szError = AppendStringAndFree (szError, szBuf)) == NULL)
            )
        {
            hr = TSECERR_NOMEM;
            goto ExitHere;
        }
    }

    //
    //  Now report the error
    //
    MessagePrint (szError, IdsError.GetString ());

ExitHere:
    if (pError)
    {
        pError->Release ();
    }
    SysFreeString (szReason);
    SysFreeString (szSrc);
    if (szError)
    {
        delete [] szError;
    }
    return hr;
}

HRESULT CXMLParser::Parse (void)
{
    HRESULT             hr = S_OK;
    IXMLDOMDocument     * pDocInput = NULL;
    VARIANT_BOOL        bSuccess;
    VARIANT             varXMLFile;

    //  Ensure we have an xml file to process
    if (*m_szXMLFile == 0)
    {
        hr = TSECERR_BADFILENAME;
        goto ExitHere;
    }

    hr = CreateTempFiles ();
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    //  Create XMLDOMDocument object
    hr = CoCreateInstance (
        CLSID_DOMFreeThreadedDocument,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IXMLDOMDocument,
        (void **)&pDocInput
        );
    if (FAILED (hr) || pDocInput == NULL)
    {
        goto ExitHere;
    }

    //   Set the validateOnParse property
    hr = pDocInput->put_validateOnParse(VARIANT_TRUE);
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    //  We do a synchronous load for now
    hr = pDocInput->put_async (VARIANT_TRUE);
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    
    //  Parse the document
    VariantInit (&varXMLFile);
    V_VT(&varXMLFile) = VT_BSTR;
    V_BSTR(&varXMLFile) = SysAllocString (m_szTempXML);
    hr = pDocInput->load (
        varXMLFile,
        &bSuccess
        );
    SysFreeString (V_BSTR(&varXMLFile));
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    if (bSuccess != VARIANT_TRUE)
    {
        hr = TSECERR_INVALFILEFORMAT;
    }
    m_pDocInput = pDocInput;
    pDocInput = NULL;

ExitHere:
    if (pDocInput != NULL)
    {
        pDocInput->Release();
    }
    if (m_szTempSchema[0] != 0)
    {
        DeleteFile (m_szTempSchema);
    }
    if (m_szTempXML[0] != 0)
    {
        DeleteFile (m_szTempXML);
    }
    return hr;
}

HRESULT CXMLParser::GetFirstUser (CXMLUser ** ppUser)
{
    HRESULT             hr = S_OK;
    IXMLDOMElement      * pEleRoot = NULL;
    IXMLDOMNode         * pFirstNode = NULL;
    BSTR                bstr = NULL;

    *ppUser = NULL;
    if (m_pDocInput == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    if (FAILED(hr = m_pDocInput->get_documentElement(&pEleRoot)) || 
        pEleRoot == NULL)
    {
        goto ExitHere;
    }
    if ((bstr = SysAllocString (L"UserList/User")) == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    if (FAILED(hr = pEleRoot->selectSingleNode (bstr, &pFirstNode)) ||
        pFirstNode == NULL)
    {
        goto ExitHere;
    }
    *ppUser = new CXMLUser (pFirstNode);
    if (*ppUser == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    else
    {
        pFirstNode->AddRef();
    }

ExitHere:
    if (pEleRoot)
    {
        pEleRoot->Release();
    }
    if (bstr)
    {
        SysFreeString (bstr);
    }
    if (pFirstNode)
    {
        pFirstNode->Release();
    }
    return hr;
}

///////////////////////////////////////////////////////////
//
//  CXMLUser implementation
//
///////////////////////////////////////////////////////////

HRESULT CXMLUser::GetNextUser (CXMLUser **ppNextUser)
{
    HRESULT             hr = S_OK;
    IXMLDOMNode         * pNodeNext = NULL;

    *ppNextUser = NULL;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    if (FAILED(hr = m_pUserNode->get_nextSibling (&pNodeNext)) ||
        pNodeNext == NULL)
    {
        goto ExitHere;
    }
    *ppNextUser = new CXMLUser (pNodeNext);
    if (*ppNextUser == NULL)
    {
        hr = TSECERR_NOMEM;
//        goto ExitHere;
    }
    else
    {
        pNodeNext->AddRef();
    }
    
ExitHere:
    if (pNodeNext)
    {
        pNodeNext->Release();
    }
    return hr;
}

HRESULT CXMLUser::GetDomainUser (LPTSTR szBuf, DWORD cch)
{
    HRESULT             hr = S_OK;
    IXMLDOMNode         * pNodeDU = NULL;
    BSTR                bstrDU = NULL;
    BSTR                bstrText = NULL;

    szBuf[0] = 0;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrDU = SysAllocString (L"DomainUser");
    if (bstrDU == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pUserNode->selectSingleNode (bstrDU, &pNodeDU);
    if (FAILED (hr) || pNodeDU == NULL)
    {
        goto ExitHere;
    }
    hr = pNodeDU->get_text (&bstrText);
    if (FAILED (hr) || bstrText == NULL)
    {
        goto ExitHere;
    }
    _tcsncpy (szBuf, bstrText, cch);
    szBuf[cch - 1] = 0;
    
ExitHere:
    if (pNodeDU)
    {
        pNodeDU->Release();
    }
    if (bstrDU)
    {
        SysFreeString (bstrDU);
    }
    if (bstrText)
    {
        SysFreeString (bstrText);
    }
    if (szBuf[0] == 0)
    {
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CXMLUser::GetFriendlyName (LPTSTR szBuf, DWORD cch)
{
    HRESULT             hr = S_OK;
    IXMLDOMNode         * pNodeFN = NULL;
    BSTR                bstrFN = NULL;
    BSTR                bstrText = NULL;

    szBuf[0] = 0;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrFN = SysAllocString (L"FriendlyName");
    if (bstrFN == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pUserNode->selectSingleNode (bstrFN, &pNodeFN);
    if (FAILED (hr) || pNodeFN == NULL)
    {
        goto ExitHere;
    }
    hr = pNodeFN->get_text (&bstrText);
    if (FAILED (hr) || bstrText == NULL)
    {
        goto ExitHere;
    }
    _tcsncpy (szBuf, bstrText, cch);
    szBuf[cch - 1] = 0;
    
ExitHere:
    if (pNodeFN)
    {
        pNodeFN->Release();
    }
    if (bstrFN)
    {
        SysFreeString (bstrFN);
    }
    if (bstrText)
    {
        SysFreeString (bstrText);
    }
    return hr;
}

HRESULT CXMLUser::IsNoMerge (BOOL *pb)
{
    HRESULT             hr = S_OK;
    IXMLDOMNamedNodeMap * pAttribs = NULL;
    IXMLDOMNode         * pAttrib = NULL;
    BSTR                bstrNM = NULL;
    VARIANT             varNM;

    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    hr = m_pUserNode->get_attributes(&pAttribs);
    if (FAILED (hr) || pAttribs == NULL)
    {
        goto ExitHere;
    }
    bstrNM = SysAllocString (L"NoMerge");
    if (bstrNM == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = pAttribs->getNamedItem(bstrNM, &pAttrib);
    if (FAILED (hr) || pAttrib == NULL)
    {
        goto ExitHere;
    }
    VariantInit (&varNM);
    hr = pAttrib->get_nodeTypedValue (&varNM);
    if (FAILED(hr))
    {
        VariantClear (&varNM);
        goto ExitHere;
    }
    if (V_VT(&varNM) == VT_BOOL)
    {
        *pb = (V_BOOL(&varNM) == VARIANT_TRUE) ? TRUE : FALSE;
    }
    else if (V_VT(&varNM) == VT_BSTR)
    {
        *pb = (V_BSTR(&varNM)[0] == L'1') ? TRUE : FALSE;
    }
    else
    {
        *pb = FALSE;
    }
    VariantClear (&varNM);
    
ExitHere:
    if (bstrNM)
    {
        SysFreeString (bstrNM);
    }
    if (pAttrib)
    {
        pAttrib->Release();
    }
    if (pAttribs)
    {
        pAttribs->Release();
    }
    return hr;
}

HRESULT CXMLUser::GetFirstLine (CXMLLine ** ppLine)
{
    HRESULT             hr = S_OK;
    BSTR                bstrLine = NULL;
    IXMLDOMNode         * pNodeLine = NULL;

    *ppLine = NULL;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    
    bstrLine = SysAllocString (L"LineList/Line");
    if (bstrLine == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pUserNode->selectSingleNode (bstrLine, &pNodeLine);
    if (FAILED(hr) || pNodeLine == NULL)
    {
        goto ExitHere;
    }
    *ppLine = new CXMLLine (pNodeLine);
    if (*ppLine == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    else
    {
        pNodeLine->AddRef();
    }
    
ExitHere:
    if (pNodeLine)
    {
        pNodeLine->Release();
    }
    if (bstrLine)
    {
        SysFreeString (bstrLine);
    }
    return hr;
}

///////////////////////////////////////////////////////////
//
//  CXMLLine implementation
//
///////////////////////////////////////////////////////////

HRESULT CXMLLine::GetNextLine (CXMLLine ** ppLine)
{
    HRESULT         hr = S_OK;
    IXMLDOMNode     * pNodeNext = NULL;

    *ppLine = NULL;
    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    hr = m_pLineNode->get_nextSibling (&pNodeNext);
    if (FAILED(hr) || pNodeNext == NULL)
    {
        goto ExitHere;
    }
    *ppLine = new CXMLLine (pNodeNext);
    if (*ppLine == NULL)
    {
        hr = TSECERR_NOMEM;
    }
    else
    {
        pNodeNext->AddRef();
    }

ExitHere:
    if (pNodeNext)
    {
        pNodeNext->Release();
    }
    return hr;
}

HRESULT CXMLLine::GetAddress (LPTSTR szBuf, DWORD cch)
{
    HRESULT         hr = S_OK;
    BSTR            bstrAddr = NULL;
    BSTR            bstrText = NULL;
    IXMLDOMNode     * pNodeAddr = NULL;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrAddr = SysAllocString (L"Address");
    if (bstrAddr == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pLineNode->selectSingleNode (bstrAddr, &pNodeAddr);
    if (FAILED(hr) || pNodeAddr == NULL)
    {
        goto ExitHere;
    }
    hr = pNodeAddr->get_text(&bstrText);
    if (FAILED(hr) || bstrText == NULL)
    {
        goto ExitHere;
    }
    _tcsncpy (szBuf, bstrText, cch);
    szBuf[cch - 1] = 0;

ExitHere:
    if (bstrAddr)
    {
        SysFreeString (bstrAddr);
    }
    if (bstrText)
    {
        SysFreeString (bstrText);
    }
    if (pNodeAddr)
    {
        pNodeAddr->Release();
    }
    return hr;
}

HRESULT CXMLLine::GetPermanentID (ULONG * pID)
{
    HRESULT         hr = S_OK;
    BSTR            bstrPID = NULL;
    IXMLDOMNode     * pNodePID = NULL;
    VARIANT         varPID;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrPID = SysAllocString (L"PermanentID");
    if (bstrPID == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pLineNode->selectSingleNode (bstrPID, &pNodePID);
    if (FAILED(hr) || pNodePID == NULL)
    {
        goto ExitHere;
    }
    VariantInit (&varPID);
    hr = pNodePID->get_nodeTypedValue(&varPID);
    if (FAILED(hr))
    {
        VariantClear (&varPID);
        goto ExitHere;
    }
    if (V_VT(&varPID) == VT_UI4)
    {
        *pID = (ULONG) V_UI4(&varPID);
    }
    else
    {
        hr = S_FALSE;
        *pID = 0;
    }
    VariantClear (&varPID);

ExitHere:
    if (bstrPID)
    {
        SysFreeString (bstrPID);
    }
    if (pNodePID)
    {
        pNodePID->Release();
    }
    return hr;
}

HRESULT CXMLLine::IsPermanentID (BOOL *pb)
{
    HRESULT         hr = S_OK;
    BSTR            bstrPID = NULL;
    IXMLDOMNode     * pNodePID = NULL;
    VARIANT         varPID;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrPID = SysAllocString (L"PermanentID");
    if (bstrPID == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pLineNode->selectSingleNode (bstrPID, &pNodePID);
    if (FAILED(hr) || pNodePID == NULL)
    {
        *pb = FALSE;
        hr = S_OK;
    }
    else
    {
        *pb = TRUE;
    }

ExitHere:
    if (pNodePID)
    {
        pNodePID->Release();
    }
    if (bstrPID)
    {
        SysFreeString (bstrPID);
    }
    return hr;
}

HRESULT CXMLLine::IsRemove (BOOL *pb)
{
    HRESULT             hr = S_OK;
    IXMLDOMNamedNodeMap * pAttribs = NULL;
    IXMLDOMNode         * pAttrib = NULL;
    BSTR                bstrRM = NULL;
    VARIANT             varRM;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    hr = m_pLineNode->get_attributes(&pAttribs);
    if (FAILED (hr) || pAttribs == NULL)
    {
        goto ExitHere;
    }
    bstrRM = SysAllocString (L"Remove");
    if (bstrRM == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = pAttribs->getNamedItem(bstrRM, &pAttrib);
    if (FAILED (hr) || pAttrib == NULL)
    {
        goto ExitHere;
    }
    VariantInit (&varRM);
    hr = pAttrib->get_nodeTypedValue (&varRM);
    if (FAILED(hr))
    {
        VariantClear (&varRM);
        goto ExitHere;
    }
    if (V_VT(&varRM) == VT_BOOL)
    {
        *pb = (V_BOOL(&varRM) == VARIANT_TRUE) ? TRUE : FALSE;
    }
    else if(V_VT(&varRM) == VT_BSTR)
    {
        *pb = (V_BSTR(&varRM)[0] == L'1') ? TRUE : FALSE;
    }
    else
    {
        *pb = FALSE;
    }
    VariantClear (&varRM);
    
ExitHere:
    if (bstrRM)
    {
        SysFreeString (bstrRM);
    }
    if (pAttrib)
    {
        pAttrib->Release();
    }
    if (pAttribs)
    {
        pAttribs->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\watchit\watchit.cpp ===
#define STRICT

#include "windows.h"
#include "windowsx.h"
#include "tapi.h"
#include "shellapi.h"

#include "watchit.h"
#include "tapiperf.h"


#if DBG
#define DBGOUT(arg) DbgPrt arg
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PCHAR DbgMessage,
    IN ...
    );
#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)
#else
#define DBGOUT(arg)
#define DOFUNC(arg1,arg2) DoFunc(arg1)
#endif


//***************************************************************************
static TCHAR gszHELPfilename [] = TEXT("watchit.HLP");
static TCHAR gszwatchitClassName[] = TEXT("WATCHIT_Class");
static TCHAR gszAppName[64];


#define MAXBUFSIZE (256)

typedef  LONG (* PERFPROC)(PERFBLOCK *);
PERFPROC    glpfnInternalPerformance = NULL;
BOOL        gfTapiSrvRunning = FALSE;
PPERFBLOCK  gpPerfBlock = NULL;

HWND       ghWndMain;
HINSTANCE  ghInst;
HINSTANCE  ghTapiInst;
HLINEAPP   ghLineApp;

TCHAR      gszBuf[MAXBUFSIZE];


//***************************************************************************
//***************************************************************************
//***************************************************************************
UINT LoadUI()
{
    return(0);
}



//***************************************************************************
UINT ReadINI()
{
    return( 0 );
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
void CheckForTapiSrv()
{
    SC_HANDLE               sc, scTapiSrv;
    SERVICE_STATUS          ServStat;

    sc = OpenSCManager(NULL,
                       NULL,
                       GENERIC_READ);

    if (NULL == sc)
    {
        return;
    }

    gfTapiSrvRunning = FALSE;

    scTapiSrv = OpenService(sc,
                            TEXT("TAPISRV"),
                            SERVICE_QUERY_STATUS);


    if (!QueryServiceStatus(scTapiSrv,
                            &ServStat))
    {
    }

    if (ServStat.dwCurrentState != SERVICE_RUNNING)
    {
    }
    else
    {
        gfTapiSrvRunning = TRUE;
    }

    if (gfTapiSrvRunning)
    {
        ghTapiInst = LoadLibrary(TEXT("tapi32.dll"));

        if (!ghTapiInst)
        {
        }
        else
        {
            glpfnInternalPerformance = (PERFPROC)GetProcAddress( ghTapiInst,
                                                             "internalPerformance");
        }


        if (!glpfnInternalPerformance)
        {
           //TODO: Say something!
        }

    }

    CloseServiceHandle(sc);

}





//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
        static HICON hIconLarge;
        static HICON hIconSmall;
        static HICON hIconDeadTapiSrv;
        static BOOL  fStarted = FALSE;
        static BOOL fDoSmall = FALSE;
        static const DWORD aMenuHelpIDs[] =
        {
//              IDD_DBUTTONPOUND,    IDH_DIALER_DIAL_KEYPAD,
                0,                   0
        };

//MessageBox(GetFocus(), "WM_INI", "Hitting", MB_OK);
        switch (msg)
        {
            case WM_ERASEBKGND:
                return( 1 );  // We handled it.  No, really... would I lie? :-)


            case WM_TIMER:
            {
                RECT rect;

                if ( fStarted )
                {
//                    SetDlgItemText( ghWndMain, IDC_AVG_TIME_TO_NEXT_CUE, szInfo );
                    fStarted = TRUE;
                }

                DBGOUT((0, "Heartbeat..."));

//                InvalidateRect( ghWndMain, NULL, TRUE );

                rect.left = 0;
                rect.top = 0;
                rect.right = 32;
                rect.bottom = 32;
                InvalidateRect( ghWndMain, &rect, FALSE );

                fDoSmall = !(fDoSmall);
            }
            break;


            case WM_INITDIALOG:
            {
//MessageBox(GetFocus(), "WM_INI", "Hitting", MB_OK);

                hIconLarge = LoadIcon( ghInst, (LPCTSTR) MAKEINTRESOURCE( IDI_LARGE ) );
                hIconSmall = LoadIcon( ghInst, (LPCTSTR) MAKEINTRESOURCE( IDI_SMALL ) );
                hIconDeadTapiSrv = LoadIcon( ghInst, (LPCTSTR) MAKEINTRESOURCE( IDI_DEADTAPISRV ) );

                SetTimer( hwnd, 1, 1000, NULL );

                return TRUE;
            }


            case WM_SYSCOMMAND:
                switch( (DWORD) wParam )
                {
                    case SC_CLOSE:
                        PostQuitMessage(0);
                }
                break;


            //
            // processes clicks on controls when
            // context mode help is selected
            //
            case WM_HELP:
                WinHelp (
                         (HWND)( (LPHELPINFO) lParam)->hItemHandle,
                         gszHELPfilename,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPVOID) aMenuHelpIDs
                        );
                return TRUE;


            //
            // processes right-clicks on controls
            //
            case WM_CONTEXTMENU:
                WinHelp (
                         (HWND)wParam,
                         gszHELPfilename,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aMenuHelpIDs
                        );
                return TRUE;


            case WM_COMMAND:
            {

                switch( LOWORD( (DWORD)wParam ) )
                {
                    // FILE menu
                    case IDM_EXIT:
                        PostQuitMessage(0);
                        return TRUE;


                    // HELP menu
                    case IDM_HELP_CONTENTS:
                        WinHelp(ghWndMain, gszHELPfilename, HELP_CONTENTS, 0);
                        return TRUE;


                    case IDM_HELP_WHATSTHIS:
                        PostMessage(ghWndMain, WM_SYSCOMMAND, SC_CONTEXTHELP, 0);
                        return TRUE;


                    case IDM_ABOUT:
                        ShellAbout(
                                   ghWndMain,
                                   gszAppName,
                                   TEXT(""),
                                   LoadIcon(ghInst, (LPCTSTR)IDI_LARGE)
                                  );
//                        DialogBoxParam(
//                                       ghInst,
//                                       MAKEINTRESOURCE(IDD_ABOUT),
//                                       ghWndMain,
//                                       (DLGPROC)AboutProc,
//                                       0
//                                      );
                        return TRUE;


                } // end switch (LOWORD((DWORD)wParam)) { ... }
                break; // end case WM_COMMAND

            }


           case WM_PAINT:
            {
                PAINTSTRUCT ps;
                RECT rc;
                HDC hdcMem;
                HBITMAP hbmMem, hbmOld;


                BeginPaint(hwnd, &ps);


                //
                // Get the size of the client rectangle.
                //

                GetClientRect(hwnd, &rc);

                //
                // Create a compatible DC.
                //

                hdcMem = CreateCompatibleDC(ps.hdc);

                //
                // Create a bitmap big enough for our client rectangle.
                //

                hbmMem = CreateCompatibleBitmap(ps.hdc,
                                                rc.right-rc.left,
                                                rc.bottom-rc.top);

                //
                // Select the bitmap into the off-screen DC.
                //

                hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);

                //
                // Erase the background.
                //

//                hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
//                hbrBkGnd = CreateSolidBrush(COLOR_3DFACE + 1);
//                FillRect(hdcMem, &rc, hbrBkGnd);
                FillRect(hdcMem, &rc, (HBRUSH)(COLOR_3DFACE + 1) );
//                DeleteObject(hbrBkGnd);

                //
                // Render the image into the offscreen DC.
                //

                SetBkMode(hdcMem, TRANSPARENT);



//                if(IsIconic(ghWndMain))
//                    DrawIcon(ps.hdc, 0, 0, fDoSmall ? hIconSmall : hIconLarge);
//                else
                {
                   int nSize;

                   if ( gpPerfBlock )
                   {
                     if (
                           ( NULL == glpfnInternalPerformance )
                         ||
                           ( LINEERR_OPERATIONFAILED ==
                                  glpfnInternalPerformance(gpPerfBlock) )
                        )
                     {
                           gpPerfBlock->dwClientApps = 1;

                           DrawIcon( hdcMem,
                                  0,
                                  0,
                                  hIconDeadTapiSrv
                                );

                           //
                           // Check again so that next time around, we'll
                           // display stuff if TAPISRV has started
                           //
                           CheckForTapiSrv();

                     }
                     else
                     {
                        DrawIcon( hdcMem,
                                  0,
                                  0,
                                  fDoSmall ? hIconSmall : hIconLarge
                                );

                     }


                     //
                     // Blt the changes to the screen DC.
                     //

                     BitBlt(ps.hdc,
                            rc.left, rc.top,
                            rc.right-rc.left, rc.bottom-rc.top,
                            hdcMem,
                            0, 0,
                            SRCCOPY);


                     nSize = wsprintf( gszBuf,
                                       TEXT("%ld"),
                                       gpPerfBlock->dwClientApps - 1 // don't count me
                                     );

                     SetDlgItemText( ghWndMain, IDC_NUMCLIENTSTEXT, gszBuf );

                     nSize = wsprintf( gszBuf,
                                       TEXT("%ld"),
                                       gpPerfBlock->dwCurrentOutgoingCalls
                                     );

                     SetDlgItemText( ghWndMain, IDC_NUMOUTCALLSTEXT, gszBuf );

                     nSize = wsprintf( gszBuf,
                                       TEXT("%ld"),
                                       gpPerfBlock->dwCurrentIncomingCalls
                                     );

                     SetDlgItemText( ghWndMain, IDC_NUMINCALLSTEXT, gszBuf );

                   }

                }


                //
                // Done with off-screen bitmap and DC.
                //

                SelectObject(hdcMem, hbmOld);
                DeleteObject(hbmMem);
                DeleteDC(hdcMem);


                EndPaint(ghWndMain, &ps);

                return TRUE;
            }



            default:
                ;
                //            return DefDlgProc( hwnd, msg, wParam, lParam );
                //            return DefWindowProc( hwnd, msg, wParam, lParam );


        } // switch (msg) { ... }

        return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
void FAR PASCAL TAPICallback( DWORD hDevice,
                              DWORD dwMsg,
                              DWORD dwCallbackInstance,
                              DWORD dwParam1,
                              DWORD dwParam2,
                              DWORD dwParam3
                            )
{
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
int WINAPI WinMain (
                                        HINSTANCE hInstance,
                                        HINSTANCE hPrevInstance,
                                        LPSTR lpCmdLine,
                                        int nCmdShow
                                   )
{
//      HACCEL hAccel;
        MSG msg;
//      DWORD errCode;
//      HANDLE hImHere;
//        DWORD dwNumDevs;
//        DWORD dwAPIVersion = 0x00020000;
//        LINEINITIALIZEEXPARAMS LineInitializeExParams = {
//                                   sizeof( LINEINITIALIZEEXPARAMS ),
//                                   0,
//                                   0,
//                                   0,
//                                   0,
//                                   0
//                                   };

//    MessageBox(GetFocus(), "Starting", "Starting", MB_OK);

DBGOUT((0, "starting"));

        ghInst = GetModuleHandle( NULL );
        LoadString( ghInst,
                    WATCHIT_STRING_FRIENDLYNAME,
                    gszAppName,
                    sizeof(gszAppName)/sizeof(TCHAR)
                  );


//
//      //
//      // Now, let's see if we've already got an instance of ourself
//  //
//      hImHere = CreateMutex(NULL, TRUE, "watchit_IveBeenStartedMutex");
//
//
//      //
//      // Is there another one of us already here?
//      if ( ERROR_ALREADY_EXISTS == GetLastError() )
//      {
//        HWND        hDialerWnd;
//
//        hDialerWnd = FindWindow(gszDialerClassName,
//                                NULL);
//
//        SetForegroundWindow(hDialerWnd);
//
//         CloseHandle( hImHere );
//         return 0;
//      }


        {
                WNDCLASS wc;
                wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;
                wc.lpfnWndProc = DefDlgProc;
                wc.cbClsExtra = 0;
                wc.cbWndExtra = DLGWINDOWEXTRA;
                wc.hInstance = ghInst;
                wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_LARGE) );
                wc.hCursor = LoadCursor(NULL, IDC_ARROW);

                wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);

                wc.lpszMenuName = NULL;
                wc.lpszClassName = gszwatchitClassName;
                if ( 0 == RegisterClass(&wc) )
                {
                   DBGOUT((0, "RegisterClass failed.  GetLastError() = 0x%08lx",
                       GetLastError() ));

                   return 0;
                }
        }


DBGOUT((0, "about to create"));

        // create the dialog box and set it with info
        // from the .INI file
        ghWndMain = CreateDialog (
            ghInst,
            (LPCTSTR)MAKEINTRESOURCE(IDD_MAIN_WATCHIT),
            (HWND)NULL,
            MainWndProc
            );

        if ( ReadINI() )
    {
        MessageBox( GetFocus(),
                    TEXT("INI File is broken."),
                    TEXT("This is not good"),
                    MB_OK
                  );
    }

    if ( LoadUI() )
    {
        MessageBox( GetFocus(),
                    TEXT("UI Load is broken."),
                    TEXT("This is not good"),
                    MB_OK
                  );
    }


    CheckForTapiSrv();

    gpPerfBlock = (PPERFBLOCK)LocalAlloc(LPTR, sizeof(PERFBLOCK));

//      errCode = lineInitializeEx(
//                                &ghLineApp,
//                                NULL,
//                                TAPICallback,
//                                gszAppName,
//                                &dwNumDevs,
//                                &dwAPIVersion,
//                                &LineInitializeExParams
//                              );

        ShowWindow(ghWndMain, SW_SHOW);

        UpdateWindow(ghWndMain);

//      hAccel = LoadAccelerators(ghInst, gszAppName);

        while ( GetMessage( &msg, NULL, 0, 0 ) )
        {
                if ( ghWndMain == NULL || !IsDialogMessage( ghWndMain, &msg ) )
                {
//                      if(!TranslateAccelerator(ghWndMain, hAccel, &msg))
                        {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                        }
                }
        }


//
//      CloseHandle( hImHere );
//

    KillTimer( ghWndMain, 1);

    if ( gpPerfBlock )
    {
       LocalFree( gpPerfBlock );
    }

    if ( ghTapiInst )
    {
       FreeLibrary( ghTapiInst );
    }


    return (int) msg.wParam;
}






#if DBG


#include "stdarg.h"
#include "stdio.h"


VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = 0;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        CHAR    buf[256] = "WATCHIT: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintfA (&buf[8],
                  lpszFormat,
                  ap
                  );

        lstrcatA(buf, "\n");

        OutputDebugStringA(buf);

        va_end(ap);
    }
}
#endif









// //***************************************************************************
// //***************************************************************************
// //***************************************************************************
// BOOL CALLBACK AboutProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
//     {
//     switch(msg)
//         {
//         case WM_INITDIALOG:
//             {
//             TCHAR sz[MAXBUFSIZE];
//             TCHAR szLabel[MAXBUFSIZE];
//
//             // sets up the version number for Windows
//             GetDlgItemText(hwnd, IDD_ATEXTTITLE, sz, MAXBUFSIZE);
//             wsprintf(
//                 szLabel,
//                 sz,
//                 LOWORD(GetVersion()) & 0xFF,
//                 HIBYTE(LOWORD(GetVersion)) == 10 ? 1 : 0
//                 );
//             SetDlgItemText(hwnd, IDD_ATEXTTITLE, szLabel);
//
// /*            // sets up version number for Dialer
//             GetDlgItemText(hwnd, IDD_ATEXTVERSION, sz, MAXBUFSIZE);
//             wsprintf(szLabel, sz, VER_MAJOR, VER_MINOR, VER_BUILD);
//
//
//             { // strip off build number for release copies
//             DWORD i;
//             LPSTR ch = szLabel;
//
//             for (i = 0; i < 2 && *ch; ++ch)
//                 {
//                 if(*ch == '.')
//                     ++i;
//                 if(i == 2)
//                     *ch = 0;
//                 }
//
//             SetDlgItemText(hwnd ,IDD_ATEXTVERSION, szLabel);
//             } */
//
//
// /*            // get free memory information
//             GetDlgItemText(hwnd, IDD_ATEXTFREEMEM, sz, MAXBUFSIZE);
//             wsprintf(szLabel, sz, GetFreeSpace(0)>>10);
//             SetDlgItemText(hwnd, IDD_ATEXTFREEMEM, szLabel);
//
//             // get free resources information
//             GetDlgItemText(hwnd, IDD_ATEXTRESOURCE, sz,MAXBUFSIZE);
//             wsprintf(szLabel, sz, GetFreeSystemResources(0));
//             SetDlgItemText(hwnd, IDD_ATEXTRESOURCE, szLabel); */
//
//             return TRUE;
//             }
//
//         case WM_COMMAND:
//             if(LOWORD((DWORD)wParam) == IDOK)
//                 {
//                 EndDialog(hwnd, TRUE);
//                 return TRUE;
//                 }
//             break;
//         }
//     return FALSE;
//     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\watchit\watchit.h ===
#define IDD_MAIN_WATCHIT   1000
#define IDD_ABOUT          1001
#define IDD_ATEXTTITLE     1002
#define IDD_ATEXTCOPYRIGHT 1003


#define IDM_EXIT                 100
#define IDM_HELP_CONTENTS        101
#define IDM_HELP_WHATSTHIS       102
#define IDM_ABOUT                103


#define IDC_NUMCLIENTSTEXT    3000
#define IDC_NUMOUTCALLSTEXT   3001
#define IDC_NUMINCALLSTEXT	  3002


#define IDI_MAIN              2000
#define IDI_LARGE             2001
#define IDI_SMALL             2002
#define IDI_DEADTAPISRV       2003


#define WATCHIT_STRING_APPNAME         600
#define WATCHIT_STRING_FRIENDLYNAME    601
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\card.h ===
/****************************************************************************
 
  Copyright (c) 1998  Microsoft Corporation
                                                              
  Module Name:  card.h
                                                              
     Abstract:  Calling Card Object definitions
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#ifndef __CARD_H_
#define __CARD_H_

#include "utils.h"
#include "rules.h"



#define MAXLEN_CARDNAME            96
#define MAXLEN_PIN                 128
#define MAXLEN_RULE                128

#define CARD_BUILTIN  1
#define CARD_HIDE     2

// Calling Card Validation Flags
#define CCVF_NOCARDNAME                     0x01
#define CCVF_NOCARDRULES                    0x02
#define CCVF_NOCARDNUMBER                   0x04
#define CCVF_NOPINNUMBER                    0x08
#define CCVF_NOINTERNATIONALACCESSNUMBER    0x10
#define CCVF_NOLOCALACCESSNUMBER            0x20
#define CCVF_NOLONGDISTANCEACCESSNUMBER     0x40


//***************************************************************************
//
//  Class Definition - CCallingCard
//
//***************************************************************************
class CCallingCard
{
private:

    DWORD       m_dwCardID;
    PWSTR       m_pszCardName;
    
    DWORD       m_dwFlags;

    PWSTR       m_pszPIN;
    PWSTR       m_pszEncryptedPIN;
    PWSTR       m_pszAccountNumber;

    PWSTR       m_pszLocalAccessNumber;
    PWSTR       m_pszLongDistanceAccessNumber;
    PWSTR       m_pszInternationalAccessNumber;
    
    CRuleSet    m_Rules;

    HKEY        m_hCard;
    PTSTR       m_pszCardPath;

    BOOL        m_bDirty;
    BOOL        m_bDeleted;
    
    DWORD       m_dwCryptInitResult;

private:
    void        CleanUp(void);
    DWORD       OpenCardKey(BOOL bWrite);
    DWORD       CloseCardKey();
    DWORD       ReadOneStringValue(PWSTR *pMember, const TCHAR *pszName);

    DWORD       EncryptPIN(void);
    DWORD       DecryptPIN(void);

public:
    CCallingCard(); 

    ~CCallingCard();

	DECLARE_TRACELOG_CLASS(CCallingCard)

	HRESULT Initialize   (
                            DWORD dwCardID,
                            PWSTR pszCardName,
                            DWORD dwFlags,
                            PWSTR pszPIN,
                            PWSTR pszAccountNumber,
                            PWSTR pszInternationalRule,
                            PWSTR pszLongDistanceRule,
                            PWSTR pszLocalRule,
                            PWSTR pszInternationalAccessNumber,
                            PWSTR pszLongDistanceAccessNumber,
                            PWSTR pszLocalAccessNumber
                         );
    HRESULT Initialize  (  DWORD dwCardID);

    HRESULT SaveToRegistry(void);
    HRESULT MarkDeleted(void);
    DWORD   IsMarkedDeleted(void) const {return m_bDeleted || (m_dwFlags & CARD_HIDE);};
    DWORD   IsMarkedHidden(void) const {return (m_dwFlags & CARD_HIDE) != 0;};
    DWORD   IsMarkedPermanent(void) const {return (m_dwFlags & CARD_BUILTIN) != 0;};

    DWORD   Validate(void);

#define GET_SET_METHOD(Member)                                 \
    PWSTR   Get##Member(void) const { return m_psz##Member; }; \
    HRESULT Set##Member(PWSTR) ;                        

    GET_SET_METHOD(CardName)
    GET_SET_METHOD(PIN);
    GET_SET_METHOD(AccountNumber);
    GET_SET_METHOD(InternationalAccessNumber);
    GET_SET_METHOD(LongDistanceAccessNumber);
    GET_SET_METHOD(LocalAccessNumber);


#define m_pszInternationalRule  m_Rules.m_pszInternationalRule
#define m_pszLongDistanceRule   m_Rules.m_pszLongDistanceRule
#define m_pszLocalRule          m_Rules.m_pszLocalRule

    GET_SET_METHOD(InternationalRule);
    GET_SET_METHOD(LongDistanceRule);
    GET_SET_METHOD(LocalRule);

#undef m_pszInternationalRule
#undef m_pszLongDistanceRule
#undef m_pszLocalRule

#undef GET_SET_METHOD

    CRuleSet * GetRuleSet(){return &m_Rules;}

    DWORD   GetCardID(void) const {return m_dwCardID;}
    HRESULT SetCardID(DWORD dwCardID) {m_dwCardID=dwCardID; return S_OK;}
};

//***************************************************************************
// Fill out the list template

typedef LinkedList<CCallingCard *> CCallingCardList;
typedef ListNode<CCallingCard *> CCallingCardNode;

//***************************************************************************
//
//  Class Definition - CCallingCards
//
//***************************************************************************
class CCallingCards
{
private:

    DWORD               m_dwNumEntries;
    DWORD               m_dwNextID;
    CCallingCardList    m_CallingCardList;
    CCallingCardList    m_DeletedCallingCardList;
    HKEY                m_hCards;

    CCallingCardNode    *m_hEnumNode;
    BOOL                m_bEnumInclHidden;
    
private:
    DWORD               CreateFreshCards(void);

    void                InternalDeleteCard(CCallingCardNode *);

public:
    CCallingCards();
    ~CCallingCards();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCallingCards)
#endif

    HRESULT     Initialize(void);
    HRESULT     SaveToRegistry(void);

    void        AddCard(CCallingCard *pNewCard) {m_CallingCardList.tail()->insert_after(pNewCard); m_dwNumEntries++;};
    void        RemoveCard(CCallingCard *pCard);
    void        RemoveCard(DWORD dwID);

    DWORD       AllocNewCardID(void) { return m_dwNextID++; };
    DWORD       GetNumCards(void) const { return m_dwNumEntries; } ;

    CCallingCard    *GetCallingCard(DWORD   dwID);
    // a sort of enumerator
    HRESULT     Reset(BOOL bInclHidden);
    HRESULT     Next(DWORD  NrElem, CCallingCard **, DWORD *pNrElemFetched);
    HRESULT     Skip(DWORD  NrElem);
    

};





#endif //__CARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\card.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  card.cpp
                                                              
     Abstract:  Calling Card Object implementation
                                                              
       Author:  noela - 09/11/98
              
        Notes:

        
  Rev History:

****************************************************************************/

#include <windows.h>
#include <windowsx.h>

#if WINNT
#else
#include <help.h>
#endif

#include <tchar.h>
#include <prsht.h>
#include <stdlib.h>
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "cplResource.h"
#include "client.h"
#include "clntprivate.h"
#include "card.h"
#include "location.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "rules.h"

#include "tregupr2.h"

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#ifdef DBG
#define assert(condition)   if(condition);else  \
        { DebugAssertFailure (__FILE__, __LINE__, #condition); }

static void DebugAssertFailure (LPCSTR file, DWORD line, LPCSTR condition);

#else

#define assert(condition)

#endif


#define CLIENT_FREE(x)  \
    if (x) { ClientFree(x); (x)=NULL;} else;

#define TRACE_DWERROR() LOG((TL_ERROR, "Error %x at line %d in file %hs", dwError, __LINE__, __FILE__))
#define TRACE_HRESULT() LOG((TL_ERROR, "Error %x at line %d in file %hs", Result, __LINE__, __FILE__))

#define EXIT_IF_DWERROR()     \
    if(dwError !=ERROR_SUCCESS)  \
    {                               \
        TRACE_DWERROR();            \
        goto forced_exit;           \
    }   

#define EXIT_IF_FAILED()     \
    if(FAILED(Result))        \
    {                               \
        TRACE_HRESULT();            \
        goto forced_exit;           \
    }   


#define MAX_NUMBER_LEN      15



const TCHAR gszCardsPath[]        = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards");
const TCHAR gszTelephonyPath[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");

const TCHAR gszCardW[]              = TEXT("Card");
const TCHAR gszCardNameW[]          = TEXT("Name");
const TCHAR gszLocalRuleW[]         = TEXT("LocalRule");
const TCHAR gszLDRuleW[]            = TEXT("LDRule");
const TCHAR gszInternationalRuleW[] = TEXT("InternationalRule");
const TCHAR gszLocalAccessNumberW[] = TEXT("LocalAccessNumber");
const TCHAR gszLDAccessNumberW[]    = TEXT("LDAccessNumber");
const TCHAR gszInternationalAccessNumberW[] = TEXT("InternationalAccessNumber");
const TCHAR gszAccountNumberW[]     = TEXT("AccountNumber");
const TCHAR gszPinW[]               = TEXT("Pin");

const TCHAR gszFlags[]              = TEXT("Flags");
const TCHAR gszCard[]               = TEXT("Card");
const TCHAR gszCards[]              = TEXT("Cards");
const TCHAR gszNextID[]             = TEXT("NextID");
const TCHAR gszCardListVersion[]    = TEXT("CardListVersion");

const TCHAR gszResourceLibrary[]    = TEXT("TAPIUI.DLL");

const TCHAR gszSystemSetupPath[]    = TEXT("System\\Setup");
const TCHAR gszSystemSetupInProgress[] = TEXT("SystemSetupInProgress"); 

static BOOL ValidValue(PWSTR);

/****************************************************************************

    Class : CCallingCard        
   Method : Constructor

****************************************************************************/
CCallingCard::CCallingCard()
{
    m_dwCardID = 0;
    m_pszCardName = NULL;;
    
    m_pszPIN = NULL;
    m_pszEncryptedPIN = NULL;
    m_pszAccountNumber = NULL;

    m_pszLocalAccessNumber = NULL;
    m_pszLongDistanceAccessNumber = NULL;
    m_pszInternationalAccessNumber = NULL;

    m_pszCardPath = NULL;
    m_hCard = NULL;

    m_bDirty = FALSE;
    m_bDeleted = FALSE;

    m_dwFlags = 0; // by default

    m_dwCryptInitResult = TapiCryptInitialize();
}



/****************************************************************************

    Class : CCallingCard         
   Method : Destructor

****************************************************************************/
CCallingCard::~CCallingCard()
{
    CleanUp();

    TapiCryptUninitialize();
}


/****************************************************************************

    Class : CCallingCard         
   Method : CleanUp

            Clean up memory allocations

****************************************************************************/


void  CCallingCard::CleanUp(void)
{
    CLIENT_FREE(m_pszCardName);
    CLIENT_FREE(m_pszPIN);
    CLIENT_FREE(m_pszEncryptedPIN);
    CLIENT_FREE(m_pszAccountNumber);
    CLIENT_FREE(m_pszLocalAccessNumber);
    CLIENT_FREE(m_pszLongDistanceAccessNumber);
    CLIENT_FREE(m_pszInternationalAccessNumber);

    CLIENT_FREE(m_Rules.m_pszInternationalRule);
    CLIENT_FREE(m_Rules.m_pszLongDistanceRule);
    CLIENT_FREE(m_Rules.m_pszLocalRule);

    CLIENT_FREE(m_pszCardPath);
    CloseCardKey();
}


/****************************************************************************

    Class : CCallingCard         
   Method : Initialize - external parameters

            Only for new calling cards (not present in registry)

****************************************************************************/
HRESULT CCallingCard::Initialize
                  (
                   DWORD dwCardID,
                   PWSTR pszCardName,
                   DWORD dwFlags,
                   PWSTR pszPIN,
                   PWSTR pszAccountNumber,
                   PWSTR pszInternationalRule,
                   PWSTR pszLongDistanceRule,
                   PWSTR pszLocalRule,
                   PWSTR pszInternationalAccessNumber,
                   PWSTR pszLongDistanceAccessNumber,
                   PWSTR pszLocalAccessNumber
                  )
{
    HRESULT     Result = S_OK;
    
#define CALLING_CARD_INIT(param)                                                            \
    m_##param = ClientAllocString(param);                                                   \
    if(m_##param == NULL)                                                                   \
    {                                                                                       \
        LOG((TL_ERROR, "Initialize create m_%s failed", _T(#param)));    \
        CleanUp();                                                                          \
        return E_OUTOFMEMORY;                                                               \
    }

    CALLING_CARD_INIT(pszCardName)
    CALLING_CARD_INIT(pszPIN)
    CALLING_CARD_INIT(pszAccountNumber)
    CALLING_CARD_INIT(pszInternationalAccessNumber)
    CALLING_CARD_INIT(pszLongDistanceAccessNumber)
    CALLING_CARD_INIT(pszLocalAccessNumber)

#undef CALLING_CARD_INIT

    //////////////////////////////////////////////////
    // copy the set of three Rules
    //
    Result = m_Rules.Initialize(    pszInternationalRule,
                                    pszLongDistanceRule,
                                    pszLocalRule );
    if(FAILED(Result))
    {
        LOG((TL_ERROR, "Initialize create m_Rules failed" ));
        CleanUp();
        return Result;
    }

    m_dwCardID = dwCardID;
    m_dwFlags = dwFlags;

    m_bDirty = TRUE;


    return Result;

}
        

/****************************************************************************

    Class : CCallingCard         
   Method : Initialize - from registry


****************************************************************************/
HRESULT CCallingCard::Initialize
                    (
                     DWORD dwCardID
                    )
{

    DWORD       dwError;
    DWORD       dwType;
    DWORD       dwLength;

    m_dwCardID = dwCardID;

    // open the registry key
    dwError = OpenCardKey(FALSE);

    if(dwError != ERROR_SUCCESS)
    {
        // If the key does not exist, it will be created at the first save
        if(dwError==ERROR_FILE_NOT_FOUND)
        {
            m_bDirty = TRUE;
        }
        return(HRESULT_FROM_WIN32(dwError));
    }

#define READ_CARD_VAL(Member, Name)      \
    dwError = ReadOneStringValue(&##Member, Name);  \
    if(dwError != ERROR_SUCCESS)                    \
    {                                               \
        TRACE_DWERROR();                            \
        CleanUp();                                  \
        return HRESULT_FROM_WIN32(dwError);         \
    }
    
    READ_CARD_VAL(m_pszCardName,                    gszCardNameW);
    READ_CARD_VAL(m_pszEncryptedPIN,                gszPinW);
//    READ_CARD_VAL(m_pszPIN,                gszPinW);
    READ_CARD_VAL(m_pszAccountNumber,               gszAccountNumberW);
    READ_CARD_VAL(m_pszLocalAccessNumber,           gszLocalAccessNumberW);
    READ_CARD_VAL(m_pszLongDistanceAccessNumber,    gszLDAccessNumberW);
    READ_CARD_VAL(m_pszInternationalAccessNumber,   gszInternationalAccessNumberW);
    READ_CARD_VAL(m_Rules.m_pszLocalRule,           gszLocalRuleW);
    READ_CARD_VAL(m_Rules.m_pszLongDistanceRule,    gszLDRuleW);
    READ_CARD_VAL(m_Rules.m_pszInternationalRule,   gszInternationalRuleW);

#undef READ_CARD_VAL

    // Decrypt the PIN number 
    dwError = DecryptPIN();
    if(dwError != ERROR_SUCCESS)
    {
        TRACE_DWERROR();
        CleanUp();
        return HRESULT_FACILITY(dwError)==0 ? HRESULT_FROM_WIN32(dwError) : dwError;
    }

    dwLength = sizeof(m_dwFlags);
    dwError = RegQueryValueEx ( m_hCard,
                                gszFlags,
                                NULL,
                                &dwType,
                                (PBYTE)&m_dwFlags,
                                &dwLength
                                );
    
    if(dwError != ERROR_SUCCESS)
    {
        TRACE_DWERROR();
        CleanUp();
        return HRESULT_FROM_WIN32(dwError);
    }

    CloseCardKey();

    return S_OK;

}

/****************************************************************************

    Class : CCallingCard         
   Method : SaveToRegistry
        

****************************************************************************/

HRESULT     CCallingCard::SaveToRegistry(void)
{
    DWORD   dwError;

    if(!m_bDirty)
        // nothing to save
        return S_OK;
    //open/create the registry key
    dwError = OpenCardKey(TRUE);
    if(dwError != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(dwError);

    assert(m_hCard);
    assert(m_pszCardPath);

    if(m_bDeleted)
    {
        CloseCardKey();

        dwError = RegDeleteKey (HKEY_CURRENT_USER,
                                m_pszCardPath);

        if(dwError != ERROR_SUCCESS)
            return HRESULT_FROM_WIN32(dwError);

        m_bDirty = FALSE;

        return S_OK;
    }
    // Encrypt the PIN number 
    dwError = EncryptPIN();
    if(dwError != ERROR_SUCCESS)
    {
        TRACE_DWERROR();
        return HRESULT_FACILITY(dwError)==0 ? HRESULT_FROM_WIN32(dwError) : dwError;
    }

    // Save !
    
#define CARD_SAVE_STRING(Member, Name)          \
    dwError = TAPIRegSetValueExW(   m_hCard,    \
                                    Name,       \
                                    0,          \
                                    REG_SZ,     \
                                    (PBYTE) Member, \
                                    (wcslen(Member)+1)*sizeof(WCHAR)  \
                                ) ;             \
    if(dwError != ERROR_SUCCESS)                \
    {                                           \
        TRACE_DWERROR();                        \
        CloseCardKey();                         \
        return HRESULT_FROM_WIN32(dwError);     \
    }

    CARD_SAVE_STRING(m_pszCardName,                    gszCardNameW);
    CARD_SAVE_STRING(m_pszEncryptedPIN,                gszPinW);
    CARD_SAVE_STRING(m_pszAccountNumber,               gszAccountNumberW);
    CARD_SAVE_STRING(m_pszLocalAccessNumber,           gszLocalAccessNumberW);
    CARD_SAVE_STRING(m_pszLongDistanceAccessNumber,    gszLDAccessNumberW);
    CARD_SAVE_STRING(m_pszInternationalAccessNumber,   gszInternationalAccessNumberW);
    CARD_SAVE_STRING(m_Rules.m_pszLocalRule,           gszLocalRuleW);
    CARD_SAVE_STRING(m_Rules.m_pszLongDistanceRule,    gszLDRuleW);
    CARD_SAVE_STRING(m_Rules.m_pszInternationalRule,   gszInternationalRuleW);
        
#undef CARD_SAVE_STRING

    dwError = RegSetValueEx (   m_hCard,
                                gszFlags,
                                0,
                                REG_DWORD,
                                (PBYTE)&m_dwFlags,
                                sizeof(m_dwFlags)
                           );
    if(dwError != ERROR_SUCCESS)                
    {                                           
        TRACE_DWERROR();
        CloseCardKey();                         
        return HRESULT_FROM_WIN32(dwError);     
    }

    m_bDirty = FALSE;

    CloseCardKey();

    return S_OK;
}


/****************************************************************************

    Class : CCallingCard         
   Method : MarkDeleted

            Mark the card as deleted

****************************************************************************/

HRESULT CCallingCard::MarkDeleted(void)
{
    m_bDirty = TRUE;
    
    if (m_dwFlags & CARD_BUILTIN)
    {
        // a builtin card is only hidden, not deleted
        m_dwFlags |= CARD_HIDE;
        return S_OK;
    }
    
    m_bDeleted = TRUE;

    return S_OK;
}


/****************************************************************************

    Class : CCallingCard         
   Method : Validate

            Returns 0 if the card contains complete and valid rules, or
            a series of flags if the card is missing any required data.

****************************************************************************/

DWORD CCallingCard::Validate(void)
{
    DWORD dwResult = 0;

    // Does the card have a name?
    if (!*m_pszCardName)
    {
        dwResult |= CCVF_NOCARDNAME;
    }

    // Does the card have any rules?
    if (!*(m_Rules.m_pszInternationalRule) &&
        !*(m_Rules.m_pszLocalRule) &&
        !*(m_Rules.m_pszLongDistanceRule) )
    {
        dwResult |= CCVF_NOCARDRULES;
    }
    else
    {
        DWORD dwFieldsToCheck = 0;;

        struct
        {
            PWSTR   pwszRule;
            DWORD   dwAccesFlag;
        }
        aData[] =
        {
            {m_Rules.m_pszInternationalRule, CCVF_NOINTERNATIONALACCESSNUMBER},
            {m_Rules.m_pszLocalRule,         CCVF_NOLOCALACCESSNUMBER},
            {m_Rules.m_pszLongDistanceRule,  CCVF_NOLONGDISTANCEACCESSNUMBER},
        };

        // Foreach rule, is the required rule data available?  We need to check
        // for use of the PIN number, CardNumber, and all three access numbers.
        // If any of these fields is used, then we need to verify that data has
        // been entered for those fields.  The data is only required if it is
        // actually used in a rule.
        for (int i=0; i<ARRAYSIZE(aData); i++)
        {
            if (StrChrW(aData[i].pwszRule, L'K'))
            {
                dwFieldsToCheck |= CCVF_NOCARDNUMBER;
            }
            if (StrChrW(aData[i].pwszRule, L'H'))
            {
                dwFieldsToCheck |= CCVF_NOPINNUMBER;
            }
            if (StrChrW(aData[i].pwszRule, L'J'))
            {
                dwFieldsToCheck |= aData[i].dwAccesFlag;
            }
        }
        if (dwFieldsToCheck & CCVF_NOCARDNUMBER)
        {
            if (!ValidValue(m_pszAccountNumber))
            {
                dwResult |= CCVF_NOCARDNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOPINNUMBER)
        {
            if (!ValidValue(m_pszPIN))
            {
                dwResult |= CCVF_NOPINNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOINTERNATIONALACCESSNUMBER)
        {
            if (!ValidValue(m_pszInternationalAccessNumber))
            {
                dwResult |= CCVF_NOINTERNATIONALACCESSNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOLOCALACCESSNUMBER)
        {
            if (!ValidValue(m_pszLocalAccessNumber))
            {
                dwResult |= CCVF_NOLOCALACCESSNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOLONGDISTANCEACCESSNUMBER)
        {
            if (!ValidValue(m_pszLongDistanceAccessNumber))
            {
                dwResult |= CCVF_NOLONGDISTANCEACCESSNUMBER;
            }
        }
    }

    return dwResult;
}

/****************************************************************************

    Class : CCallingCard         
   Method : Set##Member 

****************************************************************************/

#define     SET_METHOD(Member)                  \
HRESULT CCallingCard::Set##Member(PWSTR Value)  \
{                                               \
    PWSTR   pszTemp = NULL;                     \
                                                \
    if(Value == NULL)                           \
        return E_INVALIDARG;                    \
                                                \
    pszTemp = ClientAllocString(Value);         \
    if(pszTemp==NULL)                           \
    {                                           \
        return E_OUTOFMEMORY;                   \
    }                                           \
                                                \
    CLIENT_FREE(m_psz##Member);                 \
    m_psz##Member = pszTemp;                    \
                                                \
    m_bDirty = TRUE;                            \
                                                \
    return S_OK;                                \
}

SET_METHOD(CardName);
SET_METHOD(PIN);
SET_METHOD(AccountNumber);
SET_METHOD(InternationalAccessNumber);
SET_METHOD(LongDistanceAccessNumber);
SET_METHOD(LocalAccessNumber);

#define m_pszInternationalRule  m_Rules.m_pszInternationalRule
#define m_pszLongDistanceRule   m_Rules.m_pszLongDistanceRule
#define m_pszLocalRule          m_Rules.m_pszLocalRule

SET_METHOD(InternationalRule);
SET_METHOD(LongDistanceRule);
SET_METHOD(LocalRule);

#undef m_pszInternationalRule
#undef m_pszLongDistanceRule
#undef m_pszLocalRule

#undef SET_METHOD

                    




/****************************************************************************

    Class : CCallingCard         
   Method : OpenCardKey

            Opens the registry key for the card

****************************************************************************/

DWORD CCallingCard::OpenCardKey(BOOL bWrite)
{
    DWORD   dwDisp;
    DWORD   dwError;
     
    if(m_pszCardPath==NULL)
    {
        DWORD   dwLength;
        
        // Absolute path: Software.....Cards\CardX
        dwLength = ARRAYSIZE(gszCardsPath)+ARRAYSIZE(gszCard)+MAX_NUMBER_LEN;
 
        m_pszCardPath = (PTSTR)ClientAlloc(dwLength*sizeof(TCHAR));
        if (m_pszCardPath==NULL)
            return ERROR_OUTOFMEMORY;

        wsprintf(m_pszCardPath, TEXT("%s\\%s%d"), gszCardsPath, gszCard, m_dwCardID);
    }
    
    if(bWrite)
    {
        // Creates the key if it does not exist
        dwError = RegCreateKeyEx ( HKEY_CURRENT_USER,
                                   m_pszCardPath,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_QUERY_VALUE | KEY_SET_VALUE,
                                   NULL,
                                   &m_hCard,
                                   &dwDisp
                                  );
    }
    else
    {
        dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                                m_pszCardPath,
                                0,
                                KEY_QUERY_VALUE,
                                &m_hCard
                                );
    }
    return dwError;

}

/****************************************************************************

    Class : CCallingCard         
   Method : CloseCardKey

            Opens the registry key for the card

****************************************************************************/

DWORD CCallingCard::CloseCardKey(void)
{
    if(m_hCard)
    {
        RegCloseKey(m_hCard);
        m_hCard = NULL;
    }
    return ERROR_SUCCESS;
}

/****************************************************************************

    Class : CCallingCard         
   Method : ReadOneStringValue

            Read and allocates a string value

****************************************************************************/

DWORD CCallingCard::ReadOneStringValue(PWSTR *pMember, const TCHAR *pszName)
{
    DWORD   dwError;
    DWORD   dwLength;
    DWORD   dwType;
    PTSTR   pszBuffer;
    
    assert(m_hCard);
    assert(pMember);
    assert(pszName);

    // find the length needed
    dwError = RegQueryValueEx ( m_hCard,
                                pszName,
                                NULL,
                                &dwType,
                                NULL,
                                &dwLength
                                );
    if (dwError != ERROR_SUCCESS)
        return dwError;
    if (dwType != REG_SZ)
        return ERROR_INVALID_DATA;

    pszBuffer = (PTSTR)ClientAlloc(dwLength);
    if (pszBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    dwError = RegQueryValueEx ( m_hCard,
                                pszName,
                                NULL,
                                &dwType,
                                (PBYTE)(pszBuffer),
                                &dwLength
                                );
    if(dwError != ERROR_SUCCESS)
    {
        ClientFree(pszBuffer);
        return dwError;
    }

    // convert the required bytes for the TCHAR string into the number of characters in the string.
    dwLength = dwLength / sizeof(TCHAR);
    *pMember = (PWSTR)ClientAlloc( dwLength * sizeof(WCHAR) );
    if ( NULL == *pMember )
    {
        ClientFree(pszBuffer);
        return ERROR_OUTOFMEMORY;
    }
    SHTCharToUnicode(pszBuffer, *pMember, dwLength);

    ClientFree(pszBuffer);
    return ERROR_SUCCESS;
}

/****************************************************************************

    Class : CCallingCard         
   Method : EncryptPIN

            Encrypts the PIN

****************************************************************************/


DWORD CCallingCard::EncryptPIN(void)
{
    DWORD   dwError;
    DWORD   dwLength;
    PWSTR   pszTemp = NULL;

    // free any existing encrypted string
    CLIENT_FREE(m_pszEncryptedPIN);

    dwError = TapiEncrypt(m_pszPIN, m_dwCardID, NULL, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "EncryptPIN: TapiEncrypt (1) failed"));
        return dwError;
    }

    pszTemp = (PWSTR)ClientAlloc(dwLength*sizeof(WCHAR));
    if(pszTemp==NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    dwError = TapiEncrypt(m_pszPIN, m_dwCardID, pszTemp, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "EncryptPIN: TapiEncrypt (2) failed"));
        ClientFree(pszTemp);
        return dwError;
    }
    
    m_pszEncryptedPIN = pszTemp;   

    return dwError;

}

/****************************************************************************

    Class : CCallingCard         
   Method : DecryptPIN

            Decrypts the PIN

****************************************************************************/

DWORD CCallingCard::DecryptPIN(void)
{
    DWORD   dwError;
    DWORD   dwLength;
    PWSTR   pszTemp = NULL;

    // free any existing string
    CLIENT_FREE(m_pszPIN);
 
    dwError = TapiDecrypt(m_pszEncryptedPIN, m_dwCardID, NULL, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "DecryptPIN: TapiDecrypt (1) failed"));
        return dwError;
    }

    pszTemp = (PWSTR)ClientAlloc(dwLength*sizeof(WCHAR));
    if(pszTemp==NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    dwError = TapiDecrypt(m_pszEncryptedPIN, m_dwCardID, pszTemp, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "DecryptPIN: TapiDecrypt (2) failed"));
        // return a NULL PIN
        *pszTemp = L'\0';
        dwError = ERROR_SUCCESS;
    }
    
    m_pszPIN = pszTemp;   

    return dwError;

}



/****************************************************************************

    Class : CCallingCards        
   Method : Constructor

****************************************************************************/

CCallingCards::CCallingCards()
{
    m_dwNumEntries = 0;
    m_dwNextID = 0;

    m_hCards = NULL;

    m_hEnumNode = m_CallingCardList.head();
    
}


/****************************************************************************

    Class : CCallingCards        
   Method : Destructor

****************************************************************************/

CCallingCards::~CCallingCards()
{
    CCallingCardNode *node;

    node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_CallingCardList.flush();

    
    node = m_DeletedCallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_DeletedCallingCardList.flush();

    if(m_hCards)
        RegCloseKey(m_hCards);
}

/****************************************************************************

    Class : CCallingCards        
   Method : Initialize

            Checks the presence of the Cards key. If not present, it creates 
        and populates it from string resources.
            Verify the format of the registry config. If it is the old
        one, it converts it to the new one.
            Reads the cards from registry

****************************************************************************/

HRESULT CCallingCards::Initialize(void)
{
    DWORD       dwError;
    DWORD       dwDisp;
    BOOL        bNewCards = FALSE;
    DWORD       dwIndex;
    DWORD       dwLength;
    DWORD       dwType;
    CCallingCard    *pCard = NULL;
    HRESULT     Result = S_OK;
    BOOL        bNeedToConvert = FALSE;
    BOOL        bNeedToGenerateDefault = FALSE;

    // Test the presence of the Cards key
    dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                            gszCardsPath,
                            0,
                            KEY_READ,
                            &m_hCards
                            );
    if(dwError==ERROR_SUCCESS)
    {
        // Read the NextID value
        dwLength = sizeof(m_dwNextID);
        dwError = RegQueryValueEx ( m_hCards,
                                    gszNextID,
                                    NULL,
                                    &dwType,
                                    (PBYTE)&m_dwNextID,
                                    &dwLength
                                  );
        if(dwError==ERROR_SUCCESS)
        {
            if(dwType == REG_DWORD)
            {
                // Test the registry format and upgrade if necessary
                if(IsCardListInOldFormat(m_hCards))
                {   
                    bNeedToConvert = TRUE;
                }
            }
            else
            {
                dwError = ERROR_INVALID_DATA;
            }
        }
    }

    if(dwError != ERROR_SUCCESS)
        bNeedToGenerateDefault = TRUE;

    if(bNeedToGenerateDefault || bNeedToConvert)
    {
        // If the Cards key is missing or it has bad info, so we create a fresh, default set of cards.
        // If the cards key is in the old format, it have to be converted.
        // There's an excepted case, though: during the system setup no cards should be created or converted.
        // So detect setup case first:
        // 
        //

        HKEY    hSetupKey;
        DWORD   dwSetupValue;

        // close the cards key handle 
        if(m_hCards)
        {
            RegCloseKey(m_hCards);
            m_hCards = NULL;
        }
        
        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                gszSystemSetupPath,
                                0,
                                KEY_QUERY_VALUE,
                                &hSetupKey
                                );
        if(dwError == ERROR_SUCCESS)
        {
            dwLength = sizeof(dwSetupValue);
            dwSetupValue = 0;

            dwError = RegQueryValueEx(  hSetupKey,
                                        gszSystemSetupInProgress,
                                        NULL,
                                        &dwType,
                                        (PBYTE)&dwSetupValue,
                                        &dwLength
                                        );
            RegCloseKey(hSetupKey);
                                        
            if(dwError == ERROR_SUCCESS && dwType == REG_DWORD)
            {
                if(dwSetupValue == 1)
                {
                    // Setup time !
                    dwError = ERROR_SUCCESS;
                    goto forced_exit;
                }
            }
        }

        if(dwError != ERROR_SUCCESS)
        {
            // Hmm, cannot open the key or read the value...
            TRACE_DWERROR();
        }

        if(bNeedToConvert)
        {
            dwError = ConvertCallingCards(HKEY_CURRENT_USER);
            if(dwError!=ERROR_SUCCESS)
            {
                // fallback to default cards
                bNeedToGenerateDefault = TRUE;
            }
        }
                

        if(bNeedToGenerateDefault)   
        {
            dwError = CreateFreshCards();
            EXIT_IF_DWERROR();
        }

        // Reopen Cards key
        dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                                gszCardsPath,
                                0,
                                KEY_READ,
                                &m_hCards
                              );
        EXIT_IF_DWERROR();
  
        // ReRead the NextID value
        dwLength = sizeof(m_dwNextID);
        dwError = RegQueryValueEx ( m_hCards,
                                    gszNextID,
                                    NULL,
                                    &dwType,
                                    (PBYTE)&m_dwNextID,
                                    &dwLength
                                  );
        EXIT_IF_DWERROR();
       
    }

    // Read all entries
    dwIndex = 0;
    while(TRUE) 
    {
        TCHAR   szKeyName[ARRAYSIZE(gszCard)+MAX_NUMBER_LEN];
        DWORD   dwKeyLength;
        DWORD   dwCardID;

        // Enumerate next entry
        dwKeyLength = sizeof(szKeyName)/sizeof(TCHAR);
        dwError = RegEnumKeyEx (m_hCards,
                                dwIndex,
                                szKeyName,
                                &dwKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
                        
        if(dwError == ERROR_NO_MORE_ITEMS)
        {
            m_dwNumEntries = dwIndex;
            dwError = ERROR_SUCCESS;
            break;
        }
        
        EXIT_IF_DWERROR();

        // Create a CCallingCard object
        dwCardID = StrToInt(szKeyName+ARRAYSIZE(gszCard)-1);
        pCard = new CCallingCard;
        if(pCard != NULL)
        {
        
            // Read the card information from registry
            Result = pCard->Initialize(dwCardID);
            if(SUCCEEDED(Result))
            {
                // Add it to the list
                m_CallingCardList.tail()->insert_after(pCard);
            }
            else
            {
                LOG((TL_ERROR, "Error %x reading card %d", Result, dwCardID));
                delete pCard;
                pCard=NULL;
            }
        }

        dwIndex++;
    }
  
forced_exit:

    if(m_hCards)
    {
        RegCloseKey(m_hCards);
        m_hCards = NULL;
    }

    if(dwError != ERROR_SUCCESS)
        Result = HRESULT_FROM_WIN32(dwError);

    return Result;
}

/****************************************************************************

    Class : CCallingCards         
   Method : RemoveCard

****************************************************************************/
void CCallingCards::RemoveCard(CCallingCard *pCard)
{
    CCallingCardNode *node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        if ( pCard == node->value() ) 
        {
            InternalDeleteCard(node);
            return;
        }
        node = node->next();
    }
    assert(FALSE);
}


/****************************************************************************

    Class : CCallingCards         
   Method : RemoveCard

****************************************************************************/
void CCallingCards::RemoveCard(DWORD dwID)
{
    CCallingCardNode *node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        if ( dwID == (node->value())->GetCardID()  ) 
        {
            InternalDeleteCard(node);
            return;
        }
        node = node->next();
    }
    assert(FALSE);
}

/****************************************************************************

    Class : CCallingCards         
   Method : GetCallingCard

****************************************************************************/
CCallingCard * CCallingCards::GetCallingCard(DWORD  dwID)
{
    CCallingCardNode *node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        if ( dwID == (node->value())->GetCardID() ) 
        {
            return node->value();
        }
        node = node->next();

    }

    return NULL;


}

/****************************************************************************

    Class : CCallingCards        
   Method : SaveToRegistry


****************************************************************************/
HRESULT     CCallingCards::SaveToRegistry(void)
{
    DWORD       dwError = ERROR_SUCCESS;
    HRESULT     Result = S_OK;
    CCallingCardNode    *node;

    // Open the Cards key
    dwError = RegOpenKeyEx (HKEY_CURRENT_USER,
                            gszCardsPath,
                            0,
                            KEY_SET_VALUE,
                            &m_hCards);
    EXIT_IF_DWERROR();
 
    //first - save the next ID
    dwError = RegSetValueEx (   m_hCards,
                                gszNextID,
                                0,
                                REG_DWORD,
                                (PBYTE)&m_dwNextID,
                                sizeof(m_dwNextID)
                                );
    EXIT_IF_DWERROR();

    // save all cards (from both lists)
    node = m_CallingCardList.head();
    while( !node->beyond_tail() )
    {
        Result = node->value()->SaveToRegistry();
        EXIT_IF_FAILED();

        node = node->next();
    }

    node = m_DeletedCallingCardList.head();
    while( !node->beyond_tail() )
    {
        Result = node->value()->SaveToRegistry();
        EXIT_IF_FAILED();

        node = node->next();
    }


forced_exit:

    if(m_hCards)
    {
        RegCloseKey(m_hCards);
        m_hCards = NULL;
    }

    if(dwError != ERROR_SUCCESS)
        Result = HRESULT_FROM_WIN32(dwError);

    return Result;


}

/****************************************************************************

    Class : CCallingCards        
   Method : Reset


****************************************************************************/
HRESULT     CCallingCards::Reset(BOOL bInclHidden)
{
    m_hEnumNode = m_CallingCardList.head();
    m_bEnumInclHidden = bInclHidden;
    return S_OK;
}

/****************************************************************************

    Class : CCallingCards        
   Method : Next


****************************************************************************/
HRESULT     CCallingCards::Next(DWORD  NrElem, CCallingCard **ppCard, DWORD *pNrElemFetched)
{
    
    DWORD   dwIndex = 0;
    
    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;
    if(ppCard==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        CCallingCard    *pCard;
        
        pCard = m_hEnumNode->value();
        
        if(m_bEnumInclHidden || !pCard->IsMarkedHidden())
        {
            *ppCard++ = pCard;
            dwIndex++;
        }
        
        m_hEnumNode = m_hEnumNode->next();
    }
    
    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
}

/****************************************************************************

    Class : CCallingCards        
   Method : Skip


****************************************************************************/
HRESULT     CCallingCards::Skip(DWORD  NrElem)
{
    
    DWORD   dwIndex = 0;
    
    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
       
        if(m_bEnumInclHidden || !m_hEnumNode->value()->IsMarkedHidden())
        {
            dwIndex++;
        }
        
        m_hEnumNode = m_hEnumNode->next();
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}


 
/****************************************************************************

    Class : CCallingCards        
   Method : CreateFreshCards


****************************************************************************/

DWORD CCallingCards::CreateFreshCards(void)
{
    
    DWORD       dwError = ERROR_SUCCESS;
    HRESULT     Result = S_OK;
    HKEY        hTelephony = NULL;
    HINSTANCE   hTapiui = NULL;
    int         iNrChars;
    DWORD       dwNumCards;
    DWORD       dwDisp;
    DWORD       dwIndex;
    DWORD       dwValue;

    WCHAR       wBuffer[512];
    PWSTR       pTemp;

    CCallingCard    *pCard = NULL;

    // Open/Create the Telephony key
    dwError = RegCreateKeyEx(   HKEY_CURRENT_USER,
                                gszTelephonyPath,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                NULL,
                                &hTelephony,
                                &dwDisp
                                );
    EXIT_IF_DWERROR();

    // Delete any existing tree
    RegDeleteKeyRecursive( hTelephony, gszCards);

    // Open/Create the Cards key
    dwError = RegCreateKeyEx(   hTelephony,
                                gszCards,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE | KEY_READ,
                                NULL,
                                &m_hCards,
                                &dwDisp
                                );
    EXIT_IF_DWERROR();

    // Write the version
    dwValue = TAPI_CARD_LIST_VERSION;
    dwError = RegSetValueEx (   m_hCards,
                                gszCardListVersion,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue)
                                );
    EXIT_IF_DWERROR();

    // Load the TAPIUI.DLL resource library
    hTapiui = LoadLibrary(gszResourceLibrary);
    if(hTapiui==NULL)
        dwError = GetLastError();
    EXIT_IF_DWERROR();

    // Load the number of cards. Use wBuffer as a temporary space
    assert( MAX_NUMBER_LEN <= ARRAYSIZE(wBuffer) );
    iNrChars = LoadString( hTapiui, RC_CARD_ID_BASE, (PTSTR)wBuffer, MAX_NUMBER_LEN);
    if(iNrChars==0)
        dwError = GetLastError();
    EXIT_IF_DWERROR();

    dwNumCards = StrToInt( (PTSTR)wBuffer );

    //Read cards from string resources and write them to registry
    for(dwIndex = 0; dwIndex<dwNumCards; dwIndex++)
    {
        PWSTR pszName;
        PWSTR pszPin;
        PWSTR pszLocalRule;
        PWSTR pszLDRule;
        PWSTR pszInternationalRule;
        PWSTR pszAccountNumber;
        PWSTR pszLocalAccessNumber;
        PWSTR pszLDAccessNumber;
        PWSTR pszInternationalAccessNumber;
        DWORD dwFlags;

        // read the card description
        iNrChars = TAPILoadStringW( hTapiui,
                                    RC_CARD_ID_BASE + dwIndex + 1,
                                    wBuffer,
                                    ARRAYSIZE(wBuffer)
                                    );
        if(iNrChars==0)
            dwError = GetLastError();
        EXIT_IF_DWERROR();

        // tokenize it
#define TOKENIZE(Pointer)                       \
        Pointer = (wcschr(pTemp+1, L'"'))+1;    \
        pTemp = wcschr(Pointer, L'"');          \
        *pTemp = L'\0';

        pTemp = wBuffer-1;

        TOKENIZE(pszName);
        TOKENIZE(pszPin);
        TOKENIZE(pszLocalRule);
        TOKENIZE(pszLDRule);
        TOKENIZE(pszInternationalRule);
        TOKENIZE(pszAccountNumber);
        TOKENIZE(pszLocalAccessNumber);
        TOKENIZE(pszLDAccessNumber);
        TOKENIZE(pszInternationalAccessNumber);

#undef TOKENIZE
        // don't forget the flags
        dwFlags = _wtoi(pTemp+2);
        
        // create the card object
        pCard = new CCallingCard();
        if(pCard==NULL)
            dwError = ERROR_OUTOFMEMORY;
        EXIT_IF_DWERROR();

        Result = pCard->Initialize( dwIndex,
                                    pszName,
                                    dwFlags,
                                    pszPin,
                                    pszAccountNumber,
                                    pszInternationalRule,
                                    pszLDRule,
                                    pszLocalRule,
                                    pszInternationalAccessNumber,
                                    pszLDAccessNumber,
                                    pszLocalAccessNumber
                                    );
        EXIT_IF_FAILED();

        // save it
        Result = pCard->SaveToRegistry();

        EXIT_IF_FAILED();

        delete pCard;
        pCard = NULL;
    }

    // Write NextID value
    dwError = RegSetValueEx (   m_hCards,
                                gszNextID,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwNumCards,
                                sizeof(dwNumCards)
                                );
    EXIT_IF_DWERROR();


forced_exit:

    if(hTelephony)
        RegCloseKey(hTelephony);
    if(m_hCards)
    {
        RegCloseKey(m_hCards);
        m_hCards = NULL;
    }
    if(pCard)
        delete pCard;
    if(hTapiui)
        FreeLibrary(hTapiui);

    if(FAILED(Result))
        dwError = HRESULT_CODE(Result);

    return dwError;
}

/****************************************************************************

    Class : CCallingCards        
   Method : InternalDeleteCard


****************************************************************************/

void CCallingCards::InternalDeleteCard(CCallingCardNode *pNode)
{

    CCallingCard *pCard = pNode->value();
    
    pCard->MarkDeleted();

    if(!pCard->IsMarkedHidden())
    {
        pNode->remove();
        m_dwNumEntries--;
        m_DeletedCallingCardList.tail()->insert_after(pCard);
    }
}


/****************************************************************************

    Helpers

****************************************************************************/

BOOL ValidValue(PWSTR pwszString)
{
    // An empty string or with spaces only is not valid
    WCHAR const * pwcCrt = pwszString;
    while(*pwcCrt)
        if(*pwcCrt++ != L' ')
            return TRUE;

    return FALSE;        
}






#ifdef DBG

static void DebugAssertFailure (LPCSTR file, DWORD line, LPCSTR condition)
{
    DbgPrt (0, TEXT("%hs(%d) : Assertion failed, condition: %hs\n"), file, line, condition);

    DebugBreak();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\countrygroup.h ===
/****************************************************************************
 
  Copyright (c) 2000  Microsoft Corporation
                                                              
  Module Name:  countrygroup.h
                                                              
     Abstract:  Internal country entry and country list definitions 
                for country groups support
                                                              
****************************************************************************/

#ifndef __COUNTRYGROUP_H_
#define __COUNTRYGROUP_H_


//
// This structure is the same as LINECOUNTRYENTRY
// The only difference is that dwNextCountryID has been replaced by dwCountryGroup
//
typedef struct _linecountryentry_internal
{
    DWORD       dwCountryID;                                    
    DWORD       dwCountryCode;                                  
    DWORD       dwCountryGroup;                                
    DWORD       dwCountryNameSize;                              
    DWORD       dwCountryNameOffset;                            
    DWORD       dwSameAreaRuleSize;                             
    DWORD       dwSameAreaRuleOffset;                           
    DWORD       dwLongDistanceRuleSize;                         
    DWORD       dwLongDistanceRuleOffset;                       
    DWORD       dwInternationalRuleSize;                        
    DWORD       dwInternationalRuleOffset;                      

} LINECOUNTRYENTRY_INTERNAL, FAR *LPLINECOUNTRYENTRY_INTERNAL;

typedef struct _linecountrylist_internal
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumCountries;
    DWORD       dwCountryListSize;
    DWORD       dwCountryListOffset;

} LINECOUNTRYLIST_INTERNAL, FAR *LPLINECOUNTRYLIST_INTERNAL;


LONG PASCAL ReadCountriesAndGroups( LPLINECOUNTRYLIST_INTERNAL *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cpladvancedtab.cpp ===
/*--------------------------------------------------------------------------*\
Module:     drv.cpp

  Purpose:    routines for dealing with drivers and their configuration

  Copyright (c) 1998-1999 Microsoft Corporation
 
    History:
    8/11/93   CBB - Hack-o-rama from NickH's stuff
    10/15/98  ToddB - Major rewrite of ancient crap
\*--------------------------------------------------------------------------*/

#include "cplPreComp.h"
#include "drv.h"
#include "tlnklist.h"

#include <windowsx.h>
#include <shlwapi.h>

#define DBG_ASSERT(x,y)

#define  CPL_SUCCESS                 0
#define  CPL_APP_ERROR               100
#define  CPL_BAD_DRIVER              108

#define  CPL_MAX_STRING             132      // biggest allowed string


//----------
// Externs
//----------

typedef BOOL ( APIENTRY PGETFILEVERSIONINFO(
              LPTSTR  lptstrFilename,     // pointer to filename string
              DWORD  dwHandle,    // ignored
              DWORD  dwLen,       // size of buffer
              LPVOID  lpData      // pointer to buffer to receive file-version info.
              ));
PGETFILEVERSIONINFO *gpGetFileVersionInfo;

typedef DWORD ( APIENTRY PGETFILEVERSIONINFOSIZE(
               LPTSTR  lptstrFilename,     // pointer to filename string
               LPDWORD  lpdwHandle         // pointer to variable to receive zero
               ));
PGETFILEVERSIONINFOSIZE *gpGetFileVersionInfoSize;


//------------
// Public Data
//------------
LPLINEPROVIDERLIST glpProviderList;


//-------------
// Private Data
//-------------
static TCHAR gszVarFileInfo[]     = TEXT("\\VarFileInfo\\Translation");
static TCHAR gszStringFileInfo[]  = TEXT("\\StringFileInfo\\%04x%04x\\FileDescription");
static TCHAR gszDriverFiles[]     = TEXT("\\*.tsp");

// These are proc names passed to GetProcAddress and are therefore ANSI strings
static CHAR gszProviderInstall[] = "TSPI_providerInstall";
static CHAR gszProviderRemove[]  = "TSPI_providerRemove";
static CHAR gszProviderSetup[]   = "TSPI_providerConfig";

TCHAR gszHelpFile[] = TEXT("tapi.hlp");


//----------------------------
// Private Function Prototypes
//----------------------------
BOOL  VerifyProcExists( LPTSTR lpszFile, LPSTR lpszProcName );
UINT  GetProviderFileDesc( LPTSTR lpszFile, LPTSTR lpszDesc, int cchDesc );
BOOL  FillAddDriverList( HWND hwndParent, HWND hwndList );
BOOL  AddProvider( HWND hwndParent, HWND hwndList, LPTSTR lpszDriverFile );
LPTSTR ProviderIDToFilename( DWORD dwProviderID );
BOOL  RefreshProviderList();



/*--------------------------------------------------------------------------*\

  Function:   VerifyProcExists
  
    Purpose:    Verifies that the specified proceedure exists in the
    specified service provider
    
\*--------------------------------------------------------------------------*/
BOOL VerifyProcExists( LPTSTR lpszFile, LPSTR lpszProcName )
{
    BOOL        fResult       = TRUE;
    HINSTANCE   hProviderInst;
    
    SetLastError(0);
    
    hProviderInst = LoadLibrary( lpszFile );
    
    if (  hProviderInst == NULL )
    {

#ifdef MEMPHIS
        // return TRUE for now - assume it is a 16 bit
        // service provider.  thunk sp can handle the
        // failure cases.

        fResult = TRUE;
#else
        fResult = FALSE;
#endif

        goto  done;
    }  // end if

#ifdef MEMPHIS
    if (GetLastError() == ERROR_BAD_EXE_FORMAT)
    {
        // 16 bit DLL
        return TRUE;
    }
#endif
    
    
    if (GetProcAddress( hProviderInst, lpszProcName ) == NULL)
    {
        LOG((TL_ERROR, "GetProcAddress for \"%hs\" failed on file %s", lpszProcName, lpszFile ));
        fResult = FALSE;
        goto  done;
    }   // end if
    
done:
    
    if ( hProviderInst != NULL )
        FreeLibrary( hProviderInst );
    
    return fResult;
}


/*--------------------------------------------------------------------------*\

  Function:   FillDriverList
  
    Purpose:    Use lineGetProviderList to retrieve provider list and
    insert into listbox.
    
\*--------------------------------------------------------------------------*/
BOOL FillDriverList( HWND hwndList )
{
    BOOL uResult;
    UINT uIndex;
    UINT uListIndex;
    LPLINEPROVIDERENTRY lpProviderEntry;
    
    if (!RefreshProviderList())
    {
        LOG((TL_ERROR, "Failing FillDriverList because RefreshProviderList returned FALSE"));
        return FALSE;
    }
    
    DBG_ASSERT( glpProviderList, "Uninitialized Provider List after refresh" );
    
    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );
    SendMessage( hwndList, LB_RESETCONTENT, 0, 0 );
    
    // loop through the provider list
    //-------------------------------
    lpProviderEntry = (LPLINEPROVIDERENTRY)((LPBYTE)glpProviderList +
        glpProviderList->dwProviderListOffset);
    
    //
    // Provider list integrity check
    //
    DBG_ASSERT( glpProviderList->dwTotalSize >= (glpProviderList->dwNumProviders * sizeof( LINEPROVIDERENTRY )),
        "TAPI returned lineProviderList structure that is too small for number of providers" );
    
    for ( uIndex = 0; uIndex < glpProviderList->dwNumProviders; uIndex++ )
    {
        LPTSTR lpszProviderFilename;
        TCHAR  szFriendlyName[CPL_MAX_STRING];
        
        //
        // Another provider list integrity check
        //
        DBG_ASSERT( lpProviderEntry[uIndex].dwProviderFilenameOffset +
            lpProviderEntry[uIndex].dwProviderFilenameSize <=
            glpProviderList->dwTotalSize,
            "TAPI LINEPROVIDERLIST too small to hold provider filename" );
        
        // Get an entry to put in the list box
        //------------------------------------
        lpszProviderFilename = (LPTSTR)((LPBYTE)glpProviderList +
            lpProviderEntry[uIndex].dwProviderFilenameOffset);
        
        // Determine the user-friendly name
        //---------------------------------
        
#ifdef MEMPHIS
        // if it's the thunk sp, don't show it in the list
        if (!lstrcmpi(lpszProviderFilename, "tsp3216l.tsp"))
        {
            continue;
        }
#endif
        
        uResult = GetProviderFileDesc( lpszProviderFilename, szFriendlyName, ARRAYSIZE(szFriendlyName) );
        
        LOG((TL_INFO, "Provider friendly name: %s", szFriendlyName));
        
        if (uResult != CPL_SUCCESS && uResult != CPL_BAD_DRIVER) // just leave bad driver in list
        {
            uResult = FALSE;
            goto done;
        }
        else
        {
            uResult = TRUE;
        }
        
        // slam it into the list box
        //--------------------------
        uListIndex = (UINT)SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szFriendlyName );
        
        LOG((TL_INFO, "Setting item for index %ld, value=0x%08lx", (DWORD)uListIndex,
            (DWORD)(lpProviderEntry[uIndex].dwPermanentProviderID) ));
        
        SendMessage( hwndList, LB_SETITEMDATA, uListIndex,
            (LPARAM)(lpProviderEntry[uIndex].dwPermanentProviderID) );
    }
    
    if (glpProviderList->dwNumProviders == 0)
    {
        // no providers, add in default string!
        //-------------------------------------
        
        TCHAR szText[CPL_MAX_STRING];
        LoadString(GetUIInstance(),IDS_NOSERVICEPROVIDER,szText,ARRAYSIZE(szText));
        
        uListIndex = (UINT)SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szText);
        SendMessage( hwndList, LB_SETITEMDATA, uListIndex, 0 );
    }
    
    uResult = TRUE;
    
done:
    
    SendMessage( hwndList, LB_SETCURSEL, 0, 0 );    // set focus to the top guy
    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );
    
    return uResult;
}


/*--------------------------------------------------------------------------*\

  Function:   SetupDriver
  
  Purpose:    Calls lineConfigProvider
    
\*--------------------------------------------------------------------------*/
BOOL SetupDriver( HWND hwndParent, HWND hwndList )
{
    LRESULT lResult;
    LRESULT dwProviderID;
    LONG    res;
    
    // get the id and tell tapi to configure the provider
    //---------------------------------------------------
    lResult      = SendMessage( hwndList, LB_GETCURSEL, 0, 0 );
    dwProviderID = SendMessage( hwndList, LB_GETITEMDATA, (WPARAM)lResult, 0L );
    
    if ((dwProviderID == (LRESULT)LB_ERR) || (!dwProviderID))
    {
        LOG((TL_WARN,  "Warning: strange... dwProviderID= 0x%08lx (uResult=0x%08lx)", (DWORD)dwProviderID, (DWORD)lResult));
        return FALSE;
    }
    
    lResult = lineConfigProvider( hwndParent, (DWORD)dwProviderID );
    
    if (lResult)
    {
        LOG((TL_WARN, "Warning: lineConfigProvider failure %#08lx", lResult ));
        return FALSE;
    }
    
    return TRUE;
}


/*--------------------------------------------------------------------------*\

  Function:   RemoveSelectedDriver
  
    Purpose:    Calls lineRemoveProvider
    
\*--------------------------------------------------------------------------*/
BOOL RemoveSelectedDriver( HWND hwndParent, HWND hwndList )
{
    UINT  uResult;
    LRESULT  lResult;
    LRESULT  lrListIndex;
    LRESULT  lrProviderID;
    
    // find the one we should remove
    //------------------------------
    lrListIndex  = SendMessage( hwndList, LB_GETCURSEL, 0, 0 );
    lrProviderID = SendMessage( hwndList, LB_GETITEMDATA, lrListIndex, 0 );
    
    LOG((TL_TRACE, "Removing provider ID = %#08lx", (DWORD)lrProviderID ));
    
    if ((lrProviderID == (LRESULT)LB_ERR) || (!lrProviderID))
    {
        uResult = FALSE;
        goto  done;
    }
    
    // ask TAPI to remove this provider
    //---------------------------------
    lResult = lineRemoveProvider( (DWORD)lrProviderID, hwndParent );
    
    if (lResult)
    {
        LOG((TL_WARN, "Warning: lineRemoveProvider failure %#08lx", lResult ));
        uResult = FALSE;
        goto  done;
    }
    
    // remove him from the list box
    //-----------------------------
    lResult = SendMessage( hwndList, LB_DELETESTRING, lrListIndex, 0 );
    
    if (lResult == LB_ERR )
    {
        uResult = FALSE;
        goto  done;
    }
    
    if ( lResult == 0 )
    {
        // no providers, add in default string!
        //-------------------------------------
        TCHAR szText[CPL_MAX_STRING];
        LoadString(GetUIInstance(),IDS_NOSERVICEPROVIDER,szText,ARRAYSIZE(szText));
        
        lResult = SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szText);
        SendMessage( hwndList, LB_SETITEMDATA, (WPARAM)lResult, 0 );     // mark!
    }
    
    uResult = TRUE;
    
done:
    
    SendMessage( hwndList, LB_SETCURSEL, 0, 0 );    // set focus to the top guy
    UpdateDriverDlgButtons(hwndParent);
    
    return uResult;
}


/*--------------------------------------------------------------------------*\

  Function:   GetProviderFileDesc

    Purpose:    Reads the driver description from it's version info stuff

\*--------------------------------------------------------------------------*/
UINT GetProviderFileDesc( LPTSTR lpszFile, LPTSTR lpszDesc, int cchDesc)
{
    UINT  uResult;
    UINT  uItemSize;
    DWORD dwSize;
    DWORD dwVerHandle;
    LPTSTR lpszBuffer;
    LPBYTE   lpbVerData;
    TCHAR  szItem[1000];

    lpbVerData = NULL;
    lstrcpyn( lpszDesc, lpszFile, cchDesc );   // returns filename as description if we have any errors

    {
        HINSTANCE hVersion = NULL;

        if ( NULL == gpGetFileVersionInfo )
        {
            hVersion = LoadLibrary( TEXT("Version.dll") );
            if ( NULL == hVersion )
            {
                LOG((TL_ERROR, "LoadLibrary('VERSION.DLL') failed! err=0x%08lx", GetLastError() ));
                return FALSE;
            }

            gpGetFileVersionInfo = (PGETFILEVERSIONINFO *)GetProcAddress(
                    hVersion,
#ifdef UNICODE
                    "GetFileVersionInfoW"
#else
                    "GetFileVersionInfoA"
#endif
                    );
            if ( NULL == gpGetFileVersionInfo )
            {
                LOG((TL_ERROR, "GetProcAddress('VERSION.DLL', 'GetFileVersionInfo') failed! err=0x%08lx", GetLastError() ));
                return FALSE;
            }
        }
    
        if ( NULL == gpGetFileVersionInfoSize )
        {
            if ( NULL == hVersion )
            {
                hVersion = LoadLibrary( TEXT("Version.dll") );
            }
        
            if ( NULL == hVersion )  // Is it _STILL_ NULL?
            {
                LOG((TL_ERROR, "LoadLibrary('VERSION.DLL') failed! err=0x%08lx", GetLastError() ));
                return FALSE;
            }
        
            gpGetFileVersionInfoSize = (PGETFILEVERSIONINFOSIZE *)GetProcAddress(
                    hVersion,
#ifdef UNICODE
                    "GetFileVersionInfoSizeW"
#else
                    "GetFileVersionInfoSizeA"
#endif
                    );

            if ( NULL == gpGetFileVersionInfoSize )
            {
                LOG((TL_ERROR, "GetProcAddress('VERSION.DLL', 'GetFileVersionInfoSize') failed! err=0x%08lx", GetLastError() ));
                gpGetFileVersionInfo = NULL;
                FreeLibrary( hVersion );
                return FALSE;
            }
        }
    }
    
    if ((dwSize = gpGetFileVersionInfoSize( lpszFile, &dwVerHandle )) == 0)
    {
        LOG((TL_ERROR, "GetFileVersionInfoSize failure for %s", lpszFile ));
        uResult = CPL_BAD_DRIVER;
        goto  done;
    }
    
    lpbVerData = (LPBYTE)GlobalAllocPtr( GPTR, dwSize + 10 );      
    if ( lpbVerData == NULL )
    {
        uResult = CPL_APP_ERROR;
        goto  done;
    }
    
    if ( gpGetFileVersionInfo( lpszFile, dwVerHandle, dwSize, lpbVerData ) == FALSE )
    {
        LOG((TL_ERROR, "GetFileVersionInfo failure for %s", lpszFile ));
        uResult = CPL_BAD_DRIVER;
        goto  done;
    }
    
    lstrcpy( szItem, gszVarFileInfo );     // bug in VerQueryValue, can't handle static CS based str
    
    {
        HINSTANCE hVersion;
        typedef BOOL ( APIENTRY PVERQUERYVALUE(
            const LPVOID  pBlock,        // address of buffer for version resource
            LPTSTR  lpSubBlock,  // address of value to retrieve
            LPVOID  *lplpBuffer, // address of buffer for version pointer
            PUINT  puLen         // address of version-value length buffer
            ));
        PVERQUERYVALUE *pVerQueryValue = NULL;
        
        
        hVersion = LoadLibrary( TEXT("Version.dll") );
        if ( NULL == hVersion )
        {
            LOG((TL_ERROR, "LoadLibrary('VERSION.DLL') failed! err=0x%08lx", GetLastError() ));
            return FALSE;
        }
        
        pVerQueryValue = (PVERQUERYVALUE *)GetProcAddress( 
                hVersion,
#ifdef UNICODE
                "VerQueryValueW"
#else
                "VerQueryValueA"
#endif
                );

        if ( NULL == pVerQueryValue )
        {
            LOG((TL_ERROR, "GetProcAddress('VERSION.DLL', 'VerQueryValue') failed! err=0x%08lx", GetLastError() ));
            FreeLibrary( hVersion );
            return FALSE;
        }
        
        
        if ((pVerQueryValue( lpbVerData, szItem, (void**)&lpszBuffer, (LPUINT)&uItemSize ) == FALSE) || (uItemSize == 0))
        {
            LOG((TL_ERROR, "ERROR:  VerQueryValue failure for %s on file %s", szItem, lpszFile ));
            uResult = CPL_SUCCESS;     // does not matter if this did not work!
            FreeLibrary( hVersion );
            goto  done;
        }  // end if
        
        
        wsprintf( szItem, gszStringFileInfo, (WORD)*(LPWORD)lpszBuffer, (WORD)*(((LPWORD)lpszBuffer)+1) );
        
        if ((pVerQueryValue( lpbVerData, szItem, (void**)&lpszBuffer, (LPUINT)&uItemSize ) == FALSE) || (uItemSize == 0))
        {
            LOG((TL_ERROR, "ERROR:  VerQueryValue failure for %s on file %s", szItem, lpszFile ));
            uResult = CPL_SUCCESS;     // does not matter if this did not work!
            FreeLibrary( hVersion );
            goto  done;
        }  // end if
        
        FreeLibrary( hVersion );
    }
    
    lstrcpyn( lpszDesc, lpszBuffer, cchDesc );
    
    uResult = CPL_SUCCESS;
    
done:
    
    if ( lpbVerData )
        GlobalFreePtr( lpbVerData );
    
    return uResult;
}



#define MAX_PROVIDER_NAME   14
#define PROVIDERS_KEY       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers")
#define NUM_PROVIDERS       TEXT("NumProviders")

typedef struct
{
    LIST_ENTRY Entry;
    TCHAR szName[MAX_PROVIDER_NAME];
} INSTALLED_PROVIDER, *PINSTALLED_PROVIDER;

typedef struct
{
    LIST_ENTRY Head;
    DWORD      dwEntries;
} LIST_HEAD, *PLIST_HEAD;

void BuildInstalledProviderList (PLIST_HEAD pListHead)
{
 PINSTALLED_PROVIDER pProvider;
 HKEY hKeyProviders;
 DWORD dwNumProviders;
 DWORD cbData;
 DWORD i;
 TCHAR szValueName[24]=TEXT("ProviderFileName");
 TCHAR *pNumber = &szValueName[16];

    InitializeListHead (&pListHead->Head);
    pListHead->dwEntries = 0;

    if (ERROR_SUCCESS !=
        RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROVIDERS_KEY, 0, KEY_READ, &hKeyProviders))
    {
        return;
    }

    cbData = sizeof (dwNumProviders);
    if (ERROR_SUCCESS !=
         RegQueryValueEx (hKeyProviders, NUM_PROVIDERS, NULL, NULL, (PBYTE)&dwNumProviders, &cbData) ||
        0 == dwNumProviders)
    {
        goto CloseKeyAndReturn;
    }

    pProvider = (PINSTALLED_PROVIDER)ClientAlloc (sizeof (INSTALLED_PROVIDER));
    if (NULL == pProvider)
    {
        goto CloseKeyAndReturn;
    }

    for (i = 0; i < dwNumProviders; i++)
    {
        wsprintf (pNumber, TEXT("%d"), i);
        cbData = sizeof(pProvider->szName);
        if (ERROR_SUCCESS ==
            RegQueryValueEx (hKeyProviders, szValueName, NULL, NULL, (PBYTE)pProvider->szName, &cbData))
        {
            InsertHeadList (&pListHead->Head, &pProvider->Entry);
            pListHead->dwEntries ++;
            pProvider = (PINSTALLED_PROVIDER)ClientAlloc (sizeof (INSTALLED_PROVIDER));
            if (NULL == pProvider)
            {
                goto CloseKeyAndReturn;
            }
        }
    }

    ClientFree (pProvider);

CloseKeyAndReturn:
    RegCloseKey (hKeyProviders);
}


/*--------------------------------------------------------------------------*\

  Function:   FillAddDriverList
  
  Purpose:
    
\*--------------------------------------------------------------------------*/
BOOL FillAddDriverList( HWND hwndParent, HWND hwndList )
{
    UINT  uIndex;
    UINT  uResult;
    LPTSTR lpszDrvFile;
    HANDLE hFindFile;
    WIN32_FIND_DATA ftFileInfo;
    TCHAR szFullPath[MAX_PATH+sizeof(gszDriverFiles)/sizeof(TCHAR)];
    TCHAR  szDrvDescription[CPL_MAX_STRING];
    LIST_HEAD InstalledProvidersList;
    PINSTALLED_PROVIDER pProvider;

    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );
    SendMessage( hwndList, LB_RESETCONTENT, 0, 0 );

    // build a list of installed providers,
    // so that we don't allow the user to install them again
    //------------------------------------------------------
    BuildInstalledProviderList (&InstalledProvidersList);

    // get full path to windows/system dir
    //------------------------------------
    uIndex = GetSystemDirectory( szFullPath, MAX_PATH);
    if ((0 == uIndex) || (MAX_PATH < uIndex))
    {
        // Either the function failed,
        // or the path is greater than MAX_PATH
        uResult = FALSE;
        goto  done;
    }
    
    uIndex = (UINT)lstrlen( szFullPath );
    
    if ((uIndex > 0) && (szFullPath[uIndex-1] != '\\'))
        lstrcat( szFullPath, gszDriverFiles );          // add the '\'
    else
        lstrcat( szFullPath, gszDriverFiles + 1 );      // ignore the '\' (root dir)
    
    // find all the entries in the system dir
    //---------------------------------------
    
    hFindFile = FindFirstFile( szFullPath, &ftFileInfo );
    uResult = TRUE;
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        LOG((TL_ERROR, "FindFirstFile failed, 0x%08lx", GetLastError() ));
        uResult = FALSE;
    }
    
    while ( uResult )
    {
        // alloc and set the file name to be assocated with each driver
        //-------------------------------------------------------------
        lpszDrvFile = (LPTSTR)ClientAlloc((lstrlen(ftFileInfo.cFileName)+1)*sizeof(TCHAR));
        if (NULL == lpszDrvFile)
        {
            uResult = FALSE;
            goto  done;
        }
        
        lstrcpy( lpszDrvFile, ftFileInfo.cFileName );
        
        LOG((TL_ERROR, "Examining file %s", lpszDrvFile ));
        
#ifdef MEMPHIS
        
        if (!lstrcmpi(lpszDrvFile, "tsp3216l.tsp"))
        {
            ClientFree (lpszDrvFile);
            goto next_driver;
        }
#endif

        // if the provider is already installed, skip it
        //----------------------------------------------
        for (pProvider = (PINSTALLED_PROVIDER)InstalledProvidersList.Head.Flink, uIndex = 0;
             uIndex < InstalledProvidersList.dwEntries;
             pProvider = (PINSTALLED_PROVIDER)pProvider->Entry.Flink, uIndex++)
        {
            if (!lstrcmpi (lpszDrvFile, pProvider->szName))
            {
                RemoveEntryList (&pProvider->Entry);
                InstalledProvidersList.dwEntries --;
                ClientFree (pProvider);
                ClientFree (lpszDrvFile);
                goto next_driver;
            }
        }


        // cbb, should we make a full path???
        uResult = GetProviderFileDesc( lpszDrvFile, szDrvDescription, ARRAYSIZE(szDrvDescription) );
        if ( uResult != CPL_SUCCESS )
        {
            LOG((TL_ERROR, "No description for %s.  Default to filename.", lpszDrvFile ));
            
            /* Filename will have to suffice */
            lstrcpy( szDrvDescription, lpszDrvFile );
            uResult = FALSE;
        }
        else
        {
            uResult = TRUE;   
        }
        
        // Verify that provider has install routine
        //-----------------------------------------
        if (!VerifyProcExists( lpszDrvFile, gszProviderInstall ))
        {
            LOG((TL_ERROR, "No Install Proc"));
            goto next_driver;
        }
        
        // slam it into the list box
        //--------------------------
        uIndex = (UINT)SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szDrvDescription );
        if ( uIndex == CB_ERR )
        {
            uResult = FALSE;
            goto  done;
        }
        
        if ( SendMessage( hwndList, LB_SETITEMDATA, uIndex, (LPARAM)lpszDrvFile ) == CB_ERR )
        {
            uResult = FALSE;
            goto  done;
        }
        
next_driver:
        
        uResult = FALSE;
        if (FindNextFile( hFindFile, &ftFileInfo ))
        {
            uResult = TRUE;
        }
    }

    while (InstalledProvidersList.dwEntries > 0)
    {
        pProvider = (PINSTALLED_PROVIDER)RemoveHeadList (&InstalledProvidersList.Head);
        InstalledProvidersList.dwEntries --;
        ClientFree (pProvider);
    }

    uResult = TRUE;
    
done:
    if (0 == SendMessage (hwndList, LB_GETCOUNT, 0, 0))
    {
        if (0 < LoadString (GetUIInstance(), IDS_NO_PROVIDERS, szDrvDescription, ARRAYSIZE(szDrvDescription)))
        {
            SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szDrvDescription );
        }
        EnableWindow (GetDlgItem (hwndParent, IDC_ADD), FALSE);
    }
    else
    {
        SendMessage( hwndList, LB_SETCURSEL, 0, 0 );    // set focus to the top guy
        UpdateDriverDlgButtons( hwndParent );
    }
    
    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );
    
    return uResult;
}


/*--------------------------------------------------------------------------*\

  Function:   AddProvider
  
  Purpose:    Call lineAddProvider
    
\*--------------------------------------------------------------------------*/
BOOL AddProvider( HWND hwndParent, HWND hwndList, LPTSTR lpszDriverFile )
{
    UINT  uIndex;
    LONG  lResult;
    DWORD dwProviderID;
    
    if ( lpszDriverFile == NULL )
    {
        DBG_ASSERT( hWnd, "Simultaneously NULL pointer & hwnd" );
        
        // get the stuff from the list box
        //--------------------------------
        uIndex = (UINT)SendMessage( hwndList, LB_GETCURSEL, 0, 0 );
        lpszDriverFile = (LPTSTR)SendMessage( hwndList, LB_GETITEMDATA, uIndex, 0 );
        
        if (lpszDriverFile == NULL)
        {
            return FALSE;
        }
    }

    lResult = lineAddProvider( lpszDriverFile, hwndParent, &dwProviderID );

    if (lResult)
    {
        LOG((TL_ERROR, "Error: lineAddProvider failure %#08lx", lResult ));
        return FALSE;
    }
    
    return TRUE;
}

BOOL
IsUserAdmin()

/*++

Routine Description:

    Determine if current user is a member of the local admin's group

Arguments:

Return Value:

    True if member

--*/

{
    BOOL                        foundEntry = FALSE;
    HANDLE                      hToken = NULL;
    DWORD                       dwInfoSize = 0;
    PTOKEN_GROUPS               ptgGroups = NULL;
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
    PSID                        pSid = NULL;
    DWORD                       i;
    
    //
    //  Get user thread or process token
    //
    
    if (!OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_QUERY,
        FALSE,
        &hToken))
    {       
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) 
        {
            goto ExitHere;
        }
    }

    //
    //  Get user group SIDs
    //
    
    if (!GetTokenInformation(
        hToken,
        TokenGroups,
        NULL,
        0,
        &dwInfoSize
        ))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            goto ExitHere;
        }
    }
    ptgGroups = (PTOKEN_GROUPS) ClientAlloc (dwInfoSize);
    if (ptgGroups == NULL)
    {
        goto ExitHere;
    }
    if (!GetTokenInformation(
        hToken,
        TokenGroups,
        ptgGroups,
        dwInfoSize,
        &dwInfoSize
        ))
    {
        goto ExitHere;
    }

    //
    //  Get the local admin group SID
    //

    if(!AllocateAndInitializeSid(
        &sia,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSid
        )) 
    {
        goto ExitHere;
    }

    //
    //  Compare to see if the user is in admin group
    //
    for (i = 0; i < ptgGroups->GroupCount; ++i)
    {
        if (EqualSid (ptgGroups->Groups[i].Sid, pSid))
        {
            break;
        }
    }
    if (i < ptgGroups->GroupCount)
    {
        foundEntry = TRUE;
    }

ExitHere:
    if (pSid)
    {
        FreeSid (pSid);
    }
    if (ptgGroups)
    {
        ClientFree (ptgGroups);
    }
    if (hToken)
    {
        CloseHandle (hToken);
    }
    return foundEntry;
}

VOID UpdateDriverDlgButtons( HWND hwnd )
{
    //
    // Enable/disable the Remove & Config buttons as appropriate
    //
    
    UINT    uResult;
    LPTSTR   lpszProviderFilename;
    DWORD   dwProviderID;
    BOOL    bAdmin = IsUserAdmin ();
    
    uResult = (UINT) SendDlgItemMessage(
        hwnd,
        IDC_LIST,
        LB_GETCURSEL,
        0,
        0
        );
    
    dwProviderID = (DWORD) SendDlgItemMessage(
        hwnd,
        IDC_LIST,
        LB_GETITEMDATA,
        uResult, 0
        );
    
    lpszProviderFilename = ProviderIDToFilename (dwProviderID);
    
    EnableWindow(
        GetDlgItem (hwnd, IDC_ADD),
        bAdmin
        );
    
    EnableWindow(
        GetDlgItem (hwnd, IDC_REMOVE),
        bAdmin &&
        (lpszProviderFilename != NULL) &&
        VerifyProcExists (lpszProviderFilename, gszProviderRemove)
        );
    
    EnableWindow(
        GetDlgItem( hwnd, IDC_EDIT),
        bAdmin &&
        (lpszProviderFilename != NULL) &&
        VerifyProcExists (lpszProviderFilename, gszProviderSetup)
        );
}



/*--------------------------------------------------------------------------*\

  Function:   AddDriver_DialogProc
  
    Purpose:
    
\*--------------------------------------------------------------------------*/
INT_PTR AddDriver_DialogProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam )
{
    switch( wMessage )
    {
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a114HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a114HelpIDs);
        break;
        
    case WM_INITDIALOG:
        // initalize all the fields
        //-------------------------
        if ( !FillAddDriverList(hWnd, GetDlgItem(hWnd, IDC_DRIVER_LIST)) )
        {
            EndDialog( hWnd, IDCANCEL );
            return TRUE;
        }
        
        if ( SendDlgItemMessage( hWnd, IDC_DRIVER_LIST, LB_GETCOUNT, 0, 0 ) <= 0 )
            EnableWindow( GetDlgItem( hWnd, IDC_ADD ), FALSE );
        
        return TRUE;
        
    case  WM_COMMAND:
        // do some work with the buttons
        //------------------------------
        switch ( GET_WM_COMMAND_ID(wParam, lParam) )
        {
            case  IDC_DRIVER_LIST:
            
                // do the list stuff
                //------------------
                if ((GET_WM_COMMAND_CMD( wParam, lParam ) != LBN_DBLCLK) || (SendDlgItemMessage( hWnd, IDC_DRIVER_LIST, LB_GETCOUNT, 0, 0 ) <= 0 ))
                    break;      // done
                // fall through, threat the double click like an add message
            
            case  IDC_ADD:
            
                // add a new driver
                //-----------------
            
                if ( !AddProvider(hWnd, GetDlgItem(hWnd, IDC_DRIVER_LIST), NULL) )
                {
                    wParam = IDCANCEL;
                }
                else
                {
                    wParam = IDOK;
                }
            
                // fall through, exit the dialog
            
            case  IDOK:
            case  IDCANCEL:
            {
             UINT   uIndex, uCount;
             LPTSTR lpszDriverFile;
             HWND   hwndList = GetDlgItem(hWnd, IDC_DRIVER_LIST);

                uCount = (UINT)SendMessage( hwndList, LB_GETCOUNT, 0, 0 );
                for (uIndex = 0; uIndex < uCount; uIndex++)
                {
                    lpszDriverFile = (LPTSTR)SendMessage( hwndList, LB_GETITEMDATA, uIndex, 0 );
                    if (NULL != lpszDriverFile)
                    {
                        ClientFree (lpszDriverFile);
                    }
                }

                EndDialog( hWnd, wParam );
                break;
            }
        }
        
        return TRUE;
    }
    
    return FALSE;
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL RefreshProviderList()
{
    LONG lResult;


    if (!glpProviderList)
    {
        // Initialize data structure
        
        glpProviderList = (LPLINEPROVIDERLIST)GlobalAllocPtr(GPTR, INITIAL_PROVIDER_LIST_SIZE);
    }

    if (!glpProviderList)
    {
        LOG((TL_ERROR, " RefreshProviderList - glpProviderList is NULL - returning CPL_ERR_MEMORY"));
        return FALSE;
    }

    glpProviderList->dwTotalSize = INITIAL_PROVIDER_LIST_SIZE;
    
    lResult = lineGetProviderList( TAPI_VERSION, glpProviderList );

    if (lResult)
    {
        LOG((TL_ERROR, "Error: lineGetProviderList failure %#08lx", lResult ));
        return FALSE;
    }

    while (glpProviderList->dwNeededSize > glpProviderList->dwTotalSize)
    {
        // Expand data structure as necessary
        LOG((TL_ERROR, " RefreshProviderList - expanding glpProviderList."));
        
        LPLINEPROVIDERLIST lpTemp =
            (LPLINEPROVIDERLIST)GlobalReAllocPtr( glpProviderList,
            (size_t)(glpProviderList->dwNeededSize),
            GPTR);
        
        if (!lpTemp)
            return FALSE;
        
        glpProviderList = lpTemp;
        glpProviderList->dwTotalSize = glpProviderList->dwNeededSize;
        lResult = lineGetProviderList( TAPI_VERSION, glpProviderList );
        
        if (lResult)
        {
            LOG((TL_ERROR, "Error: lineGetProviderList failure %#08lx", lResult ));
            return FALSE;
        }
    }

    LOG((TL_ERROR, "%d providers", glpProviderList->dwNumProviders ));

    return TRUE;
}



LPTSTR ProviderIDToFilename( DWORD dwProviderID )
{
    UINT uIndex;
    LPLINEPROVIDERENTRY lpProviderEntry;
    
    // loop through the provider list
    //-------------------------------
    
    lpProviderEntry = (LPLINEPROVIDERENTRY)((LPBYTE)glpProviderList +
        glpProviderList->dwProviderListOffset);
    
    for ( uIndex = 0; uIndex < glpProviderList->dwNumProviders; uIndex++ )
    {
        if (lpProviderEntry[uIndex].dwPermanentProviderID == dwProviderID)
        {
            // Get an entry to put in the list box
            //------------------------------------
            return (LPTSTR)((LPBYTE)glpProviderList +
                lpProviderEntry[uIndex].dwProviderFilenameOffset);
        }
    }
    
    LOG((TL_ERROR, "Provider ID %d not found in list", dwProviderID ));
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplareacodedlg.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplareacodedlg.cpp
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#include "cplPreComp.h"
#include "cplAreaCodeDlg.h"
#include "cplSimpleDialogs.h"

CAreaCodeRuleDialog::CAreaCodeRuleDialog(BOOL bNew, CAreaCodeRule * pRule)
{
    m_bNew = bNew;
    m_pRule = pRule;
    m_iSelectedItem = -1;
}

CAreaCodeRuleDialog::~CAreaCodeRuleDialog()
{
}

INT_PTR CAreaCodeRuleDialog::DoModal(HWND hwndParent)
{
    return DialogBoxParam( GetUIInstance(), MAKEINTRESOURCE(IDD_NEWAREACODERULE), hwndParent, CAreaCodeRuleDialog::DialogProc, (LPARAM)this );
}

INT_PTR CALLBACK CAreaCodeRuleDialog::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAreaCodeRuleDialog * pthis = (CAreaCodeRuleDialog *)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CAreaCodeRuleDialog *)lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis);
        return pthis->OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);

    case WM_NOTIFY:
        return pthis->OnNotify(hwndDlg, (LPNMHDR)lParam);
    
    case WM_HELP:
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a109HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a109HelpIDs);

    }
    return 0;
}

void CAreaCodeRuleDialog::PopulatePrefixList(HWND hwndList)
{
    TCHAR szText[MAX_INPUT];
    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.pszText = szText;
    int i;
    LPWSTR pszz = m_pRule->GetPrefixList();

    if (pszz)
    {
        while (*pszz)
        {
            SHUnicodeToTChar( pszz, szText, ARRAYSIZE(szText) );
            ListView_InsertItem(hwndList, &lvi);
            pszz += lstrlenW(pszz)+1;
        }
    }
}

void CAreaCodeRuleDialog::SetPrefixControlsState(HWND hwndDlg, BOOL bAll)
{
    HWND hwndList = GetDlgItem(hwndDlg,IDC_PREFIXES);
    EnableWindow(hwndList, !bAll);
    hwndList = GetDlgItem(hwndDlg, IDC_LIST);
    EnableWindow(hwndList, !bAll);
    EnableWindow(GetDlgItem(hwndDlg,IDC_ADD),  !bAll);

    // by default, no prefix is selected so the remove button is always disabled at first
    if (m_iSelectedItem == -1)
    {
        m_iSelectedItem = 0;
    }
    EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), ListView_GetItemCount(hwndList) && !bAll);
    if (!bAll)
    {
        ListView_SetItemState(hwndList, m_iSelectedItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
    }
}

BOOL CAreaCodeRuleDialog::OnInitDialog(HWND hwndDlg)
{
    HWND hwnd;
    TCHAR szText[MAX_INPUT];

    if ( !m_bNew )
    {
        LoadString(GetUIInstance(),IDS_EDITRULE, szText, ARRAYSIZE(szText));
        SetWindowText(hwndDlg, szText);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
    SHUnicodeToTChar(m_pRule->GetAreaCode(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);

    BOOL bAll = m_pRule->HasAppliesToAllPrefixes();
    CheckRadioButton(hwndDlg, IDC_ALLPREFIXES, IDC_LISTEDPREFIXES, bAll?IDC_ALLPREFIXES:IDC_LISTEDPREFIXES);

    // populate the prefix list
    hwnd = GetDlgItem(hwndDlg, IDC_LIST);
    RECT rc;
    GetClientRect(hwnd, &rc);
    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn( hwnd, 0, &lvc );
    PopulatePrefixList(hwnd);
    if (ListView_GetItemCount(hwnd) > 0)
    {
        m_iSelectedItem = 0;
        ListView_SetItemState(hwnd, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
    }

    SetPrefixControlsState(hwndDlg, bAll);

    hwnd = GetDlgItem(hwndDlg,IDC_DIALNUMBER);
    SHUnicodeToTChar(m_pRule->GetNumberToDial(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    if ( m_pRule->HasDialNumber() )
    {
        SendMessage( GetDlgItem(hwndDlg,IDC_DIALCHECK), BM_SETCHECK, BST_CHECKED, 0 );
    }
    else
    {
        EnableWindow(hwnd, FALSE);
    }
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA);

    if ( m_pRule->HasDialAreaCode() )
    {
        SendMessage( GetDlgItem(hwndDlg,IDC_DIALAREACODE), BM_SETCHECK, BST_CHECKED, 0 );
    }

    return 1;
}

BOOL CAreaCodeRuleDialog::OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch (wID)
    {
    case IDOK:
        if (!ApplyChanges(hwndParent) )
        {
            break;
        }
        // fall through

    case IDCANCEL:
        HideToolTip();
        EndDialog(hwndParent,wID);
        break;

    case IDC_ALLPREFIXES:
    case IDC_LISTEDPREFIXES:
        SetPrefixControlsState(hwndParent, IDC_ALLPREFIXES==wID);
        break;

    case IDC_ADD:
        AddPrefix(hwndParent);
        break;

    case IDC_REMOVE:
        RemoveSelectedPrefix(hwndParent);
        break;

    case IDC_DIALCHECK:
        if ( BN_CLICKED == wNotifyCode )
        {
            BOOL bOn = SendMessage(hwndCrl, BM_GETCHECK, 0,0) == BST_CHECKED;
            HWND hwnd = GetDlgItem(hwndParent, IDC_DIALNUMBER);
            EnableWindow(hwnd, bOn);
            if ( bOn )
            {
                SetFocus(hwnd);
            }
        }
        break;

    default:
        return 0;
    }

    return 1;
}

BOOL CAreaCodeRuleDialog::OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    switch (pnmhdr->idFrom)
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( (pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED) )
            {
                m_iSelectedItem = pnmlv->iItem;

                EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), pnmlv->iItem != -1);
            }
            break;

        case NM_DBLCLK:
            if ( -1 == pnmlv->iItem )
            {
                // Do new case
                AddPrefix(hwndDlg);
            }
            break;

        case NM_CLICK:
            if ( (-1 == pnmlv->iItem) && (-1!=m_iSelectedItem) )
            {
                m_iSelectedItem = -1;

                EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), FALSE);
            }
            break;

        default:
            break;

        }
        break;
        #undef pnmlv

    default:
        return 0;
    }
    return 1;
}

BOOL CAreaCodeRuleDialog::ApplyChanges(HWND hwndParent)
{
    TCHAR szAreaCode[MAX_INPUT] = {0};
    TCHAR szBuffer[MAX_INPUT];
    WCHAR wszBuffer[1024];
    PWSTR pwsz;
    HWND hwnd;

    // read the area code
    hwnd = GetDlgItem(hwndParent,IDC_AREACODE);
    GetWindowText(hwnd, szAreaCode, ARRAYSIZE(szAreaCode));
    if ( !*szAreaCode )
    {
        ShowErrorMessage(hwnd, IDS_NEEDANAREACODE);
        return FALSE;
    }

    // read the prefix list
    hwnd = GetDlgItem(hwndParent, IDC_LIST);
    int iItems = ListView_GetItemCount(hwnd);
    int i;
    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;
    lvi.pszText = szBuffer;
    lvi.cchTextMax = ARRAYSIZE(szBuffer);

    UINT cchFree = ARRAYSIZE(wszBuffer);
    wszBuffer[1] = TEXT('\0');  // ensure double NULL termination if iItems is zero
    pwsz = wszBuffer;
    for (i=0; i<iItems; i++)
    {
        UINT cchPrefix;
        lvi.mask = LVIF_TEXT;
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);

        cchPrefix = lstrlen(szBuffer);
        if (cchPrefix >= cchFree)
        {
            // out of space in temp buffer.  Hopefully this will never happen
            LOG((TL_ERROR, "ApplyChanges: Out of space in temp buffer."));
            break;
        }
        SHTCharToUnicode(szBuffer, pwsz, cchFree-1);
        pwsz += cchPrefix+1;
        cchFree -= cchPrefix+1;
    }
    *pwsz = NULL;

    BOOL bAllPrefixes;
    bAllPrefixes = SendMessage( GetDlgItem(hwndParent, IDC_ALLPREFIXES), BM_GETCHECK, 0,0 ) == BST_CHECKED;
    if ( !bAllPrefixes && iItems==0 )
    {
        ShowErrorMessage(GetDlgItem(hwndParent,IDC_ADD), IDS_NEEDPREFIXLIST);
        return FALSE;
    }

    BOOL dDialNumber;
    dDialNumber = SendMessage( GetDlgItem(hwndParent, IDC_DIALCHECK), BM_GETCHECK, 0,0 ) == BST_CHECKED;
    GetWindowText(GetDlgItem(hwndParent,IDC_DIALNUMBER), szBuffer, ARRAYSIZE(szBuffer));
    if ( dDialNumber && IsEmptyOrHasOnlySpaces(szBuffer))
    {
        ShowErrorMessage(GetDlgItem(hwndParent,IDC_DIALNUMBER), IDS_NEEDDIALNUMBER);
        return FALSE;
    }

    // TODO:
    // for each prefix, look for a conflicting rule.
    // if a conflict is found, alert the user.
    // based on the alert optionally ammend the conflicting rule

    // now we have verified the input is valid, go ahead and update everything:

    // save the prefix list even if Applies To All is selected.
    m_pRule->SetPrefixList( wszBuffer, (ARRAYSIZE(wszBuffer)-cchFree+1)*sizeof(WCHAR) );

    // read all verse select prefixes radio button
    m_pRule->SetAppliesToAllPrefixes( bAllPrefixes );

    // Save the area code.
    SHTCharToUnicode(szAreaCode, wszBuffer, ARRAYSIZE(wszBuffer));
    m_pRule->SetAreaCode( wszBuffer );

    // Save the dial number
    SHTCharToUnicode(szBuffer, wszBuffer, ARRAYSIZE(wszBuffer));
    m_pRule->SetNumberToDial( wszBuffer );

    // Save the dial number checkbox
    m_pRule->SetDialNumber( dDialNumber );

    // read the dial area code check box
    BOOL b;
    b = SendMessage( GetDlgItem(hwndParent, IDC_DIALAREACODE), BM_GETCHECK, 0,0 ) == BST_CHECKED;
    m_pRule->SetDialAreaCode( b );

    return TRUE;
}

void CAreaCodeRuleDialog::AddPrefix(HWND hwndParent)
{
    CEditDialog ed;
    INT_PTR iRes = ed.DoModal(hwndParent, IDS_ADDPREFIX, IDS_TYPEPREFIX, IDS_ACPREFIXES, LIF_ALLOWNUMBER|LIF_ALLOWSPACE|LIF_ALLOWCOMMA);
    if ( iRes == (INT_PTR)IDOK )
    {
        LPTSTR psz = ed.GetString();
        if (!psz)
            return; // should be impossible, but better safe than sorry

        // The string can contain multiple prefixes seperated by spaces, parse it
        // up and add one prefix for each chunk
        while (*psz)
        {
            LPTSTR pszNext;
            TCHAR ch;
            HWND hwndList = GetDlgItem(hwndParent, IDC_LIST);

            // trim leading spaces
            while ((*psz == TEXT(' ')) || (*psz == TEXT(',')))
                psz++;

            // check if trimming the spaces toke us to the end of the string
            if ( *psz )
            {
                // find next space and make it a temporary null
                pszNext = psz;
                while (*pszNext && (*pszNext != TEXT(' ')) && (*pszNext != TEXT(',')) )
                    pszNext++;
                ch = *pszNext;
                *pszNext = NULL;

                // add this item to the list
                LVITEM lvi;
                lvi.mask = LVIF_TEXT;
                lvi.pszText = psz;
                lvi.iItem = 0;
                lvi.iSubItem = 0;

                ListView_InsertItem(hwndList, &lvi);

                // replace our tempory null with it's previous value
                *pszNext = ch;

                // advance the psz point
                psz = pszNext;
            }
        }
    }
}

void CAreaCodeRuleDialog::RemoveSelectedPrefix(HWND hwndParent)
{
    if ( -1 != m_iSelectedItem )
    {
        m_iSelectedItem = DeleteItemAndSelectPrevious(hwndParent, IDC_LIST, m_iSelectedItem, IDC_REMOVE, IDC_ADD);
    }
}

int DeleteItemAndSelectPrevious( HWND hwndParent, int iList, int iItem, int iDel, int iAdd )
{
    HWND hwnd = GetDlgItem(hwndParent, iList);
    ListView_DeleteItem(hwnd, iItem);

    // Try to select the previous item, if possible
    iItem--;
    if ( 0 > iItem )
    {
        iItem = 0;
    }
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    if ( ListView_GetItem(hwnd, &lvi) )
    {
        ListView_SetItemState(hwnd, iItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        ListView_EnsureVisible(hwnd, iItem, FALSE);
    }
    else
    {
        iItem = -1;
    }

    hwnd = GetDlgItem(hwndParent,iDel);
    if ( -1 == iItem )
    {
        if ( GetFocus() == hwnd )
        {
            HWND hwndDef = GetDlgItem(hwndParent,iAdd);
            SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
            SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
            SetFocus(hwndDef);
        }
    }
    EnableWindow(hwnd, -1!=iItem);

    return iItem;
}


BOOL  IsEmptyOrHasOnlySpaces(PTSTR pwszStr)
{
    while(*pwszStr)
        if(*pwszStr++ != TEXT(' '))
            return FALSE;

    return TRUE;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplareacodedlg.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplareacodedlg.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

class CAreaCodeRuleDialog
{
public:
    CAreaCodeRuleDialog(BOOL bNew, CAreaCodeRule * pRule);
    ~CAreaCodeRuleDialog();
#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CAreaCodeRuleDialog)
#endif
    INT_PTR DoModal(HWND hwndParent);

protected:
    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwndDlg);
    BOOL OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    void PopulatePrefixList(HWND hwndList);
    void SetPrefixControlsState(HWND hwndDlg, BOOL bAll);

    BOOL ApplyChanges(HWND hwndParent);
    void AddPrefix(HWND hwndParent);
    void RemoveSelectedPrefix(HWND hwndParent);

    BOOL            m_bNew;     // New or Edit in title
    CAreaCodeRule * m_pRule;    // the rule being added/edited
    int             m_iSelectedItem;    // current item selected in the list
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\client.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the tapi.dll implementation (client-side tapi)

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:


Notes:

    1. Make all funcArg structs STATIC, & just do whatever mov's necessary
       for the params (saves mov's for flags, pfnPostProcess, funcName, &
       argTypes)

--*/


#include "windows.h"
#include "wownt32.h"
#include "stdarg.h"
#include "stdio.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "clntprivate.h"
#include "tapsrv.h"
#include "loc_comn.h"
#include "prsht.h"
#include "shellapi.h"
#include "tapiperf.h"
#include "tlnklist.h"
#include "tapihndl.h"
#include "resource.h"
#include "tchar.h"
#include "shfusion.h"
#include <shlwapi.h>
#include <shlwapip.h>   // from private\inc
#include <MMSYSTEM.H>
#include <mmddk.h>

#undef   lineBlindTransfer
#undef   lineConfigDialog
#undef   lineConfigDialogEdit
#undef   lineDial
#undef   lineForward
#undef   lineGatherDigits
#undef   lineGenerateDigits
#undef   lineGetAddressCaps
#undef   lineGetAddressID
#undef   lineGetAddressStatus
#undef   lineGetCallInfo
#undef   lineGetDevCaps
#undef   lineGetDevConfig
#undef   lineGetIcon
#undef   lineGetID
#undef   lineGetLineDevStatus
#undef   lineGetRequest
#undef   lineGetTranslateCaps
#undef   lineHandoff
#undef   lineMakeCall
#undef   lineOpen
#undef   linePark
#undef   linePickup
#undef   linePrepareAddToConference
#undef   lineRedirect
#undef   lineSetDevConfig
#undef   lineSetTollList
#undef   lineSetupConference
#undef   lineSetupTransfer
#undef   lineTranslateAddress
#undef   lineUnpark
#undef   phoneConfigDialog
#undef   phoneGetButtonInfo
#undef   phoneGetDevCaps
#undef   phoneGetIcon
#undef   phoneGetID
#undef   phoneGetStatus
#undef   phoneSetButtonInfo
#undef   tapiGetLocationInfo
#undef   tapiRequestMakeCall
#undef   tapiRequestMediaCall
#undef   lineAddProvider
#undef   lineGetAppPriority
#undef   lineGetCountry
#undef   lineGetProviderList
#undef   lineSetAppPriority
#undef   lineTranslateDialog


//
//
//

#define HUB_MONITOR_LINE_CONTEXT_BASE   0xc0000000

#define ASNYC_MSG_BUF_SIZE 1024

typedef struct _ASYNC_EVENTS_THREAD_PARAMS
{
    BOOL    bExitThread;

    DWORD   dwBufSize;

    HANDLE  hTapi32;

    HANDLE  hWow32;

    LPBYTE  pBuf;

} ASYNC_EVENTS_THREAD_PARAMS, *PASYNC_EVENTS_THREAD_PARAMS;



#if DBG

//
// N.B. This structure MUST be a multiple of 8 bytes in size.
//

typedef struct _MYMEMINFO
{
    struct _MYMEMINFO * pNext;
    struct _MYMEMINFO * pPrev;
    DWORD               dwSize;
    DWORD               dwLine;
    PSTR                pszFile;
    DWORD               dwAlign;

//    LPTSTR              pName;
} MYMEMINFO, *PMYMEMINFO;

PMYMEMINFO            gpMemFirst = NULL, gpMemLast = NULL;
CRITICAL_SECTION      csMemoryList;
BOOL                  gbBreakOnLeak = FALSE;

void
DumpMemoryList();
#endif

//
// Global vars
//

BOOL    gbHiddenWndClassRegistered = FALSE;
BOOL    gbNTVDMClient        = FALSE;
DWORD   gdwRpcRefCount       = 0;
BOOL    gbDisableGetTranslateCapsHack = FALSE;
DWORD   gdwNumInits          = 0;
DWORD   gdwTlsIndex;
DWORD   gdwTlsIndexRpcCtx;
DWORD   gdwNumLineDevices    = 0;
DWORD   gdwNumPhoneDevices   = 0;
DWORD   gdwInitialTickCount;
HANDLE  ghAsyncEventsEvent   = NULL;
HANDLE  ghInitMutex;

#if DBG
DWORD gdwDebugLevel = 0;
#endif

TCHAR gszLCRDLL[] = TEXT("LeastCostRoutingDLL");
TCHAR gszRemoteSP[] = TEXT("RemoteSP.TSP");


LONG
(WINAPI
*pfnLineOpenWLCR)(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
(WINAPI
*pfnLineOpenALCR)(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
(WINAPI
*pfnLineTranslateAddressWLCR)(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

LONG EnsureOneLocation (HWND hwnd);

extern BOOL     gbTranslateSimple;
extern BOOL     gbTranslateSilent;

HINSTANCE  g_hInst;

PASYNC_EVENTS_THREAD_PARAMS gpAsyncEventsThreadParams = NULL;

#if DBG
const TCHAR   gszTapi32DebugLevel[] = TEXT("Tapi32DebugLevel");
#endif
const TCHAR   gszTapi32MaxNumRequestRetries[] = TEXT("Tapi32MaxNumRequestRetries");
const TCHAR   gszTapi32RequestRetryTimeout[] =  TEXT("Tapi32RequestRetryTimeout");
extern TCHAR gszTelephonyKey[];

DWORD   gdwMaxNumRequestRetries;
DWORD   gdwRequestRetryTimeout;

const TCHAR    szTapi32WndClass[]    = TEXT("Tapi32WndClass");

// These all get passed to GetProcAddress so they stay as ANSI
const CHAR  gszTUISPI_providerConfig[]        = "TUISPI_providerConfig";
const CHAR  gszTUISPI_providerGenericDialog[] = "TUISPI_providerGenericDialog";
const CHAR  gszTUISPI_providerGenericDialogData[] = "TUISPI_providerGenericDialogData";
const CHAR  gszTUISPI_providerInstall[]       = "TUISPI_providerInstall";
const CHAR  gszTUISPI_providerRemove[]        = "TUISPI_providerRemove";
const CHAR  gszTUISPI_lineConfigDialog[]      = "TUISPI_lineConfigDialog";
const CHAR  gszTUISPI_lineConfigDialogEdit[]  = "TUISPI_lineConfigDialogEdit";
const CHAR  gszTUISPI_phoneConfigDialog[]     = "TUISPI_phoneConfigDialog";

extern TCHAR  gszLocations[];

HANDLE      ghHandleTable;

HINSTANCE   ghWow32Dll = NULL;
FARPROC     gpfnWOWGetVDMPointer = NULL;

static FARPROC  gpPostQueuedCompletionStatus = NULL;

PUITHREADDATA   gpUIThreadInstances = NULL;

CRITICAL_SECTION        gCriticalSection;
CRITICAL_SECTION        gUICriticalSection;
PCONTEXT_HANDLE_TYPE    gphCx = (PCONTEXT_HANDLE_TYPE) NULL;

LIST_ENTRY              gTlsListHead;
CRITICAL_SECTION        gTlsCriticalSection;

#if DBG
// All the debug only stuff stays as ANSI (just because it was easier than chagning it).
const char *aszMsgs[] =
{
    "LINE_ADDRESSSTATE",
    "LINE_CALLINFO",
    "LINE_CALLSTATE",
    "LINE_CLOSE",
    "LINE_DEVSPECIFIC",
    "LINE_DEVSPECIFICFEATURE",
    "LINE_GATHERDIGITS",
    "LINE_GENERATE",
    "LINE_LINEDEVSTATE",
    "LINE_MONITORDIGITS",
    "LINE_MONITORMEDIA",
    "LINE_MONITORTONE",
    "LINE_REPLY",
    "LINE_REQUEST",
    "PHONE_BUTTON",
    "PHONE_CLOSE",
    "PHONE_DEVSPECIFIC",
    "PHONE_REPLY",
    "PHONE_STATE",
    "LINE_CREATE",
    "PHONE_CREATE",
    "LINE_AGENTSPECIFIC",
    "LINE_AGENTSTATUS",
    "LINE_APPNEWCALL",
    "LINE_PROXYREQUEST",
    "LINE_REMOVE",
    "PHONE_REMOVE"
};
#endif

LONG gaNoMemErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_NOMEM,
    PHONEERR_NOMEM
};

LONG gaInvalHwndErrors[3] =
{
    TAPIERR_INVALWINDOWHANDLE,
    LINEERR_INVALPARAM,
    PHONEERR_INVALPARAM
};

LONG gaInvalPtrErrors[3] =
{
    TAPIERR_INVALPOINTER,
    LINEERR_INVALPOINTER,
    PHONEERR_INVALPOINTER
};

LONG gaOpFailedErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_OPERATIONFAILED,
    PHONEERR_OPERATIONFAILED
};

LONG gaStructTooSmallErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_STRUCTURETOOSMALL,
    PHONEERR_STRUCTURETOOSMALL
};

LONG gaServiceNotRunningErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_SERVICE_NOT_RUNNING,
    PHONEERR_SERVICE_NOT_RUNNING
};

#define AllInitExOptions2_0                           \
        (LINEINITIALIZEEXOPTION_USEHIDDENWINDOW     | \
        LINEINITIALIZEEXOPTION_USEEVENT             | \
        LINEINITIALIZEEXOPTION_USECOMPLETIONPORT)


//
// Function prototypes
//

void
PASCAL
lineMakeCallPostProcess(
    PASYNCEVENTMSG  pMsg
    );

LONG
WINAPI
AllocClientResources(
    DWORD   dwErrorClass
    );

LONG
WINAPI
ReAllocClientResources(
    DWORD dwErrorClass
    );

BOOL
WINAPI
_CRT_INIT(
    HINSTANCE   hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    );

LONG
CreateHiddenWindow(
    HWND   *lphwnd,
    DWORD   dwErrorClass
    );

void
FreeInitData(
    PINIT_DATA  pInitData
    );

LONG
WINAPI
FreeClientResources(
    void
    );

LONG
CALLBACK
TUISPIDLLCallback(
    DWORD   dwObjectID,
    DWORD   dwObjectType,
    LPVOID  lpParams,
    DWORD   dwSize
    );

BOOL
CALLBACK
TranslateDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

void
UIThread(
    LPVOID  pParams
    );

char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );

void
PASCAL
lineDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    );

BOOL 
WaveStringIdToDeviceId(
    LPWSTR  pwszStringID,
    LPCWSTR  pwszDeviceType,
    LPDWORD pdwDeviceId
    );

LONG
PASCAL
xxxShutdown(
    HLINEAPP    hXXXApp,
    BOOL        bLineShutdown
    );

LONG
PASCAL
xxxGetMessage(
    BOOL            bLine,
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   pMsg,
    DWORD           dwTimeout
    );
    
void
PASCAL
lineGetAgentActivityListAPostProcess(
    PASYNCEVENTMSG pMsg
    );

void
PASCAL
lineCompleteCallPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGatherDigitsPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGatherDigitsWPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetAgentCapsAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetAgentGroupListAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetQueueListAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetAgentStatusAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineParkAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineSetupConferencePostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
phoneDevSpecificPostProcess(
    PASYNCEVENTMSG  pMsg
    );


POSTPROCESSPROC gPostProcessingFunctions[] = 
{
    NULL,
    lineGetAgentActivityListAPostProcess,
    lineCompleteCallPostProcess,
    lineDevSpecificPostProcess,
    lineGatherDigitsPostProcess,
    lineGatherDigitsWPostProcess,
    lineGetAgentCapsAPostProcess,
    lineGetAgentGroupListAPostProcess,
    lineGetAgentStatusAPostProcess,
    lineGetQueueListAPostProcess,
    lineMakeCallPostProcess,
    lineParkAPostProcess,
    lineSetupConferencePostProcess,
    phoneDevSpecificPostProcess
};


//
// The code...
//

/////////////////////////////////////
//
//  GetFunctionIndex
// 
//  find the array index of the function. 
//
//  returns 0 if the function was not found in the array
//

DWORD GetFunctionIndex(POSTPROCESSPROC Function)
{

    int i;
    const int nArraySize = 
        sizeof(gPostProcessingFunctions)/sizeof(POSTPROCESSPROC);


    for (i = 0; i < nArraySize; i++)
    {

        if (Function == gPostProcessingFunctions[i])
        {

            break;
        }
    }



    //
    // the function that is passed in had better be in the array. if not -- this should be caught in testing!
    //
#if DBG
    if (0 == i)
    {
        DebugBreak ();
    }
#endif

    if (i == nArraySize)
    {

        LOG((TL_ERROR,
            "GetFunctionIndex: function %p is not found in the array of functions!",
            Function));

        i = 0;
    }


    LOG((TL_ERROR, 
        "GetFunctionIndex: function %p mapped to index %d.", Function, i));

    return i;

}



PWSTR
PASCAL
NotSoWideStringToWideString(
    LPCSTR  lpStr,
    DWORD   dwLength
    )
{
    DWORD dwSize;
    PWSTR pwStr;


    if (IsBadStringPtrA (lpStr, dwLength))
    {
        return NULL;
    }

    dwSize = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpStr,
        dwLength,
        NULL,
        0
        );

    pwStr = ClientAlloc( dwSize * sizeof(WCHAR) );

    if (NULL != pwStr)
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpStr,
            dwLength,
            pwStr,
            dwSize
            );
    }

    return pwStr;
}


//
//NOTE: This function requires that lpBase is a pointer to the start of
//      a TAPI struct that has dwTotalSize as the first DWORD
//
void
PASCAL
WideStringToNotSoWideString(
    LPBYTE  lpBase,
    LPDWORD lpdwXxxSize
    )
{
    DWORD  dwSize;
    DWORD  dwNewSize;
    DWORD  dwOffset;
    DWORD  dwTotalSize;
    DWORD  dwUsedSize;
    PWSTR  pString;
    char   szStackBuf[64];
    PSTR   lpszStringA;


    if ((dwSize = *lpdwXxxSize) != 0)
    {
        dwTotalSize = *((LPDWORD) lpBase);

        dwUsedSize = *(((LPDWORD) lpBase)+2);

        dwOffset = *(lpdwXxxSize + 1);

        pString = (PWSTR)(lpBase + dwOffset);


        if (TAPIIsBadStringPtrW (pString, dwSize))
        {
           LOG((TL_ERROR,
               "The service provider returned an invalid field " \
               "in the structure 0x%p : 0x%p",
               lpBase,
               lpdwXxxSize
               ));

           *lpdwXxxSize     = 0;
           *(lpdwXxxSize+1) = 0;

           return;
        }


        //
        // Did we get enough chars?
        //

        if (dwUsedSize > dwOffset )
        {
            dwNewSize = WideCharToMultiByte(
                GetACP(),
                0,
                pString,
                ( dwUsedSize >= (dwOffset+dwSize)) ?
                    (dwSize/sizeof(WCHAR)) :
                    (dwUsedSize - dwOffset) / sizeof(WCHAR),
                NULL,
                0,
                NULL,
                NULL
                );

            lpszStringA = (dwNewSize <= sizeof (szStackBuf) ?
                (PSTR) szStackBuf : ClientAlloc (dwNewSize) );

            if ( NULL == lpszStringA )
            {
               *lpdwXxxSize     = 0;
               *(lpdwXxxSize+1) = 0;

               return;
            }

            WideCharToMultiByte(
                GetACP(),
                0,
                pString,
//                dwSize,
                ( dwUsedSize >= (dwOffset+dwSize)) ?
                    (dwSize/sizeof(WCHAR)) :
                    (dwUsedSize - dwOffset) / sizeof(WCHAR),
                lpszStringA,
                dwNewSize,
                NULL,
                NULL
                );

            //
            // Copy the new ANSI string back to where the Unicode string was
//            // and write out NULL terminator if possible.
            //

            CopyMemory ( (LPBYTE) pString,
                         lpszStringA,
                         dwNewSize  // + (
                                    //  ((dwNewSize + dwOffset) < dwUsedSize ) ?
                                    //  1 :
                                    //  0
                                    // )
                          );

            if (lpszStringA != (PSTR) szStackBuf)
            {
                ClientFree (lpszStringA);
            }


            //
            // Update the number of bytes
            //

            *lpdwXxxSize = dwNewSize;
        }
    }
}


VOID
CALLBACK
FreeContextCallback(
    LPVOID      Context,
    LPVOID      Context2
    )
{
    //ClientFree (Context);
}


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        g_hInst = hDLL;
        InitializeListHead (&gTlsListHead);

        SHFusionInitializeFromModuleID (hDLL,124);

        gdwInitialTickCount = GetTickCount();

        ghHandleTable = CreateHandleTable(
            GetProcessHeap(),
            FreeContextCallback,
            0x80000000,
            0x8fffffff
            );

        if (NULL == ghHandleTable)
        {
            return FALSE;
        }

        //
        // Init CRT
        //

        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            return FALSE;
        }

        {
            HKEY  hKey;


#if DBG
            gdwDebugLevel = 0;
#endif
            gdwMaxNumRequestRetries = 40;
            gdwRequestRetryTimeout = 250; // milliseconds

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszTelephonyKey,
                    0,
                    KEY_READ,
                    &hKey

                    ) == ERROR_SUCCESS)
            {
                DWORD dwDataSize = sizeof(DWORD), dwDataType;

#if DBG
                RegQueryValueEx(
                    hKey,
                    gszTapi32DebugLevel,
                    0,
                    &dwDataType,
                    (LPBYTE) &gdwDebugLevel,
                    &dwDataSize
                    );

                dwDataSize = sizeof(DWORD);
#endif

                RegQueryValueEx(
                    hKey,
                    gszTapi32MaxNumRequestRetries,
                    0,
                    &dwDataType,
                    (LPBYTE) &gdwMaxNumRequestRetries,
                    &dwDataSize
                    );

                RegQueryValueEx(
                    hKey,
                    gszTapi32RequestRetryTimeout,
                    0,
                    &dwDataType,
                    (LPBYTE) &gdwRequestRetryTimeout,
                    &dwDataSize
                    );

                RegCloseKey (hKey);
            }
        }


        //
        // Alloc a Tls index
        //

        if ((gdwTlsIndex = TlsAlloc()) == 0xffffffff ||
            (gdwTlsIndexRpcCtx = TlsAlloc()) == 0xffffffff)
        {
            return FALSE;
        }


        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);
        TlsSetValue (gdwTlsIndexRpcCtx, NULL);


        //
        //
        //

        ghInitMutex = CreateMutex (NULL, FALSE, NULL);

        InitializeCriticalSection (&gCriticalSection);
        InitializeCriticalSection (&gUICriticalSection);
        InitializeCriticalSection (&gTlsCriticalSection);
#if DBG
        InitializeCriticalSection( &csMemoryList);
#endif

        ListNodePoolsInitialize();

        break;
    }
    case DLL_PROCESS_DETACH:
    {
        PCLIENT_THREAD_INFO pTls;


        //
        // Clean up any Tls (no need to enter crit sec since process detaching)
        //

        while (!IsListEmpty (&gTlsListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList (&gTlsListHead);

            pTls = CONTAINING_RECORD (pEntry, CLIENT_THREAD_INFO, TlsList);

            ClientFree (pTls->pBuf);
            ClientFree (pTls);
        }

        //
        // If gpAsyncEventsThreadParams is non-NULL it means the AsyncEventsThread 
        // is still running (an ill-behaved app is trying to unload us
        // without calling shutdown) so go thru the motions of getting
        // the thread to terminate (like we do in xxxShutdown)
        //
        // Otherwise close our handle to the shared event
        //

        if (gpAsyncEventsThreadParams)
        {
            gpAsyncEventsThreadParams->bExitThread = TRUE;
            SetEvent (ghAsyncEventsEvent);
            gpAsyncEventsThreadParams = NULL;
            gdwNumInits = 0;

        }
        else if (gphCx && ghAsyncEventsEvent)
        {
            CloseHandle (ghAsyncEventsEvent);
            ghAsyncEventsEvent = NULL;
        }

        //
        // Free up any other resources we were using
        //

        if (ghWow32Dll)
        {
            FreeLibrary (ghWow32Dll);
            ghWow32Dll = NULL;
        }

        TlsFree (gdwTlsIndex);
        TlsFree (gdwTlsIndexRpcCtx);

        _CRT_INIT (hDLL, dwReason, lpReserved);

        CloseHandle (ghInitMutex);

        DeleteCriticalSection (&gCriticalSection);
        DeleteCriticalSection (&gUICriticalSection);
        DeleteCriticalSection (&gTlsCriticalSection);
#if DBG
        DumpMemoryList();
        DeleteCriticalSection( &csMemoryList);
#endif
        ListNodePoolsUninitialize();

        DeleteHandleTable (ghHandleTable);

        SHFusionUninitialize();

        break;
    }
    case DLL_THREAD_ATTACH:

        //
        // First must init CRT
        //

        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            return FALSE;
        }

        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);

        break;

    case DLL_THREAD_DETACH:
    {
        PCLIENT_THREAD_INFO pTls;


        //
        // Clean up any Tls
        //

        if ((pTls = (PCLIENT_THREAD_INFO) TlsGetValue (gdwTlsIndex)))
        {
            EnterCriticalSection (&gTlsCriticalSection);

            RemoveEntryList (&pTls->TlsList);

            LeaveCriticalSection (&gTlsCriticalSection);

            if (pTls->pBuf)
            {
                ClientFree (pTls->pBuf);
            }

            ClientFree (pTls);
        }


        //
        // Finally, alert CRT
        //

        _CRT_INIT (hDLL, dwReason, lpReserved);

        break;
    }

    } // switch

    return TRUE;
}


BOOL
IsLeastCostRoutingEnabled(
    void
    )
{
    static BOOL bInited = FALSE, bEnabled = FALSE;

    HKEY    hKey;
    TCHAR   szPath[MAX_PATH];
    DWORD   dwDataSize, dwDataType;
    HANDLE  hDll;


    if (!bInited)
    {
        //
        // Check the registry to see if there's an LCR DLL registered
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszTelephonyKey,
                0,
                KEY_QUERY_VALUE,
                &hKey

                ) == ERROR_SUCCESS)
        {
            dwDataSize = sizeof (szPath);
            szPath[0] = 0;

            if (RegQueryValueEx(
                    hKey,
                    gszLCRDLL,
                    0,
                    &dwDataType,
                    (LPBYTE) szPath,
                    &dwDataSize

                    ) == ERROR_SUCCESS)
            {
                //
                // Try to load the LCR DLL.
                //
                // Note that we will never explicitly free the DLL,
                // since there is no well-defined time at which we'd
                // know to free it.  (Apps can can lineTranslateAddress
                // without having done a lineInitialize(Ex), so that
                // could happen at any time between us being loaded
                // & unloaded, and doing Load/FreeLibrary from within
                // a DLLEntryPoint is not a good idea)
                //

                if ((hDll = LoadLibrary (szPath)))
                {
                    //
                    // Get the hook addresses & increment our own ref
                    // count (via LoadLibrary) so we'll never get
                    // unloaded (since we never unload the LCR DLL
                    // it might call back in to us at any time, & if
                    // an app unloaded us that would be a problem)
                    //

                    if (hDll)
                    {
                        (FARPROC) pfnLineOpenWLCR =  GetProcAddress(
                            hDll,
                            "lineOpenW"
                            );

                        (FARPROC) pfnLineOpenALCR =  GetProcAddress(
                            hDll,
                            "lineOpenA"
                            );

                        (FARPROC) pfnLineTranslateAddressWLCR = GetProcAddress(
                            hDll,
                            "lineTranslateAddressW"
                            );

                        if (pfnLineOpenWLCR ||
                            pfnLineOpenALCR ||
                            pfnLineTranslateAddressWLCR)
                        {
                            LoadLibrary (TEXT("tapi32"));

                            bEnabled = TRUE;
                        }
                    }
                }
                else
                {
                    LOG((TL_ERROR,
                        "IsLeastCostRoutingEnabled: LoadLibrary() " \
                            "failed, err=%d",
                        GetLastError()
                        ));
                }
            }

            RegCloseKey (hKey);
        }

        bInited = TRUE;
    }

    return bEnabled;
}


void
AsyncEventsThread(
    PASYNC_EVENTS_THREAD_PARAMS pAsyncEventsThreadParams
    );


void NonAsyncEventThread( void )
{
   if ( gpAsyncEventsThreadParams )
       AsyncEventsThread( (LPVOID) gpAsyncEventsThreadParams );
}


void
AsyncEventsThread(
    PASYNC_EVENTS_THREAD_PARAMS pAsyncEventsThreadParams
    )
{
    BOOL           *pbExitThread = &pAsyncEventsThreadParams->bExitThread,
                    bRetry;
    DWORD           dwBufSize    = pAsyncEventsThreadParams->dwBufSize;
    LPBYTE          pBuf         = pAsyncEventsThreadParams->pBuf;
    PTAPI32_MSG     pMsg         = (PTAPI32_MSG) pBuf;


    LOG((TL_TRACE, "AsyncEventsThread: enter"));


    //
    // Just loop reading async events/completions from server &
    // handling them
    //

    while (1)
    {
        DWORD           dwUsedSize, dwNeededSize;
        ASYNC_EVENT_PARAMS AsyncEventParams;
        PASYNCEVENTMSG  pAsyncEventMsg;

        //
        // Check to see if xxxShutdown or FreeClientResources
        // is signaling us to exit (we need to check both before
        // & after the wait to dela with a event setting/resetting
        // race condition between FreeClientResources & Tapisrv)
        //

        EnterCriticalSection (&gCriticalSection);

        if (*pbExitThread)
        {
            LeaveCriticalSection (&gCriticalSection);

            break;
        }


        //
        // Block until tapisrv signals us that it has some event data for us
        //

        LeaveCriticalSection (&gCriticalSection);
        {
            WaitForSingleObject (ghAsyncEventsEvent, INFINITE);
        }

        //
        // Check to see if xxxShutdown or FreeClientResources
        // is signaling us to exit
        //

        if (*pbExitThread)
        {
            break;
        }


        //
        // Retrieve the data from tapisrv
        //

AsyncEventsThread_clientRequest:

        do
        {
            pMsg->u.Req_Func     = xGetAsyncEvents;
            pMsg->Params[0]      = dwBufSize - sizeof (TAPI32_MSG);

            dwUsedSize = sizeof (TAPI32_MSG);

            RpcTryExcept
            {
                ClientRequest (gphCx, (char *) pMsg, dwBufSize, &dwUsedSize);
                bRetry = FALSE;
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                bRetry = !(*pbExitThread);
                LOG((TL_INFO,
                    "AsyncEventsThread: rpc exception %d handled",
                    RpcExceptionCode()
                    ));
                Sleep (10);
            }
            RpcEndExcept

        } while (bRetry);

#if DBG
        if (
              ( dwUsedSize > dwBufSize )
            ||
              ( pMsg->Params[2] > dwBufSize )
           )
        {
            LOG((TL_ERROR,  "OVERFLOW!!!"));

            LOG((TL_ERROR,  "Watch this..."));
            ClientFree( ClientAlloc( 0x10000 ) );
        }
#endif

        if ((dwUsedSize = (DWORD) pMsg->Params[2]) == 0 &&
            (dwNeededSize = (DWORD) pMsg->Params[1]) != 0)
        {
            //
            // There's a msg waiting for us that is bigger than our buffer,
            // so alloc a larger buffer & try again
            //

            LPBYTE  pNewBuf;


            LOG((TL_INFO,
                "AsyncEventsThread: allocating larger event buf (size=x%x)",
                dwNeededSize
                ));

            dwNeededSize += sizeof (TAPI32_MSG) + 128;

            if (!(pNewBuf = ClientAlloc (dwNeededSize)))
            {
                goto AsyncEventsThread_clientRequest;
            }

            dwBufSize = dwNeededSize;
            ClientFree (pBuf);
            pBuf = pNewBuf;
            pMsg = (PTAPI32_MSG) pBuf;
            goto AsyncEventsThread_clientRequest;
        }


        //
        // Handle the events
        //

        pAsyncEventMsg = (PASYNCEVENTMSG) (pBuf + sizeof (TAPI32_MSG));

        while (dwUsedSize)
        {
            PINIT_DATA  pInitData = (PINIT_DATA)ReferenceObject (ghHandleTable, pAsyncEventMsg->InitContext, INITDATA_KEY);

            if (NULL == pInitData)
            {
                // There is something very wrong with this
                // message. Skip to the next one.
                goto AsyncEventsThread_nextMessage;
            }

#ifdef _WIN64
            // For win64 we need to convert DWORDs to ULONG_PTRs (64 bit values)
            AsyncEventParams.hDevice            = pAsyncEventMsg->hDevice;
            AsyncEventParams.dwMsg              = pAsyncEventMsg->Msg;
            AsyncEventParams.dwCallbackInstance = pAsyncEventMsg->OpenContext;
            AsyncEventParams.dwParam1           = pAsyncEventMsg->Param1;
            AsyncEventParams.dwParam2           = pAsyncEventMsg->Param2;
            AsyncEventParams.dwParam3           = pAsyncEventMsg->Param3;
#else // not _WIN64
            CopyMemory (&AsyncEventParams.hDevice,
                        &pAsyncEventMsg->hDevice,
                        sizeof (ASYNC_EVENT_PARAMS));
#endif // _WIN64

            switch (pAsyncEventMsg->Msg)
            {
                case LINE_REMOVE:
                case PHONE_REMOVE:
                case LINE_CREATE:
                case LINE_REQUEST:
                case PHONE_CREATE:
                    // For all messages EXCEPT these, pAsyncEventMsg is a handle
                    // to the callbackInstance value passed in line/phoneOpen.
                    // For these messages, do nothing!
                    break;

                default:
                    // We need to get the CallbackInstance value back.
                    if (0 != pAsyncEventMsg->OpenContext)
                    {
                        AsyncEventParams.dwCallbackInstance = (ULONG_PTR)
                            ReferenceObject (ghHandleTable, pAsyncEventMsg->OpenContext, 0);
                        DereferenceObject (ghHandleTable, pAsyncEventMsg->OpenContext, 1);
                        if (LINE_CLOSE == pAsyncEventMsg->Msg ||
                            PHONE_CLOSE ==  pAsyncEventMsg->Msg)
                        {
                            // for these messages, we need to get rid of
                            // the handle to the callback instance, so
                            // dereference it once more.
                            DereferenceObject (ghHandleTable, pAsyncEventMsg->OpenContext, 1);
                        }
                    }

            }

            LOG((TL_INFO,
                "AsyncEventsThread: msg=%d, hDev=x%x, p1=x%x, p2=x%x, p3=x%x",
                AsyncEventParams.dwMsg,
                AsyncEventParams.hDevice,
                AsyncEventParams.dwParam1,
                AsyncEventParams.dwParam2,
                AsyncEventParams.dwParam3
                ));

            //
            // Special case for UI msgs (not fwd'd to client)
            //

            switch (pAsyncEventMsg->Msg)
            {
            case LINE_CREATEDIALOGINSTANCE:
            {
                DWORD           dwThreadID,
                                dwDataOffset = pAsyncEventMsg->Param1,
                                dwDataSize   = pAsyncEventMsg->Param2,
                                dwUIDllNameOffset = pAsyncEventMsg->Param3;
                PUITHREADDATA   pUIThreadData;


                if (!(pUIThreadData = ClientAlloc (sizeof (UITHREADDATA))))
                {
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if ((pUIThreadData->dwSize = dwDataSize) != 0)
                {
                    if (!(pUIThreadData->pParams = ClientAlloc (dwDataSize)))
                    {
                        goto LINE_CREATEDIALOGINSTANCE_error;
                    }

                    CopyMemory(
                        pUIThreadData->pParams,
                        ((LPBYTE)pAsyncEventMsg) + dwDataOffset,
                        dwDataSize
                        );
                }

                if (!(pUIThreadData->hUIDll = TAPILoadLibraryW(
                        (PWSTR)(((LPBYTE) pAsyncEventMsg) +
                                  dwUIDllNameOffset)
                        )))
                {
                    LOG((TL_ERROR,
                        "LoadLibraryW(%ls) failed, err=%d",
                        ((LPBYTE)pAsyncEventMsg + dwUIDllNameOffset),
                        GetLastError()
                        ));

                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if (!(pUIThreadData->pfnTUISPI_providerGenericDialog =
                        (TUISPIPROC) GetProcAddress(
                            pUIThreadData->hUIDll,
                            (LPCSTR) gszTUISPI_providerGenericDialog
                            )))
                {
                    LOG((TL_ERROR,
                        "GetProcAddr(TUISPI_providerGenericDialog) failed"
                        ));

                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                pUIThreadData->pfnTUISPI_providerGenericDialogData =
                    (TUISPIPROC) GetProcAddress(
                        pUIThreadData->hUIDll,
                        (LPCSTR) gszTUISPI_providerGenericDialogData
                        );

                if (!(pUIThreadData->hEvent = CreateEvent(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        TRUE,   // manual reset
                        FALSE,  // non-signaled
                        NULL    // unnamed
                        )))
                {
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                pUIThreadData->htDlgInst = (HTAPIDIALOGINSTANCE)
                    pAsyncEventMsg->hDevice;


                //
                // Safely add this instance to the global list
                // (check if gdwNumInits == 0, & if so fail)
                //

                EnterCriticalSection (&gCriticalSection);

                if (gdwNumInits != 0)
                {
                    if ((pUIThreadData->pNext = gpUIThreadInstances))
                    {
                        pUIThreadData->pNext->pPrev = pUIThreadData;
                    }

                    gpUIThreadInstances  = pUIThreadData;
                    LeaveCriticalSection (&gCriticalSection);
                }
                else
                {
                    LeaveCriticalSection (&gCriticalSection);
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if ((pUIThreadData->hThread = CreateThread(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) UIThread,
                        (LPVOID) pUIThreadData,
                        0,
                        &dwThreadID
                        )))
                {
                    goto AsyncEventsThread_decrUsedSize;
                }


                //
                // If here an error occured, so safely remove the ui
                // thread data struct from the global list
                //

                EnterCriticalSection (&gCriticalSection);

                if (pUIThreadData->pNext)
                {
                    pUIThreadData->pNext->pPrev = pUIThreadData->pPrev;
                }

                if (pUIThreadData->pPrev)
                {
                    pUIThreadData->pPrev->pNext = pUIThreadData->pNext;
                }
                else
                {
                    gpUIThreadInstances = pUIThreadData->pNext;
                }

                LeaveCriticalSection (&gCriticalSection);


LINE_CREATEDIALOGINSTANCE_error:

                if (pUIThreadData)
                {
                    if (pUIThreadData->pParams)
                    {
                        ClientFree (pUIThreadData->pParams);
                    }

                    if (pUIThreadData->hUIDll)
                    {
                        FreeLibrary (pUIThreadData->hUIDll);
                    }

                    if (pUIThreadData->hEvent)
                    {
                        CloseHandle (pUIThreadData->hEvent);
                    }

                    ClientFree (pUIThreadData);
                }

                {
                    FUNC_ARGS funcArgs =
                    {
                        MAKELONG (LINE_FUNC | SYNC | 1, xFreeDialogInstance),

                        {
                            (DWORD) pAsyncEventMsg->hDevice
                        },

                        {
                            Dword
                        }
                    };


                    DOFUNC (&funcArgs, "FreeDialogInstance");
                }

                goto AsyncEventsThread_decrUsedSize;
            }
            case LINE_SENDDIALOGINSTANCEDATA:
            {
                PUITHREADDATA       pUIThreadData = gpUIThreadInstances;
                HTAPIDIALOGINSTANCE htDlgInst = (HTAPIDIALOGINSTANCE)
                                        pAsyncEventMsg->hDevice;


                EnterCriticalSection (&gCriticalSection);

                while (pUIThreadData)
                {
                    if (pUIThreadData->htDlgInst == htDlgInst)
                    {
                        WaitForSingleObject (pUIThreadData->hEvent, INFINITE);

                        (*pUIThreadData->pfnTUISPI_providerGenericDialogData)(
                            htDlgInst,
                            ((LPBYTE) pAsyncEventMsg) +
                                pAsyncEventMsg->Param1,     // data offset
                            pAsyncEventMsg->Param2          // data size
                            );

                        break;
                    }

                    pUIThreadData = pUIThreadData->pNext;
                }

                LeaveCriticalSection (&gCriticalSection);

                goto AsyncEventsThread_decrUsedSize;
            }
            }

            //
            // Enter the critical section so we've exclusive access
            // to the init data, & verify it
            //

            EnterCriticalSection (&gCriticalSection);

            try
            {
#if defined(_M_IX86) && _MSC_FULL_VER <= 13008806

                  DWORD dw= pInitData->dwKey;        // workaround compiler bug.

                  if (dw != INITDATA_KEY)

#else
                if (pInitData->dwKey != INITDATA_KEY)
#endif
                {
                    LOG((TL_ERROR, "Bad pInitInst, discarding msg"));
                    goto AsyncEventsThread_leaveCritSec;
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                goto AsyncEventsThread_leaveCritSec;
            }


            //
            // Special case for PROXYREQUEST
            //

            if (pAsyncEventMsg->Msg == LINE_PROXYREQUEST)
            {
                PPROXYREQUESTHEADER     pProxyRequestHeader;
                LPLINEPROXYREQUEST      pProxyRequest = (LPLINEPROXYREQUEST)
                                            (pAsyncEventMsg + 1),
                                        pProxyRequestApp;


                switch (pProxyRequest->dwRequestType)
                {
                    case LINEPROXYREQUEST_SETAGENTGROUP:
                    case LINEPROXYREQUEST_SETAGENTSTATE:
                    case LINEPROXYREQUEST_SETAGENTACTIVITY:
                    case LINEPROXYREQUEST_AGENTSPECIFIC:
                    case LINEPROXYREQUEST_CREATEAGENT:
                    case LINEPROXYREQUEST_CREATEAGENTSESSION:
                    case LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD:
                    case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
                    case LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD:
                    case LINEPROXYREQUEST_SETAGENTSTATEEX:

                        //
                        // For these msgs the proxy request as received from
                        // the tapisrv already contains the exact bits we want
                        // to pass on to the app, so we just alloc a buffer of
                        // the same size (plus a little extra for the key at
                        // the head of the buffer) and copy the data to it
                        //

                        if (!(pProxyRequestHeader = ClientAlloc(
                                sizeof (PROXYREQUESTHEADER) + pProxyRequest->dwSize
                                )))
                        {
                            // Could not allocate memory;
                            // skip this...
                            goto AsyncEventsThread_leaveCritSec;
                        }

                        pProxyRequestApp = (LPLINEPROXYREQUEST)
                            (pProxyRequestHeader + 1);

                        CopyMemory(
                            pProxyRequestApp,
                            pProxyRequest,
                            pProxyRequest->dwSize
                            );

                        break;

                    case LINEPROXYREQUEST_GETAGENTCAPS:
                    case LINEPROXYREQUEST_GETAGENTSTATUS:
                    case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
                    case LINEPROXYREQUEST_GETAGENTGROUPLIST:
                    case LINEPROXYREQUEST_GETQUEUEINFO:
                    case LINEPROXYREQUEST_GETGROUPLIST:
                    case LINEPROXYREQUEST_GETQUEUELIST:
                    case LINEPROXYREQUEST_GETAGENTINFO:
                    case LINEPROXYREQUEST_GETAGENTSESSIONINFO:
                    case LINEPROXYREQUEST_GETAGENTSESSIONLIST:
                    {
                        DWORD dwSizeToCopy = 0;

                        //
                        // For these msgs tapisrv only embedded the dwTotalSize
                        // field of the corresponding structure (to save having
                        // to send us a bunch of unused bits), so we want to
                        // increase the pProxyRequest->dwSize by the dwTotalSize
                        // - sizeof (DWORD), alloc a buffer (including a little
                        // extra space for the key at the head of the buffer),
                        // and rebuild the request
                        //

                        if ( pProxyRequest->dwRequestType ==
                             LINEPROXYREQUEST_GETGROUPLIST )
                        {
                            pProxyRequest->dwSize +=
                                  (pProxyRequest->GetGroupList.GroupList.dwTotalSize)&TALIGN_MASK;

                            dwSizeToCopy = 8 * sizeof(DWORD);
                        }
                        else if ( pProxyRequest->dwRequestType ==
                             LINEPROXYREQUEST_GETQUEUELIST )
                        {
                            pProxyRequest->dwSize +=
                                  (pProxyRequest->GetQueueList.QueueList.dwTotalSize)&TALIGN_MASK;

                            dwSizeToCopy = 8 * sizeof(DWORD) + sizeof(GUID);
                        }
                        else
                        {
                            //
                            // all of the rest of the structures have the
                            // same format
                            //
                            pProxyRequest->dwSize +=
                                  (pProxyRequest->GetAgentCaps.AgentCaps.dwTotalSize)&TALIGN_MASK;

                            dwSizeToCopy = 9 * sizeof(DWORD);
                        }

                        if (!(pProxyRequestHeader = ClientAlloc(
                            sizeof (PROXYREQUESTHEADER) + pProxyRequest->dwSize
                            + sizeof(DWORD) + sizeof(DWORD)
                            )))
                        {
                            // Could not allocate memory;
                            // skip this...
                            goto AsyncEventsThread_leaveCritSec;
                        }

                        pProxyRequestApp = (LPLINEPROXYREQUEST)
                            (pProxyRequestHeader + 1);


                        //
                        // The following will copy the non-union fields in the
                        // proxy message, as well as the first two DWORD in the
                        // union (which currently are the dwAddressID and the
                        // dwTotalSize field of the corresponding structure)
                        //

                        CopyMemory(
                            pProxyRequestApp,
                            pProxyRequest,
                            dwSizeToCopy
                            );

                        //
                        // Relocate the machine & user names to the end of the
                        // structure
                        //

                        pProxyRequestApp->dwClientMachineNameOffset =
                            pProxyRequest->dwSize -
                                pProxyRequest->dwClientMachineNameSize;

                        wcscpy(
                            (WCHAR *)(((LPBYTE) pProxyRequestApp) +
                                pProxyRequestApp->dwClientMachineNameOffset),
                            (WCHAR *)(((LPBYTE) pProxyRequest) +
                                pProxyRequest->dwClientMachineNameOffset)
                            );

                        pProxyRequestApp->dwClientUserNameOffset =
                            pProxyRequestApp->dwClientMachineNameOffset -
                                pProxyRequest->dwClientUserNameSize;

                        wcscpy(
                            (WCHAR *)(((LPBYTE) pProxyRequestApp) +
                                pProxyRequestApp->dwClientUserNameOffset),
                            (WCHAR *)(((LPBYTE) pProxyRequest) +
                                pProxyRequest->dwClientUserNameOffset)
                            );

                        break;
                    }
                }

                pProxyRequestHeader->dwKey      = TPROXYREQUESTHEADER_KEY;
                pProxyRequestHeader->dwInstance = pAsyncEventMsg->Param1;

                AsyncEventParams.dwParam1 = (ULONG_PTR) pProxyRequestApp;
            }

            //
            // Call the post processing proc if there is one
            //

            if (pAsyncEventMsg->fnPostProcessProcHandle)
            {

                (*(gPostProcessingFunctions[
                    pAsyncEventMsg->fnPostProcessProcHandle]))(pAsyncEventMsg);
            }


            //
            // If this init instance is using a completion port then
            // alloc msg struct & post the msg to the completion port,
            // then jump down below to exit the critsec, etc
            //

            if ((pInitData->dwInitOptions & 0x3) ==
                    LINEINITIALIZEEXOPTION_USECOMPLETIONPORT)
            {
             LPLINEMESSAGE pMsg;

                if ((pMsg = LocalAlloc (LMEM_FIXED, sizeof(LINEMESSAGE))))
                {
                    CopyMemory (pMsg, &AsyncEventParams, sizeof(LINEMESSAGE));

                    if (gpPostQueuedCompletionStatus &&
                        !gpPostQueuedCompletionStatus(
                            pInitData->hCompletionPort,
                            sizeof (LINEMESSAGE),
                            pInitData->dwCompletionKey,
                            (LPOVERLAPPED) pMsg
                            ))
                    {
                        LocalFree (pMsg);
                        LOG((TL_ERROR,
                            "AsyncEventsThread: PostQueuedCompletionStatus " \
                                "failed, err=%d",
                            GetLastError()
                            ));
                    }
                    else
                    {
                        LOG((TL_INFO,
                            "AsyncEventsThread: posted complPort msg\n",
                                "\thDev=x%x, ctx=x%x, p1=x%x, p2=x%x, p3=x%x",
                            AsyncEventParams.hDevice,
                            AsyncEventParams.dwCallbackInstance,
                            AsyncEventParams.dwParam1,
                            AsyncEventParams.dwParam2,
                            AsyncEventParams.dwParam3
                            ));
                    }
                }

                goto AsyncEventsThread_leaveCritSec;
            }


            //
            // See if we need to increase the msg queue size, and if
            // so alloc a new buf, copy the existing msgs over (careful
            // to preserve order in a wrapped buffer), free the old buf
            // and reset the appropriate fields in the init data struct
            //

            if (pInitData->dwNumTotalEntries ==
                    pInitData->dwNumUsedEntries)
            {
                DWORD               dwNumTotalEntries =
                                        pInitData->dwNumTotalEntries;
                PASYNC_EVENT_PARAMS pNewEventBuffer;


                if ((pNewEventBuffer = ClientAlloc(
                        2 * dwNumTotalEntries * sizeof (ASYNC_EVENT_PARAMS)
                        )))
                {
                    DWORD   dwNumWrappedEntries = (DWORD)
                                (pInitData->pValidEntry -
                                    pInitData->pEventBuffer);


                    CopyMemory(
                        pNewEventBuffer,
                        pInitData->pValidEntry,
                        (dwNumTotalEntries - dwNumWrappedEntries)
                            * sizeof (ASYNC_EVENT_PARAMS)
                        );

                    if (dwNumWrappedEntries)
                    {
                        CopyMemory(
                            pNewEventBuffer +
                                (dwNumTotalEntries - dwNumWrappedEntries),
                            pInitData->pEventBuffer,
                            dwNumWrappedEntries * sizeof (ASYNC_EVENT_PARAMS)
                            );
                    }

                    ClientFree (pInitData->pEventBuffer);

                    pInitData->pEventBuffer =
                    pInitData->pValidEntry  = pNewEventBuffer;
                    pInitData->pFreeEntry   =
                        pNewEventBuffer + dwNumTotalEntries;

                    pInitData->dwNumTotalEntries *= 2;
                }
                else
                {
                    // Could not allocate memory,
                    // skip this message...
                    goto AsyncEventsThread_leaveCritSec;
                }
            }


            //
            // Copy the msg to the hidden window's msg queue,
            // and update that queue's pointers
            //

            CopyMemory(
                pInitData->pFreeEntry,
                &AsyncEventParams,
                sizeof (ASYNC_EVENT_PARAMS)
                );

            pInitData->dwNumUsedEntries++;

            pInitData->pFreeEntry++;

            if (pInitData->pFreeEntry >= (pInitData->pEventBuffer +
                    pInitData->dwNumTotalEntries))
            {
                pInitData->pFreeEntry = pInitData->pEventBuffer;
            }


            //
            // If this init instance is using events for msg notification
            // then see if we need to signal the app that there's an
            // event waiting for it
            //
            // Else, post a msg to the hidden window (if there's not
            // already one outstanding) to alert it that there's some
            // events it needs to pass on to the app's callback
            //

            if ((pInitData->dwInitOptions & 0x3)
                    == LINEINITIALIZEEXOPTION_USEEVENT)
            {
                if (pInitData->dwNumUsedEntries > 0)
                {
                    SetEvent (pInitData->hEvent);
                }
            }
            else // HIDDENWINDOW
            {
                if (pInitData->bPendingAsyncEventMsg == FALSE)
                {
                    LOG((TL_INFO,
                        "AsyncEventsThread: posting msg, hwnd=x%lx",
                        pInitData->hwnd
                        ));

                    PostMessage(
                        pInitData->hwnd,
                        WM_ASYNCEVENT,
                        0,
                        (LPARAM) pInitData
                        );

                    pInitData->bPendingAsyncEventMsg = TRUE;
                }
            }

AsyncEventsThread_leaveCritSec:

            LeaveCriticalSection (&gCriticalSection);

AsyncEventsThread_decrUsedSize:

            DereferenceObject (ghHandleTable, pAsyncEventMsg->InitContext, 1);

AsyncEventsThread_nextMessage:
            dwUsedSize -= (DWORD) pAsyncEventMsg->TotalSize;

            pAsyncEventMsg = (PASYNCEVENTMSG)
                ((LPBYTE) pAsyncEventMsg + pAsyncEventMsg->TotalSize);

            if ( (LONG)dwUsedSize < 0 )
            {
                LOG((TL_ERROR, "dwUsedSize went negative!!!"));
            }
        }
    }

    {
        //
        // Free our resources, and then exit
        //

        HANDLE  hTapi32 = pAsyncEventsThreadParams->hTapi32;


        if (pAsyncEventsThreadParams->hWow32)
        {
            FreeLibrary (pAsyncEventsThreadParams->hWow32);
        }

        ClientFree (pBuf);
        ClientFree (pAsyncEventsThreadParams);

        LOG((TL_TRACE, "AsyncEventsThread: exit"));

        FreeLibraryAndExitThread (hTapi32, 0);
    }
}


BOOL
PASCAL
IsBadDwordPtr(
    LPDWORD p
    )
{
    //
    // Since IsBadWritePtr won't tell us if "p" is not DWORD-aligned (an
    // issue on non-x86 platforms), we use the following to determine
    // if the pointer is good.  Note that DWORD p points at will get
    // overwritten on successful completion of the request anyway, so
    // preserving the original value is not important.
    //

    DWORD dwError;
    BOOL  bRet = FALSE;


    try
    {
        *p = *p + 1;
        *p = *p - 1;
    }
    except ((((dwError = GetExceptionCode()) == EXCEPTION_ACCESS_VIOLATION) ||
             dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        bRet = TRUE;
    }


    return bRet;
}


BOOL
WINAPI
GrowBuf(
    LPBYTE *ppBuf,
    LPDWORD pdwBufSize,
    DWORD   dwCurrValidBytes,
    DWORD   dwBytesToAdd
    )
{
    DWORD   dwCurrBufSize, dwNewBufSize;
    LPBYTE  pNewBuf;


    //
    // Try to get a new buffer big enough to hold everything
    //

    for(
        dwNewBufSize = 2 * (dwCurrBufSize = *pdwBufSize);
        dwNewBufSize < (dwCurrBufSize + dwBytesToAdd);
        dwNewBufSize *= 2
        );

    if (!(pNewBuf = ClientAlloc (dwNewBufSize)))
    {
        return FALSE;
    }


    //
    // Copy the "valid" bytes in the old buf to the new buf,
    // then free the old buf
    //

    CopyMemory (pNewBuf, *ppBuf, dwCurrValidBytes);

    ClientFree (*ppBuf);


    //
    // Reset the pointers to the new buf & buf size
    //

    *ppBuf = pNewBuf;
    *pdwBufSize = dwNewBufSize;

    return TRUE;
}


PCLIENT_THREAD_INFO
WINAPI
GetTls(
    void
    )
{
    PCLIENT_THREAD_INFO pClientThreadInfo;


    if (!(pClientThreadInfo = TlsGetValue (gdwTlsIndex)))
    {
        pClientThreadInfo = (PCLIENT_THREAD_INFO)
            ClientAlloc (sizeof(CLIENT_THREAD_INFO));

        if (!pClientThreadInfo)
        {
            return NULL;
        }

        pClientThreadInfo->pBuf = ClientAlloc (INITIAL_CLIENT_THREAD_BUF_SIZE);

        if (!pClientThreadInfo->pBuf)
        {
            ClientFree (pClientThreadInfo);

            return NULL;
        }

        pClientThreadInfo->dwBufSize = INITIAL_CLIENT_THREAD_BUF_SIZE;

        TlsSetValue (gdwTlsIndex, (LPVOID) pClientThreadInfo);

        EnterCriticalSection (&gTlsCriticalSection);

        InsertHeadList (&gTlsListHead, &pClientThreadInfo->TlsList);

        LeaveCriticalSection (&gTlsCriticalSection);
    }

    return pClientThreadInfo;
}

PCONTEXT_HANDLE_TYPE
WINAPI
GetTlsPCtxHandle(
    void
    )
{
    return TlsGetValue (gdwTlsIndexRpcCtx);
}

BOOL
WINAPI
SetTlsPCtxHandle(
    PCONTEXT_HANDLE_TYPE phCtxHandle
    )
{
    return TlsSetValue(gdwTlsIndexRpcCtx, phCtxHandle);
}

#if DBG

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    )

#else

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    )

#endif
{
    DWORD       dwFuncClassErrorIndex = (pFuncArgs->Flags & 0x00000030) >> 4;
    LONG        lResult;
    BOOL        bCopyOnSuccess = FALSE;
    BOOL        bResAllocated = FALSE;
    DWORD       i, j, dwUsedSize, dwNeededSize;
    ULONG_PTR   value;
    PCONTEXT_HANDLE_TYPE    phCtx;


    PCLIENT_THREAD_INFO pTls;

#if DBG
    LOG((TL_TRACE, "About to call %hs", pszFuncName));
#else
    LOG((TL_TRACE, "DoFunc  -- enter"));
#endif
    //
    // Check to make sure resources allocated
    // (TAPISRV started, pipes opened, etc.)
    //

    if ( (lResult = AllocClientResources (dwFuncClassErrorIndex))
            != TAPI_SUCCESS)
    {
        goto DoFunc_return;
    }

    bResAllocated = TRUE;

    //
    // Get the tls
    //

    if (!(pTls = GetTls()))
    {
        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
        goto DoFunc_return;
    }


    //
    // The first arg of all async msg blocks is a remote request id; set
    // this to zero to indicate that we are a local client (not remotesp)
    //

    if (pFuncArgs->Flags & ASYNC)
    {
        ((PTAPI32_MSG) pTls->pBuf)->Params[0] = 0;
    }


    //
    // Validate all the func args
    //

    dwNeededSize = dwUsedSize = ALIGN(sizeof (TAPI32_MSG));

    for(
        i = 0, j = (pFuncArgs->Flags & ASYNC ? 1 : 0);
        i < (pFuncArgs->Flags & NUM_ARGS_MASK);
        i++, j++
        )
    {
        value = /*((PTAPI32_MSG) pTls->pBuf)->Params[j] =*/ pFuncArgs->Args[i];

        switch (pFuncArgs->ArgTypes[i])
        {
        case Dword:

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__);
            continue;

        case hXxxApp_NULLOK:
        case hXxxApp:
        {
            //
            // Verify that the hXxxApp is a pointer to a valid InitData
            // struct, then retrieve the real hXxxApp from that struct.
            // If the hXxxApp is bad, pass the server 0xffffffff so that
            // it can figure out whether to return an UNINITIALIZED error
            // or a INVALAPPHANDLE error.
            //

            DWORD       dwError;
            PINIT_DATA  pInitData;


            if ((0 == pFuncArgs->Args[i])   &&
                (hXxxApp_NULLOK == pFuncArgs->ArgTypes[i]))
            {
                //
                // Looks good to me...
                //
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0;
                continue;
            }

            if ((pInitData = (PINIT_DATA) ReferenceObject(
                    ghHandleTable,
                    DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__),
                    INITDATA_KEY
                    )))
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pInitData->hXxxApp;

                DereferenceObject (ghHandleTable, DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__), 1);
            }
            else
            {
                //
                // Fill in with a bogus hXxxApp so tapisrv can decide which
                // error it wants to return
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0xffffffff;
            }

            continue;
        }

        case Hwnd:

            if (!IsWindow ((HWND) value))
            {
                LOG((TL_ERROR, "Bad hWnd in dofunc"));
                lResult = gaInvalHwndErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            // The only functions that pass in Hwnd are
            // tapiRequestDrop and tapiRequestMediaCall;
            // both of these are non functional on the server side
            // (correctly noted by the documentation). Parameters
            // are not checked. Simply passing in 0 for the Hwnd will
            // not affect functionality in any way, and will save a lot
            // of grief coming from the 32 / 64 bit conversions (hwnd are
            // 64 bits on 64 bit system, and the params we're using over
            // the wire are only 32 bits).
            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0;
            continue;


        case lpDword:

            if (IsBadDwordPtr ((LPDWORD) value))
            {
                LOG((TL_ERROR, "Bad lpdword in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            bCopyOnSuccess = TRUE;

            continue;


        case lpszW:

            //
            // Check if value is a valid string ptr and if so
            // copy the contents of the string to the extra data
            // buffer passed to the server
            //

            try
            {
                DWORD   n = (lstrlenW((WCHAR *) value) + 1) * sizeof(WCHAR),
                        nAligned = ALIGN(n);


                if ((nAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            nAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto DoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, n);


                //
                // Pass the server the offset of the string in the var data
                // portion of the buffer
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);


                //
                // Increment the total number of data bytes
                //

                dwUsedSize   += nAligned;
                dwNeededSize += nAligned;
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            continue;

        case lpGet_Struct:
        case lpGet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpGet_SizeToFollow);
            DWORD dwSize;


            if (bSizeToFollow)
            {
#if DBG
                //
                // Check to make sure the following arg is of type Size
                //

                if ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                    (pFuncArgs->ArgTypes[i + 1] != Size))
                {
                    LOG((TL_ERROR,
                        "DoFunc: error, lpGet_SizeToFollow !followed by Size"
                        ));

                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }
#endif
                dwSize = DWORD_CAST(pFuncArgs->Args[i + 1],__FILE__,__LINE__);
            }
            else
            {
                DWORD   dwError;

                try
                {
                    dwSize = *((LPDWORD) value);
                }
                except ((((dwError = GetExceptionCode())
                            == EXCEPTION_ACCESS_VIOLATION) ||
                         dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    LOG((TL_ERROR, "Bad get struct/size in dofunc"));
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

            }

            if (IsBadWritePtr ((LPVOID) value, dwSize))
            {
                LOG((TL_ERROR, "Bad get size/struct2 in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            if (bSizeToFollow)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
                ++j;++i;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = dwSize;
            }


            //
            // Now set the bCopyOnSuccess flag to indicate that we've data
            // to copy back on successful completion, and add to the
            // dwNeededSize field
            //

            bCopyOnSuccess = TRUE;

            dwNeededSize += ALIGN(dwSize);

            continue;
        }
        case lpSet_Struct:
        case lpSet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpSet_SizeToFollow);
            DWORD dwSize, dwError, dwSizeAligned;

#if DBG
            //
            // Check to make sure the following arg is of type Size
            //

            if (bSizeToFollow &&
                ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                (pFuncArgs->ArgTypes[i + 1] != Size)))
            {
                LOG((TL_ERROR,
                    "DoFunc: error, lpSet_SizeToFollow !followed by Size"
                    ));

                lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }
#endif
            try
            {
                //
                // First determine the data size & if the ptr is bad
                //

                dwSize = (bSizeToFollow ? DWORD_CAST(pFuncArgs->Args[i + 1],__FILE__,__LINE__) :
                     *((LPDWORD) value));

                if (IsBadReadPtr ((LPVOID) value, dwSize))
                {
                    LOG((TL_ERROR, "Bad set size/struct in dofunc"));
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                dwSizeAligned = ALIGN(dwSize);


                //
                // Special case if the size isn't even big enough to pass
                // over a complete DWORD for the dwTotalSize field
                //

                if (!bSizeToFollow && (dwSize < sizeof (DWORD)))
                {
                      static DWORD dwZeroTotalSize = 0;


                      dwSize = dwSizeAligned = sizeof (DWORD);
                      value = (ULONG_PTR) &dwZeroTotalSize;

//                    LOG((TL_ERROR, TEXT("Bad set size/struct2 in dofunc")));
//                    lResult = gaStructTooSmallErrors[dwFuncClassErrorIndex];
//                    goto DoFunc_return;
                }


                //
                // Grow the buffer if necessary, & do the copy
                //

                if ((dwSizeAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            dwSizeAligned
                            ))
                    {
                        LOG((TL_ERROR, "Nomem set size/struct in dofunc"));
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto DoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, dwSize);
            }
            except ((((dwError = GetExceptionCode())
                        == EXCEPTION_ACCESS_VIOLATION) ||
                     dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                LOG((TL_ERROR, "Bad pointer in get size/struct in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            //
            // Pass the server the offset of the data in the var data
            // portion of the buffer
            //

            if (dwSize)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }


            //
            // Increment the dwXxxSize vars appropriately
            //

            dwUsedSize   += dwSizeAligned;
            dwNeededSize += dwSizeAligned;


            //
            // Since we already know the next arg (Size) just handle
            // it here so we don't have to run thru the loop again
            //

            if (bSizeToFollow)
            {
                ++i;++j;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__);
            }

            continue;
        }
#if DBG
        case Size:

            LOG((TL_ERROR, "DoFunc: error, hit case Size"));

            continue;

        default:

            LOG((TL_ERROR, "DoFunc: error, unknown arg type"));

            continue;
#endif
        } // switch

    } // for


    //
    // Now make the request
    //

    if (dwNeededSize > pTls->dwBufSize)
    {
        if (!GrowBuf(
                &pTls->pBuf,
                &pTls->dwBufSize,
                dwUsedSize,
                dwNeededSize - pTls->dwBufSize
                ))
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto DoFunc_return;
        }
    }

    ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func = (DWORD)HIWORD(pFuncArgs->Flags);

    {
        DWORD   dwRetryCount = 0;
        BOOL    bReinitResource;
        PCONTEXT_HANDLE_TYPE    phCtxTmp = GetTlsPCtxHandle();

        do
        {
            phCtx = (phCtxTmp != NULL)?phCtxTmp : gphCx;
            bReinitResource = FALSE;
            RpcTryExcept
            {
                ClientRequest (phCtx, pTls->pBuf, dwNeededSize, &dwUsedSize);
                lResult = (LONG) ((PTAPI32_MSG) pTls->pBuf)->u.Ack_ReturnValue;
                if (lResult == TAPIERR_INVALRPCCONTEXT)
                {
                    if (dwRetryCount ++ >= gdwMaxNumRequestRetries)
                    {
                        bReinitResource = FALSE;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                        dwRetryCount = 0;
                    }
                    else
                    {
                        ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func =
                            (DWORD)HIWORD(pFuncArgs->Flags);
                        bReinitResource = TRUE;
                    }
                }
                else
                {
                    bReinitResource = FALSE;
                    dwRetryCount = 0;
                }
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                unsigned long rpcException = RpcExceptionCode();

                if (rpcException == RPC_S_SERVER_TOO_BUSY)
                {
                    if (dwRetryCount++ < gdwMaxNumRequestRetries)
                    {
                        Sleep (gdwRequestRetryTimeout);
                    }
                    else
                    {
                        dwRetryCount = 0;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    }
                }
                else if ((rpcException == RPC_S_SERVER_UNAVAILABLE) ||
                         (rpcException == RPC_S_CALL_FAILED_DNE) ||
                         (rpcException == RPC_S_UNKNOWN_IF))
                {
                    if (dwRetryCount ++ >= gdwMaxNumRequestRetries)
                    {
                        bReinitResource = FALSE;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                        dwRetryCount = 0;
                    }
                    else
                    {
                        bReinitResource = TRUE;
                    }
                }
                else
                {
                    LOG((TL_ERROR, "DoFunc: rpcException # %d", rpcException));
                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    dwRetryCount = 0;
                }
            }
            RpcEndExcept

            if (bReinitResource)
            {
                if (ReAllocClientResources(dwFuncClassErrorIndex) != TAPI_SUCCESS)
                {
                    LOG((TL_ERROR, "DoFunc: ReAllocClientResources failed"));
                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    dwRetryCount = 0;
                    bResAllocated = FALSE;
                }
            }
        } while (dwRetryCount != 0);
    }

// note: 99.99% of the time this result dump will == the one at end of the
// func (only when ptrs have gone bad will the result differ), no reason
// to dump 2x unless doing internal dbgging
//
    LOG((TL_TRACE, "DoFunc: back from srv- return code=0x%08lx", lResult));


    //
    // If request completed successfully and the bCopyOnSuccess flag
    // is set then we need to copy data back to client buffer(s)
    //

    if ((lResult == TAPI_SUCCESS) && bCopyOnSuccess)
    {
        for (i = 0, j = 0; i < (pFuncArgs->Flags & NUM_ARGS_MASK); i++, j++)
        {
            PTAPI32_MSG pMsg = (PTAPI32_MSG) pTls->pBuf;


            switch (pFuncArgs->ArgTypes[i])
            {
            case Dword:
            case Hwnd:
//            case lpsz:
            case lpszW:
            case lpSet_Struct:

                continue;

            case lpDword:

                try
                {
                    //
                    // Fill in the pointer with the return value
                    //

                    *((LPDWORD) pFuncArgs->Args[i]) = (DWORD) pMsg->Params[j];
                }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                continue;

            case lpGet_SizeToFollow:

                try
                {
                    //
                    // Fill in the pointer with the return value
                    //

                    CopyMemory(
                        (LPBYTE) pFuncArgs->Args[i],
                        pTls->pBuf + (DWORD)pMsg->Params[j] + sizeof(TAPI32_MSG),
                        pMsg->Params[j+1]
                        );
                }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }


                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpSet_SizeToFollow:

                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpGet_Struct:

                try
                {
                    //
                    // Params[j] contains the offset in the var data
                    // portion of pTls->pBuf of some TAPI struct.
                    // Get the dwUsedSize value from this struct &
                    // copy that many bytes from pTls->pBuf to client buf
                    //

                    if ((DWORD)pMsg->Params[j] != TAPI_NO_DATA)
                    {

                        LPDWORD pStruct;


                        pStruct = (LPDWORD) (pTls->pBuf + sizeof(TAPI32_MSG) +
                            (DWORD)pMsg->Params[j]);

                        CopyMemory(
                            (LPBYTE) pFuncArgs->Args[i],
                            (LPBYTE) pStruct,
                            *(pStruct + 2)      // ptr to dwUsedSize field
                            );
                    }
                }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                continue;

            default:

                continue;
            }
        }
    }



DoFunc_return:

    if (bResAllocated)
    {
        FreeClientResources();
    }

#if DBG
    {
        char szResult[32];

        LOG((TL_TRACE,
            "%hs: result = %hs",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "DoFunc: result = x%x",
            lResult
            ));
#endif

    return lResult;
}


LONG
LoadUIDll(
    HWND        hwndOwner,
    DWORD       dwWidgetID,
    DWORD       dwWidgetType,
    HANDLE     *phDll,
    LPCSTR      pszTUISPI_xxx,      // use for GetProcAddress, leave as ANSI
    TUISPIPROC *ppfnTUISPI_xxx
    )
{
    LONG    lResult;
    HANDLE  hDll = NULL;
    WCHAR   szUIDllName[MAX_PATH];
    HANDLE  hProvidersMutex;
    
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, xGetUIDllName),

        {
            (ULONG_PTR) dwWidgetID,
            (ULONG_PTR) dwWidgetType,
            (ULONG_PTR) szUIDllName,
            (ULONG_PTR) MAX_PATH
        },

        {
            Dword,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (hwndOwner && !IsWindow (hwndOwner))
    {
       lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
           PHONEERR_INVALPARAM : LINEERR_INVALPARAM);

       goto LoadUIDll_return;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );

    if (NULL == hProvidersMutex)
    {
        lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
           PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);

        goto LoadUIDll_return;
    }
    
    WaitForSingleObject (hProvidersMutex, INFINITE);
        
    if ((lResult = DOFUNC (&funcArgs, "GetUIDllName")) == 0)
    {
        if (hDll = TAPILoadLibraryW(szUIDllName))
        {
            if ((*ppfnTUISPI_xxx = (TUISPIPROC) GetProcAddress(
                hDll,
                pszTUISPI_xxx
                )))
            {
                *phDll = hDll;
                lResult = 0;
            }
            else
            {
                LOG((TL_ERROR,
                        "LoadUIDll: GetProcAddress(%ls,%hs) failed, err=%d",
                        szUIDllName,
                        pszTUISPI_xxx,
                        GetLastError()
                       ));

                FreeLibrary (hDll);
                lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
                    PHONEERR_OPERATIONUNAVAIL : LINEERR_OPERATIONUNAVAIL);
            }
        }
        else
        {
            LOG((TL_ERROR,
                    "LoadLibraryW(%ls) failed, err=%d",
                    szUIDllName,
                    GetLastError()
                   ));

            lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
                PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);
        }

    }

    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }

LoadUIDll_return:

    return lResult;
}


LONG
PASCAL
lineXxxProvider(
    LPCSTR  pszTUISPI_providerXxx,
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    DWORD   dwPermProviderID,
    LPDWORD lpdwPermProviderID
    )
{
    BOOL                bAddProvider = (pszTUISPI_providerXxx ==
                            gszTUISPI_providerInstall);
    WCHAR               szUIDllName[MAX_PATH];
    LONG                lResult;
    HINSTANCE           hDll;
    TUISPIPROC          pfnTUISPI_providerXxx;
    HTAPIDIALOGINSTANCE htDlgInst;
    LPTSTR              tszProviderFilename;
#ifdef UNICODE
    WCHAR               wszProviderFilename[255];
    HANDLE              hProvidersMutex;

    if (lpszProviderFilename)
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpszProviderFilename,
            lstrlenA (lpszProviderFilename) + 1,
            wszProviderFilename,
            sizeof(wszProviderFilename) / sizeof(WCHAR)
            );
    }
    else
    {
        wszProviderFilename[0] = 0;
    }
    tszProviderFilename = wszProviderFilename;
#else
    tszProviderFilename = lpszProviderFilename;
#endif

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );

    if (NULL == hProvidersMutex)
    {
        return LINEERR_OPERATIONFAILED;
    }

    lResult = AllocClientResources(0);
    if (lResult)
    {
        return lResult;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);

    if (bAddProvider && IsBadDwordPtr (lpdwPermProviderID))
    {
        LOG((TL_ERROR, "Bad lpdwPermProviderID pointer"));
        if (hProvidersMutex)
        {
            ReleaseMutex (hProvidersMutex);
            CloseHandle (hProvidersMutex);
        }
        FreeClientResources ();
        return LINEERR_INVALPOINTER;
    }
    else if (hwndOwner && !IsWindow (hwndOwner))
    {
        LOG((TL_ERROR, "hwndOwner is not a window"));
        if (hProvidersMutex)
        {
            ReleaseMutex (hProvidersMutex);
            CloseHandle (hProvidersMutex);
        }
        FreeClientResources ();
        return LINEERR_INVALPARAM;
    }

    {
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 7, xGetUIDllName),

            {
                (bAddProvider ? (ULONG_PTR) &dwPermProviderID :
                                (ULONG_PTR) dwPermProviderID),
                (ULONG_PTR) TUISPIDLL_OBJECT_PROVIDERID,
                (ULONG_PTR) szUIDllName,
                (ULONG_PTR) MAX_PATH,
                (bAddProvider ? (ULONG_PTR) tszProviderFilename :
                                (ULONG_PTR) TAPI_NO_DATA),
                (ULONG_PTR) (pszTUISPI_providerXxx==gszTUISPI_providerRemove ?
                                1 : 0),
                (ULONG_PTR) &htDlgInst
            },

            {
                (bAddProvider ? lpDword : Dword),
                Dword,
                lpGet_SizeToFollow,
                Size,
                (bAddProvider ? lpszW : Dword),
                Dword,
                lpDword
            }
        };


        if ((lResult = DOFUNC (&funcArgs,"lineXxxProvider/GetUIDllName")) != 0)
        {
            if (lResult == TAPI16BITSUCCESS)
            {
                // 16 bit sp success
                // set result correctly, and return here
                lResult = 0;
            }
            if (hProvidersMutex)
            {
                ReleaseMutex (hProvidersMutex);
                CloseHandle (hProvidersMutex);
            }
            FreeClientResources ();
            return lResult;
        }
    }

    if ((hDll = TAPILoadLibraryW(szUIDllName)))
    {
        if ((pfnTUISPI_providerXxx = (TUISPIPROC) GetProcAddress(
                hDll,
                pszTUISPI_providerXxx
                )))
        {
            LOG((TL_TRACE, "Calling %hs...", pszTUISPI_providerXxx));

            lResult = (*pfnTUISPI_providerXxx)(
                TUISPIDLLCallback,
                hwndOwner,
                dwPermProviderID
                );
#if DBG
            {
                char szResult[32];

                LOG((TL_TRACE,
                    "%hs: result = %hs",
                    pszTUISPI_providerXxx,
                    MapResultCodeToText (lResult, szResult)
                    ));
            }
#else
                LOG((TL_TRACE,
                    ": result = x%x",
                    lResult
                    ));
#endif
        }
        else
        {
            LOG((TL_ERROR,
                "lineXxxProvider: GetProcAddr(%ls,%hs) failed, err=%d",
                szUIDllName,
                pszTUISPI_providerXxx,
                GetLastError()
                ));
        
            //
            //  HACK ALERT !
            //  Even though remotesp.tsp does not have the add/remove/config
            //  provider function, we silently allow it to be added from 
            //  tcmsetup.exe
            //
            if (lstrcmpi (gszRemoteSP, szUIDllName) != 0)
            {
                lResult = LINEERR_OPERATIONUNAVAIL;
            }
        }

        FreeLibrary (hDll);
    }
    else
    {
        LOG((TL_ERROR,
            "lineXxxProvider: LoadLibraryW('%ls') failed, err=%d",
            szUIDllName,
            GetLastError()
            ));

        lResult = LINEERR_OPERATIONFAILED;
    }

    {
        LONG    lResult2;
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 2, xFreeDialogInstance),

            {
                (ULONG_PTR) htDlgInst,
                (ULONG_PTR) (ULONG)lResult
            },

            {
                Dword,
                Dword
            }
        };


        //
        // If TUISPI_providerXxx failed then we want to pass that error back
        // to the app, else if it succeeded & FreeDlgInst failed then pass
        // that error back to the app
        //

        if ((lResult2 = DOFUNC(
                &funcArgs,
                "lineXxxProvider/FreeDialogInstance"

                )) == 0)
        {
            if (bAddProvider)
            {
                *lpdwPermProviderID = dwPermProviderID;
            }
        }
        else if (lResult == 0)
        {
            lResult = lResult2;
        }
    }

    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }
    FreeClientResources ();
    return lResult;
}


LONG
PASCAL
ValidateXxxInitializeParams(
    DWORD                       dwAPIVersion,
    BOOL                        bLine,
    LPLINEINITIALIZEEXPARAMS    pXxxInitExParams,
    LINECALLBACK                pfnCallback
    )
{
    DWORD dwError;


    try
    {
        DWORD   dwTotalSize = pXxxInitExParams->dwTotalSize;


        if (dwTotalSize < sizeof (LINEINITIALIZEEXPARAMS))
        {
            return (bLine ? LINEERR_STRUCTURETOOSMALL :
                PHONEERR_STRUCTURETOOSMALL);
        }

        if (IsBadWritePtr (pXxxInitExParams, dwTotalSize))
        {
            return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        }


        //
        // When checking the dwOptions field be careful about compatibility
        // with future vers, so we only look at the currently valid bits
        //

        switch ((pXxxInitExParams->dwOptions & 0xf))
        {
        case 0:
        case LINEINITIALIZEEXOPTION_USEHIDDENWINDOW:

            if (IsBadCodePtr ((FARPROC) pfnCallback))
            {
                return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            }
            break;


        case LINEINITIALIZEEXOPTION_USECOMPLETIONPORT:

            if ( !gpPostQueuedCompletionStatus )
            {
                HINSTANCE hInst;

                hInst = GetModuleHandle( TEXT("Kernel32.dll") );

#ifdef MEMPHIS
                {
                    FARPROC pfn;
                    BOOL fResult;
                    DWORD dw;
                    OVERLAPPED o;


                    pfn = GetProcAddress (hInst, "GetCompletionPortStatus");

                    if ( NULL == pfn )
                    {
                        LOG((TL_ERROR,
                            "GetProcAddr(GetCompletionPortStatus) failed"
                            ));

                        return (bLine ?
                            LINEERR_INVALFEATURE : PHONEERR_OPERATIONFAILED);
                    }

                    fResult = pfn( -1, &dw, &dw, &o, 0 );
                }

                if ( ERROR_NOT_SUPPORTED != GetLastError() )
#endif
                {
                    gpPostQueuedCompletionStatus = GetProcAddress(
                        hInst,
                        "PostQueuedCompletionStatus"
                        );

                    if ( NULL == gpPostQueuedCompletionStatus )
                    {
                        LOG((TL_ERROR,
                            "GetProcAddr(PostQueuedCompletionStatus) failed"
                             ));

                        return (bLine ?
                            LINEERR_INVALFEATURE : PHONEERR_OPERATIONFAILED);
                    }
                }

            }
            break;

        case LINEINITIALIZEEXOPTION_USEEVENT:

            break;

        default:

            if ((TAPI_VERSION2_2 == dwAPIVersion) ||
                (TAPI_VERSION2_1 == dwAPIVersion) ||
                (TAPI_VERSION2_0 == dwAPIVersion))
            {
                //
                // Invalid parameter for these versions
                //

                return (bLine ? LINEERR_INVALPARAM : PHONEERR_INVALPARAM);
            }
            else
            {
                //
                // This app is asking for something we can't do.
                //

                return (bLine ? LINEERR_INCOMPATIBLEAPIVERSION :
                                PHONEERR_INCOMPATIBLEAPIVERSION);
            }

        }

        pXxxInitExParams->dwNeededSize =
        pXxxInitExParams->dwUsedSize = sizeof (LINEINITIALIZEEXPARAMS);
    }
    except ((((dwError = GetExceptionCode()) == EXCEPTION_ACCESS_VIOLATION) ||
               dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
    }

    return 0;
}


LONG
WINAPI
xxxInitialize(
    BOOL                        bLine,
    LPVOID                      phXxxApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                pfnCallback,
    LPCWSTR                     pszAppName,
    LPDWORD                     pdwNumDevs,
    LPDWORD                     pdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    pXxxInitExParams
#if DBG
    ,char                      *pszFuncName
#endif
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG ((bLine ? LINE_FUNC : PHONE_FUNC) | SYNC | 7,
            (bLine ? lInitialize : pInitialize)),

        {
            (ULONG_PTR) phXxxApp,
            (ULONG_PTR) 0,          // hInstance is ignored by tapisrv, so pass 0,
                                    // to save ourselves grief over HINSTANCE -> DWORD conversion
            (ULONG_PTR) 0,          // pfnCallback, we subst pInitData in here
            (ULONG_PTR) pszAppName,
            (ULONG_PTR) pdwNumDevs,
            (ULONG_PTR) 0,          // pszModuleName
            (ULONG_PTR) TAPI_VERSION1_0
        },

        {
            lpDword,
            Dword,
            Dword,
            lpszW,
            lpDword,
            lpszW,
            Dword
        }
    };

    WCHAR       *pszModuleNamePathW = NULL;
    WCHAR       *pszModuleNameW = NULL;
    LONG         lResult;
    BOOL         bReleaseMutex = FALSE;
    BOOL         bResAllocated = FALSE;
    PINIT_DATA   pInitData = (PINIT_DATA) NULL;
    BOOL         fIs16bitCaller = FALSE;
    DWORD        dwAllInitExOptions;


    EnterCriticalSection (&gCriticalSection);
    if (gdwNumInits == 0)
    {
        TRACELOGREGISTER (_T("tapi32"));
    }
    LeaveCriticalSection (&gCriticalSection);

    if (phXxxApp == (LPVOID) pdwNumDevs)
    {
#if DBG
        LOG((TL_TRACE, "%hs: error, lphApp == lpdwNumDevs", pszFuncName));
#else
        LOG((TL_TRACE, ": error, lphApp == lpdwNumDevs"));
#endif
		lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxInitialize_return;
    }

    if (pdwAPIVersion)
    {
        if (phXxxApp == (LPVOID) pdwAPIVersion  ||
            phXxxApp == (LPVOID) pXxxInitExParams  ||
            pdwNumDevs == pdwAPIVersion  ||
            pdwNumDevs == (LPDWORD) pXxxInitExParams  ||
            pdwAPIVersion == (LPDWORD) pXxxInitExParams)
        {
            lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            goto xxxInitialize_return;
        }


        //
        // line- & phoneInitializeEx both require a valid lpdwAPIVersion
        // pointer parameter, and the value it points to on the way in
        // must be >= 0x00020000. (Careful to allow for future vers of TAPI.)
        //

        if (*pdwAPIVersion < TAPI_VERSION2_0)
        {
            LOG((TL_ERROR,
                "%InitializeEx: error, *lpdwAPIVersion = x%x, " \
                    "must be set >= 0x20000",
                *pdwAPIVersion,
                (bLine ? "line" : "phone")
                ));

            lResult = (bLine ? LINEERR_INCOMPATIBLEAPIVERSION :
                PHONEERR_INCOMPATIBLEAPIVERSION);
            goto xxxInitialize_return;
        }


        //
        // Validate the InitEx params, or if the pointer is NULL (implying
        // that app wants to use "old" hidden window scheme) validate
        // the pfnCallback
        //

        if (pXxxInitExParams)
        {
            if ((lResult = ValidateXxxInitializeParams(
                    (*pdwAPIVersion),
                    bLine,
                    pXxxInitExParams,
                    pfnCallback

                    ))  != 0)
            {
                goto xxxInitialize_return;
            }
        }
        else if (IsBadCodePtr ((FARPROC) pfnCallback))
        {
#if DBG
            LOG((TL_ERROR, "%hs: bad lpfnCallback", pszFuncName));
#else
            LOG((TL_ERROR, ": bad lpfnCallback"));
#endif
            lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            goto xxxInitialize_return;
        }


        //
        // Now fill in *pdwAPIVersion with the version # we support, and
        // also indicate this in the params we pass to tapisrv.exe (so
        // it knows it can start sending us 2.0 msgs right away)
        //

        // bug #69742.  don't assume version 2.0
        if ( (*pdwAPIVersion == TAPI_VERSION2_2) ||
             (*pdwAPIVersion == TAPI_VERSION2_1) ||
             (*pdwAPIVersion == TAPI_VERSION2_0))
        {
            funcArgs.Args[6] = *pdwAPIVersion;
        }
        else
        {
            //
            // the app is at least 2.0 if they are calling lineIntializeEx,
            // but they passed in a bogus tapi version, so set it correctly.
            //

            funcArgs.Args[6] = *pdwAPIVersion = TAPI_CURRENT_VERSION;
        }
    }

#ifndef _WIN64

    else if ((((DWORD) pfnCallback) & 0xffff0000) == 0xffff0000)
    {
        //
        // This is a 16-bit client going through the thunk.  The
        // pfnCallback var is actually a window handle.
        //
        // Note: On NT, 32-bit code can talk to 16-bit HWNDs
        //       by setting the hi-word to 0xffff.
        //
        //       On Win95, 32-bit can talk to 16-bit HWNDs
        //       by setting the hi-word to 0x0000.
        //

//<!         ((DWORD) pfnCallback) = HWND_32( pfnCallback );
//<!
//<!

        if (!IsWindow ((HWND) pfnCallback))
        {
            //
            // If here chances are it's a 32-bit app passing in a bad
            // pfnCallback
            //

#if DBG
            LOG((TL_ERROR, "%hs: bad lpfnCallback", pszFuncName));
#else
            LOG((TL_ERROR, ": bad lpfnCallback"));
#endif
            lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            goto xxxInitialize_return;
        }

        if (!ghWow32Dll &&

            !(ghWow32Dll = LoadLibrary (TEXT("wow32.dll"))))
        {
#if DBG
            LOG((TL_ERROR,
                "%hs: LoadLib(wow32.dll) failed, err=%d",
                pszFuncName,
                GetLastError()
                ));
#else
            LOG((TL_ERROR,
                ": LoadLib(wow32.dll) failed, err=%d",
                GetLastError()
                ));
#endif

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_return;
        }

        if (!gpfnWOWGetVDMPointer &&

            !(gpfnWOWGetVDMPointer = GetProcAddress(
                ghWow32Dll,
                "WOWGetVDMPointer"
                )))
        {
#if DBG
            LOG((TL_ERROR,
                "%hs: GetProcAddr(WOWGetVDMPointer) failed, err=%d",
                pszFuncName,
                GetLastError()
                ));
#else
            LOG((TL_ERROR,
                ": GetProcAddr(WOWGetVDMPointer) failed, err=%d",
                GetLastError()
                ));
#endif

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_return;
        }

        gbNTVDMClient = TRUE;


        //
        // For 16-bit clients the module name will follow the app name
        //
        // HACK ALERT!
        //
        // Since the lpszAppName pointer was already converted to a
        // unicode string by the calling function, the following
        // module name part was lost.  So, we pass the original
        // (16->32 mapped) lpszAppName pointer in pXxxInitExParams
        // so we can discover the module name
        //

        {
            char   *pszAppName2 = (char *) pXxxInitExParams;


            pXxxInitExParams = NULL; // so we don't blow up below

            pszModuleNamePathW = NotSoWideStringToWideString(
                pszAppName2 + lstrlenA (pszAppName2) + 1,
                (DWORD) -1
                );

            funcArgs.Args[5] = (ULONG_PTR) pszModuleNamePathW;

            LOG((TL_INFO,
                "FName='%ls', MName='%ls'",
                pszAppName,
                funcArgs.Args[5]
                ));

        }
    }

#endif

    else if (IsBadCodePtr ((FARPROC) pfnCallback))
    {
        //
        // If here a 32-bit app is call line/phoneInitialize
        //

#if DBG
        LOG((TL_ERROR, "%hs: bad lpfnCallback", pszFuncName));
#else
        LOG((TL_ERROR, ": bad lpfnCallback"));
#endif
        lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxInitialize_return;
    }



    //
    // Check to see if hInstance is bad by getting the module name
    //
    // Note: We now allow a NULL hInstance (16-bit TAPI didn't)
    //

    if (gbNTVDMClient == FALSE)
    {
        DWORD   dwSize = MAX_PATH, dwLength;


alloc_module_name_buf:

        if (!(pszModuleNamePathW = ClientAlloc (dwSize*sizeof(WCHAR))))
        {
            lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
            goto xxxInitialize_return;
        }

        //
        // We're on WinNT - do Unicode
        //
        if ((dwLength = GetModuleFileNameW(
                hInstance,
                pszModuleNamePathW,
                dwSize

                )) == 0)
        {
#if DBG
            LOG((TL_ERROR,
                "%hs: GetModuleFileNameW(x%p, ...) failed, err=%d",
                pszFuncName,
                hInstance,
                GetLastError()
                ));
#else
            LOG((TL_ERROR,
                ": GetModuleFileNameW(x%p, ...) failed, err=%d",
                hInstance,
                GetLastError()
                ));
#endif

            lResult = (bLine ? LINEERR_INVALPARAM : PHONEERR_INVALPARAM);
            goto xxxInitialize_cleanup;
        }
        else if (dwLength >= dwSize)
        {
            ClientFree (pszModuleNamePathW);
            dwSize *= 2;
            goto alloc_module_name_buf;
        }

        pszModuleNameW = wcsrchr (pszModuleNamePathW, '\\') + 1;

        // For MSWORKS.EXE, the behavior of lineGetTranslateCaps 
        // will be different
        
        if(0 == _wcsicmp(pszModuleNameW, L"MSWORKS.EXE"))
        {
            LOG((TL_ERROR, "MSWORKS detected..."));
            gbDisableGetTranslateCapsHack = TRUE;
        }
        else
        {
            gbDisableGetTranslateCapsHack = FALSE;   
        }
            
        funcArgs.Args[5] = (ULONG_PTR) pszModuleNameW;
                                           
        if (!pszAppName)
        {
            funcArgs.Args[3] = funcArgs.Args[5];
        }
    }

    if (!(pInitData = ClientAlloc (sizeof(INIT_DATA))) ||

        !(pInitData->pEventBuffer = ClientAlloc(
            DEF_NUM_EVENT_BUFFER_ENTRIES * sizeof (ASYNC_EVENT_PARAMS))) ||

        !(pInitData->hInitData = NewObject (ghHandleTable, pInitData, NULL)))
    {
        lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
        goto xxxInitialize_cleanup;
    }


    //
    // When checking the dwOptions field be careful about compatibility
    // with future vers, so we only look at the currently valid bits
    // (The ExOptions are currently ordinals, but we track bits here just
    // in case we wanna use high bits later.)
    //

    dwAllInitExOptions = AllInitExOptions2_0;

    pInitData->dwInitOptions = (pXxxInitExParams ?
        (pXxxInitExParams->dwOptions & dwAllInitExOptions) :
        LINEINITIALIZEEXOPTION_USEHIDDENWINDOW);


    switch (pInitData->dwInitOptions & 0xf)
    {
    case LINEINITIALIZEEXOPTION_USECOMPLETIONPORT:

        //
        // Be libertarian- if the app wants to hose itself by passing
        // a bad hCompletionPort then so be it
        //

        pInitData->hCompletionPort =
            pXxxInitExParams->Handles.hCompletionPort;
        pInitData->dwCompletionKey = pXxxInitExParams->dwCompletionKey;
        break;

    case LINEINITIALIZEEXOPTION_USEEVENT:

        if ((pInitData->hEvent = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,
                TRUE,   // manual reset
                FALSE,  // unsignaled
                NULL    // unnamed

                )) == NULL)
        {
            lResult = (bLine ? LINEERR_OPERATIONFAILED :
                PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_cleanup;
        }

        pXxxInitExParams->Handles.hEvent = pInitData->hEvent;
        break;

    default: // case LINEINITIALIZEEXOPTION_USEHIDDENWINDOW:

        pInitData->dwInitOptions |= LINEINITIALIZEEXOPTION_USEHIDDENWINDOW;

        if (gbNTVDMClient == FALSE)
        {
            if ((lResult = CreateHiddenWindow(
                    &pInitData->hwnd,
                    (bLine ? 1 : 2)
                    )) != 0)
            {
                goto xxxInitialize_cleanup;
            }
        }
        else
        {
            pInitData->hwnd = (HWND) pfnCallback;
        }

        pInitData->lpfnCallback          = pfnCallback;
        pInitData->bPendingAsyncEventMsg = FALSE;
        break;
    }

    pInitData->dwKey                 = INITDATA_KEY;
    pInitData->dwNumTotalEntries     = DEF_NUM_EVENT_BUFFER_ENTRIES;
    pInitData->dwNumUsedEntries      = 0;
    pInitData->pValidEntry           =
    pInitData->pFreeEntry            = pInitData->pEventBuffer;
    pInitData->bLine                 = bLine;
    pInitData->dwThreadID            = GetCurrentThreadId();


    //
    // We want to pass TAPISRV pInitData so that later when it does async
    // completion/event notification it can pass pInitData along too so
    // we know which init instance to talk to
    //

    funcArgs.Args[2] = (ULONG_PTR) pInitData->hInitData;

    WaitForSingleObject (ghInitMutex, INFINITE);

    bReleaseMutex = TRUE;



#ifdef MEMPHIS

    //
    // Make sure we only do it once per
    //

    if (fIs16bitCaller  &&  gdwNumInits == 0)
    {
        HANDLE LocalEvent;
        char   buf[256];

        LocalEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

        wsprintfA(
            buf,
            "TAPI16.exe %lu %lu %lu %lu",
            0,
            (DWORD)GetCurrentProcessId(),
            (DWORD)LocalEvent,
            h16bitHelperAppTerminateEvent
            );

        LOG((TL_TRACE, "Launching [%hs]", buf));

        WinExec( buf, SW_HIDE );

        LOG((TL_TRACE, "Waiting..."));
        WaitForSingleObject( LocalEvent, INFINITE );
        CloseHandle( LocalEvent );
        LOG((TL_TRACE, "Not waiting..."));
    }

#endif

    //
    // Need to hold a reference of the Rpc connection
    // so we don't close it until lineShutdown
    //
    bResAllocated = (0 == AllocClientResources(bLine ? 1 : 2));
    if (bResAllocated)
    {
        lResult = DOFUNC (&funcArgs, pszFuncName);
    }
    else
    {
        lResult = (bLine ? LINEERR_OPERATIONFAILED :
                PHONEERR_OPERATIONFAILED);
    }

xxxInitialize_cleanup:

    if (pszModuleNamePathW)
    {
        ClientFree (pszModuleNamePathW);
    }

    if (lResult == 0)
    {
        //
        // If total number of init instances is 0 we need to start a
        // new async events thread
        //

        EnterCriticalSection (&gCriticalSection);
        if (gdwNumInits == 0)
        {
            DWORD   dwThreadID;
            HANDLE  hThread;


            //
            // Alloc resources for a new async events thread, then
            // create the thread
            //

            if ((gpAsyncEventsThreadParams = ClientAlloc(
                    sizeof (ASYNC_EVENTS_THREAD_PARAMS)
                    )))
            {
                //
                // Load ourself to increment our usage count. This is
                // done to give the AsyncEventThread a chance to
                // terminate cleanly if an app thread calls xxxShutdown
                // and then immediately unloads tapi32.dll.
                //
                // (For a while we were doing a Wait on this thread's
                // handle in xxxShutdown waiting for it to terminate,
                // but if xxxShutdown was being called from another DLL's
                // DllEntryPoint then deadlock occured, because
                // DllEntryPoint's aren't reentrant.)
                //

                if ((gpAsyncEventsThreadParams->hTapi32 = LoadLibrary(
                        TEXT("tapi32.dll")
                        )))
                {
                    //
                    // If we're supporting a 16-bit client we want to inc
                    // the usage count for wow32 too
                    //

                    if (ghWow32Dll == NULL ||

                        (gpAsyncEventsThreadParams->hWow32 = LoadLibrary(
                            TEXT("wow32.dll")
                            )))
                    {
                        //
                        // Create the initial buffer the thread will use for
                        // retreiving async events
                        //

                        gpAsyncEventsThreadParams->dwBufSize =
                            ASNYC_MSG_BUF_SIZE;

                        if ((gpAsyncEventsThreadParams->pBuf = ClientAlloc(
                                gpAsyncEventsThreadParams->dwBufSize
                                )))
                        {
                            //
                            // Now that we've all the resources try to exec
                            // the thread
                            //

                            if ((hThread = CreateThread(
                                    NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) AsyncEventsThread,
                                    (LPVOID) gpAsyncEventsThreadParams,
                                    0,
                                    &dwThreadID

                                    )) != NULL)

                            {
                                CloseHandle (hThread);
                                gdwNumInits++;
                                LeaveCriticalSection(&gCriticalSection);
                                goto xxxInitialize_releaseMutex;
                            }


                            ClientFree (gpAsyncEventsThreadParams->pBuf);

#if DBG
                            LOG((TL_ERROR,
                                "%hs: CreateThread(AsyncEventsThread) " \
                                    "failed, err=%d",
                                pszFuncName,
                                GetLastError()
                                ));
#else
                            LOG((TL_ERROR,
                                ": CreateThread(AsyncEventsThread) " \
                                    "failed, err=%d",
                                GetLastError()
                                ));
#endif
                        }

                        if (ghWow32Dll)
                        {
                            FreeLibrary (gpAsyncEventsThreadParams->hWow32);
                        }
                    }

                    FreeLibrary (gpAsyncEventsThreadParams->hTapi32);
                }
                else
                {
#if DBG
                    LOG((TL_ERROR,
                        "%hs: LoadLibrary('tapi32.dll') failed, err=%d",
                        pszFuncName,
                        GetLastError()
                        ));
#else
                    LOG((TL_ERROR,
                        ": LoadLibrary('tapi32.dll') failed, err=%d",
                        GetLastError()
                        ));
#endif
				}

                ClientFree (gpAsyncEventsThreadParams);
            }

            gpAsyncEventsThreadParams = NULL;

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
        }
        else
        {
            gdwNumInits++;
        }
        LeaveCriticalSection(&gCriticalSection);
    }

    if (lResult != 0)
    {
        if (gbNTVDMClient && pInitData)
        {
            pInitData->hwnd = (HWND) NULL;
        }

        FreeInitData (pInitData);
    }

xxxInitialize_releaseMutex:

    if (bReleaseMutex)
    {
        ReleaseMutex (ghInitMutex);
    }

    if (lResult == 0)
    {
        //
        // Save the hLineApp returned by TAPISRV in our InitData struct,
        // and give the app back a unique handle
        //

        pInitData->hXxxApp = *((LPHLINEAPP) phXxxApp);

        *((LPHLINEAPP) phXxxApp) = pInitData->hInitData;
    }

xxxInitialize_return:

    //
    // if we failed, we need to release the RPC ref count,
    // nobody will call lineShutdown
    //
    if (bResAllocated &&
        lResult !=0)
    {
        FreeClientResources();
    }

#if DBG
    {
        char szResult[32];

        LOG((TL_TRACE,
            "%hs: exit, result=%hs",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            ": exit, result=x%x",
            lResult
            ));
#endif

    return lResult;
}


//
// --------------------------------- lineXxx ----------------------------------
//

LONG
WINAPI
lineAccept(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAccept),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1]  = Dword;
        funcArgs.Args[1]      = TAPI_NO_DATA;
        funcArgs.ArgTypes[2]  = Dword;
    }

    return (DOFUNC (&funcArgs, "lineAccept"));
}

LONG
WINAPI
lineAddProviderA(
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    LPDWORD lpdwPermanentProviderID
    )
{
    LONG    lResult;


    LOG((TL_TRACE, "lineAddProviderA: enter"));
    LOG((TL_INFO, "  lpszProviderFilename=0x%p", lpszProviderFilename));

#if DBG
    if (!IsBadStringPtrA(lpszProviderFilename, (UINT)-1) )
    {
        LOG((TL_INFO, "    *lpszProviderFilename=[%hs]", lpszProviderFilename));
    }
#endif

    LOG((TL_INFO, "  hwndOwner=0x%p", hwndOwner));
    LOG((TL_INFO, "  lpdwPermanentProviderID=0x%p", lpdwPermanentProviderID));


    if ( IsBadStringPtrA(lpszProviderFilename, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszProviderFilename (0x%p)", lpszProviderFilename));
        return LINEERR_INVALPOINTER;
    }

    lResult = lineXxxProvider(
        gszTUISPI_providerInstall,  // funcName
        lpszProviderFilename,       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        0,                          // dwPermProviderID
        lpdwPermanentProviderID     // lpdwPermProviderID
        );

#if DBG
    {
        char szResult[32];

        LOG((TL_TRACE,
            "lineAddProvider: result = %hs",
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "lineAddProvider: result = x%x",
            lResult
            ));
#endif

    return lResult;
}

LONG
WINAPI
lineAddProviderW(
    LPCWSTR  lpszProviderFilename,
    HWND     hwndOwner,
    LPDWORD  lpdwPermanentProviderID
    )
{
    LONG            lResult;
    LPBYTE          pszTempPtr;
    DWORD           dwSize;


    LOG((TL_TRACE, "Entering lineAddProvider"));
    LOG((TL_INFO, "  lpszProviderFilename=0x%p", lpszProviderFilename));

    if ( TAPIIsBadStringPtrW(lpszProviderFilename, (UINT)-1) )
    {
        LOG((TL_ERROR,
            "Bad lpszProviderFilename [0x%p] passed to lineAddProviderW",
            lpszProviderFilename
            ));

        return( LINEERR_INVALPOINTER );
    }

    LOG((TL_INFO, "    *lpszProviderFilename=[%ls]", lpszProviderFilename));
    LOG((TL_INFO, "  hwndOwner=0x%p", hwndOwner));
    LOG((TL_INFO, "  lpdwPermanentProviderID=0x%p", lpdwPermanentProviderID));

    dwSize = lstrlenW(lpszProviderFilename) + 1;

    pszTempPtr = ClientAlloc(dwSize * sizeof (WCHAR));
    if (NULL == pszTempPtr)
    {
        return LINEERR_NOMEM;
    }

    // can't use this because this is for strings
    // embedded in structures.
    // WideStringToNotSoWideString (pszTempPtr, &dwSize);

    WideCharToMultiByte(
                        GetACP(),
                        0,
                        lpszProviderFilename,
                        -1,
                        pszTempPtr,
                        dwSize * sizeof(WCHAR),
                        NULL,
                        NULL
                       );

    lResult = lineAddProviderA(
        (LPCSTR) pszTempPtr,
        hwndOwner,
        lpdwPermanentProviderID
        );

    ClientFree(pszTempPtr);

    return lResult;
}




LONG
WINAPI
lineAddProvider(
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    LPDWORD lpdwPermanentProviderID
    )
{
    return lineAddProviderA(
               lpszProviderFilename,
               hwndOwner,
               lpdwPermanentProviderID
    );
}


LONG
WINAPI
lineAddToConference(
    HCALL   hConfCall,
    HCALL   hConsultCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lAddToConference),

        {
            (ULONG_PTR) hConfCall ,
            (ULONG_PTR) hConsultCall
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineAddToConference"));
}


LONG
WINAPI
lineAgentSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lAgentSpecific),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAgentExtensionIDIndex,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    DWORD hPointer = 0;
    LONG lResult;

    if ( !hLine )
    {
        return LINEERR_INVALLINEHANDLE;
    }

    if ( !lpParams )
    {
        return LINEERR_INVALPOINTER;
    }

    // Since we're passing lpParams twice, once a handle to it
    // and another time unchanged, we rely on DoFunc to test it.
    hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    if (0 > (lResult = DOFUNC (&funcArgs, "lineAgentSpecific")))
    {
        // There was an error, free the handle...
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineAnswer(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAnswer),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1]  = Dword;
        funcArgs.Args[1]      = TAPI_NO_DATA;
        funcArgs.ArgTypes[2]  = Dword;
    }

    return (DOFUNC (&funcArgs, "lineAnswer"));
}


LONG
WINAPI
lineBlindTransferW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lBlindTransfer),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if ( TAPIIsBadStringPtrW( lpszDestAddress, (UINT)-1 ) )
    {
        LOG((TL_ERROR,
            "lineBlindTransferW: bad lpszDestAddress: 0x%p",
            lpszDestAddress
            ));

        return(LINEERR_INVALPOINTER);
    }

    return (DOFUNC (&funcArgs, "lineBlindTransfer"));
}


LONG
WINAPI
lineBlindTransferA(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if ( IsBadStringPtrA( lpszDestAddress, (UINT)-1 ) )
    {
        LOG((TL_ERROR,
            "lineBlindTransferA: bad lpszDestAddress: 0x%08lx",
            lpszDestAddress
            ));

        return(LINEERR_INVALPOINTER);
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    if ( !szTempPtr )
    {
        LOG((TL_ERROR,
            "lineBlindTransferA: NotSoWideStringToWideString returned NULL"
            ));

        return(LINEERR_INVALPOINTER);
    }


    lResult = lineBlindTransferW (hCall, szTempPtr, dwCountryCode);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineBlindTransfer(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    return lineBlindTransferA(
                hCall,
                lpszDestAddress,
                dwCountryCode
    );
}


LONG
WINAPI
lineClose(
    HLINE   hLine
    )
{
    LONG lResult;
    DWORD Handle = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lClose),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) &Handle
        },

        {
            Dword,
            lpDword
        }
    };


    lResult = DOFUNC (&funcArgs, "lineClose");

    if (0 == lResult &&
        0 != Handle)
    {
        DereferenceObject (ghHandleTable, Handle, 1);
    }

    return lResult;
}


void
PASCAL
lineCompleteCallPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineCompleteCallPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwCompletionID   = (DWORD) pMsg->Param3;
        LPDWORD lpdwCompletionID = (LPDWORD) ReferenceObject (ghHandleTable, pMsg->Param4, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param4, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPDWORD lpdwCompletionIDVDM = (LPDWORD) gpfnWOWGetVDMPointer (
                    (DWORD) lpdwCompletionID,
                    sizeof(DWORD),
                    TRUE // fProtectedMode
                    );


                if (lpdwCompletionIDVDM)
                {
                    *lpdwCompletionIDVDM = dwCompletionID;
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                *lpdwCompletionID = dwCompletionID;
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineCompleteCall(
    HCALL   hCall,
    LPDWORD lpdwCompletionID,
    DWORD   dwCompletionMode,
    DWORD   dwMessageID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCompleteCall),

        {
            (ULONG_PTR) GetFunctionIndex(lineCompleteCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpdwCompletionID,
            (ULONG_PTR) dwCompletionMode,
            (ULONG_PTR) dwMessageID
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lpdwCompletionID))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lpdwCompletionID, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }

        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }


    lResult = DOFUNC (&funcArgs, "lineCompleteCall");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineCompleteTransfer(
    HCALL   hCall,
    HCALL   hConsultCall,
    LPHCALL lphConfCall,
    DWORD   dwTransferMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCompleteTransfer),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) lphConfCall,
            (ULONG_PTR) dwTransferMode,
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (dwTransferMode == LINETRANSFERMODE_TRANSFER)
    {
        //
        // lphCall should be ignored
        //

        funcArgs.Args[0] = 0; // (POSTPROCESSPROC) NULL;
    }
    else if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConfCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConfCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineCompleteTransfer");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_lineConfigDialog;


    if (lpszDeviceClass && TAPIIsBadStringPtrW (lpszDeviceClass, 256))
    {
        return LINEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_LINEID,
            &hDll,
            gszTUISPI_lineConfigDialog,
            &pfnTUISPI_lineConfigDialog

            )) == 0)
    {
        LOG((TL_TRACE, "Calling TUISPI_lineConfigDialog..."));

        lResult = (*pfnTUISPI_lineConfigDialog)(
            TUISPIDLLCallback,
            dwDeviceID,
            hwndOwner,
            lpszDeviceClass
            );

#if DBG
        {
            char szResult[32];

            LOG((TL_TRACE,
                "TUISPI_lineConfigDialog: result = %hs",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
            LOG((TL_TRACE,
                "TUISPI_lineConfigDialog: result = x%x",
                lResult
                ));
#endif

        FreeLibrary (hDll);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogA(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    PWSTR szTempString = NULL;
    LONG  lResult;


    if (lpszDeviceClass && IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempString = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);

    lResult = lineConfigDialogW (dwDeviceID, hwndOwner, szTempString);

    if (szTempString)
    {
        ClientFree (szTempString);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    return lineConfigDialogA(
               dwDeviceID,
               hwndOwner,
               lpszDeviceClass
               );
}


LONG
WINAPI
lineConfigDialogEditW(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCWSTR         lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING     lpDeviceConfigOut
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_lineConfigDialogEdit;


    if (lpszDeviceClass && TAPIIsBadStringPtrW (lpszDeviceClass, (UINT) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    if (IsBadReadPtr (lpDeviceConfigIn, dwSize))
    {
        return LINEERR_INVALPOINTER;
    }

    if (IsBadWritePtr (lpDeviceConfigOut, sizeof (VARSTRING)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpDeviceConfigOut->dwTotalSize < sizeof (VARSTRING))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (IsBadWritePtr (lpDeviceConfigOut, lpDeviceConfigOut->dwTotalSize))
    {
        return LINEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_LINEID,
            &hDll,
            gszTUISPI_lineConfigDialogEdit,
            &pfnTUISPI_lineConfigDialogEdit

            )) == 0)
    {
        LOG((TL_TRACE, "Calling TUISPI_lineConfigDialogEdit..."));

        lResult = (*pfnTUISPI_lineConfigDialogEdit)(
            TUISPIDLLCallback,
            dwDeviceID,
            hwndOwner,
            lpszDeviceClass,
            lpDeviceConfigIn,
            dwSize,
            lpDeviceConfigOut
            );

#if DBG
        {
            char szResult[32];

            LOG((TL_TRACE,
                "TUISPI_lineConfigDialogEdit: result = %hs",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
            LOG((TL_TRACE,
                "TUISPI_lineConfigDialogEdit: result = x%x",
                lResult
                ));
#endif
        FreeLibrary (hDll);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogEditA(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCSTR          lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING     lpDeviceConfigOut
    )
{
    PWSTR szTempString;
    LONG  lResult;


    if (lpszDeviceClass && IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempString = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);


    lResult = lineConfigDialogEditW(
        dwDeviceID,
        hwndOwner,
        szTempString,
        lpDeviceConfigIn,
        dwSize,
        lpDeviceConfigOut
        );

    if (szTempString)
    {
        ClientFree (szTempString);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogEdit(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCSTR          lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING     lpDeviceConfigOut
    )
{
    return lineConfigDialogEditA(
                    dwDeviceID,
                    hwndOwner,
                    lpszDeviceClass,
                    lpDeviceConfigIn,
                    dwSize,
                    lpDeviceConfigOut
    );
}


LONG
WINAPI
lineConfigProvider(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    return (lineXxxProvider(
        gszTUISPI_providerConfig,   // func name
        NULL,                       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        dwPermanentProviderID,      // dwPermProviderID
        NULL                        // lpdwPermProviderID
        ));
}


LONG
WINAPI
lineCreateAgentW(
    HLINE       hLine,
    LPWSTR      lpszAgentID,
    LPWSTR      lpszAgentPIN,
    LPHAGENT    lphAgent
    )
{
    DWORD hPointer = 0;
    LONG  lResult;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCreateAgent),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpszAgentID,
            (ULONG_PTR) lpszAgentPIN,
            (ULONG_PTR) lphAgent
        },

        {
            Dword,
            Dword,
            lpszAgentID?lpszW:Dword,
            lpszAgentPIN?lpszW:Dword,
            Dword,
        }
    };

    if ( NULL == lpszAgentID )
    {
        funcArgs.Args[2] = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }
    else if ( TAPIIsBadStringPtrW(lpszAgentID, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAgentID in lineCreateAgentW"));
        return( LINEERR_INVALPOINTER );
    }

    if ( NULL == lpszAgentPIN )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }
    else if ( TAPIIsBadStringPtrW(lpszAgentPIN, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentW"));
        return( LINEERR_INVALPOINTER );
    }

    if (IsBadDwordPtr (lphAgent))
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lphAgent, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineCreateAgentW");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineCreateAgentA(
    HLINE       hLine,
    LPSTR       lpszAgentID,
    LPSTR       lpszAgentPIN,
    LPHAGENT    lphAgent
    )
{
    PWSTR       pwAgentID;
    PWSTR       pwAgentPIN;
    LONG        lResult;



    if (lpszAgentID)
    {
        if ( IsBadStringPtrA(lpszAgentID, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszAgentID in lineCreateAgentA"));
            return( LINEERR_INVALPOINTER );
        }
        pwAgentID = NotSoWideStringToWideString (lpszAgentID, (DWORD) -1);
    }
    else
    {
        pwAgentID = NULL;
    }

    if (lpszAgentPIN)
    {
        if ( IsBadStringPtrA(lpszAgentPIN, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentA"));
            return( LINEERR_INVALPOINTER );
        }
        pwAgentPIN = NotSoWideStringToWideString (lpszAgentPIN, (DWORD) -1);
    }
    else
    {
        pwAgentPIN = NULL;
    }

    lResult = lineCreateAgentW (hLine, pwAgentID, pwAgentPIN, lphAgent);

    if (pwAgentPIN)
    {
        ClientFree (pwAgentPIN);
    }

    if (pwAgentID)
    {
        ClientFree (pwAgentID);
    }

    return lResult;
}


LONG
WINAPI
lineCreateAgentSessionW(
    HLINE           hLine,
    HAGENT          hAgent,
    LPWSTR          lpszAgentPIN,
    DWORD           dwWorkingAddressID,
    LPGUID          lpGroupID,
    LPHAGENTSESSION lphAgentSession
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lCreateAgentSession),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) lpszAgentPIN,
            (ULONG_PTR) dwWorkingAddressID,
            (ULONG_PTR) lpGroupID,
            (ULONG_PTR) sizeof( GUID ),
            (ULONG_PTR) lphAgentSession
        },

        {
            Dword,
            Dword,
            Dword,
            lpszAgentPIN?lpszW:Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( NULL == lpszAgentPIN )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }
    else if ( TAPIIsBadStringPtrW(lpszAgentPIN, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentSessionW"));
        return( LINEERR_INVALPOINTER );
    }

    if (IsBadDwordPtr (lphAgentSession))
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lphAgentSession, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[7] = (ULONG_PTR)hPointer;


    lResult = DOFUNC (&funcArgs, "lineCreateAgentSessionW");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}

LONG
WINAPI
lineCreateAgentSessionA(
    HLINE           hLine,
    HAGENT          hAgent,
    LPSTR           lpszAgentPIN,
    DWORD           dwWorkingAddressID,
    LPGUID          lpGroupID,
    LPHAGENTSESSION lphAgentSession
    )
{
    LONG    lResult;
    PWSTR   pwAgentPIN;



    if (lpszAgentPIN)
    {
        if ( IsBadStringPtrA(lpszAgentPIN, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentSessionA"));
            return( LINEERR_INVALPOINTER );
        }
        pwAgentPIN = NotSoWideStringToWideString (lpszAgentPIN, (DWORD) -1);
    }
    else
    {
        pwAgentPIN = NULL;
    }

    lResult = lineCreateAgentSessionW(
        hLine,
        hAgent,
        pwAgentPIN,
        dwWorkingAddressID,
        lpGroupID,
        lphAgentSession
        );

    if (pwAgentPIN)
    {
        ClientFree (pwAgentPIN);
    }

    return lResult;
}


LONG
WINAPI
lineDeallocateCall(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, lDeallocateCall),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };

    LOG((TL_TRACE,
        "lineDeallocateCall: enter on thread: 0x%08lx",
        GetCurrentThreadId()
        ));

    LOG((TL_INFO, "  hCall = 0x%08lx", hCall));

    return (DOFUNC (&funcArgs, "lineDeallocateCall"));
}


void
PASCAL
lineDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineDevSpecificPostProcess: enter"));

    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = (DWORD) pMsg->Param4;
        if (dwSize != 0)
        {
            LPBYTE  pParams = (LPBYTE) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

            // We don't need the handle to the pointer any more...
            DereferenceObject (ghHandleTable, pMsg->Param3, 2);

            try
            {
                if (gbNTVDMClient)
                {
#ifndef _WIN64

                    LPBYTE pParamsVDM = (LPBYTE) gpfnWOWGetVDMPointer(
                        (DWORD) pParams,
                        dwSize,
                        TRUE // fProtectedMode
                        );


                    if (pParamsVDM)
                    {
                        CopyMemory (pParamsVDM, (LPBYTE) (pMsg + 1), dwSize);
                    }
                    else
                    {
                        pMsg->Param2 = LINEERR_INVALPOINTER;
                    }
#endif
                }
                else
                {
                    CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                pMsg->Param2 = LINEERR_INVALPOINTER;
            }
        }
    }
}


LONG
WINAPI
lineDevSpecific(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lDevSpecific),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpParams, // pass the actual pointer (for post proc'g)
            (ULONG_PTR) lpParams, // pass data
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (gbNTVDMClient)
    {
#ifndef _WIN64
        if (!gpfnWOWGetVDMPointer  ||

            !(funcArgs.Args[5] = gpfnWOWGetVDMPointer(
                (DWORD)  lpParams,
                dwSize,
                TRUE // fProtectedMode
                )))
#endif
        {
            return LINEERR_OPERATIONFAILED;
        }
    }

    if ( !lpParams && dwSize > 0)
    {
        return LINEERR_INVALPOINTER;
    }

    if (dwSize > 0)
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineDevSpecific");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineDevSpecificFeature(
    HLINE   hLine,
    DWORD   dwFeature,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lDevSpecificFeature),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwFeature,
            (ULONG_PTR) lpParams, // pass the actual pointer (for post processing)
            (ULONG_PTR) lpParams, // pass data
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (gbNTVDMClient)
    {
#ifndef _WIN64
        if (!gpfnWOWGetVDMPointer ||

            !(funcArgs.Args[4] = gpfnWOWGetVDMPointer(
                (DWORD) lpParams,
                dwSize,
                TRUE // fProtectedMode
                )))
#endif
        {
            return LINEERR_OPERATIONFAILED;
        }
    }

    if ( !lpParams && dwSize > 0)
    {
        return LINEERR_INVALPOINTER;
    }

    if (dwSize > 0)
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineDevSpecificFeature");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineDialW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lDial),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if ( TAPIIsBadStringPtrW(lpszDestAddress, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineDialW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineDial"));
}


LONG
WINAPI
lineDialA(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if ( IsBadStringPtrA(lpszDestAddress, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineDialA"));
        return( LINEERR_INVALPOINTER );
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    if ( !szTempPtr )
    {
        LOG((TL_ERROR, "lineDialA: NotSoWideStringToWideString returned NULL"));
        return( LINEERR_INVALPOINTER );
    }

    lResult = lineDialW (hCall, szTempPtr, dwCountryCode);

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineDial(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    return lineDialA(
            hCall,
            lpszDestAddress,
            dwCountryCode
    );
}


LONG
WINAPI
lineDrop(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lDrop),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineDrop"));
}


LONG
WINAPI
lineForwardW(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 9, lForward),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) bAllAddresses,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpForwardList,
            (ULONG_PTR) dwNumRingsNoAnswer,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpForwardList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[7] = Dword;
        funcArgs.Args[7]     = TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[6] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineForwardW");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


// void
// LayDownNewString(
//     LPBYTE  pOldBase,
//     LPDWORD pdwOldSizeOffset,
//     LPBYTE  pNewBase,
//     LPDWORD pdwNewSizeOffset,
//     LPDWORD pdwNewOffset
//     )
// {
//     LPBYTE pOldString;
//     DWORD  dwNewStringSize;
//
//
//     pOldString =  pOldBase + *(pdwOldSizeOffset + 1);
//
//     *(pdwNewSizeOffset + 1) = *pdwNewOffset;
//
//     if ( IsBadStringPtr( pOldString, 256) )
//     {
//         return;
//     }
//
//     dwNewStringSize = sizeof(WCHAR) * MultiByteToWideChar(
//         GetACP(),
//         MB_PRECOMPOSED,
//         pOldString,
//         *pdwOldSizeOffset,
//         (PWSTR)(pNewBase + *(pdwNewSizeOffset + 1)),
//         *pdwOldSizeOffset
//         );
//
//     *pdwNewSizeOffset = dwNewStringSize;
//
//     *pdwNewOffset = (*pdwNewOffset + dwNewStringSize + 3) & 0xfffffffc;
// }


LONG
WINAPI
lineForwardA(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 9, lForward),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) bAllAddresses,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpForwardList,
            (ULONG_PTR) dwNumRingsNoAnswer,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpForwardList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[7] = Dword;
        funcArgs.Args[7]     = TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[6] = (ULONG_PTR)hPointer;
    }


    lResult = DOFUNC (&funcArgs, "lineForward");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}



LONG
WINAPI
lineForward(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return lineForwardA(
             hLine,
             bAllAddresses,
             dwAddressID,
             lpForwardList,
             dwNumRingsNoAnswer,
             lphConsultCall,
             lpCallParams
    );
}


void
PASCAL
lineGatherDigitsWPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineGatherDigitsWPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param1 & (LINEGATHERTERM_BUFFERFULL | LINEGATHERTERM_CANCEL |
            LINEGATHERTERM_TERMDIGIT | LINEGATHERTERM_INTERTIMEOUT))
    {
        LPSTR   lpsDigits = (LPSTR) ReferenceObject (ghHandleTable, pMsg->Param2, 0);
        DWORD   dwNumDigits = (DWORD) pMsg->Param4;
#if NEWTAPI32
        LPBYTE   lpBuf = (LPBYTE)(((ULONG_PTR *)(pMsg + 1)) + 2);
#endif

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param2, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPSTR lpsDigitsVDM = (LPSTR) gpfnWOWGetVDMPointer(
                    (DWORD) lpsDigits,
                    dwNumDigits * sizeof(WCHAR),
                    TRUE // fProtectedMode
                    );


                if (lpsDigitsVDM)
                {
#if NEWTAPI32
                    CopyMemory(
                        lpsDigitsVDM,
                        lpBuf,
                        dwNumDigits * sizeof (WCHAR)
                        );
#else
                    CopyMemory(
                        lpsDigitsVDM,
                        pMsg + 1,
                        dwNumDigits * sizeof (WCHAR)
                        );
#endif

                }
                else
                {
                }
#endif
            }
            else
            {
                CopyMemory (lpsDigits, lpBuf, dwNumDigits * sizeof(WCHAR));
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // Don't do anything if we GPF
            //
        }
    }

    pMsg->Param2 = 0;
}


LONG
WINAPI
lineGatherDigitsW(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPWSTR  lpsDigits,
    DWORD   dwNumDigits,
    LPCWSTR lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    FUNC_ARGS funcArgs =
    {
#if NEWTAPI32
        MAKELONG (LINE_FUNC | SYNC | 9, lGatherDigits),
#else
        MAKELONG (LINE_FUNC | SYNC | 8, lGatherDigits),
#endif

        {
            (ULONG_PTR) GetFunctionIndex(lineGatherDigitsWPostProcess),
            (ULONG_PTR) hCall,
#if NEWTAPI32
            (ULONG_PTR) 0,  // this is the dwendtoendid for remotesp
#endif
            (ULONG_PTR) dwDigitModes,
            (ULONG_PTR) lpsDigits,
            (ULONG_PTR) dwNumDigits,
            (ULONG_PTR) lpszTerminationDigits,
            (ULONG_PTR) dwFirstDigitTimeout,
            (ULONG_PTR) dwInterDigitTimeout
        },

        {

            Dword,
            Dword,
#if NEWTAPI32
            Dword,
#endif
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    //
    // Note: we do the ptr check here rather than in DOFUNC because we're
    //       not passing any digits data within the context of this func
    //

    if (lpsDigits && IsBadWritePtr (lpsDigits, dwNumDigits * sizeof (WCHAR)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpszTerminationDigits == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //
#if NEWTAPI32
        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
#else
        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = TAPI_NO_DATA;
#endif
    }
    else
    {
        if ( TAPIIsBadStringPtrW(lpszTerminationDigits, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszDestAddress in lineGatherDigitsW"));
            return( LINEERR_INVALPOINTER );
        }
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpsDigits, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGatherDigits");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGatherDigitsPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineGatherDigitsPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param1 & (LINEGATHERTERM_BUFFERFULL | LINEGATHERTERM_CANCEL |
            LINEGATHERTERM_TERMDIGIT | LINEGATHERTERM_INTERTIMEOUT))
    {
        LPSTR   lpsDigits = (LPSTR) ReferenceObject (ghHandleTable, pMsg->Param2, 0);
        DWORD   dwNumDigits = (DWORD) pMsg->Param4;
        LPWSTR  pBuffer = (LPWSTR) (((ULONG_PTR *)(pMsg + 1)) + 2);


        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param2, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPSTR lpsDigitsVDM = (LPSTR) gpfnWOWGetVDMPointer(
                    (DWORD) lpsDigits,
                    dwNumDigits * sizeof(WCHAR),
                    TRUE // fProtectedMode
                    );


                if (lpsDigitsVDM)
                {
                      WideCharToMultiByte(
                          GetACP(),
                          0,
#if NEWTAPI32
                          pBuffer,
#else
                          (LPCWSTR)(pMsg + 1),
#endif
                          dwNumDigits,
                          lpsDigitsVDM,
                          dwNumDigits,
                          NULL,
                          NULL
                          );
                }
                else
                {
                }
#endif
            }
            else
            {
                  WideCharToMultiByte(
                      GetACP(),
                      0,
#if NEWTAPI32
                      pBuffer,
#else
                      (LPCWSTR)(pMsg + 1),
#endif
                      dwNumDigits,
                      lpsDigits,
                      dwNumDigits,
                      NULL,
                      NULL
                      );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // Don't do anything if we GPF
            //
        }
    }

    pMsg->Param2 = 0;
}


LONG
WINAPI
lineGatherDigitsA(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPSTR   lpsDigits,
    DWORD   dwNumDigits,
    LPCSTR  lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    LONG lResult;
    DWORD hPointer = 0;

    FUNC_ARGS funcArgs =
    {
#if NEWTAPI32
        MAKELONG (LINE_FUNC | SYNC | 9, lGatherDigits),
#else
        MAKELONG (LINE_FUNC | SYNC | 8, lGatherDigits),
#endif

        {
            (ULONG_PTR) GetFunctionIndex(lineGatherDigitsPostProcess),
            (ULONG_PTR) hCall,
#if NEWTAPI32
            (ULONG_PTR) 0,              // dw end to end id for remotesp
#endif
            (ULONG_PTR) dwDigitModes,
            (ULONG_PTR) lpsDigits,
            (ULONG_PTR) dwNumDigits,
//BJM 06/04/97  what was this?   0, // (DWORD) lpszTerminationDigits,
            (ULONG_PTR) lpszTerminationDigits,
            (ULONG_PTR) dwFirstDigitTimeout,
            (ULONG_PTR) dwInterDigitTimeout
        },

        {
            Dword,
            Dword,
#if NEWTAPI32
            Dword,
#endif
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    //
    // Note: we do the ptr check here rather than in DOFUNC because we're
    //       not passing any digits data within the context of this func
    //

    if (gbNTVDMClient == FALSE)
    {
        if (lpsDigits && IsBadWritePtr (lpsDigits, dwNumDigits))
        {
            return LINEERR_INVALPOINTER;
        }
    }

    if (lpszTerminationDigits == (LPCSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

#if NEWTAPI32
        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
#else
        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = TAPI_NO_DATA;
#endif
    }
    else
    {
        if ( IsBadStringPtrA(lpszTerminationDigits, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszDestAddress in lineGatherDigitsA"));
            return( LINEERR_INVALPOINTER );
        }

#if NEWTAPI32
        funcArgs.Args[6] = (ULONG_PTR)  NotSoWideStringToWideString(
            lpszTerminationDigits,
            (DWORD) -1
            );
#else
        funcArgs.Args[5] = (ULONG_PTR)  NotSoWideStringToWideString(
            lpszTerminationDigits,
            (DWORD) -1
            );
#endif
    }

    if ( lpsDigits )
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpsDigits, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;
    }
    else
    {
        funcArgs.Args[4] = (ULONG_PTR) 0;
    }

    lResult = (DOFUNC (&funcArgs, "lineGatherDigits"));

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

#if NEWTAPI32
    if ( funcArgs.Args[6] && (funcArgs.Args[6] != TAPI_NO_DATA) )
    {
       ClientFree( (LPVOID)funcArgs.Args[6] );
    }
#else
    if ( funcArgs.Args[5] && (funcArgs.Args[5] != TAPI_NO_DATA) )
    {
       ClientFree( (LPVOID)funcArgs.Args[5] );
    }
#endif

    return lResult;
}


LONG
WINAPI
lineGatherDigits(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPSTR   lpsDigits,
    DWORD   dwNumDigits,
    LPCSTR  lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    return lineGatherDigitsA(
              hCall,
              dwDigitModes,
              lpsDigits,
              dwNumDigits,
              lpszTerminationDigits,
              dwFirstDigitTimeout,
              dwInterDigitTimeout
    );
}


LONG
WINAPI
lineGenerateDigitsW(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCWSTR lpszDigits,
    DWORD   dwDuration
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGenerateDigits),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwDigitMode,
            (ULONG_PTR) lpszDigits,
            (ULONG_PTR) dwDuration,
            (ULONG_PTR) 0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    if (!lpszDigits)
    {
        funcArgs.Args[2]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineGenerateDigits"));
}


LONG
WINAPI
lineGenerateDigitsA(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCSTR  lpszDigits,
    DWORD   dwDuration
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGenerateDigits),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwDigitMode,
            (ULONG_PTR) 0,              // (DWORD) lpszDigits,
            (ULONG_PTR) dwDuration,
            (ULONG_PTR) 0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    if (lpszDigits)
    {
        if (IsBadStringPtrA (lpszDigits, (DWORD) -1))
        {
            return LINEERR_INVALPOINTER;
        }
        else if (!(funcArgs.Args[2] = (ULONG_PTR) NotSoWideStringToWideString(
                    lpszDigits,
                    (DWORD) -1
                    )))
        {
            return LINEERR_NOMEM;
        }
    }
    else
    {
        funcArgs.Args[2]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    lResult = (DOFUNC (&funcArgs, "lineGenerateDigits"));

    if (funcArgs.Args[2] != TAPI_NO_DATA)
    {
        ClientFree ((LPVOID) funcArgs.Args[2]);
    }

    return lResult;
}


LONG
WINAPI
lineGenerateDigits(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCSTR  lpszDigits,
    DWORD   dwDuration
    )
{
    return lineGenerateDigitsA(
              hCall,
              dwDigitMode,
              lpszDigits,
              dwDuration
    );
}


LONG
WINAPI
lineGenerateTone(
    HCALL   hCall,
    DWORD   dwToneMode,
    DWORD   dwDuration,
    DWORD   dwNumTones,
    LPLINEGENERATETONE const lpTones
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGenerateTone),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwToneMode,
            (ULONG_PTR) dwDuration,
            (ULONG_PTR) dwNumTones,
            (ULONG_PTR) TAPI_NO_DATA,   // (DWORD) lpTones,
            (ULONG_PTR) 0,              // dwNumTones * sizeof(LINEGENERATETONE)
            (ULONG_PTR) 0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,      // lpSet_SizeToFollow,
            Dword,      // Size
            Dword
        }
    };


    if (dwToneMode == LINETONEMODE_CUSTOM)
    {
        //
        // Set lpTones (& following Size arg) since in this case
        // they are valid args
        //

        funcArgs.ArgTypes[4] = lpSet_SizeToFollow;
        funcArgs.Args[4]     = (ULONG_PTR) lpTones;
        funcArgs.ArgTypes[5] = Size;
        funcArgs.Args[5]     = dwNumTones * sizeof(LINEGENERATETONE);
    }

    return (DOFUNC (&funcArgs, "lineGenerateTone"));
}


LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetAddressCaps),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) lpAddressCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetAddressCaps"));
}


LONG
WINAPI
lineGetAddressCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    LONG lResult;


    lResult = lineGetAddressCapsW(
        hLineApp,
        dwDeviceID,
        dwAddressID,
        dwAPIVersion,
        dwExtVersion,
        lpAddressCaps
        );

    if (lResult == 0)
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpAddressCaps,
            &lpAddressCaps->dwAddressSize
            );

        //
        // WideChar to multibyte translation of the completion message
        // array is somewhat problematic in that we can't be sure
        // the msgs will all be the same size after translation.  So
        // we'll translate them, pad the remainder of each msg entry
        // with 0's, and not bother touching any of the size or
        // offset values.
        //

        if (lpAddressCaps->dwNumCompletionMessages  &&
            lpAddressCaps->dwCompletionMsgTextEntrySize)
        {
            PWSTR   pStrW;
            PSTR    pStrA;
            DWORD   dwMsgSize = lpAddressCaps->dwCompletionMsgTextEntrySize,
                    dwNewSize, i;


            if ((pStrA = ClientAlloc (dwMsgSize)))
            {
                pStrW = (PWSTR) (((LPBYTE) lpAddressCaps) +
                    lpAddressCaps->dwCompletionMsgTextOffset);

                for (i = 0; i < lpAddressCaps->dwNumCompletionMessages; i++)
                {
                    dwNewSize = WideCharToMultiByte(
                        GetACP(),
                        0,
                        pStrW,
                        dwMsgSize / sizeof(WCHAR),
                        pStrA,
                        dwMsgSize,
                        NULL,
                        NULL
                        );

                    CopyMemory (pStrW, pStrA, dwNewSize);

                    ZeroMemory(
                        ((LPBYTE) pStrW) + dwNewSize,
                        dwMsgSize - dwNewSize
                        );

                    pStrW = (PWSTR) (((LPBYTE) pStrW) + dwMsgSize);
                }

                ClientFree (pStrA);
            }
            else
            {
                lpAddressCaps->dwNumCompletionMessages      =
                lpAddressCaps->dwCompletionMsgTextEntrySize =
                lpAddressCaps->dwCompletionMsgTextSize      =
                lpAddressCaps->dwCompletionMsgTextOffset    = 0;
            }
        }

        if (dwAPIVersion >= 0x00020000)
        {
            WideStringToNotSoWideString(
                    (LPBYTE)lpAddressCaps,
                    &lpAddressCaps->dwDeviceClassesSize
                    );
        }

    }

    return lResult;
}


LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    return lineGetAddressCapsA(
                         hLineApp,
                         dwDeviceID,
                         dwAddressID,
                         dwAPIVersion,
                         dwExtVersion,
                         lpAddressCaps
    );
}


LONG
WINAPI
lineGetAddressIDW(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCWSTR lpsAddress,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetAddressID),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpdwAddressID,
            (ULONG_PTR) dwAddressMode,
            (ULONG_PTR) lpsAddress,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpDword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "lineGetAddressID"));
}


LONG
WINAPI
lineGetAddressIDA(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCSTR  lpsAddress,
    DWORD   dwSize
    )
{
    LONG    lResult;
    DWORD   dwNumChars;
    PWSTR   szTempPtr;


    //
    // Special case for dwSize = -1 (implies a NULL-terminated string as
    // far as IsBadStringPtrA is concerned)
    //

    if (dwSize == 0  ||  IsBadReadPtr (lpsAddress, dwSize))
    {
       LOG((TL_ERROR, "lineGetAddressID: Bad lpsAddress or dwSize"));
       return LINEERR_INVALPOINTER;
    }

    dwNumChars = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpsAddress,
        dwSize,
        NULL,
        0
        );

    if (!(szTempPtr = ClientAlloc (dwNumChars * sizeof (WCHAR))))
    {
        return LINEERR_NOMEM;
    }

    MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpsAddress,
        dwSize,
        szTempPtr,
        dwNumChars
        );

    lResult = lineGetAddressIDW(
        hLine,
        lpdwAddressID,
        dwAddressMode,
        szTempPtr,
        dwNumChars * sizeof (WCHAR)
        );

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineGetAddressID(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCSTR  lpsAddress,
    DWORD   dwSize
    )
{
    return lineGetAddressIDA(
              hLine,
              lpdwAddressID,
              dwAddressMode,
              lpsAddress,
              dwSize
    );
}


LONG
WINAPI
lineGetAddressStatusW(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetAddressStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAddressStatus
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetAddressStatus"));
}


LONG
WINAPI
lineGetAddressStatusA(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    LONG    lResult;
    PWSTR   szTempPtr = NULL;


    if ( IsBadWritePtr(lpAddressStatus, sizeof(LINEADDRESSSTATUS)) )
    {
       LOG((TL_ERROR, "lineGetAddressStatus: Bad lpAddressStatus pointer"));
       return LINEERR_INVALPOINTER;
    }

    lResult = lineGetAddressStatusW(
        hLine,
        dwAddressID,
        lpAddressStatus
        );


    if (lResult == 0)
    {
        DWORD         i;
        LPLINEFORWARD lplf;


        lplf = (LPLINEFORWARD) (((LPBYTE)lpAddressStatus) +
                                 lpAddressStatus->dwForwardOffset);

        for (i = 0; i < lpAddressStatus->dwForwardNumEntries;  i++, lplf++)
        {
            WideStringToNotSoWideString(
                (LPBYTE) lpAddressStatus,
                &(lplf->dwCallerAddressSize)
                );

            WideStringToNotSoWideString(
                (LPBYTE) lpAddressStatus,
                &(lplf->dwDestAddressSize)
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetAddressStatus(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    return lineGetAddressStatusA(
              hLine,
              dwAddressID,
              lpAddressStatus
    );
}


LONG
WINAPI
lineGetAgentActivityListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentActivityList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentActivityList,// pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentActivityList // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentActivityList )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentActivityList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetAgentActivityListW"));

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentActivityListAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentActivityListAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD                   dwSize  = (DWORD) pMsg->Param4;
        LPLINEAGENTACTIVITYLIST lpAgentActivityList = (LPLINEAGENTACTIVITYLIST)
                                    ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD                       dw, dwNumEntries;
            LPLINEAGENTACTIVITYENTRY    lplaae;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentActivityList, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lplaae = (LPLINEAGENTACTIVITYENTRY)(((LPBYTE)lpAgentActivityList) +
                lpAgentActivityList->dwListOffset);

            dwNumEntries = lpAgentActivityList->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lplaae++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpAgentActivityList,
                    &(lplaae->dwNameSize)
                    );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentActivityListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentActivityList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentActivityListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentActivityList,// pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentActivityList // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentActivityList )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentActivityList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentActivityListA");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lGetAgentCaps),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAppAPIVersion,
            (ULONG_PTR) lpAgentCaps,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentCaps         // pass data
        },

        {
            Dword,
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };

    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentCaps )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentCaps, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[5] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentCapsW");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentCapsAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentCapsAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD           dwSize  = (DWORD) pMsg->Param4;
        LPLINEAGENTCAPS lpAgentCaps = (LPLINEAGENTCAPS) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentCaps, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            WideStringToNotSoWideString(
                (LPBYTE) lpAgentCaps,
                &lpAgentCaps->dwAgentHandlerInfoSize
                );
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lGetAgentCaps),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentCapsAPostProcess),
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAppAPIVersion,
            (ULONG_PTR) lpAgentCaps,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentCaps         // pass data
        },

        {
            Dword,
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if ( !lpAgentCaps )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentCaps, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[5] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentCapsA");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentGroupListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList,   // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentGroupList    // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentGroupList )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentGroupListW");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentGroupListAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentGroupListAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD                   dwSize = (DWORD) pMsg->Param4;
        LPLINEAGENTGROUPLIST    lpAgentGroupList = (LPLINEAGENTGROUPLIST)
                                    ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD                   dw, dwNumEntries;
            LPLINEAGENTGROUPENTRY   lplage;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentGroupList, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lplage = (LPLINEAGENTGROUPENTRY)(((LPBYTE) lpAgentGroupList) +
                lpAgentGroupList->dwListOffset);

            dwNumEntries = lpAgentGroupList->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lplage++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpAgentGroupList,
                    &(lplage->dwNameSize)
                    );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentGroupListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentGroupListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList,   // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentGroupList    // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if ( !lpAgentGroupList )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentGroupListA");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentInfo(
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTINFO         lpAgentInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentInfo),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) lpAgentInfo,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentInfo )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentInfo, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentInfo");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentSessionInfo(
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentSessionInfo),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgentSession,
            (ULONG_PTR) lpAgentSessionInfo, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentSessionInfo  // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentSessionInfo )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentSessionInfo, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentSessionInfo");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentSessionList(
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTSESSIONLIST  lpAgentSessionList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentSessionList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) lpAgentSessionList, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentSessionList  // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentSessionList )
    {
        return LINEERR_INVALPARAM;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentSessionList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentSessionList");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentStatus),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentStatus,      // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentStatus       // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentStatus, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentStatusW");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentStatusAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentStatusAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD               dwSize = (DWORD) pMsg->Param4;
        LPLINEAGENTSTATUS   lpAgentStatus = (LPLINEAGENTSTATUS) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD                   dw, dwNumEntries;
            LPLINEAGENTGROUPENTRY   lplage;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentStatus, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lplage = (LPLINEAGENTGROUPENTRY) (((LPBYTE) lpAgentStatus) +
                lpAgentStatus->dwGroupListOffset);

            dwNumEntries = lpAgentStatus->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lplage++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE)lpAgentStatus,
                    &(lplage->dwNameSize)
                    );
            }

            WideStringToNotSoWideString(
                (LPBYTE)lpAgentStatus,
                &lpAgentStatus->dwActivitySize
                );

        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentStatus),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentStatusAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentStatus,      // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentStatus       // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentStatus, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetAgentStatusA"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAppPriorityW(
    LPCWSTR             lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGetAppPriority),

        {
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) dwMediaMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpdwPriority
        },

        {
            lpszW,      // app name
            Dword,      // media mode
            Dword,      // ext id (offset)
            Dword,      // ext id (size)
            Dword,      // request mode
            Dword,      // ext name total size
            lpDword     // lp pri
        }
    };


    if (dwMediaMode & 0xff000000)
    {
        if ((LPVOID) lpExtensionName == (LPVOID) lpdwPriority)
        {
            return LINEERR_INVALPOINTER;
        }


        //
        // We have to do some arg list munging here (adding an extra arg)
        //

        //
        // Set lpExtensionID, the following Size arg,
        // lpExtensionName, and the following MinSize
        // Type's and Value appropriately since they're
        // valid args in this case
        //

        funcArgs.ArgTypes[2] = lpSet_SizeToFollow;
        funcArgs.Args[2]     = (ULONG_PTR) lpExtensionID;
        funcArgs.ArgTypes[3] = Size;
        funcArgs.Args[3]     = (ULONG_PTR) sizeof (LINEEXTENSIONID);
        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpExtensionName;
    }

    if ( TAPIIsBadStringPtrW(lpszAppName, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetAppPriorityW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineGetAppPriority"));
}


LONG
WINAPI
lineGetAppPriorityA(
    LPCSTR              lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGetAppPriority),

        {
            (ULONG_PTR) 0,                  //  (DWORD) lpszAppName,
            (ULONG_PTR) dwMediaMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpdwPriority
        },

        {
            lpszW,      // app name
            Dword,      // media mode
            Dword,      // ext id (offset)
            Dword,      // ext id (size)
            Dword,      // request mode
            Dword,      // ext name total size
            lpDword     // lp pri
        }
    };


    if (dwMediaMode & 0xff000000)
    {
        //
        // We have to do some arg list munging here (adding an extra arg)
        //

        //
        // Set lpExtensionID, the following Size arg,
        // lpExtensionName, and the following MinSize
        // Type's and Value appropriately since they're
        // valid args in this case
        //

        funcArgs.ArgTypes[2] = lpSet_SizeToFollow;
        funcArgs.Args[2]     = (ULONG_PTR) lpExtensionID;
        funcArgs.ArgTypes[3] = Size;
        funcArgs.Args[3]     = (ULONG_PTR) sizeof (LINEEXTENSIONID);
        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpExtensionName;
    }

    if ( IsBadStringPtrA(lpszAppName, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetAppPriorityA"));
        return( LINEERR_INVALPOINTER );
    }

    funcArgs.Args[0] = (ULONG_PTR) NotSoWideStringToWideString(
        lpszAppName,
        (DWORD) -1
        );

    lResult = (DOFUNC (&funcArgs, "lineGetAppPriority"));

    if (funcArgs.Args[0])
    {
        ClientFree ((LPVOID) funcArgs.Args[0]);
    }

    return lResult;
}


LONG
WINAPI
lineGetAppPriority(
    LPCSTR              lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
    return lineGetAppPriorityA(
              lpszAppName,
              dwMediaMode,
              lpExtensionID,
              dwRequestMode,
              lpExtensionName,
              lpdwPriority
    );
}


LONG
WINAPI
lineGetCallInfoW(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallInfo),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallInfo
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetCallInfo"));
}


LONG
WINAPI
lineGetCallInfoA(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    LONG lResult;

    lResult = lineGetCallInfoW(
                    hCall,
                    lpCallInfo
                    );

    if ( 0 == lResult )
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCallerIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCallerIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCalledIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCalledIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwConnectedIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwConnectedIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectionIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectionIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectingIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectingIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwAppNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwDisplayableAddressSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCalledPartySize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCommentSize)
            );

/*
        //
        // Note: per TNixon (3/21/96), none of the following are guaranteed
        //       to be in ascii format, so we don't want to convert them
        //

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwDisplaySize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwHighLevelCompSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwLowLevelCompSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwChargingInfoSize)
            );
*/
    }

    return lResult;
}


LONG
WINAPI
lineGetCallInfo(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    return lineGetCallInfoA(
              hCall,
              lpCallInfo
    );
}


LONG
WINAPI
lineGetCallStatus(
    HCALL   hCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallStatus),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetCallStatus"));
}


LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL   hCall,
    LPLINECALLLIST  lpCallList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC| 2, lGetConfRelatedCalls),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallList
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetConfRelatedCalls"));
}


LONG
WINAPI
lineGetCountryW(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountry),

        {
            (ULONG_PTR) dwCountryID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpLineCountryList
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    if (
          ( TAPI_CURRENT_VERSION != dwAPIVersion )
        &&
          ( 0x00020001 != dwAPIVersion )
        &&
          ( 0x00020000 != dwAPIVersion )
        &&
          ( 0x00010004 != dwAPIVersion )
        &&
          ( 0x00010003 != dwAPIVersion )
       )
    {
       LOG((TL_ERROR, "lineGetCountryW - bad API version 0x%08lx", dwAPIVersion));
       return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetCountry"));
}


LONG
WINAPI
lineGetCountryA(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    LONG    lResult;
    DWORD   n;


    lResult = lineGetCountryW (dwCountryID, dwAPIVersion, lpLineCountryList);

    if (lResult == 0)
    {
        //
        // Go through the list of countries and change from Unicode to ANSI
        //

        LPLINECOUNTRYENTRY lpce;


        lpce = (LPLINECOUNTRYENTRY) (((LPBYTE) lpLineCountryList) +
            lpLineCountryList->dwCountryListOffset);

        for (n = 0; n < lpLineCountryList->dwNumCountries; n++, lpce++)
        {
            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwCountryNameSize
                );

            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwSameAreaRuleSize
                );

            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwLongDistanceRuleSize
                );

            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwInternationalRuleSize
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetCountry(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    LPLINECOUNTRYLIST pTempList;
    LONG  lResult;
    DWORD             dwSize;

    if ( IsBadWritePtr(lpLineCountryList, sizeof(LINECOUNTRYLIST)) )
    {
        LOG((TL_ERROR,
            "lineGetCountry - bad pointer: lpLineCountryList [0x%p]",
            lpLineCountryList
            ));

        return LINEERR_INVALPOINTER;
    }

    if ( lpLineCountryList->dwTotalSize < sizeof(LINECOUNTRYLIST) )
    {
        LOG((TL_ERROR,
            "lineGetCountry - dwTotalSize less than sizeof(LINECOUNTRYLIST)"
            ));

        return LINEERR_INVALPOINTER;
    }

    dwSize = lpLineCountryList->dwTotalSize * 2;

    while (TRUE)
    {
        pTempList = ClientAlloc( dwSize );

        if (NULL == pTempList)
        {
            LOG((TL_ERROR,
                "lineGetCountry - alloc failed for [x%lx] bytes",
                dwSize
                ));

            return( LINEERR_NOMEM );
        }

        pTempList->dwTotalSize = dwSize;

        lResult = lineGetCountryA(
                                  dwCountryID,
                                  dwAPIVersion,
                                  pTempList
                                 );

        // hack - if the structure isn't big enough
        // realloc ourselves.
        if (pTempList->dwNeededSize <= pTempList->dwTotalSize)
        {
            break;
        }

        dwSize = pTempList->dwNeededSize;

        ClientFree( pTempList );

        pTempList = NULL;

    } // while


    if ( 0 == lResult )
    {
        DWORD dwNewUsedSize = 0; // = sizeof(LINECOUNTRYLIST);
        DWORD i;
        DWORD dwCurrentOffset = sizeof(LINECOUNTRYLIST) +
                    (sizeof(LINECOUNTRYENTRY) * pTempList->dwNumCountries);
        LPLINECOUNTRYENTRY pOldCountryEntry;
        LPLINECOUNTRYENTRY pNewCountryEntry;

        for (
              i=0;
              (i < pTempList->dwNumCountries);
              i++
            )
        {
            pOldCountryEntry = (LPLINECOUNTRYENTRY)
                ((PBYTE)(lpLineCountryList + 1) +
                    (i * sizeof(LINECOUNTRYENTRY)));

            pNewCountryEntry = (LPLINECOUNTRYENTRY)
                   ((PBYTE)(pTempList + 1) + (i * sizeof(LINECOUNTRYENTRY)));


            // check to see if there is enough space in the buffer.
            // add 1 because we're starting with an offset, and we
            // need to convert it to a size.
            dwNewUsedSize = dwCurrentOffset +
                            pNewCountryEntry->dwCountryNameSize +
                            pNewCountryEntry->dwSameAreaRuleSize +
                            pNewCountryEntry->dwLongDistanceRuleSize +
                            pNewCountryEntry->dwInternationalRuleSize +
                            1;

            if (lpLineCountryList->dwTotalSize < dwNewUsedSize)
            {
                // i is checked at the end, so
                // subtract one here, because we're
                // not actually copying this entry
//                i--;
                break;
            }

            pOldCountryEntry->dwCountryID =
                pNewCountryEntry->dwCountryID;
            pOldCountryEntry->dwCountryCode =
                pNewCountryEntry->dwCountryCode;
            pOldCountryEntry->dwNextCountryID =
                pNewCountryEntry->dwNextCountryID;
            pOldCountryEntry->dwCountryNameSize =
                pNewCountryEntry->dwCountryNameSize;
            pOldCountryEntry->dwSameAreaRuleSize =
                pNewCountryEntry->dwSameAreaRuleSize;
            pOldCountryEntry->dwLongDistanceRuleSize =
                pNewCountryEntry->dwLongDistanceRuleSize;
            pOldCountryEntry->dwInternationalRuleSize =
                pNewCountryEntry->dwInternationalRuleSize;


            //
            // Copy Country name
            //

            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwCountryNameOffset,
                pNewCountryEntry->dwCountryNameSize
                );

            pOldCountryEntry->dwCountryNameOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwCountryNameSize;


            //
            // Copy same area rule
            //
            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwSameAreaRuleOffset,
                pNewCountryEntry->dwSameAreaRuleSize
                );

            pOldCountryEntry->dwSameAreaRuleOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwSameAreaRuleSize;


            //
            // Copy long distance rule
            //
            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwLongDistanceRuleOffset,
                pNewCountryEntry->dwLongDistanceRuleSize
                );

            pOldCountryEntry->dwLongDistanceRuleOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwLongDistanceRuleSize;


            //
            // Copy international rule
            //
            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwInternationalRuleOffset,
                pNewCountryEntry->dwInternationalRuleSize
                );

            pOldCountryEntry->dwInternationalRuleOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwInternationalRuleSize;


//            dwNewUsedSize += sizeof(LINECOUNTRYENTRY) +
//                pOldCountryEntry->dwCountryNameSize       +
//                pOldCountryEntry->dwSameAreaRuleSize      +
//                pOldCountryEntry->dwLongDistanceRuleSize  +
//                pOldCountryEntry->dwInternationalRuleSize ;

        }


        //
        // Did we stop short?
        //
        if ( i < pTempList->dwNumCountries )
        {
            lpLineCountryList->dwNeededSize = pTempList->dwNeededSize;
        }
        else
        {
            lpLineCountryList->dwNeededSize = dwNewUsedSize;
            lpLineCountryList->dwUsedSize = dwNewUsedSize;
            lpLineCountryList->dwNumCountries = pTempList->dwNumCountries;
            lpLineCountryList->dwCountryListSize =
                pTempList->dwNumCountries * sizeof(LINECOUNTRYENTRY);
            lpLineCountryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);
        }
    }


    ClientFree( pTempList );


    return lResult;
}


LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP        hLineApp,
    DWORD           dwDeviceID,
    DWORD           dwAPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetDevCaps),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) lpLineDevCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        goto ExitHere;
    }

    lResult = (DOFUNC (&funcArgs, "lineGetDevCaps"));

    if ( 0 == lResult )
    {
        lpLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
lineGetDevCapsA(
    HLINEAPP        hLineApp,
    DWORD           dwDeviceID,
    DWORD           dwAPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    LONG lResult;

    lResult = lineGetDevCapsW(
                    hLineApp,
                    dwDeviceID,
                    dwAPIVersion,
                    dwExtVersion,
                    lpLineDevCaps
                    );

    if (lResult == 0)
    {
        lpLineDevCaps->dwStringFormat = STRINGFORMAT_ASCII;

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwProviderInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwSwitchInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwLineNameSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwTerminalTextSize
            );

        if (lpLineDevCaps->dwTerminalTextEntrySize)
        {
            lpLineDevCaps->dwTerminalTextEntrySize /= sizeof(WCHAR);
        }

        if (dwAPIVersion >= 0x00020000)
        {
            WideStringToNotSoWideString(
                (LPBYTE) lpLineDevCaps,
                &lpLineDevCaps->dwDeviceClassesSize
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP        hLineApp,
    DWORD           dwDeviceID,
    DWORD           dwAPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    return lineGetDevCapsA(
                 hLineApp,
                 dwDeviceID,
                 dwAPIVersion,
                 dwExtVersion,
                 lpLineDevCaps
    );
}


LONG
WINAPI
lineGetDevConfigW(
    DWORD   dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR  lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetDevConfig),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };


    if ( lpszDeviceClass && TAPIIsBadStringPtrW(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetDevConfigW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineGetDevConfig"));
}


LONG
WINAPI
lineGetDevConfigA(
    DWORD   dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCSTR  lpszDeviceClass
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetDevConfig),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            0                        //  (DWORD) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };


    if ( lpszDeviceClass && IsBadStringPtrA(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetDevConfigA"));
        return( LINEERR_INVALPOINTER );
    }

    funcArgs.Args[2] = (ULONG_PTR) NotSoWideStringToWideString(
        lpszDeviceClass,
        (DWORD) -1
        );

    lResult = (DOFUNC (&funcArgs, "lineGetDevConfig"));

    if ((LPVOID)funcArgs.Args[2])
    {
        ClientFree ((LPVOID)funcArgs.Args[2]);
    }

    return lResult;
}


LONG
WINAPI
lineGetDevConfig(
    DWORD   dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCSTR  lpszDeviceClass
    )
{
    return lineGetDevConfigA(
              dwDeviceID,
              lpDeviceConfig,
              lpszDeviceClass
    );
}


LONG
WINAPI
lineGetGroupListA(
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lGetGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentGroupListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpGroupList         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[2] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetGroupListA"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetGroupListW(
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lGetGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpGroupList         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[2] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetAgentGroupListW"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetIconW(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetIcon),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) lphIcon
        },

        {
            Dword,
            lpszW,
            lpDword
        }
    };


    if (IsBadDwordPtr ((LPDWORD) lphIcon))
    {
        LOG((TL_ERROR, "lphIcon is an invalid pointer [0x%p]!", lphIcon));
        return LINEERR_INVALPOINTER;
    }

    if (lpszDeviceClass == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
    }

    return DOFUNC (&funcArgs, "lineGetIcon");
}


LONG
WINAPI
lineGetIconA(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszDeviceClass  &&  IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        LOG((TL_ERROR,
            "Bad class name pointer passed into lineGetIconA [0x%p]",
            lpszDeviceClass
            ));

        return LINEERR_INVALPOINTER;
    }

    szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);

    lResult = lineGetIconW (dwDeviceID, szTempPtr, lphIcon);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}



LONG
WINAPI
lineGetIcon(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    return (lineGetIconA (dwDeviceID, lpszDeviceClass, lphIcon));
}


LONG
WINAPI
lineGetIDW(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR lpszDeviceClass
    )
{

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetID),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
            lpszW
        }
    };

    LPVARSTRING lpDeviceIDTemp = NULL;
    DWORD       dwNumDevices;
    DWORD       dwBufSize;
    DWORD       dwResult;
    DWORD       dwDeviceId1, dwDeviceId2;
    BOOL        bDoItAgain = FALSE;

    if (TAPIIsBadStringPtrW (lpszDeviceClass, (UINT)-1) ||
        lstrlenW(lpszDeviceClass) == 0)
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in lineGetIDW"));
        return( LINEERR_INVALPOINTER);
    }

    if ( IsBadWritePtr(lpDeviceID, sizeof(VARSTRING)) )
    {
        LOG((TL_ERROR, "Bad lpDeviceID in lineGetIDW"));
        return( LINEERR_INVALPOINTER);
    }

    //
    // if the request is for a wave device, call LGetIDEx
    //
    if (!_wcsicmp(lpszDeviceClass, L"wave/in")  ||
        !_wcsicmp(lpszDeviceClass, L"wave/out") ||
        !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
        !_wcsicmp(lpszDeviceClass, L"midi/out") ||
        !_wcsicmp(lpszDeviceClass, L"wave/in/out")
       )
    {
        dwNumDevices = _wcsicmp(lpszDeviceClass, L"wave/in/out") ? 1 : 2;
        dwBufSize = lpDeviceID->dwTotalSize + dwNumDevices * WAVE_STRING_ID_BUFFER_SIZE;
        do
        {
            //
            // Allocate additional memory for the device string ID
            //
            lpDeviceIDTemp = (LPVARSTRING)ClientAlloc (dwBufSize);
            if (!lpDeviceIDTemp)
            {
                LOG((TL_ERROR, "Failed to allocate memory"));
                return( LINEERR_NOMEM );
            }
            lpDeviceIDTemp->dwTotalSize = dwBufSize;
            funcArgs.Flags = MAKELONG (LINE_FUNC | SYNC | 6, lGetIDEx);
            funcArgs.Args[4] = (ULONG_PTR)lpDeviceIDTemp;

            //
            // Call LGetIDEx
            //
            dwResult = DOFUNC (&funcArgs, "lineGetIDEx");
            if (dwResult)
            {
                LOG((TL_ERROR, "lineGetIDEx failed with x%x", dwResult));
                ClientFree (lpDeviceIDTemp);
                return dwResult;
            }

            if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize && !bDoItAgain)
            {
                LOG((TL_INFO, 
                     "lineGetIDEx returned needed size (%d) bigger than total size (%d) -> need to realloc", 
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
                dwBufSize = lpDeviceIDTemp->dwNeededSize;
                ClientFree ( lpDeviceIDTemp );
                bDoItAgain = TRUE;
            }
            else
            {
                bDoItAgain = FALSE;
            }
            
        } while (bDoItAgain);

        if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize)
        {
            LOG((TL_ERROR, "needed size (%d) still bigger than total size (%d)",
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
            ClientFree (lpDeviceIDTemp);
            return LINEERR_OPERATIONFAILED;
        }

        //
        // Get the device ID from string ID
        //
        if (dwNumDevices == 1)
        {
            if (!WaveStringIdToDeviceId (
                (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset),
                lpszDeviceClass,
                &dwDeviceId1)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return LINEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
            }
        }
        else
        {
            LPWSTR szString1 = (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset);

            if (!WaveStringIdToDeviceId (
                    szString1,
                    L"wave/in",
                    &dwDeviceId1) ||
                !WaveStringIdToDeviceId (
                    (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset + wcslen(szString1)),
                    L"wave/out",
                    &dwDeviceId2)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return LINEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + 2 * sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = 2 * sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
                *((DWORD *)(lpDeviceID + 1) + 1) = dwDeviceId2;
            }
        }
        ClientFree (lpDeviceIDTemp);
        return NO_ERROR;
    }
    else
    {
        return (DOFUNC (&funcArgs, "lineGetID"));
    }

}


LONG
WINAPI
lineGetIDA(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCSTR  lpszDeviceClass
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDeviceClass, (UINT)-1) ||
        lstrlenA(lpszDeviceClass) == 0)
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in lineGetIDA"));
        return( LINEERR_INVALPOINTER);
    }

    szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);
    if (NULL == szTempPtr)
    {
        return LINEERR_NOMEM;
    }

    lResult = lineGetIDW(
        hLine,
        dwAddressID,
        hCall,
        dwSelect,
        lpDeviceID,
        szTempPtr
        );

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineGetID(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCSTR  lpszDeviceClass
    )
{
    return lineGetIDA(
              hLine,
              dwAddressID,
              hCall,
              dwSelect,
              lpDeviceID,
              lpszDeviceClass
    );
}


LONG
WINAPI
lineGetLineDevStatusW(
    HLINE   hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpLineDevStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetLineDevStatus"));
}


LONG
WINAPI
lineGetLineDevStatusA(
    HLINE   hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    DWORD   dwAPIVersion;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpLineDevStatus,
            (ULONG_PTR) &dwAPIVersion
        },

        {
            Dword,
            lpGet_Struct,
            lpDword
        }
    };
    LONG lResult;


    if ((lResult = DOFUNC (&funcArgs, "lineGetLineDevStatus")) == 0)
    {
        if (dwAPIVersion >= 0x00020000)
        {
            DWORD           i;
            LPLINEAPPINFO   lplai;


            lplai = (LPLINEAPPINFO) (((LPBYTE)lpLineDevStatus) +
                lpLineDevStatus->dwAppInfoOffset);

            for (i = 0; i < lpLineDevStatus->dwNumOpens; i++, lplai++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwMachineNameSize
                    );

                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwUserNameSize
                    );

                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwModuleFilenameSize
                    );

                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwFriendlyNameSize
                    );
            }
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetLineDevStatus(
    HLINE           hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    return lineGetLineDevStatusA (hLine, lpLineDevStatus);
}


LONG
WINAPI
lineGetMessage(
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    )
{
    return (xxxGetMessage (TRUE, hLineApp, lpMessage, dwTimeout));
}


LONG
WINAPI
lineGetNewCalls(
    HLINE           hLine,
    DWORD           dwAddressID,
    DWORD           dwSelect,
    LPLINECALLLIST  lpCallList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetNewCalls),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) lpCallList
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetNewCalls"));
}


LONG
WINAPI
lineGetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPDWORD lpdwNumRings
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetNumRings),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpdwNumRings
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "lineGetNumRings"));
}


LONG
WINAPI
lineGetProviderListW(
    DWORD   dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    HANDLE      hProvidersMutex;
    LONG        lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetProviderList),

        {
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) lpProviderList
        },

        {
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT ("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        return LINEERR_OPERATIONFAILED;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);

    lResult = DOFUNC (&funcArgs, "lineGetProviderList");
    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }
    return lResult;
}


LONG
WINAPI
lineGetProviderListA(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    LONG lResult;


    lResult = lineGetProviderListW (dwAPIVersion, lpProviderList);

    if (lResult == 0)
    {
        DWORD               i;
        LPLINEPROVIDERENTRY lplpe;


        lplpe = (LPLINEPROVIDERENTRY) (((LPBYTE)lpProviderList) +
            lpProviderList->dwProviderListOffset);

        for (i = 0; i < lpProviderList->dwNumProviders; i++, lplpe++)
        {
            WideStringToNotSoWideString(
                (LPBYTE)lpProviderList,
                &(lplpe->dwProviderFilenameSize)
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetProviderList(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    return lineGetProviderListA (dwAPIVersion, lpProviderList);
}


LONG
WINAPI
lineGetProxyStatus(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAppAPIVersion,
    LPLINEPROXYREQUESTLIST  lpLineProxyReqestList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetProxyStatus),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAppAPIVersion,
            (ULONG_PTR) lpLineProxyReqestList
        },

        {
            hXxxApp,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAppAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetProxyStatus"));
}


LONG
WINAPI
lineGetQueueInfo(
    HLINE               hLine,
    DWORD               dwQueueID,
    LPLINEQUEUEINFO     lpLineQueueInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetQueueInfo),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwQueueID,
            (ULONG_PTR) lpLineQueueInfo,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpLineQueueInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpLineQueueInfo )
    {
        return LINEERR_INVALPARAM;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpLineQueueInfo, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetQueueInfo"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}

void
PASCAL
lineGetQueueListAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetQueueListAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD           dwSize  = (DWORD) pMsg->Param4;
        LPLINEQUEUELIST lpQueueList = (LPLINEQUEUELIST) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD               dw, dwNumEntries;
            LPLINEQUEUEENTRY    lpqe;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpQueueList, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lpqe = (LPLINEQUEUEENTRY)(((LPBYTE)lpQueueList) +
                lpQueueList->dwListOffset);

            dwNumEntries = lpQueueList->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lpqe++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpQueueList,
                    &(lpqe->dwNameSize)
                    );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetQueueListA(
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lGetQueueList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetQueueListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupID,
            (ULONG_PTR) sizeof( GUID ),
            (ULONG_PTR) lpQueueList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpQueueList         // pass data
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpQueueList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetQueueListA"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetQueueListW(
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lGetQueueList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupID,
            (ULONG_PTR) sizeof( GUID ),
            (ULONG_PTR) lpQueueList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpQueueList         // pass data
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpQueueList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetQueueList"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetRequestW(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPVOID      lpRequestBuffer
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetRequest),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) lpRequestBuffer,
            (ULONG_PTR) 0
        },

        {
            hXxxApp,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMAKECALLW);
    }
    else if (dwRequestMode == LINEREQUESTMODE_MEDIACALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMEDIACALLW);
    }

    return (DOFUNC (&funcArgs, "lineGetRequest"));
}


LONG
WINAPI
lineGetRequestA(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPVOID      lpRequestBuffer
    )
{
    LONG lResult;
    LPVOID pszTempPtr = NULL;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetRequest),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) 0,                //  (DWORD) lpRequestBuffer,
            (ULONG_PTR) 0
        },

        {
            hXxxApp,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (IsBadWritePtr(
            lpRequestBuffer,
            (dwRequestMode == LINEREQUESTMODE_MAKECALL ?
                sizeof (LINEREQMAKECALL) : sizeof (LINEREQMEDIACALL))
            ))
    {
        return LINEERR_INVALPOINTER;
    }

    if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMAKECALLW);

        pszTempPtr = ClientAlloc( sizeof(LINEREQMAKECALLW) );
        if (NULL == pszTempPtr)
        {
            return LINEERR_NOMEM;
        }
    }
    else if (dwRequestMode == LINEREQUESTMODE_MEDIACALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMEDIACALLW);

        pszTempPtr = ClientAlloc( sizeof(LINEREQMEDIACALLW) );
        if (NULL == pszTempPtr)
        {
            return LINEERR_NOMEM;
        }
    }

    funcArgs.Args[2] = (ULONG_PTR) pszTempPtr;


    lResult = (DOFUNC (&funcArgs, "lineGetRequest"));


    if ( 0 == lResult )
    {
        if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
        {
            LPLINEREQMAKECALLW lplrmc = pszTempPtr;

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szDestAddress,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szDestAddress,
                TAPIMAXDESTADDRESSSIZE,
                NULL,
                NULL
                );

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szAppName,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szAppName,
                TAPIMAXAPPNAMESIZE,
                NULL,
                NULL
                );

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szCalledParty,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szCalledParty,
                TAPIMAXCALLEDPARTYSIZE,
                NULL,
                NULL
                );

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szComment,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szComment,
                TAPIMAXCOMMENTSIZE,
                NULL,
                NULL
                );

        }
        else
        {

        // We don't currently support this...

//typedef struct linereqmediacallW_tag
//{
//    HWND        hWnd;
//    WPARAM      wRequestID;
//    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
//    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
//    DWORD       dwSize;
//    DWORD       dwSecure;
//    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
//    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
//    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
//    WCHAR       szComment[TAPIMAXCOMMENTSIZE];
//}

        }
    }


    if ( pszTempPtr )
    {
        ClientFree( pszTempPtr );
    }

    return lResult;
}


LONG
WINAPI
lineGetRequest(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPVOID      lpRequestBuffer
    )
{
    return lineGetRequestA (hLineApp, dwRequestMode, lpRequestBuffer);
}


LONG
WINAPI
lineGetStatusMessages(
    HLINE       hLine,
    LPDWORD     lpdwLineStates,
    LPDWORD     lpdwAddressStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetStatusMessages),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpdwLineStates,
            (ULONG_PTR) lpdwAddressStates
        },

        {
            Dword,
            lpDword,
            lpDword
        }
    };


    if (lpdwLineStates == lpdwAddressStates)
    {
        return LINEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "lineGetStatusMessages"));
}



LONG
WINAPI
lineHandoffW(
    HCALL   hCall,
    LPCWSTR lpszFileName,
    DWORD   dwMediaMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lHandoff),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszFileName,
            (ULONG_PTR) dwMediaMode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if (lpszFileName == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    return (DOFUNC (&funcArgs, "lineHandoff"));
}


LONG
WINAPI
lineHandoffA(
    HCALL   hCall,
    LPCSTR  lpszFileName,
    DWORD   dwMediaMode
    )
{
    LONG    lResult;
    LPWSTR  pTempPtr;


    if (lpszFileName)
    {
        if (IsBadStringPtrA (lpszFileName, (DWORD) -1))
        {
            return LINEERR_INVALPOINTER;
        }
        else if (!(pTempPtr = NotSoWideStringToWideString(
                        lpszFileName,
                        (DWORD) -1
                        )))
        {
            return LINEERR_NOMEM;
        }
    }
    else
    {
        pTempPtr = NULL;
    }

    lResult = lineHandoffW (hCall, pTempPtr, dwMediaMode);

    if (pTempPtr)
    {
        ClientFree (pTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineHandoff(
    HCALL   hCall,
    LPCSTR  lpszFileName,
    DWORD   dwMediaMode
    )
{
    return lineHandoffA (hCall, lpszFileName, dwMediaMode);
}


LONG
WINAPI
lineHold(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lHold),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineHold"));
}


PWSTR
PASCAL
MultiToWide(
    LPCSTR  lpStr
    )
{
    DWORD dwSize;
    PWSTR szTempPtr;


    dwSize = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpStr,
        -1,
        NULL,
        0
        );

    if ((szTempPtr = ClientAlloc ((dwSize + 1) * sizeof (WCHAR))))
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpStr,
            -1,
            szTempPtr,
            dwSize + 1
            );
    }

    return szTempPtr;
}


// Don't need this 'cause 2.0 apps must use lineInitializeEx()
//
//LONG
//WINAPI
//lineInitializeW(
//    LPHLINEAPP      lphLineApp,
//    HINSTANCE       hInstance,
//    LINECALLBACK    lpfnCallback,
//    LPCWSTR         lpszAppName,
//    LPDWORD         lpdwNumDevs
//    )
//{
//    return (xxxInitialize(
//        TRUE,
//        (LPVOID) lphLineApp,
//        hInstance,
//        lpfnCallback,
//        lpszAppName,
//        lpdwNumDevs,
//        NULL,
//        NULL
//#if DBG
//        ,"lineInitializeW"
//#endif
//        ));
//}


LONG
WINAPI
lineInitialize(
    LPHLINEAPP      lphLineApp,
    HINSTANCE       hInstance,
    LINECALLBACK    lpfnCallback,
    LPCSTR          lpszAppName,
    LPDWORD         lpdwNumDevs
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszAppName )
    {
        if ( IsBadStringPtrA (lpszAppName, (DWORD) -1))
        {
           LOG((TL_ERROR, "lineInitialize: Bad lpszAddName pointer"));
           return LINEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    }
    else
    {
        szTempPtr = NULL;
    }


    //
    // NOTE: the hack below for the lpInitExParam is for 16-bit apps,
    //       since the lpszAppName really points at a
    //       <friendly name>\0<module name>\0 string and we need the
    //       module name in xxxInitialize()
    //

    lResult = (xxxInitialize(
        TRUE,
        (LPVOID) lphLineApp,
        hInstance,
        lpfnCallback,
        szTempPtr,
        lpdwNumDevs,
        NULL,
#ifdef _WIN64
        NULL
#else
        (LPLINEINITIALIZEEXPARAMS)
            (((DWORD) lpfnCallback & 0xffff0000) == 0xffff0000 ?
                lpszAppName : NULL)
#endif
#if DBG
        ,"lineInitialize"
#endif
        ));

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineInitializeExW(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{

    if (IsBadDwordPtr (lpdwAPIVersion))
    {
        LOG((TL_ERROR,
            "lineInitializeExW: bad lpdwAPIVersion pointer (x%p)",
            lpdwAPIVersion
            ));

        return LINEERR_INVALPOINTER;
    }

    return (xxxInitialize(
        TRUE,
        (LPVOID) lphLineApp,
        hInstance,
        lpfnCallback,
        lpszFriendlyAppName,
        lpdwNumDevs,
        lpdwAPIVersion,
        (LPVOID) lpLineInitializeExParams
#if DBG
        ,"lineInitializeExW"
#endif
        ));
}


LONG
WINAPI
lineInitializeExA(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{
    LONG    lResult;
    WCHAR  *pszFriendlyAppNameW;


    if (lpszFriendlyAppName)
    {
        if (IsBadStringPtrA (lpszFriendlyAppName, (DWORD) -1))
        {
            LOG((TL_ERROR,
                "lineInitializeEx: bad lpszFriendlyAppName (x%p)",
                lpszFriendlyAppName
                ));

            return LINEERR_INVALPOINTER;
        }

        if (!(pszFriendlyAppNameW = MultiToWide (lpszFriendlyAppName)))
        {
            return LINEERR_INVALPOINTER;
        }
    }
    else
    {
        pszFriendlyAppNameW = NULL;
    }

    lResult = lineInitializeExW(
        lphLineApp,
        hInstance,
        lpfnCallback,
        pszFriendlyAppNameW,
        lpdwNumDevs,
        lpdwAPIVersion,
        lpLineInitializeExParams
        );

    if (pszFriendlyAppNameW)
    {
        ClientFree (pszFriendlyAppNameW);
    }

    return lResult;
}


void
PASCAL
lineMakeCallPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineMakeCallPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        HCALL   hCall   = (HCALL) pMsg->Param3;
        LPHCALL lphCall = (LPDWORD) ReferenceObject (ghHandleTable, pMsg->Param4, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param4, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPHCALL lphCallVDM = (LPHCALL) gpfnWOWGetVDMPointer (
                    (DWORD) lphCall,
                    sizeof(HCALL),
                    TRUE // fProtectedMode
                    );


                if (lphCallVDM)
                {
                    *lphCallVDM = hCall;
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                *lphCall = hCall;
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineMakeCallW(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lMakeCall),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    lResult = (DOFUNC (&funcArgs, "lineMakeCall"));
    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineMakeCallA(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    LONG    lResult;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lMakeCall),

        {
    