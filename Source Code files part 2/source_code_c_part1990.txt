                     reviewID,
                        name,
                        emailAddress,
                        comments}, this.SaveReportViolationOperationCompleted, userState);
        }
        
        private void OnSaveReportViolationOperationCompleted(object arg) {
            if ((this.SaveReportViolationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReportViolationCompleted(this, new SaveReportViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty) {
            this.SaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingValue, customProperty, null);
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, object userState) {
            if ((this.SaveReviewOperationCompleted == null)) {
                this.SaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewOperationCompleted);
            }
            this.InvokeAsync("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, this.SaveReviewOperationCompleted, userState);
        }
        
        private void OnSaveReviewOperationCompleted(object arg) {
            if ((this.SaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewCompleted(this, new SaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname) {
            object[] results = this.Invoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveReview(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname) {
            this.BulkSaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIDs, reviewFieldValues, ratingValue, customProperty, updateDate, nickname, null);
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname, object userState) {
            if ((this.BulkSaveReviewOperationCompleted == null)) {
                this.BulkSaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveReviewOperationCompleted);
            }
            this.InvokeAsync("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname}, this.BulkSaveReviewOperationCompleted, userState);
        }
        
        private void OnBulkSaveReviewOperationCompleted(object arg) {
            if ((this.BulkSaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveReviewCompleted(this, new BulkSaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReviewHelpfulness(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score) {
            this.SaveReviewHelpfulnessAsync(itemID, puid, msnGuid, reviewID, score, null);
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, object userState) {
            if ((this.SaveReviewHelpfulnessOperationCompleted == null)) {
                this.SaveReviewHelpfulnessOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewHelpfulnessOperationCompleted);
            }
            this.InvokeAsync("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, this.SaveReviewHelpfulnessOperationCompleted, userState);
        }
        
        private void OnSaveReviewHelpfulnessOperationCompleted(object arg) {
            if ((this.SaveReviewHelpfulnessCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewHelpfulnessCompleted(this, new SaveReviewHelpfulnessCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas) {
            object[] results = this.Invoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveUnauthRatings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas) {
            this.SaveUnauthRatingsAsync(contentTypeID, itemID, ratingScores, ratingCountDeltas, null);
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas, object userState) {
            if ((this.SaveUnauthRatingsOperationCompleted == null)) {
                this.SaveUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas}, this.SaveUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnSaveUnauthRatingsOperationCompleted(object arg) {
            if ((this.SaveUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveUnauthRatingsCompleted(this, new SaveUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndValidateReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty) {
            this.ValidateReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingValue, customProperty, null);
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, object userState) {
            if ((this.ValidateReviewOperationCompleted == null)) {
                this.ValidateReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateReviewOperationCompleted);
            }
            this.InvokeAsync("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, this.ValidateReviewOperationCompleted, userState);
        }
        
        private void OnValidateReviewOperationCompleted(object arg) {
            if ((this.ValidateReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateReviewCompleted(this, new ValidateReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdvanceStateCompletedEventHandler(object sender, AdvanceStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdvanceStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AdvanceStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameCompletedEventHandler(object sender, GetNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameSuggestionsCompletedEventHandler(object sender, GetNicknameSuggestionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameSuggestionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameSuggestionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageCompletedEventHandler(object sender, GetRatingAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public float rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageRollupCompletedEventHandler(object sender, GetRatingAverageRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public float rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserCompletedEventHandler(object sender, GetRatingByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserWithAverageCompletedEventHandler(object sender, GetRatingByUserWithAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserWithAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserWithAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int userRating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public float averageRating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMultipleRatingsByUserCompletedEventHandler(object sender, GetMultipleRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMultipleRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMultipleRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingsByUserCompletedEventHandler(object sender, GetRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.Guid userID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewByUserCompletedEventHandler(object sender, GetReviewByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review review {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsCompletedEventHandler(object sender, GetReviewsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsByUserCompletedEventHandler(object sender, GetReviewsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsRollupCompletedEventHandler(object sender, GetReviewsRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingsCompletedEventHandler(object sender, GetUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratingScores {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public long[] ratingCounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveNicknameCompletedEventHandler(object sender, SaveNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveRatingCompletedEventHandler(object sender, SaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveRatingCompletedEventHandler(object sender, BulkSaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReportViolationCompletedEventHandler(object sender, SaveReportViolationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReportViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReportViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewCompletedEventHandler(object sender, SaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveReviewCompletedEventHandler(object sender, BulkSaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewHelpfulnessCompletedEventHandler(object sender, SaveReviewHelpfulnessCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewHelpfulnessCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewHelpfulnessCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveUnauthRatingsCompletedEventHandler(object sender, SaveUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateReviewCompletedEventHandler(object sender, ValidateReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ValidateReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\RateMediaFDTest\common.cs ===
//------------------------------------------------------------------------------
// <copyright file="common.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <author>JeremyJ</author>
// <owner>JeremyJ</owner>
// <lastModifiedBy>JeremyJ</lastModifiedBy>
// <lastModifiedDate>03/18/2011</lastModifiedDate>
//------------------------------------------------------------------------------

namespace xonline.server.ratings.test
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.IO;
    using System.Management;
    using System.Net;
    using System.Threading;
    using System.Xml;
    
    using ServerTestFramework;
    using ServerTestFramework.LiveService;

    using xonline.common.sql.sqlclient;

    /// <summary>
    /// Common methods used across functional and stress tests
    /// </summary>
    public static class Common
    {
        /// <summary>
        /// Retrieves a mediaId of the specified media type
        /// </summary>
        /// <param name="desiredMediaType">The mediaTypeId of the mediaId to return</param>
        /// <returns>A mediaId of the specified mediaTypeId</returns>
        public static Guid GetMediaIdFromCatalog(int desiredMediaType)
        {
            Guid retrievedMediaId = Guid.Empty;

            using (SqlClient sqlClient = new SqlClient("fecatalogdbxbox", true))
            {
                string cmd = String.Format("SELECT TOP(1) mediaId, NEWID() AS randGuid FROM Media WHERE mediaTypeId='{0}' ORDER BY randGuid", desiredMediaType);
                sqlClient.Command.CommandText = cmd;
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                using (SqlDataReader sqlDataReader = sqlClient.Execute())
                {
                    if (sqlDataReader.HasRows)
                    {
                        while (sqlDataReader.Read())
                        {
                            retrievedMediaId = (Guid)sqlDataReader.GetSqlGuid(0);
                        }
                    }
                }
            }

            if (retrievedMediaId == Guid.Empty)
            {
                throw new Exception(String.Format("No results returned for mediaTypeId {0}.", desiredMediaType));
            }

            return retrievedMediaId;
        }

        /// <summary>
        /// Recycles the XBL Ratings FD IIS application pool
        /// </summary>
        public static void RecycleRatingsAppPool()
        {
            RecycleAppPool("ratings_int", "ratings", "Ratings-Ratings");
        }

        /// <summary>
        /// Recycles an application pool and hit a healthcheck based on the specified parameters
        /// </summary>
        /// <param name="component">The component endpoint used to connect to IIS and ping the healthcheck</param>
        /// <param name="virtualDirectory">The virtual directory of the component used as part of the healthcheck URL</param>
        /// <param name="appPool">The name of the actual applicatio pool to recycle</param>
        private static void RecycleAppPool(string component, string virtualDirectory, string appPool)
        {
            try
            {
                Global.RO.Info("Recycling the {0} app pool...", appPool);
                string componentMachineName = Global.XEnv.GetVirtualInterface(component).ToString();

                ConnectionOptions co = new ConnectionOptions();
                co.Impersonation = ImpersonationLevel.Impersonate;
                co.Authentication = AuthenticationLevel.PacketPrivacy;
                string objPath = String.Format("IISApplicationPool.Name='W3SVC/AppPools/{0}'", appPool);
                ManagementScope scope = new ManagementScope(@"\\" + componentMachineName.Split(':')[0] + @"\root\MicrosoftIISV2", co);
                using (ManagementObject mc = new ManagementObject(objPath))
                {
                    mc.Scope = scope;
                    mc.InvokeMethod("Recycle", null, null);
                    Global.RO.Info("Sucessfully recycled the {0} app pool!", appPool);
                }

                Global.RO.Info("Sleeping for 15 seconds after recycling {0} the app pool...", virtualDirectory);
                Thread.Sleep(TimeSpan.FromSeconds(15));

                Global.RO.Info("Pinging: " + String.Format("http://{0}/{1}/health.ashx", componentMachineName, virtualDirectory));

                // ping the watcher health check
                using (WebClient client = new WebClient())
                {
                    using (Stream stream = client.OpenRead(String.Format("http://{0}/{1}/health.ashx", componentMachineName, virtualDirectory)))
                    {
                        StreamReader reader = new StreamReader(stream);
                        string response = reader.ReadToEnd();
                        reader.Close();
                    }
                }
            }
            catch (Exception e)
            {
                throw new Exception(String.Format("Failed to recycle the {0} app pool! Error: {1}", appPool, e.Message), e);
            }
        }
    }

    // TODO: The code below was kept from the previous version of the RateMediaFDTest suite and could stand to be rewritten

    /// <summary>
    /// Provides ContentTypeMapping information for the current environment (from NPDB).
    /// </summary>
    public static class NPDB_MSNContentTypeMappings
    {
        /// <summary>
        /// List of ContentTypeIds
        /// </summary>
        private static List<string> contentTypeIdCollection = new List<string>();

        /// <summary>
        /// Dictionary of MediaTypeId and ContentTypeId pairs from the ratings_contenttype_mapping setting XML
        /// </summary>
        private static Dictionary<int, Guid> contentTypeMappingCollection = new Dictionary<int, Guid>();

        /// <summary>
        /// MediaTypeId to ContentTypeId mapping for full Xbox 360 games and Xbox 360 Games on Demand games (MediaTypeId 1)
        /// </summary>
        private static ContentTypeMapping fullXbox360Game = null;

        /// <summary>
        /// List of MediaTypeIds
        /// </summary>
        private static List<int> mediaTypeIdCollection = new List<int>();

        /// <summary>
        /// MediaTypeId to ContentTypeId mapping for full Xbox LIVE Arcade games (MediaTypeId 23)
        /// </summary>
        private static ContentTypeMapping xboxArcadeGame = null;

        /// <summary>
        /// MediaTypeId to ContentTypeId mapping for Xbox Original games (MediaTypeId 21)
        /// </summary>
        private static ContentTypeMapping xboxOriginalGame = null;

        /// <summary>
        /// MediaTypeId to ContentTypeId mapping for Xbox LIVE Indie games (MediaTypeId 37)
        /// </summary>
        private static ContentTypeMapping xnaCommunityGame = null;

        /// <summary>
        /// Initializes static members of the NPDB_MSNContentTypeMappings class
        /// </summary>
        static NPDB_MSNContentTypeMappings()
        {
            string contentTypeXml = Global.XEnv.GetSetting("ratings_contenttype_mapping");

            XmlDataDocument xmlDoc = new XmlDataDocument();
            xmlDoc.LoadXml(contentTypeXml);
            XmlNodeList xmlNodeList = xmlDoc.SelectNodes("root/contentTypeMapping");
            foreach (XmlNode var in xmlNodeList)
            {
                int mediaTypeId = Convert.ToInt32(var.Attributes["mediatype"].Value);
                Guid contentTypeId = new Guid(var.Attributes["contentTypeId"].Value);
                contentTypeMappingCollection.Add(mediaTypeId, contentTypeId);

                switch (mediaTypeId)
                {
                    case 1:
                        {
                            fullXbox360Game = new ContentTypeMapping();
                            fullXbox360Game.MediaTypeId = mediaTypeId;
                            fullXbox360Game.ContentTypeId = contentTypeId.ToString();
                            contentTypeIdCollection.Add(fullXbox360Game.ContentTypeId);
                            mediaTypeIdCollection.Add(fullXbox360Game.MediaTypeId);
                            break;
                        }

                    case 21:
                        {
                            xboxOriginalGame = new ContentTypeMapping();
                            xboxOriginalGame.ContentTypeId = contentTypeId.ToString();
                            xboxOriginalGame.MediaTypeId = mediaTypeId;
                            contentTypeIdCollection.Add(xboxOriginalGame.ContentTypeId);
                            mediaTypeIdCollection.Add(xboxOriginalGame.MediaTypeId);
                            break;
                        }

                    case 23:
                        {
                            xboxArcadeGame = new ContentTypeMapping();
                            xboxArcadeGame.ContentTypeId = contentTypeId.ToString();
                            xboxArcadeGame.MediaTypeId = mediaTypeId;
                            contentTypeIdCollection.Add(xboxArcadeGame.ContentTypeId);
                            mediaTypeIdCollection.Add(xboxArcadeGame.MediaTypeId);
                            break;
                        }

                    case 37:
                        {
                            xnaCommunityGame = new ContentTypeMapping();
                            xnaCommunityGame.ContentTypeId = contentTypeId.ToString();
                            xnaCommunityGame.MediaTypeId = mediaTypeId;
                            contentTypeIdCollection.Add(xnaCommunityGame.ContentTypeId);
                            mediaTypeIdCollection.Add(xnaCommunityGame.MediaTypeId);
                            break;
                        }

                    default:
                        {
                            break;
                        }
                }
            }
        }

        /// <summary>
        /// Gets or sets the contentTypeIdCollection field
        /// </summary>
        public static List<string> ContentTypeIdCollection
        {
            get { return NPDB_MSNContentTypeMappings.contentTypeIdCollection; }
            set { NPDB_MSNContentTypeMappings.contentTypeIdCollection = value; }
        }

        /// <summary>
        /// Gets or sets the contentTypeMappingCollection field
        /// </summary>
        public static Dictionary<int, Guid> ContentTypeMappingCollection
        {
            get { return NPDB_MSNContentTypeMappings.contentTypeMappingCollection; }
            set { NPDB_MSNContentTypeMappings.contentTypeMappingCollection = value; }
        }

        /// <summary>
        /// Gets or sets the fullXbox360Game field
        /// </summary>
        public static ContentTypeMapping FullXbox360Game
        {
            get { return NPDB_MSNContentTypeMappings.fullXbox360Game; }
            set { NPDB_MSNContentTypeMappings.fullXbox360Game = value; }
        }

        /// <summary>
        /// Gets or sets the mediaTypeIdCollection field
        /// </summary>
        public static List<int> MediaTypeIdCollection
        {
            get { return NPDB_MSNContentTypeMappings.mediaTypeIdCollection; }
            set { NPDB_MSNContentTypeMappings.mediaTypeIdCollection = value; }
        }

        /// <summary>
        /// Gets or sets the xboxArcadeGame field
        /// </summary>
        public static ContentTypeMapping XboxArcadeGame
        {
            get { return NPDB_MSNContentTypeMappings.xboxArcadeGame; }
            set { NPDB_MSNContentTypeMappings.xboxArcadeGame = value; }
        }

        /// <summary>
        /// Gets or sets the xboxOriginalsGame field
        /// </summary>
        public static ContentTypeMapping XboxOriginalGame
        {
            get { return NPDB_MSNContentTypeMappings.xboxOriginalGame; }
            set { NPDB_MSNContentTypeMappings.xboxOriginalGame = value; }
        }

        /// <summary>
        /// Gets or sets the xnaCommunityGame field
        /// </summary>
        public static ContentTypeMapping XnaCommunityGame
        {
            get { return NPDB_MSNContentTypeMappings.xnaCommunityGame; }
            set { NPDB_MSNContentTypeMappings.xnaCommunityGame = value; }
        }
    }

    /// <summary>
    /// Contains a mediaType/ContentType pairing.
    /// </summary>
    public class ContentTypeMapping
    {
        /// <summary>
        /// The contentTypeId to map the mediaTypeId to
        /// </summary>
        private string contentTypeId;

        /// <summary>
        /// A mediaTypeId to map the contentTypeId to
        /// </summary>
        private int mediaTypeId;

        /// <summary>
        /// Gets or sets the contentTypeId field
        /// </summary>
        public string ContentTypeId
        {
            get { return this.contentTypeId; }
            set { this.contentTypeId = value; }
        }

        /// <summary>
        /// Gets or sets the mediaTypeId field
        /// </summary>
        public int MediaTypeId
        {
            get { return this.mediaTypeId; }
            set { this.mediaTypeId = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\MSNRatingServiceTest\MSNRatingServiceMock.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.server.ratings.test.ratingstest
{
    class MSNRatingServiceMock
    {
        public int SaveMediaRatingFromUserWithFailure(FailureType failure, Guid passportPuid, Int32 mediaTypeId, Guid mediaId, String countryCode, Single ratingValue)
        {
            return (int)failure;
        }
    }

    public enum FailureType
    {
        Success = 0,
        InvalidContentTypeId = 10003,
        InvalidItemId = 10005,
        PuidCannotBeZero = 10007,
        TooManyRatingAttributeIds = 10029,
        UnspecifiedError = 99999
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsUnitTests\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\Emulator\MSNRR.MultiRating.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.MultiRating {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MultiRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public partial class MultiRating : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AdvanceStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameSuggestionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserWithAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMultipleRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReportViolationOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewHelpfulnessOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateReviewOperationCompleted;
        
        /// <remarks/>
        public MultiRating() {
            this.Url = "http://rr.msn-int.com/rrwebservice/multirating.asmx";
        }
        
        /// <remarks/>
        public event AdvanceStateCompletedEventHandler AdvanceStateCompleted;
        
        /// <remarks/>
        public event GetNicknameCompletedEventHandler GetNicknameCompleted;
        
        /// <remarks/>
        public event GetNicknameSuggestionsCompletedEventHandler GetNicknameSuggestionsCompleted;
        
        /// <remarks/>
        public event GetRatingAverageCompletedEventHandler GetRatingAverageCompleted;
        
        /// <remarks/>
        public event GetRatingAverageRollupCompletedEventHandler GetRatingAverageRollupCompleted;
        
        /// <remarks/>
        public event GetRatingByUserCompletedEventHandler GetRatingByUserCompleted;
        
        /// <remarks/>
        public event GetRatingByUserWithAverageCompletedEventHandler GetRatingByUserWithAverageCompleted;
        
        /// <remarks/>
        public event GetMultipleRatingsByUserCompletedEventHandler GetMultipleRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetRatingsByUserCompletedEventHandler GetRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewByUserCompletedEventHandler GetReviewByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsCompletedEventHandler GetReviewsCompleted;
        
        /// <remarks/>
        public event GetReviewsByUserCompletedEventHandler GetReviewsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsRollupCompletedEventHandler GetReviewsRollupCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingsCompletedEventHandler GetUnauthRatingsCompleted;
        
        /// <remarks/>
        public event SaveNicknameCompletedEventHandler SaveNicknameCompleted;
        
        /// <remarks/>
        public event SaveRatingCompletedEventHandler SaveRatingCompleted;
        
        /// <remarks/>
        public event BulkSaveRatingCompletedEventHandler BulkSaveRatingCompleted;
        
        /// <remarks/>
        public event SaveReportViolationCompletedEventHandler SaveReportViolationCompleted;
        
        /// <remarks/>
        public event SaveReviewCompletedEventHandler SaveReviewCompleted;
        
        /// <remarks/>
        public event BulkSaveReviewCompletedEventHandler BulkSaveReviewCompleted;
        
        /// <remarks/>
        public event SaveReviewHelpfulnessCompletedEventHandler SaveReviewHelpfulnessCompleted;
        
        /// <remarks/>
        public event SaveUnauthRatingsCompletedEventHandler SaveUnauthRatingsCompleted;
        
        /// <remarks/>
        public event ValidateReviewCompletedEventHandler ValidateReviewCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            object[] results = this.Invoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndAdvanceState(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            this.AdvanceStateAsync(contentTypeID, itemID, puid, msnGuid, keys, values, null);
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, object userState) {
            if ((this.AdvanceStateOperationCompleted == null)) {
                this.AdvanceStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdvanceStateOperationCompleted);
            }
            this.InvokeAsync("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, this.AdvanceStateOperationCompleted, userState);
        }
        
        private void OnAdvanceStateOperationCompleted(object arg) {
            if ((this.AdvanceStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdvanceStateCompleted(this, new AdvanceStateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNickname(long puid, System.Guid msnGuid, out string nickname) {
            object[] results = this.Invoke("GetNickname", new object[] {
                        puid,
                        msnGuid});
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNickname(long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNickname", new object[] {
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNickname(System.IAsyncResult asyncResult, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid) {
            this.GetNicknameAsync(puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid, object userState) {
            if ((this.GetNicknameOperationCompleted == null)) {
                this.GetNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameOperationCompleted);
            }
            this.InvokeAsync("GetNickname", new object[] {
                        puid,
                        msnGuid}, this.GetNicknameOperationCompleted, userState);
        }
        
        private void OnGetNicknameOperationCompleted(object arg) {
            if ((this.GetNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameCompleted(this, new GetNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNicknameSuggestions(string seed, out string[] suggestionList) {
            object[] results = this.Invoke("GetNicknameSuggestions", new object[] {
                        seed});
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNicknameSuggestions(string seed, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNicknameSuggestions", new object[] {
                        seed}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNicknameSuggestions(System.IAsyncResult asyncResult, out string[] suggestionList) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed) {
            this.GetNicknameSuggestionsAsync(seed, null);
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed, object userState) {
            if ((this.GetNicknameSuggestionsOperationCompleted == null)) {
                this.GetNicknameSuggestionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameSuggestionsOperationCompleted);
            }
            this.InvokeAsync("GetNicknameSuggestions", new object[] {
                        seed}, this.GetNicknameSuggestionsOperationCompleted, userState);
        }
        
        private void OnGetNicknameSuggestionsOperationCompleted(object arg) {
            if ((this.GetNicknameSuggestionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameSuggestionsCompleted(this, new GetNicknameSuggestionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverage(System.Guid contentTypeID, object itemID, out Rating rating) {
            object[] results = this.Invoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverage(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverage(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageOperationCompleted == null)) {
                this.GetRatingAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageOperationCompleted(object arg) {
            if ((this.GetRatingAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageCompleted(this, new GetRatingAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out Rating rating) {
            object[] results = this.Invoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverageRollup(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverageRollup(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageRollupAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageRollupOperationCompleted == null)) {
                this.GetRatingAverageRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageRollupOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageRollupOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageRollupOperationCompleted(object arg) {
            if ((this.GetRatingAverageRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageRollupCompleted(this, new GetRatingAverageRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating) {
            object[] results = this.Invoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUser(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserOperationCompleted == null)) {
                this.GetRatingByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserOperationCompleted(object arg) {
            if ((this.GetRatingByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserCompleted(this, new GetRatingByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating) {
            object[] results = this.Invoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUserWithAverage(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserWithAverageAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserWithAverageOperationCompleted == null)) {
                this.GetRatingByUserWithAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserWithAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserWithAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserWithAverageOperationCompleted(object arg) {
            if ((this.GetRatingByUserWithAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserWithAverageCompleted(this, new GetRatingByUserWithAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out Rating[] ratings) {
            object[] results = this.Invoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid});
            ratings = ((Rating[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetMultipleRatingsByUser(System.IAsyncResult asyncResult, out Rating[] ratings) {
            object[] results = this.EndInvoke(asyncResult);
            ratings = ((Rating[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid) {
            this.GetMultipleRatingsByUserAsync(contentTypeID, itemIDs, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetMultipleRatingsByUserOperationCompleted == null)) {
                this.GetMultipleRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMultipleRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, this.GetMultipleRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetMultipleRatingsByUserOperationCompleted(object arg) {
            if ((this.GetMultipleRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMultipleRatingsByUserCompleted(this, new GetMultipleRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname) {
            object[] results = this.Invoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingsByUser(System.IAsyncResult asyncResult, out System.Guid userID, out Rating[] ratings, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetRatingsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetRatingsByUserOperationCompleted == null)) {
                this.GetRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingsByUserOperationCompleted(object arg) {
            if ((this.GetRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingsByUserCompleted(this, new GetRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review) {
            object[] results = this.Invoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewByUser(System.IAsyncResult asyncResult, out Review review) {
            object[] results = this.EndInvoke(asyncResult);
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetReviewByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetReviewByUserOperationCompleted == null)) {
                this.GetReviewByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetReviewByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewByUserOperationCompleted(object arg) {
            if ((this.GetReviewByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewByUserCompleted(this, new GetReviewByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviews(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviews(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsOperationCompleted == null)) {
                this.GetReviewsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsOperationCompleted);
            }
            this.InvokeAsync("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsOperationCompleted, userState);
        }
        
        private void OnGetReviewsOperationCompleted(object arg) {
            if ((this.GetReviewsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsCompleted(this, new GetReviewsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsByUser(System.IAsyncResult asyncResult, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetReviewsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetReviewsByUserOperationCompleted == null)) {
                this.GetReviewsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetReviewsByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewsByUserOperationCompleted(object arg) {
            if ((this.GetReviewsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsByUserCompleted(this, new GetReviewsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsRollup(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsRollup(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsRollupAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsRollupOperationCompleted == null)) {
                this.GetReviewsRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsRollupOperationCompleted);
            }
            this.InvokeAsync("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsRollupOperationCompleted, userState);
        }
        
        private void OnGetReviewsRollupOperationCompleted(object arg) {
            if ((this.GetReviewsRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsRollupCompleted(this, new GetReviewsRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.Invoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse});
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatings(System.IAsyncResult asyncResult, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.EndInvoke(asyncResult);
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse) {
            this.GetUnauthRatingsAsync(contentTypeID, itemID, ratingAttributeID, daysOfRatingsToUse, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, object userState) {
            if ((this.GetUnauthRatingsOperationCompleted == null)) {
                this.GetUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse}, this.GetUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingsOperationCompleted(object arg) {
            if ((this.GetUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingsCompleted(this, new GetUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname});
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveNickname(long puid, System.Guid msnGuid, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveNickname(System.IAsyncResult asyncResult, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname) {
            this.SaveNicknameAsync(puid, msnGuid, nickname, null);
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname, object userState) {
            if ((this.SaveNicknameOperationCompleted == null)) {
                this.SaveNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveNicknameOperationCompleted);
            }
            this.InvokeAsync("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, this.SaveNicknameOperationCompleted, userState);
        }
        
        private void OnSaveNicknameOperationCompleted(object arg) {
            if ((this.SaveNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveNicknameCompleted(this, new SaveNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveRating(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues) {
            this.SaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingIDs, ratingValues, null);
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, object userState) {
            if ((this.SaveRatingOperationCompleted == null)) {
                this.SaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveRatingOperationCompleted);
            }
            this.InvokeAsync("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues}, this.SaveRatingOperationCompleted, userState);
        }
        
        private void OnSaveRatingOperationCompleted(object arg) {
            if ((this.SaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveRatingCompleted(this, new SaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, out ValidationError[] errors) {
            object[] results = this.Invoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveRating(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate) {
            this.BulkSaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingIDs, ratingValues, updateDate, null);
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, object userState) {
            if ((this.BulkSaveRatingOperationCompleted == null)) {
                this.BulkSaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveRatingOperationCompleted);
            }
            this.InvokeAsync("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate}, this.BulkSaveRatingOperationCompleted, userState);
        }
        
        private void OnBulkSaveRatingOperationCompleted(object arg) {
            if ((this.BulkSaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveRatingCompleted(this, new BulkSaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReportViolation(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments) {
            this.SaveReportViolationAsync(itemID, reviewID, name, emailAddress, comments, null);
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, object userState) {
            if ((this.SaveReportViolationOperationCompleted == null)) {
                this.SaveReportViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReportViolationOperationCompleted);
            }
            this.InvokeAsync("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, this.SaveReportViolationOperationCompleted, userState);
        }
        
        private void OnSaveReportViolationOperationCompleted(object arg) {
            if ((this.SaveReportViolationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReportViolationCompleted(this, new SaveReportViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty) {
            this.SaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, null);
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, object userState) {
            if ((this.SaveReviewOperationCompleted == null)) {
                this.SaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewOperationCompleted);
            }
            this.InvokeAsync("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, this.SaveReviewOperationCompleted, userState);
        }
        
        private void OnSaveReviewOperationCompleted(object arg) {
            if ((this.SaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewCompleted(this, new SaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname) {
            object[] results = this.Invoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveReview(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname) {
            this.BulkSaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, updateDate, nickname, null);
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname, object userState) {
            if ((this.BulkSaveReviewOperationCompleted == null)) {
                this.BulkSaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveReviewOperationCompleted);
            }
            this.InvokeAsync("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname}, this.BulkSaveReviewOperationCompleted, userState);
        }
        
        private void OnBulkSaveReviewOperationCompleted(object arg) {
            if ((this.BulkSaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveReviewCompleted(this, new BulkSaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReviewHelpfulness(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score) {
            this.SaveReviewHelpfulnessAsync(itemID, puid, msnGuid, reviewID, score, null);
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, object userState) {
            if ((this.SaveReviewHelpfulnessOperationCompleted == null)) {
                this.SaveReviewHelpfulnessOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewHelpfulnessOperationCompleted);
            }
            this.InvokeAsync("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, this.SaveReviewHelpfulnessOperationCompleted, userState);
        }
        
        private void OnSaveReviewHelpfulnessOperationCompleted(object arg) {
            if ((this.SaveReviewHelpfulnessCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewHelpfulnessCompleted(this, new SaveReviewHelpfulnessCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas) {
            object[] results = this.Invoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveUnauthRatings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas) {
            this.SaveUnauthRatingsAsync(contentTypeID, itemID, ratingAttributeID, ratingScores, ratingCountDeltas, null);
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas, object userState) {
            if ((this.SaveUnauthRatingsOperationCompleted == null)) {
                this.SaveUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas}, this.SaveUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnSaveUnauthRatingsOperationCompleted(object arg) {
            if ((this.SaveUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveUnauthRatingsCompleted(this, new SaveUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndValidateReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty) {
            this.ValidateReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, null);
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, object userState) {
            if ((this.ValidateReviewOperationCompleted == null)) {
                this.ValidateReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateReviewOperationCompleted);
            }
            this.InvokeAsync("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, this.ValidateReviewOperationCompleted, userState);
        }
        
        private void OnValidateReviewOperationCompleted(object arg) {
            if ((this.ValidateReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateReviewCompleted(this, new ValidateReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdvanceStateCompletedEventHandler(object sender, AdvanceStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdvanceStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AdvanceStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameCompletedEventHandler(object sender, GetNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameSuggestionsCompletedEventHandler(object sender, GetNicknameSuggestionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameSuggestionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameSuggestionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageCompletedEventHandler(object sender, GetRatingAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageRollupCompletedEventHandler(object sender, GetRatingAverageRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserCompletedEventHandler(object sender, GetRatingByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserWithAverageCompletedEventHandler(object sender, GetRatingByUserWithAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserWithAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserWithAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMultipleRatingsByUserCompletedEventHandler(object sender, GetMultipleRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMultipleRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMultipleRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingsByUserCompletedEventHandler(object sender, GetRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.Guid userID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewByUserCompletedEventHandler(object sender, GetReviewByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review review {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsCompletedEventHandler(object sender, GetReviewsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsByUserCompletedEventHandler(object sender, GetReviewsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsRollupCompletedEventHandler(object sender, GetReviewsRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingsCompletedEventHandler(object sender, GetUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratingScores {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public long[] ratingCounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveNicknameCompletedEventHandler(object sender, SaveNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveRatingCompletedEventHandler(object sender, SaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveRatingCompletedEventHandler(object sender, BulkSaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReportViolationCompletedEventHandler(object sender, SaveReportViolationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReportViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReportViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewCompletedEventHandler(object sender, SaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveReviewCompletedEventHandler(object sender, BulkSaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewHelpfulnessCompletedEventHandler(object sender, SaveReviewHelpfulnessCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewHelpfulnessCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewHelpfulnessCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveUnauthRatingsCompletedEventHandler(object sender, SaveUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateReviewCompletedEventHandler(object sender, ValidateReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ValidateReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsUnitTests\MainClass.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using UserRatings.Functional;

[assembly: RootNode(typeof(UserRatings.UserRatings))]

namespace UserRatings
{
    public class UserRatings : TestNode
    {
        protected int LatestVersion = 49;
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\RateMediaFDTest\RateMediaFDTest.cs ===
//------------------------------------------------------------------------------
// <copyright file="RateMediaFDTest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <author>MattLec</author>
// <owner>JeremyJ</owner>
// <lastModifiedBy>JeremyJ</lastModifiedBy>
// <lastModifiedDate>03/18/2011</lastModifiedDate>
//------------------------------------------------------------------------------

// Indicates the root node of the test tree for this suite.
[assembly: ServerTestFramework.RootNode(typeof(xonline.server.ratings.test.RateMediaFDTest))]

namespace xonline.server.ratings.test
{
    using System;
    using ServerTestFramework;

    /// <summary> Tests for the XBL Ratings front door server. </summary>
    /// <Goal> Validate XBL Ratings front door server functionality.</Goal>
    /// <NonGoal> Validate the associated Ratings CRON job OR ratings back end services (MSNRR and/or Ventura) </NonGoal>
    /// <Description>
    ///     The test suite validates: 
    ///         - Environment settings for the XBL Ratings FD
    ///         - Positive and negative functionality using the 3 possible back end service configurations (MSNRR and/or Ventura)
    ///         - Stress test cases for the get and submit Ratings APIs
    /// </Description>
    [TestGroup, Owner("JeremyJ"), EnvRequirement("Billing,Catalog"), Description("Tests for the XBL Ratings front door server")]
    public class RateMediaFDTest : TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\RateMediaFDTest\StressTests.cs ===
//------------------------------------------------------------------------------
// <copyright file="StressTests.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <author>JeremyJ</author>
// <owner>JeremyJ</owner>
// <lastModifiedBy>JeremyJ</lastModifiedBy>
// <lastModifiedDate>03/18/2011</lastModifiedDate>
//------------------------------------------------------------------------------

namespace xonline.server.ratings.test
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Threading;
    
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    using Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating;

    using ServerTestFramework;
    using ServerTestFramework.Database;
    using ServerTestFramework.LiveService;
    using ServerTestFramework.LiveService.Ratings;
    using ServerTestFramework.LiveService.UserAccount;

    /// <summary>
    /// Stress tests for the XBL Ratings FD
    /// Current TPS targets with 2 instances of stress running concurrently:
    /// Get - 160 total (80 per instance)
    /// Save - 80 total (40 per instance)
    /// </summary>
    [TestGroup, Owner("JeremyJ"), Description("XBL Ratings FD stress tests")]
    public class RateMediaFDStressTests : TestNode
    {
        /// <summary>
        /// Xenon users queue
        /// </summary>
        private static UserQueue xenonUsers;

        /// <summary>
        /// Gets or sets the xenonUsers field
        /// </summary>
        public static UserQueue XenonUsers
        {
            get { return RateMediaFDStressTests.xenonUsers; }
            set { RateMediaFDStressTests.xenonUsers = value; }
        }

        /// <summary>
        /// Initializes the Xenon users queue
        /// </summary>
        public static void InitializeUserQueue()
        {
            ulong basePuid = 0;
            int count = 0;
            string prefix = String.Empty;

            if (XenonUsers == null)
            {
                Global.RO.Info("Initializing the xenon user queue.");
                BulkUserSet userSet = Global.GetUserSet("xenon");
                basePuid = userSet.Base;
                count = (int)userSet.Count;
                prefix = userSet.Prefix;

                XenonUsers = new UserQueue(basePuid, count, prefix);
            }
        }

        /// <summary>
        /// Clean up that only occurs once (when the program is closing)
        /// </summary>
        public override void OneTimeCleanup()
        {
            // Restore FD request ignoring...
            Global.RO.Info("Updating FD Ignore Flag to disallow FD Requests...");

            Global.XEnv.OverrideSetting("ALL", "ALL", "msnrr_ignorefdrequests", "true", -1);
            Global.XEnv.ForceConfigReload("ratings");

            Global.RO.Info("Done!");
        }

        /// <summary>
        /// Setup that occurs only over the life of the program
        /// </summary>
        public override void OneTimeSetup()
        {
            // Turn off FD request ignoring for now, since this is set on by default in Stress Net
            Global.RO.Info("Updating FD Ignore Flag to allow FD Requests...");

            Global.XEnv.OverrideSetting("ALL", "ALL", "msnrr_ignorefdrequests", "false", -1);
            Global.XEnv.ForceConfigReload("ratings");

            Global.RO.Info("Done!");

            Global.RO.Info("Initializing Bulk User Queue...");
            InitializeUserQueue();
            Global.RO.Info("Done!");
        }

        /// <summary>
        /// Stress test for the XBL Ratings FD GetRating API
        /// </summary>
        [StressTest, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), Description("Stress Test for Get Rating Front Door on Emulator")]
        [StressInstantiate]
        public class StressGetRatingFrontDoorWithEmulatorTarget : TestNode
        {
            /// <summary>
            /// ContentTypeId GUID corresponding to Indie Games
            /// </summary>
            private Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XnaCommunityGame.ContentTypeId);

            /// <summary>
            /// mediaId GUID
            /// </summary>
            private Guid itemId;

            /// <summary>
            /// String consisting of a mediaId following by an underscore and a locale
            /// </summary>
            private string itemIdAsString;

            /// <summary>
            /// String of the emulator URL
            /// </summary>
            private string url = String.Empty;

            /// <summary>
            /// Setup that occurs only over the life of the program
            /// </summary>
            public override void OneTimeSetup()
            {
                Guid mediaIdFromCatalog = Common.GetMediaIdFromCatalog(37);
                this.itemId = mediaIdFromCatalog;
                this.itemIdAsString = this.itemId + "_US";

                Global.RO.Info("Setting up the emulator...");

                ulong userPuid = long.MaxValue;
                Guid msnGuid = Guid.Empty;
                int returnedRatingValue = -1;
                int returnCode = (int) HResult.S_OK;

                SingleRatingEmulator emu = new SingleRatingEmulator();
                ISingleRatingSoap mock = emu.StartRecording();

                mock.GetRatingByUser(this.contentId, this.itemIdAsString, (long)userPuid, msnGuid, out returnedRatingValue);
                LastCall.On(mock).IgnoresArgument(2).OutArguments(null, null, null, null, 3).Returns(returnCode);
                LastCall.On(mock).ExpectedAnytime();
                emu.StopRecording(mock);
                this.url = emu.GetUrl(mock);

                Global.RO.Info("Emulator setup completed...");
            }

            /// <summary>
            /// Stress test for the XBL Ratings FD GetRating API
            /// </summary>
            [StressTest, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), Description("Positive Stress Test for Get Rating Front Door on Emulator")]
            public void P_GetRatingFDToEmulator()
            {
                Global.RO.Info("P_GetRatingFDToEmulator BEGIN");

                Global.RO.Info("Creating the front door request.");

                XRLMsnGetRating request = new XRLMsnGetRating();

                using (SimpleStressUser user = new SimpleStressUser(XenonUsers))
                {
                    ulong userPuid = user.UserPuid;

                    request.Request.userXuid = userPuid;
                    request.Request.mediaId = this.itemId;
                    request.Request.userCountryId = (byte)XeUser.Country.US;
                    request.Slot.AddService(ServerTestFramework.LiveService.XOService.Ratings);
                    request.CustomHeader = string.Format("{0}: {1}\r\n", "AlternateSingleRatingSessionUrl", this.url);
                }

                Global.RO.Info("Making the call to the Get Rating Front Door...");

                if (!request.Execute())
                {
                    throw new UnexpectedTestResultException("XRLMsnGetRating failed: " + request.GetDumpString());
                }

                Global.RO.Info("Validating...");
                if (request.XErr != ServerTestFramework.LiveService.HResult.S_OK)
                {
                    throw new UnexpectedTestResultException(String.Format("XRLMsnGetRating returned XErr=0x{0:x}", request.XErr));
                }

                // If we're using MSNRR with or without Ventura the call will ultimately make it to the emulator
                if (Global.XEnv.GetBoolSetting("ratings_use_msnrr"))
                {
                    if (request.Response.userValue != 3 || request.Response.userValue == -1)
                    {
                        throw new UnexpectedTestResultException("Test FAILED -- returned user rating was not the expected value.");
                    }
                }
                else
                {
                    // Ventura only
                    if (request.Response.userValue != 0)
                    {
                        throw new UnexpectedTestResultException("Test FAILED -- returned user rating was not the expected value.");
                    }
                }

                Global.RO.Success("P_GetRatingFDToEmulator PASSED!");
            }
        }

        /// <summary>
        /// Stress test for the XBL Ratings FD SubmitRating API
        /// </summary>
        [StressTest, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), Description("Stress Test for Submit Rating Front Door on Emulator")]
        [StressInstantiate]
        public class StressSubmitRatingFrontDoorWithEmulatorTarget : TestBase
        {
            /// <summary>
            /// ContentTypeId GUID corresponding to Indie Games
            /// </summary>
            private Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XnaCommunityGame.ContentTypeId);

            /// <summary>
            /// mediaId GUID
            /// </summary>
            private Guid itemId;

            /// <summary>
            /// String consisting of a mediaId following by an underscore and a locale
            /// </summary>
            private string itemIdAsString;

            /// <summary>
            /// String of the emulator URL
            /// </summary>
            private string url = String.Empty;

            /// <summary>
            /// Setup that occurs only over the life of the program
            /// </summary>
            public override void OneTimeSetup()
            {
                Guid mediaIdFromCatalog = Common.GetMediaIdFromCatalog(37);
                this.itemId = mediaIdFromCatalog;
                this.itemIdAsString = this.itemId + "_US";

                Global.RO.Info("Setting up the emulator...");

                ulong userPuid = long.MaxValue;
                Guid msnGuid = Guid.Empty;
                int returnCode = (int) HResult.S_OK;
                int ratingValue = 1;

                SingleRatingEmulator emu = new SingleRatingEmulator();
                ISingleRatingSoap mock = emu.StartRecording();

                mock.SaveRating(this.contentId, this.itemIdAsString, (long)userPuid, msnGuid, ratingValue);
                LastCall.On(mock).IgnoresArgument(2).IgnoresArgument(0).Returns(returnCode);
                LastCall.On(mock).ExpectedAnytime();
                emu.StopRecording(mock);
                this.url = emu.GetUrl(mock);

                Global.RO.Info("Emulator setup completed...");
            }

            /// <summary>
            /// Stress test for the XBL Ratings FD SubmitRating API
            /// </summary>
            [StressTest, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), Description("Positive Stress Test for Submit Rating Front Door on Emulator")]
            public void P_SubmitRatingFDToEmulator()
            {
                Global.RO.Info("P_SubmitRatingFDToEmulator BEGIN");

                Global.RO.Info("Creating the front door request.");

                XRLMsnSubmitRating request = new XRLMsnSubmitRating();

                using (SimpleStressUser user = new SimpleStressUser(XenonUsers))
                {
                    ulong userPuid = user.UserPuid;

                    request.Request.userXuid = userPuid;
                    request.Request.mediaId = this.itemId;
                    request.Request.ratingValue = 1;
                    request.Request.userCountryId = (byte)XeUser.Country.US;
                    request.Slot.AddService(XOService.Ratings);
                    request.CustomHeader = string.Format("{0}: {1}\r\n", "AlternateSingleRatingSessionUrl", this.url);
                }

                Global.RO.Info("Making the call to the Submit Rating Front Door...");

                if (!request.Execute())
                {
                    throw new UnexpectedTestResultException("XRLMsnSubmitRating failed: " + request.GetDumpString());
                }

                Global.RO.Info("Validating...");
                if (request.XErr != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException(String.Format("XRLMsnSubmitRating returned XErr=0x{0:x}", request.XErr));
                }

                Global.RO.Success("P_SubmitRatingFDToEmulator PASSED!");
            }
        }
    }

    /// <summary>
    /// The UserQueue class contains a queue of available SimpleUser objects
    /// </summary>
    public class UserQueue
    {
        /// <summary>
        /// The base user PUID
        /// </summary>
        private ulong basePuid;

        /// <summary>
        /// The number of bulk users
        /// </summary>
        private int count;

        /// <summary>
        /// Prefix to use when creating users
        /// </summary>
        private string prefix;

        /// <summary>
        /// userQueue field
        /// </summary>
        private Queue userQueue;

        /// <summary>
        /// Initializes a new instance of the UserQueue class
        /// </summary>
        /// <param name="basePuid">Base user PUID</param>
        /// <param name="count">Number of bulk users</param>
        /// <param name="prefix">Bulk user prefix</param>
        public UserQueue(ulong basePuid, int count, string prefix)
        {
            this.basePuid = basePuid;
            this.count = count;
            this.prefix = prefix;
            this.userQueue = new Queue(count);

            for (int i = 0; i < this.count; i++)
            {
                this.userQueue.Enqueue((ulong)(basePuid + (ulong)i));
            }
        }

        /// <summary>
        /// Gets the prefix field value
        /// </summary>
        public string Prefix 
        { 
            get { return this.prefix; } 
        }

        /// <summary>
        /// Safely gets a user
        /// </summary>
        /// <returns>The user's PUID</returns>
        public ulong InterlockedGetUser()
        {
            ulong userPuid = 0;
            bool success = false;

            while (!success)
            {
                while (this.userQueue.Count == 0)
                {
                    Thread.Sleep(5);
                }

                lock (this.userQueue)
                {
                    // we need to do an extra check here just to ensure that nothing changed before the lock
                    if (this.userQueue.Count > 0)
                    {
                        userPuid = (ulong)this.userQueue.Dequeue();
                        success = true;
                    }
                }
            }

            return userPuid;
        }

        /// <summary>
        /// Safely puts the user in the user queue
        /// </summary>
        /// <param name="userPuid">The user to put in the queue</param>
        public void InterlockedQueueUser(ulong userPuid)
        {
            lock (this.userQueue)
            {
                this.userQueue.Enqueue(userPuid);
            }
        }
    }

    /// <summary>
    /// The QueuedUser class
    /// </summary>
    public class QueuedUser
    {
        /// <summary>
        /// userPuid field
        /// </summary>
        private ulong userPuid;

        /// <summary>
        /// userQueue field
        /// </summary>
        private UserQueue userQueue;

        /// <summary>
        /// Initializes a new instance of the QueuedUser class
        /// </summary>
        public QueuedUser()
        {
            this.userPuid = 0;
            this.userQueue = null;
        }

        /// <summary>
        /// Finalizes an instance of the QueuedUser class
        /// </summary>
        ~QueuedUser()
        {
            try
            {
                if (this.UserQueue != null && this.UserPuid != 0)
                {
                    this.RequeueUser();
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn("An exception was thrown in the QueuedUser finalizer: {0}", e.Message);
            }
        }

        /// <summary>
        /// Gets or sets the userPuid field
        /// </summary>
        protected internal ulong UserPuid
        {
            get { return this.userPuid; }
            set { this.userPuid = value; }
        }

        /// <summary>
        /// Gets or sets the userQueue field
        /// </summary>
        protected UserQueue UserQueue
        {
            get { return this.userQueue; }
            set { this.userQueue = value; }
        }

        /// <summary>
        /// Reverts a user back to their original state
        /// Called by the desctructor
        /// </summary>
        public virtual void RevertUser()
        {
            throw new Exception("A RevertUser() method must be implemented for the derived class");
        }

        /// <summary>
        /// Initializes a user from a UserQueue object
        /// </summary>
        /// <param name="queue">The UserQueue objec to use to initialize the user</param>
        protected void InitializeFromQueue(UserQueue queue)
        {
            Debug.Assert(queue != null, "The queue is null!");
            this.UserQueue = queue;
            this.UserPuid = queue.InterlockedGetUser();
        }

        /// <summary>
        /// Requeues the user
        /// </summary>
        protected void RequeueUser()
        {
            if (this.UserQueue != null && this.UserPuid != 0)
            {
                this.UserQueue.InterlockedQueueUser(this.UserPuid);
                this.UserPuid = 0;
                this.UserQueue = null;
            }
        }
    }

    /// <summary>
    /// SimpleStressuser class
    /// </summary>
    public class SimpleStressUser : QueuedUser, IDisposable
    {
        /// <summary>
        /// Initializes a new instance of the SimpleStressUser class
        /// </summary>
        /// <param name="queue">The UserQueue object to use to initialize the user</param>
        public SimpleStressUser(UserQueue queue)
        {
            InitializeFromQueue(queue);
        }

        /// <summary>
        /// Reverts the user
        /// </summary>
        public override void RevertUser()
        {
            RequeueUser();
        }

        /// <summary>
        /// Disposes the user
        /// </summary>
        public void Dispose()
        {
            this.RevertUser();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsUnitTests\FuncSubmitRating.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Net;
using System.Xml;
using System.Threading;
using System.Web.Services.Protocols; // SoapException

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;

using ServerTestFramework.LiveService.Ratings;

using xonline.common.config;


namespace UserRatings.Functional
{
    [TestGroup]
    public class UserRatingsUnitTest : TestNode
    {
        private Report _Report = new Report(typeof(UserRatingsUnitTest).Name);

        [TestGroupSetup]
        public void Setup()
        {
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        //[TestCase, Description("Submits a rating with valid parameters using the Front Door")]
        public void P_SubmitRatingThroughFrontDoor()
        {
            XeUser user = XbosUser.XenonSilverUser();
            float paddedPollingInterval = Config.GetIntSetting("xcache_db_pollingInterval") * 1000 * 1.1f;
            _Report.Info("Sleeping for {0} ms to allow XCache to update...", (int)paddedPollingInterval);

            Thread.Sleep((int)paddedPollingInterval);

            XRLMsnSubmitRating request = new XRLMsnSubmitRating();
            request.Request.userXuid = user.UserPuid;
            request.Request.mediaId = new Guid("66ACD000-77FE-1000-9115-D802585207D1");
            request.Request.ratingValue = 1;
            request.Request.userCountryId = 103;

            request.Slot.AddService(XOService.Ratings);

            if (!request.Execute())
            {
                throw new UnexpectedTestResultException("XRLUserRatings failed: " + request.GetDumpString());
            }
            if (request.XErr != HResult.S_OK)
            {
                throw new UnexpectedTestResultException(String.Format("XRLUserRatings returned XErr=0x{0:x}", request.XErr));
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\RateMediaFDTest\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RateMediaFDTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("RateMediaFDTest")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("4e9ba13c-45d4-46c8-8913-b8ac105dc1d3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsUnitTests\MsnRRWrapperTest.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Net;
using System.Xml;
using System.Runtime.Serialization;
using System.IO;


using ServerTestFramework;
using xonline.common.config;
using xonline.common.msnrr;
using xonline.common.service;
using xonline.common.diagnostics;
using Microsoft.XBox.Live.Server.Emulators.MSNRR.Aggregator;
using Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating;
using Microsoft.XBox.Live.Server.Emulators.Framework;


namespace UserRatings.Functional
{
    [TestGroup]
    public class MsnRRWrapperTest : TestNode
    {

	[TestGroupSetup]
        public void Setup()
        {
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        #region SaveRating Test Cases

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingWithEmulatorBasicPositiveTest()
        {
            SaveRatingIn(0, 0);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingIn35Seconds()
        {
            SaveRatingTimeOut();
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingIn10Seconds()
        {
            bool timeOut = false;
            try
            {
                SaveRatingIn(10, 0);
            }
            catch (WebException)
            {
                timeOut = true;
            }
            Assert.IsTrue(!timeOut);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingWithEmulatorBadContentType()
        {
            try
            {
                SaveRatingIn(0, 10003);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_INVALID_CONTENT_TYPE_ID);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingWithEmulatorBadItemId()
        {
            try
            {
                SaveRatingIn(0, 10005);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_INVALID_ITEM_ID);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingWithEmulatorZeroPuid()
        {
            try
            {
                SaveRatingIn(0, 10007);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_PUID_CANNOT_BE_ZERO);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingWithBadContentType2()
        {
            try
            {
                SaveRatingIn(0, 10029);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_USE_MULTIPLE_RATING);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingWithUnknownError()
        {
            try
            {
                SaveRatingIn(0, 99999);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void SaveRatingVerifyFailFast()
        {

            // trigger failfast...
            int nQueries = 3;
            Thread[] testThreads = new Thread[nQueries];
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("starting thread... " + i.ToString());
                Thread worker = new Thread(MsnRRWrapperTest.SaveRatingTimeOut);
                worker.Start();
                testThreads[i] = worker;
            }
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("joining threads...");
                testThreads[i].Join();
            }
            Console.WriteLine("trying to failfast...");
            // test fail fast...
            try
            {
                SaveRatingIn(0, 0);
            }
            catch (XRLExceptionWithoutEvent ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) != -1);
            }

        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        private static void SaveRatingTimeOut()
        {
            bool timeOut = false;
            try
            {
                SaveRatingIn(35, 0);
            }
            catch (WebException ex)
            {
                Assert.IsTrue(ex.Message.IndexOf("timed out", StringComparison.InvariantCultureIgnoreCase) != -1);
                timeOut = true;
            }
            Assert.IsTrue(timeOut);
        }

        private static void SaveRatingIn(int seconds, int returnCode)
        {
            Guid contentId = Guid.NewGuid();
            Guid itemId = Guid.NewGuid();
            Puid puid = (ulong)11;
            Guid msnGuid = Guid.Empty;
            int ratingValue = 5;
            


            SingleRatingEmulator emu = new SingleRatingEmulator();
            ISingleRatingSoap mock = emu.StartRecording();

            mock.SaveRating(contentId, itemId, (long)puid, msnGuid, ratingValue);
            LastCall.On(mock).Waits(new TimeSpan(0, 0, seconds)).Returns(returnCode);
            emu.StopRecording(mock);

            string url = emu.GetUrl(mock);

            MsnRRServiceWrapper.SetSingleRatingSessionAlternateUrl(url);
            try
            {
                MsnRRClient.SaveRating(contentId, itemId, (Puid)puid, ratingValue);
            }
            finally
            {
                MsnRRServiceWrapper.ResetSingleRatingSessionAlternateUrl();
            }

            emu.Verify(mock);
        }

        #endregion

        #region GetRatingByUser Test Cases

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        private static void RetrieveRatingAndAverageTimeOut()
        {
            bool timeOut = false;
            try
            {
                RetrieveRatingAndAverageIn(35, 0);
            }
            catch (WebException ex)
            {
                Assert.IsTrue(ex.Message.IndexOf("timed out", StringComparison.InvariantCultureIgnoreCase) != -1);
                timeOut = true;
            }
            Assert.IsTrue(timeOut);
        }

        private static void RetrieveRatingAndAverageIn(int seconds, int returnCode)
        {
            Guid contentId = Guid.NewGuid();
            Guid itemId = Guid.NewGuid();
            Puid puid = (ulong)11;
            Guid msnGuid = Guid.Empty;

            int userRating = -1;
            //float averageRating = -1.0F;
            //int count = -1;

            SingleRatingEmulator emu = new SingleRatingEmulator();
            ISingleRatingSoap mock = emu.StartRecording();

            mock.GetRatingByUser(contentId, itemId, (long)puid, msnGuid, out userRating);
            //mock.GetRatingByUserWithAverage(contentId, itemId, (long)puid, msnGuid, out userRating, out averageRating, out count);
            LastCall.On(mock).OutArguments(null, null, null, null, 3);
            LastCall.On(mock).Waits(new TimeSpan(0, 0, seconds)).Returns(returnCode);
            emu.StopRecording(mock);

            string url = emu.GetUrl(mock);
            MsnRRServiceWrapper.SetSingleRatingSessionAlternateUrl(url);
            try
            {
                MsnRRClient.GetRatingByUser(contentId, itemId, puid, out userRating);
                Assert.AreEqual(userRating, 3);
            }
            finally
            {
                MsnRRServiceWrapper.ResetSingleRatingSessionAlternateUrl();
            }

            emu.Verify(mock);
            
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageWithEmulatorBasicPositiveTest()
        {
            RetrieveRatingAndAverageIn(0, 0);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageIn10Seconds()
        {
            RetrieveRatingAndAverageIn(10, 0);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageIn35Seconds()
        {
            RetrieveRatingAndAverageTimeOut();
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageBadContentType()
        {
            try
            {
                RetrieveRatingAndAverageIn(0, 10003);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_INVALID_CONTENT_TYPE_ID);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageBadItemId()
        {
            try
            {
                RetrieveRatingAndAverageIn(0, 10005);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_INVALID_ITEM_ID);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageBadContentType2()
        {
            try
            {
                RetrieveRatingAndAverageIn(0, 10029);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_USE_MULTIPLE_RATING);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageUnknownError()
        {
            try
            {
                RetrieveRatingAndAverageIn(0, 99999);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void RetrieveRatingAndAverageVerifyFailFast()
        {
        
            // trigger failfast...
            int nQueries = 3;
            Thread[] testThreads = new Thread[nQueries];
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("starting thread... " + i.ToString());
                Thread worker = new Thread(MsnRRWrapperTest.RetrieveRatingAndAverageTimeOut);
                worker.Start();
                testThreads[i] = worker;
            }
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("joining threads...");
                testThreads[i].Join();
            }
            Console.WriteLine("trying to failfast...");
            // test fail fast...
            try
            {
                RetrieveRatingAndAverageIn(0, 0);
            }
            catch (XRLExceptionWithoutEvent ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) != -1);
            }
        
        }
 
        #endregion

        #region GetRatingAverages Test Cases 
      
        private static void GetRatingAveragesIn(int seconds, int returnCode)
        {
            Guid contentId = Guid.NewGuid();
            DateTime fromTime = DateTime.UtcNow.AddHours(-1);
            bool returnRatingAttributes = false;
            string transactionToken = null;
            DateTime transactionStartTime = DateTime.Now;
            XmlNode xmlNode = null;
            XmlNode returnXml = null; //new SerializableXmlDocument(); would be nice to have...

            AggregatorEmulator emu = new AggregatorEmulator();
            IAggregatorSoap mock = emu.StartRecording();

            mock.GetRatingAverages(contentId, fromTime, returnRatingAttributes, ref transactionToken, out transactionStartTime, out xmlNode);
            LastCall.On(mock).OutArguments(null, null, null, "BLAHBLAH", transactionStartTime, returnXml);
            LastCall.On(mock).Waits(new TimeSpan(0, 0, seconds)).Returns(returnCode);
            emu.StopRecording(mock);

            string url = emu.GetUrl(mock);
            MsnRRServiceWrapper.SetAggregatorSessionAlternateUrl(url);
            try
            {
                MsnRRClient.GetRatingAverages(contentId, fromTime,  
                    ref transactionToken, out transactionStartTime, out xmlNode);
                Assert.AreEqual(transactionToken, "BLAHBLAH");
                Assert.AreEqual(transactionStartTime, transactionStartTime);
                Assert.AreEqual(xmlNode, returnXml);
            }
            finally
            {
                MsnRRServiceWrapper.ResetAggregatorSessionAlternateUrl();
            }

            emu.Verify(mock);

        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesWithEmulatorBasicPositiveTest()
        {
            GetRatingAveragesIn(0, 0);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesWithEmulatorBasicPositiveTest2()
        {
            GetRatingAveragesIn(0, 20001);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesUnknownError()
        {
            try
            {
                GetRatingAveragesIn(0, 99999);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesIn10Seconds()
        {
            GetRatingAveragesIn(10, 0);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        private static void GetRatingAveragesTimeOut()
        {
            bool timeOut = false;
            try
            {
                GetRatingAveragesIn(35, 0);
            }
            catch (WebException ex)
            {
                Assert.IsTrue(ex.Message.IndexOf("timed out", StringComparison.InvariantCultureIgnoreCase) != -1);
                timeOut = true;
            }
            Assert.IsTrue(timeOut);
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesIn35Seconds()
        {
            GetRatingAveragesTimeOut();
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesBadContentType()
        {
            try
            {
                GetRatingAveragesIn(0, 10003);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_INVALID_CONTENT_TYPE_ID);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesBadToken()
        {
            try
            {
                GetRatingAveragesIn(0, 20003);
            }
            catch (MsnRRException ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_INVALID_TRANSACTION_TOKEN);
            }
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog")]
        public static void GetRatingAveragesVerifyFailFast()
        {
        
            // trigger failfast...
            int nQueries = 3;
            Thread[] testThreads = new Thread[nQueries];
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("starting thread... " + i.ToString());
                Thread worker = new Thread(MsnRRWrapperTest.GetRatingAveragesTimeOut);
                worker.Start();
                testThreads[i] = worker;
            }
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("joining threads...");
                testThreads[i].Join();
            }
            Console.WriteLine("trying to failfast...");
            // test fail fast...
            try
            {
                GetRatingAveragesIn(0, 0);
            }
            catch (XRLExceptionWithoutEvent ex)
            {
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) != -1);
            }
        }
        [TestCase]
        public static void GetRatingAveragesVerifyFailFastWithRecovery()
        {

            // trigger failfast...
            string value=Config.GetSetting("msnrr_failFastBlockIntervalSeconds");
            int fastfailBlockInterval = 0;
            if(!Int32.TryParse(value,out fastfailBlockInterval))
            {
                throw new Exception("failed to parse msnrr_failFastBlockIntervalSeconds from config");
            }
            int nQueries = 3;
            Thread[] testThreads = new Thread[nQueries];
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("starting thread... " + i.ToString());
                Thread worker = new Thread(MsnRRWrapperTest.GetRatingAveragesTimeOut);
                worker.Start();
                testThreads[i] = worker;
            }
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("joining threads...");
                testThreads[i].Join();
            }
            Console.WriteLine("trying to failfast...");
            // test fail fast...
            try
            {
                GetRatingAveragesIn(0, 0);
            }
            catch (XRLExceptionWithoutEvent ex)
            {
                
                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) != -1);
            }
            Console.WriteLine("In fast fail mode");
            Console.WriteLine(string.Format("Waiting for {0} seconds to allow recovery from fast fail...", fastfailBlockInterval));
            Thread.Sleep(fastfailBlockInterval*1000);
            //reissue the request
            try
            {
                GetRatingAveragesIn(0, 0);
            }
            catch (Exception ex)
            {
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) == -1);
            }


        }
        [TestCase]
        public static void GetRatingAveragesEarlyFailFastWithRecoveryNegative()
        {

            // trigger failfast...
            string value = Config.GetSetting("msnrr_failFastBlockIntervalSeconds");
            int fastfailBlockInterval = 0;
            if (!Int32.TryParse(value, out fastfailBlockInterval))
            {
                throw new Exception("failed to parse msnrr_failFastBlockIntervalSeconds from config");
            }
            int nQueries = 3;
            Thread[] testThreads = new Thread[nQueries];
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("starting thread... " + i.ToString());
                Thread worker = new Thread(MsnRRWrapperTest.GetRatingAveragesTimeOut);
                worker.Start();
                testThreads[i] = worker;
            }
            for (int i = 0; i < nQueries; i++)
            {
                Console.WriteLine("joining threads...");
                testThreads[i].Join();
            }
            Console.WriteLine("trying to failfast...");
            // test fail fast...
            try
            {
                GetRatingAveragesIn(0, 0);
            }
            catch (XRLExceptionWithoutEvent ex)
            {

                Assert.AreEqual(ex.HResult, HResult.XONLINE_E_MSNRR_UNKNOWN_ERROR);
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) != -1);
            }
            Console.WriteLine("In fast fail mode");
            Console.WriteLine(string.Format("Waiting for {0} seconds to allow recovery from fast fail...", (fastfailBlockInterval / 2)));
            Thread.Sleep((fastfailBlockInterval/2) * 1000);
            //reissue the request
            try
            {
                GetRatingAveragesIn(0, 0);
            }
            catch (Exception ex)
            {
                Assert.IsTrue(ex.Message.IndexOf("fail-fasting of msnrr", StringComparison.InvariantCultureIgnoreCase) != -1);
            }


        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\RateMediaFDTest\FunctionalTests.cs ===
//------------------------------------------------------------------------------
// <copyright file="FunctionalTests.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <author>JeremyJ</author>
// <owner>JeremyJ</owner>
// <lastModifiedBy>JeremyJ</lastModifiedBy>
// <lastModifiedDate>03/18/2011</lastModifiedDate>
//------------------------------------------------------------------------------

namespace xonline.server.ratings.test
{
    using System;

    using Microsoft.XBox.Live.Server.Emulators.Framework;
    using Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating;

    using ServerTestFramework;
    using ServerTestFramework.Database;
    using ServerTestFramework.LiveService;
    using ServerTestFramework.LiveService.Ratings;
    using ServerTestFramework.LiveService.UserAccount;

    /// <summary>
    /// Functional Tests for the XBL Ratings FD (User Ratings)
    /// </summary>
    [TestGroup, Owner("JeremyJ"), TestFrequency("Daily"), Description("Functional test cases for the XBL Ratings FD")]
    public class FunctionalTests : TestNode
    {
        #region PreRun (Environment Validation)

        /// <summary>
        /// Validates the environment before any of the the test cases in the TestGroup are run
        /// </summary>
        public override void PreRun()
        {
            Global.RO.Info("Performing PreRun environment validation...");

            Global.RO.Info("Validating that the XBL Ratings FD kill switch setting is off...");

            bool isKillSwitchOn = Global.XEnv.GetBoolSetting("msnrr_ignorefdrequests");

            Global.RO.Debug("msnrr_ignorefdrequests={0}", isKillSwitchOn);

            // Check that the ratings kill switch is off (false)
            if (!isKillSwitchOn)
            {
                Global.RO.Success("The XBL Ratings FD kill switch is off.");
            }
            else
            {
                // If it is on, output error text that no further tests in the test suite will be run
                Global.RO.Error("The XBL Ratings FD kill switch setting is ON. No further test cases in this test suite will be run as a result.");
                throw new Exception("The XBL Ratings FD kill switch setting is ON.");
            }

            Global.RO.Info("Validating that the XBL Ratings FD allow URL override setting is on...");

            bool isAllowUrlOverrideOn = Global.XEnv.GetBoolSetting("msnrr_allowUrlOverride");

            Global.RO.Debug("msnrr_allowUrlOverride={0}", isAllowUrlOverrideOn);

            // Check that the allow URL override setting is on (true)
            if (isAllowUrlOverrideOn)
            {
                Global.RO.Success("The XBL Ratings FD allow URL override setting is on.");
            }
            else
            {
                // If it is off, output error text that cases dependent on the setting will not be run
                Global.RO.Error("The XBL Ratings FD allow URL override setting is OFF. Test cases depending on this functionality will not be run as a result.");
                throw new Exception("The XBL Ratings FD allow URL override setting is OFF.");
            }
        }

        #endregion  

        #region Functional test helper methods

        /// <summary>
        /// Overrides a setting with the option of forcing the XBL Ratings FD's configuration to reload
        /// </summary>
        /// <param name="settingName">The name of the setting to override</param>
        /// <param name="settingValue">The value of the overridden setting</param>
        /// <param name="forceConfigReload">Whether or not to force the ratings FD config to be reloaded</param>
        /// <returns>A SettingState object for the setting prior to the setting value being overridden</returns>
        private static SettingState OverrideRatingsFdSetting(string settingName, string settingValue, bool forceConfigReload)
        {
            SettingState previousSettingState = Global.XEnv.OverrideSetting("ALL", "ALL", settingName, settingValue, -1);
            if (forceConfigReload)
            {
                Global.XEnv.ForceConfigReload("ratings");
            }

            return previousSettingState;
        }

        /// <summary>
        /// Restores a setting back a state based on the passed in SettingState object with the option of forcing the XBL Ratings FD's config to reload
        /// </summary>
        /// <param name="state">A SettingState object for a setting</param>
        /// <param name="forceConfigReload">Whether or not to force the ratings fd config to be reloaded</param>
        private static void RestoreRatingsFdSetting(SettingState state, bool forceConfigReload)
        {
            Global.XEnv.RestoreOverrideSettingState(state);
            if (forceConfigReload)
            {
                Global.XEnv.ForceConfigReload("ratings");
            }
        }

        /// <summary>
        /// Submits the rating to the ratings FD using the currently configured backend
        /// </summary>
        /// <param name="user">The XeUser object of the user submitting the rating</param>
        /// <param name="mediaId">The mediaId of the media to rate</param>
        /// <param name="rating">the rating to be submitted</param>
        /// <param name="alternateSingleRatingSessionURL">The alternate MSNRR URL to use</param>
        /// <returns>The XRLMsnSubmitRating request object</returns>
        private static XRLMsnSubmitRating SubmitRating(XeUser user, Guid mediaId, int rating, string alternateSingleRatingSessionURL)
        {
            return SubmitRating(user.UserPuid, mediaId, rating, user.CountryId, alternateSingleRatingSessionURL);
        }

        /// <summary>
        /// Optionally sets up the MSNRR SingleRating emulator to handle the backend request and submits the rating to the ratings FD
        /// </summary>
        /// <param name="userXuid">The user XUID of the user submitting the rating</param>
        /// <param name="mediaId">The mediaId of the media to rate</param>
        /// <param name="rating">the rating to be submitted</param>
        /// <param name="userCountryId">The user's CountryId</param>
        /// <param name="alternateSingleRatingSessionURL"> AlternateSingleRatingSessionURL to be used for the submission</param>
        /// <returns>The XRLMsnSubmitRating request object</returns>
        private static XRLMsnSubmitRating SubmitRating(ulong userXuid, Guid mediaId, int rating, byte userCountryId, string alternateSingleRatingSessionURL)
        {
            Global.RO.Info("Creating a XRLMsnSubmitRating request...");

            XRLMsnSubmitRating request = new XRLMsnSubmitRating();
            request.Request.userXuid = userXuid;
            request.Request.mediaId = mediaId;
            request.Request.ratingValue = rating;
            request.Request.userCountryId = userCountryId;
            request.Slot.AddService(XOService.Ratings);

            if (alternateSingleRatingSessionURL != null)
            {
                request.CustomHeader = String.Format("AlternateSingleRatingSessionUrl: {0}\r\n", alternateSingleRatingSessionURL);
            }

            Global.RO.Info("Executing the XRLMsnSubmitRating request...");

            if (!request.Execute())
            {
                Global.RO.Warn("The XRLMsnSubmitRating request failed!");
            }

            return request;
        }

        /// <summary>
        /// Setups the emulator to handle a SubmitRating request
        /// </summary>
        /// <param name="userXuid">The user XUID of the user submitting the rating</param>
        /// <param name="mediaId">The mediaId of the media to rate</param>
        /// <param name="rating">the rating to be submitted</param>
        /// <param name="userCountryId">The user's CountryId</param>
        /// <param name="emulatorContentTypeId">MSNRR ContentTypeId GUID to be passed to the emulator</param>
        /// <param name="emulatorReturnCode">The return code that you wish the emulator to return</param>
        /// <returns>The URL for the specified emulator behavior</returns>
        private static string SetupSubmitRatingEmulator(ulong userXuid, Guid mediaId, int rating, byte userCountryId, Guid emulatorContentTypeId, int emulatorReturnCode)
        {
            Global.RO.Info("Setting up the MSNRR SingleRating Emulator...");

            SingleRatingEmulator emulator = new SingleRatingEmulator();
            ISingleRatingSoap mock = emulator.StartRecording();

            mock.SaveRating(emulatorContentTypeId, mediaId, (long)userXuid, Guid.Empty, rating);
            
            // TODO: Set the proper IgnoresArguments
            LastCall.On(mock).IgnoresArgument(0).IgnoresArgument(1).IgnoresArgument(2).IgnoresArgument(3).IgnoresArgument(4).Returns(emulatorReturnCode);

            emulator.StopRecording(mock);

            return emulator.GetUrl(mock);
        }

        /// <summary>
        /// Configures the MSNRR SingleRating emulator to handle the backend request and submits the rating to the ratings FD and 
        /// </summary>
        /// <param name="userXuid">The user XUID of the user submitting the rating</param>
        /// <param name="mediaId">The mediaId of the media to rate</param>
        /// <param name="rating">the rating to be submitted</param>
        /// <param name="userCountryId">The user's CountryId</param>
        /// <param name="emulatorContentTypeId">MSNRR ContentTypeId GUID to be passed to the emulator</param>
        /// <param name="emulatorReturnCode">The return code that you wish the emulator to return</param>
        /// <returns>The XRLMsnSubmitRating request object</returns>
        private static XRLMsnSubmitRating SubmitRatingToEmulator(ulong userXuid, Guid mediaId, int rating, byte userCountryId, Guid emulatorContentTypeId, int emulatorReturnCode)
        {
            string emulatorUrl = SetupSubmitRatingEmulator(userXuid, mediaId, rating, userCountryId, emulatorContentTypeId, emulatorReturnCode);

            return SubmitRating(userXuid, mediaId, rating, userCountryId, emulatorUrl);
        }

        /// <summary>
        /// Gets the rating from the ratings FD using the currently configured backend
        /// </summary>
        /// <param name="user">The XeUser object of the user to get the rating for</param>
        /// <param name="mediaId">The mediaId of the media to get the rating for</param>
        /// <param name="alternateSingleRatingSessionURL">The AlternateSingleRatingSessionURL to use</param>
        /// <returns>The XRLMsnGetRating request object</returns>
        private static XRLMsnGetRating GetRating(XeUser user, Guid mediaId, string alternateSingleRatingSessionURL)
        {
            return GetRating(user.UserPuid, mediaId, user.CountryId, alternateSingleRatingSessionURL);
        }

        /// <summary>
        /// Optionally sets up the MSNRR SingleRating emulator to handle the backend request and gets the rating from the ratings FD
        /// </summary>
        /// <param name="userXuid">The user XUID of the user to get the rating for</param>
        /// <param name="mediaId">The mediaId of the media to get the rating for</param>
        /// <param name="userCountryId">The user's CountryId</param>
        /// <param name="alternateSingleRatingSessionURL">Alternate SingleRating URL to be used for retrieval</param>
        /// <returns>The XRLMsnGetRating request object</returns>
        private static XRLMsnGetRating GetRating(ulong userXuid, Guid mediaId, byte userCountryId, string alternateSingleRatingSessionURL)
        {
            Global.RO.Info("Creating a XRLMsnGetRating request...");

            XRLMsnGetRating request = new XRLMsnGetRating();
            request.Request.userXuid = userXuid;
            request.Request.mediaId = mediaId;
            request.Request.userCountryId = userCountryId;
            request.Slot.AddService(XOService.Ratings);

            if (alternateSingleRatingSessionURL != null)
            {
                request.CustomHeader = String.Format("AlternateSingleRatingSessionUrl: {0}\r\n", alternateSingleRatingSessionURL);
            }

            if (!request.Execute())
            {
                Global.RO.Warn("The XRLMsnGetRating request failed!");
            }

            return request;
        }

        /// <summary>
        /// Sets up the emulator to handle a GetRating request
        /// </summary>
        /// <param name="userXuid">The user XUID of the user to get the rating for</param>
        /// <param name="mediaId">The mediaId of the media to get the rating for</param>
        /// <param name="userCountryId">The user's CountryId</param>
        /// <param name="emulatorContentTypeId">MSNRR ContentTypeId GUID to be passed to the emulator</param>
        /// <param name="emulatorReturnCode">The return code that you wish the emulator to return</param>
        /// <param name="ratingToReturn">The rating value that you wish the emulator to return</param>
        /// <returns>The URL for the specified emulator behavior</returns>
        private static string SetupGetRatingEmulator(ulong userXuid, Guid mediaId, byte userCountryId, Guid emulatorContentTypeId, int emulatorReturnCode, int ratingToReturn)
        {
            Global.RO.Info("Setting up the MSNRR SingleRating Emulator...");

            SingleRatingEmulator emulator = new SingleRatingEmulator();
            ISingleRatingSoap mock = emulator.StartRecording();
            mock.GetRatingByUser(emulatorContentTypeId, mediaId, (long)userXuid, Guid.Empty, out ratingToReturn);
            
            // TODO: Set the proper IgnoresArguments
            // if ratingToReturn is something than -1 we should return the value specified
            if (ratingToReturn == -1)
            {
                LastCall.On(mock).IgnoresArgument(0).IgnoresArgument(1).IgnoresArgument(2).IgnoresArgument(3).Returns(emulatorReturnCode);
            }
            else
            {
                // return the specified ratingToReturn
                LastCall.On(mock).IgnoresArgument(0).IgnoresArgument(1).IgnoresArgument(2).IgnoresArgument(3).OutArguments(null, null, null, null, ratingToReturn).Returns(emulatorReturnCode);
            }

            emulator.StopRecording(mock);

            return emulator.GetUrl(mock);
        }

        /// <summary>
        /// Configures the MSNRR SingleRating emulator to handle the backend request and gets the rating from the ratings FD
        /// </summary>
        /// <param name="userXuid">The user XUID of the user to get the rating for</param>
        /// <param name="mediaId">The mediaId of the media to get the rating for</param>
        /// <param name="userCountryId">The user's CountryId</param>
        /// <param name="emulatorContentTypeId">MSNRR ContentTypeId GUID to be passed to the emulator</param>
        /// <param name="emulatorReturnCode">The return code that you wish the emulator to return</param>
        /// <param name="ratingToReturn">The rating value that you wish the emulator to return</param>
        /// <returns>The XRLMsnGetRating request object</returns>
        private static XRLMsnGetRating GetRatingFromEmulator(ulong userXuid, Guid mediaId, byte userCountryId, Guid emulatorContentTypeId, int emulatorReturnCode, int ratingToReturn)
        {
            string emulatorUrl = SetupGetRatingEmulator(userXuid, mediaId, userCountryId, emulatorContentTypeId, emulatorReturnCode, ratingToReturn);

            return GetRating(userXuid, mediaId, userCountryId, emulatorUrl);
        }

        /// <summary>
        /// Creates a XeUser to be used by ratings test cases
        /// </summary>
        /// <param name="userType">A UserType enumator indicating what type of user to create (only Gold and Silver are supported)</param>
        /// <param name="country">XeUser.Country enumerator indicating which country should be used to create the user</param>
        /// <returns>The created XeUser object</returns>
        private static XeUser CreateRatingsUser(UserType userType, XeUser.Country country)
        {
            XeUser user = new XeUser(true, country);
            switch (userType)
            {
                case UserType.Gold:
                    {
                        user.CreateAsGold = true;
                        break;
                    }

                case UserType.Silver:
                    {
                        // users are silver by default
                        break;
                    }

                default:
                    {
                        throw new Exception("Unable to create user due to an unsupported UserType being specified.");
                    }
            }

            if (user.Create() == 0)
            {
                throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            }

            UacsCommon.WaitForXCache();
            
            return user;
        }

        /// <summary>
        /// Submits the rating and validates the retrieved ratingToReturn matches the submitted ratingToReturn
        /// </summary>
        /// <param name="user">The XeUser whose Xuid will be used to submit the rating</param>
        /// <param name="mediaId">The mediaId to submit the rating for</param>
        /// <param name="rating">the rating value to rate the media</param>
        /// <param name="alternateSingleRatingSessionUrl">The URL to use for the AlternateSingleRatingSessionURL</param>
        private static void SubmitThenGetRating(XeUser user, Guid mediaId, int rating, string alternateSingleRatingSessionUrl)
        {
            XRLMsnSubmitRating submitRatingRequest = SubmitRating(user.UserPuid, mediaId, rating, user.CountryId, alternateSingleRatingSessionUrl);
            if (submitRatingRequest.XErr != HResult.S_OK)
            {
                throw new Exception(submitRatingRequest.GetDumpString());
            }

            XRLMsnGetRating getRatingRequest = GetRating(user.UserPuid, mediaId, user.CountryId, alternateSingleRatingSessionUrl);
            if (getRatingRequest.XErr == HResult.S_OK)
            {
                if (getRatingRequest.Response.userValue != rating)
                {
                    throw new Exception(String.Format("The retrieved user ratingToReturn does not match the submitted user ratingToReturn. (Expected: {0} Retrieved: {1})", rating, getRatingRequest.Response.userValue));
                }
            }
            else
            {
                throw new Exception(getRatingRequest.GetDumpString());
            }
        }

        /// <summary>
        /// Submits the rating for media and then rates the same media again
        /// </summary>
        /// <param name="user">The XeUser whose Xuid will be used to submit the rating</param>
        /// <param name="mediaId">The mediaId to submit the rating for</param>
        /// <param name="initialRating">The initial ratingToReturn value to rate the media</param>
        /// <param name="updatedRating">the rating value to update media with</param>
        private static void SubmitThenUpdateRating(XeUser user, Guid mediaId, int initialRating, int updatedRating)
        {
            XRLMsnSubmitRating submitRatingRequest = SubmitRating(user.UserPuid, mediaId, initialRating, user.CountryId, null);
            if (submitRatingRequest.XErr != HResult.S_OK)
            {
                throw new Exception(submitRatingRequest.GetDumpString());
            }

            SubmitThenGetRating(user, mediaId, updatedRating, null);
        }

        /// <summary>
        /// Gets the rating for the passed in user for the passed in media and validates the rating returned is zero
        /// </summary>
        /// <param name="user">The XeUser whose Xuid will be used to retrieve the rating</param>
        /// <param name="mediaId">The mediaId to retrieve the rating for</param>
        private static void GetRatingForUnratedGame(XeUser user, Guid mediaId)
        {
            XRLMsnGetRating request = GetRating(user.UserPuid, mediaId, user.CountryId, null);
            if (request.XErr != HResult.S_OK)
            {
                throw new Exception(request.GetDumpString());
            }

            if (request.Response.userValue != 0)
            {
                throw new Exception("The user's ratingToReturn for the media was not 0.");
            }
        }

        /// <summary>
        /// Overrides the value of the Ventura authorization endpoint
        /// </summary>
        private static void OverrideVenturaAuthorizationEndpoint()
        {
            // TODO: Write code that will change the value of the authorization endpoint
            // We may have to rely on Fiddler2 to intercept the manifest request and alter the response
            Global.RO.Warn("Fiddler2 must be setup to intercept the get manifest request to Ventura SDS and respond with an invalid authorization endpoint in the manifest XML.");
        }

        /// <summary>
        /// Overrides the value of the Ventura submit ratingToReturn endpoint
        /// </summary>
        private static void OverrideVenturaSubmitRatingEndpoint()
        {
            // TODO: Write code that will change the value of the submit ratingToReturn endpoint
            // We may have to rely on Fiddler2 to intercept the manifest request and alter the response
            Global.RO.Warn("Fiddler2 must be setup to intercept the get manifest request to Ventura SDS and respond with an invalid submit rating endpoint in the manifest XML.");
        }

        /// <summary>
        /// Overrides the value of the Ventura authorization endpoint
        /// </summary>
        private static void OverrideVenturaGetRatingEndpoint()
        {
            // TODO: Write code that will change the value of the get ratingToReturn endpoint
            // We may have to rely on Fiddler2 to intercept the manifest request and alter the response
            Global.RO.Warn("Fiddler2 must be setup to intercept the get manifest request to Ventura SDS and respond with an invalid get rating endpoint in the manifest XML.");
        }

        #endregion

        #region Configuration independent functional tests

        /// <summary>
        /// Functional test cases for the XBL Ratings FD that functional independent of what backend the front door is configured to use
        /// </summary>
        [TestGroup, TestCasePriority(2), TestFrequency("Daily"), Description("Functional test cases for the XBL Ratings FD that functional independent of what backend the front door is configured to use")]
        public class ConfigurationIndependentFunctionalTests : TestNode
        {
            #region Configuration independent functional tests - Positive

            /// <summary>
            /// Attemts to submit a rating while the FD kill switch is on
            /// </summary>
            [TestCase, TestCasePriority(3), Description("Validates the XBL Ratings FD behavior when the kill switch is on and the rating is submitted")]
            public void SubmitRatingWhileKillSwitchIsOn()
            {
                try
                {
                    OverrideRatingsFdSetting("msnrr_ignorefdrequests", "true", true);
                    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.MX), Common.GetMediaIdFromCatalog(47), 1, null);
                    if (request.XErr != HResult.S_OK)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
                finally
                {
                    OverrideRatingsFdSetting("msnrr_ignorefdrequests", "false", true);
                }
            }

            /// <summary>
            /// Attempts to get a rating while the FD kill switch is on
            /// </summary>
            [TestCase, TestCasePriority(3), Description("Validates the XBL Ratings FD behavior when the kill switch is on and an attempt to retrieve the rating is made.")]
            public void GetRatingWhileKillSwitchIsOn()
            {
                try
                {
                    OverrideRatingsFdSetting("msnrr_ignorefdrequests", "true", true);
                    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.AT), Common.GetMediaIdFromCatalog(37), null);
                    if (request.XErr != HResult.S_OK)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
                finally
                {
                    OverrideRatingsFdSetting("msnrr_ignorefdrequests", "false", true);
                }
            }

            #endregion

            #region Configuration independent functional tests - Negative

            /// <summary>
            /// Attempts to submit a rating with an invalid user Xuid of 0
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid user xuid (0) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidUserXuidZero()
            {
                XRLMsnSubmitRating request = SubmitRating((ulong)0, Common.GetMediaIdFromCatalog(34), 2, (byte)XeUser.Country.BE, null);
                if (request.XErr != HResult.XONLINE_E_SERVER_ERROR)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid user Xuid of ulong.MaxValue 
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid user xuid (ulong.MaxValue) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidUserXuidMaxValue()
            {
                XRLMsnSubmitRating request = SubmitRating(ulong.MaxValue, Common.GetMediaIdFromCatalog(30), 3, (byte)XeUser.Country.BR, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_ERROR_GETUSER)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with a mediaId that is not in the XBL Catalog (Guid.NewGuid())
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid mediaId (not in the catalog) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidMediaIdNotInCatalog()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.CH), Guid.NewGuid(), 4, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_MEDIA)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with a mediaId for an unratable media type (Arcade Game Trial)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid mediaId (unratable media type) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidMediaIdNotRatableMediaType()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Silver, XeUser.Country.CL), Common.GetMediaIdFromCatalog(5), 5, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_MEDIATYPE)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid mediaId (Guid.Empty)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid mediaId (Guid.Empty) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidMediaIdEmptyGuid()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.CO), Guid.Empty, 1, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_MISSING_MEDIA_ID_ON_GET_MEDIA_INFO)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid rating value (-1)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid ratingToReturn (-1) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidRatingNegativeNumber()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Silver, XeUser.Country.CZ), Common.GetMediaIdFromCatalog(23), -1, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_RATING)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid rating value (0)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid ratingToReturn (0) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidRatingZero()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.DK), Common.GetMediaIdFromCatalog(22), 0, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_RATING)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid rating value (6)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid ratingToReturn (6) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidRatingSix()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Silver, XeUser.Country.ES), Common.GetMediaIdFromCatalog(21), 6, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_RATING)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid rating value (Int32.MaxValue)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid ratingToReturn (Int32.MaxValue) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidRatingMaxValue()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.FI), Common.GetMediaIdFromCatalog(20), Int32.MaxValue, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_RATING)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to submit a rating with an invalid user countryId (Byte.MaxValue)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid user countryId (Byte.MaxValue) passed in for a SubmitRating request")]
            public void SubmitRatingWithInvalidUserCountryIdMaxValue()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Silver, XeUser.Country.GR).UserPuid, Common.GetMediaIdFromCatalog(19), 2, Byte.MaxValue, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_COUNTRY)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get a rating with an invalid user Xuid (0)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid user xuid (0) passed in for a GetRating request")]
            public void GetRatingWithInvalidUserXuidZero()
            {
                XRLMsnGetRating request = GetRating((ulong)0, Common.GetMediaIdFromCatalog(18), (byte)XeUser.Country.HK, null);
                if (request.XErr != HResult.XONLINE_E_SERVER_ERROR)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get a rating with an invalid user Xuid (ulong.MaxValue)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid user xuid (ulong.MaxValue) passed in for a GetRating request")]
            public void GetRatingWithInvalidUserXuidMaxValue()
            {
                XRLMsnGetRating request = GetRating(ulong.MaxValue, Common.GetMediaIdFromCatalog(1), (byte)XeUser.Country.HU, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_ERROR_GETUSER)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get a rating for a mediaId that is not in the XBL Catalog (Guid.NewGuid())
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid mediaId (not in the catalog) passed in for a GetRating request")]
            public void GetRatingWithInvalidMediaIdNotInCatalog()
            {
                XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.IE), Guid.NewGuid(), null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_MEDIA)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get a rating for a mediaId that is not a ratable media type (Game Consumable)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid mediaId (unratable media type) passed in for a GetRating request")]
            public void GetRatingWithInvalidMediaIdNotRatableMediaType()
            {
                XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.IN), Common.GetMediaIdFromCatalog(24), null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_MEDIATYPE)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get a rating for an invalid mediaId (Guid.Empty)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid mediaId (Guid.Empty) passed in for a GetRating request")]
            public void GetRatingWithInvalidMediaIdEmptyGuid()
            {
                XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.IT), Guid.Empty, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_MISSING_MEDIA_ID_ON_GET_MEDIA_INFO)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get a rating with an invalid user countryId (Byte.MaxValue)
            /// </summary>
            [TestCase, Description("Validates the XBL Ratings FD behavior when an invalid user countryId (Byte.MaxValue) passed in for a GetRating request")]
            public void GetRatingWithInvalidUserCountryIdMaxValue()
            {
                XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.KR).UserPuid, Common.GetMediaIdFromCatalog(23), Byte.MaxValue, null);
                if (request.XErr != HResult.XONLINE_E_RATINGS_INVALID_COUNTRY)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            #endregion
        }

        #endregion

        #region MSNRR configured functional test cases

        /// <summary>
        /// Functional test cases dependent on the XBL Ratings FD being configured to only use the MSNRR backend
        /// </summary>
        [TestGroup, TestCasePriority(1), TestFrequency("Daily"), Description("Test")]
        public class MSNRROnlyFunctionalTests : TestNode
        {
            #region PreRun and PostRun

            /// <summary>
            /// The SettingState of the ratings_use_msnrr setting prior to running the test group
            /// </summary>
            private SettingState previousUseMSNRRSettingState;

            /// <summary>
            /// The SettingState of the ratings_use_ventura setting prior to running the test group
            /// </summary>
            private SettingState previousUseVenturaSettingState;

            /// <summary>
            /// Configures the XBL Ratings FD to only use the MSNRR backend
            /// </summary>
            public override void PreRun()
            {
                Global.RO.Info("Performing PreRun XBL Ratings FD configuration...");

                Global.RO.Info("Configuring the XBL Ratings FD to use ONLY the MSNRR backend...");
                this.previousUseMSNRRSettingState = OverrideRatingsFdSetting("ratings_use_msnrr", "true", false);
                this.previousUseVenturaSettingState = OverrideRatingsFdSetting("ratings_use_ventura", "false", true);
                Global.RO.Info("Saving the setting state so it can be restored...");
            }

            /// <summary>
            /// Restores the XBL Ratings FD backend settings that were present prior to the test group being executed
            /// </summary>
            public override void PostRun()
            {
                Global.RO.Info("Restoring the previous XBL Ratings FD configuration...");
                RestoreRatingsFdSetting(this.previousUseMSNRRSettingState, false);
                RestoreRatingsFdSetting(this.previousUseVenturaSettingState, true);
            }

            #endregion

            #region MSNRR configured functional test cases - Positive

            /// <summary>
            /// Submits a rating and retrieves it while the XBL Ratings FD is configured to only use the MSNRR backend
            /// </summary>
            [TestCase, Description("Submits the rating and retrieves it while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            public void MSNRRSubmitThenGetRating()
            {
                try
                {
                    SubmitThenGetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.NL), Common.GetMediaIdFromCatalog(22), 3, null);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Submits a rating to the emulator and retrieves a rating from the emulator while the XBL Ratings FD is configured to only use the MSNRR backend
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Submits the rating and retrieves it using the emulator while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            public void MSNRRSubmitThenGetRatingUsingEmulator()
            {
                XeUser user = CreateRatingsUser(UserType.Silver, XeUser.Country.NO);
                Guid mediaId = Common.GetMediaIdFromCatalog(21);

                // TODO: Need to write the code to deserialize the contenttypeid mappings XML
                XRLMsnSubmitRating submitRatingRequest = SubmitRatingToEmulator(user.UserPuid, mediaId, 4, user.CountryId, Guid.Empty, (int)HResult.S_OK);
                if (submitRatingRequest.XErr != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException(submitRatingRequest.GetDumpString());
                }

                XRLMsnGetRating getRatingRequest = GetRatingFromEmulator(user.UserPuid, mediaId, user.CountryId, Guid.Empty, (int)HResult.S_OK, -1);
                if (getRatingRequest.XErr != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException(getRatingRequest.GetDumpString());
                }
            }

            /// <summary>
            /// Submits a rating and then updates the rating while the XBL Ratings FD is configured to use only the MSNRR backend
            /// </summary>
            [TestCase, Description("Submits the rating and updates the rating while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            public void MSNRRUpdateExistingRating()
            {
                try
                {
                    SubmitThenUpdateRating(CreateRatingsUser(UserType.Gold, XeUser.Country.NZ), Common.GetMediaIdFromCatalog(20), 5, 1);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Overrides the Ventura SDS endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend
            /// </summary>
            [TestCase, TestCasePriority(3), Description("Overrides the Ventura SDS endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            public void MSNRRSubmitThenGetRatingWhileVenturaSDSEndpointIsInvalid()
            {
                SettingState previousVenturaSDSEndpoint = new SettingState();

                try
                {
                    previousVenturaSDSEndpoint = OverrideRatingsFdSetting("venturarr_serviceDirectoryServiceUrl", "http://invalidVenturaSDSUrl.com", true);
                    Common.RecycleRatingsAppPool();
                    SubmitThenGetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.PL), Common.GetMediaIdFromCatalog(19), 2, null);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
                finally
                {
                    RestoreRatingsFdSetting(previousVenturaSDSEndpoint, true);
                }
            }

            /*
            /// <summary>
            /// Overrides the Ventura authorization endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.
            /// </summary>
            //[TestCase, TestCasePriority(3), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura authorization endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            //public void MSNRRSubmitThenGetRatingWhileVenturaAuthorizationEndpointIsInvalid()
            //{
            //    try
            //    {
            //        OverrideVenturaAuthorizationEndpoint();
            //        SubmitThenGetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.PL), Common.GetMediaIdFromCatalog(19), 2, null);
            //    }
            //    catch (Exception e)
            //    {
            //        throw new UnexpectedTestResultException("An exception occurred!", e);
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura submit ratingToReturn endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.
            /// </summary>
            //[TestCase, TestCasePriority(3), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura submit ratingToReturn endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            //public void MSNRRSubmitThenGetRatingWhileVenturaSubmitRatingEndpointIsInvalid()
            //{
            //    try
            ///    {
            //        OverrideVenturaSubmitRatingEndpoint();
            //        SubmitThenGetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.PT), Common.GetMediaIdFromCatalog(18), 3, null);
            //    }
            //    catch (Exception e)
            //    {
            //        throw new UnexpectedTestResultException("An exception occurred!", e);
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura get ratingToReturn endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.
            /// </summary>
            //[TestCase, TestCasePriority(3), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura get ratingToReturn endpoint to be invalid, submits the rating, and then gets the rating while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            //public void MSNRRSubmitThenGetRatingWhileVenturaGetRatingEndpointIsInvalid()
            //{
            //    try
            //    {
            //        OverrideVenturaGetRatingEndpoint();
            //        SubmitThenGetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.RU), Common.GetMediaIdFromCatalog(1), 4, null);
            //    }
            //    catch (Exception e)
            //    {
            //        throw new UnexpectedTestResultException("An exception occurred!", e);
            //    }
            //}
            */

            /// <summary>
            /// Gets the rating for a game the user has never rated while the XBL Ratings FD is configured to use only the MSNRR backend.
            /// </summary>
            [TestCase, Description("Gets the rating for a game the user has never rated while the XBL Ratings FD is configured to use only the MSNRR backend.")]
            public void MSNRRGetRatingForUnratedGame()
            {
                try
                {
                    GetRatingForUnratedGame(CreateRatingsUser(UserType.Gold, XeUser.Country.SE), Common.GetMediaIdFromCatalog(47));
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            #endregion

            #region MSNRR configured functional test cases - Negative

            /// <summary>
            /// Attempts to submit the rating while the XBL Ratings FD is configured to point to an invalid MSNRR URL
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Attempts to submit the rating while the XBL Ratings FD is configured to point to an invalid MSNRR URL")]
            public void MSNRRSubmitRatingUsingInvalidMSNRRUrl()
            {
                XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Silver, XeUser.Country.SG), Common.GetMediaIdFromCatalog(37), 5, "http://invalidMSNRRURL.com");
                if (request.XErr != HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            /// <summary>
            /// Attempts to get the rating while the XBL Ratings FD is configured to point to an invalid MSNRR URL
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Attempts to get the rating while the XBL Ratings FD is configured to point to an invalid MSNRR URL")]
            public void MSNRRGetRatingUsingInvalidMSNRRUrl()
            {
                XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.TW), Common.GetMediaIdFromCatalog(34), "http://invalidMSNRRURL.com");
                if (request.XErr != HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR)
                {
                    throw new UnexpectedTestResultException(request.GetDumpString());
                }
            }

            #endregion
        }

        #endregion

        #region Ventura configured functional test cases

        /// <summary>
        /// Functional test cases dependent on the XBL Ratings FD being configured to only use the MSNRR backend
        /// </summary>
        [TestGroup, TestCasePriority(1), TestFrequency("Daily")]
        public class VenturaOnlyFunctionalTests : TestNode
        {
            #region PreRun and PostRun

            /// <summary>
            /// The SettingState of the ratings_use_msnrr setting prior to running the test group
            /// </summary>
            private SettingState previousUseMSNRRSettingState;

            /// <summary>
            /// The SettingState of the ratings_use_ventura setting prior to running the test group
            /// </summary>
            private SettingState previousUseVenturaSettingState;

            /// <summary>
            /// Configures the XBL Ratings FD to use only the Ventura backend
            /// </summary>
            public override void PreRun()
            {
                Global.RO.Info("Performing PreRun XBL Ratings FD configuration...");

                Global.RO.Info("Configuring the XBL Ratings FD to use ONLY the Ventura backend...");
                this.previousUseMSNRRSettingState = OverrideRatingsFdSetting("ratings_use_msnrr", "false", false);
                this.previousUseVenturaSettingState = OverrideRatingsFdSetting("ratings_use_ventura", "true", true);
                Global.RO.Info("Saving the setting state so it can be restored...");
            }

            /// <summary>
            /// Restores the previous XBL Ratings FD configuration settings
            /// </summary>
            public override void PostRun()
            {
                Global.RO.Info("Restoring the previous XBL Ratings FD configuration...");
                RestoreRatingsFdSetting(this.previousUseMSNRRSettingState, false);
                RestoreRatingsFdSetting(this.previousUseVenturaSettingState, true);
            }

            #endregion

            #region Ventura configured functional test cases - Positive

            /// <summary>
            /// Submits the rating and retrieves it while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, Description("Submits the rating and retrieves it while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaSubmitThenGetRating()
            {
                try
                {
                    SubmitThenGetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.US), Common.GetMediaIdFromCatalog(1), 1, null);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Submits the rating and updates the same ratingToReturn while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, Description("Submits the rating and updates the same ratingToReturn while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaUpdateExistingRating()
            {
                try
                {
                    SubmitThenUpdateRating(CreateRatingsUser(UserType.Silver, XeUser.Country.GB), Common.GetMediaIdFromCatalog(18), 2, 3);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Submits the rating and retrieves it while the XBL Ratings FD is configured to use an invalid MSNRR URL and is configured to only the Ventura backend
            /// </summary>
            [TestCase, TestCasePriority(3), Description("Submits the rating and retrieves it while the XBL Ratings FD is configured to use an invalid MSNRR URL and is configured to only the Ventura backend.")]
            public void VenturaSubmitThenGetRatingUsingInvalidMSNRRUrl()
            {
                try
                {
                    SubmitThenGetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.CA), Common.GetMediaIdFromCatalog(19), 4, "http://invalidMSNRRUrl.com");
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Gets the rating for a game the user has never rated while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, Description("Gets the rating for a game the user has never rated while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaGetRatingForUnratedGame()
            {
                try
                {
                    GetRatingForUnratedGame(CreateRatingsUser(UserType.Silver, XeUser.Country.FR), Common.GetMediaIdFromCatalog(20));
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /*
            /// <summary>
            /// Overrides the Ventura submit ratingToReturn endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura submit ratingToReturn endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaGetRatingWhileVenturaSubmitRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaSubmitRatingEndpoint();
            //    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.NO), Common.GetMediaIdFromCatalog(37), null);
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaSubmitRatingWhileVenturaGetRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaGetRatingEndpoint();
            //    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.NZ), Common.GetMediaIdFromCatalog(47), 3, null);
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}
            */

            #endregion

            #region Ventura configured functional test cases - Negative

            /// <summary>
            /// Overrides the Ventura SDS endpoint to be invalid and attempts to the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Overrides the Ventura SDS endpoint to be invalid and attempts to the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaSubmitRatingWhileVenturaSDSEndpointIsInvalid()
            {
                SettingState previousVenturaSDSEndpoint = new SettingState();

                try
                {
                    previousVenturaSDSEndpoint = OverrideRatingsFdSetting("venturarr_serviceDirectoryServiceUrl", "http://invalidVenturaSDSUrl.com", true);
                    Common.RecycleRatingsAppPool();
                    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.AU), Common.GetMediaIdFromCatalog(21), 5, null);
                    if (request.XErr != HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
                finally
                {
                    RestoreRatingsFdSetting(previousVenturaSDSEndpoint, true);
                }
            }

            /// <summary>
            /// Overrides the Ventura SDS endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Overrides the Ventura SDS endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaGetRatingWhileVenturaSDSEndpointIsInvalid()
            {
                SettingState previousVenturaSDSEndpoint = new SettingState();

                try
                {
                    previousVenturaSDSEndpoint = OverrideRatingsFdSetting("venturarr_serviceDirectoryServiceUrl", "http://invalidVenturaSDSUrl.com", true);
                    Common.RecycleRatingsAppPool();
                    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.DE), Common.GetMediaIdFromCatalog(22), null);
                    if (request.XErr != HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
                finally
                {
                    RestoreRatingsFdSetting(previousVenturaSDSEndpoint, true);
                }
            }

            /*
            /// <summary>
            /// Overrides the Ventura authorization endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura authorization endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaSubmitRatingWhileVenturaAuthorizationEndpointIsInvalid()
            //{
            //    OverrideVenturaAuthorizationEndpoint();
            //    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.JP), Common.GetMediaIdFromCatalog(23), 1, null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura authorization endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura authorization endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaGetRatingWhileVenturaAuthorizationEndpointIsInvalid()
            //{
            //    OverrideVenturaAuthorizationEndpoint();
            //    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.MX), Common.GetMediaIdFromCatalog(30), null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura submit ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura submit ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaSubmitRatingWhileVenturaSubmitRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaSubmitRatingEndpoint();
            //    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.NL), Common.GetMediaIdFromCatalog(34), 2, null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaGetRatingWhileVenturaGetRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaGetRatingEndpoint();
            //    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.PL), Common.GetMediaIdFromCatalog(1), null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}
            */

            #endregion
        }

        #endregion

        #region Ventura with MSNRR configured functional tests

        /// <summary>
        /// Functional test cases dependent on the XBL Ratings FD being configured to use the Ventura and MSNRR backends
        /// </summary>
        [TestGroup, TestCasePriority(1), TestFrequency("Daily")]
        public class VenturaWithMSNRRFunctionalTests : TestNode
        {
            #region PreRun and PostRun

            /// <summary>
            /// The SettingState of the ratings_use_msnrr setting prior to running the test group
            /// </summary>
            private SettingState previousUseMSNRRSettingState;

            /// <summary>
            /// The SettingState of the ratings_use_ventura setting prior to running the test group
            /// </summary>
            private SettingState previousUseVenturaSettingState;

            /// <summary>
            /// Configures the XBL Ratings FD to use both the Ventura and MSNRR backends
            /// </summary>
            public override void PreRun()
            {
                Global.RO.Info("Performing PreRun XBL Ratings FD configuration...");

                Global.RO.Info("Configuring the XBL Ratings FD to use both the Ventura and MSNRR backends...");
                this.previousUseMSNRRSettingState = OverrideRatingsFdSetting("ratings_use_msnrr", "true", false);
                this.previousUseVenturaSettingState = OverrideRatingsFdSetting("ratings_use_ventura", "true", true);
                Global.RO.Info("Saving the setting state so it can be restored...");
            }

            /// <summary>
            /// Restores the XBL Ratings configuration settings to their values prior to running this test suite
            /// </summary>
            public override void PostRun()
            {
                Global.RO.Info("Restoring the previous XBL Ratings FD configuration...");
                RestoreRatingsFdSetting(this.previousUseMSNRRSettingState, false);
                RestoreRatingsFdSetting(this.previousUseVenturaSettingState, true);
            }

            #endregion

            #region Ventura with MSNRR configured functional tests - Positive

            /// <summary>
            /// Submits the rating and retrieves it while the XBL Ratings FD is configured to use both backends
            /// </summary>
            [TestCase, Description("Submits the rating and retrieves it while the XBL Ratings FD is configured to use both backends.")]
            public void VenturaWithMSNRRSubmitThenGetRating()
            {
                try
                {
                    SubmitThenGetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.PT), Common.GetMediaIdFromCatalog(18), 4, null);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Submits the rating and updates the same ratingToReturn while the XBL Ratings FD is configured to use both backends
            /// </summary>
            [TestCase, Description("Submits the rating and updates the same ratingToReturn while the XBL Ratings FD is configured to use both backends.")]
            public void VenturaWithMSNRRUpdateExistingRating()
            {
                try
                {
                    SubmitThenUpdateRating(CreateRatingsUser(UserType.Silver, XeUser.Country.RU), Common.GetMediaIdFromCatalog(19), 5, 1);
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Submits the rating and retrieves it while the XBL Ratings FD is configured to use both backends
            /// </summary>
            [TestCase, Description("Submits the rating and retrieves it while the XBL Ratings FD is configured to use both backends.")]
            public void VenturaWithMSNRRSubmitThenGetRatingUsingInvalidMSNRRUrl()
            {
                try
                {
                    SubmitThenGetRating(CreateRatingsUser(UserType.Gold, XeUser.Country.SE), Common.GetMediaIdFromCatalog(20), 2, "http://invalidMSNRRUrl.com");
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Gets the rating for a game the user has never rated while the XBL Ratings FD is configured to both backends
            /// </summary>
            [TestCase, Description("Gets the rating for a game the user has never rated while the XBL Ratings FD is configured to both backends.")]
            public void VenturaWithMSNRRGetRatingForUnratedGame()
            {
                try
                {
                    GetRatingForUnratedGame(CreateRatingsUser(UserType.Silver, XeUser.Country.SG), Common.GetMediaIdFromCatalog(21));
                }
                catch (Exception e)
                {
                    throw new UnexpectedTestResultException("An exception occurred!", e);
                }
            }

            /// <summary>
            /// Tests that we properly fallback to MSNRR when the rating is not present in Ventura
            /// </summary>
            [TestCase, Description("Tests that we properly fallback to MSNRR when the rating is not present in Ventura")]
            public void VenturaWithMSNRRUnratedGameFallback()
            {
                XeUser user = CreateRatingsUser(UserType.Gold, XeUser.Country.CL);
                Guid mediaId = Common.GetMediaIdFromCatalog(19);
                int rating = 3;
                
                // We don't submit a rating and use the emulator to return a value should the XBL Ratings FD call the MSNRR GetRating API
                XRLMsnGetRating getRatingRequest = GetRatingFromEmulator(user.UserPuid, mediaId, user.CountryId, Guid.Empty, (int)HResult.S_OK, rating); 
                if (getRatingRequest.XErr == HResult.S_OK)
                {
                    if (getRatingRequest.Response.userValue != rating)
                    {
                        throw new UnexpectedTestResultException(String.Format("The retrieved user ratingToReturn does not match the expected user ratingToReturn. (Expected: {0} Retrieved: {1})", rating, getRatingRequest.Response.userValue));
                    }
                }
                else
                {
                    throw new UnexpectedTestResultException(getRatingRequest.GetDumpString());
                }
            }

            /*
            /// <summary>
            /// Overrides the Ventura submit rating endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura submit ratingToReturn endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaWithMSNRRGetRatingWhileVenturaSubmitRatingEndpointIsInvalid()
            //{
            //    XeUser user = CreateRatingsUser(UserType.Silver, XeUser.Country.BE);
            //    Guid mediaId = Common.GetMediaIdFromCatalog(47);
            //    int rating = 1;
            //    XRLMsnSubmitRating submitRatingRequest = SubmitRating(user.UserPuid, mediaId, rating, user.CountryId, null);
            //    if (submitRatingRequest.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(submitRatingRequest.GetDumpString());
            //    }
            //    
            //    OverrideVenturaSubmitRatingEndpoint();
            //    XRLMsnGetRating getRatingRequest = GetRating(user, mediaId, null);
            //    if (getRatingRequest.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(getRatingRequest.GetDumpString());
            //    }
            //    
            //    if (getRatingRequest.Response.userValue != rating)
            //    {
            //        throw new UnexpectedTestResultException(getRatingRequest.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaWithMSNRRSubmitRatingWhileVenturaGetRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaGetRatingEndpoint();
            //    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.BR), Common.GetMediaIdFromCatalog(1), 2, null);
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}
            */

            #endregion

            #region Ventura with MSNRR configured functional test cases - Negative

            /// <summary>
            /// Overrides the Ventura SDS endpoint to be invalid and attempts to the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Overrides the Ventura SDS endpoint to be invalid and attempts to the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaWithMSNRRSubmitRatingWhileVenturaSDSEndpointIsInvalid()
            {
                SettingState previousVenturaSDSEndpoint = new SettingState();

                try
                {
                    previousVenturaSDSEndpoint = OverrideRatingsFdSetting("venturarr_serviceDirectoryServiceUrl", "http://invalidVenturaSDSUrl.com", true);
                    Common.RecycleRatingsAppPool();
                    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.TW), Common.GetMediaIdFromCatalog(22), 3, null);
                    if (request.XErr != HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
                finally
                {
                    RestoreRatingsFdSetting(previousVenturaSDSEndpoint, true);
                }
            }

            /// <summary>
            /// Overrides the Ventura SDS endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            [TestCase, TestCasePriority(2), Description("Overrides the Ventura SDS endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            public void VenturaWithMSNRRGetRatingWhileVenturaSDSEndpointIsInvalid()
            {
                SettingState previousVenturaSDSEndpoint = new SettingState();

                try
                {
                    previousVenturaSDSEndpoint = OverrideRatingsFdSetting("venturarr_serviceDirectoryServiceUrl", "http://invalidVenturaSDSUrl.com", true);
                    Common.RecycleRatingsAppPool();
                    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.ZA), Common.GetMediaIdFromCatalog(23), null);
                    if (request.XErr != HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
                finally
                {
                    RestoreRatingsFdSetting(previousVenturaSDSEndpoint, true);
                }
            }

            /*
            /// <summary>
            /// Overrides the Ventura authorization endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura authorization endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaWithMSNRRSubmitRatingWhileVenturaAuthorizationEndpointIsInvalid()
            //{
            //    OverrideVenturaAuthorizationEndpoint();
            //    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.AE), Common.GetMediaIdFromCatalog(30), 4, null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura authorization endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura authorization endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaWithMSNRRGetRatingWhileVenturaAuthorizationEndpointIsInvalid()
            //{
            //    OverrideVenturaAuthorizationEndpoint();
            //    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.AT), Common.GetMediaIdFromCatalog(34), null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura submit rating endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura submit ratingToReturn endpoint to be invalid and attempts to submit the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaWithMSNRRSubmitRatingWhileVenturaSubmitRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaSubmitRatingEndpoint();
            //    XRLMsnSubmitRating request = SubmitRating(CreateRatingsUser(UserType.Gold, XeUser.Country.AU), Common.GetMediaIdFromCatalog(37), 5, null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}

            /// <summary>
            /// Overrides the Ventura get rating endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend
            /// </summary>
            //[TestCase, TestCasePriority(2), TestTag("Manual"), TestFrequency("Manual"), Description("Overrides the Ventura get ratingToReturn endpoint to be invalid and attempts to get the rating while the XBL Ratings FD is configured to use only the Ventura backend.")]
            //public void VenturaWithMSNRRGetRatingWhileVenturaGetRatingEndpointIsInvalid()
            //{
            //    OverrideVenturaGetRatingEndpoint();
            //    XRLMsnGetRating request = GetRating(CreateRatingsUser(UserType.Silver, XeUser.Country.CA), Common.GetMediaIdFromCatalog(18), null);
            //    
            //    // TODO: Need to determine what the actual error is here.... 
            //    if (request.XErr != HResult.S_OK)
            //    {
            //        throw new UnexpectedTestResultException(request.GetDumpString());
            //    }
            //}
            */

            #endregion
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rstrans.cpp ===
// ---------------------------------------------------------------------------------------
// umtrans.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Winsock and common service layer definitions
// ---------------------------------------------------------------------------------------

#include "compport.h"
#include "servsock.h"

class CSgSocket : public CServerSocketCallback
{
public:
    
    CSgSocket()
    {
        _ulRefCount = 0;
    }

    ULONG AddRef() { return (ULONG) InterlockedIncrement((volatile LONG*)&_ulRefCount); }
    ULONG Release() { return (ULONG) InterlockedDecrement((volatile LONG*)&_ulRefCount); }

    void OnSocketSendTo( BYTE *pbBufferSent, DWORD cbToSend, DWORD cbSent, HRESULT hr, QWORD qwCallbackArg );
    void OnSocketReceive( BYTE *pbFilledInBuffer, DWORD cbRead, HRESULT hr, QWORD qwCallbackArg );
    void OnSocketReceiveFrom( BYTE *pbFilledInBuffer, DWORD cbRead, sockaddr_in *pFilledInFrom, HRESULT hr, QWORD qwCallbackArg );

    void SetSocketInfo( CServerSocket* pSocket, CTransInfo* pTransInfo, BOOL fUDP ) 
    {
        _pSocket = pSocket;
        _pTransInfo = pTransInfo;
        _fUDP = fUDP;

        // Post the first receive
        RepostReceive();
    }
    void Term()
    {
        if( NULL != _pSocket )
        {
            // Shutdown socket. Closing the socket will abort pending operations
            _pSocket->Close();

            // Wait until the socket callbacks are not referenced anymore before fully 
            // shutting down
            while(_ulRefCount)
                ::Sleep(50);

            _pSocket->Release();
            _pSocket = NULL;
        }
        
        _fUDP = FALSE;
        _pTransInfo = 0;
    }

    BOOL IsActive() { return NULL != _pSocket; }
    CTransInfo* GetTransInfo() { return _pTransInfo; }
    CServerSocket* GetSocket() { return _pSocket; }

private:
    void RepostReceive();

    volatile ULONG _ulRefCount;
    BOOL           _fUDP;
    CServerSocket* _pSocket;
    CTransInfo*    _pTransInfo;
    BYTE           _rgbRecvBuffer[ CBFRAMEMAX ];
};


// ---------------------------------------------------------------------------------------
// SG IP Hook Filter Driver
// @@RAWNIC for DMZ
// ---------------------------------------------------------------------------------------

// #include "sgiphook.h"


// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

CCompletionPort* g_pCompletionPort = NULL;

/* @@RAWNIC for DMZ
// DMZ interface
CSgSocket g_SgDmzSocket;
CSgSocket g_SgMsgSocket;
HANDLE g_hIpHookDriver = INVALID_HANDLE_VALUE;
*/

// Internet interface
CSgSocket g_SgInetSocket;
CSgSocket g_SgInetSocket2;
CSgSocket g_SgInetSocket3;

// ---------------------------------------------------------------------------------------
// Forward Declarations
// ---------------------------------------------------------------------------------------

// @@RNTRANS -- Declare RNTrans functions so they can be called when datacenter traffic is
// exiting the service.
namespace RNTRANS
{
BOOL                TransInit();
BOOL                TransStart(CTransInfo* pTransInfo);
void                TransStop();
void                TransTerm(CTransInfo * pTransInfo);
void                TransTerm();
BOOL                TransInstall(OUT BOOL *pfRebootRequired);
BOOL                TransUninstall(OUT BOOL *pfRebootRequired);
BOOL                TransConfig(CCfgInfo* pci);
BOOL                TransConfigTransport(CCfgInfo* pci, CTransInfo* pTransInfo );
void                TransQueryCounters(CTransInfo* pTransInfo, CTransInfoCounters* pCounters);
BOOL                TransIsActive(CTransInfo * pTransInfo);
void                TransXmit(CPacket * ppkt);
}

// ---------------------------------------------------------------------------------------
// TransInit
// ---------------------------------------------------------------------------------------

BOOL TransInit()
{
    HRESULT hr;
    WSADATA wsaData;

    // Initialize Winsock
    int iReturn = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
    if( 0 != iReturn )
    {
        // If this fails we can't call WSAGetLastError because the provider is not yet initialized
        SgEventSz(CONFIG_ERROR, "Error: WSAStartup failed, error=%u", iReturn );
        return FALSE;
    }

    return RNTRANS::TransInit();

} 

// ---------------------------------------------------------------------------------------
// TransStop
// ---------------------------------------------------------------------------------------
void TransStop()
{
    RNTRANS::TransStop();
}

// ---------------------------------------------------------------------------------------
// TransTerm
// ---------------------------------------------------------------------------------------
void TransTerm()
{
    WSACleanup();
    RNTRANS::TransTerm();

} // UmTerm

// ---------------------------------------------------------------------------------------
// TransInstall
// ---------------------------------------------------------------------------------------

BOOL TransInstall(OUT BOOL *pfRebootRequired)
{
    return RNTRANS::TransInstall(pfRebootRequired);
}

// ---------------------------------------------------------------------------------------
// TransUninstall
// ---------------------------------------------------------------------------------------

BOOL TransUninstall(OUT BOOL *pfRebootRequired)
{
    return RNTRANS::TransUninstall(pfRebootRequired);
}

// ---------------------------------------------------------------------------------------
// TransConfig
// ---------------------------------------------------------------------------------------

BOOL TransConfig(CCfgInfo* pci)
{
//    UNREFERENCED_PARAMETER(pci);
    return RNTRANS::TransConfig(pci);
}

// ---------------------------------------------------------------------------------------
// TransConfigTransport
// ---------------------------------------------------------------------------------------

BOOL TransConfigTransport(CCfgInfo* pci, CTransInfo* pTransInfo )
{
    UNREFERENCED_PARAMETER(pci);

    BOOL fReturn = FALSE;
    HRESULT hr;
    sockaddr_in sin;
    CServerSocket* pSocket = NULL;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = pTransInfo->_ipa;
    sin.sin_port = 0;
    memset( &sin.sin_zero, 0, sizeof( sin.sin_zero ) );

    if( NULL == g_pCompletionPort )
    {
        hr = CCompletionPort::CreateInstance( 0, 0, THREAD_PRIORITY_NORMAL, &g_pCompletionPort );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed creating completion port, hr=0x%08X", hr );
            return FALSE;
        }
    }

    if( TRANSTYPE_DMZ == pTransInfo->_dwType )
    {
        return RNTRANS::TransConfigTransport(pci, pTransInfo);
/* @@RAWNIC for DMZ
        if( g_SgDmzSocket.IsActive() )
        {
            SgEventSz( CONFIG_ERROR, "Config warning: Onebox only allows one Datacenter interface" );
            goto Exit;
        }

        Assert( INVALID_HANDLE_VALUE == g_hIpHookDriver );

        // Create DMZ server socket
        hr = CServerSocket::CreateInstance( &pSocket, g_pCompletionPort, NULL );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed creating DMZ socket, hr=0x%08X", hr );
            goto Exit;
        }

        // We want this socket to listen on all ports
        sin.sin_port = 0;

        // Initialize the DMZ socket as an IP raw socket on all addresses
        hr = pSocket->Init( IPPROTO_IP, &sin, FALSE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed initializing datacenter server socket at addr %s:%u, hr=0x%08X", inet_ntoa( sin.sin_addr ), NTOHS( sin.sin_port ), hr );
            goto Exit;
        }

        // Store the socket (this will also kick of the initial receive)
        g_SgDmzSocket.SetSocketInfo( pSocket, pTransInfo, FALSE );
        pSocket = NULL;

        // Create DMZ SGMSG socket
        hr = CServerSocket::CreateInstance( &pSocket, g_pCompletionPort, NULL );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed creating SGMSG socket, hr=0x%08X", hr );
            goto Exit;
        }

        // We want this socket to listen on port 65535
        sin.sin_port = 0xFFFF;

        // Initialize the SgMsg socket as a UDP socket on all addresses
        hr = pSocket->Init( IPPROTO_UDP, &sin, FALSE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed initializing datacenter sgmsg socket at addr %s:%u, hr=0x%08X", inet_ntoa( sin.sin_addr ), NTOHS( sin.sin_port ), hr );
            goto Exit;
        }

        // Store the socket (this will also kick of the initial receive)
        g_SgMsgSocket.SetSocketInfo( pSocket, pTransInfo, TRUE );
        pSocket = NULL;

        // Load the kernel mode driver
        g_hIpHookDriver = SgIpHookLoadDriver();
        if( INVALID_HANDLE_VALUE == g_hIpHookDriver )
        {
            SgEventSz( CONFIG_ERROR, "Error: SgIpHookLoadDriver failed" );
            goto Exit;
        }

        // Set the hook driver to the correct range of ports, this will also turn it on
        if( !SgIpHookSetPortRange( g_hIpHookDriver, pTransInfo->_wIpportBeg, pTransInfo->_wIpportEnd ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed setting port range with hook driver" );
            goto Exit;
        }
*/
    }
    else
    {
        Assert( TRANSTYPE_INTERNET == pTransInfo->_dwType );

        if( g_SgInetSocket.IsActive() )
        {
            SgEventSz( CONFIG_ERROR, "Config warning: Onebox only allows one Internet interface" );
            goto Exit;
        }

        // 
        // Create Inet server socket (3074)
        //
        hr = CServerSocket::CreateInstance( &pSocket, g_pCompletionPort, NULL );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed creating Inet socket, hr=0x%08X", hr );
            goto Exit;
        }

        // We only want this socket to receive data for the XSP port
        sin.sin_port = XSP_PORT;

        // Initialize the Inet socket as a UDP socket on port 3074
        hr = pSocket->Init( IPPROTO_UDP, &sin, TRUE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed initializing internet server socket at addr %s:%u, hr=0x%08X", inet_ntoa( sin.sin_addr ), NTOHS( sin.sin_port ), hr );
            goto Exit;
        }

        // Ignore broadcasts on the Internet socket
        hr = pSocket->SetReceiveBroadcast( FALSE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed setting server socket broadcast option, hr=0x%08X", hr );
            goto Exit;
        }

        g_SgInetSocket.SetSocketInfo( pSocket, pTransInfo, TRUE );
        pSocket = NULL;


        //
        // Create Inet server socket for UDP echo (3075)
        //
        hr = CServerSocket::CreateInstance( &pSocket, g_pCompletionPort, NULL );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed creating Inet socket2, hr=0x%08X", hr );
            goto Exit;
        }

        // We only want this socket to receive data for the UDP echo port
        sin.sin_port = XSP_PORT_UDPECHO;

        // Initialize the Inet socket as a UDP socket on port 3076
        hr = pSocket->Init( IPPROTO_UDP, &sin, TRUE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed initializing internet server socket at addr %s:%u, hr=0x%08X", inet_ntoa( sin.sin_addr ), NTOHS( sin.sin_port ), hr );
            goto Exit;
        }

        // Ignore broadcasts on the Internet socket
        hr = pSocket->SetReceiveBroadcast( FALSE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed setting server socket broadcast option, hr=0x%08X", hr );
            goto Exit;
        }

        g_SgInetSocket2.SetSocketInfo( pSocket, pTransInfo, TRUE );
        pSocket = NULL;


        //
        // Create Inet server socket for XSP echo (3076)
        //
        hr = CServerSocket::CreateInstance( &pSocket, g_pCompletionPort, NULL );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed creating Inet socket3, hr=0x%08X", hr );
            goto Exit;
        }

        // We only want this socket to receive data for the XSP echo port
        sin.sin_port = XSP_PORT_XSPECHO;

        // Initialize the Inet socket as a UDP socket on port 3076
        hr = pSocket->Init( IPPROTO_UDP, &sin, TRUE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed initializing internet server socket at addr %s:%u, hr=0x%08X", inet_ntoa( sin.sin_addr ), NTOHS( sin.sin_port ), hr );
            goto Exit;
        }

        // Ignore broadcasts on the Internet socket
        hr = pSocket->SetReceiveBroadcast( FALSE );
        if( FAILED( hr ) )
        {
            SgEventSz( CONFIG_ERROR, "Failed setting server socket broadcast option, hr=0x%08X", hr );
            goto Exit;
        }

        g_SgInetSocket3.SetSocketInfo( pSocket, pTransInfo, TRUE );
        pSocket = NULL;

    }

    pTransInfo->_pvPacketTrans = pTransInfo;

    fReturn = TRUE;

Exit:
    if( NULL != pSocket )
    {
        pSocket->Release();
        pSocket = NULL;
    }
        
    return fReturn;

}

BOOL TransStart(CTransInfo* pTransInfo)
{
    if ( TRANSTYPE_DMZ == pTransInfo->_dwType )
    {
        return RNTRANS::TransStart(pTransInfo);
    }
    Assert( TRANSTYPE_INTERNET == pTransInfo->_dwType );
    return TRUE;
}

// ---------------------------------------------------------------------------------------
// TransQueryCounters
// ---------------------------------------------------------------------------------------
void TransQueryCounters(CTransInfo* pTransInfo, CTransInfoCounters* pCounters)
{
    if ( TRANSTYPE_DMZ == pTransInfo->_dwType )
    {
        RNTRANS::TransQueryCounters(pTransInfo, pCounters);
    }
    else
    {
        Assert( TRANSTYPE_INTERNET == pTransInfo->_dwType );
        ZeroMemory(pCounters, sizeof(CTransInfoCounters));
    }
}

// ---------------------------------------------------------------------------------------
// TransTerm
// ---------------------------------------------------------------------------------------

void TransTerm(CTransInfo * pTransInfo)
{
    if ( TRANSTYPE_DMZ == pTransInfo->_dwType )
    {
        RNTRANS::TransTerm(pTransInfo);
    }
    else
    {
        Assert( TRANSTYPE_INTERNET == pTransInfo->_dwType );

/*      @@RNTRANS for DMZ
        if( pTransInfo == g_SgDmzSocket.GetTransInfo() )
        {
            if( INVALID_HANDLE_VALUE != g_hIpHookDriver )
            {
                // Turn off the hook driver
                SgIpHookSetPortRange( g_hIpHookDriver, 0, 0 );

                SgIpHookUnloadDriver( g_hIpHookDriver );
                g_hIpHookDriver = INVALID_HANDLE_VALUE;
            }

            g_SgDmzSocket.Term();
            g_SgMsgSocket.Term();
        }
        else
        {
*/
            Assert( pTransInfo == g_SgInetSocket.GetTransInfo() );

            g_SgInetSocket.Term();
            g_SgInetSocket2.Term();
            g_SgInetSocket3.Term();
//        }

        pTransInfo->_pvPacketTrans = NULL;

        // Last TransInfo out should clean up the completion port
        if( NULL != g_pCompletionPort &&
//            !g_SgDmzSocket.IsActive() &&
            !g_SgInetSocket.IsActive() )
        {
            g_pCompletionPort->Release();
            g_pCompletionPort = NULL;
        }
    }
}

// ---------------------------------------------------------------------------------------
// TransIsActive
// ---------------------------------------------------------------------------------------

BOOL TransIsActive(CTransInfo * pTransInfo)
{
    if ( TRANSTYPE_DMZ == pTransInfo->_dwType )
    {
        return RNTRANS::TransIsActive(pTransInfo);
    }

    Assert( TRANSTYPE_INTERNET == pTransInfo->_dwType );
    return pTransInfo->_fActive;
}

// ---------------------------------------------------------------------------------------
// TransXmit
// ---------------------------------------------------------------------------------------

void TransXmit(CPacket * ppkt)
{
    if( TRANSTYPE_DMZ == ppkt->_pTransInfoXmit->_dwType )
    {
        RNTRANS::TransXmit(ppkt);
    }
    else
    {
        Assert( TRANSTYPE_INTERNET == ppkt->_pTransInfoXmit->_dwType );

        HRESULT hr;
        BYTE *  pbDst = ppkt->_abTransSend;
        UINT    cbDst = sizeof( ppkt->_abTransSend );
        BYTE ** ppb   = ppkt->_apb;
        UINT *  pcb   = ppkt->_acb;
        UINT    cpb   = ppkt->_cpb;

        // Merge everything into one contiguous buffer for ease of working with it
        for (; cpb > 0; ++ppb, ++pcb, --cpb)
        {
            if (*pcb > cbDst)
            {
                TraceSz(Warning, "Xmit: Frame is larger than the maximum (%d bytes)", CBFRAMEMAX);
                goto Fail;
            }

            memcpy(pbDst, *ppb, *pcb);
            pbDst += *pcb;
            cbDst -= *pcb;
        }

        CEnetHdr* pEnetHdr = (CEnetHdr*) ppkt->_abTransSend;
        CIpHdr* pIpHdr = (CIpHdr*)( pEnetHdr + 1 );
        CUdpHdr* pUdpHdr = (CUdpHdr*)( pIpHdr + 1 );
        CTcpHdr* pTcpHdr = (CTcpHdr*)( pIpHdr + 1 );
        BYTE* pbData;

        // Drop ARP and any other non-IP ethernet traffic
        if( ENET_TYPE_IP != pEnetHdr->_wType )
        {
            TraceSz(Warning, "Xmit: Dropping non-IP packet");
            goto Fail;
        }

        sockaddr_in addrto;
        addrto.sin_family = AF_INET;
        addrto.sin_addr.s_addr = pIpHdr->_ipaDst;
        memset( &addrto.sin_zero, 0, sizeof( addrto.sin_zero ) );

        switch( pIpHdr->_bProtocol )
        {
        case IPPROTOCOL_TCP:
    	    addrto.sin_port = pTcpHdr->_ipportDst;
            pbData = (BYTE*) pTcpHdr + pTcpHdr->_info.GetHdrLen();
            break;
        case IPPROTOCOL_UDP:
    	    addrto.sin_port = pUdpHdr->_ipportDst;
            pbData = (BYTE*)( pUdpHdr + 1 );
            break;
        case IPPROTOCOL_ICMP:
            TraceSz(Warning, "Xmit: Dropping ICMP packet");
            goto Fail;
        default:
            TraceSz(Warning, "Xmit: Dropping unknown IP protocol packet, protocol=%u", pIpHdr->_bProtocol);
            goto Fail;
        }

        // Send the packet
//        if( TRANSTYPE_INTERNET == ppkt->_pTransInfoXmit->_dwType )
//        {
            hr = g_SgInetSocket.GetSocket()->SendTo( pbData, (DWORD)(pbDst - pbData), &addrto, &g_SgInetSocket, (QWORD) ppkt );
/*      @@RNTRANS for DMZ
        }
        else
        {
            // Replies to packets that came in on 65535 are handled on a special socket
            if( ppkt->_pUdpHdr->_ipportDst == 0xFFFF && 
                ppkt->_pIpHdr->_bProtocol == IPPROTOCOL_UDP )
            {
                hr = g_SgMsgSocket.GetSocket()->SendTo( pbData, (DWORD)(pbDst - pbData), &addrto, &g_SgMsgSocket, (QWORD) ppkt );
            }
            else
            {
                hr = g_SgDmzSocket.GetSocket()->SendTo( (BYTE*) pIpHdr, CBFRAMEMAX - cbDst - sizeof(CEnetHdr), &addrto, &g_SgDmzSocket, (QWORD) ppkt );
            }
        }
*/
        if( FAILED( hr ) )
        {
            TraceSz(Warning, "Xmit: SendTo on iTransInfo %d failed", ppkt->_pTransInfoXmit->_iTransInfo);
            goto Fail;
        }

        return;

    Fail:
        ppkt->Complete();
    }
}


// ---------------------------------------------------------------------------------------
// CSgSocket implementation
// ---------------------------------------------------------------------------------------

void CSgSocket::RepostReceive()
{
    HRESULT hr;

    // Now that we are done with the buffer, re-queue it for the next receive
    do
    {
        if( _fUDP )
        {
            hr = _pSocket->ReceiveFrom( _rgbRecvBuffer, sizeof( _rgbRecvBuffer ), this, (QWORD) _pSocket );
        }
        else
        {
            hr = _pSocket->Receive( _rgbRecvBuffer, sizeof( _rgbRecvBuffer ), this, (QWORD) _pSocket );
        }
    
        // If a previous receive in this socket resulted in an ICMP "Port Unreachable" message,
        // WSARecv/WSARecvFrom will fail returning WSAECONNRESET. We must handle this error and retry.

    } while( FAILED(hr) && HRESULT_FACILITY(hr) == FACILITY_WIN32 && HRESULT_CODE(hr) == WSAECONNRESET );

    if( FAILED( hr ) )
    {
        TraceSz( Warning, "RepostReceive(): failed to post new receive" );
    }
}

void CSgSocket::OnSocketSendTo( BYTE *pbBufferSent, DWORD cbToSend, DWORD cbSent, HRESULT hr, QWORD qwCallbackArg )
{
    CPacket* ppkt = (CPacket*) qwCallbackArg;

    if( FAILED( hr ) )
    {
        TraceSz(Warning, "CSgSocketCallback::OnSocketSendTo(): failure returned, hr=0x%08X", hr);
    }

    ppkt->Complete();
}

void CSgSocket::OnSocketReceive( BYTE* pb, DWORD cb, HRESULT hr, QWORD qwCallbackArg )
{
    if( FAILED( hr ) )
    {
        TraceSz(Warning, "CSgSocketCallback::OnSocketReceive(): failure returned, hr=0x%08X", hr);
        goto Discard;
    }
    
    Assert( qwCallbackArg == (QWORD) _pSocket );  
    Assert( pb == _rgbRecvBuffer );
    Assert( cb <= sizeof(CIeeeHdr) + ENET_DATA_MAXSIZE );

    if( cb < sizeof( CIpHdr ) )
    {
        // Packet isn't valid IP traffic, definitely not for us
        TraceSz( RecvIgnore, "OnSocketReceive: invalid IP packet received, too short (%u < %u)", cb, sizeof( CIpHdr ) );
        goto Discard;
    }

    // See if it was sent to our IP address
    CIpHdr* pIpHdr = (CIpHdr*)( pb );
    CUdpHdr* pUdpHdr = (CUdpHdr*)( pIpHdr + 1 );

    sockaddr_in sinLocal;
    hr = _pSocket->GetLocalAddress( &sinLocal );
    Assert( SUCCEEDED( hr ) );

    // Check the destination address against the one we bound to
    if( pIpHdr->_ipaDst != sinLocal.sin_addr.s_addr )
    {
        // Packet wasn't sent to this machine, ignore it
        TraceSz( RecvIgnore, "OnSocketReceive: packet is not for this machine" );
        goto Discard;
    }

    // If it is sent to the XSP port, then it is for the Inet side, not us
    // NOTE: Both TCP and UDP headers start with the ports, so it is safe to use the UDP header class to check either one
    if( cb < sizeof( CIpHdr ) + sizeof( CUdpHdr ) )
    {
        // Packet is too short to be valid UDP or TCP
        TraceSz( RecvIgnore, "OnSocketReceive: packet is too short to be valid UDP or TCP (%u < %u)", cb, sizeof( CIpHdr ) + sizeof( CUdpHdr ) );
        goto Discard;
    }

    if( NULL == _pTransInfo )
    {
        TraceSz( RecvIgnore, "OnSocketReceive: received packet before CTransInfo is available" );
        goto Discard;
    }

    if(    _pTransInfo->_wIpportBeg > NTOHS( pUdpHdr->_ipportDst )
        || _pTransInfo->_wIpportEnd < NTOHS( pUdpHdr->_ipportDst ) )
    {
        // Packet is outside of our port range
        TraceSz( RecvIgnore, "OnSocketReceive: packet is outside of our port range (%u != [%u,%u])", NTOHS( pUdpHdr->_ipportDst ), _pTransInfo->_wIpportBeg, _pTransInfo->_wIpportEnd );
        goto Discard;
    }

    // SPECIAL CASE: Due to the fact that the TCP driver will attempt to handle all incoming TCP packets, we run a TCP filter
    // hook that changes our incoming TCP packets to RAW packets.  Change them back here.
    if( IPPROTO_RAW == pIpHdr->_bProtocol )
    {
        pIpHdr->_bProtocol = IPPROTO_TCP;
    }
    else if( IPPROTO_RAW-1 == pIpHdr->_bProtocol )
    {
        pIpHdr->_bProtocol = IPPROTO_UDP;
    }

    // This packet looks good enough to pass to the SG core

    CPacket * ppkt = SgPacketAlloc();
    if (ppkt == NULL)
    {
        TraceSz(Warning, "CSgSocketCallback::OnSocketReceive(): Out of memory allocating a CPacket");
        goto Discard;
    }

    // NOTE: Packets on the DMZ side come in on a raw socket, and we get the IP header, UDP/TCP header, as well as the data.  
    // The SG Core expects all data to come in starting with an Ethernet header, meaning that we will have to tack on some dummy header
    // info.

    // Fill in the packet
    ppkt->_apb[0]         = ppkt->_abTransRecv + ETH_HEADER_ALIGN; 
    ppkt->_acb[0]         = cb + sizeof( CEnetHdr );
    ppkt->_cpb            = 1;
    ppkt->_pTransInfoRecv = _pTransInfo;
    
    CEnetHdr* pEnetHdr = (CEnetHdr*) ppkt->_apb[0];
    pIpHdr = (CIpHdr*)( pEnetHdr + 1 );

    // Copy the incoming data early so that we can free up the receive buffer quickly
    memcpy( pIpHdr, pb, cb );

    // Add dummy headers
    pEnetHdr->_eaDst.SetZero();
    pEnetHdr->_eaSrc.SetZero();
    pEnetHdr->_wType = ENET_TYPE_IP;

    SgRecv( ppkt );
    
    // We are done with the original buffer now, free it up for re-use. Don't allow 
    // another receive to come in before queueing the packet on the SPI queue, which is 
    // what SgRecv() will do. Otherwise your packets may get reordered.
    RepostReceive();

    return;

Discard:
    Assert( NULL != pb );

    // If we aren't shutting down, repost the buffer
    if( HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED ) != hr )
    {
        RepostReceive();
    }
}

void CSgSocket::OnSocketReceiveFrom( BYTE* pb, DWORD cb, sockaddr_in* pAddrFrom, HRESULT hr, QWORD qwCallbackArg )
{
    if( FAILED( hr ) )
    {
        TraceSz(Warning, "CSgSocketCallback::OnSocketReceiveFrom(): failure returned, hr=0x%08X", hr);
        goto Discard;
    }
    
    Assert( qwCallbackArg == (QWORD) _pSocket );
    Assert( pb == _rgbRecvBuffer );
    Assert( cb <= sizeof(CIeeeHdr) + ENET_DATA_MAXSIZE );

    sockaddr_in sinLocal;
    hr = _pSocket->GetLocalAddress( &sinLocal );
    Assert( SUCCEEDED( hr ) );

    CPacket * ppkt = SgPacketAlloc();
    if (ppkt == NULL)
    {
        TraceSz(Warning, "CSgSocketCallback::OnSocketReceiveFrom(): Out of memory allocating a CPacket");
        goto Discard;
    }

    // NOTE: ReceiveFrom packets come in on a normal UDP socket, so we only see the actual data.  The SG Core expects
    // all data to come in starting with an Ethernet header, meaning that we will have to tack on some dummy header
    // info.

    // Fill in the packet
    ppkt->_apb[0]         = ppkt->_abTransRecv + ETH_HEADER_ALIGN; 
    ppkt->_acb[0]         = cb + sizeof( CEnetHdr ) + sizeof( CIpHdr ) + sizeof( CUdpHdr );
    ppkt->_cpb            = 1;
    ppkt->_pTransInfoRecv = _pTransInfo;

    CEnetHdr* pEnetHdr = (CEnetHdr*) ppkt->_apb[0];
    CIpHdr* pIpHdr = (CIpHdr*)( pEnetHdr + 1 );
    CUdpHdr* pUdpHdr = (CUdpHdr*)( pIpHdr + 1 );

    // Copy the incoming data early so that we can free up the receive buffer quickly
    memcpy( pUdpHdr + 1, pb, cb );

    // Add dummy headers
    pEnetHdr->_eaDst.SetZero();
    pEnetHdr->_eaSrc.SetZero();
    pEnetHdr->_wType = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = 0;
    pIpHdr->_wLen      = HTONS((WORD)( sizeof(CIpHdr) + sizeof(CUdpHdr) + cb ));
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = 0;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc    = pAddrFrom->sin_addr;
    pIpHdr->_ipaDst    = sinLocal.sin_addr;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pUdpHdr->_ipportSrc = pAddrFrom->sin_port;
    pUdpHdr->_ipportDst = sinLocal.sin_port;
    SgSetUdpHdrChecksum( pIpHdr, pUdpHdr, sizeof( CUdpHdr ), (BYTE*)( pUdpHdr + 1 ), cb, NULL, 0, NULL, 0, NULL, 0);

    SgRecv( ppkt );

    // We are done with the original buffer now, free it up for re-use. Don't allow 
    // another receive to come in before queueing the packet on the SPI queue, which is 
    // what SgRecv() will do. Otherwise your packets may get reordered.
    RepostReceive();

    return;

Discard:
    Assert( NULL != pb );

    // If we aren't shutting down, repost the buffer
    if( HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED ) != hr )
    {
        RepostReceive();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rntrans.cpp ===
// ---------------------------------------------------------------------------------------
// Copyright (C) Microsoft Corporation
//
// rntrans.cpp
//
// SG transport layer using Rawnic
// ---------------------------------------------------------------------------------------

#include "sg.h"
#include <rawnic.h>
#include <sha.h>
#include <stdlib.h>

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

#define RECV_RETRY_INTERVAL         (TICKS_PER_SECOND * 5)

// ---------------------------------------------------------------------------------------
// NTSTATUS
// ---------------------------------------------------------------------------------------

typedef long NTSTATUS, *PNTSTATUS;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)
#define STATUS_CANCELLED                 ((NTSTATUS)0xC0000120L)

#define RAWNIC_RCV_BUFFER_LEN 102400
#define RAWNIC_SND_MAX_BATCH  1000

// Parallelizing recvs seems like a good idea, but may cause reordering of packets.  
// Twiddle this for testing only.
#define RAWNIC_RECV_MAX_PARALLELIO 1

// Each one requires at least RAWNIC_RCV_BUFFER_LEN bytes, but at least they are only 
// allocated as needed...
#define RAWNIC_XMIT_MAX_PARALLELIO 100

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

// Settings
UINT            g_DriverRecvMaxLatency;
UINT            g_DriverRecvDesiredLatency;
UINT            g_DriverRecvMaxConcurrency;
UINT            g_DriverRecvProcessPackets;

// Number of threads actively processing packets in the recv io completion.
volatile ULONG  g_cActiveRecvThreads;

// Defined in sgprocbal.cpp. For optimization's sake, we're peeking into these globals.
extern CThreadPool   g_SgProcBalThreadPool;
extern CIoThreadPool g_SgProcBalIoThreadPool;
extern DWORD         g_SgProcBalThreadPoolType;

// ---------------------------------------------------------------------------------------
// CRawNic
// Rawnic adapter.  
// ---------------------------------------------------------------------------------------
class CRawNic
{
public:
    DECLARE_NEW_DELETE(CRawNic);
    
    CRawNic();
    ~CRawNic();

    BOOL Init(
        CTransInfo* pTransInfo, 
        DWORD recvMaxLatency,
        DWORD recvDesiredLatency,
        DWORD recvMaxConcurrency,
        BOOL fProcessRecvPackets);

    void Term();

    BOOL Start();

    void Xmit(CPacket* ppkt);

    void QueryCounters(RAWNIC_COUNTERS* pCounters);

protected:
    
    // Type of IO operation 
    enum IO_TYPE
    {
        IO_RECV = 1,
        IO_XMIT = 2
    };
    
    // Custom OVERLAPPED structure with ioType embedded
    struct RAWNIC_OVERLAPPED
    {
        CListEntry  leLookAside;    // list-entry lookaside free list
        OVERLAPPED  _overlapped;
        IO_TYPE     _ioType;
        CRawNic*    _pRawnic;
        BYTE        _buffer[RAWNIC_RCV_BUFFER_LEN];
        
        // Reset _overlapped field without touching other fields
        void Reset()
        {
            ZeroMemory(&_overlapped, sizeof(_overlapped));
        }
    };
    

    BOOL Recv(OVERLAPPED* po, BOOL fRetry);

    static void CALLBACK OnIoCompleted(
        DWORD error,
        DWORD numberOfBytes, 
        OVERLAPPED* pOverlapped);

    void OnRecvCompleted(
        RAWNIC_OVERLAPPED* pro,
        DWORD error,
        DWORD numberOfBytes);

    void OnXmitCompleted(
        RAWNIC_OVERLAPPED* pro,
        DWORD error,
        DWORD numberOfBytes);

    void DispatchXmit();

    BOOL MovePacketsToStage2();

    void XmitPacketsFromStage2();

    RAWNIC_OVERLAPPED* OverlappedAlloc(
        IO_TYPE ioType);

    void OverlappedFree(RAWNIC_OVERLAPPED *overlapped);

    CLookAsideList      _overlappedLookAside;
    volatile UINT32     _cOverlappedsAllocated;

   
    // There will be a fixed number of recv IO operations outstanding. There may be an 
    // unknown number of xmit IO operations outstanding, which is why we use a lookaside 
    // list to allocate them. However, there will be exactly 1 oustanding xmit IO 
    // operation that is still the pending; any others are guaranteed to have completed 
    // already, even if the IO completion hasn't posted yet.
    //
    // By using our special OVERLAPPED structure, we can differentiate between recv and 
    // xmit callbacks which will also allow us to calculate the original pointer to 
    // CRawnic.
    RAWNIC_OVERLAPPED   _recvOverlapped[RAWNIC_RECV_MAX_PARALLELIO];                        
    volatile RAWNIC_OVERLAPPED * _pXmitOverlapped;

    CTransInfo *        _pTransInfo;            // Pointer to CTransInfo with information about this transport
    HANDLE              _hNic;                  // Rawnic handle
    SLIST_HEADER        _pqXmitStage1;          // Thread safe xmit packet queue
    volatile UINT32     _cXmitStage1;           // Number of packets queued on stage 1
    CPacketQueue        _pqXmitStage2;          // Xmit packet queue with packets removed from _pqXmitStage1
    volatile LONG       _xmitInProgress;        // Indicates whether a xmit operation is in progress
    volatile LONG       _shutdown;              // Indicates whether we're shutting down
    UINT32              _recvParallelIoCount;   // Number of simultaneous outstanding recvs() allowed
    UINT32              _recvMaxConcurrency;    // Number of simultaneous recv() threads allowed
    BOOL                _fProcessRecvPackets;   // Are we responsible for completing received packets?
};

// ---------------------------------------------------------------------------------------
// CRawNic::CRawNic
// constructor
// ---------------------------------------------------------------------------------------
CRawNic::CRawNic() :
    _pTransInfo(NULL),
    _hNic(NULL),
    _cXmitStage1(0),
    _xmitInProgress(FALSE),
    _shutdown(FALSE),
    _recvParallelIoCount(0),
    _recvMaxConcurrency(0),
    _fProcessRecvPackets(0),
    _cOverlappedsAllocated(0),
    _pXmitOverlapped(NULL)
{
    for(UINT32 i=0; i < ARRAYSIZE(_recvOverlapped); i++)
    {
        _recvOverlapped[i]._ioType  = IO_RECV;
        _recvOverlapped[i]._pRawnic = this;
    }

    ::InitializeSListHead(&_pqXmitStage1);
    _pqXmitStage2.Init();
}

// ---------------------------------------------------------------------------------------
// CRawNic::~CRawNic
// destructor
// ---------------------------------------------------------------------------------------
CRawNic::~CRawNic()
{
    Term();
}

// ---------------------------------------------------------------------------------------
// CRawNic::Init
// Initialize adapter and bind it to IO thread pool. After initializing the object, you 
// still need to call Start() to start receiving packets.
// - pTransInfo: pointer to CTransInfo structure which contains information about this 
// adapter and uniquely identifies it in the SG. CRawNic keeps a reference to this 
// structure.
// - recvMaxLatency: safety net to ensure packets get sent up (in microseconds)
// - recvDesiredLatency: average desired packet latency (in microseconds)
// - recvMaxConcurrency: how many recv() threads are allowed to process work items
// - fProcessRecvPackets: should recv() threads process work items?  
// Returns TRUE if succeeded, FALSE otherwise
// ---------------------------------------------------------------------------------------
BOOL CRawNic::Init(
    CTransInfo* pTransInfo, 
    DWORD recvMaxLatency,
    DWORD recvDesiredLatency,
    DWORD recvMaxConcurrency,
    BOOL fProcessRecvPackets)
{
    Assert(!_pTransInfo);
    DWORD dwErr;
    BOOL ok = FALSE;

    _pTransInfo = pTransInfo;
    _recvMaxConcurrency = recvMaxConcurrency;
    _fProcessRecvPackets = fProcessRecvPackets;
    _recvParallelIoCount = 1;  // more than 1 and you reorder packets  

    // Initialize lookaside list of overlapped structures
    _overlappedLookAside.Init(
        sizeof(RAWNIC_OVERLAPPED),
        RAWNIC_XMIT_MAX_PARALLELIO);

    // Will grow as necessary..
    _overlappedLookAside.PreAlloc(10);

    // Open rawnic adapter

    dwErr = RawAdapterOpen(
        pTransInfo->_eaAdapter._ab, 
        pTransInfo->_ea._ab,
        RN_OPTION_OVERLAPPED | RN_OPTION_BROADCAST_ARP,
        recvMaxLatency, 
        recvDesiredLatency,
        (HANDLE *)&_hNic);

    TraceSz(Config, "    Opened rawnic driver with real MAC %s, virtual MAC %s", 
             pTransInfo->_eaAdapter.Str(),
             pTransInfo->_ea.Str());
    TraceSz(Config, "        Receive max latency: %u us", recvMaxLatency);
    TraceSz(Config, "        Receive desired latency: %u us", recvDesiredLatency);
    TraceSz(Config, "        Receive max thread concurrency: %u", _recvMaxConcurrency);
    TraceSz(Config, "        Rawnic process receive packets: %u", _fProcessRecvPackets);

    if (dwErr != NO_ERROR)
    {
        // TCHARs on WinNT are 2 byte characters, fyi. This means the printf format needs 
        // to be "%S" not "%s". Subtle but important.
        TCHAR szErrMsg[1024];
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                      0,
                      dwErr,
                      0,
                      szErrMsg,
                      ARRAYSIZE(szErrMsg),
                      NULL);
        
        if (dwErr == ERROR_UNEXP_NET_ERR)
        {
            // Try to get list of real MAC addresses, as this Win32 error indicates Rawnic 
            // said no adapter could be found that matches the provided MAC address.

            CTinyStr strMacs;
            RAWNIC_ADAPTER_INFO aAdapters[16];  // arbitrarily large
            DWORD cAdapters = 0;

            strMacs.SetAllocator(CMemAlloc::Default());  // allow dynamic growth
            memset(aAdapters, 0, sizeof(aAdapters));

            DWORD dwErr2 = RawnicReadAdapters(ARRAYSIZE(aAdapters), aAdapters, &cAdapters);
            
            if (cAdapters == 0)
            {
                strMacs.Format("<Error retrieving list of adapters, Win32 error %u>\n", dwErr2);
            }
            else 
            {
                if (dwErr2 == ERROR_MORE_DATA)
                {
                    strMacs.Format("<Too many adapters found, showing partial list>\n");
                }
                
                Assert(cAdapters <= ARRAYSIZE(aAdapters));
                for (DWORD idx = 0; idx < cAdapters; idx++)
                {
                    strMacs.Format(ETHERFMT "\n", ETHERPRM(aAdapters[idx].MacAddress));
                }

            }

            SgEventSz(CONFIG_ERROR,
                       "Failed to open a handle to the network card. It appears an invalid MAC "
                       "address was specified in the config. Please ensure it is correct and Rawnic "
                       "is bound to the NIC.\n\n"
                       "Invalid MAC address from config:\n%s\n\n"
                       "Valid MAC addresses that Rawnic is currently bound to:\n%s", 
                       pTransInfo->_eaAdapter.Str(),
                       strMacs.cstr());

            goto Exit;
        }
        else
        {
            SgEventSz(CONFIG_ERROR, 
                       "Failed to open a handle to the network card.\n"
                       "Real MAC: %s\n"
                       "Virtual MAC: %s\n"
                       "GetLastError: %u\n"
                       "Error Code: %u\n"
                       "Error Message: %S",
                       pTransInfo->_eaAdapter.Str(),
                       pTransInfo->_ea.Str(), 
                       GetLastError(),
                       dwErr, 
                       szErrMsg);
            goto Exit;
        }
    }

    // Bind rawnic handle to IO thread pool's completion port

    if(!SgProcBalBindHandle(_hNic, OnIoCompleted))
    {
        SgEventSz(CONFIG_ERROR, 
                   "(RawNic::Init) Bind '%s' (recv) failed, GetLastError = %u",
                   pTransInfo->_ea.Str(), GetLastError());
        goto Exit;
    }

    ok = TRUE;

Exit:

    if(!ok)
    {
        Term();
    }

    return ok;
}

// ---------------------------------------------------------------------------------------
// CRawNic::Term
// Terminate Rawnic
// ---------------------------------------------------------------------------------------
void CRawNic::Term()
{
    if(_hNic)
    {
        CloseHandle(_hNic);
        _hNic = NULL;
    }

    _overlappedLookAside.Term();
}

// ---------------------------------------------------------------------------------------
// CRawNic::Start
// Starts receiving packets. Should only be called once. The completion routine for the 
// receive operation will start a new one.
// - Returns TRUE if succeeded, FALSE otherwise
// ---------------------------------------------------------------------------------------
BOOL CRawNic::Start()
{
    for(UINT32 i=0; i < _recvParallelIoCount; i++)
    {
        if(!Recv(&_recvOverlapped[i]._overlapped, FALSE))
        {
            return FALSE;
        }
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// CRawNic::Xmit
// Posts a packet in the outbound queue and starts the xmit IO operation if required.
// ---------------------------------------------------------------------------------------
void CRawNic::Xmit(CPacket* ppkt)
{
    ::InterlockedPushEntrySList(&_pqXmitStage1, &ppkt->_ppktNextSl);
    _cXmitStage1++;  // only used for perfctr

    // If _xmitInProgress is set,  it's guaranteed that our packets will be picked up at 
    // the end of the xmit operation. Otherwise, we might have to start the operation 
    // ourselves. DispatchXmit() will take care of it.

    DispatchXmit();
}

// ---------------------------------------------------------------------------------------
// CRawNic::QueryCounters
// Query Rawnic performance counters
// ---------------------------------------------------------------------------------------
void CRawNic::QueryCounters(RAWNIC_COUNTERS* pCounters)
{
    C_ASSERT(sizeof(CTransInfoCounters) == sizeof(RAWNIC_COUNTERS));

    DWORD error = RawAdapterReadCounters(
        _hNic,
        sizeof(CTransInfoCounters),
        pCounters,
        NULL);

    if(error != NO_ERROR)
    {
        SgEventSz(INTERNAL_ERROR, "RawAdapterReadCounters failed. winerr = %u", error);
        return;
    }

    pCounters->adapter.cOverlappedsAllocated = _cOverlappedsAllocated;
    pCounters->adapter.cXmitStage1 = _cXmitStage1;
    pCounters->adapter.cXmitStage2 = _pqXmitStage2.Count();;
}

// ---------------------------------------------------------------------------------------
// CRawNic::Recv
// Start a recv IO operation
// - fRetry: if TRUE, this function will never fail. Instead it will keep retrying until 
// it succeeds (this is the old behavior. It should be revisited). If FALSE, this 
// function can fail
// ---------------------------------------------------------------------------------------
BOOL CRawNic::Recv(OVERLAPPED* po, BOOL fRetry)
{
    DWORD dwErr;
    BOOL ok = FALSE;
    DWORD retryCount = 10;  // why not?

    // @@@ shutdown?

    // @@@ fRetry still doesn't make much sense to me. Leaving it in until I better 
    // understand it.
    
    RAWNIC_OVERLAPPED* pro = CONTAINING_RECORD(po, RAWNIC_OVERLAPPED, _overlapped);

    do
    {
        pro->Reset();
        dwErr = RawAdapterRecv(_hNic, sizeof(pro->_buffer),
                               pro->_buffer, &pro->_overlapped, NULL);    
        
        if(dwErr == ERROR_IO_PENDING)
        {
            ok = TRUE;
        }
        else
        {
            ok = FALSE;
            retryCount--;
            SgEventSz(INTERNAL_ERROR, "RAWNIC read failed. hr = %X. Trying %u more time(s).", HRESULT_FROM_WIN32(dwErr), retryCount);
            Sleep(0);
        }
    
    } while(fRetry && !ok && retryCount > 0);

    // @@@ kill process if retryCount == 0?

    return ok;
}

// ---------------------------------------------------------------------------------------
// CRawNic::OnIoCompleted
// IO completion callback.
// - error: the WIN32 error
// - numberOfBytes: number of bytes received/sent. Depends on operation type.
// - pOverlapped: pointer to OVERLAPPED structure used in the original IO call.
// ---------------------------------------------------------------------------------------
void CRawNic::OnIoCompleted(
    DWORD error,
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped
    )
{
    // We used our special RAWNIC_OVERLAPPED structure
    RAWNIC_OVERLAPPED* pro = CONTAINING_RECORD(pOverlapped, RAWNIC_OVERLAPPED, _overlapped);
    CRawNic* pRawnic = pro->_pRawnic;

    // Based on _ioType, we can determine what type of operation this is about
    if(pro->_ioType == IO_RECV)
    {
        // Because we know that this is a recv operation, we also know that pOverlapped 
        // points to _recvOverlapped. With this knowledge, we can calculate the pointer 
        // to CRawNic and use it to call the recv completion function.
        pRawnic->OnRecvCompleted(pro, error, numberOfBytes);
    }
    else if(pro->_ioType == IO_XMIT)
    {
        // Same as above, but pOverlapped points to _xmitOverlapped. Complete the xmit 
        // operation.
        pRawnic->OnXmitCompleted(pro, error, numberOfBytes);
    }
    else
    {
        // @@@ critical error
        Assert(false);
    }
}

// ---------------------------------------------------------------------------------------
// CRawNic::OnRecvCompleted
// Complete the recv operation. Parse all the packets received and send them to SgRecv().  
// Start a new recv IO operation when we're done (unless application is shutting down)
// - error: WIN32 error of operation. NO_ERROR if it succeeded.
// - numberOfBytes: number of bytes written to pro->_buffer
//
// Some notes on what's going on here:
// Have recv() threads process work items saves context switches, and since our work items 
// are small and plentiful, this makes a lot of sense. Processing them does not require 
// any blocking calls. However, if all IO thread are busy processing work items in the 
// recv(), then none are left to process xmit() completions. This is undesirable, so there 
// is a setting to control the number of concurrent recv() threads allowed.
// ---------------------------------------------------------------------------------------
void CRawNic::OnRecvCompleted(
    RAWNIC_OVERLAPPED* pro,
    DWORD error,
    DWORD numberOfBytes
    )
{
    if(error != NO_ERROR)
    {
        SgEventSz(INTERNAL_ERROR, "RecvCallback returned hr 0x%08u, numberOfBytes=%u", HRESULT_FROM_WIN32(error), numberOfBytes);
        // kick off a new read. if it fails, there's not much we can do.
        Recv(&pro->_overlapped, TRUE);
        return;
    }
    
    // Bump up
    InterlockedIncrement((LONG*)&g_cActiveRecvThreads);

    // Rawnic returns one or more packets in the buffer. Each packet is prefixed by a 
    // WORD that contains the size of the packet. Process the buffer and put each packet 
    // in a CPacket.

    CPacket* ppkt  = NULL;
    BYTE* pb       = pro->_buffer;
    DWORD cb       = numberOfBytes;
    WORD  cbPacket = 0;

    while(cb > 0)
    {
        if(cb < sizeof(WORD))
        {
            SgEventInternalError(numberOfBytes, pro->_buffer);
            break;
        }
       
        // Grab the size of the packet from the first word. 
        cbPacket = *(WORD*)pb;

        if(cbPacket == 0 ||
           cbPacket > (sizeof(ppkt->_abTransRecv) - ETH_HEADER_ALIGN) ||
           cb < sizeof(WORD) + cbPacket)
        {
            SgEventInternalError(numberOfBytes, pro->_buffer);
            break;
        }
        
        ppkt = SgPacketAlloc();
        if (ppkt == NULL)
        {
            // SgPacketAlloc will log a (throttled) event for us and increment a perf 
            // counter. We're going to give up on the rest of the packets in this batch 
            // since it's unlikely more packets will free up in the next .0000001 ms.  
            break;
        }

        // Copy the packet over, less the inital word which contains the size, into
        // the spot in the buffer after the alignment.  Make sure the pointer is 
        // correct though.
        memcpy(ppkt->_abTransRecv + ETH_HEADER_ALIGN, pb + sizeof(WORD), cbPacket);
        ppkt->_pTransInfoRecv = _pTransInfo;
        ppkt->_apb[0]         = ppkt->_abTransRecv + ETH_HEADER_ALIGN;
        ppkt->_acb[0]         = cbPacket;
        ppkt->_cpb            = 1;
     
        // SgRecv does minimal processing of packet and queues it on the Spi queue. This 
        // will not decrypt the packet yet. It may generate a queued work item if this is 
        // the first packet for the spi.

        // If we're going to process the work items, then this packet should be set to low 
        // priority, which will prevent us from waking up an idle thread
        if (_fProcessRecvPackets)
        {
            ppkt->_priority = PACKET_PRIORITY_LOW;
        }
        SgRecv(ppkt);
        ppkt = NULL;

        pb += sizeof(WORD) + cbPacket;
        cb -= sizeof(WORD) + cbPacket;
    }

    // Trigger next recv
    Recv(&pro->_overlapped, TRUE);

    // Do we need to process some work items? Only do it if turned on and we haven't 
    // exceeded the concurrency limit yet.
    if (_fProcessRecvPackets &&
        g_cActiveRecvThreads <= _recvMaxConcurrency)
    {
        // If batching is enabled, we'll grab all available work items. Presumably this 
        // will include the packets we just processed, but it may be fewer (if some other 
        // worker thread already processed them) or more (if there were already pending 
        // items on the queue). That's OK. They need to be processed. May as well let this 
        // IO thread do it, since we have other available for additional receives.
        //
        // This could take a while to return.

        g_SgProcBalThreadPool.ExternalThreadProcessWorkItems();
    }

    // Bump down
    InterlockedDecrement((LONG*)&g_cActiveRecvThreads);

    return;
}

// ---------------------------------------------------------------------------------------
// CRawNic::OnXmitCompleted
// Complete a xmit operation. There is nothing to be completed, really except that we 
// might want to start a new xmit IO operation if there are packets in the queue already.
// - error: WIN32 error. NO_ERROR if operation succeeded.
// - numberOfBytes: number of bytes transmitted.
// ---------------------------------------------------------------------------------------
void CRawNic::OnXmitCompleted(
    RAWNIC_OVERLAPPED* pro,
    DWORD error,
    DWORD numberOfBytes
    )
{
    // Always release overlapped structure
    OverlappedFree(pro);

    if(error != NO_ERROR)
    {
        SgEventSz(INTERNAL_ERROR, "XmitCallback returned hr 0x%08u, numberOfBytes=%u", HRESULT_FROM_WIN32(error), numberOfBytes);
        // what to do?
    }

    if(_shutdown)
    {
        return;
    }

    // Try to start a new xmit operation.
    DispatchXmit();
}

// ---------------------------------------------------------------------------------------
// CRawNic::DispatchXmit
// If there is an IO operation in progress or if the xmit packet queue is empty, this 
// function does nothing. Otherwise, this function starts a xmit IO operation with as 
// many packets as it can fit. There can be only one xmit IO operation in progress per 
// CRawNic. When one IO operation completes, it triggers another one (if there are 
// packets in the queue).
// ---------------------------------------------------------------------------------------
void CRawNic::DispatchXmit()
{
    for(;;)
    {
        if(_xmitInProgress)
        {
            // already transmitting
            // @@@ perf counter here?
            return;
        }

        if(_pqXmitStage2.Count() == 0 &&
           ::QueryDepthSList(&_pqXmitStage1) == 0)
        {
            // no packets
            return;
        }

        if(::InterlockedCompareExchange(&_xmitInProgress, TRUE, FALSE) == TRUE)
        {
            // another thread beat us to the punch
            return;
        }

        // We have the lock

        // If last outstanding IO has not completed, bail out.
        if (_pXmitOverlapped &&
            !HasOverlappedIoCompleted(&_pXmitOverlapped->_overlapped))
        {
            _xmitInProgress = FALSE;
            return;
        }
        
        // This will signal DispatchXmit to stop watching for the xmit to finish, 
        // particularly in the case where a xmit fails.
        _pXmitOverlapped = NULL;

        // Move packets from stage 1 stack to stage 2 queue. Stage 1 is where the packets 
        // are stored when other threads call CRawnic::Xmit. It's very efficient in 
        // multi-thread situations but it's a stack and we need a queue to process the 
        // packets in the original order. The stage 1 stack supports a flush operation, 
        // though, and we use it to attomically move all packets, in the right order, to 
        // the stage 2 queue. Because there is only one thread transmitting at any time, 
        // the stage 2 queue can be a simple list without any locks. The process of 
        // preparing the packets to transmit is relatively expensive and it's good that 
        // we can do it without any locks.

        if(!MovePacketsToStage2())
        {
            // no packets (rare race condition)
            // try again

            _xmitInProgress = FALSE;
            continue;
        }

        // Transmit packets in the stage 2 queue.  
        // Note: This will release the lock, and we do it there because it releases the 
        // lock before completing the packets.. no need to hold it while doing that work.

        XmitPacketsFromStage2();
        return;
    }
}

// ---------------------------------------------------------------------------------------
// CRawNic::MovePacketsToStage2
// Move packets from stage 1 to stage 2. Refer to DispatchXmit() for an explanation on 
// stage 1 and stage 2.
// - Return TRUE if one or more packets are available to transmit in stage 2. Returns 
// FALSE if the stage 2 queue is empty.
// ---------------------------------------------------------------------------------------
BOOL CRawNic::MovePacketsToStage2()
{
    // Retrieve all packets from stage 1 list in one atomic operation

    SLIST_ENTRY* ple = ::InterlockedFlushSList(&_pqXmitStage1);
    _cXmitStage1 = 0;
    
    // Move packets from stage 1 list into a packet queue. Because the stage 1 list is 
    // actually a stack, we need to revert the order of the packets to preserve the 
    // original order.

    CPacketQueue packets;
    packets.Init();
    
    while(ple)
    {
        CPacket* ppkt = CONTAINING_RECORD(ple, CPacket, _ppktNextSl);
        ple = ppkt->_ppktNextSl.Next;
        packets.InsertHead(ppkt);
    }

    // Merge with existing stage 2 packet queue. 

    if(!_pqXmitStage2.IsEmpty())
    {
        packets.InsertHead(&_pqXmitStage2);
    }
    _pqXmitStage2 = packets;

    return _pqXmitStage2.Count() != 0;
}
        
// ---------------------------------------------------------------------------------------
// CRawNic::XmitPacketsFromStage2
// Transmit packets from stage 2 queue to Rawnic.
// ---------------------------------------------------------------------------------------
void CRawNic::XmitPacketsFromStage2()
{
    RAWNIC_OVERLAPPED *pXmitOverlapped;
   
    // Try to allocate a new overlapped. If things back up a lot, we may hit our 
    // artificial ceiling, which is OK. Just return, and let a later DispatchXmit handle 
    // the packets. Eventually the outstanding IOs will complete and get returned to the 
    // free list.
    pXmitOverlapped = OverlappedAlloc(IO_XMIT);
    if (pXmitOverlapped == NULL)
    {
        _xmitInProgress = FALSE;
        return;
    }

    BYTE* pb = pXmitOverlapped->_buffer;
    DWORD cbAvailable = sizeof(pXmitOverlapped->_buffer);
    DWORD cPackets = 0;

    CPacketQueue packets;
    packets.Init();

    while(_pqXmitStage2.Count() != 0 && cPackets < RAWNIC_SND_MAX_BATCH)
    {
        CPacket* ppkt = _pqXmitStage2.GetHead();

        if(!ppkt)
        {
            // queue is empty
            break;
        }
        
        Assert(ppkt->_cb != 0 && ppkt->_cb <= CBFRAMEMAX);

        DWORD cbRequired = sizeof(WORD) + ppkt->_cb;
        if(cbRequired > cbAvailable)
        {
            // max size of buffer reached
            break;
        }

        // Packets are prefixed by their size

        *(WORD*)pb = (WORD) ppkt->_cb;
        
        BYTE *  pbDst = pb + sizeof(WORD);
        BYTE ** ppb   = ppkt->_apb;
        UINT *  pcb   = ppkt->_acb;
        UINT    cpb   = ppkt->_cpb;

        for (; cpb > 0; ++ppb, ++pcb, --cpb)
        {
            memcpy(pbDst, *ppb, *pcb);
            pbDst += *pcb;
        }
        Assert(pbDst - pb == cbRequired);
        
        pb += cbRequired;
        cbAvailable -= cbRequired;
        cPackets++;

        _pqXmitStage2.RemoveHead();
        packets.InsertTail(ppkt);
    }

    // Calculate size of formatted packet buffer
    
    DWORD cb = (DWORD)(pb - pXmitOverlapped->_buffer);
    Assert(cb <= sizeof(pXmitOverlapped->_buffer));

    // Initiate the xmit

    DWORD dwErr = RawAdapterSend(
        _hNic, 
        cb, 
        pXmitOverlapped->_buffer, 
        &pXmitOverlapped->_overlapped);

    if(dwErr != ERROR_IO_PENDING)
    {
        SgEventSz(INTERNAL_ERROR, "XmitPacketsFromStage2 (%d bytes) on iTransInfo %u failed, err = %u",
                   cb, _pTransInfo->_iTransInfo, dwErr);

        // Note: MSDN states if an overlapped call (WriteFile, here) returns anything but 
        // ERROR_IO_PENDING, you should not look at the overlapped structure. Do not call 
        // HasOverlappedIoCompleted(). 
        
        OverlappedFree(pXmitOverlapped);
    }
    else
    {
        // Set member pointer so we can reference this outstanding overlapped. No more 
        // xmits will happen until this is either cleared or it completes.
        _pXmitOverlapped = pXmitOverlapped;
    }

    // Release the lock, we're done!
    _xmitInProgress = FALSE;

    // LOP captures indicate this is a non-trivial amount of time, so let's do it after 
    // sending the packets on their way. We need to speed up xmits as much as possible.
    packets.Complete();

    return;
}

// ---------------------------------------------------------------------------------------
// CRawNic::OverlappedAlloc
//
// Allocate a new RAWNIC_OVERLAPPED structure from the lookaside list. This allows 
// simultaneous pending xmits.
// - ioType: must be IO_XMIT for now, no support for multiple outstanding recvs yet.
// 
// Returns: new RAWNIC_OVERLAPPED ready for immediate use, or NULL if unable to allocate 
// memory.
// ---------------------------------------------------------------------------------------
CRawNic::RAWNIC_OVERLAPPED* 
CRawNic::OverlappedAlloc(
        IO_TYPE ioType)
{
    // Only support xmit right now, but may change in the future.
    Assert(ioType == IO_XMIT);
    if (ioType != IO_XMIT)
        return NULL;

    RAWNIC_OVERLAPPED *pOverlapped;

    if (_cOverlappedsAllocated >= RAWNIC_XMIT_MAX_PARALLELIO)
    {
        return NULL;
    }

    pOverlapped = (RAWNIC_OVERLAPPED*)_overlappedLookAside.Alloc();
    if (pOverlapped)
    {
        pOverlapped->Reset();
        pOverlapped->_ioType = ioType;
        pOverlapped->_pRawnic = this;
        InterlockedIncrement((LONG*)&_cOverlappedsAllocated);
    }
    return pOverlapped;
}

// ---------------------------------------------------------------------------------------
// CRawNic::OverlappedFree
//
// Return item to lookaside list. May end up freeing the memory if too many packets 
// stored.
// ---------------------------------------------------------------------------------------
void CRawNic::OverlappedFree(CRawNic::RAWNIC_OVERLAPPED *pOverlapped)
{
    Assert(pOverlapped);
    _overlappedLookAside.Free(pOverlapped);
    InterlockedDecrement((LONG*)&_cOverlappedsAllocated);
}


// ---------------------------------------------------------------------------------------
// Onebox transformations for Transit functions -- since both are required now for the
// onebox install, adding a namespace around the function names to prevent compiler
// issues
// ---------------------------------------------------------------------------------------
#ifdef SG_BUILD_ONEBOX
namespace RNTRANS
{
#endif

// ---------------------------------------------------------------------------------------
// TransInit
// ---------------------------------------------------------------------------------------

BOOL TransInit()
{
    DWORD dwErr = RawnicDetectDriver();
    if (dwErr != NO_ERROR)
    {
        SgEventSz(INTERNAL_ERROR, "RAWNIC driver not found. hr = %X", HRESULT_FROM_WIN32(dwErr));
        return FALSE;
    }
   

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// TransStop
// Stops receiving packets in preparation for shutdown
// ---------------------------------------------------------------------------------------
void TransStop()
{
}

// ---------------------------------------------------------------------------------------
// TransTerm
// ---------------------------------------------------------------------------------------

void TransTerm()
{
}

// ---------------------------------------------------------------------------------------
// TransInstall
// ---------------------------------------------------------------------------------------

BOOL TransInstall(OUT BOOL *pfRebootRequired)
{
    CLargeStr strLog;
    BOOL bRes = RawnicInstallDriver( L"Xbox Live Security Gateway", pfRebootRequired, &strLog );

    // InstallInfo(...) isn't available here, but basically just does a printf.
    printf("  RawnicInstallDriver details:\n");
    printf(strLog.cstr());

    return bRes;
}

// ---------------------------------------------------------------------------------------
// TransUninstall
// ---------------------------------------------------------------------------------------

BOOL TransUninstall(OUT BOOL *pfRebootRequired)
{
    CLargeStr strLog;
    BOOL bRes = RawnicUninstallDriver( L"Xbox Live Security Gateway", pfRebootRequired, &strLog );

    // InstallInfo(...) isn't available here, but basically just does a printf.
    printf("  RawnicUninstallDriver details:\n");
    printf(strLog.cstr());

    return bRes;
}

// ---------------------------------------------------------------------------------------
// TransConfig
// ---------------------------------------------------------------------------------------

BOOL TransConfig(CCfgInfo* pci)
{
    // Latency should be expressed in microseconds
    if(!pci->GetVar("DriverRecvMaxLatency", &g_DriverRecvMaxLatency, 0, 1000000, 0) ||
       !pci->GetVar("DriverRecvDesiredLatency", &g_DriverRecvDesiredLatency, 0, 1000000, 1000) ||
       !pci->GetVar("DriverRecvMaxConcurrency", &g_DriverRecvMaxConcurrency, 0, 100, 0) ||
       !pci->GetVar("DriverRecvProcessPackets", &g_DriverRecvProcessPackets, 0, 1, 1))
    {
        return FALSE;
    }

    // The DriverRecvProcessPackets setting only applies when the normal threadpool 
    // (separate IO and work item) is being used.
    if (g_SgProcBalThreadPoolType != SGPROCBAL_THREADPOOL_NORMAL)
    {
        g_DriverRecvProcessPackets = 0;
    }

    // Tweak settings if not overridden and using DriverRecvProcessPackets. See notes in 
    // sgprocbal.cpp SgProcBalConfig().
    if (g_DriverRecvProcessPackets)
    {
        SYSTEM_INFO si;
        ::GetSystemInfo(&si);
        DWORD numProcs = si.dwNumberOfProcessors;
        
        if (g_DriverRecvMaxConcurrency == 0)
        {
            if (numProcs > 2)
                g_DriverRecvMaxConcurrency = numProcs - 2;
            else
                g_DriverRecvMaxConcurrency = 1;
        }
    }

    g_cActiveRecvThreads = 0;

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// TransConfigTransport
// ---------------------------------------------------------------------------------------

BOOL TransConfigTransport(CCfgInfo* pci, CTransInfo* pTransInfo)
{
    CRawNic *       prn     = NULL;
    DWORD           cb;

    TraceSz(Config, "    TransConfigTransport:");
   
    if( pTransInfo->_eaAdapter.IsZero() )
    {
        SgEventSz(CONFIG_ERROR, "Missing 'Nic' for one of the interfaces (or it's zero)");
        goto fail;
    }

    if( pTransInfo->_ea.IsZero() )
    {
        // we may share this nic with TCP/IP, so make a fake ea from the computer
        // name and the normal ea
        
        char * pszComp = getenv("COMPUTERNAME");
        A_SHA_CTX shaCtx;
        BYTE      abHash[A_SHA_DIGEST_LEN];

        A_SHAInit(&shaCtx);
        A_SHAUpdate(&shaCtx, (BYTE *)pszComp, strlen(pszComp));
        A_SHAUpdate(&shaCtx, pTransInfo->_eaAdapter._ab, sizeof(pTransInfo->_eaAdapter._ab));
        A_SHAFinal(&shaCtx, abHash);
        abHash[0] &= ~3; // zap multicast bit(1), locally administered(2)

        memcpy(pTransInfo->_ea._ab, abHash, sizeof(pTransInfo->_ea._ab));
    }

    prn = new CRawNic();
    if (prn == NULL)
    {
        SgEventSz(CONFIG_ERROR, "Config error: Out of memory allocating CRawNic (%d bytes)",
                  sizeof(CRawNic));
        goto fail;
    }

    if(!prn->Init(pTransInfo, 
                  g_DriverRecvMaxLatency, 
                  g_DriverRecvDesiredLatency, 
                  g_DriverRecvMaxConcurrency,
                  g_DriverRecvProcessPackets))
    {
        goto fail;
    }

    // return transport info to upper layer
    
    pTransInfo->_pvPacketTrans = prn;

    return(TRUE);

fail:

    if (prn)
    {
        delete prn;
        prn = NULL;
    }

    return(FALSE);
}

// ---------------------------------------------------------------------------------------
// TransStart
// Called after TransConfig to start receiving packets. I decided to move this out of 
// TransConfig to avoid the following racing condition: Adapter A is initialized and 
// immediatelly starts receiving packets. As a result of one of this packets, a packet is 
// sent to Adapter B which hasn't been initialized yet. Synchronizing the two adapters 
// during initialization can be complicated. Instead, we first initialize all adapters 
// but do not start receiving. When we finally start receiving, all adapters will be 
// initialized and ready to go.
// - pTransInfo: pointer to CTransInfo corresponding to adapter to be started.
// ---------------------------------------------------------------------------------------
BOOL TransStart(CTransInfo* pTransInfo)
{
    CRawNic* prn = (CRawNic*) pTransInfo->_pvPacketTrans;

    return prn->Start();
}

// ---------------------------------------------------------------------------------------
// TransQueryCounters
// ---------------------------------------------------------------------------------------
void TransQueryCounters(CTransInfo* pTransInfo, CTransInfoCounters* pCounters)
{
    CRawNic* prn = (CRawNic*) pTransInfo->_pvPacketTrans;
    
    if(!prn)
        return;

    C_ASSERT(sizeof(CTransInfoCounters) == sizeof(RAWNIC_COUNTERS));
    prn->QueryCounters((RAWNIC_COUNTERS*)pCounters);
}

// ---------------------------------------------------------------------------------------
// TransTerm
// ---------------------------------------------------------------------------------------

void TransTerm(CTransInfo * pTransInfo)
{
    if (pTransInfo->_pvPacketTrans != NULL)
    {
        CRawNic * prn = (CRawNic *)pTransInfo->_pvPacketTrans;
        delete prn;
        
        pTransInfo->_pvPacketTrans = NULL;
    }
}

// ---------------------------------------------------------------------------------------
// TransIsActive
// ---------------------------------------------------------------------------------------

BOOL TransIsActive(CTransInfo * pTransInfo)
{
    // @@@ hit the query API periodically for this one
    return(pTransInfo->_fActive);
}

// ---------------------------------------------------------------------------------------
// TransXmit
// ---------------------------------------------------------------------------------------

void TransXmit(CPacket * ppkt)
{
    // The packet should have already been detached from any CCliInfo or CSpiInfo before 
    // being transmitted, but let's just make sure.

    SgCliInfoDetach(ppkt);
    SgSpiInfoDetach(ppkt);

    // CRawnic requires that ppkt->_cb contain the total size of all buffers

    DWORD cb = 0;

    for(DWORD i=0; i < ppkt->_cpb; i++)
    {
        cb += ppkt->_acb[i];
    }

    // Too big for ethernet? Note max ethernet payload is 1500 bytes, and we always send 
    // an ethernet header, not a IEEE header, so max frame is 1514 bytes, not 1522 bytes.
    if (cb == 0 || cb > CBFRAMEMAXSEND)
    {
        // @@@ We have to drop this packet. Ideally, we'd let the sender know this, but I 
        // can't find a good ICMP message (and do we even know the sender at this point?).  
        // So we'll discard the packet and trace it.
        Assert(ppkt->_pXspHdr);
        TraceSz(Xmit, "%s: [Discard] [XSP %08lX, %s]: bad size %u", 
                ppkt->Str(), (DWORD)ppkt->_pXspHdr->_dwSpiAndFlags, 
                SgXspTypeStr(ppkt->_pXspHdr->_bFlags & XSP_TYPE_MASK), cb);
        ppkt->Complete();
        return;
    }

    ppkt->_cb = cb;

    Assert(ppkt->_pTransInfoXmit);
    Assert(ppkt->_pTransInfoXmit->_pvPacketTrans);

    // Now queue ppkt on Rawnic's outbound packet queue

    CRawNic * prn = (CRawNic *)ppkt->_pTransInfoXmit->_pvPacketTrans;
    prn->Xmit(ppkt);
}

#ifdef SG_BUILD_ONEBOX
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\ServiceMask.cpp ===
//
// Wrapper to handle a 128-bit mask.
//
#include "sg.h"
#include "ServiceMask.h"

ServiceMask const ServiceMask::Empty(0, 0);

ServiceMask::ServiceMask()
        : LowPart(0)
        , HighPart(0)
{
}

ServiceMask::ServiceMask(ULONGLONG const lowPart, ULONGLONG const highPart)
    : LowPart(lowPart)
    , HighPart(highPart)
{
    // All the code here really depends on there just being a high-part and a low-part, and them being the same.
    C_ASSERT(sizeof(LowPart) == sizeof(HighPart));
    C_ASSERT(sizeof(*this) == sizeof(LowPart) + sizeof(HighPart));
    C_ASSERT(SERVICE_BYTES == sizeof(*this));

    // We also rely on the fact that our layout is exactly LowPart followed by HighPart.
    C_ASSERT(offsetof(ServiceMask, LowPart) + sizeof(LowPart) == offsetof(ServiceMask, HighPart));
}

ServiceMask ServiceMask::operator&(ServiceMask const & right) const
{
    return ServiceMask(LowPart & right.LowPart, HighPart & right.HighPart);
}

ServiceMask ServiceMask::operator|(ServiceMask const & right) const
{
    return ServiceMask(LowPart | right.LowPart, HighPart | HighPart);
}

ServiceMask ServiceMask::operator~() const
{
    return ServiceMask(~LowPart, ~HighPart);
}

ServiceMask& ServiceMask::operator&=(ServiceMask const & right)
{
    LowPart &= right.LowPart;
    HighPart &= right.HighPart;
    return *this;
}

ServiceMask& ServiceMask::operator|=(ServiceMask const & right)
{
    LowPart |= right.LowPart;
    HighPart |= right.HighPart;
    return *this;
}

BOOL ServiceMask::operator==(ServiceMask const & right) const
{
    return LowPart == right.LowPart && HighPart == right.HighPart;
}

BOOL ServiceMask::operator!=(ServiceMask const & right) const
{
    return LowPart != right.LowPart || HighPart != right.HighPart;
}

// Didn't want to build a bit-shifting operator...
BOOL ServiceMask::IsBitSet(size_t const bitPos) const
{
    // If the position is out of our range, we will just return false.
    if (sizeof(ServiceMask) * SERVICES_PER_BYTE <= bitPos)
    {
        return FALSE;
    }

    // Which part and mask should I use?
    ULONGLONG const * const pPart = PartFromPos(bitPos);
    ULONGLONG const mask = MaskFromPos(bitPos);

    // Test the individual bit.
    return (*pPart & mask) == mask;
}

void ServiceMask::SetBit(size_t const bitPos)
{
    // If the position is out of our range, we will just do nothing.
    if (sizeof(ServiceMask) * SERVICES_PER_BYTE <= bitPos)
    {
        return;
    }

    // Set the bit (helpers are awesome);
    ULONGLONG * pPart = const_cast<ULONGLONG *>(PartFromPos(bitPos));
    *pPart |= MaskFromPos(bitPos);
}

// I get a little confused by things like
// (svcMask1 & svcMask2) != ServiceMask::Empty
// So as long as I'm making a full-fledged object to handle this, why
// not add helper functions?
BOOL ServiceMask::HasAnyBits(ServiceMask const mask) const
{
    return (*this & mask) != Empty;
}

BOOL ServiceMask::HasAllBits(ServiceMask const mask) const
{
    return (*this & mask) == mask;
}

// Figures out which part to use, based on the bit position passed in.
ULONGLONG const * ServiceMask::PartFromPos(size_t const bitPos) const
{
    return  bitPos < BitsPerPart()  ? &LowPart : &HighPart;
}

// Figures out the mask for a single bit position. This handles the fact
// that bit, say, 40 is actually but 8, but in a different part.
ULONGLONG ServiceMask::MaskFromPos(size_t const bitPos) const
{
    return ((ULONGLONG)1) << (bitPos % BitsPerPart());
}

// Helper to know how many bits are in an individual part.
size_t ServiceMask::BitsPerPart() const
{
    return sizeof(LowPart) * SERVICES_PER_BYTE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\ServiceMask.h ===
//
// Wrapper to handle a 128-bit mask.
//
#pragma once
struct ServiceMask
{
    ULONGLONG LowPart;
    ULONGLONG HighPart;
    static ServiceMask const Empty;

    static size_t const SERVICES_PER_BYTE = 8;
    static size_t const SERVICE_BITS = XONLINE_MAX_BASE_SERVICES_ID;
    static size_t const SERVICE_BYTES = SERVICE_BITS / SERVICES_PER_BYTE;

    ServiceMask();
    ServiceMask(ULONGLONG const lowPart, ULONGLONG const highPart);
    template<size_t N>
    ServiceMask(DWORD (&rgServices)[N])
        : LowPart(0)
        , HighPart(0)
    {
        C_ASSERT(N == XONLINE_NUM_BASE_SERVICES_DWORDS);
        memcpy(&LowPart, rgServices, SERVICE_BYTES);
    }

    ServiceMask operator~() const;
    ServiceMask& operator&=(ServiceMask const & right);
    ServiceMask& operator|=(ServiceMask const & right);
    BOOL operator==(ServiceMask const & right) const;
    BOOL operator!=(ServiceMask const & right) const;

    // Didn't want to build a bit-shifting operator...
    BOOL IsBitSet(size_t const bitPos) const ;
    void SetBit(size_t const bitPos);

    // I get a little confused by things like
    // (svcMask1 & svcMask2) != ServiceMask::Empty
    // So as long as I'm making a full-fledged object to handle this, why
    // not add helper functions?
    BOOL HasAnyBits(ServiceMask const mask) const;
    BOOL HasAllBits(ServiceMask const mask) const;

private:
    ServiceMask operator&(ServiceMask const & right) const;
    ServiceMask operator|(ServiceMask const & right) const;

    // Figures out which part to use, based on the bit position passed in.
    ULONGLONG const * PartFromPos(size_t const bitPos) const;

    // Figures out the mask for a single bit position. This handles the fact
    // that bit, say, 40 is actually but 8, but in a different part.
    ULONGLONG MaskFromPos(size_t const bitPos) const;

    // Helper to know how many bits are in an individual part.
    size_t ServiceMask::BitsPerPart() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sg.h ===
// ---------------------------------------------------------------------------------------
// sg.h
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#pragma once

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#if defined(SG_BUILD_LSP)
    // This is the SGLSP build. No commonconfig. Yes proxy.
    #pragma message("Building Security Gateway (LSP)")
    #define SG_FEATURE_ARBITRATION_WORKAROUND
    #define SG_FEATURE_ARP
    #define SG_FEATURE_LSP
    #define SG_FEATURE_PERFCTRS
    #define SG_FEATURE_TRACE
    #define SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
#elif defined(SG_BUILD_ONEBOX)
    // This is the Xblob build.
    #pragma message("Building Security Gateway (ONEBOX)")
    #define SG_FEATURE_ARBITRATION_WORKAROUND
    #define SG_FEATURE_ARP
    #define SG_FEATURE_NOISY_EVENTS
    #define SG_FEATURE_XMGMT
    #define SG_FEATURE_CONFIG_DB
    #define SG_FEATURE_PERFCTRS
    #define SG_FEATURE_TRACE
    #define SG_FEATURE_LUA
    #define SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
    // TEST ONLY!
    #define SG_FEATURE_UDP_ECHO
#elif defined(SG_BUILD_NEWSG)
    // This is the main SG build.
    #pragma message("Building Security Gateway (NEWSG)")
    #define SG_FEATURE_ARBITRATION_WORKAROUND
    #define SG_FEATURE_ARP
    #define SG_FEATURE_NOISY_EVENTS
    #define SG_FEATURE_XMGMT
    #define SG_FEATURE_CONFIG_DB
    #define SG_FEATURE_PERFCTRS
    #define SG_FEATURE_TRACE
    #define SG_FEATURE_LUA
    #define SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
#elif defined(SG_BUILD_INSTRUMENTATION)
    // This is a special test version of the SG that is an instrumented version of the LSP
    // build. It does not require the proxy though, nor commonconfig, making it very
    // standalone and easy to use. You will need a proper sgconfig.ini though.
    #pragma message("Building instrumented Security Gateway for perf investigation (LSP hybrid)")
    #define SG_FEATURE_ARBITRATION_WORKAROUND
    #define SG_FEATURE_ARP
    #define SG_FEATURE_LSP
    #define SG_FEATURE_PERFCTRS
    #define SG_FEATURE_TRACE
    #define SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
    #define SG_FEATURE_INSTRUMENTATION
    #define SG_FEATURE_UDP_ECHO
//  This will significantly slow down the locks!
//    #define CUTIL_FEATURE_FASTLOCK_INSTRUMENTATION
#else
    #error("Don't know which Security Gateway configuration to build")
#endif

#if DBG
#define SG_FEATURE_ASSERT
#endif

#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
#pragma message("  SG_FEATURE_ARBITRATION_WORKAROUND")
#endif

#ifdef SG_FEATURE_ARP
#pragma message("  SG_FEATURE_ARP")
#endif

#ifdef SG_FEATURE_ASSERT
#pragma message("  SG_FEATURE_ASSERT")
#endif

#ifdef SG_FEATURE_ASSERT_NOPOP
#pragma message("  SG_FEATURE_ASSERT_NOPOP")
#endif

#ifdef SG_FEATURE_COMMAND
#pragma message("  SG_FEATURE_COMMAND")
#endif

#ifdef SG_FEATURE_INSECURE
#pragma message("  SG_FEATURE_INSECURE")
#endif

#ifdef SG_FEATURE_LSP
#pragma message("  SG_FEATURE_LSP")
#endif

#ifdef SG_FEATURE_TRACE
#pragma message("  SG_FEATURE_TRACE")
#endif

#ifdef SG_FEATURE_NOISY_EVENTS
#pragma message("  SG_FEATURE_NOISY_EVENTS")
#endif

#ifdef SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
#pragma message("  SG_FEATURE_SGINFO_BACKCOMPAT_CACHE")
#endif

// ---------------------------------------------------------------------------------------
// System Includes
// ---------------------------------------------------------------------------------------

#define _WINSOCKAPI_ // Prevent inclusion of winsock.h in windows.h
#include <windows.h>
#undef _WINSOCKAPI_

#if DBG
    #define IFDBG(x)    x
    #define IFNDBG(x)
#else
    #define IFDBG(x)
    #define IFNDBG(x)   x
#endif

#ifndef s_addr
/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { BYTE s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { WORD s_w1,s_w2; } S_un_w;
                DWORD S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};
typedef in_addr IN_ADDR;
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>
#include <wincrypt.h>
#include <winsock2.h>
#include <wsockntp.h>
#include <Iphlpapi.h>
#include <cutil.h>
#include <xcrypt.h>
#include <xonlinep.h>
#include <xeventids.h>
#include <addref.h>
#include <xlocks.h>
using xlocks::CReaderWriterLock3;

#if defined(SG_FEATURE_LSP)
    #include "lspservice.h"
    #define CNTService CLspService
    #include <XmgmtLogging.h>
#else
    #include <ntservice.h>
#endif

#include "sgevent.h"

#ifdef SG_FEATURE_XMGMT
#include "xmgmt.h"
#endif

#include "ServiceMask.h"


#ifdef SG_FEATURE_LUA
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}
#endif

#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>
#include <atlsafe.h>
#include <atlconv.h>

using namespace ATL;

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
#include <commonconfig.h>

#include <ConfigListener.h>

#import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers

#define INLINE __forceinline

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

class   CPacket;
struct  CTransInfo;
struct  CDstInfo;
struct  CDstTransInfo;
struct  CSvcInfo;
struct  CSpiInfo;
typedef void (*PFNCOMPLETE)(class CPacket * ppkt);
struct  CIpAddr;
struct  CIpPort;
struct  CCfgInfo;
class   CXomParamList;
class   CXomControlResponseInterface;


// ---------------------------------------------------------------------------------------
// NTSTATUS
// ---------------------------------------------------------------------------------------

typedef long NTSTATUS, *PNTSTATUS;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

INLINE
void SgDbgBreak()
{
    DebugBreak();
}

#ifdef SG_FEATURE_ASSERT

    void SgDbgAssert(const char* pszExpr, const char* pszFile, int iLine, const char* pszMsg);
    char * __cdecl SgDbgAssertFmt(char const * pszFmt, ...);
    const char * SgDbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire);

    #define Assert(x) \
            do { if (!(x)) { SgDbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
    #define AssertSz(x,sz,...) \
            do { if (!(x)) { char * __pch__ = SgDbgAssertFmt(sz,__VA_ARGS__); SgDbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)

    #define AssertList(ple) \
            do { const char * __psz__ = SgDbgVerifyList(ple,NULL); \
            if (__psz__) { SgDbgAssert("AssertList("#ple")",__FILE__,__LINE__,__psz__); } } while (0)
    #define AssertListEntry(ple,pleReq) \
            do { const char * __psz__ = SgDbgVerifyList(ple,pleReq); \
            if (__psz__) { SgDbgAssert("AssertListEntry("#ple","#pleReq")",__FILE__,__LINE__,__psz__); } } while (0)

#else

    #define Assert(x)
    #define AssertSz(x,sz,...)
    #define AssertList(ple)
    #define AssertListEntry(ple,pleReq)

#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Trace
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_TRACE

//
// Tag list
//

#define TAG_LIST_BASIC() \
    DefineTag(ChalTrace,            TAG_DISABLE)        \
    DefineTag(ClientStats,          TAG_DISABLE)        \
    DefineTag(ClientStatsFlow,      TAG_DISABLE)        \
    DefineTag(Config,               TAG_ENABLE_DEBUG)   \
    DefineTag(CConfigInfoDbg,       TAG_DISABLE)        \
    DefineTag(DnsResolve,           TAG_DISABLE)        \
    DefineTag(Event,                TAG_ENABLE_DEBUG)   \
    DefineTag(KerbVerbose,          TAG_DISABLE)        \
    DefineTag(KerbWarn,             TAG_DISABLE)        \
    DefineTag(Lock,                 TAG_DISABLE)        \
    DefineTag(LspRefresh,           TAG_DISABLE)        \
    DefineTag(NatInfo,              TAG_DISABLE)        \
    DefineTag(Notification,         TAG_DISABLE)        \
    DefineTag(Pulse,                TAG_DISABLE)        \
    DefineTag(RecvArp,              TAG_DISABLE)        \
    DefineTag(RecvDiscard,          TAG_DISABLE)        \
    DefineTag(RecvEnet,             TAG_DISABLE)        \
    DefineTag(RecvIgnore,           TAG_DISABLE)        \
    DefineTag(RecvIp,               TAG_DISABLE)        \
    DefineTag(RecvKeyEx,            TAG_DISABLE)        \
    DefineTag(RecvSecMsg,           TAG_DISABLE)        \
    DefineTag(RecvXsp,              TAG_DISABLE)        \
    DefineTag(ScratchMemoryAlloc,   TAG_DISABLE)        \
    DefineTag(ScratchMemoryVerbose, TAG_DISABLE)        \
    DefineTag(SgSvc,                TAG_DISABLE)        \
    DefineTag(SpiFlow,              TAG_DISABLE)        \
    DefineTag(SpiTrace,             TAG_DISABLE)        \
    DefineTag(Timer,                TAG_DISABLE)        \
    DefineTag(UdpEcho,              TAG_DISABLE)        \
    DefineTag(Warning,              TAG_DISABLE)        \
    DefineTag(Xmit,                 TAG_DISABLE)        \
    DefineTag(XmitArp,              TAG_DISABLE)        \
    DefineTag(XmitKeyEx,            TAG_DISABLE)        \
    DefineTag(XmitXsp,              TAG_DISABLE)        \

#ifdef SG_FEATURE_LUA
#define TAG_LIST_FEATURE() \
    DefineTag(LuaInfo,             TAG_DISABLE)        \
    DefineTag(LuaScript,           TAG_ENABLE_DEBUG)   \

#else
#define TAG_LIST_FEATURE()

#endif

#define TAG_LIST() \
    TAG_LIST_BASIC() \
    TAG_LIST_FEATURE() \

//
// Export tags - tags will be always disabled in retail builds. Some tags will be enabled
// in debug builds.
//

#define TAG_DISABLE     0
#define TAG_ENABLE      1

#if _DEBUG
#define TAG_ENABLE_DEBUG 1
#else
#define TAG_ENABLE_DEBUG 0
#endif

#define Tag(t)  t_##t

#define DefineTag(t, s) extern int Tag(t);

TAG_LIST();

#undef DefineTag

void __cdecl SgDbgTrace(const char * szTag, const char * szFmt, ...);

#define SetTag(t, i)    Tag(t) = i

#define TraceSz(t,sz,...) \
        do { if (Tag(t) > 0) { SgDbgTrace(#t,sz,__VA_ARGS__); if (Tag(t) > 1) SgDbgBreak(); } } while (0)

#else // ! SG_FEATURE_TRACE

#define Tag(t)  0

#define SetTag(t, i)
#define TraceSz(t,sz,...)

#endif

#define INAFMT "%d.%d.%d.%d"
#define INAPRM(x) \
    (x)->S_un.S_un_b.s_b1, \
    (x)->S_un.S_un_b.s_b2, \
    (x)->S_un.S_un_b.s_b3, \
    (x)->S_un.S_un_b.s_b4

#define SYSTEMTIMEFMT "%04d/%02d/%02d %02d:%02d:%02d.%03d"
#define SYSTEMTIMEPRM(x) \
    (x)->wYear, \
    (x)->wMonth, \
    (x)->wDay, \
    (x)->wHour, \
    (x)->wMinute, \
    (x)->wSecond, \
    (x)->wMilliseconds

#define ETHERFMT "%02X-%02X-%02X-%02X-%02X-%02X"
#define ETHERPRM(x) \
    x[0], \
    x[1], \
    x[2], \
    x[3], \
    x[4], \
    x[5]


BOOL            SgTraceInit();
BOOL            SgTraceConfig(CCfgInfo* pci);
BOOL            SgTraceConfigDone(CCfgInfo* pci);
void            SgTraceTerm();

// ---------------------------------------------------------------------------------------
// Event Log
// ---------------------------------------------------------------------------------------

#define         SgEventSz(id,sz,...)                                    SgLogEvent(EVENT_SG_##id,0,NULL,0,NULL,sz,__VA_ARGS__)

#define         SgEvent(id)                                             SgLogEvent(EVENT_SG_##id,0,NULL,0,NULL,NULL);

#define         SgEventData(id,cb,pv)                                   SgLogEvent(EVENT_SG_##id,0,NULL,cb,pv,NULL);
#define         SgEventDataSz(id,cb,pv,sz,...)                          SgLogEvent(EVENT_SG_##id,0,NULL,cb,pv,sz,__VA_ARGS__);

#define         SgCurrentFile()                                         SgFileFromPath(__FILE__)
#define         SgEventPacketWithText(id,ppkt,ip,port,cb,pv,txt)        SgLogPacketEvent(EVENT_SG_##id,ppkt,ip,port,cb,pv,txt);
#define         SgEventPacket(id,ppkt,ip,port,cb,pv)                    SgLogPacketEvent(EVENT_SG_##id,ppkt,ip,port,cb,pv,NULL);
#define         SgEventInternalError(cb,pv)                             SgLogEvent(EVENT_SG_INTERNAL_ERROR,0,NULL,cb,pv,"%d:%s",__LINE__,SgCurrentFile());

#ifdef SG_FEATURE_NOISY_EVENTS
#define         SgEventPacketNoisy(id,ppkt,ip,port,cb,pv)               SgLogPacketEvent(EVENT_SG_##id,ppkt,ip,port,cb,pv,NULL);
#else
#define         SgEventPacketNoisy(id,ppkt,ip,port,cb,pv)
#endif

void __cdecl    SgLogEvent(DWORD dwId, ULONG cbPkt, CIpAddr *pipaSrc, ULONG cb, PVOID pv, const char * pszFmt, ...);

void __cdecl    SgLogPacketEvent(DWORD dwId, CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipport, ULONG cb, PVOID pb, LPCSTR szText);

// Controls what we log during SgEventLogPacket calls. Caller MUST ensure the appropriate
// ppkt->_pEnetHdr, _pIpHdr, _pXspHdr pointers are correctly set!

#define PEVT_FILTER_ENET        0x01
#define PEVT_FILTER_IP          0x02
#define PEVT_FILTER_UDP         0x04
#define PEVT_FILTER_XSP         0x08

#define         SgEventPacketLogNoisy(id,ppkt,ip,port,filter)             SgLogPacketToLog(1, EVENT_SG_##id,ppkt,ip,port,filter,NULL);
#define         SgEventPacketLogNoisyEx(id,ppkt,ip,port,filter,cb,pv)     SgLogPacketToLog(1, EVENT_SG_##id,ppkt,ip,port,filter,(cb) > 0 ? SgHexStr((pv),(cb)) : NULL);
#define         SgEventPacketLogNoisyWithText(id,ppkt,ip,port,filter,txt) SgLogPacketToLog(1, EVENT_SG_##id,ppkt,ip,port,filter,txt);
#define         SgEventPacketLog(id,ppkt,ip,port,filter)                  SgLogPacketToLog(2, EVENT_SG_##id,ppkt,ip,port,filter,NULL);
#define         SgEventPacketLogEx(id,ppkt,ip,port,filter,cb,pv)          SgLogPacketToLog(2, EVENT_SG_##id,ppkt,ip,port,filter,(cb) > 0 ? SgHexStr((pv),(cb)) : NULL);
#define         SgEventPacketLogWithText(id,ppkt,ip,port,filter,txt)      SgLogPacketToLog(2, EVENT_SG_##id,ppkt,ip,port,filter,txt);

void __cdecl    SgLogPacketToLog(char level,
                                 DWORD dwId,
                                 CPacket * ppkt,
                                 CIpAddr ipaSrc,
                                 CIpPort ipportSrc,
                                 DWORD dwPacketEventFilter,
                                 LPCSTR szText);

#define MAX_EVENT_LENGTH    8000

void            SgWriteEventLogEntry(DWORD dwId, ULONG cb, PVOID pv, LPCSTR psz);

INLINE char *   SgFileFromPath(char * pszPath)
{
    char * pszFile = strrchr(pszPath, '\\');
    return (pszFile ? pszFile + 1 : pszPath);
}

// ---------------------------------------------------------------------------------------
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
// ---------------------------------------------------------------------------------------

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

// ---------------------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------------

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define ROUNDUP16(count)        (((count) + 15) & ~15)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }
INLINE UINT64 HTONQ(UINT64 uq) {

    LARGE_INTEGER t1;
    LARGE_INTEGER t2;

    t1.QuadPart = uq;
    t2.HighPart = HTONL(t1.LowPart);
    t2.LowPart  = HTONL(t1.HighPart);
    return t2.QuadPart;
}
INLINE UINT64 NTOHQ(UINT64 uq) { return (HTONQ(uq)); }

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

typedef LARGE_INTEGER PUID;

#define DECLARE_NEW_DELETE(class) \
   INLINE void * operator new(size_t cb) { return(SgMemAlloc(cb, PTAG_##class)); } \
   INLINE void operator delete(void * pv) { SgMemFree(pv); }

#define DECLARE_NEW_DELETE_ZERO(class) \
   INLINE void * operator new(size_t cb) { return(SgMemAllocZ(cb, PTAG_##class)); } \
   INLINE void operator delete(void * pv) { SgMemFree(pv); }

#define _LODWORD(x)      (DWORD)(x & 0xFFFFFFFF)
#define _HIDWORD(x)      (DWORD)((x >> 32) & 0xFFFFFFFF)

extern UINT     g_cbSpiFlowData;

char *          SgHexStr(const void * pv, size_t cb);
char *          SgHexDumpStr(const void * pv, size_t cb);
void            SgHexDumpSpiFlow(DWORD dwPktNum, DWORD dwSpi, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3);
char *          SgSecMsgStr(WORD wType);
char *          SgSecMsgDelStr(DWORD dwReason);
char *          SgMsgStr(WORD wType);
char *          SgXspTypeStr(BYTE bType);
extern "C" WORD tcpipxsum(WORD xsum, const void * buf, UINT buflen);

// ---------------------------------------------------------------------------------------
// API Prototypes
// ---------------------------------------------------------------------------------------

struct CSgPerfData;

BOOL SgInit();
void SgTerm();
BOOL SgInstall(OUT BOOL *pfRebootRequired);
BOOL SgUninstall(OUT BOOL *pfRebootRequired);
BOOL SgConfig();
BOOL SgConfigWatcherInit();
void SgConfigWatcherTerm();
BOOL SgConfigWatcherConfig(CCfgInfo*);
void SgPerfdataQuery( CSgPerfData* pPerfData );

// ---------------------------------------------------------------------------------------
// CScriptInfo
// Encapsulates the data needed for loading and configuring a script
// ---------------------------------------------------------------------------------------
class CScriptInfo
{
public:
    CScriptInfo();

    CSmallStr   scriptName;
    CBuffer     scriptBuffer;
    CBuffer     blobBuffer;
    BOOL        bKickEnabled;
    BOOL        bTimeoutEnabled;
};

#define CONFIG_SCRIPT_FROM_RESOURCE             0x0001
#define CONFIG_SCRIPT_FROM_FILE                 0x0002
#define CONFIG_SCRIPT_FROM_DB                   0x0004
#define CONFIG_SCRIPT_ALL                       0x0007

#define SG_CONFIG_SCRIPT_LOCATION               "..\\sgcfg\\"
#define SG_CONFIG_SIM_SCRIPT_LOCATION           "..\\sgsim\\"
#define SG_CONFIG_SCRIPT_PATTERN                "*.lua"

BOOL SgConfigGetScriptList(
    CArenaAlloc*                                pArenaAlloc,
    THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts,
    CStr*                                       pScriptLocation,
    DWORD                                       dwScriptFlags
    );

HRESULT SgConfigGetScript(
    LPCSTR       pFilename,
    CScriptInfo* pScriptInfo,
    CStr*        pScriptLocation,
    DWORD        dwScriptFlags
    );

// ---------------------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------------------

#define CBCHALCODE                   768         // Maximum amount of code in a challenge
#define CBCHALCODESIG                256
#define CBSITEKEY                    16
#define CCHMAXUSERDATA               200
#define CLSPPROXYMAX                 1
#define MAX_ADAPTER_NAME             128
#define MAX_NETWORK_INTERFACES       8
#define MAX_PARAM_RESPONSE           16
#define MAX_SG_SERVICE_NAME          64
#define TICKS_PER_SECOND             5           // 200 ms per tick (25 years before DWORD wraps)

// Various config options for the threadpools. Mostly used for testing.
#define SGPROCBAL_THREADPOOL_NORMAL         0
#define SGPROCBAL_THREADPOOL_UNIFIED        1
#define SGPROCBAL_THREADPOOL_WIN32          2
#define SGPROCBAL_THREADPOOL_HYBRID         3
#define SGPROCBAL_THREADPOOL_MAXVALID       SGPROCBAL_THREADPOOL_HYBRID

// ---------------------------------------------------------------------------------------
// Crypto
// ---------------------------------------------------------------------------------------

void XcHMAC4(BYTE * pbKey, UINT cbKey, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3, BYTE * pb4, UINT cb4, BYTE * pbHash);
void XcHMACMakeKeyTable(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbKeyTable);
void XcHMACWithKeyTable(BYTE * pbKeyTable, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3, BYTE * pb4, UINT cb4, BYTE * pbHash);
void XcCrypt(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2);
void XcCryptWithKeyTable(DWORD dwOp, BYTE * pbKeyTable, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2);
void XcSHA(BYTE * pbSha, UINT cbSha, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3);
void XcGetCryptParamsFromKeyLength(IN UINT cbKey, OUT UINT *puiCipher, OUT UINT *puiBlockLen, OUT UINT *puiTableSize);

#define CBHT    (XC_SERVICE_SHA_CONTEXT_SIZE * 2)
#define CBDT    (max(XC_SERVICE_DES3_TABLESIZE, XC_SERVICE_AES_TABLESIZE))
#define CBDHG1  96
extern const BYTE g_abOakleyGroup1Mod[CBDHG1];
extern const BYTE g_abOakleyGroup1Base[CBDHG1];

// ---------------------------------------------------------------------------------------
// Locking
// ---------------------------------------------------------------------------------------

typedef DWORD KIRQL;

#ifdef SG_FEATURE_INSTRUMENTATION_none
#define AcquireDpc()   AcquireLock(); TraceSz3(Lock, "Acquire %s:%d %s", SgCurrentFile(), __LINE__, __FUNCTION__)
#define ReleaseDpc()   ReleaseLock(); TraceSz3(Lock, "Release %s:%d %s", SgCurrentFile(), __LINE__, __FUNCTION__)
#else
#define AcquireDpc()   AcquireLock()
#define ReleaseDpc()   ReleaseLock()
#endif

class CLock
{
public:

    INLINE void     Init()
    {
        _lock.Init();
    }
    INLINE void     Term()
    {
    }
    INLINE void     _Acquire(KIRQL * oldIrql)        { AcquireDpc(); }
    INLINE void     _Release(KIRQL oldIrql)          { ReleaseDpc(); }

    INLINE void     AcquireLock()
    {
        _lock.Lock();
        AssertSz(!_fAcquired, "Spin locks cannot be acquired recursively");
        IFDBG(_fAcquired = TRUE;)
   }

    INLINE void     ReleaseLock()
    {
        AssertSz(_fAcquired, "Unlocked spin lock released");
        IFDBG(_fAcquired = FALSE;)
        _lock.Unlock();
    }

private:
    CFastLock   _lock;
    IFDBG(BOOL  _fAcquired;)
};

// Use CFastLock from cu_base.h
typedef CFastLock CSpinLock;

// ---------------------------------------------------------------------------------------
// Performance Data
// ---------------------------------------------------------------------------------------

// Constants -----------------------------------------------------------------------------

#define PROC_DATA_COUNT 2 // The maximum number of processors to record performance data for

// Structures ----------------------------------------------------------------------------

struct CSgPerfData
{
    // global

    ULONGLONG   _ullCurrentConnections; // current connections
    ULONGLONG   _ullFreeConnections;    // current free connections
    ULONGLONG   _ullMaximumConnections; // maximum connections
    ULONGLONG   _ullConnectionsCipherDes;  // current connections using DES
    ULONGLONG   _ullConnectionsCipherDes3; // current connections using DES3
    ULONGLONG   _ullConnectionsCipherAes;  // current connections using AES
    ULONGLONG   _ullConnectionsCipherNull; // current connections using NULL
    ULONGLONG   _ullRecvTotal;          // packets received
    ULONGLONG   _ullRecvTotalBytes;     // bytes received
    ULONGLONG   _ullXmitTotal;          // packets sent
    ULONGLONG   _ullQueuedProc;         // load balancing queue
    ULONGLONG   _ullQueuedCli;          // CCliInfo queue
    ULONGLONG   _ullDroppedCli;         // Packets dropped from cli
    ULONGLONG   _ullQueuedSpi;          // CSpiInfo queue
    ULONGLONG   _ullDroppedSpi;         // packets dropped from spi
    ULONGLONG   _ullCurrentBlocked;     // CBlockInfo queue
    ULONGLONG   _ullDroppedBlocked;     // clients dropped from CBlockInfo
    ULONGLONG   _ullCurrentFreeBlockInfo; // free CBlockInfo items                                        
    ULONGLONG   _ullThreadPoolWaitCount;
    ULONGLONG   _ullThreadPoolActiveCount;
    ULONGLONG   _ullThreadPoolWorkItemsMissCount;
    ULONGLONG   _ullThreadPoolWorkItemsHitCount;
    ULONGLONG   _ullThreadPoolWorkItemsRetrievedCount;
    ULONGLONG   _ullSpinLockCollisions;
    ULONGLONG   _ullSpinLockSleeps;
    ULONGLONG   _ullSpinLockLocks;
    ULONGLONG   _ullPacketsAvailable;   // max packets - g_cPacketsInUse
    ULONGLONG   _ullPacketAllocFail;    // calls to SgPacketAlloc that failed (out of packets)
    ULONGLONG   _ullPacketAllocSuccess; // calls to SgPacketAlloc that succeeded
    ULONGLONG   _ullLoglinesFlowmap;

    // notifications

    ULONGLONG   _ullNotificationsDelete;
    ULONGLONG   _ullNotificationsDeleteDrop;
    ULONGLONG   _ullNotificationsDeleteQueue;
    ULONGLONG   _ullNotificationsDeleteBatches;
    ULONGLONG   _ullNotificationsUpdate;
    ULONGLONG   _ullNotificationsUpdateDrop;
    ULONGLONG   _ullNotificationsUpdateQueue;
    ULONGLONG   _ullNotificationsUpdateBatches;
    ULONGLONG   _ullNotificationsTitleChange;
    ULONGLONG   _ullNotificationsTitleChangeDrop;
    ULONGLONG   _ullNotificationsTitleChangeQueue;
    ULONGLONG   _ullNotificationsTitleChangeBatches;
    ULONGLONG   _ullNotificationsUserChange;
    ULONGLONG   _ullNotificationsUserChangeDrop;
    ULONGLONG   _ullNotificationsUserChangeQueue;
    ULONGLONG   _ullNotificationsUserChangeBatches;
    ULONGLONG   _ullNotificationsSpiUpdate;
    ULONGLONG   _ullNotificationsSpiUpdateDrop;
    ULONGLONG   _ullNotificationsSpiUpdateQueue;
    ULONGLONG   _ullNotificationsSpiUpdateBatches;

    // internet

    ULONGLONG   _ullIRecv;
    ULONGLONG   _ullIRecvBytes;
    ULONGLONG   _ullIXmit;
    ULONGLONG   _ullIXmitBytes;
    ULONGLONG   _ullIRecvDriverCalls;
    ULONGLONG   _ullIRecvPacketsDriver;
    ULONGLONG   _ullIRecvBatchThreshold;
    ULONGLONG   _ullIDropPacketsDriver;
    ULONGLONG   _ullIXmitDriverCalls;
    ULONGLONG   _ullIXmitPacketsDriver;
    ULONGLONG   _ullIXmitStage1Count;
    ULONGLONG   _ullIXmitStage2Count;
    ULONGLONG   _ullIXmitInProgress;

    ULONGLONG   _ullKeyEx;              // successful key exchanges
    ULONGLONG   _ullKeyExTotal;         // total key exchanges attempted
    ULONGLONG   _ullLogoffTotal;        // total logoffs
    ULONGLONG   _ullLogoffTimeout;      // client timed out
    ULONGLONG   _ullLogoffTimeoutKeyEx; // client timed out before sending any packets
    ULONGLONG   _ullLogoffReinit;       // client re-initiated key exchange
    ULONGLONG   _ullLogoffKick;         // client kicked off
    ULONGLONG   _ullXspRecv;            // verified XSP packets received
    ULONGLONG   _ullXspRecvTotal;       // total XSP packets received
    ULONGLONG   _ullXspXmit;            // XSP packets sent
    ULONGLONG   _ullAuthdataV2;         // successful sign-ins and changes using version 2
    ULONGLONG   _ullAuthdataV3;         // successful sign-ins and changes using version 3
    ULONGLONG   _ullAuthdataV4;         // successful sign-ins and changes using version 4

    // datacenter

    ULONGLONG   _ullZRecv;
    ULONGLONG   _ullZRecvBytes;
    ULONGLONG   _ullZXmit;
    ULONGLONG   _ullZXmitBytes;
    ULONGLONG   _ullZRecvDriverCalls;
    ULONGLONG   _ullZRecvPacketsDriver;
    ULONGLONG   _ullZRecvBatchThreshold;
    ULONGLONG   _ullZDropPacketsDriver;
    ULONGLONG   _ullZXmitDriverCalls;
    ULONGLONG   _ullZXmitPacketsDriver;
    ULONGLONG   _ullZXmitStage1Count;
    ULONGLONG   _ullZXmitStage2Count;
    ULONGLONG   _ullZXmitInProgress;

    // sgmsg

    ULONGLONG   _ullSgMsg;              // total SgMsg packets received
    ULONGLONG   _ullSgMsgInvalid;       // invalid SgMsg packets received
    ULONGLONG   _ullSgMsgNoMatch;       // SgMsg packets that didn't map to a client
    ULONGLONG   _ullSgMsgKick;          // kick requests
    ULONGLONG   _ullSgMsgQvalsLazy;     // QVALS lazy
    ULONGLONG   _ullSgMsgQvalsPush;     // QVALS push
    ULONGLONG   _ullSgMsgForward;       // Xb to Xb forward
    ULONGLONG   _ullSgMsgForward2;      // Xb to Xb forward 2
    ULONGLONG   _ullSgMsgSpiData;       // SpiData requests
    ULONGLONG   _ullSgMsgSpiData2;      // SpiData2 requests
    ULONGLONG   _ullSgMsgSpiData2Backcompat; // SpiData requests v2 requesting old authdata version

    // secmsg

    ULONGLONG   _ullSecMsg;                  // Number of SecMsgs received.
    ULONGLONG   _ullSecDelete;               // Client logoff
    ULONGLONG   _ullSecPulse;                // pulse without data
    ULONGLONG   _ullSecDataPulse;            // pulse with data
    ULONGLONG   _ullSecForward;              // Xb to Xb forward
    ULONGLONG   _ullSecForward2;             // Xb to Xb forward 2
    ULONGLONG   _ullSecQos;                  // QoS probe
    ULONGLONG   _ullSecChangeUsers;          // Change users request

#ifdef SG_FEATURE_LUA
    // challenges (sync)
    ULONGLONG   _ullChalSyncIssue;        // New Sync challenges being sent out
    ULONGLONG   _ullChalSyncResponse;     // Sync challenges being answered
    ULONGLONG   _ullChalSyncTimeout;      // Sync challenges not being answered
    ULONGLONG   _ullChalSyncPass;         // Sync challenges which are correct
    ULONGLONG   _ullChalSyncFail;         // Sync challenges which are incorrect
    ULONGLONG   _ullChalSyncBlock;        // Sync challenges that result in a block

    // challenges (async)
    ULONGLONG   _ullChalAsyncIssue;       // New Async challenges being sent out
    ULONGLONG   _ullChalAsyncResponse;    // Async challenges being answered
    ULONGLONG   _ullChalAsyncTimeoutDropped; // Async challenges being dropped
    ULONGLONG   _ullChalAsyncTimeoutAck;  // Async challenges not being ack'ed
    ULONGLONG   _ullChalAsyncTimeoutResp; // Async challenges not being responded to
    ULONGLONG   _ullChalAsyncPass;        // Async challenges which are correct
    ULONGLONG   _ullChalAsyncFail;        // Async challenges which are incorrect
    ULONGLONG   _ullChalAsyncBlock;       // Async challenges that result in a block

    // challenges (active)
    ULONGLONG   _ullChalActive;           // Number of challenges currently in active state
    ULONGLONG   _ullChalRetry;            // Number of challenges currently in retry state
    ULONGLONG   _ullChalRetryAck1;        // Number of challenges currently in retry state due to 1 ack timeout
    ULONGLONG   _ullChalRetryAck2;        // Number of challenges currently in retry state due to 2 ack timeout
    ULONGLONG   _ullChalRetryAck3;        // Number of challenges currently in retry state due to 3 ack timeout
    ULONGLONG   _ullChalRetryAck4;        // Number of challenges currently in retry state due to 4 ack timeout
    ULONGLONG   _ullChalRetryAck5;        // Number of challenges currently in retry state due to 5+ ack timeout
    ULONGLONG   _ullChalRetryResp1;       // Number of challenges currently in retry state due to 1 resp timeout
    ULONGLONG   _ullChalRetryResp2;       // Number of challenges currently in retry state due to 2 resp timeout
    ULONGLONG   _ullChalRetryResp3;       // Number of challenges currently in retry state due to 3 resp timeout
    ULONGLONG   _ullChalRetryResp4;       // Number of challenges currently in retry state due to 4 resp timeout
    ULONGLONG   _ullChalRetryResp5;       // Number of challenges currently in retry state due to 5+ resp timeout

    // filter
    ULONGLONG   _ullFilterKick;         // kicked due to filter
    ULONGLONG   _ullFilterSetDES;       // cipher set to DES via filter
    ULONGLONG   _ullFilterSetDES3;      // cipher set to DES3 via filter
    ULONGLONG   _ullFilterSetAES;       // cipher set to AES via filter
    ULONGLONG   _ullFilterSetNULL;      // cipher set to NULL via filter
#endif

    // dropped packets

    ULONGLONG   _ullDropEnetHdr;        // dropped for bad enet hdr
    ULONGLONG   _ullDropIpHdr;          // dropped for bad IP hdr
    ULONGLONG   _ullDropXspHdr;         // dropped for bad XSP hdr
    ULONGLONG   _ullDropXspHash;        // dropped for bad XSP hash
    ULONGLONG   _ullDropDenied;         // dropped for Service access denied
    ULONGLONG   _ullDropKeyExFormat;    // dropped for bad keyex format
    ULONGLONG   _ullDropKeyExKerb;      // dropped for bad keyex kerb ticket
    ULONGLONG   _ullDropAuthenticator;  // dropped for bad keyex authenticator
    ULONGLONG   _ullDropKeyExTooSoon;   // dropped for arriving too soon
    ULONGLONG   _ullDropKeyExHash;      // dropped for bad keyex hash
    ULONGLONG   _ullDropKeyExBlocked;   // dropped for blocked keyex
    
    // lua

    ULONGLONG   _ullLuaCalls;            // Number of LUA calls
    ULONGLONG   _ullLuaMemoryUsageBytes; // Amount of LUA memory in bytes
    ULONGLONG   _ullLuaStateInUse;       // Number of LUA states in use
    ULONGLONG   _ullLuaStateAcquire;     // Rate of LUA states acquired
    ULONGLONG   _ullLuaStateTime;        // Time spent in LUA
    ULONGLONG   _ullLuaStateLockTime;    // Time spent acquiring LUA state
                                         
    // driver

    ULONGLONG   _ullDriverProtocolReceivePacketCalls;      // Number of ProtocolReceivePacket calls received by the driver
    ULONGLONG   _ullDriverProtocolReceivePacketCopyCalls;  // Number of ProtocolReceivePacket calls received by the driver where we had to copy the packet
    ULONGLONG   _ullDriverProtocolReceiveIndicationCalls;  // Number of ProtocolReceiveIndication calls received by the driver
    ULONGLONG   _ullDriverProtocolReceiveIndicationDiscard;// Number of ProtocolReceiveIndication calls that discarded the packet
    ULONGLONG   _ullDriverProtocolReceiveCompleteCalls;    // Number of ProtocolReceiveComplete calls received by the driver
    ULONGLONG   _ullDriverPacketsInUse;                    // Number of packets being used by the driver
};

// ---------------------------------------------------------------------------------------
// Callback Data
// ---------------------------------------------------------------------------------------

// Structures ----------------------------------------------------------------------------

#include <pshpack1.h>

struct CSgSvcHdr
{
    // Definitions of message types ------------------------------------------------------

    #define SGSVC_TYPE_CLIENT_ADD       1               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_DEL       2               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_UPD       3               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_TCHG      4               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_LOGCHAL   5               // CSgSvcClient
    #define SGSVC_TYPE_CONFIG           6               // CSgSvcConfig
    #define SGSVC_TYPE_CLIENT_SCHG      7               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_UCHG      8               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_CHG       9               // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_FLOWMAP   10              // CSgSvcClient
    #define SGSVC_TYPE_CLIENT_LOGLUA    11              // CSgSvcClient

    // Definitions for Delete ------------------------------------------------------------

    #define SPIDEL_REINIT                       1       // Client re-initiated session
    #define SPIDEL_ALLOC                        2       // SG allocation failure
    #define SPIDEL_BLOCK1                       3       // AuthBlock at keyex
    #define SPIDEL_BLOCK2                       4       // AuthBlock after keyex
    #define SPIDEL_INHIBIT                      5       // KeyEx inhibited (insecure SG only)
    #define SPIDEL_CLIENT                       6       // Client closed session
    #define SPIDEL_OBSOLETE_1                   7       // Client failed DVD challenge was SPIDEL_CHALDVD
    #define SPIDEL_OBSOLETE_2                   8       // Client failed code challenge was SPIDEL_CHALCODE
    #define SPIDEL_OBSOLETE_3                   9       // Client failed both challenges was SPIDEL_CHALBOTH
    #define SPIDEL_KICK                         10      // Duplicate logon
    #define SPIDEL_TIMEOUT_KEYEX                11      // Client never responded to keyex
    #define SPIDEL_TIMEOUT                      12      // Client timed out active session
    #define SPIDEL_NAT_DETECTION_DISCONNECT     13      // Client timed out activity-wise
    #define SPIDEL_CHALLENGE_TIMEOUT            14      // Client timed out challenge wise
    #define SPIDEL_CHALLENGE_LUA                15      // Kicked by a LUA challenge
    #define SPIDEL_PACKET_LIMIT                 16      // Count of packets exceeded disconnect threshold
    #define SPIDEL_POLICY                       17      // Client violated a policy decision
    #define SPIDEL_TICKET_EXPIRED               18      // Client has an expired ticket

    #define MAX_SPIDEL                          19

    // Data ------------------------------------------------------------------------------

    WORD                    _wType;                     // See SGSVC_TYPE_* above
    WORD                    _cbEnt;                     // Size of this entry
};


// Type SGSVC_TYPE_CLIENT_LOGCHAL - the rest of the entry is a CLogChallenge.
// Type SGSVC_TYPE_CLIENT_LOGCHAL_2
struct CLogChallenge
{
    BOOL                _fCodeLog;                  // write record to code log
    BOOL                _fCodeKick;                 // code challenge failed
    DWORD               _dwChalCodeId;              // code challenge id
    DWORD               _iChalCodeParam;            // code challenge parameter index
};

size_t const CSVCINFOMAX = 128;  // Maximum number of services
#define MAX_NOTIFY_URL_LEN           256
#define MAX_NETWORK_INTERFACES       8
#define MAX_DNSNAME_LEN              64

struct CSgSvcConfig : public CSgSvcHdr
{
    // Data ------------------------------------------------------------------------------

    // Members that specify the number of structures of each type that follow
    DWORD                   _cNotifyUpdateServers;
    DWORD                   _cNotifyTitleChangeServers;
    DWORD                   _cNotifyDeleteServers;
    DWORD                   _cNotifyUserChangeServers;
    DWORD                   _cNotifySpiUpdateServers;

    // Global Settings (alphabetical) ////////////////////////////////////////////////////
    DWORD                   _dwNotifyUpdateBatchIntervalInSeconds;
    DWORD                   _dwNotifyUpdateBatchCount;
    DWORD                   _dwNotifyUpdateQueueCount;
    DWORD                   _dwNotifyTitleChangeBatchIntervalInSeconds;
    DWORD                   _dwNotifyTitleChangeBatchCount;
    DWORD                   _dwNotifyTitleChangeQueueCount;
    DWORD                   _dwNotifyDeleteBatchIntervalInSeconds;
    DWORD                   _dwNotifyDeleteBatchCount;
    DWORD                   _dwNotifyDeleteQueueCount;
    DWORD                   _dwNotifyUserChangeBatchIntervalInSeconds;
    DWORD                   _dwNotifyUserChangeBatchCount;
    DWORD                   _dwNotifyUserChangeQueueCount;
    DWORD                   _dwNotifySpiUpdateBatchIntervalInSeconds;
    DWORD                   _dwNotifySpiUpdateBatchCount;
    DWORD                   _dwNotifySpiUpdateQueueCount;

    // Internet Interfaces ///////////////////////////////////////////////////////////////
    DWORD                   _cInetInterfaces;
    DWORD                   _rgdwInetInterfaces[ MAX_NETWORK_INTERFACES ]; // The IP in network byte order

    // Servers ///////////////////////////////////////////////////////////////////////////
    struct Server
    {
        char  _rgchUrl[ MAX_NOTIFY_URL_LEN ];
        char  _rgchHealthUrl[ MAX_NOTIFY_URL_LEN ];
        DWORD _cServiceIds;
        DWORD _rgdwServiceIds[ CSVCINFOMAX ]; // At most all services are on one server
        char  _szDnsName[ MAX_DNSNAME_LEN ];
        DWORD _dwIp;
        WORD  _wPort;
        WORD  _wHealthPort;
    };

    // Helper functions for accessing individual structures //////////////////////////////
    Server*         GetUpdateServerList() const      { return (Server*)( this + 1 ); }
    Server*         GetTitleChangeServerList() const { return (Server*)( GetUpdateServerList() + _cNotifyUpdateServers ); }
    Server*         GetDeleteServerList() const      { return (Server*)( GetTitleChangeServerList() + _cNotifyTitleChangeServers ); }
    Server*         GetUserChangeServerList() const  { return (Server*)( GetDeleteServerList() + _cNotifyDeleteServers ); }
    Server*         GetSpiUpdateServerList() const   { return (Server*)( GetUserChangeServerList() + _cNotifyUserChangeServers ); }
};

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// Performance Counters
// ---------------------------------------------------------------------------------------

    INLINE LARGE_INTEGER SgQueryPerformanceCounter(LARGE_INTEGER * pliFreq)
    {
        if (pliFreq != NULL)
        {
            QueryPerformanceFrequency(pliFreq);
        }

        LARGE_INTEGER li;
        QueryPerformanceCounter(&li);

        return(li);
    }

// ---------------------------------------------------------------------------------------
// CEnetAddr
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    INLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    char * Str() const;
};

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// CIpAddr
// ---------------------------------------------------------------------------------------

struct CIpAddr
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IPADDR_BROADCAST            CIpAddr(HTONL(0xFFFFFFFF))
    #define IPADDR_LOOPBACK             CIpAddr(HTONL(0x7F000001))
    #define IPADDR_CLASSA_NETMASK       CIpAddr(HTONL(0xFF000000))
    #define IPADDR_CLASSB_NETMASK       CIpAddr(HTONL(0xFFFF0000))
    #define IPADDR_CLASSC_NETMASK       CIpAddr(HTONL(0xFFFFFF00))
    #define IPADDR_CLASSD_NETMASK       CIpAddr(HTONL(0xF0000000))
    #define IPADDR_CLASSD_NETID         CIpAddr(HTONL(0xE0000000))
    #define IPADDR_LOOPBACK_NETID       CIpAddr(HTONL(0x7F000000))

    INLINE operator DWORD () const { return(_dw); }
    INLINE operator IN_ADDR () const { return(*((IN_ADDR*)(&_dw))); }
    INLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    INLINE DWORD operator = (IN_ADDR & addr) { return(_dw = addr.s_addr); }
    INLINE BOOL operator == (CIpAddr & ipa) { return(_dw == ipa._dw); }
    INLINE BOOL operator != (CIpAddr & ipa) { return(_dw != ipa._dw); }
    INLINE CIpAddr(DWORD dw) { _dw = dw; }
    INLINE CIpAddr(IN_ADDR addr) { _dw = addr.s_addr; }
    INLINE CIpAddr():_dw(0) {}

    INLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    INLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    INLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    INLINE BOOL IsClassA() const { return((_dw & HTONL(0x80000000)) == HTONL(0x00000000)); }
    INLINE BOOL IsClassB() const { return((_dw & HTONL(0xC0000000)) == HTONL(0x80000000)); }
    INLINE BOOL IsClassC() const { return((_dw & HTONL(0xE0000000)) == HTONL(0xC0000000)); }
    INLINE BOOL IsClassD() const { return((_dw & HTONL(0xF0000000)) == HTONL(0xE0000000)); }
    INLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
           BOOL IsValidAddr(CIpAddr ipaMask) const;
    char * Str() const;
};

// ---------------------------------------------------------------------------------------
// CIpPort
// ---------------------------------------------------------------------------------------

struct CIpPort
{
    WORD            _w;

    INLINE operator WORD () { return (_w); }
    INLINE WORD operator = (WORD & w) { return(_w = w); }
    INLINE CIpPort(WORD w) { _w = w; }
    INLINE CIpPort():_w(0) {}
};

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

class CPacketQueue
{

public:

    void                InsertHead(CPacket * ppkt);
    void                InsertTail(CPacket * ppkt);
    void                InsertHead(CPacketQueue * ppq);
    CPacket *           RemoveHead();
    BOOL                Dequeue(CPacket * ppktDequeue);
    void                Complete();
    UINT                Count();

    INLINE void         Init()      { _ppktHead = NULL; _ppktTail = NULL; _cPacket = 0; }
    INLINE BOOL         IsEmpty()   { return(_ppktHead == NULL); }
    INLINE CPacket *    GetHead()   { return(_ppktHead); }

private:

    CPacket *           _ppktHead;
    CPacket *           _ppktTail;
    volatile DWORD      _cPacket;
};

// ---------------------------------------------------------------------------------------
// CSgMsgQueue - queues using CPackets. Kinda ghetto.
// ---------------------------------------------------------------------------------------

class CSgMsgQueue
{

public:

    BOOL            Enqueue(const CSgMsgHdr * pSgMsg);
    DWORD           DequeueMultiToBuffer(BYTE * abBuffer, DWORD cBuffer);

    void            Init()                 { _pq.Init(); _lock.Init(); }
    void            Term()                 { _lock.AcquireLock(); _pq.Complete(); _maxCount = 0; _lock.ReleaseLock(); }
    void            Config(DWORD maxCount) { _maxCount = maxCount; }
    DWORD           Count()                { return _pq.Count(); }
    DWORD           SlotsRemaining()       { return _maxCount - _pq.Count(); }
    void            Complete()             { _lock.AcquireLock(); _pq.Complete(); _lock.ReleaseLock(); }

private:

    CPacketQueue        _pq;
    CLock               _lock;
    DWORD               _maxCount;
};



// ---------------------------------------------------------------------------------------
// CTimer
// ---------------------------------------------------------------------------------------

typedef void (*PFNTIMER)(struct CTimer * pTimer);

struct CTimer : public SERVER_TIMER_APPOINTMENT
{
    #define TICKS_PER_MINUTE            (TICKS_PER_SECOND * 60)
    #define TIMER_INFINITE              0xFFFFFFFFFFFFFFFF
    #define TIMER_MAX_TICK_DUE_DELTA    (TICKS_PER_SECOND * 60 * 60 * 24)

    void Init()
    {
        memset(this, 0, sizeof(*this));
    }

    static VOID WINAPI TimerCallback(VOID* pParam)
    {
        CTimer* pThis = (CTimer*)pParam;
        pThis->_pfn(pThis);
    }

    PFNTIMER _pfn;
    CServerTimer* _pServerTimer;
};

BOOL                SgEventInstall();
BOOL                SgEventInit();
BOOL                SgEventConfig(CCfgInfo* pci);
void                SgEventTerm();

extern UINT64       g_qwTickNow;

BOOL                SgTimerInit();
BOOL                SgTimerConfig(CCfgInfo* pci);
void                SgTimerStop();
void                SgTimerTerm();
void                SgTimerSet(CTimer * pt, PFNTIMER pfn, UINT64 qwTickDue, BOOL fLong);
INLINE UINT64       SgTimerTick()   { return(g_qwTickNow); }
void                SgTimerPush();

// ---------------------------------------------------------------------------------------
// Memory
// ---------------------------------------------------------------------------------------

BOOL                SgMemInit();
BOOL                SgMemConfig(CCfgInfo* pci);
void *              SgMemAlloc(size_t size, ULONG tag);
void *              SgMemAllocZ(size_t size, ULONG tag);
void *              SgMemReAlloc(void * pv, size_t cb, ULONG tag);
void                SgMemFree(void * pv);
void                SgMemTerm();

#define PTAG_Sg                         NTOHL_('Sg__')
#define PTAG_CAdapter                   NTOHL_('SgAD')
#define PTAG_ExternalDataBuffer         NTOHL_('SgED')
#define PTAG_CPacketInfo                NTOHL_('SgPI')
#define PTAG_RSA                        NTOHL_('SgRS')
#define PTAG_CArpInfo                   NTOHL_('SgAi')
#define PTAG_CAdapterTable              NTOHL_('SgAT')
#define PTAG_CTransInfo                 NTOHL_('SgTi')
#define PTAG_CSiteInfo                  NTOHL_('SgSi')
#define PTAG_CSvcInfo                   NTOHL_('SgSv')
#define PTAG_CDstInfo                   NTOHL_('SgDi')
#define PTAG_CDstTransInfo              NTOHL_('SgDt')
#define PTAG_CBlockInfo                 NTOHL_('SgBl')
#define PTAG_CCliInfo                   NTOHL_('SgCi')
#define PTAG_CCfgInfo                   NTOHL_('SgCg')
#define PTAG_CSpiInfo                   NTOHL_('SgSp')
#define PTAG_CNatInfo                   NTOHL_('SgNi')
#define PTAG_CNdisRequest               NTOHL_('SgNR')
#define PTAG_CProcBalInfo               NTOHL_('SgPB')
#define PTAG_CPacket                    NTOHL_('SgPk')
#define PTAG_PROCINFO                   NTOHL_('SgPR')
#define PTAG_CDhInfo                    NTOHL_('SgDh')
#define PTAG_SG_PROC_PERFORMANCE_DATA   NTOHL_('SgPd')
#define PTAG_TempCfg                    NTOHL_('SgTc')
#define PTAG_CEventThrottle             NTOHL_('SgET')
#define PTAG_CRawNic                    NTOHL_('SgRn')
#define PTAG_CTitleInfo                 NTOHL_('SgTt')
#define PTAG_CSvcMsgConfig              NTOHL_('SgCf')
#define PTAG_CPacketQueue               NTOHL_('SgPq')
#define PTAG_CTransCtx                  NTOHL_('SgTx')
#define PTAG_IpAdapterInfo              NTOHL_('SgIa')
#define PTAG_TraceFile                  NTOHL_('SgTf')
#define PTAG_CUtil                      NTOHL_('SgCu')
#define PTAG_Lua                        NTOHL_('SgLu')
#define PTAG_CSgLuaStateTable           NTOHL_('SgLt')
#define PTAG_CSgLuaState                NTOHL_('SgLs')
#define PTAG_CClientStats               NTOHL_('SgCS')
#define PTAG_CPacketHistoryRecords      NTOHL_('SgPH')
#define PTAG_CPacketTypeStats           NTOHL_('SgPT')
#define PTAG_NullCipher                 NTOHL_('SgNC')
#define PTAG_CConnGroup                 NTOHL_('SgCN')
#define PTAG_DnsEntry                   NTOHL_('SgDN')

// CSgMemAlloc
// IMemAlloc based memory allocator for cutil.h's classes that use SgMem* functions

class CSgMemAlloc : public IMemAlloc
{
public:

    virtual void* Alloc(size_t size)
    {
        return SgMemAlloc(size, PTAG_CUtil);
    }

    virtual void Free(void* memblock)
    {
        return SgMemFree(memblock);
    }

    static IMemAlloc* GetAlloc()
    {
        return &_sgAlloc;
    }

    static CSgMemAlloc _sgAlloc;
};

// ---------------------------------------------------------------------------------------
// CHashTable
// ---------------------------------------------------------------------------------------

typedef DWORD (*PFNHCOMPUTE)(LIST_ENTRY * ple);
typedef BOOL  (*PFNHCOMPARE)(LIST_ENTRY * ple1, void * ple2);
typedef void  (*PFNHFREE)(void * pv);
typedef void  (*PFNHDUMP)(LIST_ENTRY * ple);

class CHashTable
{

public:

    INLINE          CHashTable() { _ple = NULL; }
    INLINE         ~CHashTable() { Term(); }
    BOOL            Init(UINT cBucket, ULONG tag,
                         PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare, PFNHFREE pfnFree, PFNHDUMP pfnDump);
    void            Term();
    void            Free();
    void            Dump();
    LIST_ENTRY *    Lookup(LIST_ENTRY * pleLok);
    void            Insert(LIST_ENTRY * pleIns);
    void            Delete(LIST_ENTRY * pleDel);
    INLINE UINT     GetCount() const                { return(_cEnt); }
    INLINE UINT     GetBucketCount() const          { return(_cBucket); }

private:

    LIST_ENTRY *    _ple;               // Vector of hash buckets
    UINT            _cBucket;           // Number of buckets in the table
    UINT            _cEnt;              // Number of entries in the table
    PFNHCOMPUTE     _pfnCompute;        // Function to compute a 32-bit hash from an entry
    PFNHCOMPARE     _pfnCompare;        // Function to compare two entries for equality
    PFNHFREE        _pfnFree;           // Function to free entries
    PFNHDUMP        _pfnDump;           // Function to dump entries
};

#define DECLARE_HASH_TABLE(_type) \
    DWORD Sg##_type##HashCompute(C##_type *); \
    BOOL  Sg##_type##HashCompare(C##_type *, C##_type *); \
    class C##_type##Hash : public CHashTable { public: DECLARE_NEW_DELETE(C##_type); \
    INLINE BOOL Init(UINT cEnt, PFNHFREE pfnFree, PFNHDUMP pfnDump = NULL) { return(CHashTable::Init(cEnt, PTAG_C##_type, (PFNHCOMPUTE)Sg##_type##HashCompute, (PFNHCOMPARE)Sg##_type##HashCompare, pfnFree, pfnDump)); } \
    INLINE C##_type * Lookup(C##_type * pvEnt) { return((C##_type *)CHashTable::Lookup((LIST_ENTRY *)pvEnt)); } \
    INLINE void  Insert(C##_type * pvEnt) { CHashTable::Insert((LIST_ENTRY *)pvEnt); } \
    INLINE void  Delete(C##_type * pvEnt) { CHashTable::Delete((LIST_ENTRY *)pvEnt); } \
    }; \

// ---------------------------------------------------------------------------------------
// CArpInfo
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_ARP

struct CArpInfo
{
    // Definitions -----------------------------------------------------------------------

    #define ARP_STATE_IDLE       0           // entry needs to be resolved
    #define ARP_STATE_GOOD       1           // entry has been sucessfully resolved
    #define ARP_STATE_BAD        2           // entry has failed resolution
    #define ARP_STATE_PROBE_1    3           // probe 1/3 has been sent
    #define ARP_STATE_PROBE_2    4           // probe 2/3 has been sent
    #define ARP_STATE_PROBE_3    5           // probe 3/3 has been sent
    #define ARP_STATE_ANNOUNCE_1 6           // announcement 1/2 has been sent
    #define ARP_STATE_ANNOUNCE_2 7           // announcement 2/2 has been sent
    #define ARP_STATE_DEFEND     8           // we're defending an ip address of ours
    #define ARP_STATE_CLEANUP    9           // entry needs to be released
    #define ARP_STATE_BUSY       10          // entry is currently being resolved
    // ARP_STATE_BUSY must be the last entry!

    #define ARP_OP_REQUEST      HTONS(1)    // opcodes
    #define ARP_OP_REPLY        HTONS(2)

    #define ARP_HWTYPE_ENET     HTONS(1)    // hardware address spaces
    #define ARP_HWTYPE_802      HTONS(6)

    // Important that these remain in order b/c we increment through them
    C_ASSERT(ARP_STATE_PROBE_1 == ARP_STATE_PROBE_2 - 1);
    C_ASSERT(ARP_STATE_PROBE_2 == ARP_STATE_PROBE_3 - 1);
    C_ASSERT(ARP_STATE_PROBE_3 == ARP_STATE_ANNOUNCE_1 - 1);
    C_ASSERT(ARP_STATE_ANNOUNCE_1 == ARP_STATE_ANNOUNCE_2 - 1);
    C_ASSERT(ARP_STATE_ANNOUNCE_2 == ARP_STATE_DEFEND - 1);

    // Data ------------------------------------------------------------------------------

    LIST_ENTRY      _le;                    // Link into _pTransInfo->_leArp
    CTransInfo *    _pTransInfo;            // Pointer to CTransInfo
    CIpAddr         _ipa;                   // Target IP address
    CEnetAddr       _ea;                    // Target Ethernet address
    volatile WORD   _wState;                // See ARP_STATE_* above
    CPacketQueue    _pqWait;                // Queue of packets waiting for resolution
    CTimer          _Timer;                 // Timer for scheduling timeouts
    UINT            _cRefs;                 // Reference count from CTransInfo and CDstInfo
    BOOL            _fPersistent;           // TRUE if _pTransInfo owns this entry
};

extern CLock        g_lockArpInfo;          // Synchronizes access to ARP data
extern CTimer       g_timerPoolProbe;

BOOL                SgArpInfoInit();
BOOL                SgArpInfoConfig(CCfgInfo* pci);
void                SgArpInfoTerm();

INLINE void         SgArpInfoLock()         { g_lockArpInfo.AcquireDpc(); }
INLINE void         SgArpInfoUnlock()       { g_lockArpInfo.ReleaseDpc(); }

CArpInfo *          SgArpInfoLookupAddress(CTransInfo * pTransInfo, CIpAddr ipa);
CArpInfo *          SgArpInfoLookupProbe(CTransInfo * pTransInfo, CIpAddr ipa);
CArpInfo *          SgArpInfoLookup(CDstInfo * pDstInfo, CTransInfo * pTransInfo);
CArpInfo *          SgArpInfoInsert(CTransInfo * pTransInfo, CIpAddr ipa, BOOL fPersist);
CArpInfo *          SgArpInfoAlloc();
void                SgArpInfoRelease(CArpInfo * pArpInfo, BOOL fPersistent);
void                SgArpInfoRecv(CPacket * ppkt);
void                SgArpInfoXmit(CArpInfo * pArpInfo);
void                SgArpInfoTimer(CTimer * pTimer);
void                SgArpInfoStartNewProbe(CTransInfo * pTransInfo, CIpAddr ipa, BOOL fDefend);
void                SgArpInfoPoolTimer(CTimer *pTimer);
BOOL                SgIpConflictConfig(CCfgInfo* pci);

#else !SG_FEATURE_ARP

INLINE void         SgArpInfoLock()         {}
INLINE void         SgArpInfoUnlock()       {}

#endif // SG_FEATURE_ARP

// ---------------------------------------------------------------------------------------
// CTransInfo
// ---------------------------------------------------------------------------------------

DECLARE_HASH_TABLE(DstTransInfo);

struct CTransInfo
{
    // Definitions -----------------------------------------------------------------------

    // NONE could also be considered SG or SECMSG
    #define TRANSTYPE_NONE                  ((DWORD)'S')
    #define TRANSTYPE_INTERNET              ((DWORD)'I')
    #define TRANSTYPE_DMZ                   ((DWORD)'Z')

    // Data ------------------------------------------------------------------------------

    UINT                _iTransInfo;            // Index of this entry in g_pTransInfo
    BOOL                _fActive;               // TRUE if transport is not disabled
    void *              _pvPacketTrans;         // Private packet transport context
    CEnetAddr           _ea;                    // Ethernet address of this transport
    CEnetAddr           _eaAdapter;             // Ethernet address of the network adapter
    CIpAddr             _ipa;                   // IP address of this transport
    CIpAddr             _ipaMask;               // IP address mask
    CIpAddr             _ipaSubnet;             // IP subnet address
    CIpAddr             _ipaGateway;            // IP address of the default gateway
    CIpAddr             _ipaAdmin;              // IP address for administration (DMZ only)
    DWORD               _dwTransId;             // Id number of interface (DMZ only)
    DWORD               _dwIpaBeg;              // Lowest IP address (host byte order)
    DWORD               _dwIpaEnd;              // Highest IP address (host byte order)
    WORD                _wIpportBeg;            // Lowest IP port (host byte order)
    WORD                _wIpportEnd;            // Highest IP port (host byte order)
    DWORD               _dwType;                // See TRANSTYPE_* above
    UINT                _iNatInfoBase;          // Index of first CNatInfo of this transport
    UINT                _cNatInfo;              // Count of CNatInfo pointing to this transport
#ifdef SG_FEATURE_ARP
    LIST_ENTRY          _leArpAddresses;        // Queue of CArpInfo structures for traditional resolution
    LIST_ENTRY          _leArpProbes;           // Queue of CArpInfo structures for probes/announces/defends
    volatile BOOL       _fProbeInProgress;      // TRUE if probe is still in progress
    volatile BOOL       _fProbeConflict;        // TRUE if ip conflict detected for main ip
    volatile DWORD      _cProbePoolDone;        // Counts up for each probed _dwIpaBeg to _dwIpaEnd
    volatile DWORD      _cProbePoolConflict;    // Counts up for each conflict
#endif
    CDstTransInfoHash * _pDstTransInfoHash;     // Hash table mapping IP/Port to CDstTransInfo *
    CLock               _lockNatInfoFree;       // Synchronizes access to _leNatInfoFree
    UINT                _cNatInfoFree;          // Count of CNatInfo in _leNatInfoFree
    LIST_ENTRY          _leNatInfoFree;         // List of fre CNatInfo for this transport
};

struct CTransInfoCountersAdapter
{
    DWORD cReceiveCalls;
    DWORD cSendCalls;
    DWORD cPacketReceived;
    DWORD cPacketDropped;
    DWORD cPacketSent;
    DWORD cXmitStage1;
    DWORD cXmitStage2;
    DWORD cRecvBatchThreshold;
    DWORD cOverlappedsAllocated;
};

struct CTransInfoCountersGlobal
{
    DWORD cProtocolReceivePacket;
    DWORD cProtocolReceivePacketCopy;
    DWORD cProtocolReceiveIndication;
    DWORD cProtocolReceiveIndicationDiscard;
    DWORD cProtocolReceiveComplete;
    DWORD cPacketsInUse;
};

struct CTransInfoCounters
{
    CTransInfoCountersAdapter adapter;
    CTransInfoCountersGlobal global;
};

extern UINT         g_cTransInfo;               // Number of transports available
extern UINT         g_cTransInfoZ;              // Number of datacenter transports available
extern CTransInfo * g_pTransInfo;               // Vector of all CTransInfo structures

BOOL                TransConfig(CCfgInfo* pci);
BOOL                TransConfigTransport(CCfgInfo* pci, CTransInfo* pTransInfo);
BOOL                TransStart(CTransInfo * pTransInfo);
void                TransTerm(CTransInfo * pTransInfo);
BOOL                TransIsActive(CTransInfo * pTransInfo);
void                TransQueryCounters(CTransInfo* pTransInfo, CTransInfoCounters* pCounters);

BOOL                SgTransInfoInit();
BOOL                SgTransInfoConfig(CCfgInfo* pci);
void                SgTransInfoTerm();

BOOL                SgTransInfoReady();
CTransInfo *        SgTransInfoLookup(UINT iTransInfo);
CTransInfo *        SgTransInfoLookupZ(CIpAddr ipa);
CTransInfo *        SgTransInfoLookupZ(DWORD dwInterfaceId);
INLINE BOOL         SgTransInfoIsActive(CTransInfo * pTransInfo) { return TransIsActive(pTransInfo); }

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define IPPROTOCOL_SECMSG       0
#define IPPROTOCOL_ICMP         1
#define IPPROTOCOL_TCP          6
#define IPPROTOCOL_UDP          17

#define XSP_PORT                HTONS_(3074)
#define XSP_PORT_UDPECHO        HTONS_(3075)
#define XSP_PORT_XSPECHO        HTONS_(3076)

// Ethernet Headers ----------------------------------------------------------------------

#define ENET_DATA_MAXSIZE   1500
#define ENET_TYPE_IP        HTONS_(0x0800)
#define ENET_TYPE_ARP       HTONS_(0x0806)

#include <pshpack1.h>

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    INLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    INLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

#include <poppack.h>

// IP Header in Network Byte Order -------------------------------------------------------

#include <pshpack1.h>

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    INLINE UINT     GetHdrLen()     { return((_bVerHdr & 0xF) << 2); }
};

#include <poppack.h>

#define MAXIPHDRLEN         (15*4)
#define DONT_FRAGMENT       BIT(14)
#define MORE_FRAGMENTS      BIT(13)
#define FRAGOFFSET_MASK     0x1FFF
#define CBFRAMEMAX          ( sizeof( CIeeeHdr ) + ENET_DATA_MAXSIZE ) // Maximum number of bytes in a frame
#define CBFRAMEMAXSEND      ( sizeof( CEnetHdr) + ENET_DATA_MAXSIZE ) // Maximum number of bytes in a frame that we send

// UDP/TCP Pseudo Header in Network Byte Order -------------------------------------------

#include <pshpack1.h>

struct CPseudoHeader
{
    CIpAddr         _ipaSrc;
    CIpAddr         _ipaDst;
    BYTE            _bZero;
    BYTE            _bProtocol;
    WORD            _wLen;
};

#include <poppack.h>

// UDP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum
};

#include <poppack.h>

void    SgSetUdpHdrChecksum(CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3, BYTE * pb4, UINT cb4, BYTE * pb5, UINT cb5);

// TCP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CTcpInfo
{
    // Definitions -----------------------------------------------------------------------

    INLINE void SetHdrLen(UINT cb)  { _bHdrLen = (BYTE)(ROUNDUP4(cb) << 2); }
    INLINE UINT GetHdrLen()         { return((_bHdrLen & 0xF0) >> 2); }

    // Data ------------------------------------------------------------------------------

    DWORD           _dwSeqNum;      // Sequence number
    DWORD           _dwAckNum;      // Ack number
    BYTE            _bHdrLen;       // Header length (number of DWORDs)
    BYTE            _bFlags;        // Flags
    WORD            _wWindow;       // Window
};

struct CTcpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    CTcpInfo        _info;          // CTcpInfo
    WORD            _wChecksum;     // Checksum
    WORD            _wUrgent;       // Urgent pointer
};

#include <poppack.h>

#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

void    SgSetTcpHdrChecksum(CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cb1, BYTE * pb2, UINT cb2);

// ICMP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

class CIcmpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define ICMPTYPE_ECHO_REPLY                 0
    #define ICMPTYPE_DESTINATION_UNREACHABLE    3
    #define   ICMPCODE_NET_UNREACHABLE          0
    #define   ICMPCODE_HOST_UNREACHABLE         1
    #define   ICMPCODE_PROTOCOL_UNREACHABLE     2
    #define   ICMPCODE_PORT_UNREACHABLE         3
    #define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
    #define   ICMPCODE_SRCROUTE_FAILED          5
    #define   ICMPCODE_DEST_NET_UNKNOWN         6
    #define   ICMPCODE_DEST_HOST_UNKNOWN        7
    #define   ICMPCODE_SRC_HOST_ISOLATED        8
    #define   ICMPCODE_DEST_NET_PROHIBITED      9
    #define   ICMPCODE_DEST_HOST_PROHIBITED     10
    #define   ICMPCODE_NET_UNREACHABLE_TOS      11
    #define   ICMPCODE_HOST_UNREACHABLE_TOS     12
    #define ICMPTYPE_SOURCE_QUENCH              4
    #define ICMPTYPE_REDIRECT                   5
    #define   ICMPCODE_REDIRECT_NET             0
    #define   ICMPCODE_REDIRECT_HOST            1
    #define   ICMPCODE_REDIRECT_NET_TOS         2
    #define   ICMPCODE_REDIRECT_HOST_TOS        3
    #define ICMPTYPE_ECHO_REQUEST               8
    #define ICMPTYPE_ROUTER_ADVERTISEMENT       9
    #define ICMPTYPE_ROUTER_SOLICIATION         10
    #define ICMPTYPE_TIME_EXCEEDED              11
    #define   ICMPCODE_TTL_EXCEEDED             0
    #define   ICMPCODE_REASSEMBLY_TIMEOUT       1
    #define ICMPTYPE_PARAMETER_PROBLEM          12
    #define   ICMPCODE_PTR_INDICATES_ERROR      0
    #define   ICMPCODE_MISSING_REQD_OPTION      1
    #define ICMPTYPE_TIMESTAMP_REQUEST          13
    #define ICMPTYPE_TIMESTAMP_REPLY            14
    #define ICMPTYPE_INFORMATION_REQUEST        15
    #define ICMPTYPE_INFORMATION_REPLY          16
    #define ICMPTYPE_ADDRESSMASK_REQUEST        17
    #define ICMPTYPE_ADDRESSMASK_REPLY          18

    // Data ------------------------------------------------------------------------------

public:

    BYTE            _bType;         // One of ICMPTYPE_* above
    BYTE            _bCode;         // One of ICMPCODE_* above
    WORD            _wChecksum;     // Checksum
    DWORD           _dwData;        // Data (depends on _bType)

};

#include <poppack.h>

// ESP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CXspHdr : public CUdpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define XSP_TYPE_SEC            0           // Packet is in SecMsg format
    #define XSP_TYPE_TCP_0          1           // packet is in TCP format (0 byte ports)
    #define XSP_TYPE_TCP_1          2           // Packet is in TCP format (1 byte ports)
    #define XSP_TYPE_TCP_2          3           // Packet is in TCP format (2 byte ports)
    #define XSP_TYPE_UDP_0          4           // packet is in UDP format (0 byte ports)
    #define XSP_TYPE_UDP_1          5           // Packet is in UDP format (1 byte ports)
    #define XSP_TYPE_UDP_2          6           // Packet is in UDP format (2 byte ports)
    #define XSP_TYPE_VDP_0          7           // Packet is in VDP format (0 byte ports)
    #define XSP_TYPE_VDP_1          8           // Packet is in VDP format (1 byte ports)
    #define XSP_TYPE_VDP_2          9           // Packet is in VDP format (2 byte ports)
    #define XSP_TYPE_VDP_VO_0       10          // Packet is in VDP voice-only format (0 byte ports)
    #define XSP_TYPE_VDP_VO_1       11          // Packet is in VDP voice-only format (1 byte ports)
    #define XSP_TYPE_VDP_VO_2       12          // Packet is in VDP voice-only format (2 byte ports)
    #define XSP_TYPE_VDP_DO_0       13          // Packet is in VDP data-only format (0 byte ports)
    #define XSP_TYPE_VDP_DO_1       14          // Packet is in VDP data-only format (1 byte ports)
    #define XSP_TYPE_VDP_DO_2       15          // Packet is in VDP data-only format (2 byte ports)
    #define XSP_TYPE_MAX            15          // Highest packet type defined
    #define XSP_TYPE_MASK           0x0F        // Packet type mask
    #define XSP_DATPAD_MASK         0xE0        // Payload padding (8 byte blocks) in bytes
    #define XSP_DATPAD_SHIFT        5           // How far left to shift payload padding
    #define XSP_DATPADEX_MASK       0x10        // Payload padding (high bit of 16 byte blocks)
    #define XSP_DATPADEX_SHIFT      1           // How far left to shift payload padding

    #define XSP_SPI_MASK            0xFFFFFF00  // SPI occupies the top 24 bits
    #define XSP_FLAGS_MASK          0x000000FF  // Flags occupies the low 8 bits

#define XSP_DECODE_PADDING(flags)   (((flags & XSP_DATPAD_MASK) >> XSP_DATPAD_SHIFT) | \
                                     ((flags & XSP_DATPADEX_MASK) >> XSP_DATPADEX_SHIFT))

#define XSP_ENCODE_PADDING(pad)     (((pad << XSP_DATPAD_SHIFT) & XSP_DATPAD_MASK) | \
                                     ((pad << XSP_DATPADEX_SHIFT) & XSP_DATPADEX_MASK))

    // Data ------------------------------------------------------------------------------

    union {
        BYTE        _bFlags;                    // See XSP_* above
        DWORD       _dwSpiAndFlags;             // SPI and bFlags
    };
};

struct CXspTail
{
    WORD        _wSeqLo;                    // Low word of sequence number
    union {
        struct {
            WORD    _wSeqHi;                // High word of sequence number (not transmitted)
            DWORD   _dwSpiAndFlags;         // Copy of _dwSpiAndFlags from CXspHdr
            DWORD   _dwZero;                // Zero for making tail 4 byte multiple
        };
        BYTE    _abHash[10];                // HMAC-SHA digest
    };
};

#define IPPROTOCOL_VDP          254         // Used to temorarily mark packet during Z->I encode

struct CXspCtx
{

    // The following fields are used during packet authentication, encryption, and decryption.
    // Note that pointers might get shifted back to the nearest DWORD boundary (i.e. the
    // output from the encryption/decryption will blast up to three bytes before the given
    // locations).  If that happens the pointers will be adjusted after the encryption or
    // decryption is complete.  It is the callers responsibility to make sure that either
    // the pointers are already aligned, or that the area before those locations can be
    // overwritten.

    BYTE *          _pb1;                   // Pointer to 1st block of data
    UINT            _cb1;                   // Count of bytes in 1st block
    BYTE *          _pb2;                   // Pointer to 2nd block of data
    UINT            _cb2;                   // Count of bytes in 2nd block
    BYTE *          _pb3;                   // Pointer to 3rd block of data
    UINT            _cb3;                   // Count of bytes in 3rd block
    BYTE *          _pb4;                   // Pointer to 4th block of data
    UINT            _cb4;                   // Count of bytes in 4th block
    BYTE            _abIv[16];              // Initialization vector for crypto. Must match block size.

    // The following fields are used during packet encoding/decoding.  Note that the
    // amount of space that the CXspTail portion of the encoded packet actually uses could
    // be less than what is shown here, but we leave enough room for the maximum case of a
    // TCP packet with uncompressed src/dst ports.

    BYTE            _abHash[10];            // Additional scratch area and _abHash temporary
    BYTE            _abPadEx[6];            // Additional scratch area for padding and alignment
    BYTE            _abPad[16];             // Scratch area for padding out encrypted payload
    CTcpHdr         _TcpHdr;                // CTcpHdr (if encoding/decoding TCP)
    CXspTail        _XspTail;               // CXspTail appended to encoded packet
    WORD            _wAlign;                // Align _IpHdr to DWORD (CEnetHdr is 14 bytes)
    CEnetHdr        _EnetHdr;               // CEnetHdr for the encoded packet
    CIpHdr          _IpHdr;                 // CIpHdr for the encoded packet
    CXspHdr         _XspHdr;                // CXspHdr for the encoded packet

};

// Note: When sending a packet, _pb2 points to _XspTail and walks backward. It will
// potentially consume the ports (4 bytes), CTcpInfo (12 bytes) or the voice byte (1
// byte). This bumps into _TcpHdr, which is really used as more of a buffer. When
// receiving a packet, _TcpHdr actually points to the incoming TcpHdr OR UdpHeader.  Lots
// of overloads going on here.
C_ASSERT(sizeof(CTcpHdr) >= sizeof(CTcpInfo) + 2*sizeof(CIpPort));  // tcp worst case
C_ASSERT(offsetof(CXspCtx, _XspTail) >= offsetof(CXspCtx, _TcpHdr) + (sizeof(CTcpInfo) + 2*sizeof(CIpPort)));
C_ASSERT(offsetof(CXspCtx, _abPad) >= offsetof(CXspCtx, _abHash) + 16);
C_ASSERT(offsetof(CXspCtx, _TcpHdr) > offsetof(CXspCtx, _abPad));

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// CArpMsg
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct CArpMsg
{
    WORD            _wHrd;      // hardware address space
    WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
    BYTE            _bHln;      // hardware address length (6)
    BYTE            _bPln;      // protocol address length (4)
    WORD            _wOp;       // opcode
    CEnetAddr       _eaSender;  // sender's hardware address
    CIpAddr         _ipaSender; // sender's protocol address
    CEnetAddr       _eaTarget;  // target's hardware address
    CIpAddr         _ipaTarget; // target's protocol address
};

#include <poppack.h>

#define CBARPMSG    (sizeof(CEnetHdr) + sizeof(CArpMsg))

// ---------------------------------------------------------------------------------------
// CSiteInfo
// ---------------------------------------------------------------------------------------

struct CSiteInfo
{
    LIST_ENTRY      _le;                    // Link into g_leSiteInfo
    DWORD           _dwSiteId;              // Site identifier (derived from kerberos site name)
    DWORD           _dwVersion;             // Kerberos key version
    ULONGLONG       _qwTimeLastConfig;      // Time this key was last seen in the config data
    BYTE            _abKey[CBSITEKEY];      // Kerberos preshared key
};

#define SITEID_NULL         0

extern UINT         g_cSiteInfo;            // Number of CSiteInfo structures
extern LIST_ENTRY   g_leSiteInfo;           // List of CSiteInfo structures
extern CLock        g_lockSiteInfo;         // Synchronizes g_leSiteInfo

BOOL                SgSiteInfoInit();
BOOL                SgSiteInfoConfig(CCfgInfo* pci);
void                SgSiteInfoTerm();

CSiteInfo*          SgSiteInfoLookup(DWORD dwSiteId, DWORD dwVersion);
BOOL                SgSiteInfoLookupKey(DWORD dwSiteId, DWORD dwVersion, BYTE * pbKey);

// ---------------------------------------------------------------------------------------
// CSvcInfo
// ---------------------------------------------------------------------------------------

extern CLock        g_lockSvcInfo;          // Synchronizes all SvcInfo
extern CSvcInfo *   g_pSvcInfo;             // Vector of all CSvcInfo structures

struct CSvcInfo
{
    LIST_ENTRY      _leHash;                // Link into hash table bucket
    UINT            _iSvcInfo;              // Index of this entry in g_pSvcInfo
    DWORD           _dwSvcId;               // Service identifier
    char            _achName[64];           // Service name
};

BOOL                SgSvcInfoInit();
BOOL                SgSvcInfoConfig(CCfgInfo* pci);
void                SgSvcInfoTerm();

INLINE void         SgSvcInfoLock()         { g_lockSvcInfo.AcquireDpc(); }
INLINE void         SgSvcInfoUnlock()       { g_lockSvcInfo.ReleaseDpc(); }

CSvcInfo *          SgSvcInfoLookup(DWORD dwSvcId);
CSvcInfo *          SgSvcInfoLookup(const char* pchName);
ServiceMask         SgSvcInfoMask( UINT cDwordServiceIds, const DWORD* pDwordServiceIds, ServiceMask const & byteServicesMask);
ServiceMask         SgSvcInfoMask( DWORD dwSvcId );

// ---------------------------------------------------------------------------------------
// CBlockInfo
// ---------------------------------------------------------------------------------------

struct CBlockInfo
{
    LIST_ENTRY      _leHash;                // Link into hash table bucket
    LIST_ENTRY      _leFree;                // Link into g_leBlockInfoFree
    LIST_ENTRY      _leUsed;                // Link into g_leBlockInfoUsed

    PUID            _puid;                  // PUID of the blocked machine/user
    ULONGLONG       _qwBlockedTimeKeyEx;    // How long the connection is blocked
};

extern CLock        g_lockBlockInfo;        // Synchronizes CBlockInfo setup

BOOL                SgBlockInfoConfig(UINT cBlockInfo);
BOOL                SgBlockInfoInit();
void                SgBlockInfoTerm();

BOOL                SgBlockInfoBlockPuid(PUID * ppuid, ULONGLONG qwExtraBlockTime = 0);
void                SgBlockInfoUnblockPuid(PUID * ppuid);
BOOL                SgBlockInfoIsBlocked(PUID * ppuid, ULONGLONG *qwBlockTime);

void                SgConnectionBlockedMgmtCmd(CXomParamList * pxompl, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);

CBlockInfo *        SgBlockInfoAlloc(PUID * ppuid);
INLINE void         SgBlockInfoLock()       { g_lockBlockInfo.AcquireDpc(); }
INLINE void         SgBlockInfoUnlock()     { g_lockBlockInfo.ReleaseDpc(); }
INLINE CBlockInfo * SgBlockInfoFromFreeLink(LIST_ENTRY * ple) { return((CBlockInfo *)((BYTE *)ple - offsetof(CBlockInfo, _leFree))); }
INLINE CBlockInfo * SgBlockInfoFromUsedLink(LIST_ENTRY * ple) { return((CBlockInfo *)((BYTE *)ple - offsetof(CBlockInfo, _leUsed))); }

extern UINT         g_cBlockInfo;
extern UINT         g_cBlockInfoInUse;
extern ULONGLONG    g_qwKeyExBlockInterval; // Length of Time to block KeyEx for (in 100ns)
extern LIST_ENTRY   g_leBlockInfoFree;      // Queue of CBlockInfo structures no longer in use in LRU order
extern LIST_ENTRY   g_leBlockInfoUsed;      // Queue of CBlockInfo structures in use in LRU order

// ---------------------------------------------------------------------------------------
// CCliInfo
// ---------------------------------------------------------------------------------------

#define CLI_PACKET_QUEUE_MAX 100            // Maximum number of packets allowed in the Cli queue

struct CCliInfo
{
    LIST_ENTRY      _leHash;                // Link into hash table bucket
    LIST_ENTRY      _leLru;                 // Link into g_leCliInfoLru
    UINT            _iCliInfo;              // Index of this entry in g_pCliInfo
    DWORD           _dwSiteId;              // Id of the CSiteInfo referenced by this client
    PUID            _puid;                  // PUID of the client machine

    // Dispatcher members. Everything below _lock is memset to zero by SgCliInfoAlloc ----

    CLock           _lock;                  // Synchronizes access to dispatcher members
    CPacket *       _ppkt;                  // Current packet running with this CCliInfo
    CPacketQueue    _pq;                    // Queue of KeyEx packets waiting to execute with CCliInfo
    BOOL            _fSpiDeleted;           // TRUE after SgCliResetSpiInfo is called

    // Current SPI info. Can be modified by current ppkt ---------------------------------

    DWORD           _dwSpi;                 // Current CSpiInfo attached to this client
    LARGE_INTEGER   _liTimeAuth;            // Highest authenticator time seen
    UINT            _cReplay;               // Number of times authenticator has been replayed
    ULONGLONG       _qwTimeKeyEx;           // System time when last KeyEx packet received
};

extern CLock        g_lockCliInfo;          // Synchronizes CCliInfo setup

BOOL                SgCliInfoInit();
void                SgCliInfoTerm();

INLINE void         SgCliInfoLock()         { g_lockCliInfo.AcquireDpc(); }
INLINE void         SgCliInfoUnlock()       { g_lockCliInfo.ReleaseDpc(); }

void                SgCliInfoAttach(CPacket * ppkt, PFNCOMPLETE pfn, DWORD dwSiteId, PUID * ppuid);
void                SgCliInfoDetach(CPacket * ppkt);
void                SgCliInfoSetSpiInfo(CCliInfo * pCliInfo, CSpiInfo * pSpiInfo);
void                SgCliInfoResetSpiInfo(CCliInfo * pCliInfo, CSpiInfo * pSpiInfo);

CCliInfo *          SgCliInfoAlloc(DWORD dwSiteId, PUID * ppuid);
INLINE CCliInfo *   SgCliInfoFromLruLink(LIST_ENTRY * ple) { return((CCliInfo *)((BYTE *)ple - offsetof(CCliInfo, _leLru))); }

// ---------------------------------------------------------------------------------------
// CDstInfo
// ---------------------------------------------------------------------------------------

#define CONN_GROUP_DEFAULT              0
#define CONN_GROUP_CONNECTION_SERVER    1

extern CReaderWriterLock3 g_lockDstInfo;    // Synchronizes access to DstInfo

struct CDstTransInfo
{
    LIST_ENTRY      _leHash;                // Link into hash table bucket
#ifdef SG_FEATURE_ARP
    CArpInfo *      _pArpInfo;              // CArpInfo for this interface
#endif
    CIpAddr         _ipaZ;                  // IP address as mapped on this interface
    CIpPort         _ipportZ;               // Port as mapped on this interface
    CHAR            _szDnsNameZ[ MAX_DNSNAME_LEN ]; // Optional DNS name used to map to _ipaZ
};


struct CDstInfo
{
    CIpPort         _ipportI;           // Port as assigned on the I side
    ServiceMask     _svcMask;           // Mask of services this port provides
    BOOL            _fVdpOnly;          // TRUE if this destination is for voice-and-data only
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
    BOOL            _fArbitration;      // TRUE if this destination is for Arbitration
#endif
    DWORD           _dwConnGroupId;     // Which connection group to use?
    UINT            _cDstTransInfo;     // Count of elements in _aDstTransInfo
    CDstTransInfo   _aDstTransInfo[1];  // Vector of CDstTransInfo data (one per g_cTransInfo)
};

BOOL                SgDstInfoInit();
BOOL                SgDstInfoConfig(CCfgInfo* pci);
void                SgDstInfoTerm();

INLINE void         SgDstInfoReadLock()          { g_lockDstInfo.ReadLock(); }
INLINE void         SgDstInfoReadUnlock()        { g_lockDstInfo.ReadUnlock(); }
INLINE void         SgDstInfoWriteLock()         { g_lockDstInfo.WriteLock(); }
INLINE void         SgDstInfoWriteUnlock()       { g_lockDstInfo.WriteUnlock(); }

CDstInfo *          SgDstInfoLookup(CIpPort ipportI);
CDstInfo *          SgDstInfoLookup(CTransInfo * pTransInfo, CIpAddr ipaZ, CIpPort ipportZ);
void                SgDstInfoFree(CDstInfo * pDstInfo);

BOOL                SgDnsResolveToIP(const CHAR* szDnsName, CIpAddr & ipa);


// ---------------------------------------------------------------------------------------
// CNatInfo
// ---------------------------------------------------------------------------------------

struct CNatPort
{
    CIpPort         _ipportI;               // Original source port on the I side
    CIpPort         _ipportZ;               // Mapped source port on the Z side
    UINT64          _qwTick;                // Timer tick this port was last used
};

struct CNatInfo
{
    LIST_ENTRY      _leFree;                // Link into g_leNatInfoFree
    UINT            _iNatInfo;              // Index of this entry in g_ppNatInfo
    CTransInfo *    _pTransInfo;            // Pointer to CTransInfo that owns _ipaZ
    DWORD           _dwSpi;                 // SPI assigned to this entry
    CIpAddr         _ipaZ;                  // NAT'd IP address on the Z side
    UINT            _iBasePortZ;            // First Z port in this map
    CNatPort *      _pNatPort;              // Vector of all CNatPort sorted by ipportZ
    CNatPort **     _ppNatPortByI;          // Vector of pointers to CNatPort sorted by ipportI
};

extern BOOL         g_fPortTranslation;     // TRUE if source port translation is used
extern UINT         g_cPortsPerNatInfo;     // Number of source ports a CNatInfo can have mapped
extern UINT         g_cNatInfoPerIpAddr;    // Number of CNatInfo mapped by an IP address
extern UINT         g_cTotalIpa;            // Number of total IP addresses configured
extern UINT         g_cValidIpa;            // Number of valid IP addresses configured
extern UINT         g_cNatInfoValid;        // Number of valid CNatInfo structures
extern CNatInfo *   g_pNatInfo;             // Vector of all CNatInfo structures
extern DWORD        g_dwConnectionServerPortLimit; // Number of ports reserved for CONNECTION_SERVER traffic

BOOL                SgNatInfoConfig(UINT cSpiInfo, UINT cPortsPerNatInfo);
BOOL                SgNatInfoInit();
void                SgNatInfoTerm();

CIpPort             SgNatInfoLookupI(CNatInfo * pNatInfo, CIpPort ipportI, CDstInfo *pDstInfo);
CNatInfo *          SgNatInfoLookupZ(CTransInfo * pTransInfo, DWORD dwIpaDst, UINT iPortDst);
CNatInfo *          SgNatInfoAlloc(DWORD dwSpi);
void                SgNatInfoFree(CNatInfo * pNatInfo);

void                SgConnectionInfoMgmtCmd(CXomParamList * xompl, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);

// ---------------------------------------------------------------------------------------
// CUserInfo
// ---------------------------------------------------------------------------------------

struct CUserInfo
{
    ULONGLONG       _qwUserId;              // User id of the user
    CQVal           _aQVal[QVAL_COUNT];     // Vector of CQVal for this user
    DWORD           _dwQValModified;        // Bit vector of recently modified CQVal
    DWORD           _dwQValTransmit;        // Bit vector of CQVal being transmitted
    DWORD           _dwPState;              // Presence state
    XNKID           _xnkid;                 // Game session user is currently playing
    WORD            _cbData;                // Count of bytes of title data
    BYTE            _abData[256];           // Custom presence title data
    DWORD           _dwTitleId;             // Title-id user is currently playing
    BOOL            _fUpdated;              // TRUE while this record is being updated
};

// ---------------------------------------------------------------------------------------
// CQosProbe
// ---------------------------------------------------------------------------------------

struct CQosProbe
{
    BYTE            _abNonce[8];            // Nonce assigned by the QoS client
    WORD            _wQosIdx;               // Index assigned by the QoS client
    BYTE            _bPktIdx;               // Packet sequence number
    BYTE            _fWaiting;              // Waiting for second packet in pair
    LARGE_INTEGER   _liTscRecv;             // Performance counter when first packet in pair arrived
};

// ---------------------------------------------------------------------------------------
// SgOffload
// ---------------------------------------------------------------------------------------

void                SgOffloadEncodePacket(CPacket * ppkt);
void                SgOffloadDecodePacket(CPacket * ppkt);
void                SgOffloadBuildSpi(CPacket * ppkt);

// -------------------------------------------------------------------------------------
// SgClientStats
// -------------------------------------------------------------------------------------

// Number of timeslices to track packets
#define SGSTATS_REQUEST_COUNT_FRACTIONS 8

// Used in histogram calculations
#define HISTOGRAM_BUCKETS   10

// Packet types to track, need a sequential list. SVCBASE indicates the base index, just
// add the iSvcInfo value to it.
#define SGSTATS_PT_SECMSG                           0
#define SGSTATS_PT_UDP                              1
#define SGSTATS_PT_TCP                              2
#define SGSTATS_PT_VDP                              3
#define SGSTATS_PT_TCPSYN                           4
#define SGSTATS_PT_SVCBASE                          5
#define SGSTATS_PT_MAX                              (SGSTATS_PT_SVCBASE + CSVCINFOMAX)
#define SGSTATS_PT_UNKNOWN                          0xFFFFFFFF


// -------------------------------------------------------------------------------------
// enum StatsFormatType
//
// There are different ways to format stats for output and are meant for different
// consumers.  Event are meant for OPS for things that don't happen very often but logs
// are meant to be parsed at a later time and could possibly be happening on a regular basis
// -------------------------------------------------------------------------------------
typedef enum _StatsFormatType
{
    StatsFormatEvent = 0,
    StatsFormatLog = 1
} StatsFormatType;

// -------------------------------------------------------------------------------------
// Class CPacketHistoryRecord
//
// Tracks stats for a single packet type and single client. There will be one of these
// objects per each packet type per each client.
//
// -------------------------------------------------------------------------------------

class CPacketHistoryRecord
{
public:
    void            Increment();
    void            Refresh();
    DWORD           GetCount();
    void            GetStatsDetailed(CStr * pText,StatsFormatType statsFormatType);

    static void INLINE  SetHistoryTime(DWORD cHistoryInMs) { s_cTicksPerBucket = ((cHistoryInMs * TICKS_PER_SECOND) / SGSTATS_REQUEST_COUNT_FRACTIONS) / 1000; s_cHistoryInMs = cHistoryInMs;}
    static UINT64 INLINE TicksToFraction(UINT64 ticks)     { return ticks / s_cTicksPerBucket; }
    static DWORD INLINE CountToRate(DWORD count)           { return (count * 1000) / (s_cHistoryInMs); }

private:
    UINT64          _qwTickLastRequest;
    WORD            _aCountFractions[SGSTATS_REQUEST_COUNT_FRACTIONS];

    static DWORD    s_cTicksPerBucket;
    static DWORD    s_cHistoryInMs;
};


// -------------------------------------------------------------------------------------
// Class CClientStats
//
// Tracks all stats for a single client. All of these member functions should assume
// appropriate locks have been grabbed already by the caller. There will be one of these
// objects per each client.
//
// -------------------------------------------------------------------------------------
class CClientStats
{
public:
    void            Init(VOID *pBuffer, DWORD cPacketTypes);
    void            Reset();
    void            ProcessPacket(CPacket * ppkt, CDstInfo * pDstInfo);
    DWORD           GetCount(DWORD dwPktType);
    UINT64          Warn(DWORD dwPktType, DWORD dwLimit, DWORD dwPenaltyTimeInTicks);
    BOOL            IsInPenaltyBox();
    void            GetStatsDetailed(CStr * pText);
    void            LogStatsDetailed(ULONGLONG qwMachinePuid);

    static LPCSTR   PacketTypeToString(DWORD dwPktType);

private:
    void            ProcessPacketType(DWORD dwPktType, CPacket * ppkt);

    CPacketHistoryRecord * _aPacketHistory;     // Array of packet histories, 1 for each packet type
    DWORD                  _cPacketHistory;     // Number of elements
    UINT64                 _qwTickWarning;      // Time this client got warned
    DWORD                  _dwTicksPerPenalty;  // Time this client will spend in penalty box after getting warned
};

// -------------------------------------------------------------------------------------
// Struct CStatsRecord
//
// Tracks overall statistics for a single packet type. There will be one of these objects
// per each packet type. It's unfortunate we need to use floats, but since these values
// are only incrementally updated, using DWORDs produces huge rounding errors.
// -------------------------------------------------------------------------------------
struct CStatsRecord
{
    FLOAT           _Mean;
    DWORD           _Max;
    DWORD           _Min;
    FLOAT           _Variance;
    FLOAT           _StdDev;
    DWORD           _LimitWarning;
    DWORD           _LimitDisconnect;
    DWORD           _NumSamples;
};

// -------------------------------------------------------------------------------------
// Class CSgStats
//
// Tracks all global statistics for the whole SG. Expected to have exactly one of these
// per SG, but we could have more if we need multiple stats trackers, or something. There
// will be one of these objects per SG.
//
// -------------------------------------------------------------------------------------
class CSgStats
{
public:
    void            Init();
    void            Term();
    void            ClearStats();
    BOOL            Config(UINT cHistoryInMs,
                           UINT cWarningSigmaInterval,
                           UINT cDisconnectSigmaInterval,
                           UINT cConfidenceLimit,
                           UINT cSecondsPerPenalty);
    void            AttachClient(DWORD iClientIdx);
    void            ProcessPacket(DWORD iClientIdx, CPacket * ppkt, CDstInfo * pDstInfo);
    void            RefreshStats(DWORD iClientIdx);

    //
    // These are the externally accessible report gathering functions. They should only be
    // called if you do not currently hold the lock. If you have the lock, then you must
    // call the corresponding private function with the "WithLock" suffix.
    //
    BOOL            GetStatsOverall(CStr * pText);
    BOOL            GetStatsOverallPackets(CStr * pText, DWORD *pPktTypes, DWORD cPktTypes);
    BOOL            GetStatsHistogram(CStr * pText);
    BOOL            GetStatsClientByPuid(CStr * pText, ULONGLONG qwMachinePuid);
    BOOL            GetStatsClientBySpi(CStr * pText, DWORD dwSpiRecv);
    BOOL            GetStatsWarnings(CStr * pText);

    INLINE BOOL     IsEnabled()         { return _bClientStatsEnabled; }

private:

    void            ClearMemory();
    BOOL            ConfigMemory();
    BOOL            GetStatsForEventWithLock(CStr * pText, CSpiInfo * pSpiInfo, DWORD iPktType);
    BOOL            GetStatsForLogWithLock(CStr * pText, CSpiInfo * pSpiInfo, CClientStats * pClientStats, DWORD iPktType);

    //
    // These are the internal report gathering worker functions. They should only be
    // called if you already hold the lock.
    //
    BOOL            GetStatsOverallWithLock(CStr * pText);
    BOOL            GetStatsOverallPacketsWithLock(CStr * pText, DWORD *pPktTypes, DWORD cPktTypes);
    BOOL            GetStatsHistogramWithLock(CStr * pText);
    BOOL            GetStatsClientByPuidWithLock(CStr * pText, ULONGLONG qwMachinePuid);
    BOOL            GetStatsClientBySpiWithLock(CStr * pText, DWORD dwSpiRecv);
    BOOL            GetStatsWarningsWithLock(CStr * pText);
    BOOL            GetLogLine(CStr* pText,CStr* pLine,PDWORD pnLen);
    BOOL            AddLogLine(CStr* pText,DWORD dwSequence,PUID mpuid,PDWORD pnLen);

    //
    // Lock methods. IMPORTANT NOTE: Do not recursively acquire this lock.
    //

    INLINE BOOL     SafeReadLock()
    {
        _lockClientStats.ReadLock();
        if (!_bClientStatsEnabled)
        {
            _lockClientStats.ReadUnlock();
            return FALSE;
        }
        return TRUE;
    }
    INLINE void     ReadUnlock()        { _lockClientStats.ReadUnlock(); }
    INLINE void     WriteLock()         { _lockClientStats.WriteLock(); }
    INLINE void     WriteUnlock()       { _lockClientStats.WriteUnlock(); }

    //
    // Settings related to configuration and packet operation
    //
    volatile BOOL           _bClientStatsEnabled;       // Are we even turned on?
    UINT                    _cHistoryInMs;              // How long the moving average is
    UINT                    _cWarningSigmaInterval;     // Number of stdevs before we issue an event
    UINT                    _cDisconnectSigmaInterval;  // Number of stdevs before we disconnect a client
    UINT                    _cConfidenceLimitInClients; // How many clients we need before enforcing the warning/disconnect?
    UINT                    _cPacketTypes;              // Number of packet types we are tracking
    UINT                    _cTicksPerPenalty;          // Number of ticks to throttle warning messages (put in penalty box)
    UINT                    _cSvcInfoLast;              // Last count of services, so we can detect changes
    UINT                    _cSpiInfoLast;              // Last count of spis, so we can detect changes (not currently reconfigurable)

    //
    // Array of client stat trackers, 1 per client. These are the entry points to
    // per-packet processing.
    //
    CClientStats *          _pClientStats;
    UINT                    _cClientStats;

    //
    // Just memory pointers. Nothing more. These are accessed internally in the
    // CClientStat objects.
    //
    CPacketHistoryRecord *  _pPacketHistoryRecords;
    UINT                    _cPacketHistoryRecords;

    //
    // Handy objects
    //
    CReaderWriterLock3      _lockClientStats;          // Synchronizes access to client stats

    //
    // Information related to overall SG, 1 stats record per packet type. Represents all
    // clients.
    //
    CStatsRecord            _PacketStats[SGSTATS_PT_MAX];
};

//
// SgClientStats entry points from the rest of the SG
//
BOOL                SgClientStatsInit();
void                SgClientStatsTerm();
BOOL                SgClientStatsConfig(CCfgInfo * pci);
void                SgClientStatsAttach(CSpiInfo * pSpiInfo);
void                SgClientStatsProcessPacket(CPacket * ppkt, CDstInfo * pDstInfo);
void                SgClientStatsRefreshStats(CSpiInfo * pSpiInfo);
void                SgClientStatsMgmtCmd(CXomParamList * xompl, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);

// ---------------------------------------------------------------------------------------
// CSpiInfo
// ---------------------------------------------------------------------------------------

#define SPI_PACKET_QUEUE_MAX            5000    // Maximum number of packets allowed in the Spi queue
#define SESSION_KEY_NUMBER_OF_DIGESTS   5       // Number of 20 byte digests needed to generate all key material
#define SESSION_KEY_SHA_SIZE            16      // Number of bytes in the _abKeySha* array

#define KEYMATERIAL(pSpiInfo, field) (((pSpiInfo)->_cbKeyCrypt == 16 || (pSpiInfo)->_cbKeyCrypt == 0) ? (pSpiInfo)->_keyMaterialAes.field : (pSpiInfo)->_keyMaterialDes.field)

//
// ***** IMPORTANT NOTE ABOUT KEY MATERIAL *****
//
// It's absolutely critical that the CSpiKeyMaterial* structures are generated exactly the
// same in the client and server. It is also critical that the CSpiKeyMaterialDes
// structure does not change format, in order to maintain backwards-compatibility.
//

struct CSpiKeyMaterialDes
{
    BYTE            _abKeyShaRecv[SESSION_KEY_SHA_SIZE];    // Negotiated incoming SHA auth key
    BYTE            _abKeyCryptRecv[24];                    // Negotiated incoming crypt key
    BYTE            _abKeyShaXmit[SESSION_KEY_SHA_SIZE];    // Negotiated outgoing SHA auth key
    BYTE            _abKeyCryptXmit[24];                    // Negotiated outgoing crypt key
    BYTE            _abIvRecv[8];                           // Negotiated incoming starting IV
    BYTE            _abIvXmit[8];                           // Negotiated outgoing starting IV
    BYTE            _abKeyExFill[4];                        // Filler to make the negotiated area exactly 5 digests
};

struct CSpiKeyMaterialAes
{
    BYTE            _abKeyShaRecv[SESSION_KEY_SHA_SIZE];    // Negotiated incoming SHA auth key
    BYTE            _abKeyCryptRecv[16];                    // Negotiated incoming crypt key
    BYTE            _abKeyShaXmit[SESSION_KEY_SHA_SIZE];    // Negotiated outgoing SHA auth key
    BYTE            _abKeyCryptXmit[16];                    // Negotiated outgoing crypt key
    BYTE            _abIvRecv[16];                          // Negotiated incoming starting IV
    BYTE            _abIvXmit[16];                          // Negotiated outgoing starting IV
    BYTE            _abKeyExFill[4];                        // Filler to make the negotiated area exactly 5 digests
};

// Assert the encrypted part is actually a multiple of 16
C_ASSERT(((sizeof(CKeyExSgToXbResp) - offsetof(CKeyExSgToXbResp, _sgaddrInit)) % 16) == 0);

// Don't change the size of the key material for back-compat!
C_ASSERT(sizeof(CSpiKeyMaterialDes) == SESSION_KEY_NUMBER_OF_DIGESTS * 20);
C_ASSERT(sizeof(CSpiKeyMaterialAes) == SESSION_KEY_NUMBER_OF_DIGESTS * 20);


struct CSpiInfo
{
    LIST_ENTRY      _leFree;                // Link into g_leSpiInfoFree
    CLock           _lock;                  // Synchronizes _ppkt and _pq

    // SgSpiInfoAlloc will zero everything below this point ------------------------------

    CPacket *       _ppkt;                  // Current packet running with this CSpiInfo
    CPacketQueue    _pq;                    // Queue of packets waiting to execute with CSpiInfo

    // Some BOOLs condensed down to a single bit to save space. Add future ones here!
    BOOL            _fDeleted        : 1;   // TRUE after first call to SgSpiInfoFree
    BOOL            _fCs             : 1;   // TRUE if providing connection services to client
    BOOL            _fSgToXbPulse    : 1;   // TRUE if SgToXb pulse should be sent even if traffic is flowing
    BOOL            _fLuaFilterKeyEx : 1;   // TRUE if LUA filter has been run at key exchange time already
    // 28 more bits up for grabs!

    CTransInfo *    _pTransInfo;            // Pointer to CTransInfo to the client
    CCliInfo *      _pCliInfo;              // Pointer to CCliInfo of this client
    PUID            _puid;                  // PUID of the machine account
    CNatInfo *      _pNatInfo;              // Pointer to CNatInfo assigned to this client
    CEnetAddr       _eaI;                   // Ethernet address of client
    CIpAddr         _ipaI;                  // IP address of client
    CIpPort         _ipportI;               // UDP port of client
    DWORD           _dwSpiRecv;             // SPI assigned by this side
    DWORD           _dwSpiXmit;             // SPI assigned by other side
    DWORD           _dwSpiOld;              // SPI previously assigned to this connection (reinit)
    DWORD           _dwSeqRecv;             // Base sequence of receive window
    DWORD           _dwSeqMask;             // Bit mask of sequence numbers received
    DWORD           _dwSeqXmit;             // Highest sequence number transmitted
    ServiceMask     _svcMask;               // Mask of services this client can access
    ServiceMask     _svcMaskOrig;           // Original (from ticket) mask of services
    UINT64          _qwTickKeyEx1;          // Timer tick when key-exchange response sent
    UINT64          _qwTickKeyEx2;          // Timer tick when key-exchange challenge received
    UINT64          _qwTickPulse;           // Timer tick when last SECMSG_TYPE_SGTOXB_PULSE_2 sent
    UINT64          _qwTickRecv;            // Timer tick when last packet received
    UINT64          _qwTickXmit;            // Timer tick when last packet transmitted
    UINT64          _qwTickWatchdog;        // Timer tick when last attached to a packet
    UINT64          _qwTickNatDetect;       // Timer tick when last Nat detect request occurred
    UINT64          _qwTickTicketStart;     // Timer tick when last ticket change occured
    UINT64          _qwTickTicketEnd;       // Timer tick when ticket is no longer valid
    UINT64          _qwTickChalAsync;       // Timer tick for the next async challenge event
    DWORD           _dwChalAsyncState;      // Current Challenge Engine State
    DWORD           _dwLastTitleId;         // Title the user was previously in
    WORD            _wVersionInit;          // Version of the initiator
    WORD            _wFlagsInit;            // Flags of the initiator
    BYTE            _abKeyHmac[16];         // Session key of the initiator
    BYTE            _abNonceInit[8];        // Nonce of the initiator
    BYTE            _abNonceResp[8];        // Nonce of the responder
    BYTE            _abDhGX[CBDHG1];        // Diffie-hellman g^X of the initiator
    BYTE            _abDhGY[CBDHG1];        // Diffie-hellman g^Y of the responder

    union
    {
        CSpiKeyMaterialDes _keyMaterialDes;
        CSpiKeyMaterialAes _keyMaterialAes;
    };

    UINT            _cbKeyCrypt;            // Size of negotiated crypt key
    BYTE            _abKeyTblShaRecv[CBHT]; // Precomputed incoming HMAC-SHA key table
    BYTE            _abKeyTblShaXmit[CBHT]; // Precomputed outgoing HMAC-SHA key table
    BYTE            _abKeyTblCryptRecv[CBDT]; // Precomputed incoming key table
    BYTE            _abKeyTblCryptXmit[CBDT]; // Precomputed outgoing key table
    CAuthData4      _AuthData;              // Kerberos auth-data from ticket, possibly converted. Primary version.
#ifdef SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
    CAuthData3      _AuthDataV3;            // Kerberos auth-data from ticket, possibly converted. Shadow version.
#endif
    CUserInfo       _aUserInfo[4];          // Vector of CUserInfo for connection services
    DWORD           _dwSeqSgToXb;           // Sequence number of latest SgToXb pulse containing CQVal changes
    DWORD           _dwSeqXbToSg;           // Sequence number to acknowledge in next SgToXb pulse
    DWORD           _dwSeqXbToSgHigh;       // Highest sequence number of any SgToXb pulse message (detect packet reordering)
    UINT            _iQosProbe;             // Next slot to use in _aQosProbe vector
    CQosProbe       _aQosProbe[8];          // Vector of CQosProbe structures
    DWORD           _dwChallengeNonce;      // Nonce for the current challenge
    ULONGLONG       _qwTimeInit;            // System time at which this SPI was initialized

    DWORD           _dwSpiFlags     : 8;    // See SPIFLAG_*
    DWORD           _dwDeleteReason : 8;    // see SPIDEL_*
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
    DWORD            _ipportLastArbitration : 16; // The last port an Arbitration request arrived on for this user
#endif
#ifdef SG_FEATURE_LSP
    XNKID           _xnkid;                 // XNKID of the initiator
    BYTE            _abKeyShaKeyEx[16];     // HMAC-SHA key used during keyex
#endif

    // ******** LUA Challenge Response Parameters ********
    DWORD           _dwLuaChalCodeId;        // The LUA code challenge selected
    DWORD           _dwLuaChalCodeParamId;   // The LUA code challenge param selected
    DWORD           _dwLuaChalState;         // State of the LUA Challenge System
    DWORD           _dwLuaChalSendTicks;     // Ticks for the Send Interval
    DWORD           _dwLuaChalResendTicks;   // Ticks for the Resend Interval
    DWORD           _dwLuaChalTimeoutTicks;  // TIcks for the Timeout Interval

};

BOOL                SgSpiInfoInit();
BOOL                SgSpiInfoConfig(CCfgInfo* pci);
void                SgSpiInfoTerm();

CSpiInfo *          SgSpiInfoAllocSpiOnly();
void                SgSpiInfoAlloc(CPacket * ppkt, PFNCOMPLETE pfn, DWORD dwSpiOld = 0);
void                SgSpiInfoFree(CSpiInfo * pSpiInfo, DWORD dwReason);
void                SgSpiInfoKick(CSpiInfo * pSpiInfo, DWORD dwReason, DWORD dwDelReason);
void                SgSpiInfoAttach(CPacket * ppkt, PFNCOMPLETE pfn, DWORD dwSpi);
void                SgSpiInfoDetach(CPacket * ppkt);
void                SgSpiInfoTimer();
void                SgSpiInfoToSgAddr(CSpiInfo * pSpiInfo, SGADDR * psgaddr);
BOOL                SgSpiInfoMatchesSgAddr(CSpiInfo * pSpiInfo, SGADDR * psgaddr);

extern UINT         g_cXbToSgTimeoutInSeconds;
extern UINT         g_cXbToSgPulseTimeoutInSeconds;
extern CSpiInfo *   g_pSpiInfo;
extern UINT         g_cSpiInfo;
extern CSpiInfo *   g_pSpiInfoLast;                     // Pointer to last CSpiInfo structure in use

#define SPIFLAG_BLOCK 0x00000001                        // Block current SPI

// ---------------------------------------------------------------------------------------
// CKeyExCtx
// ---------------------------------------------------------------------------------------

struct CKeyExCtx
{
    CKeyExHdr *             _pKeyExApReq;           // CKeyExHdr for AP request (Kerb or NULL)
    CKeyExHdr *             _pKeyExDhGX;            // CKeyExHdr for g^X

    union
    {
        CKeyExSgToXbResp        _KeyExRespSg;       // CKeyExSgToXbResp for response (SG style)
#ifdef SG_FEATURE_LSP
        CKeyExTsToXbResp        _KeyExRespTs;       // CKeyExTsToXbResp for response (TS style)
#endif
    };

    CKeyExHdr               _KeyExDhGY;             // CKeyExHdr for diffie-hellman g^Y
    BYTE                    _abDhGY[CBDHG1];        // diffie-hellman g^Y
    CKeyExSgToXbChal        _KeyExSgToXbChal;       // CKeyExSgToXbChal for response
    BYTE                    _abChal[CBCHALCODE];    // Code bytes of the challenge
    struct {
        CAuthData4          _AuthData;              // Kerberos auth-data from ticket
        BYTE                _abDhY[CBDHG1];         // diffie-hellman Y
        BYTE                _abDhGXY[CBDHG1];       // diffie-hellman g^XY
        DWORD               _dwSiteId;              // SiteId from ticket
        PUID                _puid;                  // PUID of the client from ticket
        BYTE                _abKey[16];             // Session key from ticket
        BYTE                _abSha[20];             // Authenticator SHA hash from ticket
        LARGE_INTEGER       _liTime;                // Authenticator time
        DWORD               _dwUsec;                // Authenticator usec
        LARGE_INTEGER       _liEndTime;             // Ticket end time
        DWORD               _dwLifetimeInSeconds;   // Amount of ticket lifetime left (in seconds)
    };
    union {
        CKeyExKerbApRep     _KerbApRep;             // Kerberos AP reply
        CKeyExNullApRep     _NullApRep;             // NULL AP reply (insecure; test only)
    };
};

BOOL                SgCrackKerbApReq(CPacket * ppkt, BYTE * pb, UINT cb);
BOOL                SgBuildKerbApRep(CPacket * ppkt);
BOOL                SgCrackNullApReq(CPacket * ppkt);
BOOL                SgBuildNullApRep(CPacket * ppkt);
void                SgConvertAuthData4ToAuthData3( const CAuthData4* pOldAuthData, CAuthData3* pNewAuthData );

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

class CPacket
{
    // Definitions -----------------------------------------------------------------------

    #define CBCTX_SKIP_IXMIT        (sizeof(CXspCtx))
    #define CBCTX_SKIP_SECMSG       (CBCTX_SKIP_IXMIT+sizeof(CEnetHdr)+sizeof(CIpHdr)+sizeof(DWORD))
    #define CBCTX_MAX_SIZE          max(max(max(sizeof(CXspCtx), sizeof(CKeyExCtx)), CBARPMSG), CBSGSPIREPMSG)

    // Since the ethernet header is only 14 bytes, this will throw off the alignment of the whole
    // rest of the packet.  Pad before the ethernet header a bit to prevent this.  Since we're being
    // careful, I figure we should explicitly call out our memory needs to the compiler.
    #define ETH_HEADER_ALIGN        (sizeof(WORD))
    #define BUFFER_ALIGNMENT        0x04
    #define ALIGNED_BUFFER          __declspec(align(BUFFER_ALIGNMENT)) BYTE

    // Packet priority should correspond to WorkItemPriority in CThreadPool (cu_tpool.h).
    //
    // Low: never wake an idle worker thread to process this, let someone else grab it
    // later.
    //
    // Normal: sometimes wake an idle thread depending on thread affinity heuristic.
    //
    // High: always wake an idle thread to process this immediately
    //
    // This may get extended in the future to boost thread priorities, but it doesn't do
    // that right now.

    #define PACKET_PRIORITY_NORMAL  0  // Ordering is weird because I want 0 to be the default
    #define PACKET_PRIORITY_LOW     1
    #define PACKET_PRIORITY_HIGH    2

    // Member Functions ------------------------------------------------------------------

public:

    INLINE CPacket *    GetNextPkt()                { return(_ppktNext); }

    void                Reset();
    void                Complete();
    void                CompletePush(PFNCOMPLETE pfn);
    char *              Str() const;

    // Data ------------------------------------------------------------------------------

public:

    union
    {
        CPacket *           _ppktNext;          // Next packet in packet queue
        SLIST_ENTRY         _ppktNextSl;        // Next packet in a S-list
    };

    CTransInfo *        _pTransInfoRecv;    // Pointer to CTransInfo that received packet
    void *              _pvTransRecv;       // Private to packet transport that received packet
    CTransInfo *        _pTransInfoXmit;    // Pointer to CTransInfo that transmits packet
    void *              _pvTransXmit;       // Private to packet transport that transmits packet
    CSpiInfo *          _pSpiInfo;          // Pointer to CSpiInfo during processing
    CCliInfo *          _pCliInfo;          // Pointer to CCliInfo during key exchange
    BOOL                _fOffloadSuccess;   // status of the last offload operation
    UINT                _cpfn;              // Number of completion functions pushed
    UINT                _cpb;               // Number of data buffers in use
    UINT                _priority;          // See PACKET_PRIORITY_* above

    // Members below this point are NOT zero initialized ---------------------------------

    DWORD               _dwPktNum;          // Serial number of packet for tracing
    BYTE *              _pb;                // Scanning byte pointer during processing
    UINT                _cb;                // Scanning byte count during processing
    CEnetHdr *          _pEnetHdr;          // Pointer to CEnetHdr in the packet buffers
    CIpHdr *            _pIpHdr;            // Pointer to CIpHdr in the packet buffers
    CUdpHdr *           _pUdpHdr;           // Pointer to CUdpHdr in the packet buffers
    CTcpHdr *           _pTcpHdr;           // Pointer to CTcpHdr in the packet buffers
    CXspHdr *           _pXspHdr;           // Pointer to CXspHdr in the packet buffers
    CXspTail *          _pXspTail;          // Pointer to CXspTail in the packet buffers
    DWORD               _dwSeq;             // Inferred dwSeq from CXspTail
    UINT                _cbDat;             // Size of encrypted payload
    UINT                _cbPad;             // Size of encrypted payload padding (included in _cbDat)
    UINT                _cbTov;             // Overlap between _cbPad and _cbTex
    UINT                _cbBpp;             // Number of bytes per port
    UINT                _cbTex;             // Size of ports and CTcpInfo
    UINT                _cbTvo;             // Size of unencrypted voice (including bDatLen byte, if any)
    PFNCOMPLETE         _apfn[8];           // Vector of completion functions
    BYTE *              _apb[6];            // Vector of data buffer pointers
    UINT                _acb[6];            // Vector of data buffer sizes
    BYTE                _abCtx[CBCTX_MAX_SIZE];
    ALIGNED_BUFFER      _abTransRecv[ CBFRAMEMAX + ETH_HEADER_ALIGN ]; // Receive buffer for the transport layer
#ifdef SG_BUILD_ONEBOX
    // Only used for raw sockets (Xblobs), not RawNic
    BYTE                _abTransSend[ CBFRAMEMAX ]; // Send buffer for the transport layer
#endif
};

BOOL         SgPacketInit();
BOOL         SgPacketConfig(CCfgInfo* pci);
CPacket*     SgPacketAlloc();
void         SgPacketTerm();

// ---------------------------------------------------------------------------------------
// Random Number Generation
// ---------------------------------------------------------------------------------------

BOOL                SgRandInit();
BOOL                SgRandConfig(CCfgInfo* pci);
BOOL                SgRand(BYTE * pb, UINT cb);
DWORD               SgQuickRand(DWORD dwMin, DWORD dwMax);
void                SgRandTerm();

#ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// Filters
// ---------------------------------------------------------------------------------------

struct CScriptSpiCtx
{
    CSpiInfo*       _pSpiInfo;
};

void SgApplyFilterScriptWithSpi(CSpiInfo* pSpiInfo);
void SgApplyFilterScriptAll();

#endif // #ifdef SG_FEATURE_LUA

#ifdef SG_FEATURE_LSP

// ---------------------------------------------------------------------------------------
// LSP
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

#define MAX_SITE_KEYS 3
#define SALT_LSP_XNKID HTONL('XKID')
#define SALT_LSP_XNKEY HTONL('XKEY')

struct LspKeyInfo
{
    DWORD         _dwVersion;
    BYTE          _abKey[16];
};

struct LspSiteInfo
{
    LARGE_INTEGER _liTime;
    DWORD         _cKeys;
    LspKeyInfo    _aKeys[MAX_SITE_KEYS];
};

#include <poppack.h>

struct CLspProxy
{
    CIpAddr _ipa;
    CIpPort _ipport;
    DWORD   _dwSiteId;
};

struct CKeyReg
{
    XNKID      _xnkid;
    XNKEY      _xnkey;
    BYTE       _abKeySha[16];                       // key exchange SHA auth key
};

struct CTitleInfo
{
    DWORD       _dwTitleId;                         // A title ID supported by this SG
    CHAR        _szUserData[CCHMAXUSERDATA];        // User specified string we'll put into query
};

BOOL                SgLspInit();
BOOL                SgLspConfig(CCfgInfo* pci);
void                SgLspTerm();

void                SgLspTimer(CTimer * pTimer);
BOOL                SgLspLookupQueryKey(XNKID * pxnkid, BYTE * pbkey);
void                SgLspLog(LPCSTR pszArea, LPCSTR pszFmt, ...);
void                SgLspLogFT(LPCSTR pszArea, FLOKEN& flowToken, LPCSTR pszFmt, ...);

#endif

// ---------------------------------------------------------------------------------------
// SgXmit
// ---------------------------------------------------------------------------------------

void                TransXmit(CPacket * ppkt);
void                SgXmitDirect(CPacket * ppkt);
void                SgXmit(CPacket * ppkt);

#ifdef SG_FEATURE_ARP
void                SgXmitWithArp(CPacket * ppkt, CArpInfo * pArpInfo);
#endif
void                SgIXmitWithSpi(CPacket * ppkt);
void                SgIXmitSecMsgWithSpi(CPacket * ppkt);
void                SgIXmitSecMsgSgToXbPulse(CSpiInfo * pSpiInfo, CPacket * ppktWithSpi);

#ifdef SG_FEATURE_LUA
void                SgIXmitSecMsgSgToXbChallenge(CSpiInfo * pSpiInfo, CPacket *ppkWithSpi);
void                SgIXmitSecMsgSgToXbChallengeRespAck(CSpiInfo * pSpiInfo, CPacket *ppkWithSpi, DWORD dwChallengeNonce);
#endif // #ifdef SG_FEATURE_LUA

void                SgZXmitSgMsgForward(CPacket * ppkt, CTransInfo * pTransInfoXmit, SGADDR * psgaddr, void * pvMsg, UINT cbMsg);
void                SgZXmitSgMsgForward2(CPacket* ppkt, CTransInfo* pTransInfoXmit, SGADDR* psgaSender, SGADDR* psgaTarget, void* pvMsg, UINT cbMsg);

void                SgIcmpXmit(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// SgRecv
// ---------------------------------------------------------------------------------------

void                SgCalcIvAtSeq(const BYTE * pbIvInit, DWORD dwSeq, BYTE * pbIvCalc);
BOOL                SgRecvInit();
BOOL                SgRecvConfig(CCfgInfo* pci);
void                SgRecv(CPacket * ppkt);
INLINE void         SgRecvTerm()                        {}
void                SgKeyExPermute(CAuthData4* pAuthData, DWORD dwPermuteMask);

extern UINT         g_iIpHdrTtl;                              // IP header Ttl
extern UINT         g_iIpHdrTos;                              // IP header Tos
extern UINT         g_iKeyExMinRetryInterval;                 // In 100 nanosecond units
extern UINT         g_cbKeyExXbToSgInitMin;                   // Minimum size of KeyExXbToSgInit payload
extern BOOL         g_fKeyExDontSendIcmp;                     // TRUE to prevent sending ICMP before KeyExResp
extern DWORD        g_ipaKeyExIcmpVip;                        // IP address to spoof when sending ICMP before KeyExResp
extern BOOL         g_fForceReplay;                           // TRUE to allow key exchange replay
extern BOOL         g_fForceReplayValue;                      // TRUE to force replay check to succeed
extern UINT         g_cbKeyDes;                               // DES encryption key length (decide between DES or DES3, but not AES)
extern DWORD        g_dwAesMinClientVersionXbox360;           // Minimum client version for Xbox360 that supports AES and NULL ciphers
extern DWORD        g_dwAesMinClientVersionPc;                // Minimum client version for PC that supports AES and NULL ciphers
extern BOOL         g_fAesProtocolEnabled;                    // Is the AES/NULL protocol enabled for clients that support it?

#if DBG
extern BOOL         g_fDumpFirstKeyExResp;                     // TRUE to force client to retransmit KeyEx
#endif

// ---------------------------------------------------------------------------------------
// SgSecMsg
// ---------------------------------------------------------------------------------------

void                SgIRecvSecMsgWithSpi(CPacket * ppkt);
void                SgIRecvSecMsgForwardWithSpi(CPacket * ppkt);
void                SgIRecvSecMsgForward2WithSpi(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// SgKeyEx
// ---------------------------------------------------------------------------------------

void                SgIRecvKeyEx(CPacket * ppkt);
void                SgIRecvKeyExWithCli(CPacket * ppkt);
void                SgIRecvKeyExBuildSpi(CPacket * ppkt);
void                SgIRecvKeyExWithSpi(CPacket * ppkt);
void                SgIXmitKeyExWithSpi(CPacket * ppkt);

#ifdef SG_FEATURE_LSP
void                SgIRecvTsKeyEx(CPacket * ppkt);
void                SgIRecvTsKeyExWithCli(CPacket * ppkt);
void                SgIRecvTsKeyExWithSpi(CPacket * ppkt);
void                SgIRecvTsKeyExBuildSpi(CPacket * ppkt);
void                SgIXmitTsKeyExWithSpi(CPacket * ppkt);
#endif //SG_FEATURE_LSP

BOOL                SgKeyExVerify(CKeyExHdr * pKeyExHdr, UINT cb);
CKeyExHdr         * SgKeyExLookup(CKeyExHdr * pKeyExHdr, UINT cb, WORD wType);
BOOL                SgKeyExDhGXIsInvalid(const BYTE * pbDhGX);

// ---------------------------------------------------------------------------------------
// SgXmit
// ---------------------------------------------------------------------------------------

void                SgZXmitRst(CPacket * ppkt);
void                SgZXmitSgMsgRep(CPacket * ppkt, CSgMsgHdr * pSgMsgHdr, UINT cbSgMsg);


// ---------------------------------------------------------------------------------------
// SgIndicate
// ---------------------------------------------------------------------------------------

void                SgIndicateSgSvcClient(CSpiInfo * pSpiInfo, WORD wType,
                                          CLogChallenge * pLogChallenge,
                                          PVOID pv);

// ---------------------------------------------------------------------------------------
// SgDatacenter
// ---------------------------------------------------------------------------------------

BOOL                SgDatacenterInit();
BOOL                SgDatacenterConfig(CCfgInfo* pci);
void                SgDatacenterTerm();

extern BOOL g_fEnableConnectionServices;

// ---------------------------------------------------------------------------------------
// SgHash
// ---------------------------------------------------------------------------------------

INLINE BOOL         SgHashInit()                        { return(TRUE); }
BOOL                SgHashConfig(CCfgInfo* pci);
INLINE void         SgHashTerm()                        {}

// ---------------------------------------------------------------------------------------
// CDhInfo
// ---------------------------------------------------------------------------------------

struct CDhInfo
{
    BYTE    _abX[CBDHG1];
    BYTE    _abGX[CBDHG1];
};

BOOL                SgDhInfoInit();
BOOL                SgDhInfoConfig(CCfgInfo* pci);
void                SgDhInfoAssign(BYTE * pbX, BYTE * pbGX);
void                SgDhInfoTerm();

// ---------------------------------------------------------------------------------------
// Processor load balancing
// ---------------------------------------------------------------------------------------

BOOL    SgProcBalInit();
BOOL    SgProcBalConfig(CCfgInfo* pci);
void    SgProcBalTerm();
BOOL    SgProcBalBindHandle(HANDLE hFile, PFNIOCOMPLETED pCallback);
void    SgProcBalQueuePacket(CPacket * ppkt);
void    SgProcBalQueryCounters(CSgPerfData* pPerfData);

// ---------------------------------------------------------------------------------------
// Challenge/Response
// ---------------------------------------------------------------------------------------


#ifdef SG_FEATURE_LUA

extern BOOL g_fEnableChallengeResponse;

//
// Number of ticks of no inbound data/pulse (after key-ex confirmed) before
// disconnect
//
extern UINT g_cTicksPerSpiInfoTimeout;

//
// Number of ticks of no inbound data/pulse (right after key-ex) before
// disconnect
//
extern UINT g_cTicksPerSpiInfoKeyExTimeout;

//
// Number of ticks of no outbound data/pulse before SG should send
// SECMSG_TYPE_SGTOXBPULSE
//
extern UINT g_cTicksPerSpiInfoPulseTimeout;

//
// Number of ticks that a CSpiInfo can be attached before watchdog warns
//
extern UINT g_cTicksPerSpiInfoWatchdog;

//
// Number of ticks between challenges to the clients
//
extern UINT g_cTicksPerSpiInfoChalResp;

//
// Number of ticks between re-issuing the challenges to the client
//
extern UINT g_cTicksPerSpiInfoChalRespAck;

//
// Number of ticks after a challenge has been sent, before a timeout
//
extern UINT g_cTicksPerSpiInfoChalRespTimeout;

BOOL SgChalInit();
void SgChalTerm();
BOOL SgChalConfig(CCfgInfo* pci);

void SgChalCodeUpdateSpiInfo(CSpiInfo *pSpiInfo);
void SgChalDropped(CSpiInfo *pSpiInfo);
void SgChalProcessSyncResponse( CPacket * ppkt );
BOOL SgChalAssignSyncChallenge( CSpiInfo *pSpiInfo, CKeyExCtx *pKeyExCtx );
BOOL SgChalAssignAsyncChallenge(CSpiInfo * pSpiInfo, CSecMsgSgToXbChal * pSecMsgSgToXbChal);

#define SPI_LUA_CHAL_STATE_ENABLED          0x00000001
#define SPI_LUA_CHAL_STATE_KICK             0x00000002
#define SPI_LUA_CHAL_STATE_LOG              0x00000004
#define SPI_LUA_CHAL_STATE_ASYNC            0x00000008
#define SPI_LUA_CHAL_STATE_CUSTOM_SEND      0x00000010
#define SPI_LUA_CHAL_STATE_CUSTOM_RESEND    0x00000020
#define SPI_LUA_CHAL_STATE_CUSTOM_TIMEOUT   0x00000040
#define SPI_LUA_CHAL_STATE_BLOCK            0x00000080
#define SPI_LUA_CHAL_STATE_RESEND           0x00000100

// Legal values for CSpiInfo._dwChalAsyncState
#define SPI_CHAL_ASYNC_STATE_OFF            0
#define SPI_CHAL_ASYNC_STATE_IDLE           1
#define SPI_CHAL_ASYNC_STATE_WAIT_FOR_ACK   2
#define SPI_CHAL_ASYNC_STATE_WAIT_FOR_RESP  3
#define SPI_CHAL_ASYNC_STATE_MAX            3

//
// LUA related Challenge functions
//

void SgLuaChalAssign(CSpiInfo *pSpiInfo, BOOL bAsync = FALSE);
void SgLuaChalAnalyze(CSpiInfo *pSpiInfo, BYTE *pbBuffer, ULONG cbBuffer);
void SgLuaChalDropped(CSpiInfo *pSpiInfo);
BOOL SgLuaChalGetBinary(CSpiInfo* pSpiInfo, CBuffer* pCode, CBuffer* pParam);
void SgLuaChalWaitForAckTimeout(CSpiInfo *pSpiInfo);
void SgLuaChalWaitForRespTimeout(CSpiInfo *pSpiInfo);

BOOL SgLuaChalStateAsync(CSpiInfo *pSpiInfo);
BOOL SgLuaChalStateBlock(CSpiInfo *pSpiInfo);
BOOL SgLuaChalStateEnabled(CSpiInfo *pSpiInfo);
BOOL SgLuaChalStateKick(CSpiInfo *pSpiInfo);
BOOL SgLuaChalStateLog(CSpiInfo *pSpiInfo);
BOOL SgLuaChalStateResend(CSpiInfo *pSpiInfo);
void SgLuaChalStateClear(CSpiInfo *pSpiInfo);

void SgLuaChalSetAsyncStateActive(CSpiInfo *pSpiInfo );
void SgLuaChalSetAsyncStateIdle(CSpiInfo *pSpiInfo );
void SgLuaChalSetAsyncStateWaitForAck(CSpiInfo *pSpiInfo );
void SgLuaChalSetAsyncStateWaitForResp(CSpiInfo *pSpiInfo );
void SgLuaChalSetAsyncStateOff(CSpiInfo *pSpiInfo);

void SgLuaChalStateSetAsync(CSpiInfo *pSpiInfo, BOOL bEnable);
void SgLuaChalStateSetBlock(CSpiInfo *pSpiInfo, BOOL bEnable);
void SgLuaChalStateSetEnabled(CSpiInfo *pSpiInfo, BOOL bEnable);
void SgLuaChalStateSetKick(CSpiInfo *pSpiInfo, BOOL bEnable);
void SgLuaChalStateSetLog(CSpiInfo *pSpiInfo, BOOL bEnable);
void SgLuaChalStateSetResend(CSpiInfo *pSpiInfo, BOOL bEnable);

void SgLuaChalStateSetCustomSendTicks(CSpiInfo *pSpiInfo, UINT64 qwTicks);
void SgLuaChalStateSetCustomResendTicks(CSpiInfo *pSpiInfo, UINT64 qwTicks);
void SgLuaChalStateSetCustomTimeoutTicks(CSpiInfo *pSpiInfo, UINT64 qwTicks);

#endif

// ---------------------------------------------------------------------------------------
// Init/Config/Term
// ---------------------------------------------------------------------------------------

BOOL                TransInit();
void                TransStop();
void                TransTerm();
BOOL                TransInstall(OUT BOOL *pfRebootRequired);
BOOL                TransUninstall(OUT BOOL *pfRebootRequired);

BOOL SgInstall();
BOOL SgUninstall();

// ---------------------------------------------------------------------------------------
// UM/KM Includes
// ---------------------------------------------------------------------------------------

#ifndef SG_FEATURE_LSP
#define CKeyExXbToTsInit InvalidKeyExType
#define CKeyExTsToXbResp InvalidKeyExType
#endif

// ---------------------------------------------------------------------------------------
// Time
// ---------------------------------------------------------------------------------------

typedef short CSHORT;

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;

typedef TIME_FIELDS *PTIME_FIELDS;

ULONGLONG           SgGetSystemTime();
char *              SgTimeToStr(UINT64 qwTime);
char *              SgTickToStr(UINT64 qwTickTime);
DWORD               SgTickElapsedInSeconds( UINT64 qwTick );
DWORD               SgTickElapsedInSeconds( UINT64 qwTick, UINT64 qwTickNow );
BOOLEAN             SgTimeFieldsToTime(PTIME_FIELDS ptfTime, PLARGE_INTEGER pliTime);
void                SgTimeToTimeFields(PLARGE_INTEGER pliTime, PTIME_FIELDS ptfTime);

// ---------------------------------------------------------------------------------------
// Performance Data
// ---------------------------------------------------------------------------------------

extern CSgPerfData g_Perfdata;

BOOL            SgPerfdataInit();
BOOL            SgPerfdataConfig(CCfgInfo* pci);
void            SgPerfdataTerm();

#define         SgPerfdataInc(ctr, addend)          (g_Perfdata._ull##ctr += addend)
#define         SgPerfdataDec(ctr, addend)          (g_Perfdata._ull##ctr -= addend)
#define         SgPerfdataSet(ctr, addend)          (g_Perfdata._ull##ctr = addend)
#define         SgPerfdataGet(ctr)                  (g_Perfdata._ull##ctr)

#define         SgPerfdataInterlockedInc(ctr)       InterlockedIncrement64((PLONGLONG)&g_Perfdata._ull##ctr)
#define         SgPerfdataInterlockedDec(ctr)       InterlockedDecrement64((PLONGLONG)&g_Perfdata._ull##ctr)
#define         SgPerfdataInterlockedAdd(ctr, add)  InterlockedExchangeAdd64((PLONGLONG)&g_Perfdata._ull##ctr, (LONGLONG)add)

#define         SgPerfdataPerProcInc(ctr, addend)                                       \
do                                                                                      \
{                                                                                       \
    if (g_pPerProcData != NULL)                                                         \
    {                                                                                   \
        g_pPerProcData[0]._ull##ctr += (addend);    \
    }                                                                                   \
} while (0)

// ---------------------------------------------------------------------------------------
// Scratch memory management routines
// ---------------------------------------------------------------------------------------

//
// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

#define SCRATCH_MEMORY_ALIGNMENT 4

#define SCRATCH_MEMORY_STACK_SIZE 8

class CScratchMemoryAllocator
{
private:
    PBYTE m_pbStart;
    PBYTE m_pbEnd;
    PBYTE m_pbCurrent;
    PBYTE m_pbTempBuffer;
    DWORD m_dwTempBufferSize;
    DWORD m_dwStackPointer;
    PBYTE m_Stack[SCRATCH_MEMORY_STACK_SIZE];
    PBYTE m_pbPeakUsage;

public:
    inline CScratchMemoryAllocator()
    {
        m_pbStart = NULL;
    }

    inline PVOID ScratchMemoryInitialize( IN PVOID ptr, IN size_t size, IN PVOID tempBuffer, IN size_t tempBufferSize )
    {
        AssertSz(m_pbStart == NULL,"Scratch Memory already in use");
        m_pbStart = (PBYTE)ptr;
        m_dwTempBufferSize = 0;
        AssertSz(m_pbStart != NULL,"Scratch Memory Initialize failed");
        if (m_pbStart != NULL)
        {
            m_pbCurrent = m_pbStart;
            m_pbEnd = m_pbStart + size;
            m_dwStackPointer = 0;
            RtlZeroMemory( m_pbStart, size );
            m_pbTempBuffer = (PBYTE)tempBuffer;
            if (m_pbTempBuffer != NULL)
            {
                Assert( tempBufferSize > 0 );
                m_dwTempBufferSize = tempBufferSize;
            }
            else
            {
                Assert( tempBufferSize == 0 );
            }
            m_pbPeakUsage = m_pbStart;
        }
        return m_pbStart;
    }

    inline ~CScratchMemoryAllocator()
    {
        TraceSz(ScratchMemoryVerbose, "Destructing, peak %d out of %d used",
                m_pbPeakUsage - m_pbStart,
                m_pbEnd - m_pbStart);
    }

    inline PVOID TempBuffer()
    {
        return m_pbTempBuffer;
    }

    inline DWORD TempBufferSize()
    {
        return m_dwTempBufferSize;
    }

    inline PVOID Alloc( IN size_t BufferSize )
    {
        PBYTE CurrentPosition;
        Assert(m_pbStart != NULL);
        CurrentPosition = m_pbCurrent;

        size_t RoundedBufferSize = ROUND_UP_COUNT(BufferSize,SCRATCH_MEMORY_ALIGNMENT);

        if(RoundedBufferSize < BufferSize)
        {
            Assert(!"Integer overflow");
            return NULL;
        }

        BufferSize = RoundedBufferSize;

        m_pbCurrent += BufferSize;
        TraceSz(ScratchMemoryAlloc, "Alloc %d, now used %d out of %d", BufferSize,
                m_pbCurrent - m_pbStart,
                m_pbEnd - m_pbStart);
        AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
        if (m_pbCurrent > m_pbEnd)
        {
            m_pbCurrent = CurrentPosition;
            CurrentPosition = NULL;
        }
        if (m_pbPeakUsage < m_pbCurrent)
        {
            m_pbPeakUsage = m_pbCurrent;
        }
        return CurrentPosition;
    }

    inline PVOID ReAlloc( IN PVOID Buffer, IN size_t BufferSize )
    {
        PBYTE CurrentPosition;
        Assert(m_pbStart != NULL);
        CurrentPosition = m_pbCurrent;
        size_t RoundedBufferSize = ROUND_UP_COUNT(BufferSize,SCRATCH_MEMORY_ALIGNMENT);

        if(RoundedBufferSize < BufferSize)
        {
            Assert(!"Integer overflow");
            return NULL;
        }

        BufferSize = RoundedBufferSize;

        m_pbCurrent += BufferSize;
        TraceSz(ScratchMemoryAlloc, "ReAlloc %d, now used %d out of %d", BufferSize,
                m_pbCurrent - m_pbStart,
                m_pbEnd - m_pbStart);
        AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
        if (m_pbCurrent > m_pbEnd)
        {
            m_pbCurrent = CurrentPosition;
            CurrentPosition = NULL;
        }
        else
        {
            RtlCopyMemory( CurrentPosition, Buffer, BufferSize );
        }
        if (m_pbPeakUsage < m_pbCurrent)
        {
            m_pbPeakUsage = m_pbCurrent;
        }
        return CurrentPosition;
    }

    inline PVOID ImmediateReAlloc( IN PVOID Buffer, IN size_t OldBufferSize, IN size_t NewBufferSize )
    {
        Assert(m_pbStart != NULL);
        size_t RoundedOldBufferSize = ROUND_UP_COUNT(OldBufferSize,SCRATCH_MEMORY_ALIGNMENT);

        if(RoundedOldBufferSize < OldBufferSize)
        {
            Assert(!"Integer overflow");
            return NULL;
        }

        OldBufferSize = RoundedOldBufferSize;

        if ( m_pbCurrent == (PBYTE)Buffer + OldBufferSize )
        {
            //
            // Nothing else was allocated in between, we can do things better.
            //
            PBYTE CurrentPosition;
            CurrentPosition = m_pbCurrent;
            size_t RoundedNewBufferSize = ROUND_UP_COUNT(NewBufferSize,SCRATCH_MEMORY_ALIGNMENT);

            if(RoundedNewBufferSize < NewBufferSize)
            {
                Assert(!"Integer overflow");
                return NULL;
            }

            NewBufferSize = RoundedNewBufferSize;

            m_pbCurrent += (NewBufferSize - OldBufferSize);
            TraceSz(ScratchMemoryAlloc, "ImmediateReAlloc %d, now used %d out of %d", NewBufferSize,
                    m_pbCurrent - m_pbStart,
                    m_pbEnd - m_pbStart);
            AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
            if (m_pbCurrent > m_pbEnd)
            {
                m_pbCurrent = CurrentPosition;
                return NULL;
            }
            else
            {
                if (m_pbPeakUsage < m_pbCurrent)
                {
                    m_pbPeakUsage = m_pbCurrent;
                }
                return Buffer;
            }
        }
        else
        {
            return ReAlloc( Buffer, NewBufferSize );
        }
    }

    inline VOID Free( IN PVOID Buffer )
    {
        Assert(m_pbStart != NULL);
    }

    inline VOID Push()
    {
        Assert(m_pbStart != NULL);
        AssertSz(m_dwStackPointer < SCRATCH_MEMORY_STACK_SIZE,"Scratch Memory Stack Overflow");
        m_Stack[m_dwStackPointer++] = m_pbCurrent;
    }

    inline VOID Pop()
    {
        PVOID pTemp;
        Assert(m_pbStart != NULL);
        AssertSz(m_dwStackPointer != 0,"Scratch Memory Stack Underflow");
        pTemp = m_pbCurrent;
        m_pbCurrent = m_Stack[--m_dwStackPointer];
        Assert( m_pbCurrent <= pTemp);
        RtlZeroMemory( m_pbCurrent, (PBYTE)pTemp - m_pbCurrent );
    }
};

class CReleaseAllScratchMemoryUponDestruction
{
public:

    inline CReleaseAllScratchMemoryUponDestruction( CScratchMemoryAllocator* pScratchMemoryAllocator )
    {
        m_pScratchMemoryAllocator = pScratchMemoryAllocator;
        m_pbPreservedMemory = NULL;
        //
        // Anything allocated after the constructed will be released later
        //
        m_pScratchMemoryAllocator->Push();
    }

    inline CScratchMemoryAllocator* ScratchMemoryAllocator()
    {
        return m_pScratchMemoryAllocator;
    }

    inline PVOID PreserveThisMemory( void** ppMemoryPointer, DWORD dwPreservedMemoryLength )
    {
        void* pbUseThisMemory = NULL;

        Assert( dwPreservedMemoryLength != 0 );
        Assert( ppMemoryPointer != NULL );
        Assert( *ppMemoryPointer != NULL );
        if (m_pScratchMemoryAllocator->TempBufferSize() >= dwPreservedMemoryLength)
        {
            pbUseThisMemory = m_pScratchMemoryAllocator->TempBuffer();
        }
        else
        {
            AssertSz(0,"Had Temp Buffer, but not big enough");
        }
        if (pbUseThisMemory != NULL)
        {
            RtlCopyMemory(pbUseThisMemory, *ppMemoryPointer, dwPreservedMemoryLength);
            m_ppMemoryPointer = ppMemoryPointer;
            m_dwPreservedMemoryLength = dwPreservedMemoryLength;
            m_pbPreservedMemory = pbUseThisMemory;
        }
        return pbUseThisMemory;
    }

    inline PVOID PreserveThisMemoryToTempBuffer( PBYTE* ppMemoryPointer, DWORD dwPreservedMemoryLength )
    {
        PVOID pbDestinationMemory = NULL;

        Assert( dwPreservedMemoryLength != 0 );
        Assert( ppMemoryPointer != NULL );
        Assert( *ppMemoryPointer != NULL );
        if (m_pScratchMemoryAllocator->TempBuffer() != NULL &&
            m_pScratchMemoryAllocator->TempBufferSize() >= dwPreservedMemoryLength )
        {
            pbDestinationMemory = m_pScratchMemoryAllocator->TempBuffer();
            RtlCopyMemory(pbDestinationMemory, *ppMemoryPointer, dwPreservedMemoryLength);
            *ppMemoryPointer = (PBYTE)pbDestinationMemory;
        }
        else
        {
            AssertSz(FALSE, "Temp Buffer can't fit PreserveThisMemoryToTempBuffer");
        }
        return pbDestinationMemory;
    }

    inline ~CReleaseAllScratchMemoryUponDestruction()
    {
        m_pScratchMemoryAllocator->Pop();

        if (m_pbPreservedMemory != NULL)
        {
            Assert( m_dwPreservedMemoryLength != 0 );
            *m_ppMemoryPointer = m_pScratchMemoryAllocator->Alloc(m_dwPreservedMemoryLength);
            RtlCopyMemory(*m_ppMemoryPointer, m_pbPreservedMemory, m_dwPreservedMemoryLength);
        }
    }

private:

    CScratchMemoryAllocator* m_pScratchMemoryAllocator;
    PVOID m_pbPreservedMemory;
    PVOID* m_ppMemoryPointer;
    DWORD m_dwPreservedMemoryLength;
};

// ---------------------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------------------

// String config -------------------------------------------------------------------------

// Definitions ---------------------------------------------------------------------------

#define CFGERR_SUCCESS                  0       // Parsing was successful
#define CFGERR_UNCLOSED_STRING          1       // Quoted string without closing quote
#define CFGERR_UNCLOSED_BRACES          2       // Braced string without closing brace
#define CFGERR_UNOPENED_BRACE           3       // Stray close-brace without opened brace
#define CFGERR_INVALID_NAME             4       // Name is not an unquoted/unbraced string
#define CFGERR_MISSING_VALUE            5       // Value missing in a name-value pair
#define CFGERR_OUT_OF_MEMORY            6       // Ran out of memory while parsing

struct CCfgStr
{
    // Functions -------------------------------------------------------------------------

    BOOL            GetNum( WORD* pwNum );
    BOOL            GetNum( DWORD* pdwNum );
    BOOL            GetNum( ULONGLONG* pqwNum );
    BOOL            GetHex( BYTE* pb, DWORD cb );
    BOOL            GetIpAddr( CIpAddr* pIp );
    BOOL            StrEql( const char* pch );
    const char*     Str() const;

    // Data ------------------------------------------------------------------------------

    const char*     _pch;
    DWORD           _cch;
    DWORD           _iLine;
};

struct CCfgInfo
{
    // Definitions -----------------------------------------------------------------------

    #define CFGF_ALLOC          0x00000001      // CCfgInfo was allocated (vs on stack)
    #define CFGF_LIST           0x00000002      // Value is a list of items

    // Functions -------------------------------------------------------------------------

    CCfgInfo()      { memset(this, 0, sizeof(*this)); }

    INLINE BOOL     IsAlloc() { return(!!(_dwFlags & CFGF_ALLOC)); }
    INLINE BOOL     IsList()  { return(!!(_dwFlags & CFGF_LIST)); }
    void            Free();

    DWORD           Parse( const char* pch, DWORD* piLineErr );
    DWORD           Parse( DWORD* piLineErr );

    CCfgInfo *      Find( const char* pchName, CCfgInfo* pciAfter, BOOL fMustExist );
    CCfgInfo *      FindList( const char* pchName, CCfgInfo* pciAfter, BOOL fMustExist );
    CCfgInfo *      FindNonList( const char* pchName, CCfgInfo* pciAfter, BOOL fMustExist );
    DWORD           Count( const char* pchName );

    BOOL            GetNum( const char* pchName, WORD* pwNum, BOOL fMustExist );
    BOOL            GetNum( const char* pchName, DWORD* pdwNum, BOOL fMustExist );
    BOOL            GetNum( const char* pchName, UINT* pdwNum, BOOL fMustExist );
    BOOL            GetNum( const char* pchName, ULONGLONG* pqwNum, BOOL fMustExist );
    BOOL            GetHex( const char* pchName, BYTE* pb, DWORD* pcb, DWORD cbMax, BOOL fMustExist );
    BOOL            GetIpAddr( const char* pchName, CIpAddr* pIp, BOOL fMustExist, BOOL fZeroOk = FALSE );
    BOOL            GetIpPort(char * pchName, CIpPort * pipport, BOOL fMustExist);
    BOOL            GetString( const char* pchName, char* pch, DWORD cchMax, BOOL fMustExist );

    BOOL            GetVar( const char* pchName, DWORD* piVar, DWORD iMin, DWORD iMax, DWORD iDef );
    BOOL            GetVar( const char* pchName, UINT* piVar, UINT iMin, UINT iMax, UINT iDef );
    BOOL            GetVar( const char* pchName, WORD* piVar, WORD iMin, WORD iMax, WORD iDef );

    // Data ------------------------------------------------------------------------------

    DWORD           _dwFlags;                   // See CFGF_* above
    CCfgStr         _csName;                    // Name string
    CCfgStr         _csValue;                   // Value string
    CCfgInfo *      _pciHead;                   // Head of CCfgInfo queue
    CCfgInfo *      _pciTail;                   // Tail of CCfgInfo queue
    CCfgInfo *      _pciNext;                   // Next CCfgInfo in queue owning this item
    CCfgInfo *      _pciTodoNext;               // Next CCfgInfo to process during parse/free
};


// ---------------------------------------------------------------------------------------
// Internal APIs
// ---------------------------------------------------------------------------------------
BOOL SgIoSendConfig(CCfgInfo* pci);

#ifdef SG_FEATURE_XMGMT

    // XMGMT: We get to use real xmgmt macros

    #define SvcLog( area, format, ... ) \
        XomLog( area, format, __VA_ARGS__ )

    #define SvcLogFT( area, flowToken, format, ... ) \
        XomLogFT( area, flowToken, format, __VA_ARGS__ )

    // If you want to log, but need to control the level. Yes, you can set the output of
    // this to a file.. it doesn't have to be "tracing" only.

    #define SvcLogLvl( area, lvl, format, ... ) \
        XomTrace( area, lvl, format, __VA_ARGS__ )

    #define SvcLogLvlFT( area, lvl, flowToken, format, ... ) \
        XomTraceFT( area, lvl, flowToken, format, __VA_ARGS__ )

#elif defined SG_FEATURE_LSP

    // LSP: We do our own logging

    #define SvcLog( area, format, ... ) \
        SgLspLog( #area, format, __VA_ARGS__ )

    #define SvcLogFT( area, flowToken, format, ... ) \
        SgLspLogFT( #area, flowToken, format, __VA_ARGS__ )

    // If you want to log, but need to control the level. Yes, you can set the output of
    // this to a file.. it doesn't have to be "tracing" only.

    #define SvcLogLvl( area, lvl, format, ... )
    #define SvcLogLvlFT( area, lvl, flowToken, format, ... )

    #define XomImportArea( area )
    #define XomDefineArea( area )

#else

    // No LSP, no XMGMT.. that means no logging.

    #define SvcLog( area, format, ... )
    #define SvcLogFT( area, flowToken, format, ... )

    #define SvcLogLvl( area, lvl, format, ... )
    #define SvcLogLvlFT( area, lvl, flowToken, format, ... )

    #define XomImportArea( area )
    #define XomDefineArea( area )

#endif

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------
XomImportArea(Debug);
XomImportArea(Integration);
XomImportArea(log);
XomImportArea(LogCode);
XomImportArea(LogCodeWindows);
XomImportArea(LogTitle);
XomImportArea(LogWindows);
XomImportArea(lua);
XomImportArea(Reporting);
XomImportArea(SgClientStats);

// ---------------------------------------------------------------------------------------
// Service Core
// ---------------------------------------------------------------------------------------

BOOL SgServiceInit( HANDLE hShutdownEvent );
void SgServiceTerm();
void SgServiceHeartbeat();
BOOL SgServiceInstall(OUT BOOL *pfRebootRequired);
BOOL SgServiceUninstall(OUT BOOL *pfRebootRequired);

// ---------------------------------------------------------------------------------------
// Message Handling Layer
// ---------------------------------------------------------------------------------------

BOOL SgServiceMsgHandlerInit();
void SgServiceMsgHandlerTerm();
BOOL SgServiceMsgHandlerConfig(CCfgInfo* pci);
void SgServiceMsgHandlerHeartbeat();

// ---------------------------------------------------------------------------------------
// Notify Layer
// ---------------------------------------------------------------------------------------

BOOL SgServiceNotifyInit();
void SgServiceNotifyTerm();
BOOL SgServiceNotifyConfig( const CSgSvcConfig* pSgSvcConfig );
void SgServiceNotifyHeartbeat();
BOOL SgServiceNotifyRefreshDns();
void SgServiceNotifyCliUpdate( const SGADDR* psgaddr, ULONGLONG qwUserId, ULONGLONG qwXnkid, DWORD dwAuthFlags, DWORD dwState, DWORD dwTitleId, WORD cbTitleData, const BYTE* pbTitleData );
void SgServiceNotifyCliTitleChange( const SGADDR* psgaddr, DWORD dwLastTitleId, DWORD dwTitleId );
void SgServiceNotifyCliUserChange( const SGADDR* psgaddr, ULONGLONG qwUser0, ULONGLONG qwUser1, ULONGLONG qwUser2, ULONGLONG qwUser3, IN_ADDR ipaI, DWORD dwFlags );
void SgServiceNotifyCliDelete( const SGADDR* psgaddr, DWORD dwTitleId );
void SgServiceNotifySpiUpdate( const SGADDR* psgaddr, DWORD dwOldSpi );

// ---------------------------------------------------------------------------------------
// Perf Counter Layer
// ---------------------------------------------------------------------------------------

BOOL SgServicePerfCountersInit();
void SgServicePerfCountersTerm();
void SgServicePerfCountersHeartbeat();

// ---------------------------------------------------------------------------------------
// NULL Cipher Layer
// ---------------------------------------------------------------------------------------
BOOL SgNullCipherInit();
void SgNullCipherTerm();
BOOL SgNullCipherConfig(CCfgInfo* pci);
BOOL SgNullCipherCheckMachine(ULONGLONG machineId);

// ---------------------------------------------------------------------------------------
// Health Layer
// ---------------------------------------------------------------------------------------

BOOL SgHealthInit(CComBSTR &bstrComponent);
void SgHealthTerm();

// ---------------------------------------------------------------------------------------
// XMgmt Callback Layer
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_XMGMT

class CSgControlCallback : public CXomControlCallback
{
public:

    ULONG __stdcall AddRef () { return 1; }
    ULONG __stdcall Release() { return 1; }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );
};

extern CSgControlCallback g_SgControlCallback;

#endif // SG_FEATURE_XMGMT

char * SgSvcHexStr(const void * pv, size_t cb);


// ---------------------------------------------------------------------------------------
// Config Listener class
// ---------------------------------------------------------------------------------------

#define SG_AUTORELOAD_DELAY_MS 5000

class CSGConfigListener : public CConfigListenerBase
{
    IMPLEMENT_REFCOUNT_COM

public:

    CSGConfigListener() {}
    virtual ~CSGConfigListener() { Term(); }

    HRESULT Init();
    void    Term();

    STDMETHODIMP QueryInterface( REFIID riid, void **ppObj )
    {
        if (ppObj == NULL)
        {
            return E_POINTER;
        }

        if (riid == IID_IUnknown)
        {
            *ppObj = (void *)(IUnknown*)this;
            AddRef();
            return S_OK;
        }
        if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void *)(IConfigListener*)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    virtual HRESULT __stdcall SettingChange(
        /*[in]*/ struct ISettingChangeEventArgs *e
        );

    virtual HRESULT __stdcall MultiSettingChange(
        /*[in]*/ struct IMultiSettingChangeEventArgs *e
        );

    virtual HRESULT __stdcall VirtualInterfaceChange(
        /*[in]*/ struct IVirtualInterfaceChangeEventArgs *e
        );

};

#ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// Lua
// ---------------------------------------------------------------------------------------

class __declspec(novtable) ISgLuaState
{
public:

    virtual void Lock() = 0;
    virtual BOOL LinkLuaStateToSpi(CSpiInfo* pSpiInfo, CStr* perror) = 0;
    virtual lua_State* GetLuaState() = 0;
    virtual BOOL SetGlobalBuffer(LPCSTR pName, BYTE *pbBuffer, ULONG cbBuffer, BOOL bReadOnly, BOOL bCopy, CStr *perror) = 0;
    virtual BOOL SetGlobalInteger(LPCSTR pName, DWORD dwValue, CStr *perror) = 0;
    virtual BOOL UnsetGlobal(LPCSTR pName, CStr *perror) = 0;
    virtual void Release() = 0;
    virtual BOOL CCall(lua_CFunction func, void *ud, CStr* perror) = 0;
    virtual BOOL LCall_va(const char* pFunc, const char* pSig, CStr* perror, ... ) = 0;
};

BOOL            SgLuaInit();
void            SgLuaTerm();
BOOL            SgLuaConfig(CCfgInfo* pci);
BOOL            SgLuaReloadChallenges();
ISgLuaState*    SgLuaGetState(CSpiInfo* pSpiInfo);
ISgLuaState*    SgLuaGetState(UINT32 dwIndex);
void            SgLuaReleaseSpiStorage(CSpiInfo* pSpiInfo);
void            SgLuaStackDump(lua_State *L, LPCSTR pMessage);

// *** SgLuaBuffer ***

void            SgLuaBufferRegister(lua_State *L);
int             SgLuaBufferInitialize(lua_State *L, BYTE *pbBuffer,ULONG cbBuffer, BOOL bReadOnly, BOOL bCopy);
void            SgLuaBufferCheck(lua_State *L, int narg, OUT BYTE** ppBuffer, OUT UINT32* pcbBuffer);

// *** Qword ***

UINT64          SgLuaQwordCheck(lua_State* pLuaState, int narg);
int             SgLuaQwordInitialize(lua_State* pLuaState, UINT64 value);
BOOL            SgLuaQwordPresent(lua_State* pLuaState, int narg);
void            SgLuaQwordRegister(lua_State* pLuaState);

// *** Challenge ***

void            SgLuaChalRegister(lua_State* pLuaState);

// *** Spi ***

int             SgLuaSpiStorageTerm(lua_State* pLuaState);
void            SgLuaSpiRegister(lua_State* pLuaState);
void            SgLuaSetSpiInfo(lua_State* pLuaState, CSpiInfo* pSpiInfo);
CSpiInfo*       SgLuaGetSpiInfo(lua_State* pLuaState, BOOL throwOnError = TRUE);

// *** Filter ***

void            SgLuaFilterRegister(lua_State* pLuaState);

// *** Binary ***

void            SgLuaBinaryRegister(lua_State* pLuaState);

// *** Debug ***

void            SgLuaDebugRegister(lua_State* pLuaState);
void            SgLuaDebugMasterRegister(lua_State* pLuaState);

// *** Log   ***

void            SgLuaLogRegister(lua_State* pLuaState);

// *** Perf  ***

void            SgLuaPerfReset();
void            SgLuaPerfRegister(lua_State* pLuaState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsUnitTests\MsnRRWrapperIntEnvTest.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Net;
using System.Xml;
using System.Web.Services.Protocols; // SoapException

using ServerTestFramework;
using ServerTestFramework.LiveService;
//using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Ratings;
using xonline.common.config;

using xonline.common.msnrr;
using xonline.common.service;
using xonline.common.diagnostics;

using System.Text.RegularExpressions;

namespace UserRatings.Functional
{
    static public class NPDB_MSNContentTypeMappings
    {
        static NPDB_MSNContentTypeMappings()
        {
            XConfig xconfig = new XConfig();
            string contentTypes = xconfig.GetSetting("ratings_contenttype_mapping");

            Regex reg = new Regex("mediatype=\"1\"\\s*contentTypeId=\"(?<guid>[0-9a-zA-Z-]{36})\"");
            Match m1 = reg.Match(contentTypes);
            if (m1.Success)
            {
                FullXbox360Game = m1.Groups["guid"].Value;
            }

            reg = new Regex("mediatype=\"21\"\\s*contentTypeId=\"(?<guid>[0-9a-zA-Z-]{36})\"");
            m1 = reg.Match(contentTypes);
            if (m1.Success)
            {
                XboxOriginalGame = m1.Groups["guid"].Value;
            }

            reg = new Regex("mediatype=\"23\"\\s*contentTypeId=\"(?<guid>[0-9a-zA-Z-]{36})\"");
            m1 = reg.Match(contentTypes);
            if (m1.Success)
            {
                XboxArcadeGame = m1.Groups["guid"].Value;
            }

            reg = new Regex("mediatype=\"37\"\\s*contentTypeId=\"(?<guid>[0-9a-zA-Z-]{36})\"");
            m1 = reg.Match(contentTypes);
            if (m1.Success)
            {
                XNACommunityGame = m1.Groups["guid"].Value;
            }
        }

        static public string FullXbox360Game;
        static public string XboxOriginalGame;
        static public string XboxArcadeGame;
        static public string XNACommunityGame;


    }

    #region TEMPORARY WORK AROUND FOR XBLOB ACCOUNT CREATION!!!

    //
    // Workaround: 
    //   1) Comment out reference to ServerTestFramework.LiveService.UserAccount.
    //   2) Automatically utilize the new XeUser and XbosUser.* objects and methods (no change in test case code required).
    //
    // To remove workaround:
    //   1) Remove the two classes inside this region.
    //   2) Uncomment the using reference above for ServerTestFramework.LiveService.UserAccount
    //

    public class XeUser
    {
        public XeUser(ulong userpuid)
        {
            _UserPuid = userpuid;
        }

        private ulong _UserPuid;
        public ulong UserPuid
        {
            get
            {
                return _UserPuid;
            }
            set
            {
                _UserPuid = value;
            }
        }

        public enum Country
        {
            AT = 5,
            AU = 6,
            BE = 8,
            CA = 16,
            CH = 18,
            CN = 20,
            CO = 21,
            DE = 24,
            DK = 25,
            ES = 31,
            FI = 32,
            FR = 34,
            UK = 35,
            GR = 37,
            HK = 39,
            IE = 44,
            IN = 46,
            IT = 50,
            JP = 53,
            KR = 56,
            MX = 71,
            NL = 74,
            NO = 75,
            NZ = 76,
            PT = 84,
            SE = 90,
            SG = 91,
            TW = 101,
            US = 103,
        }
    }

    static public class XbosUser
    {
        public static XeUser JuvenileUser()
        {
            return new XeUser(1);
        }
        public static XeUser MinorUser()
        {
            return new XeUser(2);
        }

        public static XeUser XenonGoldCCUser()
        {
            return new XeUser(4);
        }

        public static XeUser XenonGoldPPUser()
        {
            return new XeUser(5);
        }

        public static XeUser XenonGoldUser()
        {
            return new XeUser(6);
        }

        public static XeUser XenonSilverUser()
        {
            return new XeUser(7);
        }
    }

    #endregion

    [TestGroup]
    class MsnRRWrapperIntEnvTest : TestNode
    {
        private static Report _Report = new Report(typeof(MsnRRWrapperIntEnvTest).Name);

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Submits a rating to MSN with a too long item ID")]
        public void N_SubmitWithTooLongItemID()
        {
            _Report.Info("Test BEGIN");
            XeUser user = XbosUser.XenonGoldUser();

            Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XNACommunityGame);
            string itemId = "12345678901234567890123456789012345678901234567890123456789012345";
            Puid puid = user.UserPuid;
            Guid msnGuid = Guid.Empty;
            int ratingValue = 2;

            try
            {
                _Report.Info("Calling MSN Wrapper...");
                MsnRRClient.SaveRating(contentId, itemId, (Puid)puid, ratingValue);
                _Report.Error("Test FAILED. Expected exception was not received.");
            }
            catch (MsnRRException e)
            {
                // We expect this exception to occur.
                xonline.common.service.HResult expected = new xonline.common.service.HResult();
                expected = 0x80154102;
                Assert.IsTrue(e.HResult == expected);
            }

            _Report.Success("Test PASSED");
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Submits a rating to MSN with an invalid (zero) user ID")]
        public void N_SubmitWithZeroUserID()
        {
            _Report.Info("Test BEGIN");

            Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XNACommunityGame);
            Guid itemId = new Guid("00000000-0000-0000-0000-000000000001");
            Puid puid = (ulong)0;
            Guid msnGuid = Guid.Empty;
            int ratingValue = 2;

            try
            {
                _Report.Info("Calling MSN Wrapper...");
                MsnRRClient.SaveRating(contentId, itemId, (Puid)puid, ratingValue);
                _Report.Error("Test FAILED. Expected exception was not received.");
            }
            catch(MsnRRException e)
            {
                // We expect this exception to occur.
                xonline.common.service.HResult expected = new xonline.common.service.HResult();
                expected = 0x80154103;
                Assert.IsTrue(e.HResult == expected);
            }

            _Report.Success("Test PASSED");
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Submits a rating to MSN with an invalid content type ID")]
        public void N_SubmitWithInvalidContentTypeID()
        {
            _Report.Info("Test BEGIN");

            XeUser user = XbosUser.XenonGoldUser();

            Guid contentId = new Guid("00000000-0000-0000-0000-000000000001");
            Guid itemId = Guid.NewGuid();
            Puid puid = user.UserPuid;
            Guid msnGuid = Guid.Empty;
            int ratingValue = 5;

            try
            {
                _Report.Info("Calling MSN Wrapper...");
                MsnRRClient.SaveRating(contentId, itemId, (Puid)puid, ratingValue);
                _Report.Error("Test FAILED. Expected exception was not received.");
            }
            catch(MsnRRException e)
            {
                // We expect this exception to occur.
                xonline.common.service.HResult expected = new xonline.common.service.HResult();
                expected = 0x80154101;
                Assert.IsTrue(e.HResult == expected);
            }
            _Report.Success("Test PASSED");
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Submits a rating to MSN with valid parameters")]
        public void P_SubmitAndRetrieveRating()
        {
            _Report.Info("Test BEGIN");
            XeUser user = XbosUser.XenonGoldUser();

            Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XNACommunityGame);
            Guid itemId = new Guid("00000000-0000-0000-0000-000000000001");
            Puid puid = user.UserPuid;
            Guid msnGuid = Guid.Empty;
            int ratingValue = 2;

            int userRatingFromMSN;

            _Report.Info("Calling MSN Wrapper...");
            MsnRRClient.SaveRating(contentId, itemId, puid, ratingValue);
            MsnRRClient.GetRatingByUser(contentId, itemId, (Puid)puid, out userRatingFromMSN);

            Assert.IsTrue(userRatingFromMSN == ratingValue);

            _Report.Success("Test PASSED");
        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Retrieve a rating from MSN with a too long item ID")]
        public void N_RetrieveWithTooLongItemID()
        {
            _Report.Info("Test BEGIN");
            XeUser user = XbosUser.XenonGoldUser();

            Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XNACommunityGame);
            string itemId = "12345678901234567890123456789012345678901234567890123456789012345";
            Puid puid = user.UserPuid;
            Guid msnGuid = Guid.Empty;

            int userRatingFromMSN;

            try
            {
                _Report.Info("Calling MSN Wrapper...");
                MsnRRClient.GetRatingByUser(contentId, itemId, puid, out userRatingFromMSN);
                _Report.Error("Test FAILED. Expected exception was not received.");
            }
            catch (MsnRRException e)
            {
                // We expect this exception to occur.
                xonline.common.service.HResult expected = new xonline.common.service.HResult();
                expected = 0x80154102;
                Assert.IsTrue(e.HResult == expected);
            }

            _Report.Success("Test PASSED");

        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Retrieve a rating from MSN with a zero user ID")]
        public void N_RetrieveWithZeroUserID()
        {
            _Report.Info("Test BEGIN");

            Guid contentId = new Guid(NPDB_MSNContentTypeMappings.XNACommunityGame);
            Guid itemId = new Guid("00000000-0000-0000-0000-000000000001");
            Puid puid = (ulong)0;
            Guid msnGuid = Guid.Empty;

            int userRatingFromMSN;

            try
            {
                _Report.Info("Calling MSN Wrapper...");
                MsnRRClient.GetRatingByUser(contentId, itemId, puid, out userRatingFromMSN);
                _Report.Error("Test FAILED. Expected exception was not received.");
            }
            catch (MsnRRException e)
            {
                // We expect this exception to occur.
                xonline.common.service.HResult expected = new xonline.common.service.HResult();
                expected = 0x80154103;
                Assert.IsTrue(e.HResult == expected);
            }

            _Report.Success("Test PASSED");

        }

        [TestCase, Owner("mattlec"), EnvRequirement("Billing,Catalog"), Description("Retrieve a rating with an invalid content type ID")]
        public void N_RetrieveWithInvalidContentTypeID()
        {
            _Report.Info("Test BEGIN");

            XeUser user = XbosUser.XenonGoldUser();

            Guid contentId = new Guid("00000000-0000-0000-0000-000000000001");
            Guid itemId = Guid.NewGuid();
            Puid puid = user.UserPuid;
            Guid msnGuid = Guid.Empty;

            int userRatingFromMSN;

            try
            {
                _Report.Info("Calling MSN Wrapper...");
                MsnRRClient.GetRatingByUser(contentId, itemId, puid, out userRatingFromMSN);
                _Report.Error("Test FAILED. Expected exception was not received.");
            }
            catch (MsnRRException e)
            {
                // We expect this exception to occur.
                xonline.common.service.HResult expected = new xonline.common.service.HResult();
                expected = 0x80154101;
                Assert.IsTrue(e.HResult == expected);
            }
            _Report.Success("Test PASSED");


        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgasn1.cpp ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "sg.h"
#include <stdlib.h>
#include <stdio.h>

#ifdef ENABLE_DOUBLE
#include <float.h>
#include <math.h>

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif
#endif

#define ASN1LIB
#define MULTI_LEVEL_ZONES

#define ENABLE_BER
#define ENABLE_COMPARE
#define XBOX_SPECIFIC_OPTIMIZATIONS

#include "sgasn1.h"

#ifdef _DEBUG
#define MyDebugBreak() SgDbgBreak()
#endif // _DEBUG


//#include <msper.h>
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}

extern ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
extern void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_inc(ASN1intx_t *);
extern void ASN1API ASN1intx_dec(ASN1intx_t *);
extern void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
// extern void ASN1API ASN1intx_free(ASN1intx_t *);
extern void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern int  ASN1API ASN1intxisuint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint8(ASN1intx_t *);
extern int  ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern double ASN1API ASN1intx2double(ASN1intx_t *);
extern double ASN1API ASN1real2double(ASN1real_t *);
extern double ASN1API ASN1double_minf();
extern double ASN1API ASN1double_pinf();
extern int ASN1API ASN1double_isminf(double);
extern int ASN1API ASN1double_ispinf(double);
extern int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Comparison APIs ------ */

extern int ASN1API ASN1ztchar32string_cmp(ASN1ztchar32string_t, ASN1ztchar32string_t);
extern int ASN1API ASN1double_cmp(double, double);
extern int ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern int ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern int ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern int ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern int ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));


#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    
// internal functions
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **di);


#if ! defined(_DEBUG) && defined(TEST_CODER)
#undef TEST_CODER
#endif

typedef struct ASN1INTERNencoding_s *ASN1INTERNencoding_t;
typedef struct ASN1INTERNdecoding_s *ASN1INTERNdecoding_t;

// lonchanc: this is really bad to duplicate the definitions of ASN1encoding_s
// and ASN1decoding_s here. We sould simply use them as components in
// the following ASN1INTERNencoding_s and ASN1INTERNdecoding_s.

struct ASN1INTERNencoding_s {

    // public view of encoding structure
    struct ASN1encoding_s       info;

    // private portion of encoding structure
    ASN1INTERNencoding_t        parent;
    ASN1INTERNencoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO
};

struct ASN1INTERNdecoding_s {

    // public view of decoding structure
    struct ASN1decoding_s       info;

    // private portion of decoding structure
    ASN1INTERNdecoding_t        parent;
    ASN1INTERNdecoding_t        child;

    // how deeply this decoding is nested
    ASN1uint32_t                recursionLevel; 

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO

    // decoded into an external buffer
    ASN1uint32_t                fExtBuf;
    void*                       lpOrigExtBuf;    // original buffer pointer
    ASN1uint32_t                cbOrigExtBufSize;// original buffer size
    ASN1uint8_t*                lpRemExtBuf;     // remaining buffer pointer
    ASN1uint32_t                cbRemExtBufSize; // remaining buffer size
    ASN1uint32_t                cbLinearBufSize; // linear buffer size to hold the data
};

extern ASN1_PUBLIC void ASN1API ASN1DecAbort(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1DecDone(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1EncAbort(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1EncDone(ASN1encoding_t enc);

#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification);
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification);
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_EMBEDDED_PDV

int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src);

ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val);
ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src);
ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds);
void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p);


/* ------ perencod.c ------ */

int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
__inline int ASN1PEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}
__inline int ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}

/* ------ bit.c ------ */

int ASN1is32space(ASN1char32_t);
int ASN1str32len(ASN1char32_t *);
int ASN1is16space(ASN1char16_t);
int ASN1str16len(ASN1char16_t *);
int My_lstrlenA(char *p);
int My_lstrlenW(WCHAR *p);
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets);
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets);

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(arr)             (sizeof(arr) / sizeof(arr[0]))
#endif

// #define FIELD_OFFSET(type, field)   ((long)&(((type *)0)->field))   // from winnt.h
#define PARAMS_SIZE_N_ARRARY(arr)   ARRAY_SIZE(arr), arr

#define LPVOID_ADD(ptr,inc)  (LPVOID) ((ASN1octet_t *) (ptr) + (ASN1uint32_t) (inc))
#define LPVOID_SUB(ptr,dec)  (LPVOID) ((ASN1octet_t *) (ptr) - (ASN1uint32_t) (inc))

#define LPVOID_NEXT(ptr)     *(LPVOID FAR *) (ptr)

// the following constants is for calculating decoded data structure size
// we are conservative here and try to be 4-byte aligned due to Alpha platform.

#define ASN1_SIZE_ALIGNED(n)    (n) = ((((n) + 3) >> 2) << 2)

#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size);
#endif // ENABLE_BER

#define UNKNOWN_MODULE                  0

#define MemAllocEx(dec,cb,fZero)        (dec)->pScratchMemoryAllocator->Alloc((cb))
#define MemFree(lp)
#define MemReAllocEx(dec,lp,cb,fZero)   ((lp) ? \
            (dec)->pScratchMemoryAllocator->ReAlloc((lp),(cb)) : \
            (dec)->pScratchMemoryAllocator->Alloc((cb)))

#define _ModName(enc_dec)                   

LPVOID DecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize );
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize );

#define EncMemAlloc(enc,cb)             (enc)->pScratchMemoryAllocator->Alloc((cb))
#define EncMemReAlloc(enc,lp,cb)        (enc)->pScratchMemoryAllocator->ReAlloc((lp),(cb))
#define EncMemImmediateReAlloc(dec,lp,ocb,cb)   (dec)->pScratchMemoryAllocator->ImmediateReAlloc((lp),(ocb),(cb))

void   DecMemFree    ( ASN1decoding_t dec, LPVOID lpData );

#define EncMemFree(enc,lpData)              MemFree(lpData)

int IsDigit(char p);
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch);
void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        );

#define MyAssert(f)         
#ifdef _DEBUG
    __inline void EncAssert(ASN1encoding_t enc, int val)
    {
        if ((! (enc->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
    __inline void DecAssert(ASN1decoding_t dec, int val)
    {
        if ((! (dec->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
#else
    #define EncAssert(enc,f)   
    #define DecAssert(dec,f)   
#endif // _DEBUG

// making a magic number
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))

/* magic number for ASN1encoding_t */
#define MAGIC_ENCODER       MAKE_STAMP_ID('E','N','C','D')

/* magic number for ASN1decoding_t */
#define MAGIC_DECODER       MAKE_STAMP_ID('D','E','C','D')


#ifdef TEST_CODER
typedef struct ASN1testcoder_s
{
    struct ASN1INTERNencoding_s     e;
    struct ASN1INTERNdecoding_s     d;
}   *ASN1testcoder_t;
#define ASN1_TEST_CODER_SIZE    (sizeof(struct ASN1testcoder_s))
int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod);
int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod);
int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *valref, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
#else
#define ASN1_TEST_CODER_SIZE    0
#endif

#define ENCODE_BUFFER_INCREMENT         128
#define ENCODE_BUFFER_MAX_INCREMENT     256

static const ASN1uint8_t c_aBitMask2[] =
{
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff
};

#define TO64(x) ((unsigned __int64)(x))

/* check if sufficient data is in decoding buffer */
int ASN1PERDecCheck(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    unsigned __int64 overflowCheck; 

    // Ensure that our computation doesn't overflow:
    overflowCheck = (TO64(dec->pos) - TO64(dec->buf)) * 8 + TO64(dec->bit) + TO64(nbits); 
    if (overflowCheck & (0xFFFFFFFFi64 << 32))
    {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0;
    }

    // we're confident that no arithmetic overflow will occur.  Perform the check.
    if ((dec->pos - dec->buf) * 8 + dec->bit + nbits <= dec->size * 8)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

/* skip up to octet boundary */
void ASN1PERDecAlignment(ASN1decoding_t dec)
{
    if (dec->bit)
    {
        dec->bit = 0;
        dec->pos++;
    }
}

// moved from perdecod.c
/* end of decoding */
int ASN1PERDecFlush(ASN1decoding_t dec)
{
    /* complete broken byte */
    ASN1PERDecAlignment(dec);

    /* get zero-octet if encoding is empty bitstring */
    if (dec->buf == dec->pos)
    {
        if (ASN1PERDecCheck(dec, 8))
        {
            if (*dec->pos == 0)
            {
                dec->pos++;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}
// moved from perencod.c
/* end of encoding */
int ASN1PEREncFlush(ASN1encoding_t enc)
{
    /* complete broken octet */
    ASN1PEREncAlignment(enc);

    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);

        return 1;
    }

    return ASN1PEREncCheck(enc, 1);
}

// moved from perencod.c
/* encode an octet alignment */
void ASN1PEREncAlignment(ASN1encoding_t enc)
{
    /* complete broken octet */
    if (enc->bit)
    {
        enc->pos++;
        enc->bit = 0;
    }
}

// moved from perencod.c
/* check for space in buffer for PER and BER. */
int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    // any additional space required?
    if (noctets)
    {
        // buffer exists?
        if (NULL != enc->buf)
        {
            // buffer large enough?
            if (enc->size - (enc->pos - enc->buf) - ((enc->bit != 0) ? 1 : 0) >= noctets)
            {
                return 1;
            }

            // static buffer overflow?
            if (enc->dwFlags & ASN1ENCODE_SETBUFFER)
            {
                ASN1EncSetError(enc, ASN1_ERR_OVERFLOW);
                return 0;
            }
            else
            {
                // round up to next 256 byte boundary and resize buffer
                ASN1octet_t *oldbuf = enc->buf;
                ASN1uint32_t oldsize = enc->size;
                // enc->size = ((noctets + (enc->pos - oldbuf) + (enc->bit != 0) - 1) | 255) + 1;
                if (ASN1_PER_RULE & enc->eRule)
                {
                    enc->size += max(noctets, ENCODE_BUFFER_INCREMENT);
                }
                else
                {
                    //enc->size += max(noctets, enc->size);
                    enc->size += min(max(noctets, enc->size), ENCODE_BUFFER_MAX_INCREMENT);
                }
                enc->buf = (ASN1octet_t *)EncMemImmediateReAlloc(enc, enc->buf, oldsize, enc->size);
                if (NULL != enc->buf)
                {
                    enc->pos = enc->buf + (enc->pos - oldbuf);
                }
                else
                {
                    ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                    return 0;
                }
            }
        }
        else
        {
            // no buffer exists, allocate new one.
            // round up to next 256 byte boundary and allocate buffer
            // enc->size = ((noctets - 1) | 255) + 1;
            enc->size = max(noctets + enc->cbExtraHeader, ENCODE_BUFFER_INCREMENT);
            enc->buf = (ASN1octet_t*) EncMemAlloc(enc, enc->size);
            if (NULL != enc->buf)
            {
                enc->pos = (ASN1octet_t *) (enc->buf + enc->cbExtraHeader);
            }
            else
            {
                enc->pos = NULL;
                ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                return 0;
            }
        }
    }

    return 1;
}

// moved from perfn.c
int ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* nothing to scan? */
    if (n > minlen)
    {
        /* let val point to last ASN1octet used */
        val += (n - 1) / 8;

        /* check if broken ASN1octet consist out of zero bits */
        if ((n & 7) && !(*val & c_aBitMask2[n & 7])) {
            n &= ~7;
            val--;
        }

        /* scan complete ASN1octets (memrchr missing ...) */
        if (!(n & 7)) {
            while (n > minlen && !*val) {
                n -= 8;
                val--;
            }
        }

        /* scan current octet bit after bit */
        if (n > minlen) {
            for (i = (n - 1) & 7; i >= 0; i--) {
                if (*val & (0x80 >> i))
                    break;
                n--;
            }
        }

        /* return real bitstring len */
        *nbits = n < minlen ? minlen : n;
    }
    return 1;
}

/* init an ASN1encoding_t */
ASN1error_e ASN1_CreateEncoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        mod,
    ASN1encoding_t     *enc,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
)
{
    if (NULL != mod && NULL != enc)
    {
        ASN1INTERNencoding_t    e;

        *enc = NULL;

        /* construct ASN1encoding_t */
        e = (ASN1INTERNencoding_t)pScratchMemoryAllocator->Alloc(sizeof(*e) + ASN1_TEST_CODER_SIZE);
        if (NULL != e)
        {
            RtlZeroMemory(e, sizeof(*e) + ASN1_TEST_CODER_SIZE);
            e->info.pScratchMemoryAllocator = pScratchMemoryAllocator;
            e->info.magic = MAGIC_ENCODER;
            e->info.err = ASN1_SUCCESS;
            // e->info.pos = e->info.buf = NULL;
            // e->info.size = e->info.len = e->info.bit = 0;
            e->info.dwFlags = mod->dwFlags;
            e->info.module = mod;
            // e->child = NULL;

            /* set buffer if given */
            if (NULL != pbBuf && cbBufSize)
            {
                e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
                e->info.pos = e->info.buf = pbBuf;
                e->info.size = cbBufSize;
            }

            /* set parent if parented, otherwise, initialized to itself */
            if (NULL != pParent)
            {
                e->parent = (ASN1INTERNencoding_t) pParent;
                e->info.eRule = pParent->eRule;
            }
            else
            {
                e->parent = e;
                e->info.eRule = mod->eRule;
            }

            // e->mem = NULL;
            // e->memlength = 0;
            // e->memsize = 0;
            // e->epi = NULL;
            // e->epilength = 0;
            // e->episize = 0;
            // e->csi = NULL;
            // e->csilength = 0;
            // e->csisize = 0;

            if (! (e->info.dwFlags & ASN1ENCODE_SETBUFFER) && (NULL != pParent))
            {
                // lonchanc: make sure we have a minimum 256 bytes available.
                BOOL fRet = FALSE;
                if (ASN1_PER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1PEREncCheck((ASN1encoding_t) e, 1);
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1BEREncCheck((ASN1encoding_t) e, 1);
                }
#endif // ENABLE_BER
                else
                {
                    EncAssert((ASN1encoding_t) e, 0);
                    MemFree(e);
                    return ASN1_ERR_RULE;
                }
                if (fRet)
                {
                    // lonchanc: make sure the first byte is zeroed out, which
                    // is required for h245.
                    e->info.buf[0] = '\0';
                }
                else
                {
                    MemFree(e);
                    return ASN1_ERR_MEMORY;
                }
            }

#if defined(TEST_CODER) && defined(_DEBUG)
            TestEnc_InitCoder(e, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                EncAssert((ASN1encoding_t) e, NULL == ((ASN1INTERNencoding_t) pParent)->child);
                ((ASN1INTERNencoding_t) pParent)->child = e;
            }

            *enc = (ASN1encoding_t) e;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* encode a value */
ASN1error_e ASN1_Encode
(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t    e = (ASN1INTERNencoding_t)enc;

        /* check magic numbers */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        /* clear error */
        ASN1EncSetError(enc, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1ENCODE_SETBUFFER)
        {
            e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = pbBuf;
            enc->size = cbBufSize;
            enc->len = enc->bit = 0;
        }
        /* use a new buffer? */
        else if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
        {
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = NULL;
            enc->size = enc->len = enc->bit = 0;
        }
        /* reuse buffer? */
        else if ((flags & ASN1ENCODE_REUSEBUFFER) || !((e->info.dwFlags | flags) & ASN1ENCODE_APPEND))
        {
            EncAssert(enc, NULL != enc->buf);
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
        }
        /* otherwise append to buffer */

        /* check id number */
        if (id < enc->module->cPDUs)
        {
            if (ASN1_PER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1PerEncFun_t pfnPER;
                if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
                {
                    if ((*pfnPER)(enc, value))
                    {
                        ASN1PEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1BerEncFun_t pfnBER;
                if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
                {
                    if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
                    {
                        ASN1BEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#endif // ENABLE_BER
            else
            {
                return ASN1EncSetError(enc, ASN1_ERR_RULE);
            }

            /* call abort/done function for non-parented encoding stream */
            if (ASN1_SUCCEEDED(e->parent->info.err))
            {
                // not parented
                if (e == e->parent)
                {
#if defined(TEST_CODER) && defined(_DEBUG)
                    if (ASN1_PER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#ifdef ENABLE_BER
                    else
                    if (ASN1_BER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#endif // ENABLE_BER
#endif
                    ASN1EncDone(enc);
                }
            }
            else
            {
                ASN1INTERNencoding_t child, child2;

                // not parented
                if (e == e->parent)
                {
                    ASN1EncAbort(enc);
                }

                // clean up...
                if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
                {
                    ASN1_FreeEncoded(enc, enc->buf);
                    enc->pos = enc->buf = NULL;
                    enc->size = enc->len = enc->bit = 0;
                }
                for (child = e->child; child; child = child2)
                {
                    child2 = child->child;
                    // make sure it does not touch its parent which may already be freed
                    child->parent = child;
                    ASN1_CloseEncoder2((ASN1encoding_t) child);
                }
                e->child = NULL;
            }

            /* return error code */
            return e->parent->info.err;
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for encoding */
ASN1error_e ASN1_SetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            enc->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_NOT_REUSE_BUFFER:
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->buf = enc->pos = NULL;
            enc->size = enc->bit = enc->len = 0;
            break;

        case ASN1OPT_REWIND_BUFFER:
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}

ASN1error_e ASN1_GetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = enc->eRule;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy encoding stream */
void ASN1_CloseEncoder
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        if (e != e->parent)
        {
            EncAssert(enc, e == e->parent->child);
            e->parent->child = NULL;
        }

        /* free encoding stream */
        MemFree(e);
    }
}

/* destroy encoding stream */
void ASN1_CloseEncoder2
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, enc->buf);

        ASN1_CloseEncoder(enc);
    }
}

#define ASN1_DEFAULT_MAX_RECURSION_LEVEL        5
#define ASN1_DEFAULT_MAX_DECODE_BUFFER_SIZE     2000

DWORD   g_dwMaxRecursionLevel       = ASN1_DEFAULT_MAX_RECURSION_LEVEL; 
DWORD   g_dwMaxDecodeBufferSize     = ASN1_DEFAULT_MAX_DECODE_BUFFER_SIZE; 

/* init an ASN1decoding_t */
ASN1error_e ASN1_CreateDecoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
)
{
    //
    // BUG 780462: MSASN1: Should limit recursion for constructed type decoding
    // Don't allow arbitrary recursion depth here.  
    //

    if (NULL != pParent && (((ASN1INTERNdecoding_t)pParent)->recursionLevel > g_dwMaxRecursionLevel))
    {
        return ASN1_ERR_LARGE; 
    }

    //
    // BUG 807085: MSASN1.dll: Should limit the size of buffer to decode
    // Check that our buffer isn't too big 
    //
    if (NULL != pbBuf && cbBufSize > g_dwMaxDecodeBufferSize) 
    {
        return ASN1_ERR_LARGE; 
    } 

    if (NULL != mod && NULL != dec)
    {
        ASN1INTERNdecoding_t d;

        *dec = NULL;

        /* construct ASN1decoding_t */
        d = (ASN1INTERNdecoding_t)pScratchMemoryAllocator->Alloc(sizeof(*d) + ASN1_TEST_CODER_SIZE);
        if (NULL != d)
        {
            RtlZeroMemory(d, sizeof(*d) + ASN1_TEST_CODER_SIZE);
            d->info.pScratchMemoryAllocator = pScratchMemoryAllocator;
            d->info.magic = MAGIC_DECODER;
            d->info.err = ASN1_SUCCESS;
            d->info.dwFlags = mod->dwFlags;
            d->info.module = mod;
            // d->child = NULL;
            // d->recursionLevel = 0; 

            /* set buffer if given */
            // lonchanc: it is ok to have a zero buffer size here
            if (NULL != pbBuf)
            {
                d->info.dwFlags |= ASN1DECODE_SETBUFFER;
                d->info.buf = d->info.pos = pbBuf;
                d->info.size = cbBufSize;
                // d->info.len = d->info.bit = 0;
            }
            else
            {
                // d->info.buf = d->info.pos = NULL;
                // d->info.size = d->info.len = d->info.bit = 0;
            }

            /* set parent if parented */
            if (NULL != pParent)
            {
                d->parent = (ASN1INTERNdecoding_t) pParent;
                d->info.eRule = pParent->eRule;
                d->recursionLevel = d->parent->recursionLevel + 1; 
            }
            else
            /* initialize otherwise */
            {
                d->parent = d;
                d->info.eRule = mod->eRule;
            }

            // d->mem = NULL;
            // d->memlength = 0;
            // d->memsize = 0;
            // d->epi = NULL;
            // d->epilength = 0;
            // d->episize = 0;
            // d->csi = NULL;
            // d->csilength = 0;
            // d->csisize = 0;

#if defined(TEST_CODER) && defined(_DEBUG)
            TestDec_InitCoder(d, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                DecAssert((ASN1decoding_t) d, NULL == ((ASN1INTERNdecoding_t) pParent)->child);
                ((ASN1INTERNdecoding_t) pParent)->child = d;
            }

            *dec = (ASN1decoding_t) d;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* decode a value */
ASN1error_e ASN1_Decode
(
    ASN1decoding_t      dec,
    void              **valref,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    ASN1error_e ReturnCode = ASN1_SUCCESS;

    if (NULL != dec && NULL != valref)
    {
        ASN1INTERNdecoding_t    d = (ASN1INTERNdecoding_t)dec;

        /* check magic numbers */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        /* clear error */
        ASN1DecSetError(dec, ASN1_SUCCESS);

        /* new buffer given? */
        *valref = NULL;
        if (flags & ASN1DECODE_SETBUFFER)
        {
            if (NULL != pbBuf && 0 != cbBufSize)
            {
                dec->pos = dec->buf = pbBuf;
                dec->size = cbBufSize;
                dec->bit = dec->len = 0;
            }
            else
            {
                ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADARGS);
                goto ErrorExit;
            }
        }
        /* rewind buffer? */
        else if ((flags & ASN1DECODE_REWINDBUFFER) ||
                 !((d->info.dwFlags | flags ) & ASN1DECODE_APPENDED))
        {
            dec->pos = dec->buf;
            dec->bit = dec->len = 0;
        }
        /* otherwise continue reading from last buffer */

        /* 
            Check that our buffer isn't too big 
            (BUG 807085 46650 MSASN1.dll: Should limit the size of buffer to decode)
        */
        if (dec->size > g_dwMaxDecodeBufferSize)
        {
            ReturnCode = ASN1DecSetError(dec, ASN1_ERR_LARGE); 
            goto ErrorExit; 
        }

        /* check id number */
        if (id < dec->module->cPDUs)
        {
            ASN1uint32_t cbTopLevelStruct;

            /* clear length of linear buffer required */
            d->cbLinearBufSize = 0;

            /* double check for the availability of destination buffer */
            if (d->lpOrigExtBuf == NULL || d->cbOrigExtBufSize == 0)
            {
                d->fExtBuf = FALSE;
            }

            cbTopLevelStruct = dec->module->acbStructSize[id];
            if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
            {
                if (ASN1_PER_RULE & dec->eRule)
                {
                    ASN1PerDecFun_t pfnPER;
                    /* decode value */
                    if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
                    {
                        if ((*pfnPER)(dec, *valref))
                        {
                            ASN1PERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                        goto ErrorExit;
                    }
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & dec->eRule)
                {
                    ASN1BerDecFun_t pfnBER;
                    /* decode value */
                    if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
                    {
                        if ((*pfnBER)(dec, 0, *valref)) // lonchanc: tag is 0 to make it compiled
                        {
                            ASN1BERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                        goto ErrorExit;
                    }
                }
#endif // ENABLE_BER
                else
                {
                    ReturnCode = ASN1DecSetError(dec, ASN1_ERR_RULE);
                    goto ErrorExit;
                }

                /* call abort/done function for non-parented decoding stream */
                if (ASN1_SUCCEEDED(d->parent->info.err))
                {
                    // not parented
                    if (d == d->parent)
                    {
#if defined(TEST_CODER) && defined(_DEBUG)
                        if (ASN1_PER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#ifdef ENABLE_BER
                        else
                        if (ASN1_BER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#endif // ENABLE_BER
#endif
                        ASN1DecDone(dec);
                    }
                }
                else
                {
                    ASN1INTERNdecoding_t child, child2;

                    // not parented
                    if (d == d->parent)
                    {
                        ASN1DecAbort(dec);
                    }

                    // clean up...
                    for (child = d->child; child; child = child2)
                    {
                        child2 = child->child;
                        // make sure it does not touch its parent which may already be freed
                        child->parent = child;
                        ASN1_CloseDecoder((ASN1decoding_t) child);
                    }
                    d->child = NULL;
                }

                /* return error code */
                ReturnCode = d->parent->info.err;
                goto ErrorExit;
            }
            else
            {
                ReturnCode = ASN1_ERR_MEMORY;
                goto ErrorExit;
            }
        }
        else
        {
            ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            goto ErrorExit;
        }
    }

    ReturnCode = ASN1_ERR_BADARGS;

ErrorExit:
    if (ASN1_FAILED(ReturnCode))
    {
        if (NULL != valref)
        {
        ASN1_FreeDecoded(dec ,*valref, id);
        *valref = NULL;
    }
    }

    return ReturnCode;
}

/* control function for decoding */
ASN1error_e ASN1_SetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            dec->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_SET_DECODED_BUFFER:
            if (NULL != pOptParam->Buffer.pbBuf && 0 != pOptParam->Buffer.cbBufSize)
            {
                d->fExtBuf = TRUE;
                d->lpOrigExtBuf = pOptParam->Buffer.pbBuf;
                d->cbOrigExtBufSize = pOptParam->Buffer.cbBufSize;
                d->lpRemExtBuf = (ASN1uint8_t*) d->lpOrigExtBuf;
                d->cbRemExtBufSize = d->cbOrigExtBufSize;
            }
            else
            {
                rc = ASN1_ERR_BADARGS;
            }
            break;

        case ASN1OPT_DEL_DECODED_BUFFER:
            d->fExtBuf = FALSE;
            d->lpOrigExtBuf = NULL;
            d->cbOrigExtBufSize = 0;
            d->lpRemExtBuf = NULL;
            d->cbRemExtBufSize = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* control function for decoding */
ASN1error_e ASN1_GetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = dec->eRule;
            break;

        case ASN1OPT_GET_DECODED_BUFFER_SIZE:
            pOptParam->cbRequiredDecodedBufSize = d->cbLinearBufSize;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy decoding stream */
void ASN1_CloseDecoder
(
    ASN1decoding_t      dec
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        if (d != d->parent)
        {
            DecAssert(dec, d == d->parent->child);
            d->parent->child = NULL;
        }

        /* free decoding stream */
        MemFree(d);
    }
}

/* free an encoded value */
void ASN1_FreeEncoded
(
    ASN1encoding_t      enc,
    void               *val
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, val);
    }
}

/* free a unencoded value */
void ASN1_FreeDecoded
(
    ASN1decoding_t      dec,
    void               *val,
    ASN1uint32_t        id
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        // same behavior of LocalFree
        if (val != NULL)
        {
            if (id != ASN1DECFREE_NON_PDU_ID)
            {
                ASN1FreeFun_t       pfnFreeMemory;

                /* free value */
                if (id < dec->module->cPDUs)
                {
                    if (NULL != (pfnFreeMemory = dec->module->apfnFreeMemory[id]))
                    {
                        (*pfnFreeMemory)(val);
                    }
                }
                else
                {
                    return;
                }
            }

            // free the top-level structure
            MemFree(val);
        }
    }
}

static struct tagASN1module_t ASN1_Main_Module;

ASN1module_t ASN1_CreateModule
(
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
)
{
    ASN1module_t module = NULL;

    /* compiler output and library version match together? */
    if (
        // version <= ASN1_THIS_VERSION &&
        NULL != apfnEncoder             &&
        NULL != apfnDecoder             &&
        NULL != apfnFreeMemory          &&
        NULL != acbStructSize)
    {
        if (NULL != (module = (ASN1module_t)&ASN1_Main_Module))
        {
            RtlZeroMemory( module, sizeof(ASN1_Main_Module) );
            
            module->nModuleName = nModuleName;
            module->eRule = eEncodingRule;
            module->dwFlags = dwFlags;
            module->cPDUs = cPDUs;

            module->apfnFreeMemory = apfnFreeMemory;
            module->acbStructSize = acbStructSize;

            if (ASN1_PER_RULE & eEncodingRule)
            {
                module->PER.apfnEncoder = (const ASN1PerEncFun_t *) apfnEncoder;
                module->PER.apfnDecoder = (const ASN1PerDecFun_t *) apfnDecoder;
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & eEncodingRule)
            {
                module->BER.apfnEncoder = (const ASN1BerEncFun_t *) apfnEncoder;
                module->BER.apfnDecoder = (const ASN1BerDecFun_t *) apfnDecoder;
            }
#endif // ENABLE_BER
        }
    }
    return module;
}


void ASN1_CloseModule(ASN1module_t pModule)
{
}



#ifdef TEST_CODER

static int MyMemCmp(ASN1octet_t *p1, ASN1octet_t *p2, ASN1uint32_t c)
{
    BYTE diff;
    while (c--)
    {
        if ((diff = *p1++ - *p2++) != 0)
            return (int) diff;
    }
    return 0;
}

__inline ASN1INTERNencoding_t TestEnc_GetEnc(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->e); }
__inline ASN1INTERNdecoding_t TestEnc_GetDec(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->d); }
__inline ASN1INTERNencoding_t TestDec_GetEnc(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->e); }
__inline ASN1INTERNdecoding_t TestDec_GetDec(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->d); }

static void Test_InitEnc(ASN1INTERNencoding_t e, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    RtlZeroMemory(e, sizeof(*e));
    e->info.magic = MAGIC_ENCODER;
    e->info.err = ASN1_SUCCESS;
    e->info.module = mod;
    e->info.eRule = eRule;
    e->parent = e;
    e->child = NULL;
}

static void Test_InitDec(ASN1INTERNdecoding_t d, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    RtlZeroMemory(d, sizeof(*d));
    d->info.magic = MAGIC_DECODER;
    d->info.err = ASN1_SUCCESS;
    d->info.module = mod;
    d->info.eRule = eRule;
    d->parent = d;
    d->child = NULL;
}

static int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    Test_InitEnc(ee, mod, e->info.eRule);
    Test_InitDec(ed, mod, e->info.eRule);
    return 1;
}

static int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    ASN1INTERNdecoding_t dd = TestDec_GetDec(d);
    Test_InitEnc(de, mod, d->info.eRule);
    Test_InitDec(dd, mod, d->info.eRule);
    return 1;
}

static int Test_Encode(ASN1INTERNencoding_t e, void *value, ASN1uint32_t id)
{
    ASN1encoding_t enc = (ASN1encoding_t) e;

    /* clear error */
    ASN1EncSetError(enc, ASN1_SUCCESS);

    // clean buffer
    enc->pos = enc->buf;
    enc->bit = enc->len = 0;

    if (ASN1_PER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1PerEncFun_t pfnPER;
        if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
        {
            if ((*pfnPER)(enc, value))
            {
                ASN1PEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1BerEncFun_t pfnBER;
        if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
        {
            if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
            {
                ASN1BEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#endif // ENABLE_BER
    else
    {
        return ASN1EncSetError(enc, ASN1_ERR_RULE);
    }

    /* call abort/done function for non-parented encoding stream */
    if (e->parent->info.err >= 0)
    {
        if (e == e->parent)
        {
            ASN1EncDone(enc);
        }
    }
    else
    {
        ASN1INTERNencoding_t child, child2;

        if (e == e->parent)
        {
            ASN1EncAbort(enc);
        }

        // clean up...
        ASN1_FreeEncoded(enc, enc->buf);
        enc->pos = enc->buf = NULL;
        enc->size = enc->len = enc->bit = 0;
        for (child = e->child; child; child = child2)
        {
            child2 = child->child;
            // make sure it does not touch its parent which may already be freed
            child->parent = child;
            ASN1_CloseEncoder((ASN1encoding_t) child);
        }
        e->child = NULL;
    }

    /* return error code */
    return e->parent->info.err;
}

static int Test_Decode(ASN1INTERNdecoding_t d, void ** valref, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1decoding_t dec = (ASN1decoding_t) d;
    ASN1uint32_t cbTopLevelStruct;

    /* clear error */
    ASN1DecSetError(dec, ASN1_SUCCESS);

    // set up buffer containing encoded data
    dec->pos = dec->buf = pbBuf;
    dec->size = cbBufSize;
    dec->bit = dec->len = 0;

    /* clear length of linear buffer required */
    d->cbLinearBufSize = 0;
    d->fExtBuf = FALSE;

    cbTopLevelStruct = dec->module->acbStructSize[id];
    if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
    {
        if (ASN1_PER_RULE & dec->eRule)
        {
            ASN1PerDecFun_t pfnPER;
            /* decode value */
            if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
            {
                if ((*pfnPER)(dec, *valref))
                {
                    ASN1PERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#ifdef ENABLE_BER
        else
        if (ASN1_BER_RULE & dec->eRule)
        {
            ASN1BerDecFun_t pfnBER;
            /* decode value */
            if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
            {
                if ((*pfnBER)(dec, 0, *valref))
                {
                    ASN1BERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#endif // ENABLE_BER
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_RULE);
        }

        /* call abort/done function for non-parented decoding stream */
        if (d->parent->info.err >= 0)
        {
            // not parented
            if (d == d->parent)
            {
                ASN1DecDone(dec);
            }
        }
        else
        {
            ASN1INTERNdecoding_t child, child2;

            // not parented
            if (d == d->parent)
            {
                ASN1DecAbort(dec);
            }

            // clean up...
            ASN1_FreeDecoded(dec ,*valref, id);
            *valref = NULL;
            for (child = d->child; child; child = child2)
            {
                child2 = child->child;
                // make sure it does not touch its parent which may already be freed
                child->parent = child;
                ASN1_CloseDecoder((ASN1decoding_t) child);
            }
            d->child = NULL;
        }
    }
    else
    {
        return ASN1_ERR_MEMORY;
    }

    /* return error code */
    return d->parent->info.err;
}

static void Test_CleanEnc(ASN1INTERNencoding_t e)
{
    if (e->info.buf)
    {
        EncMemFree((ASN1encoding_t) e, e->info.buf);
    }
    Test_InitEnc(e, e->info.module, e->info.eRule);
}

static void Test_CleanDec(ASN1INTERNdecoding_t d)
{
    Test_InitDec(d, d->info.module, d->info.eRule);
}

static int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    int ret;
    void *val = NULL;
    int fRet = 0;

    ee->info.eRule = e->info.eRule;
    ed->info.eRule = e->info.eRule;

    ret = Test_Decode(ed, &val, id, pbBuf, cbBufSize);
    if (ret == ASN1_SUCCESS)
    {
        ret = Test_Encode(ee, val, id);
        if (ret == ASN1_SUCCESS)
        {
            if (ee->info.len == cbBufSize)
            {
                fRet = (MyMemCmp(pbBuf, ee->info.buf, cbBufSize) == 0);
            }
        }
    }

    if (val)
    {
        ASN1_FreeDecoded((ASN1decoding_t) ed, val, id);
    }

    Test_CleanEnc(ee);
    Test_CleanDec(ed);

    return fRet;
}

static int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *val, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    int ret;
    int fRet = 0;

    de->info.eRule = d->info.eRule;

    ret = Test_Encode(de, val, id);
    if (ret == ASN1_SUCCESS)
    {
        if (de->info.len == cbBufSize)
        {
            fRet = (MyMemCmp(pbBuf, de->info.buf, cbBufSize) == 0);
        }
    }

    Test_CleanEnc(de);

    return fRet;
}
#endif

#ifdef ENABLE_BER

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* decode bit string value */
int _BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1bitstring_t b;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (_BERDecBitString(dd, 0x3, &b, fNoCopy))
                        {
                            if (b.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = b;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + b.length + 7) / 8);
                                if (val->value)
                                {
                                    /* concat bit strings */
                                    ASN1bitcpy(val->value, val->length, b.value, 0, b.length);
                                    val->length += b.length;
                                    if (val->length & 7)
                                        val->value[val->length / 8] &= bitmsk2[val->length & 7];

                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                }
                                else
                                {
                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                    return 0;
                                }
                            }
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                if (!len)
                {
                    val->length = 0;
                    val->value = NULL;
                    return 1;
                }
                else if (1 == len)
                {
                    // BUG 785505: MSASN1: Decoding data can cause memory corruption
                    // Special-case len==1, or else we'll have an arithmetic overflow below
                    val->length = 0;
                    val->value = NULL;
                    dec->pos += 1; 
                    return 1; 
                }
                else
                {
                    if (*dec->pos < 8)
                    {
                        len--; // skip over the initial octet; len is now the actual length of octets
                        val->length = len * 8 - *dec->pos++;
                        if (fNoCopy)
                        {
                            val->value = dec->pos;
                            dec->pos += len;
                            return 1;
                        }
                        else
                        {
                            if (val->length)
                            {
                                val->value = (ASN1octet_t *)DecMemAlloc(dec, (val->length + 7) / 8);
                                if (val->value)
                                {
                                    RtlCopyMemory(val->value, dec->pos, len);
                                    if (val->length & 7)
                                        val->value[len - 1] &= bitmsk2[val->length & 7];
                                    dec->pos += len;
                                    return 1;
                                }
                            }
                            else
                            {
                                val->value = NULL;
                                return 1;
                            }
                        }
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    }
                }
            }
        }
    }
    return 0;
}

/* decode bit string value, making copy */
int ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, FALSE);
}

/* decode bit string value, no copy */
int ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, TRUE);
}

/* decode string value */
int ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1charstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecCharString(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (char *)DecMemReAlloc(dd, val->value,
                                    val->length + c.length + 1);
                                if (val->value)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(val->value + val->length, c.value, c.length);
                                    val->length += c.length;
                                    val->value[val->length] = 0;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                val->length = len;
                if (len)
                {
                    val->value = (char *)DecMemAlloc(dec, len+1);
                    if (val->value)
                    {
                        RtlCopyMemory(val->value, dec->pos, len);
                        dec->pos += len;
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 16 bit string value */
int ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar16String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char16_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length + 1) * sizeof(ASN1char16_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char16_t));
                                    val->length += c.length;
                                    val->value[val->length] = 0; 

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 2 * sizeof(ASN1octet_t) == sizeof(ASN1char16_t));
                len = len >> 1; // divided by 2
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char16_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char16_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 32 bit string value */
int ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar32String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char32_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length + 1) * sizeof(ASN1char32_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char32_t));
                                    val->length += c.length;
                                    val->value[val->length] = 0; 

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 4 * sizeof(ASN1octet_t) == sizeof(ASN1char32_t));
                len = len >> 2; // divided by 4
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char32_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char32_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];;
                            dec->pos += 4;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* decode character string value */
int ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1characterstring_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? CS-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->csilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o =
                ASN1characterstring_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1characterstring_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1characterstring_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1characterstring_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1characterstring_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1characterstring_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddCharacterStringIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? CS-B encoded */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        val->data_value.u.encoded.length = len - 1;
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        RtlCopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetCharacterStringIdentification(d->parent,
            index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
/* decode embedded pdv value */
int ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1embeddedpdv_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? EP-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* then start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->epilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1embeddedpdv_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1embeddedpdv_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1embeddedpdv_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1embeddedpdv_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1embeddedpdv_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddEmbeddedPdvIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? EP-B encoded: */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        val->data_value.u.encoded.length = 8 * (len - 1);
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        RtlCopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetEmbeddedPdvIdentification(d->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

#ifdef ENABLE_EXTERNAL
/* decode external value */
int ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1objectidentifier_t id;
    ASN1octetstring_t os;

    /* decode explicit tag */
    if (!ASN1BERDecExplicitTag(dec, tag | 0x20000000, &dd, &di))
        return 0;

    /* peek tag of choice alternative */
    if (!ASN1BERDecPeekTag(dd, &tag))
        return 0;

    /* decode alternative */
    if (tag == 0x6)
    {
        if (!ASN1BERDecObjectIdentifier(dd, 0x6, &id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
        if (tag == 0x2)
        {
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            val->identification.u.context_negotiation.transfer_syntax = id;
            if (!ASN1BERDecU32Val(dd, 0x2, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecPeekTag(dd, &tag))
                return 0;
        }
        else
        {
            val->identification.o = ASN1external_identification_syntax_o;
            val->identification.u.syntax = id;
        }
    }
    else
    if (tag == 0x2)
    {
        val->identification.o =
            ASN1external_identification_presentation_context_id_o;
        if (!ASN1BERDecU32Val(dd, 0x2,
            &val->identification.u.presentation_context_id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* decode optional data value descriptor if present */
    if (tag == 0x7)
    {
        if (!ASN1BERDecZeroCharString(dd, 0x7, &val->data_value_descriptor))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        val->data_value_descriptor = NULL;
    }

    /* decode data value alternative */
    switch (tag)
    {
    case 0:
        val->data_value.o = ASN1external_data_value_notation_o;
        if (!ASN1BERDecOpenType(dd, &val->data_value.u.notation))
            return 0;
        break;
    case 1:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x4, &os))
            return 0;
        val->data_value.u.encoded.value = os.value;
        val->data_value.u.encoded.length = os.length * 8;
        break;
    case 2:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x3, &val->data_value.u.encoded))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* end of constructed (explicit tagged) value */
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;

    return 1;
}
#endif // ENABLE_EXTERNAL

/* decode generalized time value */
int ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    ASN1ztcharstring_t time = NULL;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    } else { 
        if (NULL != time) { 
            DecMemFree(dec, time);
        }
    } 
    return 0;
}

/* decode multibyte string value */
int ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    return ASN1BERDecZeroCharString(dec, tag, val);
}

int ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BERDecCharString(dec, tag, val);
}

/* decode null value */
int ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag)
{
    ASN1uint32_t len;
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (! len)
            {
                return 1;
            }
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        ASN1uint32_t nelem;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            data = dec->pos;
            dec->pos += len;
            nelem = 1;
            for (i = 0, p = data; i < len; i++, p++)
            {
                if (!(*p & 0x80))
                    nelem++;
            }
            *val = q = DecAllocObjectIdentifier(dec, nelem);
            if (q)
            {
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (q == *val)
                        { // first id
                            q->value = v / 40;
                            if (q->value > 2)
                                q->value = 2;
                            q->next->value = v - 40 * q->value;
                            q = q->next->next;
                        }
                        else
                        {
                            q->value = v;
                            q = q->next;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        //ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
            // NOTE: first byte of encoded OID encodes the first two elements of the OID, 
            // so allow only 15 bytes for the encoded OID.  
            if (len <= 15) 
            {
                data = dec->pos;
                dec->pos += len;
                val->count = 0;
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (! val->count)
                        { // first id
                            val->value[0] = v / 40;
                            if (val->value[0] > 2)
                                val->value[0] = 2;
                            val->value[1] = v - 40 * val->value[0];
                            val->count = 2;
                        }
                        else
                        {
                            val->value[val->count++] = v;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode integer into signed 8 bit value */
int ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (1 == len)
            {
                *val = *dec->pos++;
                return 1;
            }
            ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode integer into signed 16 bit value */
int ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            return 1;
        }
    }
    return 0;
}

const ASN1int32_t c_nSignMask[] = { 0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0 };

/* decode integer into signed 32 bit value */
int ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            int fSigned = 0x80 & *dec->pos;

            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            case 3:
                *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                dec->pos += 3;
                break;
            case 4:
                *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                    (dec->pos[2] << 8) | dec->pos[3];
                dec->pos += 4;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            if (fSigned)
            {
                *val |= c_nSignMask[len-1];
            }
            return 1;
        }
    }
    return 0;
}

/* decode integer into intx value */
int ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                val->length = len;
                val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                if (val->value)
                {
                    RtlCopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 8 bit value */
int ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                if (0 == *dec->pos)
                {
                    *val = dec->pos[1];
                    dec->pos += 2;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 16 bit value */
int ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                return 1;
            case 3:
                if (0 == *dec->pos)
                {
                    *val = (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode utc time value */
int ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *val)
{
    ASN1ztcharstring_t time = NULL;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    } else { 
        if (NULL != time) { 
            DecMemFree(dec, time);
        } 
    } 
    return 0;
}

/* decode zero terminated string value */
int ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztcharstring_t c = NULL;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroCharString(dd, 0x4, &c))
                        {
                            lv = My_lstrlenA(*val);
                            lc = My_lstrlenA(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (char *)DecMemReAlloc(dd, *val, lv + lc + 1);
                                if (*val)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(*val + lv, c, lc + 1);

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                    c = NULL;
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            if (NULL != c) { 
                                DecMemFree(dec, c); 
                            }
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (char *)DecMemAlloc(dec, len + 1);
                if (*val)
                {
                    RtlCopyMemory(*val, dec->pos, len);
                    (*val)[len] = 0;
                    dec->pos += len;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 16 bit string value */
int ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroChar16String(dd, 0x4, &c))
                        {
                            lv = ASN1str16len(*val);
                            lc = ASN1str16len(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (ASN1char16_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char16_t));
                                if (*val)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char16_t));

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char16_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char16_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 8) | dec->pos[1];
                        dec->pos += 2;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 32 bit string value */
int ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
                if (*val)
                {
                    **val = 0;
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecZeroChar32String(dd, 0x4, &c))
                            {
                                lv = ASN1str32len(*val);
                                lc = ASN1str32len(c);
                                if (lc)
                                {
                                    /* resize value */
                                    *val = (ASN1char32_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char32_t));
                                    if (*val)
                                    {
                                        /* concat strings */
                                        RtlCopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char32_t));

                                        /* free unused string */
                                        DecMemFree(dec, c);
                                    }
                                    else
                                    {
                                        /* free unused string */
                                        DecMemFree(dec, c);
                                        return 0;
                                    }
                                }
                            }
                            else
                            {
                                return 0;
                            }
                        }
                        return ASN1BERDecEndOfContents(dec, dd, di);
                    }
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char32_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                    (dec->pos[2] << 8) | dec->pos[3];;
                        dec->pos += 4;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* skip a value */
int ASN1BERDecSkip(ASN1decoding_t dec)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* set warning flag */
    ASN1DecSetError(dec, ASN1_WRN_EXTENDED);

    /* read tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        // remove the above warning set previously
                        ASN1DecSetError(dec, ASN1_SUCCESS);
                        return 1;
                    } 

                    /* start skipping of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            // remove the above warning set previously
                            ASN1DecSetError(dec, ASN1_SUCCESS);
                            return 1;
                        }
                        return 0;
                    }
                }
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                    // remove the above warning set previously
                    ASN1DecSetError(dec, ASN1_SUCCESS);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value */
int _BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1octet_t *p;

    p = dec->pos;

    /* skip tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        goto MakeCopy;
                    } 

                    /* start decoding of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            goto MakeCopy;
                        }
                    }
                }
                return 0;
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                }
                else
                {
                    return 0;
                }
            }

        MakeCopy:

            // clean up unused fields
            // val->decoded = NULL;
            // val->userdata = NULL;

            /* copy skipped value */
            val->length = (ASN1uint32_t) (dec->pos - p);
            if (fNoCopy)
            {
                val->encoded = p;
                return 1;
            }
            else
            {
                val->encoded = (ASN1octet_t *)DecMemAlloc(dec, val->length);
                if (val->encoded)
                {
                    RtlCopyMemory(val->encoded, p, val->length);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value, making a copy */
int ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, FALSE);
}

/* decode an open type value, no copy */
int ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, TRUE);
}

/* finish decoding */
int ASN1BERDecFlush(ASN1decoding_t dec)
{
    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        DecAssert(dec, dec->len == dec->size);
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

#endif // ENABLE_BER


#ifdef ENABLE_BER

/* encode a string value */
int ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            RtlCopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a string value (CER) */
int ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                RtlCopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        RtlCopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 16 bit string value */
int ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
        }
        return 1;
    }
    return 0;
}

/* encode a 16 bit string value (CER) */
int ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char16_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char16_t) ?
                    1000 / sizeof(ASN1char16_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 32 bit string value */
int ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 24);
                *enc->pos++ = (ASN1octet_t)(*val >> 16);
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
            return 1;
        }
    }
    return 0;
}

/* encode a 32 bit string value (CER) */
int ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char32_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char32_t) ?
                    1000 / sizeof(ASN1char32_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 24);
                            *enc->pos++ = (ASN1octet_t)(*val >> 16);
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a bit string value */
int ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets = (len + 7) / 8;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, noctets + 1))
        {
            ASN1uint32_t cUnusedBits = (7 - ((len + 7) & 7));
            *enc->pos++ = (ASN1octet_t) cUnusedBits;
            RtlCopyMemory(enc->pos, val, noctets);
            enc->pos += noctets;
            EncAssert(enc, noctets >= 1);
            if (cUnusedBits)
            {
                EncAssert(enc, 8 >= cUnusedBits);
                *(enc->pos - 1) &= bitmsk2[8 - cUnusedBits];
            }
            return 1;
        }
    }
    return 0;
}

/* encode a bit string value (CER) */
int ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n;

    noctets = (len + 7) / 8;
    if (noctets + 1 <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, noctets + 1))
            {
                *enc->pos++ = (ASN1octet_t) (7 - ((len + 7) & 7));
                RtlCopyMemory(enc->pos, val, noctets);
                enc->pos += noctets;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (noctets)
            {
                n = len > 999 ? 999 : len;
                if (ASN1BEREncTag(enc, 0x3))
                {
                    if (ASN1BEREncLength(enc, n + 1))
                    {
                        *enc->pos++ = (ASN1octet_t) (n < len ? 0 : 7 - ((len + 7) & 7));
                        RtlCopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        noctets -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* encode a character string value */
int ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255)
        flag = 1;

    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* CS-A encoding: */
        /* encode as constructed value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.notation.length,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of character string */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* CS-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length);
            enc->pos += val->data_value.u.encoded.length;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* encode a real value */
int ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double d)
{
    double mantissa;
    int exponent;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1octet_t eASN1octets[16]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (ASN1double_ispinf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (ASN1double_isminf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        else
        /* check for bad real value */
        if (finite(d))
        {
            /* encode normal real value */

            /* split into mantissa and exponent */
            mantissa = frexp(d, &exponent);

            /* check for zero value */
            if (mantissa == 0.0 && exponent == 0)
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmoctets = 0;
            while (mantissa != 0.0 && nmoctets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmoctets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neoctets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neoctets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neoctets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if ASN1int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neoctets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neoctets + nmoctets;
            if (ASN1BEREncLength(enc, len))
            {
                /* put head octet, mantissa and exponent */
                *enc->pos++ = head;
                RtlCopyMemory(enc->pos, eASN1octets, neoctets);
                enc->pos += neoctets;
                RtlCopyMemory(enc->pos, mASN1octets, nmoctets);
                enc->pos += nmoctets;
                return 1;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_BADREAL);
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
/* encode a real value */
int ASN1BEREncReal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1intx_t mantissa;
    ASN1intx_t exponent;
    ASN1intx_t help;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[256]; /* should be enough */
    ASN1octet_t eASN1octets[256]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (val->type == eReal_PlusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (val->type == eReal_MinusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        /* encode normal real value */
        else
        {
            /* check for zero value */
            if (!ASN1intx_cmp(&val->mantissa, &ASN1intx_0))
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (val->mantissa.value[0] > 0x7f)
            {
                sign = 1;
                ASN1intx_neg(&mantissa, &val->mantissa);
            }
            else
            {
                sign = 0;
                if (! ASN1intx_dup(&mantissa, &val->mantissa))
                {
                    return 0;
                }
            }
            if (! ASN1intx_dup(&exponent, &val->exponent))
            {
                return 0;
            }

            /* encode mantissa */
            nmoctets = ASN1intx_uoctets(&mantissa);
            if (nmoctets < 256)
            {
                RtlCopyMemory(mASN1octets,
                    mantissa.value + mantissa.length - nmoctets,
                    nmoctets);
                ASN1intx_setuint32(&help, 8 * nmoctets);
                ASN1intx_sub(&exponent, &exponent, &help);
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);

                /* encode exponent and create head octet of encoded value */
                neoctets = ASN1intx_octets(&exponent);
                if (neoctets < 256)
                {
                    RtlCopyMemory(mASN1octets,
                        val->exponent.value + val->exponent.length - neoctets,
                        neoctets);
                    ASN1intx_free(&exponent);
                    head = (ASN1octet_t) (0x80 | (sign << 6) | (neoctets - 1));

                    /* encode length into first octet */
                    len = 1 + neoctets + nmoctets;
                    if (ASN1BEREncLength(enc, len))
                    {
                        /* put head octet, mantissa and exponent */
                        *enc->pos++ = head;
                        RtlCopyMemory(enc->pos, eASN1octets, neoctets);
                        enc->pos += neoctets;
                        RtlCopyMemory(enc->pos, mASN1octets, nmoctets);
                        enc->pos += nmoctets;
                        return 1;
                    }
                }
                else
                {
                    ASN1intx_free(&exponent);
                    ASN1EncSetError(enc, ASN1_ERR_LARGE);
                }
            }
            else
            {
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);
                ASN1EncSetError(enc, ASN1_ERR_LARGE);
            }
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* encode an embedded pdv value */
int ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255 ||
            (val->data_value.o == ASN1embeddedpdv_data_value_encoded_o &&
        (val->data_value.u.encoded.length & 7))) {
        flag = 1;
    }
        
    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* EP-A encoding: */
        /* encode as construct value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.notation.length * 8,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of embedded pdv */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* EP-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length / 8 + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length / 8);
            enc->pos += val->data_value.u.encoded.length / 8;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV


#ifdef ENABLE_EXTERNAL
/* encode an external value */
int ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1uint32_t t;
    ASN1uint32_t nLenOff_, nLenOff0;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode tag */
    if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
        return 0;

    /* encode identification */
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode data value descriptor if present */
    if (val->o[0] & 0x80) {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1BEREncCharString(enc, 0x7, t, val->data_value_descriptor))
            return 0;
    }

    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1BEREncExplicitTag(enc, 0, &nLenOff0))
            return 0;
        if (!ASN1BEREncOpenType(enc, &val->data_value.u.notation))
            return 0;
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1BEREncExplicitTag(enc, 1, &nLenOff0))
                return 0;
            if (!ASN1BEREncOctetString(enc, 0x4,
                val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        else
        {
            if (!ASN1BEREncExplicitTag(enc, 2, &nLenOff0))
                return 0;
            if (!ASN1BEREncBitString(enc, 0x3,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* end of external value */
    return ASN1BEREncEndOfContents(enc, nLenOff_);
}
#endif // ENABLE_EXTERNAL

/* encode a generalized time value */
int ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1generalizedtime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a generalized time value (CER) */
int ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1generalizedtime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a signed integer value */
int ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (val >= -0x8000 && val < 0x8000)
        {
            if (val >= -0x80 && val < 0x80)
            {
                if (ASN1BEREncLength(enc, 1))
                {
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 2))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
        else
        {
            if (val >= -0x800000 && val < 0x800000)
            {
                if (ASN1BEREncLength(enc, 3))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 4))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 24);
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* encode a intx_t integer value */
int ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *val)
{
    ASN1uint32_t cb;
    ASN1octet_t *p;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        // strip out leading 0 and ff.
        for (cb = val->length, p = val->value; cb > 1; cb--, p++)
        {
			// break if not 00 nor FF
            if (*p && *p != 0xFF)
            {
                break;
            }
			// break if 00 FF
			if ((! *p) && (*(p+1) & 0x80))
			{
				break;
			}
			// break if FF 7F
			if (*p == 0xFF && (!(*(p+1) & 0x80)))
			{
				break;
			}
        }

        /* encode length */
        if (ASN1BEREncLength(enc, cb))
        {
            /* copy value */
            RtlCopyMemory(enc->pos, p, cb);
            enc->pos += cb;
            return 1;
        }
    }
    return 0;
}

/* encode a multibyte string value */
int ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncCharString(enc, tag, val->length, val->value);
}

/* encode a multibyte string value (CER) */
int ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1CEREncCharString(enc, tag, val->length, val->value);
}

/* encode a null value */
int ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

// encode an oid node s to buffer pointed by p
ASN1octet_t *_BEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1objectidentifier_t obj = *val;
        ASN1uint32_t i, s, l;
        ASN1octet_t *data, *p;

        l = GetObjectIdentifierCount(obj);
        if (l)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)EncMemAlloc(enc, l * 5); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < l; i++)
                {
                    s = obj->value;
                    obj = obj->next;
                    if (!i && l > 1)
                    {
                        s = s * 40 + obj->value;
                        obj = obj->next;
                        i++;
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    RtlCopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;

        if (val->count)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)EncMemAlloc(enc, val->count * 5); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < val->count; i++)
                {
                    s = val->value[i];
                    if (!i && val->count > 1)
                    {
                        i++;
                        s = s * 40 + val->value[i];
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    RtlCopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an octet string value (CER) */
int ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                /* copy value */
                RtlCopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        RtlCopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode an open type value */
int ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *val)
{
    if (ASN1BEREncCheck(enc, val->length))
    {
        /* copy value */
        RtlCopyMemory(enc->pos, val->encoded, val->length);
        enc->pos += val->length;
        return 1;
    }
    return 0;
}

/* remove trailing zero bits from bit string */
int ASN1BEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* let val point to last ASN1octet used */
    val += (n - 1) / 8;

    /* check if broken ASN1octet consist out of zero bits */
    if ((n & 7) && !(*val & bitmsk2[n & 7]))
    {
        n &= ~7;
        val--;
    }

    /* scan complete ASN1octets (memcchr missing ...) */
    if (!(n & 7))
    {
        while (n && !*val)
        {
            n -= 8;
            val--;
        }
    }

    /* scan current ASN1octet bit after bit */
    if (n)
    {
        for (i = (n - 1) & 7; i >= 0; i--)
        {
            if (*val & (0x80 >> i))
                break;
            n--;
        }
    }

    /* return real bitstring len */
    *nbits = n;
    return 1;
}

/* encode an utc time value */
int ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1utctime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode an utc time value (CER) */
int ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1utctime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* end of encoding */
int ASN1BEREncFlush(ASN1encoding_t enc)
{
    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);
        return 1;
    }
    return ASN1BEREncCheck(enc, 1);
}

#endif // ENABLE_BER

/* get the expected length based on the table */
ASN1uint32_t _BERGetLength(ASN1uint32_t val, const ASN1uint32_t Tbl[], ASN1uint32_t cItems)
{
    ASN1uint32_t i;
    for (i = 0; i < cItems; i++)
    {
        if (val < Tbl[i])
            return i+1;
    }
    return cItems+1;
}

static const ASN1uint32_t c_TagTable[] = { 31, 0x80, 0x4000, 0x200000, 0x10000000 };

/* encode a tag */
int ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag)
{
    ASN1uint32_t tagclass, tagvalue, cbTagLength;

    tagclass = (tag >> 24) & 0xe0;
    tagvalue = tag & 0x1fffffff;

    cbTagLength = _BERGetLength(tagvalue, c_TagTable, ARRAY_SIZE(c_TagTable));
    if (ASN1BEREncCheck(enc, cbTagLength))
    {
        if (cbTagLength == 1)
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | tagvalue);
        }
        else
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | 0x1f);
            switch (cbTagLength)
            {
            case 6:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 28) | 0x80);
                // lonchanc: intentionally fall through
            case 5:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 21) | 0x80);
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 14) | 0x80);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 7) | 0x80);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(tagvalue & 0x7f);
                break;
            }
        }
        return 1;
    }
    return 0;
}

/* put the length value */
void _BERPutLength(ASN1encoding_t enc, ASN1uint32_t len, ASN1uint32_t cbLength)
{
    if (cbLength > 1)
    {
        *enc->pos++ = (ASN1octet_t) (0x7f + cbLength); // 0x80 + cbLength - 1;
    }

    switch (cbLength)
    {
    case 5:
        *enc->pos++ = (ASN1octet_t)(len >> 24);
        // lonchanc: intentionally fall through
    case 4:
        *enc->pos++ = (ASN1octet_t)(len >> 16);
        // lonchanc: intentionally fall through
    case 3:
        *enc->pos++ = (ASN1octet_t)(len >> 8);
        // lonchanc: intentionally fall through
    default: // case 2: case 1:
        *enc->pos++ = (ASN1octet_t)len;
        break;
    }
}

static const ASN1uint32_t c_LengthTable[] = { 0x80, 0x100, 0x10000, 0x1000000 };

/* encode length */
int ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len)
{
    ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

    if (ASN1BEREncCheck(enc, cbLength + len))
    {
        _BERPutLength(enc, len, cbLength);
        return 1;
    }
    return 0;
}

/* encode an octet string value */
int ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            /* copy value */
            RtlCopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a boolean value */
int ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (ASN1BEREncLength(enc, 1))
        {
            *enc->pos++ = val ? 0xFF : 0;
            return 1;
        }
    }
    return 0;
}

static const ASN1uint32_t c_U32LengthTable[] = { 0x80, 0x8000, 0x800000, 0x80000000 };

/* encode a unsigned integer value */
int ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val)
{
    EncAssert(enc, tag != 0x01);
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t cbLength;
        cbLength = _BERGetLength(val, c_U32LengthTable, ARRAY_SIZE(c_U32LengthTable));
        if (ASN1BEREncLength(enc, cbLength))
        {
            switch (cbLength)
            {
            case 5:
                *enc->pos++ = 0;
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)(val >> 24);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)(val >> 16);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(val >> 8);
                // lonchanc: intentionally fall through
            case 1:
                *enc->pos++ = (ASN1octet_t)(val);
                break;
            }
            return 1;
        }
    }
    return 0;
}


// THE FOLLOWING IS FROM BERDECOD.C

/* check if len octets are left in decoding stream */
int ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    // We need to ensure:
    // 1) that dec->pos + len doesn't cause an arithmetic overflow 
    // 2) dec->pos + len doesn't exceed the size of our buffer
    if (dec->pos + len >= dec->pos && 
        dec->pos + len <= dec->buf + dec->size)
    {
        return 1;
    }

    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

int _BERDecPeekCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    return ((dec->pos + len <= dec->buf + dec->size) ? 1 : 0);
}

/* start decoding of a constructed value */
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    // safety net
    DecAssert(dec, NULL != dd);
    if (dd != NULL)
    {
        *dd = dec;
    }

#ifdef XBOX_SPECIFIC_OPTIMIZATIONS
    // lonchanc: this does not work because open type can be the last component and
    // the open type decoder needs to peek a tag. as a result, we may peek the tag
    // outside the buffer boundary.
    if (ppBufEnd && (! infinite))
    {
        *ppBufEnd = dec->pos + len;
        return 1;
    }
#endif

    /* initialize a new decoding stream as child of running decoding stream */
    if (ASN1_CreateDecoder(dec->pScratchMemoryAllocator, dec->module, dd,
        dec->pos, infinite ? dec->size - (ASN1uint32_t) (dec->pos - dec->buf) : len, dec) >= 0)
    {
        /* set pointer to end of decoding stream if definite length case selected */
        *ppBufEnd = infinite ? NULL : (*dd)->buf + (*dd)->size;
        return 1;
    }

    return 0;
}

/* decode a tag value; return constructed bit if desired */
int ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed)
{
    ASN1uint32_t tagvalue, tagclass, c;

    /* get tag class and value */
    if (ASN1BERDecCheck(dec, 1))
    {
        tagclass = *dec->pos & 0xe0;
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (ASN1BERDecCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* extract constructed bit if wanted */
        if (constructed)
        {
            *constructed = tagclass & 0x20;
            tagclass &= ~0x20;
        }

        /* check if tag equals desires */
        if (tag == ((tagclass << 24) | tagvalue))
        {
            return 1;
        }

        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
    }
    return 0;
}

/* decode length */
int ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite)
{
    // default is definite length
    if (infinite)
    {
        *infinite = 0;
    }

    /* get length and infinite flag */
    if (ASN1BERDecCheck(dec, 1))
    {
        ASN1uint32_t l = *dec->pos++;
        if (l < 0x80)
        {
            *len = l;
        }
        else
        if (l == 0x80)
        {
            *len = 0;
            if (infinite)
            {
                *infinite = 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        if (l <= 0x84)
        {
            ASN1uint32_t i = l - 0x80;
            if (ASN1BERDecCheck(dec, i))
            {
                l = 0;
                switch (i)
                {
                case 4:
                    l = *dec->pos++ << 24;
                    /*FALLTHROUGH*/
                case 3:
                    l |= *dec->pos++ << 16;
                    /*FALLTHROUGH*/
                case 2:
                    l |= *dec->pos++ << 8;
                    /*FALLTHROUGH*/
                case 1:
                    l |= *dec->pos++;
                    break;
                }
                *len = l;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* check if enough octets left if length is known */
        if (!infinite || !*infinite)
        {
            return ASN1BERDecCheck(dec, *len);
        }
        return 1;
    }

    return 0;
}

/* decode an explicit tag */
int ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    ASN1uint32_t len, infinite;

    // safety net
    if (dd)
    {
        *dd = dec;
    }

    /* skip the constructed tag */
    if (ASN1BERDecTag(dec, tag | 0x20000000, NULL))
    {
        /* get the length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            /* start decoding of constructed value */
            if (! dd)
            {
                *ppBufEnd = infinite ? NULL : dec->pos + len;
                return 1;
            }
            return _BERDecConstructed(dec, len, infinite, dd, ppBufEnd);
        }
    }
    return 0;
}

/* decode octet string value (helper function) */
int _BERDecOctetStringWorker(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy, ASN1uint32_t nMaxRecursionDepth)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* BUG 750698: Limit the recursion depth for octet strings */ 
    if (nMaxRecursionDepth-- == 0) 
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return -1; /* max recursion depth exceeded */ 
    }

    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (! constructed)
            {
                val->length = len;
                if (fNoCopy)
                {
                    val->value = dec->pos;
                    dec->pos += len;
                    return 1;
                }
                else
                {
                    if (len)
                    {
#ifdef XBOX_SPECIFIC_OPTIMIZATIONS
                        val->value = dec->pos;
                        dec->pos += len;
                        return 1;
#else
                        val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                        if (val->value)
                        {
                            RtlCopyMemory(val->value, dec->pos, len);
                            dec->pos += len;
                            return 1;
                        }
#endif
                    }
                    else
                    {
                        val->value = NULL;
                        return 1;
                    }
                }
            }
            else
            {
                ASN1octetstring_t o;
                val->length = 0;
                val->value = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        int nRet; 

                        o.length = 0;
                        o.value = NULL;

                        nRet = _BERDecOctetStringWorker(dd, 0x4, &o, fNoCopy, nMaxRecursionDepth);

                        if (-1 == nRet) /* max recursion depth exceeded */ 
                        {
                            /* propagate the error */
                            return nRet;
                        }
                        else if (nRet)
                        {
                            if (o.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = o;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                                                val->length + o.length);
                                if (val->value)
                                {
                                    /* concat octet strings */
                                    RtlCopyMemory(val->value + val->length, o.value, o.length);
                                    val->length += o.length;

                                    /* free unused octet string */
                                    DecMemFree(dec, o.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
        }
    }
    return 0;
}

/* define the maximum allowed recursion depth for octet strings */ 
#define MAX_OCTET_STRING_DEPTH 2

/* decode octet string value */
int _BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy)
{
    int nRet = _BERDecOctetStringWorker(dec, tag, val, fNoCopy, MAX_OCTET_STRING_DEPTH); 

    if (-1 == nRet)
    {
        nRet = 0;
    }
    return nRet; 
}

/* decode octet string value, making copy */
int ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, FALSE);
}

/* decode octet string value, no copy */
int ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, TRUE);
}

/* peek the following tag without advancing the read position */
int ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag)
{
    ASN1uint32_t tagvalue, tagclass, c;
    ASN1octet_t *p;

    *tag = 0; // invalid tag
    if (_BERDecPeekCheck(dec, 1))
    {
        p = dec->pos;

        /* get tagclass without primitive/constructed bit */
        tagclass = *dec->pos & 0xc0;

        /* get tag value */
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (_BERDecPeekCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* return tag */
        *tag = ((tagclass << 24) | tagvalue);

        /* reset decoding position */
        dec->pos = p;
        return 1;
    }
    return 0;
}

/* decode boolean into ASN1boot_t */
int ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len >= 1)
            {
                DecAssert(dec, len == 1);
                *val = *dec->pos ? 1 : 0;
                dec->pos += len; // self defensive
                return 1;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 32 bit value */
int ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val)
{
    ASN1uint32_t len;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                switch (len)
                {
                case 1:
                    *val = *dec->pos++;
                    break;
                case 2:
                    *val = (*dec->pos << 8) | dec->pos[1];
                    dec->pos += 2;
                    break;
                case 3:
                    *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    break;
                case 4:
                    *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                    break;
                case 5:
                    if (! *dec->pos)
                    {
                        *val = (dec->pos[1] << 24) | (dec->pos[2] << 16) |
                            (dec->pos[3] << 8) | dec->pos[4];
                        dec->pos += 5;
                        break;
                    }
                    // intentionally fall through
                default:
                    ASN1DecSetError(dec, ASN1_ERR_LARGE);
                    return 0;
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 0;
}

int ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd)
{
    ASN1error_e err = ASN1_ERR_CORRUPT;

    if (! dd)
    {
        dd = dec;
    }

    DecAssert(dec, NULL != dd);

    if (pBufEnd)
    {
        /* end of definite length case: */
        /* check if decoded up to end of contents */
        if (dd->pos == pBufEnd)
        {
            dec->pos = pBufEnd;
            err = ASN1_SUCCESS;
        }
    }
    else
    {
        /* end of infinite length case: */
        /* expect end-of-contents octets */
        if (ASN1BERDecCheck(dd, 2))
        {
            if (0 == dd->pos[0] && 0 == dd->pos[1])
            {
                dd->pos += 2;
                if (dd != dec)
                {
                    /* finit child decoding stream and update parent decoding stream */
                    dec->pos = dd->pos;
                }
                err = ASN1_SUCCESS;
            }
        }
        else
        {
            err = ASN1_ERR_EOD;
        }
    }

    if (dd && dd != dec)
    {
        ASN1_CloseDecoder(dd);
    }

    if (ASN1_SUCCESS == err)
    {
        return 1;
    }

    ASN1DecSetError(dec, err);
    return 0;
}

/* check if end of contents (of a constructed value) has been reached */
int ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *pBufEnd)
{
    return (pBufEnd ?
                (dec->pos < pBufEnd) :
                (ASN1BERDecCheck(dec, 2) && (dec->pos[0] || dec->pos[1])));
}


#ifdef ENABLE_BER

typedef struct
{
    ASN1octet_t        *pBuf;
    ASN1uint32_t        cbBufSize;
}
    CER_BLK_BUF;

typedef struct
{
    ASN1blocktype_e     eBlkType;
    ASN1encoding_t      encPrimary;
    ASN1encoding_t      encSecondary;
    ASN1uint32_t        nMaxBlkSize;
    ASN1uint32_t        nCurrBlkSize;
    CER_BLK_BUF        *aBlkBuf;
}
    CER_BLOCK;

#define MAX_INIT_BLK_SIZE   16

int ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) EncMemAlloc(enc, sizeof(CER_BLOCK));
    if (NULL != pBlk)
    {
        EncAssert(enc, ASN1_DER_SET_OF_BLOCK == eBlkType);
        pBlk->eBlkType = eBlkType;
        pBlk->encPrimary = enc;
        pBlk->encSecondary = NULL;
        pBlk->nMaxBlkSize = MAX_INIT_BLK_SIZE;
        pBlk->nCurrBlkSize = 0;
        pBlk->aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(enc, MAX_INIT_BLK_SIZE * sizeof(CER_BLK_BUF));
        if (NULL != pBlk->aBlkBuf)
        {
            *ppBlk_ = (void *) pBlk;
            return 1;
        }
        EncMemFree(enc, pBlk);
    }
    return 0;
}

int ASN1CEREncNewBlkElement(void *pBlk_, ASN1encoding_t *enc2)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    if (NULL == pBlk->encSecondary)
    {
        if (ASN1_SUCCESS == ASN1_CreateEncoder(pBlk->encPrimary->pScratchMemoryAllocator, pBlk->encPrimary->module,
                                               &(pBlk->encSecondary),
                                               NULL, 0, pBlk->encPrimary))
        {
            pBlk->encSecondary->eRule = pBlk->encPrimary->eRule;
            *enc2 = pBlk->encSecondary;
            return 1;
        }
    }
    else
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) (*enc2 = pBlk->encSecondary);

        RtlZeroMemory(e, sizeof(*e));
        e->info.magic = MAGIC_ENCODER;
        // e->info.err = ASN1_SUCCESS;
        // e->info.pos = e->info.buf = NULL;
        // e->info.size = e->info.len = e->info.bit = 0;
        // e->info.dwFlags = 0;
        e->info.module = pBlk->encPrimary->module;
        e->info.eRule = pBlk->encPrimary->eRule;

        ((ASN1INTERNencoding_t) pBlk->encPrimary)->child = e;
        e->parent = (ASN1INTERNencoding_t) pBlk->encPrimary;
        // e->child = NULL;

        // e->mem = NULL;
        // e->memlength = 0;
        // e->memsize = 0;
        // e->epi = NULL;
        // e->epilength = 0;
        // e->episize = 0;
        // e->csi = NULL;
        // e->csilength = 0;
        // e->csisize = 0;

        if (ASN1BEREncCheck((ASN1encoding_t) e, 1))
        {
            // lonchanc: make sure the first byte is zeroed out, which
            // is required for h245.
            e->info.buf[0] = '\0';
            return 1;
        }
    }

    *enc2 =  NULL;
    return 0;
}

int ASN1CEREncFlushBlkElement(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encSecondary;
    ASN1uint32_t i;

    if (ASN1BEREncFlush(enc))
    {
        // make sure we have enough space...
        if (pBlk->nCurrBlkSize >= pBlk->nMaxBlkSize)
        {
            CER_BLK_BUF *aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(pBlk->encPrimary, (pBlk->nMaxBlkSize << 1) * sizeof(CER_BLK_BUF));
            if (NULL != aBlkBuf)
            {
                RtlCopyMemory(aBlkBuf, pBlk->aBlkBuf, pBlk->nMaxBlkSize * sizeof(CER_BLK_BUF));
                EncMemFree(pBlk->encPrimary, pBlk->aBlkBuf);
                pBlk->aBlkBuf = aBlkBuf;
                pBlk->nMaxBlkSize <<= 1;
            }
            else
            {
                return 0;
            }
        }

        if (pBlk->encPrimary->eRule & (ASN1_BER_RULE_DER | ASN1_BER_RULE_CER))
        {
            // we need to sort these octet strings
            for (i = 0; i < pBlk->nCurrBlkSize; i++)
            {
                if (0 >= My_memcmp(enc->buf, enc->len, pBlk->aBlkBuf[i].pBuf, pBlk->aBlkBuf[i].cbBufSize))
                {
                    ASN1uint32_t cnt = pBlk->nCurrBlkSize - i;
                    ASN1uint32_t j;
                    for (j = pBlk->nCurrBlkSize; cnt--; j--)
                    {
                        pBlk->aBlkBuf[j] = pBlk->aBlkBuf[j-1];
                    }
                    // i is the place to hold the new one
                    break;
                }
            }
        }
        else
        {
            EncAssert(enc, ASN1_BER_RULE_BER == pBlk->encPrimary->eRule);
            i = pBlk->nCurrBlkSize;
        }

        // remeber the new one.
        pBlk->aBlkBuf[i].pBuf = enc->buf;
        pBlk->aBlkBuf[i].cbBufSize = enc->len;
        pBlk->nCurrBlkSize++;
        
        // clean up the encoder structure
        enc->buf = enc->pos = NULL;
        enc->size = enc->len = 0;
        return 1;
    }
    return 0;
}

int ASN1CEREncEndBlk(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encPrimary;
    ASN1uint32_t cbTotalSize = 0;
    ASN1uint32_t i;
    int fRet = 0;

    // calculate the total size for all the buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        cbTotalSize += pBlk->aBlkBuf[i].cbBufSize;
    }

    if (ASN1BEREncCheck(enc, cbTotalSize))
    {
        for (i = 0; i < pBlk->nCurrBlkSize; i++)
        {
            ASN1uint32_t cbBufSize = pBlk->aBlkBuf[i].cbBufSize;
            RtlCopyMemory(enc->pos, pBlk->aBlkBuf[i].pBuf, cbBufSize);
            enc->pos += cbBufSize;
        }
        fRet = 1;
    }

    // free these block buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        EncMemFree(enc, pBlk->aBlkBuf[i].pBuf);
    }

    // free the block buffer array
    EncMemFree(enc, pBlk->aBlkBuf);

	// free the secondary encoder structure
	ASN1_CloseEncoder(pBlk->encSecondary);

    // free the block structure itself.
    EncMemFree(enc, pBlk);

    return fRet;
}

#endif // ENABLE_BER

/* encode explicit tag */
int ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag | 0x20000000))
    {
        /* encode infinite length */
        if (ASN1BEREncCheck(enc, 1))
        {
            if (ASN1_BER_RULE_CER != enc->eRule)
            {
                // BER and DER always use definite length form.
                /* return the place to hold the length */
                *pnLenOff = (ASN1uint32_t) (enc->pos++ - enc->buf);
            }
            else
            {
                // CER sub-rule always use indefinite length form.
                *enc->pos++ = 0x80;
                *pnLenOff = 0;
            }
            return 1;
        }
    }
    return 0;
}

/* encode definite length */
int ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t nLenOff)
{
    if (ASN1_BER_RULE_CER != enc->eRule)
    {
        ASN1octet_t *pbLen = enc->buf + nLenOff;
        ASN1uint32_t len = (ASN1uint32_t) (enc->pos - pbLen - 1);
        ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

        //ASN1uint32_t i;

        if (cbLength == 1)
        {
            *pbLen = (ASN1octet_t) len;
            return 1;
        }

        // we have to move the octets upward by cbLength-1
        // --cbLength;
        if (ASN1BEREncCheck(enc, cbLength-1))
        {
            // update pbLen because enc->buf may change due to realloc.
            pbLen = enc->buf + nLenOff;

            // move memory
            RtlMoveMemory(pbLen + cbLength, pbLen + 1, len);

            // put the length
            enc->pos = pbLen;
            _BERPutLength(enc, len, cbLength);
            EncAssert(enc, enc->pos == pbLen + cbLength);

            // set up new position pointer.
            // now enc->pos is at the beginning of contents.
            enc->pos += len;
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0 == nLenOff);
        if (ASN1BEREncCheck(enc, 2))
        {
            *enc->pos++ = 0;
            *enc->pos++ = 0;
            return 1;
        }
    }
    return 0;
}


// The following is for CryptoAPI

#ifdef ENABLE_BER

 // max num of octets, ceiling of 64 / 7, is 10
#define MAX_BYTES_PER_NODE      10

ASN1uint32_t _BEREncOidNode64(ASN1encoding_t enc, unsigned __int64 n64, ASN1octet_t *pOut)
{
    ASN1uint32_t Low32, i, cb;
    ASN1octet_t aLittleEndian[MAX_BYTES_PER_NODE];

    RtlZeroMemory(aLittleEndian, sizeof(aLittleEndian));
    for (i = 0; n64 != 0; i++)
    {
        Low32 = *(ASN1uint32_t *) &n64;
        aLittleEndian[i] = (ASN1octet_t) (Low32 & 0x7f);
        n64 = Int64ShrlMod32(n64, 7);
    }
    cb = i ? i : 1; // at least one byte for zero value
    EncAssert(enc, cb <= MAX_BYTES_PER_NODE);
    if (cb > MAX_BYTES_PER_NODE)
    {
        cb = MAX_BYTES_PER_NODE;
    }
    for (i = 0; i < cb; i++)
    {
        EncAssert(enc, 0 == (0x80 & aLittleEndian[cb - i - 1]));
        *pOut++ = (ASN1octet_t) (0x80 | aLittleEndian[cb - i - 1]);
    }
    *(pOut-1) &= 0x7f;
    return cb;
}


ASN1uint32_t _BERDecOidNode64(unsigned __int64 *pn64, ASN1octet_t *pIn)
{
    ASN1uint32_t c;
    *pn64 = 0;
    for (c = 1; TRUE; c++)
    {
        *pn64 = Int64ShllMod32(*pn64, 7) + (unsigned __int64) (*pIn & 0x7f);
        if (!(*pIn++ & 0x80))
        {
            return c;
        }
    }
    return 0;
}


/* encode an object identifier value */
int ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        int rc = ASN1BEREncLength(enc, val->length);
        if (rc)
        {
            /* copy value */
            RtlCopyMemory(enc->pos, val->value, val->length);
            enc->pos += val->length;
        }
        return rc;
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    val->length = 0; // safety net
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            val->length = (ASN1uint16_t) len;
            if (len)
            {
                val->value = (ASN1octet_t *) DecMemAlloc(dec, len);
                if (val->value)
                {
                    RtlCopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                val->value = NULL;
                return 1;
            }
        }
    }
    return 0;
}


void ASN1BEREoid_free(ASN1encodedOID_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}

#endif // ENABLE_BER

static const ASN1uint8_t
c_aBitMask[] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff
};

static const ASN1uint8_t
c_aBitMask4[] = {
    0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00
};

static const ASN1int32_t
c_aBitMask5[] = {
    (ASN1int32_t)0xffffffff, (ASN1int32_t)0xfffffffe,
    (ASN1int32_t)0xfffffffc, (ASN1int32_t)0xfffffff8,
    (ASN1int32_t)0xfffffff0, (ASN1int32_t)0xffffffe0,
    (ASN1int32_t)0xffffffc0, (ASN1int32_t)0xffffff80,
    (ASN1int32_t)0xffffff00, (ASN1int32_t)0xfffffe00,
    (ASN1int32_t)0xfffffc00, (ASN1int32_t)0xfffff800,
    (ASN1int32_t)0xfffff000, (ASN1int32_t)0xffffe000,
    (ASN1int32_t)0xffffc000, (ASN1int32_t)0xffff8000,
    (ASN1int32_t)0xffff0000, (ASN1int32_t)0xfffe0000,
    (ASN1int32_t)0xfffc0000, (ASN1int32_t)0xfff80000,
    (ASN1int32_t)0xfff00000, (ASN1int32_t)0xffe00000,
    (ASN1int32_t)0xffc00000, (ASN1int32_t)0xff800000,
    (ASN1int32_t)0xff000000, (ASN1int32_t)0xfe000000,
    (ASN1int32_t)0xfc000000, (ASN1int32_t)0xf8000000,
    (ASN1int32_t)0xf0000000, (ASN1int32_t)0xe0000000,
    (ASN1int32_t)0xc0000000, (ASN1int32_t)0x80000000,
    (ASN1int32_t)0x00000000
};

static const ASN1uint8_t
c_aBitCount[] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/* copy nbits bits from src/srcbit into dst/dstbit;
   src points to first octet containing bits to be copied
   srcbit names the first bit within the first octet to be copied (0=msb, 7=lsb)
   dst points to first octet to copy into
   dstbit names the first bit within the first octet to copy into (0=msb, 7=lsb)
   nbits is the number of bits to copy;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit, xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }

    /* check if we have to fill broken first octet */
    if (dstbit) {
        xdstbit = 8 - dstbit;

        /* enough bits to fill up broken octet? */
        if (nbits >= xdstbit) {
            if (srcbit < dstbit) {
                *dst++ |= (*src >> (dstbit - srcbit)) & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit += xdstbit;
                dstbit = 0;
            } else if (srcbit == dstbit) {
                *dst++ |= *src++ & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit = 0;
                dstbit = 0;
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    (src[1] >> (8 - (srcbit - dstbit)));
                nbits -= xdstbit;
                src++;
                srcbit -= dstbit;
                dstbit = 0;
            }

        /* less bits to fill than needed to fill up the broken octet */
        } else {
            if (srcbit <= dstbit) {
                *dst |= ((*src >> (8 - srcbit - nbits)) & c_aBitMask[nbits]) <<
                    (xdstbit - nbits);
            } else {
                *dst |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)); 
                if (nbits > 8 - srcbit) {
                    /* we have src bits beyond the first byte */ 
                    *dst |= ((src[1] >> (16 - srcbit - nbits)) << (xdstbit - nbits));
                }
            }
            return;
        }
    }

    /* fill up complete octets */
    if (nbits >= 8) {
        if (!srcbit) {
            RtlCopyMemory(dst, src, nbits / 8);
            dst += nbits / 8;
            src += nbits / 8;
            nbits &= 7;
        } else {
            xsrcbit = 8 - srcbit;
            do {
                *dst++ = (*src << srcbit) | (src[1] >> (xsrcbit));
                src++;
                nbits -= 8;
            } while (nbits >= 8);
        }
    }

    /* fill bits into last octet */
    if (nbits)
        {
                *dst = (*src << srcbit) & c_aBitMask2[nbits];
                // lonchanc: made the following fix for the case that
                // src bits across byte boundary.
                if (srcbit + nbits > 8)
                {
                        xsrcbit = nbits - (8 - srcbit);
                        src++;
                        *dst |= ((*src & c_aBitMask2[xsrcbit]) >> (8 - srcbit));
                }
        }
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* clear broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        *dst &= c_aBitMask2[xdstbit];
        if (xdstbit < nbits) {
            dst++;
            nbits -= xdstbit;
        } else {
            return;
        }
    }

    /* clear remaining bits */
    RtlZeroMemory(dst, (nbits + 7) / 8);
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* set broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        if (xdstbit < nbits) {
            *dst |= c_aBitMask4[xdstbit];
            dst++;
            nbits -= xdstbit;
        } else {
            *dst |= c_aBitMask4[nbits] << (xdstbit - nbits);
            return;
        }
    }

    /* set complete octets */
    if (nbits >= 8) {
        memset(dst, 0xff, nbits / 8);
        dst += nbits / 8;
        nbits &= 7;
    }

    /* set remaining bits */
    if (nbits)
        *dst |= c_aBitMask4[nbits] << (8 - nbits);
}

/* write nbits bits of val at dst/dstbit;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    xdstbit = 8 - dstbit;

    /* fill up broken octet first */
    if (dstbit) {
        if (xdstbit <= nbits) {
            *dst++ |= val >> (nbits -= xdstbit);
        } else {
            *dst |= (val & c_aBitMask[nbits]) << (xdstbit - nbits);
            return;
        }
    }

    /* copy complete octets */
    while (nbits >= 8)
        *dst++ = (ASN1octet_t) (val >> (nbits -= 8));

    /* copy left bits */
    if (nbits)
        *dst = (ASN1octet_t) ((val & c_aBitMask[nbits]) << (8 - nbits));
}

/* read nbits bits of val at src/srcbit */
// lonchanc: the return value is independent of big or little endian
// because we use shift left within a long integer.
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = (*src++ & c_aBitMask[xsrcbit]) << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* read nbits bits of val at src/srcbit */
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1int32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    if (*src & (0x80 >> srcbit))
        ret = c_aBitMask5[nbits];
    else
        ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = *src++ << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* get number of set bits in nbits bits at src/srcbit */
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;

    /* count bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = c_aBitCount[*src++ & c_aBitMask4[srcbit]];
            nbits -= xsrcbit;
        } else {
            return c_aBitCount[(*src >> (xsrcbit - nbits)) & c_aBitMask[nbits]];
        }
    } else {
        ret = 0;
    }

    /* count bits in complete octets */
    while (nbits >= 8)
	{
        ret += c_aBitCount[*src++];
		nbits -= 8;
	}

    /* count left bits */
    if (nbits)
        ret += c_aBitCount[(*src) & c_aBitMask2[nbits]];
    return ret;
}

/* write noctets of val at dst */
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        *dst++ = (ASN1octet_t)(val >> 24);
        /*FALLTHROUGH*/
    case 3:
        *dst++ = (ASN1octet_t)(val >> 16);
        /*FALLTHROUGH*/
    case 2:
        *dst++ = (ASN1octet_t)(val >> 8);
        /*FALLTHROUGH*/
    case 1:
        *dst++ = (ASN1octet_t)(val);
        break;
    default:
        break;
    }
}

/* read noctets of val at dst */
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        return (*src << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    case 3:
        return (*src << 16) | (src[1] << 8) | src[2];
    case 2:
        return (*src << 8) | src[1];
    case 1:
        return *src;
    default:
        MyAssert(0);
        return(0);
        /*NOTREACHED*/
    }
}

/* check if a 16 bit character is a space */
int ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int ASN1str16len(ASN1char16_t *p)
{
    
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

#ifdef USE_lstrlen
int My_lstrlenA(char *p)
{
    return (NULL != p) ? lstrlenA(p) : 0;
}

int My_lstrlenW(WCHAR *p)
{
    return (NULL != p) ? lstrlenW(p) : 0;
}
#else
int My_lstrlenA( char* lpString )
{
    if (lpString == NULL)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return strlen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return strlen(lpString);
#endif
}

int My_lstrlenW( WCHAR* lpString )
{
    if (lpString == NULL)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return wcslen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return wcslen(lpString);
#endif
}
#endif

/* check if a 32 bit character is a space */
int ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
            c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

/* external use only, allocate memory for decoding */
LPVOID ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size)
{
    return DecMemAlloc(dec, size);
}

/* external use only, reallocate memory for decoding */
LPVOID ASN1DecRealloc(ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size)
{
    return DecMemReAlloc(dec, ptr, size);
}

/* external use only, free a memory block */
void ASN1Free(LPVOID ptr)
{
    MemFree(ptr);
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort decoding, free any memory allocated for decoding */
void ASN1DecAbort(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish decoding */
void ASN1DecDone(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort encoding, free any memory allocated for encoding */
void ASN1EncAbort(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish encoding */
void ASN1EncDone(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}


/* search the identification of an embedded pdv */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1embeddedpdv_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate EP-B encoding) and return */
    for (*index = 0, id = e->epi; *index < e->epilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1embeddedpdv_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->epilength >= e->episize) {
        e->episize = e->episize ? 4 * e->episize : 16;
        e->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(e->epi,
            e->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->epi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->epi[e->epilength++] = identification;

    /* return flag for EP-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* search the identification of an character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1characterstring_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate CS-B encoding) and return */
    for (*index = 0, id = e->csi; *index < e->csilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1characterstring_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->csilength >= e->csisize) {
        e->csisize = e->csisize ? 4 * e->csisize : 16;
        e->csi = (ASN1characterstring_identification_t **)MemReAlloc(e->csi,
            e->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->csi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->csi[e->csilength++] = identification;

    /* return flag for CS-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* allocate and copy an object identifier */
#if defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)
int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;
    ASN1uint32_t l = GetObjectIdentifierCount(*src);
    *dst = DecAllocObjectIdentifier(dec, l);
    if (! *dst)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
        return 0;
    }
    CopyObjectIdentifier(*dst, *src);
    return 1;
}
#endif // defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)

/* add an embedded pdv identification to the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification)
{
    if (d->epilength >= d->episize) {
        d->episize = d->episize ? 4 * d->episize : 16;
        d->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(d->epi,
            d->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->epi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->epi[d->epilength++] = identification;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* get an embedded pdv identification from the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->epilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->epi[index];
}
#endif // ENABLE_EMBEDDED_PDV

/* add a character string identification to the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification)
{
    if (d->csilength >= d->csisize) {
        d->csisize = d->csisize ? 4 * d->csisize : 16;
        d->csi = (ASN1characterstring_identification_t **)MemReAlloc(d->csi,
            d->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->csi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->csi[d->csilength++] = identification;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* get a character string identification from the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->csilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->csi[index];
}
#endif // ENABLE_GENERALIZED_CHAR_STR

ASN1error_e ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err)
{
    ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) enc;
    EncAssert(enc, ASN1_SUCCESS <= err);
    while (e)
    {
        e->info.err = err;
        if (e == e->parent)
        {
            break;
        }
        e = e->parent;
    }
    return err;
}

ASN1error_e ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    DecAssert(dec, ASN1_SUCCESS <= err);
    while (d)
    {
        d->info.err = err;
        if (d == d->parent)
        {
            break;
        }
        d = d->parent;
    }
    return err;
}

// Memory manager for decoder
LPVOID DecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize )
{
    ASN1uint32_t cbSizeUnaligned = cbSize; 
    LPVOID lp = NULL;
    ASN1INTERNdecoding_t lpInfo = (ASN1INTERNdecoding_t) dec;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    lpInfo->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (lpInfo->fExtBuf)
    {
        if (lpInfo->cbRemExtBufSize >= cbSize)
        {
            lp = lpInfo->lpRemExtBuf;
            lpInfo->lpRemExtBuf += cbSize;
            lpInfo->cbRemExtBufSize -= cbSize;
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
        if (cbSizeUnaligned > cbSize) { 
            //
            // Check for arithmetic overflow (caused by ASN1_SIZE_ALIGNED)
            //
            lp = NULL; 
        } else { 
            lp = MemAllocEx(dec, cbSize, TRUE); // zero memory
        }
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}

void DecMemFree ( ASN1decoding_t dec, LPVOID lpData )
{
    if (! ((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        MemFree(lpData);
    }
}

LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize )
{
    ASN1uint32_t cbSizeUnaligned = cbSize; 
    LPVOID lp = NULL;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    ((ASN1INTERNdecoding_t) dec)->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        if (lpData == NULL)
        {
            lp = DecMemAlloc(dec, cbSizeUnaligned);
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
        if (cbSizeUnaligned > cbSize) { 
            //
            // Check for arithmetic overflow (caused by ASN1_SIZE_ALIGNED)
            //
            lp = NULL; 
        } else { 
            lp = MemReAllocEx(dec, lpData, cbSize, TRUE); // zero memory
        }
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}



/***
*char *ms_bSearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        char *lo = (char *)base;
        char *hi = (char *)base + (num - 1) * width;
        char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}


int IsDigit(char p)
{
      return ((p >= ('0')) && (p <=('9'))) ? 1 : 0 ;
}



// BUGBUG - This is a copy of the same routine in nmutil
// BUGBUG - Remove this when we convert our files to CPP and use nmutil
/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch)
{
	unsigned int uRet = 0;
	char * pszStr =  pcszString;
	while (cch-- && ('\0') != pszStr[0])
	{
		uRet = (10 * uRet) + (int) (pszStr[0] - ('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size)
{
    int diff;
    ASN1uint32_t cbMinBufSize = (cbBuf1Size < cbBuf2Size) ? cbBuf1Size : cbBuf2Size;
    while (cbMinBufSize--)
    {
        diff = (int) (ASN1uint32_t) *pBuf1++ - (int) (ASN1uint32_t) *pBuf2++;
        if (0 != diff)
        {
            return diff;
        }
    }
    return ((int) cbBuf1Size - (int) cbBuf2Size);
}
#endif // ENABLE_BER

#ifdef ENABLE_DOUBLE

const ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
const ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_pinf_octets));
    RtlCopyMemory(&val, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_minf_octets));
    RtlCopyMemory(&val, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

#endif

/* convert a real value into a double */
#ifdef ENABLE_REAL
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                if (! ASN1intx_dup(&exp, &val->exponent))
                {
                    return 0.0;
                }
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}
#endif // ENABLE_REAL

/* free a real value */
#ifdef ENABLE_REAL
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}
#endif // ENABLE_REAL

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    if (val)
    {
        // lonchanc: we allocate the entire object identifer as a chunk.
        // as a result, we free it only once as a chunk.
        MemFree(*val);
    }
}

/* free a string value */
#ifdef ENABLE_BER
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free a 32 bit string value */
#ifdef ENABLE_BER
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    MemFree(val);
}

/* free a zero-terminated 16 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free a zero-terminated 32 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free an external value */
#ifdef ENABLE_EXTERNAL
void ASN1external_free(ASN1external_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1external_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1external_identification_presentation_context_id_o:
            break;
        case ASN1external_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        }
        ASN1ztcharstring_free(val->data_value_descriptor);
        switch (val->data_value.o)
        {
        case ASN1external_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1external_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EXTERNAL

/* free an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EMBEDDED_PDV

/* free a character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1characterstring_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1characterstring_data_value_encoded_o:
            ASN1octetstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* free an open type value */
#ifdef ENABLE_BER
void ASN1open_free(ASN1open_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->encoded);
    }
}
#endif // ENABLE_BER

#ifdef ENABLE_BER
void ASN1utf8string_free(ASN1wstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    if (dst && val)
    {
        sprintf(dst, "%04d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->millisecond) {
            if (!(val->millisecond % 100))
                sprintf(dst + 14, ".%01d", val->millisecond / 100);
            else if (!(val->millisecond % 10))
                sprintf(dst + 14, ".%02d", val->millisecond / 10);
            else
                sprintf(dst + 14, ".%03d", val->millisecond);
        }
        if (val->universal)
            strcpy(dst + My_lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}

/* convert a utc time value into a string */
#ifdef ENABLE_BER
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    if (dst && val)
    {
        sprintf(dst, "%02d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->universal)
            strcpy(dst + My_lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_BER

//
// scan the decimal fraction of a number based on the base
// base must be a power of 10
//
static DWORD scanfrac(char *p, char **e, DWORD base)
{
    DWORD ret = 0;

    while (IsDigit(*p)) {
        if (base != 1)
        {
            base /= 10;
            ret = (ret * 10) + (*p++ - '0');
        }
        else
        {
            p++;
        }
    }
    *e = p;
    return ret * base;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    if (dst && val)
    {
        int year, month, day, hour, minute, second, millisecond, diff, universal;
        char *p;
        DWORD frac;
        DWORD temp;

        millisecond = second = minute = universal = diff = 0;
        if (My_lstrlenA(val) < 10)
        {
            return 0;
        }
        year = DecimalStringToUINT(val, 4);
        month = DecimalStringToUINT((val+4), 2);
        day = DecimalStringToUINT((val+6), 2);
        hour = DecimalStringToUINT((val+8), 2);
        p = val + 10;
        if (*p == '.' || *p == ',')
        {
            const DWORD base = 10000000;
            frac = scanfrac(p+1, &p, base);
            temp = frac * 60;
            minute = (temp / base);
            frac = temp % base;
            temp = frac * 60;
            second = (temp / base);
            frac = temp % base;
            millisecond = (frac / (base / 1000) );
        }
        else if (IsDigit(*p))
        {
            minute = DecimalStringToUINT(p, 2);
            p += 2;
            if (*p == '.' || *p == ',')
            {
                const DWORD base = 100000;
                frac = scanfrac(p+1, &p, base);
                temp = frac * 60;
                second = (temp / base);
                frac = temp % base;
                millisecond = (frac / (base / 1000) );
            } else if (IsDigit(*p))
            {
                second = DecimalStringToUINT(p, 2);
                p += 2;
                if (*p == '.' || *p == ',')
                {
                    const DWORD base = 1000;
                    frac = scanfrac(p+1, &p, base);
                    millisecond = frac;
                }
            }
        }
        if (*p == 'Z')
        {
            universal = 1;
            p++;
        }
        else if (*p == '+')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            diff = frac / (base/100) * 60 + frac % 100;
        }
        else if (*p == '-')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            diff = -((int)(frac / (base/100) * 60 + frac % 100));
        }
        if (*p)
        {
            return 0;
        }
        dst->year = (ASN1uint16_t)year;
        dst->month = (ASN1uint8_t)month;
        dst->day = (ASN1uint8_t)day;
        dst->hour = (ASN1uint8_t)hour;
        dst->minute = (ASN1uint8_t)minute;
        dst->second = (ASN1uint8_t)second;
        dst->millisecond = (ASN1uint16_t)millisecond;
        dst->universal = (ASN1bool_t)universal;
        dst->diff = (ASN1uint16_t)diff;
        return 1;
    }
    return 0;
}

/* convert a string into a utc time value */
#ifdef ENABLE_BER
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    if (dst && val)
    {
        char *p;
        DWORD frac;

        if (My_lstrlenA(val) < 10)
            return 0;

        p = val;
        dst->year = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->month = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->day = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->hour = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->minute = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;

        if (IsDigit(*p))
        {
            dst->second = (ASN1uint8_t) DecimalStringToUINT(p, 2);
            p += 2;
        }
        else
        {
            dst->second = 0;
        }

        dst->universal = 0;
        dst->diff = 0;

        if (*p == 'Z')
        {
            dst->universal = 1;
            p++;
        }
        else if (*p == '+')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            dst->diff = (int)(frac / (base/100) * 60 + frac % 100);
        }
        else if (*p == '-')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            dst->diff = -((int)(frac / (base/100) * 60 + frac % 100));
        }
        return ((*p) ? 0 : 1);
    }
    return 0;
}
#endif // ENABLE_BER


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while (dst && src)
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) DecMemAlloc(dec, cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        if(cObjIds > 0)
        {
            for (q = p, i = 0; i < cObjIds-1; i++)
            {
                q->value = 0;
                q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
                q = q->next;
            }
            q->next = NULL;
        }
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    DecMemFree(dec, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgblockinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgblockinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// CBlockInfo
// ---------------------------------------------------------------------------------------

DECLARE_HASH_TABLE(BlockInfo);

CBlockInfo *    g_pBlockInfo;           // Vector of all CBlockInfo structures
UINT            g_cBlockInfo;           // Number of CBlockInfo structures allocated
UINT            g_cBlockInfoInUse;      // Number of CBlockInfo structures in use
CBlockInfoHash *g_pBlockInfoHash;       // Hash table mapping {_puid} to CBlockInfo *
LIST_ENTRY      g_leBlockInfoFree;      // Queue of CBlockInfo structures no longer in use in LRU order
LIST_ENTRY      g_leBlockInfoUsed;      // Queue of CBlockInfo structures in use in LRU order
CLock           g_lockBlockInfo;        // Synchronizes CBlockInfo setup                                        
CTimer          g_blockInfoTimer;       // Frees expired blocks

#define BLOCK_INFO_TIMER_INTERVAL_SECONDS 60

BOOL SgBlockInfoInit()
{
    Assert(g_pBlockInfo == NULL);
    Assert(g_cBlockInfo == 0);
    Assert(g_cBlockInfoInUse == 0);
    Assert(g_pBlockInfoHash == NULL);
    Assert(g_leBlockInfoFree.Flink == NULL);
    Assert(g_leBlockInfoFree.Blink == NULL);
    Assert(g_leBlockInfoUsed.Flink == NULL);
    Assert(g_leBlockInfoFree.Blink == NULL);
    InitializeListHead(&g_leBlockInfoFree);
    InitializeListHead(&g_leBlockInfoUsed);
    g_lockBlockInfo.Init();
    g_blockInfoTimer.Init();
    return(TRUE);
}

void SgBlockInfoTerm()
{
    SgMemFree(g_pBlockInfo);
    delete g_pBlockInfoHash;

    g_pBlockInfo      = NULL;
    g_cBlockInfo      = 0;
    g_cBlockInfoInUse = 0;
    g_pBlockInfoHash  = NULL;

    // No need to cancel timer -- it will gracefully be cancelled when the Sg terminates
    g_lockBlockInfo.Term();
    memset(&g_leBlockInfoFree, 0, sizeof(LIST_ENTRY));
}

//
// This routine is responsible for taking expired timers off of the used block
// info list and placing them in the free list. This will make the block info
// available for use by another puid
// 
void SgBlockInfoTimer(CTimer*)
{
    ULONGLONG qwTime = SgGetSystemTime();

    // Grab the lock
    SgBlockInfoLock();

    // Walk the in-use list
    PLIST_ENTRY ple, pleNext;
    for (ple = g_leBlockInfoUsed.Flink; ple != &g_leBlockInfoUsed; ple = pleNext) 
    {
        CBlockInfo * pBlockInfo = SgBlockInfoFromUsedLink( ple );
        pleNext = ple->Flink;

        // Does this entry need to be removed?
        if (qwTime >= pBlockInfo->_qwBlockedTimeKeyEx) 
        {
            // Remove this entry from the used list and add it to the 
            // free list. 
            RemoveEntryList( &(pBlockInfo->_leUsed) );
            InsertTailList(&g_leBlockInfoFree, &(pBlockInfo->_leFree) );

            // Make sure that the block is no longer in the hash table.
            // The reason for doing this now instead of during the alloc
            // step (ie: similar to how CCliInfo does it) is that we
            // cannot have SgBlockedInfoIsBlocked() succeed while the
            // element is on the free list. If we don't remove it
            // from the hash table, then IsBlocked() will find it
            g_pBlockInfoHash->Delete(pBlockInfo);

            // BlockInfo is now free. Track Queue Counts
            SgPerfdataInterlockedDec(CurrentBlocked);
            SgPerfdataInterlockedInc(CurrentFreeBlockInfo);
        }
    }

    // Release the lock
    SgBlockInfoUnlock();

    // Reschedule
    SgTimerSet(
        &g_blockInfoTimer,
        SgBlockInfoTimer,
        SgTimerTick() + (BLOCK_INFO_TIMER_INTERVAL_SECONDS * TICKS_PER_SECOND),
        TRUE
        );
}

BOOL SgBlockInfoConfig(UINT cBlockInfo)
{
    g_pBlockInfo = (CBlockInfo *)SgMemAllocZ(cBlockInfo * sizeof(CBlockInfo), PTAG_CBlockInfo);

    if (g_pBlockInfo == NULL)
    {
        TraceSz(Config, "Config error: Out of memory allocating vector of %d CBlockInfo (%d bytes)",
                 cBlockInfo, cBlockInfo * sizeof(CBlockInfo));
        return(FALSE);
    }

    g_pBlockInfoHash = new CBlockInfoHash;

    if (g_pBlockInfoHash == NULL || !g_pBlockInfoHash->Init(cBlockInfo, NULL))
    {
        TraceSz(Config, "Config error: Out of memory allocating CBlockInfoHash (%d entries)",
                 cBlockInfo);
        return(FALSE);
    }

    g_cBlockInfo      = cBlockInfo;
    g_cBlockInfoInUse = 0;

    // Perf counter that tracks number of free blocks
    SgPerfdataSet( CurrentFreeBlockInfo, cBlockInfo );

    // Start the BlockInfoTimer as a Long timer
    SgTimerSet(
        &g_blockInfoTimer, 
        SgBlockInfoTimer, 
        SgTimerTick() + (BLOCK_INFO_TIMER_INTERVAL_SECONDS * TICKS_PER_SECOND),
        TRUE
        );

    TraceSz( Config, "    Configured blocked client history with %u clients in %u hash buckets",
              g_cBlockInfo, g_pBlockInfoHash->GetBucketCount() );

    return(TRUE);
}

BOOL SgBlockInfoBlockPuid(PUID * ppuid, ULONGLONG qwExtraBlockTime)
{
    ULONGLONG qwBlockKeyExTime;

    // Calculate the length of the block
    qwBlockKeyExTime = SgGetSystemTime();
    qwBlockKeyExTime += g_qwKeyExBlockInterval;
    qwBlockKeyExTime += qwExtraBlockTime;

    // Build the record that we will be searching for in the hash table
    CBlockInfo BlockInfo;
    BlockInfo._puid = *ppuid;

    // Grab the lock in order to allocate or find the record for this puid
    SgBlockInfoLock();
    if (g_cBlockInfo == 0)
    {
        // Not yet initialized
        SgPerfdataInterlockedInc(DroppedBlocked);
        SgBlockInfoUnlock();
        return FALSE;
    }

    // Find the block in the hash table. The record might already be
    // allocated, so creating another one would confuse the hash table
    CBlockInfo * pBlockInfo = g_pBlockInfoHash->Lookup(&BlockInfo);
    if (pBlockInfo == NULL)
    {
        // Block doesn't exist, so allocate one
        pBlockInfo = SgBlockInfoAlloc(ppuid);
        if (pBlockInfo == NULL) 
        {
            SgBlockInfoUnlock();
            return FALSE;
        }
    }

    // Remember the length of the block
    pBlockInfo->_qwBlockedTimeKeyEx = qwBlockKeyExTime;

    // Is this entry in the free list? if so, remove it
    if (pBlockInfo->_leFree.Flink != NULL) 
    {
        RemoveEntryList( &(pBlockInfo->_leFree) );
        pBlockInfo->_leFree.Flink = NULL;
    }

    // Release the lock
    SgBlockInfoUnlock();
    return TRUE;
}

void SgBlockInfoUnblockPuid(PUID * ppuid)
{
    ULONGLONG qwBlockKeyExTime = SgGetSystemTime();

    // Build the record that we will be searching for in the hash table
    CBlockInfo BlockInfo;
    BlockInfo._puid = *ppuid;

    // Grab the lock in order find the record for this puid
    SgBlockInfoLock();

    // Find the block in the hash table
    CBlockInfo * pBlockInfo = g_pBlockInfoHash->Lookup(&BlockInfo);
    if (pBlockInfo != NULL)
    {
        // Remember the length of the block
        pBlockInfo->_qwBlockedTimeKeyEx = qwBlockKeyExTime;
    }

    // Release the lock
    SgBlockInfoUnlock();
}

// 
// This routine will take a given PUID and determined if there is a block
// that applies to it.
// 
// Note that this function does not free any expired block infos that it
// finds. It waits for the SgBlockInfoTimer() to come by and clean up
// those entries.
// 
BOOL SgBlockInfoIsBlocked(PUID * ppuid, ULONGLONG *qwBlockTime)
{
    BOOL      bBlocked = FALSE;
    ULONGLONG qwBlockKeyExTime = SgGetSystemTime();

    // Build the record that we will be searching for in the hash table
    CBlockInfo BlockInfo;
    BlockInfo._puid = *ppuid;

    // Grab the lock in order find the record for this puid
    SgBlockInfoLock();

    // Find the block in the hash table
    CBlockInfo * pBlockInfo = g_pBlockInfoHash->Lookup(&BlockInfo);
    if (pBlockInfo != NULL && pBlockInfo->_qwBlockedTimeKeyEx >= qwBlockKeyExTime)
    {
        if (qwBlockTime != NULL) 
        {
            *qwBlockTime = pBlockInfo->_qwBlockedTimeKeyEx;
        }
        bBlocked = TRUE;
    }

    // Release the lock
    SgBlockInfoUnlock();
    return bBlocked;
}

CBlockInfo * SgBlockInfoAlloc(PUID * ppuid)
{
    //
    // This entire routine is called with g_lockBlockInfo lock held
    // 

    CBlockInfo * pBlockInfo;
    if (g_cBlockInfoInUse < g_cBlockInfo)
    {
        pBlockInfo = &g_pBlockInfo[g_cBlockInfoInUse++];
    }
    else if (IsListEmpty(&g_leBlockInfoFree))
    {
        // Attempt to re-use the chronologically oldest CBlockInfo
        // The logic here is that we have to absolutely block the
        // current request, so we are willing to sacrifice someone
        // that we blocked a long time ago.
        // Walk the in-use list
        if (!IsListEmpty(&g_leBlockInfoUsed)) 
        {
            LIST_ENTRY * pleFree = RemoveHeadList(&g_leBlockInfoUsed);
            pBlockInfo = SgBlockInfoFromUsedLink(pleFree);

            // Remove the entry from the hash table
            g_pBlockInfoHash->Delete(pBlockInfo);

            // Perf Counters for correct bookeeping
            SgPerfdataInterlockedDec(CurrentBlocked);
            SgPerfdataInterlockedInc(CurrentFreeBlockInfo);

            // This counts as a dropped item
            SgPerfdataInterlockedInc(DroppedBlocked);
        }
        else
        {             
            // We're out of CBlockInfos. 
            SgEventSz(MAX_BLOCK_LIMIT, "machine puid: 0x%016I64X", ppuid->QuadPart);
            SgPerfdataInterlockedInc(DroppedBlocked);
            return(NULL);
        }
    }
    else
    {
        // Take an unused blockinfo
        LIST_ENTRY * pleFree = RemoveHeadList(&g_leBlockInfoFree);
        pBlockInfo = SgBlockInfoFromFreeLink(pleFree);
    }

    memset(pBlockInfo, 0, sizeof(CBlockInfo));
    pBlockInfo->_puid = *ppuid;

    g_pBlockInfoHash->Insert(pBlockInfo);
    InsertTailList(&g_leBlockInfoUsed, &(pBlockInfo->_leUsed) );

    // Perf Counter
    SgPerfdataInterlockedInc(CurrentBlocked);
    SgPerfdataInterlockedDec(CurrentFreeBlockInfo);

    return(pBlockInfo);
}

DWORD SgBlockInfoHashCompute(CBlockInfo * pBlockInfo)
{
    return (pBlockInfo->_puid.HighPart ^ pBlockInfo->_puid.LowPart);
}

BOOL SgBlockInfoHashCompare(CBlockInfo * pBlockInfo1, CBlockInfo * pBlockInfo2)
{
    return(pBlockInfo1->_puid.QuadPart == pBlockInfo2->_puid.QuadPart);
}

#ifdef SG_FEATURE_XMGMT

// -------------------------------------------------------------------------------------
// SgConnectionBlockedMgmtCmd
//
// Entry point for xmgmt commands with the "blocked" command
// -------------------------------------------------------------------------------------
void SgConnectionBlockedMgmtCmd(CXomParamList * pxompl, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
#define ERR_MSG(fmt, ...) \
    pResponseInterface->WriteResponse( \
        dwRequestId, \
        (BYTE *)CSmallStr().Format(fmt "\r\n", __VA_ARGS__).cstr(), \
        (DWORD) -1)
        

    // Dynamically allocate and grow memory as needed. Seed it to a reasonable starting 
    // value.

    CLargeStr statsText;
    statsText.SetAllocator(CMemAlloc::Default());

    CSpiInfo * pSpiInfo = NULL;

    //
    // Process commands here
    // 
    
    if ( (pxompl->GetCount() == 2 && _strcmpi(pxompl->GetParam(1), "list") == 0) ||
         (pxompl->GetCount() == 1) )
    {
        ULONGLONG qwTimeNow = SgGetSystemTime();
        DWORD numBlocked = 0;
        LIST_ENTRY * ple;

        SgBlockInfoLock();

        // List all blocked machines
        for (ple = g_leBlockInfoUsed.Flink; ple != &g_leBlockInfoUsed; ple = ple->Flink) 
        {
            CBlockInfo * pBlockInfo = SgBlockInfoFromUsedLink( ple );

            if (numBlocked == 0) 
            {
                statsText.Format(
                    "Num %18s Blocked Until\r\n",
                    "Machine Puid"
                    );
            }
            numBlocked++;

            // Give a hint that the time is expired
            statsText.Format(
                "%3d 0x%016I64X %s",
                numBlocked,
                pBlockInfo->_puid,
                SgTimeToStr( pBlockInfo->_qwBlockedTimeKeyEx )
                );
            if (qwTimeNow >= pBlockInfo->_qwBlockedTimeKeyEx) 
            {
                statsText.Format(" (Expired)");
            }
            statsText.Format("\r\n");
        }

        SgBlockInfoUnlock();

        // Display a message if no connection are blocked
        if (numBlocked == 0)
        {
            statsText.Format("No blocked connections at %s\r\n", SgTimeToStr( qwTimeNow ) );
        }
    }
    else if (pxompl->GetCount() == 3 && _strcmpi(pxompl->GetParam(1), "remove") == 0) 
    {
        // Look up machine puid
        ULONGLONG    mpuid = _strtoui64(pxompl->GetParam(2), NULL, 0);
        CBlockInfo   BlockInfo;
        CBlockInfo * pBlockInfo;

        // Find the block if present
        BlockInfo._puid.QuadPart = mpuid;
        SgBlockInfoLock();
        pBlockInfo = g_pBlockInfoHash->Lookup( &BlockInfo );
        SgBlockInfoUnlock();

        // If we have a block, then clear the timer
        if (pBlockInfo != NULL) 
        {
            // Set the block time to 0. Depends on the timer
            // routine to actually clean up the blockInfo entry
            pBlockInfo->_qwBlockedTimeKeyEx = SgGetSystemTime();

            statsText.Format("Machine Puid 0x%016I64X is no longer blocked", mpuid);
        }
        else
        {
            statsText.Format("Machine Puid 0x%016I64X is not blocked", mpuid);
        }
    }
    else if (pxompl->GetCount() == 3 && _strcmpi(pxompl->GetParam(1), "add") == 0) 
    {
        // Look up machine puid
        ULONGLONG    mpuid = _strtoui64(pxompl->GetParam(2), NULL, 0);
        ULONGLONG    qwExtraTime = g_qwKeyExBlockInterval * 4;
        PUID         puid;
        BOOL         result = FALSE;

        // Block the machine
        puid.QuadPart = mpuid;
        result = SgBlockInfoBlockPuid( &puid, qwExtraTime );
        if (result == TRUE) 
        {
            statsText.Format("Machine Puid 0x%016I64X is now blocked", mpuid);
        }
        else
        {
            statsText.Format("Machine Puid 0x%016I4X is NOT blocked due to no free block items", mpuid);
        }
    }
    else
    {
        ERR_MSG("Invalid params - Not one of [List | Add | Remove]");
        goto lDone;
    }

    // Output
    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE *)statsText.cstr(),
        (DWORD)statsText.GetLength()
        );

lDone:

    return;
}

#endif // SG_FEATURE_XMGMT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgarpinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgarpinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// CArpInfo
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_ARP

CArpInfo *  SgArpInfoLookup(LIST_ENTRY * pleHead, CIpAddr ipa);
char *      SgArpInfoStateStr(WORD wState);
void        SgArpInfoUpdateTransState(CTransInfo *pTransInfo, CIpAddr ipa, WORD wArpState);

UINT    g_cArpRequestRetries;               // Number of times to retransmit ARP requests
UINT    g_cTicksArpRexmitTimeout;           // Ticks to wait for ARP reply before retransmit
UINT    g_cTicksArpPosTimeout;              // Ticks before a good ARP entry is verified
UINT    g_cTicksArpNegTimeout;              // Ticks before a bad ARP entry is verified
UINT    g_cTicksArpProbeMinInterval;        // Ticks between probes (min)
UINT    g_cTicksArpProbeMaxInterval;        // Ticks between probes (max)
UINT    g_cTicksArpAnnounceWait;            // Ticks between probe & announcement
UINT    g_cTicksArpAnnounceInterval;        // Ticks between announcements
UINT    g_cTicksArpDefendInterval;          // Ticks to throttle defend announcements
BOOL    g_fDetectIpConflicts;               // Detect IP address conflicts or ignore them?
CLock   g_lockArpInfo;                      // Synchronizes access to ARP data

LIST_ENTRY  g_leArpInfoFree;                // Free list of CArpInfo structures
CLock       g_lockArpInfoFree;              // Protects access to free list
UINT        g_cArpInfoFree;                 // Count of free CArpInfo structures

UINT    g_cPoolProbeBatchSize;              // Max number of pool ips to probe for at once
UINT    g_cTicksPoolProbeInterval;          // Time between batches
CTimer  g_timerPoolProbe;                   // Continues probing all pool ips
UINT    g_iNextPoolToProbe;                 // Index of next IP that needs probing in g_pNatInfo
UINT    g_cPoolProbe;                       // Count of pool ips already probed
UINT64  g_qwPoolProbeStartTicks;            // When we started probing pool ips


BOOL SgArpInfoInit()
{
    Assert(g_cArpRequestRetries == 0);
    Assert(g_cTicksArpRexmitTimeout == 0);
    Assert(g_cTicksArpPosTimeout == 0);
    Assert(g_cTicksArpNegTimeout == 0);

    g_lockArpInfo.Init();
    g_timerPoolProbe.Init();

    InitializeListHead(&g_leArpInfoFree);
    g_lockArpInfoFree.Init();
    g_cArpInfoFree = 0;
    g_iNextPoolToProbe = 0;
    g_cPoolProbe = 0;
    g_qwPoolProbeStartTicks = 0;

    return(TRUE);
}

void SgArpInfoTerm()
{
    g_cArpRequestRetries = 0;
    g_cTicksArpRexmitTimeout = 0;
    g_cTicksArpPosTimeout = 0;
    g_cTicksArpNegTimeout = 0;

    g_lockArpInfo.Term();
}

BOOL SgArpInfoConfig(CCfgInfo * pci)
{
    TraceSz(Config, "SgArpInfoConfig: ");

    // Some guidance:
    //
    // Quick defend interval should ideally be shorter than the time it takes an SG to 
    // start, detect a conflict, shut down, and get re-started. This will prevent us from 
    // ignoring the 2nd startup's PROBE and thus allowing the 2nd startup to succeed, in 
    // the case of a conflict. Less than 6 seconds would be good.
    //

    if(!pci->GetVar("ArpRequestRetries", &g_cArpRequestRetries, 1, 10, 4) ||
       !pci->GetVar("ArpRexmitTimeoutInSeconds", &g_cTicksArpRexmitTimeout, 1, 10, 2) ||
       !pci->GetVar("ArpPositiveTimeoutInSeconds", &g_cTicksArpPosTimeout, 1, 60*60, 600) ||
       !pci->GetVar("ArpNegativeTimeoutInSeconds", &g_cTicksArpNegTimeout, 1, 60*60, 60) ||
       !pci->GetVar("ArpProbeMinIntervalInMs", &g_cTicksArpProbeMinInterval, 1, 10000, 1000) ||
       !pci->GetVar("ArpProbeMaxIntervalInMs", &g_cTicksArpProbeMaxInterval, 1, 10000, 2000) ||
       !pci->GetVar("ArpAnnounceWaitInMs", &g_cTicksArpAnnounceWait, 1, 10000, 2000) ||
       !pci->GetVar("ArpAnnounceIntervalInMs", &g_cTicksArpAnnounceInterval, 1, 10000, 2000) ||
       !pci->GetVar("ArpDefendIntervalInSeconds", &g_cTicksArpDefendInterval, 1, 60*60, 10) ||
       !pci->GetVar("ArpPoolProbeBatchSize", &g_cPoolProbeBatchSize, 1, 65535, 256) ||
       !pci->GetVar("ArpPoolProbeBatchFrequencyInMs", &g_cTicksPoolProbeInterval, 1, 60000, 2000) ||
       !pci->GetVar("DetectIpConflicts", (DWORD*)&g_fDetectIpConflicts, 0, 1, 1))
    {
        return FALSE;
    }

    g_cTicksArpRexmitTimeout *= TICKS_PER_SECOND;
    g_cTicksArpPosTimeout    *= TICKS_PER_SECOND;
    g_cTicksArpNegTimeout    *= TICKS_PER_SECOND;

    if (g_cTicksArpProbeMinInterval > g_cTicksArpProbeMaxInterval)
    {
        g_cTicksArpProbeMinInterval = g_cTicksArpProbeMaxInterval;
    }

    g_cTicksArpProbeMinInterval *= TICKS_PER_SECOND;
    g_cTicksArpProbeMaxInterval *= TICKS_PER_SECOND;
    g_cTicksArpAnnounceWait     *= TICKS_PER_SECOND;
    g_cTicksArpAnnounceInterval *= TICKS_PER_SECOND;
    g_cTicksArpDefendInterval   *= TICKS_PER_SECOND;
    g_cTicksPoolProbeInterval   *= TICKS_PER_SECOND;
    
    // These are in milliseconds
    g_cTicksArpProbeMinInterval /= 1000;
    g_cTicksArpProbeMaxInterval /= 1000;
    g_cTicksArpAnnounceWait     /= 1000;
    g_cTicksArpAnnounceInterval /= 1000;
    g_cTicksPoolProbeInterval   /= 1000;

    TraceSz(Config, "    Configured ARP retransmit attempts to %d", g_cArpRequestRetries);

    TraceSz(Config, "    Configured ARP retransmit timeout to %d seconds (%d ticks)",
             g_cTicksArpRexmitTimeout / TICKS_PER_SECOND, g_cTicksArpRexmitTimeout);

    TraceSz(Config, "    Configured ARP positive timeout to %d seconds (%d ticks)",
             g_cTicksArpPosTimeout / TICKS_PER_SECOND, g_cTicksArpPosTimeout);

    TraceSz(Config, "    Configured ARP negative timeout to %d seconds (%d ticks)",
             g_cTicksArpNegTimeout / TICKS_PER_SECOND, g_cTicksArpNegTimeout);

    TraceSz(Config, "    Configured ARP probe min interval to %.1f seconds (%d ticks)",
            (float)g_cTicksArpProbeMinInterval / TICKS_PER_SECOND, g_cTicksArpProbeMinInterval);

    TraceSz(Config, "    Configured ARP probe max interval to %.1f seconds (%d ticks)",
            (float)g_cTicksArpProbeMaxInterval / TICKS_PER_SECOND, g_cTicksArpProbeMaxInterval);

    TraceSz(Config, "    Configured ARP announce wait to %.1f seconds (%d ticks)",
            (float)g_cTicksArpAnnounceWait / TICKS_PER_SECOND, g_cTicksArpAnnounceWait);

    TraceSz(Config, "    Configured ARP announce interval to %.1f seconds (%d ticks)",
            (float)g_cTicksArpAnnounceInterval / TICKS_PER_SECOND, g_cTicksArpAnnounceInterval);

    TraceSz(Config, "    Configured ARP defend interval to %d seconds (%d ticks)",
            g_cTicksArpDefendInterval / TICKS_PER_SECOND, g_cTicksArpDefendInterval);

    TraceSz(Config, "    Configured ARP pool ip probe batch size to %u addresses",
            g_cPoolProbeBatchSize);

    TraceSz(Config, "    Configured ARP pool ip probe batch frequency to %d seconds (%d ticks)",
            g_cTicksPoolProbeInterval / TICKS_PER_SECOND, g_cTicksPoolProbeInterval);

    TraceSz(Config, "    Configured ARP to %sdetect IP address conflicts",
            g_fDetectIpConflicts ? "" : "not ");

    return(TRUE);
}

CArpInfo * SgArpInfoLookupAddress(CTransInfo * pTransInfo, CIpAddr ipa)
{
    return SgArpInfoLookup(&pTransInfo->_leArpAddresses, ipa);
}

CArpInfo * SgArpInfoLookupProbe(CTransInfo * pTransInfo, CIpAddr ipa)
{
    return SgArpInfoLookup(&pTransInfo->_leArpProbes, ipa);
}

CArpInfo * SgArpInfoLookup(LIST_ENTRY * pleHead, CIpAddr ipa)
{
    CArpInfo * pArpInfo = (CArpInfo *)pleHead->Flink;

    while (&pArpInfo->_le != pleHead)
    {
        if (pArpInfo->_ipa == ipa && pArpInfo->_wState != ARP_STATE_CLEANUP)
        {
            return(pArpInfo);
        }

        pArpInfo = (CArpInfo *)pArpInfo->_le.Flink;
    }

    return(NULL);
}

CArpInfo * SgArpInfoLookup(CDstInfo * pDstInfo, CTransInfo * pTransInfo)
{
    if (pTransInfo->_iTransInfo < pDstInfo->_cDstTransInfo)
    {
        return(pDstInfo->_aDstTransInfo[pTransInfo->_iTransInfo]._pArpInfo);
    }

    AssertSz(FALSE, "TransInfo index out of range: iTransInfo = %d, cArpInfo = %d, g_cTransInfo = %d",
              pTransInfo->_iTransInfo, pDstInfo->_cDstTransInfo, g_cTransInfo);
    SgEventInternalError(sizeof(pTransInfo), pTransInfo);

    return(NULL);
}

CArpInfo * SgArpInfoInsert(CTransInfo * pTransInfo, CIpAddr ipa, BOOL fPersist)
{
    CIpAddr ipaDst;

    if ((ipa & pTransInfo->_ipaMask) == pTransInfo->_ipaSubnet)
        ipaDst = ipa;
    else
        ipaDst = pTransInfo->_ipaGateway;

    CArpInfo * pArpInfo = SgArpInfoLookupAddress(pTransInfo, ipaDst);

    if (pArpInfo == NULL)
    {
        pArpInfo = (CArpInfo *)SgMemAllocZ(sizeof(CArpInfo), PTAG_CArpInfo);

        if (pArpInfo == NULL)
        {
            TraceSz(Config, "Config error: Out of memory allocating CArpInfo (%d bytes)", sizeof(CArpInfo));
            return(NULL);
        }

        pArpInfo->_pTransInfo = pTransInfo;
        pArpInfo->_ipa        = ipaDst;
        pArpInfo->_wState     = ARP_STATE_IDLE;
        pArpInfo->_cRefs      = 1;
        pArpInfo->_Timer.Init();

        InsertTailList(&pTransInfo->_leArpAddresses, &pArpInfo->_le);
    }
    else if (!fPersist)
    {
        // CDstInfos hold references to the CArpInfo.
        pArpInfo->_cRefs += 1;
    }

    pArpInfo->_fPersistent = pArpInfo->_fPersistent || fPersist;

    return(pArpInfo);
}

CArpInfo * SgArpInfoAlloc()
{
    CArpInfo *pArpInfo = NULL;

    g_lockArpInfoFree.AcquireLock();
    if (g_cArpInfoFree > 0)
    {
        pArpInfo = (CArpInfo*)RemoveHeadList(&g_leArpInfoFree);
        g_cArpInfoFree--;
    }
    g_lockArpInfoFree.ReleaseLock();

    if (pArpInfo == NULL)
    {
        pArpInfo = (CArpInfo *)SgMemAllocZ(sizeof(CArpInfo), PTAG_CArpInfo);
    }

    return pArpInfo;
}

void SgArpInfoRelease(CArpInfo * pArpInfo, BOOL fPersistent)
{
    if (pArpInfo != NULL)
    {
        Assert(pArpInfo->_cRefs > 0);
        Assert(!fPersistent || pArpInfo->_fPersistent);

        pArpInfo->_cRefs -= 1;

        if (pArpInfo->_cRefs == 0)
        {
            RemoveEntryList(&pArpInfo->_le);
            SgTimerSet(&pArpInfo->_Timer, NULL, TIMER_INFINITE, FALSE);

            g_lockArpInfoFree.AcquireLock();
            InsertTailList(&g_leArpInfoFree, &pArpInfo->_le);
            g_cArpInfoFree++;
            g_lockArpInfoFree.ReleaseLock();

        }
    }
}

void SgArpInfoRecv(CPacket * ppkt)
{
    CTransInfo *    pTransInfoRecv  = ppkt->_pTransInfoRecv;
    CEnetHdr *      pEnetHdr        = ppkt->_pEnetHdr;
    CArpMsg *       pArpMsg         = (CArpMsg *)ppkt->_pb;
    UINT            cb              = ppkt->_cb;

    if (cb < sizeof(CArpMsg))
    {
        TraceSz(RecvDiscard, "%s: ARP packet payload (%d bytes) is too small (%d bytes)",
                 ppkt->Str(), cb, sizeof(CArpMsg));
        goto complete;
    }

    if (pTransInfoRecv->_ea.IsEqual(pEnetHdr->_eaSrc))
    {
        // We received an ARP packet from someone who has the same Ethernet address
        // as us.  Issue a warning and discard the packet if the IP address is unknown to 
        // us.  There's a very good chance this came from a hub that reflected our own 
        // broadcast back to us, in which case we should recognize the IP.
        //
        // Unfortunately, looking up the IP to see if we know of it requires grabbing the 
        // lock and searching for the ip, which isn't cheap and we would likely do 
        // unnecessarily since there's a very good chance the hub/switch HAS reflected our 
        // own packet back to us. Back to doing nothing...

#if 0
        TraceSz(RecvDiscard, "%s: ARP sender has my ethernet address (%s)",
                 ppkt->Str(), pEnetHdr->_eaSrc.Str());
#endif
        goto complete;
    }

    if (    pArpMsg->_wHrd != ARP_HWTYPE_ENET && pArpMsg->_wHrd != ARP_HWTYPE_802
        ||  pArpMsg->_wPro != ENET_TYPE_IP
        ||  pArpMsg->_bHln != sizeof(CEnetAddr)
        ||  pArpMsg->_bPln != sizeof(CIpAddr)
        ||  pArpMsg->_wOp != ARP_OP_REQUEST && pArpMsg->_wOp != ARP_OP_REPLY
        ||  pArpMsg->_eaSender.IsBroadcast())
    {
        TraceSz(RecvDiscard, "%s: ARP message is invalid (%d,%d,%d,%d,%d,%d)",
                 ppkt->Str(),
                 pArpMsg->_wHrd != ARP_HWTYPE_ENET && pArpMsg->_wHrd != ARP_HWTYPE_802,
                 pArpMsg->_wPro != ENET_TYPE_IP,
                 pArpMsg->_bHln != sizeof(CEnetAddr),
                 pArpMsg->_bPln != sizeof(CIpAddr),
                 pArpMsg->_wOp != ARP_OP_REQUEST && pArpMsg->_wOp != ARP_OP_REPLY,
                 pArpMsg->_eaSender.IsBroadcast());
        goto complete;
    }

    // For all received ARP packets, request or reply, check if the sender ip address is 
    // one of our ip addresses. For received ARP probe packets (sender ip is 0), check if 
    // the target ip address is one of ours. Remember to ignore packets that have our own 
    // MAC for the sender MAC (done above). 
    // 
    // Note that _dwIpaBeg and _dwIpaEnd are in HOST order, but _ipaAdmin and _ipaRoute 
    // are in NETWORK order. 

    DWORD dwIpaSender = NTOHL(pArpMsg->_ipaSender);
    DWORD dwIpaTarget = NTOHL(pArpMsg->_ipaTarget);
    BOOL fSenderIsMe = (dwIpaSender >= pTransInfoRecv->_dwIpaBeg && dwIpaSender <= pTransInfoRecv->_dwIpaEnd)
        || (pTransInfoRecv->_dwType == TRANSTYPE_DMZ && pArpMsg->_ipaSender == (pTransInfoRecv->_ipaAdmin ? pTransInfoRecv->_ipaAdmin : pTransInfoRecv->_ipa));
    BOOL fTargetIsMe = (dwIpaTarget >= pTransInfoRecv->_dwIpaBeg && dwIpaTarget <= pTransInfoRecv->_dwIpaEnd)
        || (pTransInfoRecv->_dwType == TRANSTYPE_DMZ && pArpMsg->_ipaTarget == (pTransInfoRecv->_ipaAdmin ? pTransInfoRecv->_ipaAdmin : pTransInfoRecv->_ipa));
    BOOL fProbe = (pArpMsg->_ipaSender == 0);

    if (fSenderIsMe || (fProbe && fTargetIsMe))
    {
        CIpAddr ipaConflict = fSenderIsMe ? pArpMsg->_ipaSender : pArpMsg->_ipaTarget;
        DWORD dwIpaConflict = fSenderIsMe ? dwIpaSender : dwIpaTarget;

        // Request is for an IP address assigned to this transport.
        TraceSz(RecvArp, "%s: ARP Conflict sender %s is using our ip address %s",
                ppkt->Str(), pEnetHdr->_eaSrc.Str(), ipaConflict.Str());

        // Is this an ip address we are already defending or probing?
        SgArpInfoLock();
        
        CArpInfo * pArpInfo = SgArpInfoLookupProbe(pTransInfoRecv, ipaConflict);

        //
        // IP Conflict State Tables
        //
        // Our state is on the left.
        // Received packet state is on the top.
        // "E" = log event
        //
        //                              Target
        //             Sender           Conflict
        //             Conflict         (Probe)
        //           +----------------+----------------+
        //           |                | Send normal    |
        // Running   | Defend!        | ARP response   |
        //           |               E|                |
        //           +----------------+----------------+
        //           | No response,   | Send normal    |
        // Probing   | fail to start, | ARP response,  |
        //           | stop probe     | fail to start, |
        //           |               E| stop probe    E|
        //           +----------------+----------------+
        //           |                | Send normal    |
        // Defending | Do nothing     | ARP response   |
        //           |                |                |
        //           +----------------+----------------+
        //
        //

        BOOL fWeAreProbing = 
            pArpInfo && 
            pArpInfo->_wState >= ARP_STATE_PROBE_1 && 
            pArpInfo->_wState <= ARP_STATE_PROBE_3;

        BOOL fWeAreDefending =
            pArpInfo &&
            pArpInfo->_wState == ARP_STATE_DEFEND;

        BOOL fWeAreRunning = 
            !fWeAreProbing && !fWeAreDefending;


        //
        // Legislate actions
        //

        // By default, we will:
        //   Not defend
        //   Don't log event
        //   Continue starting
        //   Continue probe
        //   Send a normal arp response

#define IPCONFLICT_ACTION_STOPPROBE     0x01
#define IPCONFLICT_ACTION_DEFEND        0x02
#define IPCONFLICT_ACTION_FAILTOSTART   0x04
#define IPCONFLICT_ACTION_EVENT         0x08
#define IPCONFLICT_ACTION_NORESP        0x10

        DWORD dwActions = 0;
        if (fSenderIsMe)
        {
            // First column
            if (fWeAreRunning)
            {
                dwActions |= IPCONFLICT_ACTION_DEFEND;
                dwActions |= IPCONFLICT_ACTION_EVENT;
                dwActions |= IPCONFLICT_ACTION_NORESP;
            }
            else if (fWeAreProbing)
            {
                dwActions |= IPCONFLICT_ACTION_FAILTOSTART;
                dwActions |= IPCONFLICT_ACTION_EVENT;
                dwActions |= IPCONFLICT_ACTION_STOPPROBE;
                dwActions |= IPCONFLICT_ACTION_NORESP;
            }
            else if (fWeAreDefending)
            {
                dwActions |= IPCONFLICT_ACTION_NORESP;

                TraceSz(RecvArp, "%s: Existing conflict detected for ip address (%s)",
                        ppkt->Str(), ipaConflict.Str()); 
            }
            else
            {
                Assert(!"Invalid state");
            }
        }
        else if (fProbe && fTargetIsMe)
        {
            // Second column
            if (fWeAreRunning)
            {
            }
            else if (fWeAreProbing)
            {
                dwActions |= IPCONFLICT_ACTION_FAILTOSTART;
                dwActions |= IPCONFLICT_ACTION_EVENT;
                dwActions |= IPCONFLICT_ACTION_STOPPROBE;
            }
            else if (fWeAreDefending)
            {
            }
            else
            {
                Assert(!"Invalid state");
            }
        }
        else
        {
            Assert(!"Invalid state");
        }

        //
        // Execute actions
        //

        // IMPORTANT: Don't release the arp info. The timer callback could be called with 
        // an invalid pArpInfo if you do. Please set its state to CLEANUP and schedule a 
        // timer callback.
        // 
        
        // --------------------------------------------------------------------
        // Action: Stop probe
        // --------------------------------------------------------------------
        if ((dwActions & IPCONFLICT_ACTION_STOPPROBE) == IPCONFLICT_ACTION_STOPPROBE)
        {
            Assert(pArpInfo);

            pArpInfo->_wState = ARP_STATE_CLEANUP;
            SgTimerSet(&pArpInfo->_Timer, SgArpInfoTimer, SgTimerTick(), FALSE);

        }

        // --------------------------------------------------------------------
        // Action: Defend!  
        // --------------------------------------------------------------------
        if ((dwActions & IPCONFLICT_ACTION_DEFEND) == IPCONFLICT_ACTION_DEFEND)
        {
            // Note: SgArpInfoXmitProbe will release the lock
            if (pArpInfo)
            {
                // Reuse arp object to send the defend
                pArpInfo->_wState = ARP_STATE_DEFEND;
                SgArpInfoXmit(pArpInfo);
            }
            else
            {
                // Allocate new object and xmit
                SgArpInfoUnlock();
                SgArpInfoStartNewProbe(pTransInfoRecv, ipaConflict, TRUE);
            }

            // The lock is not held at this point.
        }
        else
        {
            // We're done touching pArpInfo now, release the lock
            SgArpInfoUnlock();
        }
        pArpInfo = NULL;

        // --------------------------------------------------------------------
        // Action: Fail to start
        // --------------------------------------------------------------------
        if ((dwActions & IPCONFLICT_ACTION_FAILTOSTART) == IPCONFLICT_ACTION_FAILTOSTART)
        {
            // DEFEND indicates a conflict, even though we may not be actually defending.
            SgArpInfoUpdateTransState(pTransInfoRecv, ipaConflict, ARP_STATE_DEFEND);
        }

        // --------------------------------------------------------------------
        // Action: Log event  
        // --------------------------------------------------------------------
        if ((dwActions & IPCONFLICT_ACTION_EVENT) == IPCONFLICT_ACTION_EVENT)
        {
            CSmallStr strEventText;
            strEventText.Format("\nTransport: %s\nIP: %s\nRemote MAC address: %s",
                                pTransInfoRecv->_dwType == TRANSTYPE_DMZ ? "Datacenter" : "Internet",
                                ipaConflict.Str(), 
                                pEnetHdr->_eaSrc.Str());

            // We use unique event ids for these buckets to enable individual throttling.
            if (pTransInfoRecv->_dwType == TRANSTYPE_INTERNET)
            {
                SgEventSz(IP_CONFLICT_INTERNET, strEventText.cstr());
            }
            else if (ipaConflict == pTransInfoRecv->_ipaAdmin)
            {
                SgEventSz(IP_CONFLICT_DATACENTER, strEventText.cstr());
            }
            else
            {
                SgEventSz(IP_CONFLICT_CLIENTPOOL, strEventText.cstr());
            }
        }

        // --------------------------------------------------------------------
        // Action: Send no response 
        // --------------------------------------------------------------------
        if ((dwActions & IPCONFLICT_ACTION_NORESP) == IPCONFLICT_ACTION_NORESP)
        {
            return;
        }

        // Fall out of "if" to send a normal response
    }
        

    if (pArpMsg->_wOp == ARP_OP_REQUEST &&
        pArpMsg->_ipaTarget != pArpMsg->_ipaSender
        )
    {
        // If the sender was my ip, we should have detected a conflict and done something 
        // (defend, send no resp, or do nothing). We shouldn't have made it to this code.
        Assert(!fSenderIsMe);

        if (!fTargetIsMe)
        {
            // Request is not for any of the IP addresses assigned to this transport nor 
            // do we need to send a response to a conflict.

            goto complete;
        }

        // Reply with the ethernet address of this transport

        pEnetHdr->_eaDst    = pArpMsg->_eaSender;
        pEnetHdr->_eaSrc    = pTransInfoRecv->_ea;
        pEnetHdr->_wType    = ENET_TYPE_ARP;

        pArpMsg->_wOp       = ARP_OP_REPLY;
        pArpMsg->_eaTarget  = pArpMsg->_eaSender;
        pArpMsg->_eaSender  = pTransInfoRecv->_ea;
        pArpMsg->_ipaTarget = pArpMsg->_ipaSender;  // @@@ for probes, this will be 0. ok?
        pArpMsg->_ipaSender = HTONL(dwIpaTarget);

        ppkt->_apb[0] = (BYTE *)pEnetHdr;
        ppkt->_acb[0] = sizeof(CEnetHdr);
        ppkt->_apb[1] = (BYTE *)pArpMsg;
        ppkt->_acb[1] = sizeof(CArpMsg);
        ppkt->_cpb    = 2;

        ppkt->_pTransInfoXmit = pTransInfoRecv;

        TraceSz(RecvArp, "%s: [ARP Sending Reply to %s %s for %s %s]",
                 ppkt->Str(),
                 pArpMsg->_ipaTarget.Str(), pArpMsg->_eaTarget.Str(),
                 pArpMsg->_ipaSender.Str(), pArpMsg->_eaSender.Str());

        SgXmit(ppkt);
        return;
    }

    TraceSz(RecvArp, "%s: [ARP Got Reply/Announcement from %s %s for %s %s]",
             ppkt->Str(),
             pArpMsg->_ipaSender.Str(), pArpMsg->_eaSender.Str(),
             pArpMsg->_ipaTarget.Str(), pArpMsg->_eaTarget.Str());

    SgArpInfoLock();

    CArpInfo * pArpInfo = SgArpInfoLookupAddress(pTransInfoRecv, pArpMsg->_ipaSender);

    if (pArpInfo == NULL)
    {
        SgArpInfoUnlock();
        goto complete;
    }

    pArpInfo->_wState = ARP_STATE_GOOD;
    pArpInfo->_ea     = pArpMsg->_eaSender;

    SgTimerSet(&pArpInfo->_Timer, SgArpInfoTimer, SgTimerTick() + g_cTicksArpPosTimeout, FALSE);

    TraceSz(RecvArp, "%s: %s resolved to %s", ppkt->Str(), pArpInfo->_ipa.Str(), pArpInfo->_ea.Str());

    CPacketQueue pq;
    CEnetAddr    eaDst;
    pq.Init();

    if (!pArpInfo->_pqWait.IsEmpty())
    {
        TraceSz(RecvArp, "%s: Sending %d packet%s waiting for %s", ppkt->Str(),
                 pArpInfo->_pqWait.Count(), pArpInfo->_pqWait.Count() == 1 ? "" : "s",
                 pArpInfo->_ipa.Str());

        pq.InsertHead(&pArpInfo->_pqWait);
        eaDst = pArpInfo->_ea;
    }

    SgArpInfoUnlock();
    pArpInfo = NULL;

    if (!pq.IsEmpty())
    {
        while (!pq.IsEmpty())
        {
            CPacket * ppktWait = pq.RemoveHead();
            ppktWait->_pEnetHdr->_eaDst = eaDst;

            SgXmit(ppktWait);
        }
    }

    goto complete;

complete:

    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgArpInfoXmit - transmit any ARP packet - request, probe, or announcement.  Must be 
// called with the ARP lock held, as it will release the lock.
// ---------------------------------------------------------------------------------------
void SgArpInfoXmit(CArpInfo * pArpInfo)
{
    // Note: this function is called with the ARP lock held

    Assert(pArpInfo);
    Assert(pArpInfo->_pTransInfo);
    Assert(pArpInfo->_ipa);
    Assert(pArpInfo->_wState == ARP_STATE_IDLE || 
           pArpInfo->_wState >= ARP_STATE_BUSY ||
           (pArpInfo->_wState >= ARP_STATE_PROBE_1 && pArpInfo->_wState <= ARP_STATE_DEFEND));

    if (pArpInfo->_wState == ARP_STATE_IDLE)
    {
        pArpInfo->_wState = ARP_STATE_BUSY + g_cArpRequestRetries;
    }

    // Find the correct timeout value
    DWORD dwTicksInterval = 0;
    switch (pArpInfo->_wState)
    {
    case ARP_STATE_PROBE_1:
    case ARP_STATE_PROBE_2:
        dwTicksInterval = SgQuickRand(g_cTicksArpProbeMinInterval, g_cTicksArpProbeMaxInterval);
        break;
    case ARP_STATE_PROBE_3:
        dwTicksInterval = g_cTicksArpAnnounceWait;
        break;
    case ARP_STATE_ANNOUNCE_1:
    case ARP_STATE_ANNOUNCE_2:
        dwTicksInterval = g_cTicksArpAnnounceInterval;
        break;
    case ARP_STATE_DEFEND:
        dwTicksInterval = g_cTicksArpDefendInterval;
        break;
    default:
        // regular old ARP 
        dwTicksInterval = g_cTicksArpRexmitTimeout;
        break;
    }
    SgTimerSet(&pArpInfo->_Timer, SgArpInfoTimer, SgTimerTick() + dwTicksInterval, FALSE);

    // Save off things we need in pArpInfo, since we're about to release the lock on it
    WORD         wState     = pArpInfo->_wState;
    CTransInfo * pTransInfo = pArpInfo->_pTransInfo;
    CIpAddr      ipaTarget  = pArpInfo->_ipa;

    SgArpInfoUnlock();
    pArpInfo = NULL;

    // Notify transport of a state change. Config tracks this.
    SgArpInfoUpdateTransState(pTransInfo, ipaTarget, wState);

    CPacket * ppkt = SgPacketAlloc();

    if (ppkt == NULL)
    {
        TraceSz(XmitArp, "%s: failed to allocate a packet.", __FUNCTION__);
        return;
    }

    CEnetHdr *   pEnetHdr   = ppkt->_pEnetHdr = (CEnetHdr *)ppkt->_abCtx;
    CArpMsg *    pArpMsg    = (CArpMsg *)(pEnetHdr + 1);

    pEnetHdr->_eaDst.SetBroadcast();
    pEnetHdr->_eaSrc    = pTransInfo->_ea;
    pEnetHdr->_wType    = ENET_TYPE_ARP;

    pArpMsg->_wHrd      = ARP_HWTYPE_ENET;
    pArpMsg->_wPro      = ENET_TYPE_IP;
    pArpMsg->_bHln      = sizeof(CEnetAddr);
    pArpMsg->_bPln      = sizeof(CIpAddr);
    pArpMsg->_wOp       = ARP_OP_REQUEST;
    pArpMsg->_eaSender  = pTransInfo->_ea;
    pArpMsg->_eaTarget.SetZero();
    pArpMsg->_ipaTarget = ipaTarget;

    if (wState >= ARP_STATE_PROBE_1 && wState <= ARP_STATE_PROBE_3)
    {
        // Probes must be 0
        pArpMsg->_ipaSender = 0;
    }
    else if (wState >= ARP_STATE_ANNOUNCE_1 && wState <= ARP_STATE_ANNOUNCE_2)
    {
        // Announce our ip
        pArpMsg->_ipaSender = ipaTarget;
    }
    else
    {
        // Regular old arp
#ifdef SG_FEATURE_ARP
        if( pTransInfo->_dwType == TRANSTYPE_DMZ && pTransInfo->_ipaAdmin )
        {
            pArpMsg->_ipaSender = pTransInfo->_ipaAdmin;
        }
        else
#endif
        {
            pArpMsg->_ipaSender = pTransInfo->_ipa;
        }
    }

    TraceSz(XmitArp, "%s: ARP Sending %s from %s %s for %s %s, timeout %u ticks",
            ppkt->Str(),
            SgArpInfoStateStr(wState),
            pArpMsg->_ipaSender.Str(), pArpMsg->_eaSender.Str(),
            pArpMsg->_ipaTarget.Str(), pArpMsg->_eaTarget.Str(),
            dwTicksInterval);

    ppkt->_apb[0] = (BYTE *)pEnetHdr;
    ppkt->_acb[0] = sizeof(CEnetHdr) + sizeof(CArpMsg);
    ppkt->_cpb    = 1;

    ppkt->_pTransInfoXmit = pTransInfo;
    SgXmit(ppkt);
}

void SgArpInfoTimer(CTimer * pTimer)
{
    CArpInfo *   pArpInfo = (CArpInfo *)((BYTE *)pTimer - offsetof(CArpInfo, _Timer));
    WORD         wArpState = pArpInfo->_wState;
    CPacketQueue pq;

    pq.Init();

    SgArpInfoLock();

    if (wArpState != pArpInfo->_wState)
    {
        // Race condition - some other thread has changed the state of this arp info, so 
        // presumably the original reason the timer was set is now invalid. Just return.  

        SgArpInfoUnlock();
        return;
    }

    // There remains a tiny race condition where we may have grabbed the new state a 
    // couple lines above and thus are executing here despite the original intention of 
    // this timer callback changing, so be on the lookout for that.

    if (pArpInfo->_wState > ARP_STATE_BUSY)
    {
        // No response to previous ARP request.  Transmit it again.

        TraceSz(RecvArp, "%s didn't respond to request.  Trying again.", pArpInfo->_ipa.Str());

        pArpInfo->_wState -= 1;

        // SgArpInfoXmit will release the ARP lock

        SgArpInfoXmit(pArpInfo);
        return;
    }
    else if (pArpInfo->_wState == ARP_STATE_BUSY)
    {
        // No response to all ARP requests for this entry.  Mark it BAD for a while,
        // and discard any packets waiting.

        TraceSz(RecvArp, "%s is unreachable.  Discarding %d waiting packet%s.",
                 pArpInfo->_ipa.Str(), pArpInfo->_pqWait.Count(),
                 pArpInfo->_pqWait.Count() == 1 ? "" : "s");

        SgEventSz(BACKEND_SERVICE_UNREACHABLE, pArpInfo->_ipa.Str());

        SgTimerSet(&pArpInfo->_Timer, SgArpInfoTimer, SgTimerTick() + g_cTicksArpNegTimeout, FALSE);

        pArpInfo->_wState = ARP_STATE_BAD;
        pq.InsertHead(&pArpInfo->_pqWait);
    }
    else if (pArpInfo->_wState >= ARP_STATE_PROBE_1 &&
             pArpInfo->_wState <= ARP_STATE_ANNOUNCE_1)
    {
        // Send probes 2 and 3, move to announcement 1 and 2.
        pArpInfo->_wState += 1;

        // SgArpInfoXmit will release the ARP lock
        SgArpInfoXmit(pArpInfo);
        return;
    }
    else if (pArpInfo->_wState == ARP_STATE_ANNOUNCE_2)
    {
        // All done. Free it?
        TraceSz(XmitArp, "Probe and Announce completed for %s", pArpInfo->_ipa.Str());
        SgArpInfoRelease(pArpInfo, pArpInfo->_fPersistent);
        pArpInfo = NULL;
    }
    else if (pArpInfo->_wState == ARP_STATE_DEFEND)
    {
        TraceSz(XmitArp, "Defend period completed for %s", pArpInfo->_ipa.Str());
        SgArpInfoRelease(pArpInfo, pArpInfo->_fPersistent);
        pArpInfo = NULL;
    }
    else if (pArpInfo->_wState == ARP_STATE_CLEANUP)
    {
        // This is the only state that can be set without a corresponding call to 
        // SgTimerSet, so we need to handle the tiny race condition mentioned above by 
        // clearing any other pending callbacks before releasing the object.
        
        SgTimerSet(&pArpInfo->_Timer, NULL, TIMER_INFINITE, FALSE);

        TraceSz(XmitArp, "Cleaning up ARP info for %s", pArpInfo->_ipa.Str());
        SgArpInfoRelease(pArpInfo, pArpInfo->_fPersistent);
        pArpInfo = NULL;
    }
    else
    {
        // Entry has timed out.  Mark it IDLE so that it will be resolved the next
        // time a packet is transmitted to it.

        TraceSz(RecvArp, "%s has timed out %s", pArpInfo->_ipa.Str(),
                 pArpInfo->_wState == ARP_STATE_BAD ? " (previously unresponsive)" : "");

        pArpInfo->_wState = ARP_STATE_IDLE;
    }

    SgArpInfoUnlock();

    pq.Complete();
}

char * SgArpInfoStateStr(WORD wState)
{
    switch (wState)
    {
        case ARP_STATE_IDLE:        return "IDLE";
        case ARP_STATE_GOOD:        return "GOOD";
        case ARP_STATE_BAD:         return "BAD";
        case ARP_STATE_PROBE_1:     return "PROBE_1";
        case ARP_STATE_PROBE_2:     return "PROBE_2";
        case ARP_STATE_PROBE_3:     return "PROBE_3";
        case ARP_STATE_ANNOUNCE_1:  return "ANNOUNCE_1";
        case ARP_STATE_ANNOUNCE_2:  return "ANNOUNCE_2";
        case ARP_STATE_DEFEND:      return "DEFEND";
        case ARP_STATE_CLEANUP:     return "CLEANUP";
    }
    return "BUSY";
}

// ---------------------------------------------------------------------------------------
//
// ARP probe and announcement functions. See http://tools.ietf.org/rfc/rfc5227.txt.
//
// ---------------------------------------------------------------------------------------


// ---------------------------------------------------------------------------------------
// SgArpInfoStartNewProbe - allocate a new CArpInfo and send a new probe or an 
// announcement (for a defend state). The arp lock must not be held prior to calling this 
// function.
// ---------------------------------------------------------------------------------------
void SgArpInfoStartNewProbe(CTransInfo * pTransInfo, CIpAddr ipa, BOOL fDefend)
{
    Assert(pTransInfo);

    // System disabled?
    if (!g_fDetectIpConflicts)
    {
        return;
    }

    WORD wArpState = fDefend ? ARP_STATE_DEFEND : ARP_STATE_PROBE_1;

    CArpInfo * pArpInfo = SgArpInfoAlloc();

    if (pArpInfo == NULL)
    {
        TraceSz(XmitArp, "%s: Out of memory allocating CArpInfo (%d bytes)", __FUNCTION__, sizeof(CArpInfo));
        return;
    }

    pArpInfo->_pTransInfo = pTransInfo;
    pArpInfo->_ipa        = ipa;
    pArpInfo->_wState     = wArpState;
    pArpInfo->_cRefs      = 1;
    pArpInfo->_fPersistent = TRUE;  // FALSE means CDstInfo owns it, basically
    pArpInfo->_Timer.Init();
    
    SgArpInfoLock();
    InsertTailList(&pTransInfo->_leArpProbes, &pArpInfo->_le);

    // Send it! This will release the lock.
    SgArpInfoXmit(pArpInfo);
}

// ---------------------------------------------------------------------------------------
// SgArpInfoUpdateTransState - updates the state (in progress, conflict) variables in 
// CTransInfo that track probe status. Config blocks on this until probing has finished.
// ---------------------------------------------------------------------------------------
static void SgArpInfoUpdateTransState(CTransInfo *pTransInfo, CIpAddr ipa, WORD wArpState)
{
    Assert(pTransInfo);
    Assert(ipa);

    if (wArpState < ARP_STATE_PROBE_1 || wArpState > ARP_STATE_DEFEND)
    {
        // Not for us to handle
        return;
    }

    BOOL fInProgress = (wArpState >= ARP_STATE_PROBE_1 && wArpState <= ARP_STATE_PROBE_3);
    BOOL fDone       = (wArpState >= ARP_STATE_ANNOUNCE_1 && wArpState <= ARP_STATE_DEFEND);
    BOOL fConflict   = (wArpState == ARP_STATE_DEFEND);

    // ip is either _ipa for the internet nic or within the datacenter client ip range or 
    // optionally _ipaAdmin for the datacenter nic.
    if (pTransInfo->_dwType == TRANSTYPE_DMZ)
    {
        // Datacenter nic
        if (ipa == pTransInfo->_ipaAdmin)
        {
            pTransInfo->_fProbeInProgress = fInProgress;
            pTransInfo->_fProbeConflict = fConflict;
        }
        else
        {
            // we assume this is the client pool range
            if (fDone)
            {
                pTransInfo->_cProbePoolDone++;
            }
            if (fConflict)
            {
                pTransInfo->_cProbePoolConflict++;
            }
        }
    }
    else
    {
        // Internet nic
        Assert(ipa == pTransInfo->_ipa);

        pTransInfo->_fProbeInProgress = fInProgress;
        pTransInfo->_fProbeConflict = fConflict;
    }
}

// ---------------------------------------------------------------------------------------
// SgArpInfoPoolTimer - continues probing the client ip (pool) range until all have been 
// done. Reschedules itself until finished.
// ---------------------------------------------------------------------------------------
void SgArpInfoPoolTimer(CTimer *pTimer)
{
    // Shrink batch size to match actual count if it is smaller
    if (g_cPoolProbeBatchSize > g_cValidIpa)
    {
        TraceSz(Config, "ARP Pool Probe: adjusting pool ip probe batch size from %u to %u",
                g_cPoolProbeBatchSize, g_cValidIpa);
        g_cPoolProbeBatchSize = g_cValidIpa;
    }

    // Initial call?
    if (g_cPoolProbe == 0)
    {
        g_qwPoolProbeStartTicks = SgTimerTick();
    }

    UINT    cStart   = g_cPoolProbe;
    CIpAddr ipaStart = g_pNatInfo[(g_iNextPoolToProbe * g_cNatInfoPerIpAddr)]._ipaZ;

    for (; g_iNextPoolToProbe < g_cTotalIpa; g_iNextPoolToProbe++)
    {
        // Check batch size or early completion
        if (g_cPoolProbe - cStart >= g_cPoolProbeBatchSize ||
            g_cPoolProbe >= g_cValidIpa)
        {
            break;
        }

        UINT iNatInfo = g_iNextPoolToProbe * g_cNatInfoPerIpAddr;
        CNatInfo * pNatInfo = &g_pNatInfo[iNatInfo];

        // Skip invalid ip addresses
        if (pNatInfo->_ipaZ.IsValidAddr(pNatInfo->_pTransInfo->_ipaMask))
        {
            SgArpInfoStartNewProbe(pNatInfo->_pTransInfo, pNatInfo->_ipaZ, FALSE);
            g_cPoolProbe++;
        }
    }

    CIpAddr ipaEnd = g_pNatInfo[((g_iNextPoolToProbe - 1) * g_cNatInfoPerIpAddr)]._ipaZ;
    TraceSz(Config, "ARP Pool Probe: Initiated probes for %u client IPs %s - %s, %u of %u completed",
            g_cPoolProbe - cStart, ipaStart.Str(), ipaEnd.Str(), g_cPoolProbe, g_cValidIpa);

    if (g_cPoolProbe < g_cValidIpa)
    {
        // Keep on probing
        Assert(g_iNextPoolToProbe < g_cTotalIpa);
        SgTimerSet(&g_timerPoolProbe, SgArpInfoPoolTimer, SgTimerTick() + g_cTicksPoolProbeInterval, TRUE);
    }
    else
    {
        float fElapsed = (float)(SgTimerTick() - g_qwPoolProbeStartTicks) / TICKS_PER_SECOND;
        TraceSz(Config, "ARP Pool Probe: Done probing all client ip addresses");
        SgEventSz(IP_DONE_PROBING, "Completed %u pool ip address(es) in %.1f second(s).",
                  g_cValidIpa, fElapsed);
    }
}

// ---------------------------------------------------------------------------------------
// SgIpConflictConfig - this is less of a "config" function and more of a "verification" 
// one. It returns TRUE if no ip conflicts have been detected on any interface, or FALSE 
// if at least one conflict is detected.
//
// The datacenter's client ip range is not exhaustively checked. As soon as one or more 
// responses come back, we stop blocking.
// ---------------------------------------------------------------------------------------
BOOL SgIpConflictConfig(CCfgInfo* pci)
{
    static BOOL s_fReload = FALSE;
    if (s_fReload || !g_fDetectIpConflicts)
    {
        // Only do this check on the initial config
        return TRUE;
    }
    s_fReload = TRUE;

    TraceSz( Config, "SgIpConflictConfig:" );

    BOOL            fOk = TRUE;
    UINT            cTransInfo;
    CTransInfo *    pTransInfo;

    for( cTransInfo = g_cTransInfo, pTransInfo = g_pTransInfo; cTransInfo > 0; --cTransInfo, ++pTransInfo )
    {
        // The "main ip" probe for the Internet transport is the _ipa. It is _ipaAdmin for 
        // the Datacenter transport, but this is optional for it.

        CIpAddr ipa = (pTransInfo->_dwType == TRANSTYPE_DMZ && pTransInfo->_ipaAdmin) ? pTransInfo->_ipaAdmin : pTransInfo->_ipa;

        TraceSz(Config, "    Checking %s ip %s:",
                pTransInfo->_dwType == TRANSTYPE_DMZ ? "datacenter" : "internet",
                ipa.Str());

        TraceSz(Config, "        In progress: %d, Conflict found: %d",
                pTransInfo->_fProbeInProgress,
                pTransInfo->_fProbeConflict);

        // spin, wait for done
        while (pTransInfo->_fProbeInProgress)
        {
            Sleep(15);
        }

        if (pTransInfo->_fProbeConflict)
        {
            TraceSz(Config, "        Conflict detected for %s address %s",
                    pTransInfo->_dwType == TRANSTYPE_DMZ ? "datacenter _ipaAdmin (_ipaRoute)" : "internet _ipa",
                    ipa.Str());
            return FALSE;
        }

        if (pTransInfo->_dwType == TRANSTYPE_DMZ)
        {
            // Check client pool ip range.  Wait for at least 1 batch's worth of 
            // responses, but not all of them.
            
            TraceSz(Config, "    Checking client pool ip range. Total addresses: %d, Checking: %d",
                    g_cValidIpa,
                    g_cPoolProbeBatchSize);

            if (pTransInfo->_cProbePoolDone < g_cPoolProbeBatchSize && 
                pTransInfo->_cProbePoolConflict == 0)
            {
                TraceSz(Config, "        Number done: %d, Number conflicts: %d",
                        pTransInfo->_cProbePoolDone,
                        pTransInfo->_cProbePoolConflict);
            }

            // spin, wait for done
            while (pTransInfo->_cProbePoolDone < g_cPoolProbeBatchSize && 
                   pTransInfo->_cProbePoolConflict == 0)
            {
                Sleep(15);
            }

            TraceSz(Config, "        Number done: %d, Number conflicts: %d",
                    pTransInfo->_cProbePoolDone,
                    pTransInfo->_cProbePoolConflict);

            if (pTransInfo->_cProbePoolConflict > 0)
            {
                TraceSz(Config, "        Conflict detected within datacenter client pool ip range");
                return FALSE;
            }
        }
    }

    return TRUE;
}

#endif // SG_FEATURE_ARP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgchal.cpp ===
// -----------------------------------------------------------------------------
// sgchal.cpp
//
// Copyright (C) Microsoft Corporation
// -----------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// -----------------------------------------------------------------------------
// State
// -----------------------------------------------------------------------------

BOOL    g_fEnableChallengeResponse = FALSE;

// -----------------------------------------------------------------------------
// Local State
// -----------------------------------------------------------------------------

static CTimer   g_chalHeartbeatTimer;   // Timer to call LUA heartbeat on
static UINT     g_chalHeartbeatTimeout; // Number of ticks between LUA heartbeat pulses

BOOL SgChalInit()
{
    Assert(!g_fEnableChallengeResponse);
    Assert(g_chalHeartbeatTimeout == 0);
    g_chalHeartbeatTimer.Init();

    return(TRUE);
}

void SgChalTerm()
{
    g_fEnableChallengeResponse = FALSE;

    // No need to cancel timer --- it will be gracefully cancelled when the SG
    // terminates
}

void SgChalHeartbeatTimer(CTimer *)
/*++

Routine Description:

    This routine invokes the Heartbeat method in all of the LUA state machines
    currently enabled

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        fOk = TRUE;
    UINT32      dwIndex;
    ISgLuaState *pLua;
    CLargeStr   error;

    for (dwIndex = 0; fOk ; dwIndex++)
    {
        //
        // Get Interface
        //
        pLua = SgLuaGetState(dwIndex);
        if (pLua == NULL)
        {
            break;
        }

        fOk = fOk && pLua->LCall_va(
            "Heartbeat",
            "",
            &error
            );

        //
        // Release interface
        //
        pLua->Release();
    }

    //
    // Report Errors if any
    //
    if (!fOk)
    {
        SgEventSz(
            CHAL_SCRIPT_FAILED,
            "[%s] : Heartbeat() : LUA Error: %s",
            __FUNCTION__,
            error.cstr()
            );
    }

    // reschedule
    if (g_fEnableChallengeResponse && g_chalHeartbeatTimeout > 0)
    {
        SgTimerSet(
            &g_chalHeartbeatTimer,
            SgChalHeartbeatTimer,
            SgTimerTick() + g_chalHeartbeatTimeout,
            TRUE
            );
    }
}

BOOL SgChalConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgChalConfig:" );

    if( !g_fEnableConnectionServices )
    {
        return(TRUE);
    }

    if(!pci->GetVar("EnableChallengeResponse",      (DWORD*)&g_fEnableChallengeResponse, 0,       1,  0) ||
       !pci->GetVar("ChalHeartbeatTimeoutInSeconds", &g_chalHeartbeatTimeout,           1, 5*60*60, 60))

    {
        return FALSE;
    }

    // Convert seconds to ticks
    g_chalHeartbeatTimeout *= TICKS_PER_SECOND;

    TraceSz(Config, "    Configured EnableChallengeResponse to %s",
             g_fEnableChallengeResponse ? "true" : "false");
    TraceSz( Config, "   Configured LUA Heartbeat to %u seconds (%u ticks)",
        g_chalHeartbeatTimeout / TICKS_PER_SECOND, g_chalHeartbeatTimeout );

    if (!g_fEnableChallengeResponse)
    {
        return(TRUE);
    }

    // Start heartbeat timer (long) on next interval
    if (g_chalHeartbeatTimeout > 0)
    {
        SgTimerSet(
            &g_chalHeartbeatTimer,
            SgChalHeartbeatTimer,
            SgTimerTick() + g_chalHeartbeatTimeout,
            TRUE
            );
    }

    BOOL fOk = TRUE;
    return(fOk);
}

void SgChalCodeUpdateSpiInfo(CSpiInfo *pSpiInfo)
/*++

Routine Description:

    This routine is called when the CAuthData3 for a particular SPI has
    changed such that the user is no longer playing the same title

Arguments:

    pSpiInfo    - SpiInfo to check

Return Value:

    None

--*/
{
    //
    // Sanity check for things that would disable challenges for this SPI
    //

    if ((pSpiInfo->_fCs == FALSE) ||
        (pSpiInfo->_AuthData.GetPlatform() == XPLT_XBOX1) ||
        g_cTicksPerSpiInfoChalResp == 0)
    {

        //
        // Disable challenges
        //

        pSpiInfo->_dwChalAsyncState = SPI_CHAL_ASYNC_STATE_OFF;
        return;
    }

    //
    // Enable challenges
    //

    SgLuaChalSetAsyncStateActive( pSpiInfo );
    return;

}

void SgChalDropped(CSpiInfo *pSpiInfo)
/*++

Routine Description:

    This routine is called when a client is about to be kicked for
    SPIDEL_TIMEOUT_KEYEX

Arguments:

    pSpiInfo    -SpiInfo that is going to get dropped

Return Value:

    None

--*/
{
    //
    // Are we in the middle of KeyEx?
    // 

    if ( 0 != pSpiInfo->_qwTickKeyEx1 && 
         0 == pSpiInfo->_qwTickKeyEx2 ) 
    {

        //
        // Yes, so we must be in a sync challenge. If there is an active
        // one on this SPI, call the LUA drop routine
        // 

        if ( FALSE == SgLuaChalStateAsync(pSpiInfo) &&
             TRUE  == SgLuaChalStateEnabled(pSpiInfo) )
        {
            SgPerfdataInterlockedInc( ChalSyncTimeout );
            SgLuaChalDropped(pSpiInfo);
        }

        //
        // Did we block or kick? Note that doing nothing is an implied kick.
        // 

        if (TRUE == SgLuaChalStateBlock(pSpiInfo)) 
        {
            TraceSz(
                SpiTrace,
                "%08lX: nonce %08lx block",
                pSpiInfo->_dwSpiRecv,
                pSpiInfo->_dwChallengeNonce
                );
            SgPerfdataInterlockedInc( ChalSyncBlock );
            SgBlockInfoBlockPuid( &(pSpiInfo->_puid) );
        }
        else 
        {
            TraceSz(
                SpiTrace,
                "%08lX: nonce %08lx implicit kick",
                pSpiInfo->_dwSpiRecv,
                pSpiInfo->_dwChallengeNonce
                );
            SgPerfdataInterlockedInc( ChalSyncFail );
        }
        return;
    }

    //
    // Is there an active async challenge and are we in the middle of
    // waiting for some response from it?
    // 

    if ( SPI_CHAL_ASYNC_STATE_OFF  != pSpiInfo->_dwChalAsyncState &&
         SPI_CHAL_ASYNC_STATE_IDLE != pSpiInfo->_dwChalAsyncState ) 
    {
        if ( TRUE == SgLuaChalStateAsync( pSpiInfo ) &&
             TRUE == SgLuaChalStateEnabled( pSpiInfo) ) 
        {
            SgPerfdataInterlockedInc( ChalAsyncTimeoutDropped );
            SgLuaChalDropped(pSpiInfo);
        }

        //
        // Did we block or kick? Note that doing nothing is an implied kick.
        // 

        if (TRUE == SgLuaChalStateBlock(pSpiInfo)) 
        {
            TraceSz(
                SpiTrace,
                "%08lX: nonce %08lx block",
                pSpiInfo->_dwSpiRecv,
                pSpiInfo->_dwChallengeNonce
                );
            SgPerfdataInterlockedInc( ChalAsyncBlock );
            SgBlockInfoBlockPuid( &(pSpiInfo->_puid) );
        }
        else 
        {
            TraceSz(
                SpiTrace,
                "%08lX: nonce %08lx implicit kick",
                pSpiInfo->_dwSpiRecv,
                pSpiInfo->_dwChallengeNonce
                );
            SgPerfdataInterlockedInc( ChalAsyncFail );
        }
        return;
    }

}

#ifdef SG_FEATURE_XMGMT

#define MAX_CHAL_RESPONSE_SIZE 16384

void SgChalListChallenges(
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface
    )
{
    char         pbResponse[MAX_CHAL_RESPONSE_SIZE];
    int          cbResponse = 0;
    CLargeStr    clsLuaChallenges;
    CLargeStr    clsLuaError;
    BOOL         fOk;

    //
    // See if there are lua challenges loaded
    //
    ISgLuaState *pLua = SgLuaGetState( (UINT32) 0 );

    //
    // Execute the LUA script to command to build the challenge list
    //
    fOk = pLua->LCall_va(
        "ChallengeList", ">s",
        &clsLuaError,
        &clsLuaChallenges
        );
    if (!fOk)
    {
        cbResponse += _snprintf(
            pbResponse + cbResponse,
            MAX_CHAL_RESPONSE_SIZE - cbResponse,
            "%s",
            clsLuaError.cstr()
            );
    }
    else
    {
        cbResponse += _snprintf(
            pbResponse + cbResponse,
            MAX_CHAL_RESPONSE_SIZE - cbResponse,
            "LUA Challenges Loaded\n%s",
            clsLuaChallenges.cstr()
            );
    }

    //
    // Release the interface
    //
    pLua->Release();

    //
    // Display the response
    //
    if (cbResponse && pResponseInterface)
    {
        pResponseInterface->WriteResponse(
            dwRequestId,
            (BYTE *)pbResponse,
            (DWORD) -1
            );
    }
}

#endif

void SgChalProcessSyncResponse( CPacket * ppkt )
{
    BYTE *pbBuffer = NULL;
    BOOL fKickCode = FALSE;
    DWORD dwReason = SPIDEL_CHALLENGE_LUA;
    DWORD dwChalCodeId = 0;
    DWORD dwChalCodeParamId = 0;
    DWORD cbBuffer = 0;

    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    //
    // Determine what type of response we got by the message type
    // 
    
    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP) 
    {
        CSecMsgXbToSgChalResp * pSecMsgChal = (CSecMsgXbToSgChalResp *)pSecMsgHdr;

        pbBuffer = pSecMsgChal->_abExecute;
        cbBuffer = sizeof(pSecMsgChal->_abExecute);
    }
    else if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP_3) 
    {
        CSecMsgXbToSgChalResp3 * pSecMsgChal = (CSecMsgXbToSgChalResp3 *)pSecMsgHdr;

        pbBuffer = pSecMsgChal->_abExecute;
        cbBuffer = sizeof(pSecMsgChal->_abExecute);
    }
    else
    {
        goto complete;
    }

    //
    // Did we get our response from a LUA based challenge?
    //

    if (SgLuaChalStateEnabled(pSpiInfo) == FALSE)
    {
        //
        // Shouldn't be possible to get 2 responses to the same key
        // exchange challenge
        // 

        goto complete;
    }

    //
    // Remember what the code id and param id was for logging
    //

    dwChalCodeId = pSpiInfo->_dwLuaChalCodeId;
    dwChalCodeParamId = pSpiInfo->_dwLuaChalCodeParamId;

    //
    // At this point, we have a valid response
    // 

    SgPerfdataInterlockedInc( ChalSyncResponse );

    //
    // Call into the lua engine to process that response
    //

    SgLuaChalAnalyze(pSpiInfo, pbBuffer, cbBuffer);

    //
    // Determine the result of the operation
    //

    if (SgLuaChalStateBlock(pSpiInfo) == TRUE) 
    {
        TraceSz( SpiTrace, "%08lX: key-ex block", pSpiInfo->_dwSpiRecv );
        SgPerfdataInterlockedInc( ChalSyncBlock );

        fKickCode = true;
        SgBlockInfoBlockPuid( &(pSpiInfo->_puid) );
    }
    else if (SgLuaChalStateKick(pSpiInfo) == TRUE) 
    {
        TraceSz( SpiTrace, "%08lX: key-ex kick", pSpiInfo->_dwSpiRecv );
        SgPerfdataInterlockedInc( ChalSyncFail );

        fKickCode = true;
    }
    else
    {
        SgPerfdataInterlockedInc( ChalSyncPass );
    }

    //
    // Log if required
    // 

    if (SgLuaChalStateLog(pSpiInfo) == TRUE)
    {
        TraceSz(
            ChalTrace,
            "[%08lX] log key-ex code %s",
            pSpiInfo->_dwSpiRecv,
            SgHexDumpStr(pbBuffer, cbBuffer)
            );

        CLogChallenge lc;

        lc._fCodeLog        = TRUE;
        lc._fCodeKick       = fKickCode;
        lc._dwChalCodeId    = dwChalCodeId;
        lc._iChalCodeParam  = dwChalCodeParamId;

        SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_LOGCHAL, &lc, pSecMsgHdr);
    }

    //
    // Reset the lua state
    //

    SgLuaChalStateClear(pSpiInfo);

    //
    // Kick the client if necessary
    //

    if (fKickCode)
    {
        SgSpiInfoFree(pSpiInfo, dwReason);
        SgSpiInfoDetach(ppkt);

        goto complete;
    }

    //
    // Challenge response is acceptable.  Send a pulse back to the client
    // to acknowledge.
    //

    pSpiInfo->_qwTickKeyEx2 = SgTimerTick();
    pSpiInfo->_qwTickRecv   = SgTimerTick();

    //
    // Determine if anytime challenges need to be enabled
    //

    SgChalCodeUpdateSpiInfo(pSpiInfo);

    //
    // And send a pulse back to the client to let it know that its okay
    // 

    SgIXmitSecMsgSgToXbPulse(pSpiInfo, ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}

BOOL SgChalAssignSyncChallenge( CSpiInfo *pSpiInfo, CKeyExCtx *pKeyExCtx )
/*++

Routine Description:

    Select a sync challenge to send to the client. If a challenge is found,
    copy it into the packet

Arguments:

    pSpiInfo  - client to send challenge to
    pKeyExCtx - packet location to put challenge in

Return Value:

    FALSE - Indicates that client should be dropped/kicked
    TRUE  - Indicates Success

--*/
{
    CKeyExSgToXbChal *pKeyExChal = &pKeyExCtx->_KeyExSgToXbChal;

    //
    // Select and send challenges if possible. We can challenge clients with
    // connection services or those that request the signature service.
    // Other clients cannot be challenged because the logon state machine
    // is not set up to respond. We also cannot send a challenge to a Xenon
    // console running in back-compat.
    //

    if (!g_fEnableChallengeResponse)
    {
        pKeyExChal->_cbEnt = 0;
        return TRUE;
    }

    BOOL fChallenge = FALSE;
    fChallenge = fChallenge || pSpiInfo->_fCs;
    fChallenge = fChallenge || pSpiInfo->_AuthData.IsSvcAuthorized(
        XONLINE_SIGNATURE_SERVICE
        );
    if (!fChallenge)
    {
        pKeyExChal->_cbEnt = 0;
        return TRUE;
    }

    //
    // Setup the packet header
    //

    pKeyExChal->_wType = KEYEX_TYPE_SGTOXB_CHAL;
    pKeyExChal->_cbEnt = sizeof(CKeyExSgToXbChal);

    //
    // DVD challenges are depracated
    //

    pKeyExChal->_dwDvdBlock = 0;
    pKeyExChal->_ibDvdHash  = 0;
    pKeyExChal->_ibDvdCopy  = 0;

    //
    // First step is to check to see if a LUA challenge was not assigned, in
    // which case we attempt to do so
    //

    if (FALSE == SgLuaChalStateEnabled(pSpiInfo))
    {
        SgLuaChalAssign( pSpiInfo, FALSE );
    }

    //
    // See if the challenge thinks the client should be kicked or blocked
    //

    if (TRUE == SgLuaChalStateBlock(pSpiInfo)) 
    {

        pKeyExChal->_cbEnt = 0;
        TraceSz(
            ChalTrace,
            "%08lX not assigned key-ex due to block",
            pSpiInfo->_dwSpiRecv
            );
        SgPerfdataInterlockedInc( ChalSyncBlock );
        SgBlockInfoBlockPuid( &(pSpiInfo->_puid) );
        return FALSE;

    }
    if (TRUE == SgLuaChalStateKick(pSpiInfo))
    {

        pKeyExChal->_cbEnt = 0;
        TraceSz(
            ChalTrace,
            "%08lX not assigned key-ex due to kick",
            pSpiInfo->_dwSpiRecv
            );
        SgPerfdataInterlockedInc( ChalSyncFail );
        return FALSE;

    }

    //
    // If at this point we have an LUA assigned challenge, then we must attempt
    // to extract out the binary blob from it to fill in the challenge buff
    //

    if (FALSE == SgLuaChalStateEnabled(pSpiInfo))
    {
        //
        // Nothing more to do here
        //

        pKeyExChal->_cbEnt = 0;
        return TRUE;
    }

    DWORD dwSize = 1024;

    TraceSz(
        ChalTrace,
        "%08lX assigned key-ex code lua challenge %d",
        pSpiInfo->_dwSpiRecv,
        pSpiInfo->_dwLuaChalCodeId
        );

    //
    // Lua worker routine to copy the code buffer. Initialize the code and
    // param buffers to point directly to message buffer so that the code
    // and parameter bytes are copied directly to the message.
    //

    CBuffer code(pKeyExChal->_abPkSig, dwSize, 0);
    CBuffer param(pKeyExChal->_abParams,
                  sizeof(pKeyExChal->_abParams), 0);

    //
    // Attempt to get the binary information. This can fail if there was
    // a reload attempt
    //

    if (!SgLuaChalGetBinary(pSpiInfo, &code, &param))
    {
        pKeyExChal->_cbEnt = 0;
        return TRUE;
    }

    dwSize = code.GetSize();

    //
    // This challenge cannot be more than 1016 bytes. We don't have anything
    // close to that right now, so enforce this for all future requirements.
    //

    if (dwSize > 1016)
    {
        SgEventSz(CHAL_TOO_LARGE,
                   "Challenge id 0x%x size is %d. AES requires size to be no more than 1016 bytes.",
                   pSpiInfo->_dwLuaChalCodeId, dwSize );
        pKeyExChal->_cbEnt = 0;
        return TRUE;
    }


    //
    // Update the packet size field
    //

    pKeyExChal->_cbEnt += (WORD) (dwSize - sizeof(pKeyExChal->_abPkSig) );
    SgPerfdataInterlockedInc( ChalSyncIssue );

    //
    // encrypt the challenge. If we're using DES or DES3, we must use DES3 here for
    // back-compat. If we're using AES, then use AES to encrypt, and also make sure we're
    // encrypting a multiple of 16 bytes. This means the challenge binaries must be
    // carefully constructed -- safest is to always pad up to 16 bytes, but you can get
    // away with padding Xbox1 challenges to only 8 bytes.
    //

    DWORD dwChalSize = pKeyExCtx->_KeyExSgToXbChal._cbEnt - sizeof(CKeyExHdr);
    if (pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES_KEYSIZE ||
        pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES3_KEYSIZE)
    {
        if ((dwChalSize % 8) != 0)
        {
            SgEventSz(INVALID_KEYEX_CHAL_SIZE,
                       "Challenge id 0x%x size is %d. DES3 requires size to be a multiple of 8 bytes.",
                       pSpiInfo->_dwLuaChalCodeId, dwChalSize);
            pKeyExChal->_cbEnt = 0;
            return TRUE;
        }

        Assert((dwChalSize % 8) == 0);
        XcCrypt(
            XC_SERVICE_ENCRYPT,
            pSpiInfo->_keyMaterialDes._abKeyCryptXmit,
            XC_SERVICE_DES3_KEYSIZE,
            pSpiInfo->_abNonceResp,
            (BYTE *)&pKeyExCtx->_KeyExSgToXbChal + sizeof(CKeyExHdr),
            dwChalSize,
            NULL,
            0
            );
    }
    else
    {
        // AES. Force alignment to 16 byte boundary
        pKeyExChal->_cbEnt += (WORD) (ROUNDUP16(dwChalSize) - dwChalSize);
        dwChalSize = ROUNDUP16(dwChalSize);

        Assert((dwChalSize % 16) == 0);
        C_ASSERT(offsetof(CSpiInfo, _abNonceResp) - offsetof(CSpiInfo, _abNonceInit) == 8);
        XcCrypt(
            XC_SERVICE_ENCRYPT,
            pSpiInfo->_keyMaterialAes._abKeyCryptXmit,
            XC_SERVICE_AES_KEYSIZE,
            pSpiInfo->_abNonceInit,  // _abNonceInit + _abNonceResp
            (BYTE *)&pKeyExCtx->_KeyExSgToXbChal + sizeof(CKeyExHdr),
            dwChalSize,
            NULL,
            0
            );
    }
    return TRUE;
}

BOOL SgChalAssignAsyncChallenge(
    CSpiInfo *          pSpiInfo,
    CSecMsgSgToXbChal * pSecMsgSgToXbChal
    )
/*++

Routine Description:

    Select a async challenge to send to the client. If a challenge is found,
    copy it into the packet.

    This is only called from within the SpiTimer path. At the point that
    this routine is called, the SPI can be in the following state:

        IDLE -> call "__Target" in LUA script
        WAIT_FOR_ACK -> call "__ChallengeWaitForAckTimeout" in LUA script
        WAIT_FOR_RESP -> call "__ChallengeWaitForRespTimeout" in LUA script

    If the LUA script enables the challenge (Chal.SetParamId), then the
    SPI transitions to the WAIT_FOR_ACK state.

    If the LUA script KICKS/BLOCKS (Chal.Kick, Chal.Block), then the
    connection is setup to be closed.

    If the LUA script disables the challenge (Chal.SetEnable), then the
    SPI transitions to the IDLE state.

Arguments:

    pSpiInfo          - client to send challenge to
    pSecMsgSgToXbChal - packet location to put challenge in

Return Value:

    FALSE - Indicates that no challenge was assigned
    TRUE  - Indicates Success

--*/
{
    BOOL    bNonceRequired        = FALSE;
    BOOL    bChallengeFound       = FALSE;
    BOOL    bKicked               = FALSE;
    BYTE  * pb                    = (BYTE *)(pSecMsgSgToXbChal->_abPkSig);
    DWORD   dwLastChalCodeId      = pSpiInfo->_dwLuaChalCodeId;
    DWORD   dwLastChalCodeParamId = pSpiInfo->_dwLuaChalCodeParamId;
    DWORD   dwSize                = 1024;
    CBuffer code(pb, dwSize, 0);
    CBuffer param(pSecMsgSgToXbChal->_abParams, sizeof(pSecMsgSgToXbChal->_abParams), 0);


    //
    // Pick the LUA call to make based upon our current state
    // 

    switch (pSpiInfo->_dwChalAsyncState) 
    {
    case SPI_CHAL_ASYNC_STATE_WAIT_FOR_ACK:

        //
        // Tell LUA that there was an ack timeout
        // 

        SgLuaChalWaitForAckTimeout( pSpiInfo );
        SgPerfdataInterlockedInc( ChalAsyncTimeoutAck );

        break;

    case SPI_CHAL_ASYNC_STATE_WAIT_FOR_RESP:

        //
        // Tell LUA that there was an resp timeout
        // 

        SgLuaChalWaitForRespTimeout( pSpiInfo );
        SgPerfdataInterlockedInc( ChalAsyncTimeoutResp );

        break;

    default:

        // 
        // Pick a new nonce
        // 

        bNonceRequired = TRUE;

        //
        // Assign a challenge
        // 

        SgLuaChalAssign( pSpiInfo, TRUE );
        
    }

    //
    // At this point, try to find the LUA assigned challenge. Extract out the
    // binary blob from it to fill in the challenge buffer
    //

    if (FALSE == SgLuaChalStateEnabled(pSpiInfo))
    {

        TraceSz(
            ChalTrace,
            "[%08lX]: no suitable challenge can be found",
            pSpiInfo->_dwSpiRecv
            );
        goto complete;

    }
    if (TRUE == SgLuaChalStateBlock(pSpiInfo))
    {

        TraceSz(
            ChalTrace,
            "[%08lX] blocked LUA challenge id 0x%X nonce %08lX",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwLuaChalCodeId,
            pSpiInfo->_dwChallengeNonce
            );    

        bKicked = TRUE;
        SgPerfdataInterlockedInc(ChalAsyncBlock);
        SgBlockInfoBlockPuid( &(pSpiInfo->_puid) );

    }
    if (TRUE == SgLuaChalStateKick(pSpiInfo)) 
    {
        TraceSz(
            ChalTrace,
            "[%08lX] kicked LUA challenge id 0x%X nonce %08lX",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwLuaChalCodeId,
            pSpiInfo->_dwChallengeNonce
            );    

        bKicked = TRUE;
        SgPerfdataInterlockedInc(ChalAsyncFail);

    }
    if (TRUE == bKicked) 
    {
        goto complete;
    }

    //
    // Nonce Generation Rules:
    //  * State == OFF|IDLE -> New Nonce Required
    //  * State == ACK|RESP -> New Nonce Only if challenge changes
    //

    if ( (pSpiInfo->_dwChalAsyncState == SPI_CHAL_ASYNC_STATE_WAIT_FOR_ACK ||
          pSpiInfo->_dwChalAsyncState == SPI_CHAL_ASYNC_STATE_WAIT_FOR_RESP) &&
         (pSpiInfo->_dwLuaChalCodeId != dwLastChalCodeId || 
          pSpiInfo->_dwLuaChalCodeParamId != dwLastChalCodeParamId) ) 
    {
        bNonceRequired = TRUE;
    }

    //
    // Nonce Generation
    // 

    if (bNonceRequired == TRUE) 
    {
        do {

            SgRand(
                (BYTE *) &pSpiInfo->_dwChallengeNonce,
                sizeof(pSpiInfo->_dwChallengeNonce)
                );

        } while (pSpiInfo->_dwChallengeNonce == 0);
    }

    TraceSz(
        ChalTrace,
        "[%08lX] %sassigned LUA challenge id 0x%X nonce %08lX",
        pSpiInfo->_dwSpiRecv,
        (bNonceRequired ? "" : "re:"),
        pSpiInfo->_dwLuaChalCodeId,
        pSpiInfo->_dwChallengeNonce
        );

    //
    // Lua worker routine to copy the code buffer. Initialize the code and
    // param buffers to point directly to message buffer so that the code
    // and parameter bytes are copied directly to the message.
    //

    //
    // Get the binary and parameter information. This can fail due to a
    // reload config
    //

    if (SgLuaChalGetBinary(pSpiInfo, &code, &param) == FALSE)
    {

        TraceSz(
            ChalTrace,
            "[%08lX]: no suitable binary can be found",
            pSpiInfo->_dwSpiRecv
            );
        goto complete;

    }

    //
    // Craft the rest of the packet properly
    //

    pb += code.GetSize();
    pSecMsgSgToXbChal->_wType = SECMSG_TYPE_SGTOXB_CHAL;
    pSecMsgSgToXbChal->_dwChallengeNonce = pSpiInfo->_dwChallengeNonce;
    pSecMsgSgToXbChal->_dwChallengeFlags = 0;
    pSecMsgSgToXbChal->_cbEnt = (WORD)(pb - (BYTE *)pSecMsgSgToXbChal);
    bChallengeFound = TRUE;

    SgPerfdataInterlockedInc( ChalAsyncIssue );

complete:

    //
    // Result depends on if we found a challenge or not
    // 
    if (TRUE == bKicked) 
    {

        //
        // Disable challenges
        // 

        SgLuaChalSetAsyncStateOff( pSpiInfo );

    }
    else if (bChallengeFound == FALSE) 
    {

        //
        // Go back to the the idle state
        // 

        SgLuaChalSetAsyncStateIdle( pSpiInfo );

    }
    else
    {
        //
        // Wait for the ACK
        // 
        
        SgLuaChalSetAsyncStateWaitForAck( pSpiInfo );

    }

    return bChallengeFound;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgclientstats.cpp ===
// ---------------------------------------------------------------------------------------
// sgstatistics.cpp
//
// Copyright (C) Microsoft Corporation
//
// This class is tied to CSpiInfo in sgstate.cpp. The index into g_pClientStats maps 
// one-to-one with g_pSpiInfo, for instance. The reason this class isn't included within 
// the definition of CSpiInfo is it allocates memory dynamically. This class is also tied 
// to CSvcInfo, since we dynamically allocate memory based on the number of services 
// configured.
//
// This means we need to reference the local global (?) variables in sgstate.cpp.
//
// ---------------------------------------------------------------------------------------

#include "sg.h"
#include <math.h>

XomImportArea(SgClientStats);
// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

static void             SgClientStatsReportTimer(CTimer*);
static void             SgClientStatsRefreshTimer(CTimer*);

// ---------------------------------------------------------------------------------------
// Global variables
// ---------------------------------------------------------------------------------------

static CSgStats         g_sgStats;
static UINT             g_cTicksPerReport;          // How often to report global stats (mean, stddev, etc)
static UINT             g_cTicksRefreshFrequency;   // How often to refresh global stats (period)
static CTimer           g_statsReportTimer;         // timer to periodically report global stats
static CTimer           g_statsRefreshTimer;        // timer to refresh global sg stats

// References to other globals.. *sigh* See comments at top of file for reason we are 
// doing this.
extern UINT             g_cSpiInfoFree;
extern UINT             g_cSpiInfoInUse;
extern UINT             g_cSpiInfo; 
extern CSpiInfo *       g_pSpiInfo;
extern UINT             g_cSvcInfo;
extern CSvcInfo *       g_pSvcInfo;

static INLINE DWORD     SpiToClientIdx(CSpiInfo *pSpiInfo) { return (pSpiInfo->_dwSpiRecv >> 8) % g_cSpiInfo; }
static INLINE BOOL      IsSpiActive(CSpiInfo *pSpiInfo)    { return (pSpiInfo && !pSpiInfo->_fDeleted && pSpiInfo->_leFree.Flink == NULL); }

BOOL SgClientStatsInit()
{
    g_sgStats.Init();
    g_statsReportTimer.Init();
    g_statsRefreshTimer.Init();
    return (TRUE);
}

void SgClientStatsTerm()
{
    g_sgStats.Term();
    // no need to cancel timer - it will be gracefully cancelled when the Sg terminates
}

// -------------------------------------------------------------------------------------
// SgClientStatsRefreshTimer
//
// Updates the global SG statistics in CSgStats for each client. This is done very 
// similarly to the SpiInfoTimer, where we loop through each client on a long period.  
// Let's say the period is 300 seconds.. then this function will run every tick (200 ms) 
// but only update 1 / (300 * 5) of the total clients.  
// -------------------------------------------------------------------------------------
void SgClientStatsRefreshTimer(CTimer*)
{
    static UINT s_cTimerNumer           = 0;
    static UINT s_iLastSpiInfoIdx       = 0;
    UINT        cTicksRefreshFrequency  = g_cTicksRefreshFrequency;
    UINT        startCount              = 0;
    UINT        activeCount             = 0;

    ULONGLONG qwStartTime = SgGetSystemTime();

    
    if (g_cSpiInfoInUse == 0)
        goto lDone;

    s_cTimerNumer += g_cSpiInfoInUse;

    if (s_cTimerNumer < cTicksRefreshFrequency)
        goto lDone;

    UINT count      = s_cTimerNumer / cTicksRefreshFrequency;
    startCount      = count;
    s_cTimerNumer    -= count * cTicksRefreshFrequency;

    Assert(s_cTimerNumer < cTicksRefreshFrequency);

    UINT iSpiInfoIdx = s_iLastSpiInfoIdx;

    for (; count > 0; --count, ++iSpiInfoIdx)
    {
        if (iSpiInfoIdx >= g_cSpiInfoInUse)
            iSpiInfoIdx = 0;

        CSpiInfo * pSpiInfo = &g_pSpiInfo[iSpiInfoIdx];

        if (!IsSpiActive(pSpiInfo))
        {
            // Not active
            continue;
        }

        // Update global stats with this client
        activeCount++;
        SgClientStatsRefreshStats(pSpiInfo);
    }

    s_iLastSpiInfoIdx = iSpiInfoIdx;

lDone:
    ULONGLONG qwEndTime = SgGetSystemTime();
    if (Tag(ClientStatsFlow))
    {
        TraceSz(ClientStatsFlow, "RefreshTimer: %u/%u in %u ms [g_cSpiInfoInUse=%5u, cTimerNumer=%5u, s_iLastSpiInfoIdx=%5u]", 
                 activeCount,
                 startCount,
                 (UINT)((qwEndTime - qwStartTime) / 10000), 
                 g_cSpiInfoInUse, 
                 s_cTimerNumer, 
                 s_iLastSpiInfoIdx);
    }

    // reschedule
    if (g_sgStats.IsEnabled())
    {
        SgTimerSet(&g_statsRefreshTimer, SgClientStatsRefreshTimer, SgTimerTick() + 1, TRUE);
    }
}


// -------------------------------------------------------------------------------------
// SgClientStatsReportTimer
//
// Called by timer periodically to report the stats information. Useful for gathering 
// stats info or debugging.
// -------------------------------------------------------------------------------------
void SgClientStatsReportTimer(CTimer*)
{
    CLargeStr statsText;
    g_sgStats.GetStatsOverall(&statsText);
    TraceSz(ClientStats, statsText.cstr());

    // reschedule
    if (g_cTicksPerReport > 0 && g_sgStats.IsEnabled())
    {
        SgTimerSet(&g_statsReportTimer, SgClientStatsReportTimer, SgTimerTick() + g_cTicksPerReport, TRUE);
    }
}


// -------------------------------------------------------------------------------------
// SgClientStatsConfig
//
// Entry point for config changes. Called first time and also whenever "reload_config" 
// occurs. 
// -------------------------------------------------------------------------------------
BOOL SgClientStatsConfig(CCfgInfo * pci)
{
    TraceSz( Config, "SgClientStatsConfig:" );
    
    UINT cHistoryInMs;
    UINT cWarningSigmaInterval;
    UINT cDisconnectSigmaInterval;
    UINT cConfidenceLimit;
    UINT cSecondsPerPenalty;

    // Get settings

    if (!pci->GetVar("StatsHistoryInMs",               &cHistoryInMs,             0, 1000*60*60*4,   0) ||
        !pci->GetVar("StatsWarningSigmaInterval",      &cWarningSigmaInterval,    0,         1000,   3) ||
        !pci->GetVar("StatsDisconnectSigmaInterval",   &cDisconnectSigmaInterval, 0,         1000,   0) ||
        !pci->GetVar("StatsConfidenceLimitInClients",  &cConfidenceLimit,         0,        65535,  10) ||
        !pci->GetVar("StatsPenaltyTimeInSeconds",      &cSecondsPerPenalty,       0,     60*60*24,  60) ||
        !pci->GetVar("StatsReportIntervalInSeconds",   &g_cTicksPerReport,        0,     60*60*24,   0) ||
        !pci->GetVar("StatsRefreshFrequencyInSeconds", &g_cTicksRefreshFrequency, 1,      60*60*4,  60))
    {
        return FALSE;
    }

    // Convert from seconds to ticks
    g_cTicksPerReport        *= TICKS_PER_SECOND;
    g_cTicksRefreshFrequency *= TICKS_PER_SECOND;
    TraceSz(Config, "    Configured report timer to %d seconds (%d ticks)", g_cTicksPerReport / TICKS_PER_SECOND, g_cTicksPerReport);
    TraceSz(Config, "    Configured refresh frequency timer to %d seconds (%d ticks)", g_cTicksRefreshFrequency / TICKS_PER_SECOND, g_cTicksRefreshFrequency);

    if (!g_sgStats.Config(cHistoryInMs, 
                          cWarningSigmaInterval, 
                          cDisconnectSigmaInterval, 
                          cConfidenceLimit,
                          cSecondsPerPenalty))
    {
        TraceSz(Config, "    Failed to configure CSgStats");
        return FALSE;
    }
    
    // Start report timer (long) on next tick
    if (g_cTicksPerReport > 0 && cHistoryInMs > 0)
    {
        SgTimerSet(&g_statsReportTimer, SgClientStatsReportTimer, SgTimerTick() + g_cTicksPerReport, TRUE);
    }
    
    // Start stats refresh timer. Ok to reschedule, previous appointments will be 
    // cancelled.
    if (cHistoryInMs > 0)
    {
        SgTimerSet(&g_statsRefreshTimer, SgClientStatsRefreshTimer, SgTimerTick() + 1, TRUE);
    }

    return TRUE;
}

// -------------------------------------------------------------------------------------
// SgClientStatsAttach
//
// Entry point. Called when a new spi info gets allocated.
// -------------------------------------------------------------------------------------
void SgClientStatsAttach(CSpiInfo * pSpiInfo)
{
    g_sgStats.AttachClient(SpiToClientIdx(pSpiInfo));
}

// -------------------------------------------------------------------------------------
// SgClientStatsProcessPacket
//
// Entry point for the rest of the SG to process a new packet. Presumably we only track 
// incoming packets from the Internet NIC.
// -------------------------------------------------------------------------------------
void SgClientStatsProcessPacket(CPacket * ppkt, CDstInfo * pDstInfo)
{
    // Get the SPI from the spiinfo and use it to index into out client stats array, just 
    // like SgSpiInfoAttach does for the spiinfo array.
    CSpiInfo *      pSpiInfo        = ppkt->_pSpiInfo;
    Assert(pSpiInfo != NULL);
    g_sgStats.ProcessPacket(SpiToClientIdx(pSpiInfo), ppkt, pDstInfo);
}

// -------------------------------------------------------------------------------------
// SgClientStatsRefreshStats
//
// Entry point. Called on the spi timer to incrementally update the global stats with this 
// client's info. Be fast like a ninja!
// -------------------------------------------------------------------------------------
void SgClientStatsRefreshStats(CSpiInfo * pSpiInfo)
{
    g_sgStats.RefreshStats(SpiToClientIdx(pSpiInfo));
}


#ifdef SG_FEATURE_XMGMT

// -------------------------------------------------------------------------------------
// SgClientStatsMgmtCmd
//
// Entry point for xmgmt commands with the "stats" command
// -------------------------------------------------------------------------------------
void SgClientStatsMgmtCmd(CXomParamList * pxompl, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
#define ERR_MSG(msg) \
    TraceSz(ClientStats, "Operation failed: %s\r\n", msg); \
    pResponseInterface->WriteResponse( \
        dwRequestId, \
        (BYTE *)"Operation failed: " msg "\r\n", \
        (DWORD) -1)
        
#define IF_FAILED_GOTO_LDONE(op) \
    if(!(op)) { \
        ERR_MSG(#op); \
        goto lDone; \
    }


    // Dynamically allocate and grow memory as needed. Seed it to a reasonable starting 
    // value.

    CSmallStr statsText;
    statsText.SetAllocator(CMemAlloc::Default());
    if (!statsText.SetCapacity(4000))
    {
        ERR_MSG("allocating 4000 bytes for text string");
        return;
    }

    // Verify stats are even enabled
    if (!g_sgStats.IsEnabled())
    {
        ERR_MSG("Client statistics are not enabled.");
        return;
    }

    //
    // Process commands here
    // 
    
    ULONGLONG qwStartTime = SgGetSystemTime();

    if (pxompl->GetCount() == 1)
    {
        IF_FAILED_GOTO_LDONE(g_sgStats.GetStatsOverall(&statsText));
    }
    else if (pxompl->GetCount() == 2 &&
             _strcmpi(pxompl->GetParam(1), "histogram") == 0)
    {
        IF_FAILED_GOTO_LDONE(g_sgStats.GetStatsHistogram(&statsText));
    }
    else if (pxompl->GetCount() == 3 &&
             _strcmpi(pxompl->GetParam(1), "mpuid") == 0)
    {
        IF_FAILED_GOTO_LDONE(g_sgStats.GetStatsClientByPuid(&statsText, _strtoui64(pxompl->GetParam(2), NULL, 0)));
    }
    else if (pxompl->GetCount() == 3 &&
             _strcmpi(pxompl->GetParam(1), "spi") == 0)
    {
        IF_FAILED_GOTO_LDONE(g_sgStats.GetStatsClientBySpi(&statsText, strtoul(pxompl->GetParam(2), NULL, 0)));
    }
    else if (pxompl->GetCount() == 2 &&
             _strcmpi(pxompl->GetParam(1), "warnings") == 0)
    {
        IF_FAILED_GOTO_LDONE(g_sgStats.GetStatsWarnings(&statsText));
    }
    else if (pxompl->GetCount() == 2 &&
             _strcmpi(pxompl->GetParam(1), "reset") == 0)
    {
        g_sgStats.ClearStats();
        statsText.Format("Global stats have been reset for all packet types.\r\n");
    }
    else
    {
        ERR_MSG("invalid params\r\n");
        goto lDone;
    }

    ULONGLONG qwEndTime = SgGetSystemTime();
    statsText.Format("This report took %u ms to generate.\r\n", (UINT)((qwEndTime - qwStartTime) / 10000));

    // Output

    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE *)statsText.cstr(),
        (DWORD)statsText.GetLength()
        );

lDone:

    return;
}

#endif // SG_FEATURE_XMGMT

// -------------------------------------------------------------------------------------
// Class CPacketHistoryRecord
// -------------------------------------------------------------------------------------

DWORD CPacketHistoryRecord::s_cTicksPerBucket = 1;
DWORD CPacketHistoryRecord::s_cHistoryInMs = 1;

// -------------------------------------------------------------------------------------
// CPacketHistoryRecord::Increment
//
// Increments counter within appropriate bucket. Will clear out old buckets plus the 
// newest bucket.
// -------------------------------------------------------------------------------------
void
CPacketHistoryRecord::Increment()
{
    // Note: I refer to fractions and buckets interchangeably.  
    // Note2: This code is based on \private\server\kdc\dos\kdcdos.cpp

    UINT64 now          = SgTimerTick(); 
    UINT64 fractionNow  = TicksToFraction(now); 

    // Clear out stale entries

    Refresh();

    // Increment current fraction. Be careful not to overflow.
    
    DWORD fractionSlot = (DWORD) (fractionNow % SGSTATS_REQUEST_COUNT_FRACTIONS);

    if (_aCountFractions[fractionSlot] != 0xFFFF)
    {
        _aCountFractions[fractionSlot]++;
    }
}

// -------------------------------------------------------------------------------------
// CPacketHistoryRecord::Refresh
//
// As time marches on, we need to clear out the old buckets that we may have skipped over, 
// plus the current bucket if we just rolled over. Otherwise we get stale values and no 
// one likes stale values, unless you are making stats croutons.
// -------------------------------------------------------------------------------------
void
CPacketHistoryRecord::Refresh()
{
    // Note2: This code is based on \private\server\kdc\dos\kdcdos.cpp

    UINT64 now          = SgTimerTick(); 
    UINT64 fractionNow  = TicksToFraction(now); 
    UINT64 fractionLast = TicksToFraction(_qwTickLastRequest);
    UINT64 fractionDiff = fractionNow - fractionLast;

    if (fractionDiff == 0)
    {
        return;
    }
    else if (fractionDiff > SGSTATS_REQUEST_COUNT_FRACTIONS)
    {
        // More time than current window size has elapsed. Clear all fractions.
        ZeroMemory(_aCountFractions, sizeof(WORD) * SGSTATS_REQUEST_COUNT_FRACTIONS);
    }
    else if (fractionDiff > 0)
    {
        // Bucket has rolled over, clear all fractions in between last access and now, 
        // including the now bucket. Is that (last, now] or something?

        UINT64 fractionClearStart = fractionLast + 1;
        UINT64 fractionClearEnd = fractionClearStart + fractionDiff - 1;

        for (UINT64 i = fractionClearStart; i <= fractionClearEnd; i++)
        {
            _aCountFractions[i % SGSTATS_REQUEST_COUNT_FRACTIONS] = 0;
        }
    }

    // Update last seen time. This is only used to know when we need to clear out entries, 
    // so updating in Refresh() is more appropriate than Increment().

    _qwTickLastRequest = now;
   
}

// -------------------------------------------------------------------------------------
// CPacketHistoryRecord::GetCount
//
// Get total count of packets seen in this window
// -------------------------------------------------------------------------------------
DWORD
CPacketHistoryRecord::GetCount()
{
    // Clear out old entries
    Refresh();

    // @@@ Optimization idea: instead of calling Refresh() then adding up every slot, why 
    // not just add up the "valid" slots and skip Refresh().  Go from now back 8 slots and 
    // take intersection of this window with the _aCountFractions window.
    DWORD requestCount = 0;
    for (DWORD i = 0; i < SGSTATS_REQUEST_COUNT_FRACTIONS; i++)
    {
        requestCount += _aCountFractions[i];
    }
    
    return requestCount;

}

// -------------------------------------------------------------------------------------
// CPacketHistoryRecord::GetStatsDetailed
//
// Retrieve detailed stats info for this packet type record
// -------------------------------------------------------------------------------------
void
CPacketHistoryRecord::GetStatsDetailed(CStr * pText,StatsFormatType statsFormatType)
{
    DWORD  dwTotal     = GetCount();
    DWORD  dwPerSec    = CountToRate(dwTotal);
    UINT64 fractionNow = TicksToFraction(SgTimerTick()); 

    C_ASSERT(SGSTATS_REQUEST_COUNT_FRACTIONS == 8);
    const CHAR c_szDisplayFormat[] = "%7d %7d %5d %5d %5d %5d %5d %5d %5d %5d";
    const CHAR c_szLogFormat[] = "%d|%d|%d|%d|%d|%d|%d|%d|%d|%d";
    PCSTR szFormat = NULL;

    if (statsFormatType == StatsFormatLog)
    {
        if (dwTotal == 0)
        {
            return;
        }

        szFormat = c_szLogFormat;
    }
    else
    {
        szFormat = c_szDisplayFormat;
    }
    pText->Format(szFormat,
        dwTotal,
        dwPerSec,
        _aCountFractions[(fractionNow - 0) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 1) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 2) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 3) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 4) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 5) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 6) % SGSTATS_REQUEST_COUNT_FRACTIONS],
        _aCountFractions[(fractionNow - 7) % SGSTATS_REQUEST_COUNT_FRACTIONS]);
}


// -------------------------------------------------------------------------------------
// Class CClientStats
// -------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------
// CClientStats::Init
//
// Prepare object for use. We allocate the packet history memory elsewhere, so we don't 
// end up with a bunch of small allocations. It's assumed the caller knows what it is 
// doing and passes the correct pointer to the memory to use.
// -------------------------------------------------------------------------------------
void
CClientStats::Init(VOID *pBuffer, DWORD cPacketTypes)
{
    _aPacketHistory = (CPacketHistoryRecord*)pBuffer;
    _cPacketHistory = cPacketTypes;
    _qwTickWarning = 0;
    _dwTicksPerPenalty = 0;
}

// -------------------------------------------------------------------------------------
// CClientStats::Reset
//
// Clear out object, prepare for re-use.
// -------------------------------------------------------------------------------------
void
CClientStats::Reset()
{
    memset(_aPacketHistory, 0, _cPacketHistory * sizeof(CPacketHistoryRecord));
    _qwTickWarning = 0;
    _dwTicksPerPenalty = 0;
}

// -------------------------------------------------------------------------------------
// CClientStats::ProcessPacket
//
// Determine packet type, increment packet counter for this client.
// -------------------------------------------------------------------------------------
void
CClientStats::ProcessPacket(CPacket * ppkt, CDstInfo * pDstInfo)
{
    // Note: Only 1 packet per SPI is processed at a time. So the lock being held right 
    // now protects from changes to the client stats objects, and we don't need to worry 
    // about multiple packets getting processed and incremented simultaneously within this 
    // function. Go ahead and use ++ all you want!

    
    // Pull out pointers to useful info, mostly collected from SgIRecvWithSpi
    CSpiInfo *      pSpiInfo    = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr  = (CSecMsgHdr *)ppkt->_pb;
    CXspHdr *       pXspHdr     = ppkt->_pXspHdr;
    CXspTail *      pXspTail    = ppkt->_pXspTail;
    CTcpInfo *      pTcpInfo    = &((CTcpInfo *)pXspTail)[-1];

    // Find the XSP_TYPE_* and convert to 0 byte port version of constant
    BYTE bXspType = (pXspHdr->_bFlags & XSP_TYPE_MASK) - ppkt->_cbBpp;

    // First handle the major categories of packets
    if (bXspType == XSP_TYPE_SEC)
    {
        ProcessPacketType(SGSTATS_PT_SECMSG, ppkt);
        // This is not a service packet, stop processing
        return;
    }
    else if (bXspType == XSP_TYPE_TCP_0)
    {
        // TCP, check SYN
        if (pTcpInfo->_bFlags & TCP_SYN)
            ProcessPacketType(SGSTATS_PT_TCPSYN, ppkt);
        else
            ProcessPacketType(SGSTATS_PT_TCP, ppkt);
    }
    else if (bXspType == XSP_TYPE_UDP_0)
    {
        ProcessPacketType(SGSTATS_PT_UDP, ppkt);
    }
    else if (bXspType >= XSP_TYPE_VDP_0)
    {
        ProcessPacketType(SGSTATS_PT_VDP, ppkt);
    }
    else
    {
        TraceSz(ClientStatsFlow, "ProcessPacket %s: Unknown packet type. Xsp type is %d",
                ppkt->Str(),
                pXspHdr->_bFlags & XSP_TYPE_MASK);
        // @@@ Event here? How unusual is this?
        return;
    }

    // Now handle the per-service packets

    // Lookup service index (_iSvcInfo) for the first service targetted by this packet. 
    // This can be done simply by looking at the service(s) provided in 
    // CDstInfo._dwSvcMask. Each bit there represents the position in g_pSvcInfo to fin:bd 
    // the relevant service. However, since services are always stuck into that array in 
    // sequential order starting at 0, we only need the _iSvcInfo (bit provided by service 
    // mask) value. 
    //
    // The gotcha comes from the fact each server (destination port) can provide one or 
    // more services. When the SG gets a packet destined for a port, it can't necessarily 
    // map that back to a single service. Here, we'll just use the first lowest-numbered 
    // service we find. For our base services, each server provides exactly one service, 
    // so we should be just fine.

    DWORD iSvcInfo;
    for (iSvcInfo = 0; iSvcInfo < CSVCINFOMAX; iSvcInfo++)
    {
        if (pDstInfo->_svcMask.IsBitSet(iSvcInfo))
        {
            break;
        }
    }

    ProcessPacketType(SGSTATS_PT_SVCBASE + iSvcInfo, ppkt);

}

// -------------------------------------------------------------------------------------
// CClientStats::ProcessPacketType
//
// Internal routine for incrementing the packet count of the given packet type.
// -------------------------------------------------------------------------------------
void
CClientStats::ProcessPacketType(DWORD dwPktType, CPacket * ppkt)
{
    Assert(dwPktType < _cPacketHistory);
    _aPacketHistory[dwPktType].Increment();

    if (Tag(ClientStatsFlow))
    {
        // This is somewhat expensive to do upon every packet, fyi.
        DWORD count = _aPacketHistory[dwPktType].GetCount();
        TraceSz(ClientStatsFlow, "ProcessPacket %s: +1 Total %5d PerSec %5d [%2d %s]",
                 ppkt->Str(),
                 count,
                 CPacketHistoryRecord::CountToRate(count),
                 dwPktType,
                 PacketTypeToString(dwPktType));
    }
}

// -------------------------------------------------------------------------------------
// CClientStats::GetCount
//
// Returns total count of packets for given packet type.
// -------------------------------------------------------------------------------------
DWORD
CClientStats::GetCount(DWORD dwPktType)
{
    Assert(dwPktType < _cPacketHistory);
    return _aPacketHistory[dwPktType].GetCount();
}

// -------------------------------------------------------------------------------------
// CClientStats::Warn
//
// Called when a client has exceeded its warning limit to generate a notification or 
// otherwise mark this client as 'interesting'. This should throttle excessive 
// notification.
// -------------------------------------------------------------------------------------
UINT64
CClientStats::Warn(DWORD dwPktType, DWORD dwLimit, DWORD dwPenaltyTimeInTicks)
{
    UINT64 lastWarning = _qwTickWarning;
    _qwTickWarning = SgTimerTick();
    _dwTicksPerPenalty = dwPenaltyTimeInTicks;
    return lastWarning;
}

// -------------------------------------------------------------------------------------
// CClientStats::IsInPenaltyBox
//
// Is this client being tracked because it did something bad?
// -------------------------------------------------------------------------------------
BOOL
CClientStats::IsInPenaltyBox()
{
    if (_qwTickWarning == 0)
    {
        return FALSE;
    }
    return (_qwTickWarning >= (SgTimerTick() - _dwTicksPerPenalty));
}

// -------------------------------------------------------------------------------------
// CClientStats::GetStatsDetailed
//
// Retrieve detailed stats info for this client.
// -------------------------------------------------------------------------------------
void
CClientStats::GetStatsDetailed(CStr * pText)
{
    pText->Format("  Total Packets <---- Total Packets History ------------------>\r\n");
    pText->Format("Packets Per Sec   [0]  [-1]  [-2]  [-3]  [-4]  [-5]  [-6]  [-7] PktType\r\n");
    pText->Format("======= ======= ===== ===== ===== ===== ===== ===== ===== ===== =======\r\n");
    for (DWORD iPktType = 0; iPktType < _cPacketHistory; iPktType++)
    {
        _aPacketHistory[iPktType].GetStatsDetailed(pText, StatsFormatEvent);
        pText->Format(" %s\r\n", PacketTypeToString(iPktType));
    }

}

// -------------------------------------------------------------------------------------
// CClientStats::LogStatsDetailed
//
// Retrieve detailed stats info for this client and log it
// -------------------------------------------------------------------------------------
void
CClientStats::LogStatsDetailed(ULONGLONG qwMachinePuid)
{
    TLocalStr<1024> str;
    for (DWORD iPktType = 0; iPktType < _cPacketHistory; iPktType++)
    {
        str.Reset();
        _aPacketHistory[iPktType].GetStatsDetailed(&str, StatsFormatLog);
        if (!str.IsEmpty())
        {
            //don't log the packet type if there is no data
            SvcLogLvl(SgClientStats, L_LOW,
                       "SGCLSD|%016I64X|%s|%s",
                       qwMachinePuid,
                       str.cstr(), 
                       PacketTypeToString(iPktType));
        }
    }

}

// -------------------------------------------------------------------------------------
// CClientStats::PacketTypeToString 
//
// Convert a packet type index into a human string 
// (static)
// -------------------------------------------------------------------------------------
LPCSTR
CClientStats::PacketTypeToString(DWORD dwPktType)
{
    switch (dwPktType)
    {
    case SGSTATS_PT_UNKNOWN: return "UNKNOWN";
    case SGSTATS_PT_SECMSG:  return "SECMSG";
    case SGSTATS_PT_UDP:     return "UDP";
    case SGSTATS_PT_TCP:     return "TCP";
    case SGSTATS_PT_VDP:     return "VDP";
    case SGSTATS_PT_TCPSYN:  return "TCPSYN";
    }

    // Must be a service
    Assert(dwPktType - SGSTATS_PT_SVCBASE < g_cSvcInfo);
    CSvcInfo *pSvcInfo = &g_pSvcInfo[dwPktType - SGSTATS_PT_SVCBASE];
    return pSvcInfo->_achName;
}


// -------------------------------------------------------------------------------------
// Class CSgStats
// -------------------------------------------------------------------------------------


void
CSgStats::Init()
{
    _bClientStatsEnabled = FALSE;
    _cHistoryInMs = 0;
    _cWarningSigmaInterval = 0;
    _cDisconnectSigmaInterval = 0;
    _cPacketTypes = 0;
    _cTicksPerPenalty = 0;
    _cSvcInfoLast = 0;
    _cSpiInfoLast = 0;

    // Reset memory
    ClearMemory();
    ClearStats();
}

void
CSgStats::Term()
{
    WriteLock();
    ClearMemory();
    WriteUnlock();
}


// -------------------------------------------------------------------------------------
// CSgStats::ClearMemory
//
// Clears memory only, useful for configuration changes that may alter how much memory we 
// need. Adding a service is a good example.
// -------------------------------------------------------------------------------------
void
CSgStats::ClearMemory()
{
    if (_pClientStats != NULL)
    {
        SgMemFree(_pClientStats);
        _pClientStats = NULL;
        _cClientStats = 0;
    }
    if (_pPacketHistoryRecords != NULL)
    {
        SgMemFree(_pPacketHistoryRecords);
        _pPacketHistoryRecords = NULL;
        _cPacketHistoryRecords = 0;
    }

}

// -------------------------------------------------------------------------------------
// CSgStats::ClearStats
//
// Reset running stats values
// -------------------------------------------------------------------------------------
void
CSgStats::ClearStats()
{
    for (DWORD i = 0; i < SGSTATS_PT_MAX; i++)
    {
        _PacketStats[i]._Mean = 0;
        _PacketStats[i]._Max = 0;
        _PacketStats[i]._Min = MAXDWORD;
        _PacketStats[i]._Variance = 0;
        _PacketStats[i]._StdDev = 0;
        _PacketStats[i]._LimitWarning = MAXDWORD;
        _PacketStats[i]._LimitDisconnect = MAXDWORD;
        _PacketStats[i]._NumSamples = 0;
    }
}

// -------------------------------------------------------------------------------------
// CSgStats::Config 
//
// Initialize all settings, allocate memory. Will reset itself if called again 
// with different values.
// {{{
// -------------------------------------------------------------------------------------
BOOL
CSgStats::Config(
    UINT cHistoryInMs,
    UINT cWarningSigmaInterval,
    UINT cDisconnectSigmaInterval,
    UINT cConfidenceLimit,
    UINT cSecondsPerPenalty)
{

    // Disable client stats by setting StatsHistoryInMs to 0

    if (cHistoryInMs == 0)
    {
        if (_bClientStatsEnabled)
        {
            // Clear with write lock
            WriteLock();
            ClearMemory();
            _bClientStatsEnabled = FALSE;
            WriteUnlock();
        }
        TraceSz(Config, "    Client packet statistics are disabled");
        return TRUE;
    }

    TraceSz(Config, "    Client packet statistics are enabled");

    _cWarningSigmaInterval      = cWarningSigmaInterval;
    _cDisconnectSigmaInterval   = cDisconnectSigmaInterval;
    _cConfidenceLimitInClients  = cConfidenceLimit;
    _cTicksPerPenalty           = cSecondsPerPenalty * TICKS_PER_SECOND;
    _cHistoryInMs               = cHistoryInMs;

    if (_cWarningSigmaInterval == 0)
        TraceSz(Config, "    Disabled warnings (warning sigma level is 0)");
    else
        TraceSz(Config, "    Configured warning sigma level to %u standard deviations", _cWarningSigmaInterval);

    if (_cDisconnectSigmaInterval == 0)
        TraceSz(Config, "    Disabled disconnections (disconnection sigma level is 0)");
    else
        TraceSz(Config, "    Configured disconnection sigma level to %u standard deviations", _cDisconnectSigmaInterval);

    TraceSz(Config, "    Configured confidence limit to %u clients", _cConfidenceLimitInClients);
    TraceSz(Config, "    Configured warning penalty time to %u seconds (%u ticks)", _cTicksPerPenalty / TICKS_PER_SECOND, _cTicksPerPenalty);


    // We need to ensure some boundaries so we don't get aliasing in our intervals. Each 
    // bucket needs to be an exact multiple of ticks (200ms).  We should always round up 
    // the history time to achieve this.   
    //
    // Example (doesn't work when already on a boundary, hence 'if' statement):
    //
    // cTotalBucketTimeInMs = 1600
    // cHistoryInMs = 3400
    // (3400 + (1600 - 3400 % 1600))
    // cHistoryInMs is now 3600. Try it for any value!

    UINT cTotalBucketTimeInMs = SGSTATS_REQUEST_COUNT_FRACTIONS * (1000 / TICKS_PER_SECOND);
    if (_cHistoryInMs % cTotalBucketTimeInMs > 0)
    {
        _cHistoryInMs = cHistoryInMs + (cTotalBucketTimeInMs - (cHistoryInMs % cTotalBucketTimeInMs));

        TraceSz(Config, "    Rounding up history time from %d ms to %d ms, an even multiple of bucket history (%d ms)",
            cHistoryInMs, _cHistoryInMs, cTotalBucketTimeInMs);
    }
    CPacketHistoryRecord::SetHistoryTime(_cHistoryInMs);
    TraceSz(Config, "    Configured sliding window to %d milliseconds (%d seconds) (%d ticks)", 
             _cHistoryInMs, _cHistoryInMs / 1000, _cHistoryInMs * TICKS_PER_SECOND / 1000);
 

    //
    // Detect any changes that would require us to reallocate memory
    //

    if (_cSpiInfoLast != g_cSpiInfo || 
        _cSvcInfoLast != g_cSvcInfo ||
        !_bClientStatsEnabled)
    {
        if (!ConfigMemory())
        {
            return FALSE;
        }
    }
   
    _cSpiInfoLast        = g_cSpiInfo;
    _cSvcInfoLast        = g_cSvcInfo;
    _bClientStatsEnabled = TRUE;

    return TRUE;
}

// -------------------------------------------------------------------------------------
// CSgStats::Config 
//
// Internal helper to clear and reallocate memory for the client stats. You should only 
// call this when necessary. This grabs a writelock.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::ConfigMemory()
{
    //
    // This is where the real work begins for memory manipulation. Notice we're holding a lock.
    //

    TraceSz(Config, "    Reconfiguring client stats due to a change, erasing all previous history");
    
    WriteLock();
    ClearMemory();
    ClearStats();
    
    // Figure out how many packet types we are tracking. All the base types plus one for 
    // each service.
    _cPacketTypes          = g_cSvcInfo + SGSTATS_PT_SVCBASE;
    _cClientStats          = g_cSpiInfo;  // same as count of spi objects
    _cPacketHistoryRecords = _cClientStats * _cPacketTypes;
    
    TraceSz(Config, "    Configured number of packet types to track to %d", _cPacketTypes);

    //
    // Allocate our memory
    // 

    // Allocate chunk of memory for client stat objects. Each of these will have a pointer 
    // into the buffer below.

    TraceSz(Config, "    Allocating %d client stat objects. %d bytes each, %d bytes total.",
        _cClientStats, sizeof(CClientStats), _cClientStats * sizeof(CClientStats));

    _pClientStats = (CClientStats *)SgMemAllocZ(_cClientStats * sizeof(CClientStats), PTAG_CClientStats);
    if (_pClientStats == NULL)
    {
        SgEventSz(CONFIG_ERROR, "Error allocating %d bytes for CClientStats in SgClientStatsConfig.",
                   _cClientStats * sizeof(CClientStats));
        TraceSz(Config, "    Config error: Out of memory");
        goto err;
    }
   
    // This is sort-of an internal buffer for each packet history record. We'll allocate 
    // this memory ourselves to each client stat object.

    TraceSz(Config, "    Allocating %d packet history record objects. %d bytes each, %d bytes total.",
        _cPacketHistoryRecords, sizeof(CPacketHistoryRecord), _cPacketHistoryRecords * sizeof(CPacketHistoryRecord));

    _pPacketHistoryRecords = (CPacketHistoryRecord *)SgMemAllocZ(_cPacketHistoryRecords * sizeof(CPacketHistoryRecord), PTAG_CPacketHistoryRecords);
    if (_pPacketHistoryRecords == NULL)
    {
        SgEventSz(CONFIG_ERROR, "Error allocating %d bytes for CPacketHistoryRecord in SgClientStatsConfig.",
                   _cPacketHistoryRecords * sizeof(CPacketHistoryRecord));
        TraceSz(Config, "    Config error: Out of memory");
        goto err;
    }

    // Initialize all of them. Pass in a buffer to the appropriate memory chunk in the 
    // packet history record buffer. _cPacketTypes * _cClientStats equals how much 
    // memory we allocated to _cPacketHistoryRecords.. so we're cool.

    for (DWORD i = 0; i < _cClientStats; i++)
    {
        _pClientStats[i].Init(_pPacketHistoryRecords + _cPacketTypes * i, _cPacketTypes);
    }

    // Release lock!
    WriteUnlock();
    return (TRUE);

err:
    
    WriteUnlock();
    return (FALSE);
}
// }}}

// -------------------------------------------------------------------------------------
// CSgStats::AttachClient
//
// Called when a packet is attached to a spi. Since we have a one-to-one link based on 
// index with g_pSpiInfo, this means all we have to do is prepare the stats object for 
// first use.
// -------------------------------------------------------------------------------------
void
CSgStats::AttachClient(DWORD iClientIdx)
{
    if (!SafeReadLock())
    {
        return;
    }

    Assert(iClientIdx < _cClientStats);
    _pClientStats[iClientIdx].Reset();

    ReadUnlock();
}

// -------------------------------------------------------------------------------------
// CSgStats::ProcessPacket
//
// Called for every incoming packet. Determines the packet type and increments that 
// counter for the client.
// -------------------------------------------------------------------------------------
void 
CSgStats::ProcessPacket(DWORD iClientIdx, CPacket * ppkt, CDstInfo * pDstInfo)
{
    if (!SafeReadLock())
    {
        return;
    }

    Assert(iClientIdx < _cClientStats);

    _pClientStats[iClientIdx].ProcessPacket(ppkt, pDstInfo);

    ReadUnlock();
}

// -------------------------------------------------------------------------------------
// CSgStats::RefreshStats
//
// Maintains the online set of global statistical information incrementally. Should be 
// called periodically for each client.
//
// Statistics references:
// http://en.wikipedia.org/wiki/Standard_deviation
// http://en.wikipedia.org/wiki/Chebyshev%27s_inequality
// http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance - Algorithm III
// -------------------------------------------------------------------------------------
void
CSgStats::RefreshStats(DWORD iClientIdx)
{
    if (!SafeReadLock())
    {
        return;
    }

    Assert(iClientIdx < _cClientStats);
    
    DWORD           activeClients = g_cSpiInfoInUse - g_cSpiInfoFree;
    DWORD           dwValue       = 0;
    FLOAT           fDelta        = 0;
    CClientStats *  pClientStats  = &_pClientStats[iClientIdx];

    if (activeClients == 0)
    {
        ClearStats();
        ReadUnlock();
        return;
    }

//     TraceSz(ClientStatsFlow, "%08lX Refreshing stats for client idx %d",
//              g_pSpiInfo[iClientIdx]._dwSpiRecv, iClientIdx);

    // Incrementally update each packet type record

    for (DWORD iPktType = 0; iPktType < _cPacketTypes; iPktType++)
    {
        // Pointer
        CStatsRecord * ps = &_PacketStats[iPktType];
        ps->_NumSamples++;
        
        // Get value for this client and packet type
        dwValue = pClientStats->GetCount(iPktType);

        // Update online (running) values
        fDelta = dwValue - ps->_Mean;
        ps->_Mean = ps->_Mean + (fDelta / activeClients);
        ps->_Variance = ((activeClients - 1) * ps->_Variance + (dwValue - ps->_Mean) * fDelta);

        // Numerical system blew up if variance is negative
        Assert(ps->_Variance >= 0);
       
        // Population variance instead of sample variance (N vs N-1)
        // @@@ Review this very carefully.
        ps->_Variance = ps->_Variance / (activeClients);
        ps->_StdDev = sqrtf(ps->_Variance);

        if (dwValue > ps->_Max)
        {
            ps->_Max = dwValue;
        }

        if (dwValue < ps->_Min)
        {
            ps->_Min = dwValue;
        }

        //
        // Enforce the limits for each packet type for this client
        //

        // If we don't have enough clients or samples, then the mean is rather meaningless 
        // and we don't want to update or enforce the limits. Since the stats can be reset 
        // by xmgmtc command, we need to track the # of samples as well as the number of 
        // clients.  Or, imagine if a bunch of clients connected all of a sudden - the 
        // client count would be high but we may not have refreshed the stats for all 
        // these clients yet (on a 15 second cycle, remember).
        if (activeClients < _cConfidenceLimitInClients ||
            ps->_NumSamples < _cConfidenceLimitInClients)
        {
            continue;
        }
       
        if (_cWarningSigmaInterval > 0)
        {
            ps->_LimitWarning = (DWORD)(ps->_Mean + (ps->_StdDev * _cWarningSigmaInterval));
            // @@@ configurable? 1 packet every 30 seconds seems like a reasonable minimum 
            // limit.
            DWORD min = _cHistoryInMs / 30000;
            if (ps->_LimitWarning < min)
            {
                ps->_LimitWarning = min;
            }
        }

        if (_cDisconnectSigmaInterval > 0)
        {
            ps->_LimitDisconnect = (DWORD)(ps->_Mean + (ps->_StdDev * _cDisconnectSigmaInterval));
            // @@@ configurable? 1 packet every 30 seconds seems like a reasonable minimum 
            // limit.
            DWORD min = _cHistoryInMs / 30000;
            if (ps->_LimitDisconnect < min)
            {
                ps->_LimitDisconnect = min;
            }
        }

        if (_cDisconnectSigmaInterval > 0 &&
            ps->_LimitDisconnect > 0 && 
            dwValue > ps->_LimitDisconnect)
        {
            //
            // Disconnect you if enabled, limit exceeded, and you've already been warned.
            //
            TraceSz(ClientStats, 
                     "spi[%08lX] mpuid[0x%016I64X] idx[%u] Alert: %u exceeds disconnect limit %u [%d %s]",
                     g_pSpiInfo[iClientIdx]._dwSpiRecv,
                     g_pSpiInfo[iClientIdx]._puid.QuadPart,
                     iClientIdx,
                     dwValue,
                     ps->_LimitDisconnect,
                     iPktType,
                     CClientStats::PacketTypeToString(iPktType));
           
            // Get the logline for this client and log it
            CLargeStr strStats;
            if (GetStatsForLogWithLock(&strStats, 
                                       &g_pSpiInfo[iClientIdx], 
                                       pClientStats,
                                       iPktType))
            {
                SvcLogLvl(SgClientStats, L_HIGH,
                           "SGCLDL|%s",
                           strStats.cstr());

                // These are done at L_LOW (0) level, so they get filtered by default (logfiles have a 
                // level of 1 by default). It can be turned on at any time using the standard xmgmt 
                // ChangeAreaLevel command for SgClientStats level.
                pClientStats->LogStatsDetailed(g_pSpiInfo[iClientIdx]._puid.QuadPart);

                SgSpiInfoKick(&g_pSpiInfo[iClientIdx], SECMSG_DELETE_KICK, SPIDEL_PACKET_LIMIT);
            }
            else
            {
                TraceSz(ClientStats, 
                         "spi[%08lX] mpuid[0x%016I64X] idx[%u] Failed to get stats for event text",
                         g_pSpiInfo[iClientIdx]._dwSpiRecv,
                         g_pSpiInfo[iClientIdx]._puid.QuadPart,
                         iClientIdx);
            }
        }
        else if (_cWarningSigmaInterval > 0 &&
                 ps->_LimitWarning > 0 &&
                 dwValue > ps->_LimitWarning)
        {
            //
            // Warn you if enabled, limit exceeded, and you haven't been warned recently
            //
            TraceSz(ClientStats, 
                     "spi[%08lX] mpuid[0x%016I64X] idx[%u] Warning: %u exceeds limit %u [%d %s]",
                     g_pSpiInfo[iClientIdx]._dwSpiRecv,
                     g_pSpiInfo[iClientIdx]._puid.QuadPart,
                     iClientIdx,
                     dwValue,
                     ps->_LimitWarning,
                     iPktType,
                     CClientStats::PacketTypeToString(iPktType));

            // Mark client as 'interesting' (warn)
            BOOL bWasInPenaltyBox = pClientStats->IsInPenaltyBox();
            pClientStats->Warn(iPktType, ps->_LimitWarning, _cTicksPerPenalty);

            if (!bWasInPenaltyBox)
            {
                // Throttle our warning events. Only show an event when a client goes from 
                // good to bad. Log client stats for first warning.
                CLargeStr strStats;
                if (GetStatsForLogWithLock(&strStats,
                                           &g_pSpiInfo[iClientIdx], 
                                           pClientStats, 
                                           iPktType))
                {
                    SvcLogLvl(SgClientStats, L_NORMAL,
                               "SGCLWL|%s",
                               strStats.cstr());
                    
                    // These are done at L_LOW (0) level, so they get filtered by default 
                    // (logfiles have a level of 1 by default). It can be turned on at any 
                    // time using the standard xmgmt ChangeAreaLevel command for 
                    // SgClientStats level.
                    pClientStats->LogStatsDetailed(g_pSpiInfo[iClientIdx]._puid.QuadPart);
                }
                else
                {
                    TraceSz(ClientStats, 
                             "spi[%08lX] mpuid[0x%016I64X] idx[%u] Failed to get stats for event text",
                             g_pSpiInfo[iClientIdx]._dwSpiRecv,
                             g_pSpiInfo[iClientIdx]._puid.QuadPart,
                             iClientIdx);
                }

            }

        }

    }

    ReadUnlock();
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsOverall
//
// Retrieve global statistics (mean, max, min, etc) for all packet types.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsOverall(CStr * pText)
{
    if (!SafeReadLock())
    {
        return FALSE;
    }
    BOOL fOk = GetStatsOverallWithLock(pText);
    ReadUnlock();
    return fOk;
}

BOOL
CSgStats::GetStatsOverallWithLock(CStr * pText)
{
    pText->Format("OverallStats: Total packets over %u ms for %d active clients\r\n", 
                  _cHistoryInMs,
                  (g_cSpiInfoInUse - g_cSpiInfoFree));
    pText->Format("   Min   Mean    Max      Var StdDev   Lmt1   Lmt2 NumSamps PktType\r\n");
    pText->Format("====== ====== ====== ======== ====== ====== ====== ======== =======\r\n");

    for (DWORD iPktType = 0; iPktType < _cPacketTypes; iPktType++)
    {
        // Pointer
        CStatsRecord * ps = &_PacketStats[iPktType];

        pText->Format("%6u %6.0f %6u %8.0f %6.0f %6u %6u %8u %s\r\n",
                      ((ps->_Min == MAXDWORD) ? 0 : ps->_Min),
                      (ps->_Mean),
                      (ps->_Max),
                      (ps->_Variance),
                      (ps->_StdDev),
                      ((ps->_LimitWarning == MAXDWORD) ? 0 : ps->_LimitWarning),
                      ((ps->_LimitDisconnect == MAXDWORD) ? 0 : ps->_LimitDisconnect),
                      ((ps->_NumSamples > 99999999) ? 999999999 : ps->_NumSamples),
                      CClientStats::PacketTypeToString(iPktType));
    }

    pText->Format("\r\n");
    return TRUE;
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsOverallPackets
//
// Retrieve global statistics (mean, max, min, etc) for specified packet types. Input is 
// an array of packet types to include stats for.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsOverallPackets(CStr * pText, DWORD *pPktTypes, DWORD cPktTypes)
{
    if (!SafeReadLock())
    {
        return FALSE;
    }
    BOOL fOk = GetStatsOverallPacketsWithLock(pText, pPktTypes, cPktTypes);
    ReadUnlock();
    return fOk;
}

BOOL
CSgStats::GetStatsOverallPacketsWithLock(CStr * pText, DWORD *pPktTypes, DWORD cPktTypes)
{
    pText->Format("OverallStats: Total packets over %u ms for %d active clients\r\n", 
                  _cHistoryInMs,
                  (g_cSpiInfoInUse - g_cSpiInfoFree));
    pText->Format("   Min   Mean    Max      Var StdDev   Lmt1   Lmt2 NumSamps PktType\r\n");
    pText->Format("====== ====== ====== ======== ====== ====== ====== ======== =======\r\n");

    if (pPktTypes == NULL || cPktTypes == 0)
    {
        return TRUE;
    }

    for (DWORD i = 0; i < cPktTypes; i++)
    {
        // Pointer
        CStatsRecord * ps = &_PacketStats[pPktTypes[i]];

        pText->Format("%6u %6.0f %6u %8.0f %6.0f %6u %6u %8u %s\r\n",
                      ((ps->_Min == MAXDWORD) ? 0 : ps->_Min),
                      (ps->_Mean),
                      (ps->_Max),
                      (ps->_Variance),
                      (ps->_StdDev),
                      ((ps->_LimitWarning == MAXDWORD) ? 0 : ps->_LimitWarning),
                      ((ps->_LimitDisconnect == MAXDWORD) ? 0 : ps->_LimitDisconnect),
                      ((ps->_NumSamples > 99999999) ? 999999999 : ps->_NumSamples),
                      CClientStats::PacketTypeToString(pPktTypes[i]));
    }

    pText->Format("\r\n");
    return TRUE;
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsHistogram
//
// Retrieve a histogram view of the whole SG stats picture at this moment in time.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsHistogram(CStr * pText)
{
    if (!SafeReadLock())
    {
        return FALSE;
    }
    BOOL fOk = GetStatsHistogramWithLock(pText);
    ReadUnlock();
    return fOk;
}

BOOL
CSgStats::GetStatsHistogramWithLock(CStr * pText)
{
    // Determine largest packet count evar
    DWORD maxPackets = 0;
    for (DWORD iPktType = 0; iPktType < _cPacketTypes; iPktType++)
    {
        if (_PacketStats[iPktType]._Max > maxPackets)
        {
            maxPackets = _PacketStats[iPktType]._Max;
        }
    }

    // Add 1 to account for integer round-down errors. If maxPackets is 39, we want the 
    // largest histogram bucket to include it. Because we have 10 buckets, and we're using   
    // integers to represent the interval, this means we'll represent values 0-39.  If 
    // maxPackets is 30, we'll still have to represent 0-39, since our other option would 
    // be 0-29.
    //
    // The math:
    // 39 maxpackets / 10 = 3.9 or 3 for the interval. Take 39 and divide by 3, we get 13, 
    // which is way more than our 10 buckets.  If we add 1 to the interval to make it 4, 
    // then divide 39 by 4, we get 9 (integer), which is exactly what we want (the last 
    // 10th and last bucket). Super.
    DWORD interval = (maxPackets / HISTOGRAM_BUCKETS) + 1;
    DWORD histogram[SGSTATS_PT_MAX][HISTOGRAM_BUCKETS];
    DWORD activeClients = 0;

    ZeroMemory(histogram, sizeof(histogram));
       
    // Walk through all spis that have been allocated. This means they are either in use 
    // or on the free list.

    for (DWORD i = 0; i < g_cSpiInfoInUse; i++)
    {
        CSpiInfo * pSpiInfo = &g_pSpiInfo[i];
        CClientStats * pClientStats = &_pClientStats[i];

        if (!IsSpiActive(pSpiInfo))
        {
            continue;
        }

        activeClients++;
        
        // Get all histogram stats for each packet type from the client. It's additive.
        for (DWORD iPktType = 0; iPktType < _cPacketTypes; iPktType++)
        {
            DWORD count = pClientStats->GetCount(iPktType);

            // We don't want to count 0 packets received
            if (count == 0)
                continue;

            DWORD slot = count / interval;
            if (slot >= HISTOGRAM_BUCKETS)
            {
                slot = HISTOGRAM_BUCKETS - 1;
            }

            histogram[iPktType][slot]++;
        }
    }

    // Report everything

    pText->Format("Statistics summary for %u active clients (out of %u max)\r\n", activeClients, g_cSpiInfo);
    pText->Format("Histogram with %u intervals for up to %u packets over the last %u ms\r\n", HISTOGRAM_BUCKETS, maxPackets, _cHistoryInMs);
    pText->Format("\r\n");
    pText->Format("Column -> Total packets received (bucketed)\r\n");
    pText->Format("   Row -> Packet type\r\n");
    pText->Format("  Cell -> Total clients\r\n");
    pText->Format("\r\n");

    C_ASSERT(HISTOGRAM_BUCKETS == 10);
    
    pText->Format("%6u %6u %6u %6u %6u %6u %6u %6u %6u %6u\r\n",
        0*interval, 1*interval, 2*interval, 3*interval, 4*interval, 5*interval, 6*interval, 7*interval, 8*interval, 9*interval);
    pText->Format("    to     to     to     to     to     to     to     to     to     to\r\n");
    pText->Format("%6u %6u %6u %6u %6u %6u %6u %6u %6u %6u PktType\r\n",
        1*interval-1, 2*interval-1, 3*interval-1, 4*interval-1, 5*interval-1, 6*interval-1, 7*interval-1, 8*interval-1, 9*interval-1, 10*interval-1);
    pText->Format("====== ====== ====== ====== ====== ====== ====== ====== ====== ====== =======\r\n");
    for (DWORD iPktType = 0; iPktType < _cPacketTypes; iPktType++)
    {
        pText->Format("%6u %6u %6u %6u %6u %6u %6u %6u %6u %6u %s\r\n",
            histogram[iPktType][0],
            histogram[iPktType][1],
            histogram[iPktType][2],
            histogram[iPktType][3],
            histogram[iPktType][4],
            histogram[iPktType][5],
            histogram[iPktType][6],
            histogram[iPktType][7],
            histogram[iPktType][8],
            histogram[iPktType][9],
            CClientStats::PacketTypeToString(iPktType));
    }

    pText->Format("\r\n");
    return TRUE;
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsClientByPuid
//
// Retrieve a summary of a single client's stats at this moment in time.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsClientByPuid(CStr * pText, ULONGLONG qwMachinePuid)
{
    if (!SafeReadLock())
    {
        return FALSE;
    }
    BOOL fOk = GetStatsClientByPuidWithLock(pText, qwMachinePuid);
    ReadUnlock();
    return fOk;
}

BOOL
CSgStats::GetStatsClientByPuidWithLock(CStr * pText, ULONGLONG qwMachinePuid)
{
    // Walk through all spis that have been allocated. This means they are either in use 
    // or on the free list.

    BOOL fFoundAClient = FALSE;

    for (DWORD i = 0; i < g_cSpiInfoInUse; i++)
    {
        CSpiInfo * pSpiInfo = &g_pSpiInfo[i];
        CClientStats * pClientStats = &_pClientStats[i];

        if (!IsSpiActive(pSpiInfo))
        {
            // Not active
            continue;
        }

        if (pSpiInfo->_puid.QuadPart == qwMachinePuid)
        {
            // Found it
            fFoundAClient = TRUE;

            pText->Format("Machine stats for mpuid 0x%016I64X, spi 0x%08X, ip %s:%d, title 0x%08X\r\n",
                pSpiInfo->_puid, 
                pSpiInfo->_dwSpiRecv, 
                pSpiInfo->_ipaI.Str(), 
                pSpiInfo->_ipportI._w,
                pSpiInfo->_AuthData.dwTitleID);
            pText->Format("\r\n");
            pClientStats->GetStatsDetailed(pText);
            
            // Could break here for optimization. Or could continue if there may be 
            // multiple matches.
            break;
        }
    }
   
    if (!fFoundAClient)
    {
        pText->Format("Machine puid 0x%016I64X not found\r\n", qwMachinePuid);
    }

    pText->Format("\r\n");
    return TRUE;
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsClientBySpi
//
// Retrieve a summary of a single client's stats at this moment in time.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsClientBySpi(CStr * pText, DWORD dwSpiRecv)
{
    if (!SafeReadLock())
    {
        return FALSE;
    }
    BOOL fOk = GetStatsClientBySpiWithLock(pText, dwSpiRecv);
    ReadUnlock();
    return fOk;
}

BOOL
CSgStats::GetStatsClientBySpiWithLock(CStr * pText, DWORD dwSpiRecv)
{
    int iSpiIdx                 = (dwSpiRecv >> 8) % g_cSpiInfo;
    CSpiInfo *pSpiInfo          = &g_pSpiInfo[iSpiIdx];
    int iClientIdx              = SpiToClientIdx(pSpiInfo);
    CClientStats * pClientStats = &_pClientStats[iClientIdx];

    if (!IsSpiActive(pSpiInfo) ||
        pSpiInfo->_dwSpiRecv != dwSpiRecv ||
        pSpiInfo->_dwSpiRecv == 0)
    {
        // Not active
        pText->Format("Spi 0x%08X is not active.\r\n", dwSpiRecv);
    }

    pText->Format("Machine stats for mpuid 0x%016I64X, spi 0x%08X, ip %s:%d, title 0x%08X\r\n",
                  pSpiInfo->_puid, 
                  pSpiInfo->_dwSpiRecv, 
                  pSpiInfo->_ipaI.Str(), 
                  pSpiInfo->_ipportI._w,
                  pSpiInfo->_AuthData.dwTitleID);
    pText->Format("\r\n");
    pClientStats->GetStatsDetailed(pText);
    pText->Format("\r\n");
    
    return TRUE;
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsWarnings
//
// Retrieve a report of all clients that have been warned
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsWarnings(CStr * pText)
{
    if (!SafeReadLock())
    {
        return FALSE;
    }
    BOOL fOk = GetStatsWarningsWithLock(pText);
    ReadUnlock();
    return fOk;
}

BOOL
CSgStats::GetStatsWarningsWithLock(CStr * pText)
{
    DWORD warnedClients = 0;
    DWORD totalCount = 0;

    // Walk through all spis that have been allocated. This means they are either in use 
    // or on the free list.

    pText->Format("All clients that are currently in their warning period (%d seconds):\r\n", _cTicksPerPenalty / TICKS_PER_SECOND);
    pText->Format("\r\n");
    pText->Format("       MachinePuid       Spi  TotalCount\r\n");
    pText->Format("==================  ========  ==========\r\n");

    for (DWORD i = 0; i < g_cSpiInfoInUse; i++)
    {
        CSpiInfo * pSpiInfo = &g_pSpiInfo[i];
        CClientStats * pClientStats = &_pClientStats[i];

        if (!IsSpiActive(pSpiInfo) ||
            !pClientStats->IsInPenaltyBox())
        {
            continue;
        }

        warnedClients++;
        totalCount = 0;
        for (DWORD iPktType = 0; iPktType < _cPacketTypes; iPktType++)
        {
            totalCount += pClientStats->GetCount(iPktType);
        }

        pText->Format("0x%016I64X  %08X  %10u\r\n", 
                      pSpiInfo->_puid.QuadPart,
                      pSpiInfo->_dwSpiRecv, 
                      totalCount);
    }

    pText->Format("\r\nDone. Found %u clients in the penalty box.\r\n", warnedClients);
    pText->Format("\r\n");
    return TRUE;
}


// -------------------------------------------------------------------------------------
// CSgStats::GetStatsForEventWithLock
//
// Retrieve a summary of a single client's stats at this moment in time to output to an 
// event.
//
// WARNING: this does not grab the readlock. Please ensure it is held before calling this 
// function.
// -------------------------------------------------------------------------------------
BOOL
CSgStats::GetStatsForEventWithLock(CStr * pText, 
                                   CSpiInfo * pSpiInfo, 
                                   DWORD iPktType)
{
    if (!IsSpiActive(pSpiInfo))
        return FALSE;

    DWORD aPktTypes[] = { iPktType };
    BOOL fOk = TRUE;

    fOk = fOk & GetStatsClientBySpiWithLock(pText, pSpiInfo->_dwSpiRecv);
    pText->Format("\r\n");
    fOk = fOk & GetStatsOverallPacketsWithLock(pText, aPktTypes, ARRAY_SIZE(aPktTypes));
    return fOk;
}

// -------------------------------------------------------------------------------------
// CSgStats::GetStatsForLogWithLock
//
// Retrieve a summary of a single client's stats at this moment in time to output to a 
// logfile.
//
// Format for SGCLDL and SGCLWL lines:
//
// mpuid | spi | ip | port | titleid | authdataflags | pkttype | count | pkttypemean | 
// warninglimit | disconnectlimit | pkttypemax | pkttypenumsamples
//
// WARNING: this does not grab the readlock. Please ensure it is held before calling this 
// function.
// -------------------------------------------------------------------------------------
BOOL CSgStats::GetStatsForLogWithLock(CStr * pText, 
                                      CSpiInfo * pSpiInfo, 
                                      CClientStats * pClientStats, 
                                      DWORD iPktType)
{
    if (!IsSpiActive(pSpiInfo))
        return FALSE;

    CStatsRecord * pPacketRecord = &_PacketStats[iPktType];

    pText->Format("%016I64X|%08X|%s|%hu|%08X|%X|%s|%u|%u|%u|%u|%u|%u",
                  // Client info
                  pSpiInfo->_puid, 
                  pSpiInfo->_dwSpiRecv, 
                  pSpiInfo->_ipaI.Str(), 
                  pSpiInfo->_ipportI._w,
                  pSpiInfo->_AuthData.dwTitleID,
                  pSpiInfo->_AuthData.dwAuthDataFlags,
                  CClientStats::PacketTypeToString(iPktType),
                  pClientStats->GetCount(iPktType),
                  // Packet type info
                  (DWORD)pPacketRecord->_Mean,
                  ((pPacketRecord->_LimitWarning == MAXDWORD) ? 0 : pPacketRecord->_LimitWarning),
                  ((pPacketRecord->_LimitDisconnect == MAXDWORD) ? 0 : pPacketRecord->_LimitDisconnect),
                  pPacketRecord->_Max,
                  ((pPacketRecord->_NumSamples > 99999999) ? 999999999 : pPacketRecord->_NumSamples));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#define ASN1_PUBLIC
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    class CScratchMemoryAllocator* pScratchMemoryAllocator;
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    class CScratchMemoryAllocator* pScratchMemoryAllocator;
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder2
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    ASN1encoding_t      pEncoderInfo,
    void               *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101,

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);

#include <poppack.h> /* End 8-byte packing */

//
// msber.h
//

#include <pshpack8.h> /* Assume 8 byte packing throughout */

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);

/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgconfig.cpp ===
// ---------------------------------------------------------------------------------------
// sgconfig.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"
#include <atlbase.h>
#include <atlcom.h>
#include <atlsafe.h>
#include <oledbwrapper.h>

// This seems to live in ntrtl.h (mstcpip.h later), but including that whole file 
// introduces a bunch of compile-time errors and seems like overkill.
extern "C" {
NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressExW (
    IN PCWSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );
};

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_CONFIG_DB
BOOL g_fUseConfigDb = TRUE;
#else
BOOL g_fUseConfigDb = FALSE;
#endif

// Npdb connection string
CSmallWStr g_npdbConnectionString;

// Save off last good config blob
BOOL        g_configTextLastKnownGoodOk = FALSE;
CSmallStr   g_configTextLastKnownGood;

#define SG_CONFIG_INI                      L"sgconfig.ini"
#define SG_CONFIG_UNSECURE_FILES_PATTERN   L"..\\sgcfg\\*.ini"
#define SG_CONFIG_UNSECURE_FILES_EXTENSION L"ini"
#define SG_CONFIG_SECURE_FILES_PATTERN     L"..\\sgcfg\\*.cfg"
#define SG_CONFIG_SECURE_FILES_EXTENSION   L"cfg"

#define IF_FAILED_GOTO_LDONE(op) \
    if(!(op)) { \
        SgEventSz(CONFIG_ERROR, "Operation failed:\n%s\n", #op); \
        goto lDone; \
    }

#define IF_FAILED_GOTO_LDONE_WITH_HR(op) \
    if(FAILED(hr = (op))) { \
        SgEventSz(CONFIG_ERROR, "Operation failed:\n%s\nHR: 0x%08x", #op, hr); \
        goto lDone; \
    }

// ---------------------------------------------------------------------------------------
// Forward Declarations
// ---------------------------------------------------------------------------------------

BOOL SgConfigBuild(CStr* pConfigText);
BOOL SgConfigBuildFromFiles( CStr* );
BOOL SgConfigBuildFromFilePattern( const WCHAR*, const WCHAR*, BOOL, CStr*);
BOOL SgConfigBuildFromFile( const WCHAR*, BOOL, CStr* );
BOOL SgConfigWithText( const char* pszConfigText);

#ifdef SG_FEATURE_CONFIG_DB
BOOL SgConfigDbInit();
void SgConfigDbTerm();
BOOL SgConfigAddFromCommonConfig(CStr* pConfigText);
BOOL SgConfigAddSettingFromCommonConfig( CStr*, CComBSTR& setting, LPCSTR pszSettingName );
BOOL SgConfigAddMultiSettingFromCommonConfig( CStr*, CComBSTR& setting, LPCSTR pszSettingName );
BOOL SgConfigAddInterfacesFromCommonConfig( CStr* );
BOOL SgConfigAddServicesFromCommonConfig( CStr* );
BOOL SgConfigAddNotifiesFromCommonConfig( CStr* );
BOOL SgConfigAddEventsFromCommonConfig( CStr* );
BOOL SgConfigGetNpdbInterface();
#endif

BOOL    SgConfigGetScriptListFromConfigDb ( CArenaAlloc* pArenaAlloc, THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts );
BOOL    SgConfigGetScriptListFromFiles    ( CArenaAlloc* pArenaAlloc, THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts, CStr *pScriptLocation );
BOOL    SgConfigGetScriptListFromResources( CArenaAlloc* pArenaAlloc, THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts );

HRESULT SgConfigGetScriptFromDatabase( LPCSTR pFilename, CScriptInfo *pScriptInfo );
HRESULT SgConfigGetScriptFromFile    ( LPCSTR pFilename, CScriptInfo *pScriptInfo, CStr *pScriptLocation );
HRESULT SgConfigGetScriptFromResource( LPCSTR pFilename, CScriptInfo *pScriptInfo );

VOID    SgConfigReloadTimer(CTimer*);
VOID    SgConfigScheduleReload(DWORD dwDelayInMs);

// {{{ SgConfig goop

// ---------------------------------------------------------------------------------------
// CScriptInfo
// Encapsulates the data needed for loading and configuring a script
// ---------------------------------------------------------------------------------------
CScriptInfo::CScriptInfo() :
    scriptBuffer(NULL, 0, 0),
    blobBuffer(NULL, 0, 0),
    bKickEnabled(TRUE),
    bTimeoutEnabled(TRUE)
{
    scriptBuffer.SetAllocator(CSgMemAlloc::GetAlloc());
    blobBuffer.SetAllocator(CSgMemAlloc::GetAlloc());
}


// ---------------------------------------------------------------------------------------
// SgConfig
// Build configuration text from Live common config and from config text files and then
// use it to configure the SG components
// ---------------------------------------------------------------------------------------
BOOL SgConfig()
{
    BOOL ok = FALSE;
    BOOL fReloading = g_configTextLastKnownGoodOk;
    CSmallStr configText;

    // Allocate some memory for the config text before we start. Also set it to autogrow
    // if more memory is needed.
    configText.SetAllocator(CMemAlloc::Default());
    IF_FAILED_GOTO_LDONE(configText.SetCapacity(1048576));

    // Build configuration text blob
    IF_FAILED_GOTO_LDONE(SgConfigBuild(&configText));

    // Initialize the SG with it
    if (!SgConfigWithText(configText.cstr()))
    {
        if (g_configTextLastKnownGoodOk)
        {
            // Attempt config again, using old setting blob
            SgEventSz(CONFIG_WARNING, "SgConfig failed using new configuration, falling back to last known good configuration. The previous events should indicate which setting(s) failed. Please correct this immediately.");
            fReloading = FALSE;
            if (!SgConfigWithText(g_configTextLastKnownGood.cstr()))
            {
                g_configTextLastKnownGoodOk = FALSE;
                SgEventSz(CONFIG_ERROR, "SgConfig failed using last known good configuration. This is highly suspect, please investigate. The previous events should indicate which setting(s) failed.");
                goto lDone;
            }
        }
        else
        {
            // This is probably the first config attempt. Rather than attempt to use
            // default values and get into some obscure unknown state, we will just fail
            // to start.
            SgEventSz(CONFIG_ERROR, "SgConfig failed. There is no previous good configuration to fall back to. The previous events should indicate which setting(s) failed.");
            goto lDone;
        }
    }
    else
    {
        // All is well with the new config. Save off config state so we can fall back
        // later if needed.
        g_configTextLastKnownGood.Reset();
        g_configTextLastKnownGood.CopyFrom(configText);
        g_configTextLastKnownGoodOk = TRUE;
    }
    ok = TRUE;

lDone:

    if(ok && !fReloading)
    {
        SgEvent(CONFIG_SUCCESS);
    }
    else if (ok)
    {
        SgEvent(CONFIG_RELOAD_SUCCESS);
    }
    else
    {
        SgEvent(CONFIG_FAILURE);
    }

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptList
// Build a hashtable with the names of scripts retrieved from both the database and the
// sgcfg directory.
//   - pArenaAlloc : Arena allocator used to allocate the script names to be inserted in
//   pScripts
//   - pScripts : pointer to hashtable to write the script names to.
//   - pScriptLocation: Points to the search location
//   - dwScriptFlags: Controls which locations to read the script from
// Returns:
//   TRUE if it succeeded, FALSE otherwise
// ---------------------------------------------------------------------------------------
BOOL SgConfigGetScriptList(
    CArenaAlloc*                                pArenaAlloc,
    THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts,
    CStr*                                       pScriptLocation,
    DWORD                                       dwScriptFlags
    )
{
    BOOL ok = FALSE;
    HRESULT hr;

    //
    // First try to find the scripts in the resources
    //
    if ((dwScriptFlags & CONFIG_SCRIPT_FROM_RESOURCE) != 0)
    {
        IF_FAILED_GOTO_LDONE_WITH_HR(SgConfigGetScriptListFromResources(pArenaAlloc, pScripts));
    }

    //
    // Next try to find the scripts in the filesystem
    //
    if ((dwScriptFlags & CONFIG_SCRIPT_FROM_FILE) != 0)
    {
        IF_FAILED_GOTO_LDONE_WITH_HR(SgConfigGetScriptListFromFiles(pArenaAlloc, pScripts, pScriptLocation));
    }

    //
    // Lastly try to find the scripts in the DB
    //
    if ((dwScriptFlags & CONFIG_SCRIPT_FROM_DB) != 0 && g_fUseConfigDb)
    {
        IF_FAILED_GOTO_LDONE_WITH_HR(SgConfigGetScriptListFromConfigDb(pArenaAlloc, pScripts));
    }

    ok = TRUE;

lDone:

    return ok;
}

struct SG_CONFIG_GET_SCRIPT_LIST_CONTEXT
{
    CArenaAlloc* pArenaAlloc;
    THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts;
    BOOL errorOccurred;
};

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptListCallback
// Callback used by SgConfigGetScriptListFromFiles to enumerate the script files from the
// sgcfg directory.
//   - userData: pointer to SG_CONFIG_GET_SCRIPT_LIST_CONTEXT
//   - pPath: points to null-terminated string with the file's path
//   - pFilename: points to null-terminated string with the filename
// Returns:
//   true - if it wishes to continue, false if it wishes to stop the enumeration.
// ---------------------------------------------------------------------------------------
static
bool SgConfigGetScriptListCallback(void* userData, LPCSTR pPath, LPCSTR pFilename)
{
    SG_CONFIG_GET_SCRIPT_LIST_CONTEXT* pContext =
        (SG_CONFIG_GET_SCRIPT_LIST_CONTEXT*) userData;

    // skip . and ..

    if(strcmp(pFilename, ".") == 0 ||
       strcmp(pFilename, "..") == 0)
    {
        return true;
    }

    // don't add duplicates

    _strlwr_s( (char *) pFilename, MAX_PATH );
    if(pContext->pScripts->Get(pFilename, NULL))
    {
        return true;
    }

    // Make a copy of the filename using the arena allocator specified by the caller

    int len = strlen(pFilename);
    LPSTR pKey = (LPSTR) pContext->pArenaAlloc->Alloc(len + 1);

    if(!pKey)
    {
        pContext->errorOccurred = TRUE;
        return false;
    }

    memcpy(pKey, pFilename, len + 1);

    // Add script to hashtable

    if(!pContext->pScripts->Set(pKey, 0))
    {
        pContext->errorOccurred = TRUE;
        return false;
    }

    return true;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptListFromFiles
// Build a hashtable with the names of scripts retrieved from the sgcfg directory.
//   - pArenaAlloc : Arena allocator used to allocate the script names to be inserted in
//   pScripts
//   - pScripts : pointer to hashtable to write the script names to.
//   - pScriptLocation: Points to the search location
// Returns:
//   TRUE if it succeeded, FALSE otherwise
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigGetScriptListFromFiles(
    CArenaAlloc* pArenaAlloc,
    THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts,
    CStr*                                       pScriptLocation
    )
{
    TLocalStr<MAX_PATH> pattern;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOL ok = FALSE;

    //
    // Build pattern
    //
    pattern.Format( "%s%s", pScriptLocation->cstr(), SG_CONFIG_SCRIPT_PATTERN );

    // Enumerate files and build list. EnumerateFiles will call
    // SgConfigGetScriptListCallback once for every file that matches the pattern. Our
    // callback will add the filename to the list.

    SG_CONFIG_GET_SCRIPT_LIST_CONTEXT context;
    context.pArenaAlloc  = pArenaAlloc;
    context.pScripts     = pScripts;
    context.errorOccurred = FALSE;

    if(!CSystem::EnumerateFiles(pattern.cstr(), SgConfigGetScriptListCallback, &context) ||
       context.errorOccurred)
    {
        DWORD err = GetLastError();
        if(err != ERROR_FILE_NOT_FOUND &&
           err != ERROR_PATH_NOT_FOUND)
        {
            SgEventSz(
                CONFIG_ERROR,
                "Failed to enumerate files using pattern: '%s'. Win32 error = %u",
                pattern.cstr(), err);
            goto Exit;
        }
    }

    ok = TRUE;

Exit:

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptListFromConfigDb
// Build a hashtable with the names of scripts retrieved from the configdb (npdb)
//   - pArenaAlloc : Arena allocator used to allocate the script names to be inserted in
//   pScripts
//   - pScripts : pointer to hashtable to write the script names to.
// Returns:
//   TRUE if it succeeded, FALSE otherwise
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigGetScriptListFromConfigDb(
    CArenaAlloc* pArenaAlloc,
    THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts
    )
{
    Assert(!g_npdbConnectionString.IsEmpty());

    BOOL ok = FALSE;
    CODBWSession npdb;
    HRESULT hr;

    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.InitializeEx(g_npdbConnectionString.cstr()));

    IF_FAILED_GOTO_LDONE_WITH_HR(
        npdb.CallProc(NULL, L"dbo.p_sg_script_list"));

    struct SCRIPT_INFO
    {
        CHAR   scriptName[129];
        UINT32 enabled;
    } scriptInfo;

    static DBBINDING bind[] = {
        WSBIND(1, offsetof(SCRIPT_INFO, scriptName), DBTYPE_STR, ARRAY_SIZE(scriptInfo.scriptName)),
        WSBIND(2, offsetof(SCRIPT_INFO, enabled),    DBTYPE_I4,  0)
    };

    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.SetBindings(bind, ARRAY_SIZE(bind)));

    for(;;)
    {
        DBCOUNTITEM cRows = 1;
        IF_FAILED_GOTO_LDONE_WITH_HR(npdb.GetRows(&cRows, &scriptInfo, sizeof(scriptInfo)));

        if(cRows == 0)
        {
            // No more rows
            break;
        }

        if(!scriptInfo.enabled)
        {
            // This script is not enabled. Skip it.
            continue;
        }

        // don't add duplicates

        _strlwr_s( scriptInfo.scriptName, sizeof(scriptInfo.scriptName) );
        if(pScripts->Get(scriptInfo.scriptName, NULL))
        {
            continue;
        }

        // Make a copy of the filename using the arena allocator specified by the caller

        int len = strlen(scriptInfo.scriptName);

        LPSTR pKey = (LPSTR) pArenaAlloc->Alloc(len + 1);
        IF_FAILED_GOTO_LDONE(pKey != NULL);

        memcpy(pKey, scriptInfo.scriptName, len + 1);

        // Add it to hashtable

        IF_FAILED_GOTO_LDONE(pScripts->Set(pKey, 0));
    }

    ok = TRUE;

lDone:

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptListFromResourcesCallback
// Callback for SgConfigGetScriptListFromResources to enumerate the resources in the
// executable. It adds each resource name to the script list hash table passed in the
// context struct user data parameter.
//   - hModule : module whose resources we're enumerating. We don't care about this.
//   - pszType : resource type. We also don't case. It should always be LUA_SCRIPT.
//   - pszName : name of the resource. Scripts are stored using their filenames as
//   resource names with the .s replaced by _s.
//   - lParam : user data parameter provided to EnumResourceNamesA. We use this parameter
//   to pass our context structure
// Returns:
//   TRUE - if it wishes to continue, FALSE if it wishes to stop the enumeration.
// ---------------------------------------------------------------------------------------
static
BOOL CALLBACK SgConfigGetScriptListFromResourcesCallback(
    HMODULE   hModule,
    LPCSTR    pszType,
    LPSTR     pszName,
    LONG_PTR  lParam
    )
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(pszType);

    SG_CONFIG_GET_SCRIPT_LIST_CONTEXT* pContext =
        (SG_CONFIG_GET_SCRIPT_LIST_CONTEXT*) lParam;

    // Make a copy of the filename so that we can modify it

    CHAR filenameCopy[MAX_PATH];
    lstrcpynA(filenameCopy, pszName, ARRAY_SIZE(filenameCopy));

    // replate all _ with .

    for(char* p=filenameCopy; *p != 0; p++)
    {
        if(*p == '_')
        {
            *p = '.';
        }
    }

    // don't add duplicates
    _strlwr_s( filenameCopy, MAX_PATH );
    if(pContext->pScripts->Get(filenameCopy, NULL))
    {
        return TRUE;
    }

    // Make a copy of the filename using the arena allocator specified by the caller

    int len = strlen(filenameCopy);
    LPSTR pKey = (LPSTR) pContext->pArenaAlloc->Alloc(len + 1);

    if(!pKey)
    {
        pContext->errorOccurred = TRUE;
        return FALSE;
    }

    memcpy(pKey, filenameCopy, len + 1);

    // Add script to hashtable

    if(!pContext->pScripts->Set(pKey, 0))
    {
        pContext->errorOccurred = TRUE;
        return FALSE;
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptListFromResources
// Build a hashtable with the names of scripts retrieved from the sgcfg directory.
//   - pArenaAlloc : Arena allocator used to allocate the script names to be inserted in
//   pScripts
//   - pScripts : pointer to hashtable to write the script names to.
// Returns:
//   TRUE if it succeeded, FALSE otherwise
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigGetScriptListFromResources(
    CArenaAlloc* pArenaAlloc,
    THashtable<LPCSTR, BYTE, CStringHashClass>* pScripts
    )
{
    BOOL ok = FALSE;
    BOOL success;

    SG_CONFIG_GET_SCRIPT_LIST_CONTEXT context;
    context.pArenaAlloc  = pArenaAlloc;
    context.pScripts     = pScripts;
    context.errorOccurred = FALSE;

    success = EnumResourceNamesA(
            NULL,
            "LUA_SCRIPT",
            SgConfigGetScriptListFromResourcesCallback,
            (LONG_PTR) &context);

    if(!success || context.errorOccurred)
    {
        SgEventSz(CONFIG_ERROR,
                   "Failed to enumerate scripts from resources. Win32 error = %u",
                   GetLastError());
        goto Exit;
    }

    ok = TRUE;

Exit:

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScript
// Get a script from either the sgcfg directory or the configdb. If a script with the
// same name exists in both places, the one from the sgcfg will take precedence.
//   - pFilename: points to null-terminated string with the name of the script to
//   retrieve.
//   - pScriptInfo: points to a CScriptInfo object to receive the script, binary data, and
//   settings related to the script.
//   - pScriptLocation: Points to the relative directory structure of the script
//   - dwScriptFlags: Controls which locations to read the script from
// Returns:
//   S_OK if it succeeds.
//   HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the script was not found
//   Other HRESULT errors if it failed to load the script for another reason
// ---------------------------------------------------------------------------------------
HRESULT SgConfigGetScript(
    LPCSTR       pFilename,
    CScriptInfo* pScriptInfo,
    CStr*        pScriptLocation,
    DWORD        dwScriptFlags
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    //
    // First try to find the script as a file
    //
    if ((dwScriptFlags & CONFIG_SCRIPT_FROM_FILE) != 0)
    {
        hr = SgConfigGetScriptFromFile(pFilename, pScriptInfo, pScriptLocation);
        if (SUCCEEDED(hr))
        {
            TraceSz( Config, "    Loaded script %s from file", pFilename);
            return hr;
        }
    }

    //
    // Next try to find the script as a DB setting
    //
    if ((dwScriptFlags & CONFIG_SCRIPT_FROM_DB) != 0 && g_fUseConfigDb)
    {
        hr = SgConfigGetScriptFromDatabase(pFilename, pScriptInfo);
        if (SUCCEEDED(hr))
        {
            TraceSz( Config, "    Loaded script %s from database", pFilename);
            return hr;
        }
    }

    //
    // Lastly, try to find the script from the resource
    //
    if ((dwScriptFlags & CONFIG_SCRIPT_FROM_RESOURCE) != 0)
    {
        hr = SgConfigGetScriptFromResource(pFilename, pScriptInfo);
        if (SUCCEEDED(hr))
        {
            TraceSz( Config, "    Loaded script %s from resource", pFilename);
            return hr;
        }
    }

    TraceSz( Config, "    Unable to load script %s", pFilename);
    return hr;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptFromDatabase
// Get a script from the config db
//   - pFilename: points to null-terminated string with the name of the script to
//   retrieve.
//   - pScriptInfo: points to a CScriptInfo object to receive the script, binary data, and
//   settings related to the script.
// Returns:
//   S_OK if it succeeds.
//   HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the script was not found
//   Other HRESULT errors if it failed to load the script for another reason
// ---------------------------------------------------------------------------------------
HRESULT SgConfigGetScriptFromDatabase(
    LPCSTR       pFilename,
    CScriptInfo* pScriptInfo
    )
{
    Assert(!g_npdbConnectionString.IsEmpty());

    CODBWSession npdb;
    HRESULT hr = E_FAIL;

    //
    // Initialize the connection
    //
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.InitializeEx(g_npdbConnectionString.cstr()));

    //
    // Execute the script to get the result sets
    //
    IF_FAILED_GOTO_LDONE_WITH_HR(
        npdb.CallProc(NULL, L"dbo.p_sg_script_get %128S", pFilename));

    //
    // ROWSET 1 - ti_chal_kick_enabled, ti_chal_timeout_enabled
    //

    // BOOL is 4 bytes. This db class doesn't seem to like converting the tinyint (1 byte)
    // to 4 bytes automatically, so we need a little intermediate class. If a column is
    // null, like i_chal_timeout_secs may be, then this db class seems to not set the
    // value at all, which is good -- we'll keep the TIMEOUT_NOT_SPECIFIED value.
    struct SETTINGS
    {
        unsigned char bKickEnabled;
        unsigned char bTimeoutEnabled;
    } settings;
    settings.bKickEnabled    = 1;
    settings.bTimeoutEnabled = 1;

    DBBINDING bindSettings[] = {
        WSBIND(1, offsetof(SETTINGS, bKickEnabled), DBTYPE_I1, 1),
        WSBIND(2, offsetof(SETTINGS, bTimeoutEnabled), DBTYPE_I1, 1)
    };

    DBCOUNTITEM cRows = 1;
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.SetBindings(bindSettings, ARRAY_SIZE(bindSettings)));
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.GetRows(&cRows, &settings, sizeof(settings)));

    //
    // Check to see that we got at least one row back
    //
    if(cRows == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto lDone;
    }

    pScriptInfo->bKickEnabled    = settings.bKickEnabled;
    pScriptInfo->bTimeoutEnabled = settings.bTimeoutEnabled;


    //
    // ROWSET 2 - txt_script
    //

    hr = npdb.NextRowsetResult();
    if (hr != S_OK)
    {
        goto lSuccess;
    }

    struct SIZES
    {
        ULONG scriptSize;
    } sizes;

    static DBBINDING bindSizes[] = {
        WSBIND2(1, 0, DBTYPE_STR,   10485760, DBPART_LENGTH, offsetof(SIZES, scriptSize), 0)
    };

    //
    // Get the size of the first row
    //
    cRows = 1;
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.SetBindings(bindSizes, ARRAY_SIZE(bindSizes)));
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.GetRows(&cRows, &sizes, sizeof(sizes)));

    //
    // Check to see that we got at least one row back
    //
    if(cRows == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto lDone;
    }

    //
    // Make sure buffer has enough space. 'HasRoom' will attempt to expand buffer if
    // necessary.
    //
    IF_FAILED_GOTO_LDONE(pScriptInfo->scriptBuffer.HasRoom(sizes.scriptSize + 2));

    //
    // Get a pointer to the buffer
    //
    UINT32 bufferCapacity;
    BYTE* pBuffer = pScriptInfo->scriptBuffer.StartWrite(&bufferCapacity);

    DBBINDING bindScript[] = {
        WSBIND(1, 0, DBTYPE_STR, sizes.scriptSize + 2)
    };

    //
    // Fill in the buffer with the contents of the 1st row
    //
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.SetBindings(bindScript, ARRAY_SIZE(bindScript)));
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.GetLastRow(pBuffer));

    //
    // We are done writting to this buffer
    //
    pScriptInfo->scriptBuffer.EndWrite(sizes.scriptSize);


    //
    // ROWSET 3 - im_blob
    //

    hr = npdb.NextRowsetResult();
    if (hr != S_OK)
    {
        goto lSuccess;
    }

    static DBBINDING bindSizes2[] = {
        WSBIND2(1, 0, DBTYPE_BYTES, 10485760, DBPART_LENGTH, offsetof(SIZES, scriptSize), 0)
    };

    //
    // Get the size of the first row
    //
    cRows = 1;
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.SetBindings(bindSizes2, ARRAY_SIZE(bindSizes2)));
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.GetRows(&cRows, &sizes, sizeof(sizes)));

    //
    // Check to see that we got at least one row back
    //
    if(cRows == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto lDone;
    }

    //
    // We are allowed to not have a binary blob
    //
    if (sizes.scriptSize == 0)
    {
        goto lSuccess;
    }

    //
    // Make sure buffer has enough space. 'HasRoom' will attempt to expand buffer if
    // necessary.
    //
    IF_FAILED_GOTO_LDONE(pScriptInfo->blobBuffer.HasRoom(sizes.scriptSize + 2));

    //
    // Get a pointer to the buffer
    //
    pBuffer = pScriptInfo->blobBuffer.StartWrite(&bufferCapacity);

    DBBINDING bindScript2[] = {
        WSBIND(1, 0, DBTYPE_BYTES, sizes.scriptSize + 2)
    };

    //
    // Fill in the buffer with the contents of the 1st row
    //
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.SetBindings(bindScript2, ARRAY_SIZE(bindScript2)));
    IF_FAILED_GOTO_LDONE_WITH_HR(npdb.GetLastRow(pBuffer));

    //
    // We are done writting to this buffer
    //
    pScriptInfo->blobBuffer.EndWrite(sizes.scriptSize);

lSuccess:

    SgEventSz(LOADING_SCRIPT, "From t_sg_scripts: %s", pFilename);

    hr = S_OK;

lDone:

    return hr;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptFromFile
// Get a script from the sgcfg directory.
//   - pFilename: points to null-terminated string with the name of the script to
//   retrieve.
//   - pScriptInfo: points to a CScriptInfo object to receive the script, binary data, and
//   settings related to the script.
//   - pScriptLocation: Points to the relative directory structure of the script
// Returns:
//   S_OK if it succeeds.
//   HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the script was not found
//   Other HRESULT errors if it failed to load the script for another reason
// ---------------------------------------------------------------------------------------
HRESULT SgConfigGetScriptFromFile(
    LPCSTR       pFilename,
    CScriptInfo* pScriptInfo,
    CStr*        pScriptLocation
    )
{
    BYTE* pBuffer;
    DWORD read;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFile2 = INVALID_HANDLE_VALUE;
    HRESULT hr = E_FAIL;
    TLocalStr<MAX_PATH> moduleName;
    TLocalStr<MAX_PATH> filename;
    TLocalStr<MAX_PATH> binaryname;
    UINT32 bufferCapacity;
    UINT32 fileSize;

    //
    // Generate the full pathname to the file
    //
    filename.Format("%s%s", pScriptLocation->cstr(), pFilename);

    //
    // Open file for reading
    //
    hFile = CreateFileA(
        filename.cstr(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    // Get the file size
    //
    fileSize = GetFileSize(hFile, NULL);

    //
    // Make sure buffer has enough space. 'HasRoom' will attempt to expand buffer if
    // necessary.
    //
    if (!pScriptInfo->scriptBuffer.HasRoom(fileSize))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Get a pointer to the buffer
    //
    pBuffer = pScriptInfo->scriptBuffer.StartWrite(&bufferCapacity);

    //
    // Read the file
    //
    if(!ReadFile(hFile, pBuffer, bufferCapacity, &read, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    // Signal that we are done reading
    //
    pScriptInfo->scriptBuffer.EndWrite(read);

    //
    // Generate the blob filename by appending .bin to the end of the file
    //
    binaryname.Format("%s%s.bin", pScriptLocation->cstr(), pFilename);

    //
    // See if the file exists
    //
    hFile2 = CreateFileA(
        binaryname.cstr(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (INVALID_HANDLE_VALUE == hFile2)
    {
        goto Succeeded;
    }

    //
    // Get the file size and make sure that there is enough room in the buffer
    //
    fileSize = GetFileSize(hFile2, NULL );
    if (!pScriptInfo->blobBuffer.HasRoom(fileSize))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Setup the read buffer
    //
    pBuffer = pScriptInfo->blobBuffer.StartWrite(&bufferCapacity);

    //
    // Read the file
    //
    if (!ReadFile(hFile2, pBuffer, bufferCapacity, &read, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    // Signal that we are done reading
    //
    pScriptInfo->blobBuffer.EndWrite(read);


Succeeded:

    SgEventSz(LOADING_SCRIPT, "From file: %s", filename.cstr());

    hr = S_OK;

Exit:

    //
    // Close the resources
    //
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (INVALID_HANDLE_VALUE != hFile2)
    {
        CloseHandle(hFile2);
    }

    return hr;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetScriptFromResource
// Get a script from the executable's resources.
//   - pFilename: points to null-terminated string with the name of the script to
//   retrieve.
//   - pScriptInfo: points to a CScriptInfo object to receive the script, binary data, and
//   settings related to the script.
// Returns:
//   S_OK if it succeeds.
//   HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the script was not found
//   Other HRESULT errors if it failed to load the script for another reason
// ---------------------------------------------------------------------------------------
HRESULT SgConfigGetScriptFromResource(
    LPCSTR       pFilename,
    CScriptInfo* pScriptInfo
    )
{
    HRSRC   hrsrc   = NULL;
    HGLOBAL hglobal = NULL;
    DWORD   size    = 0;
    BYTE*   presbin = NULL;
    HRESULT hr      = E_UNEXPECTED;

    // Make a copy of the filename so that we can modify it

    CHAR filenameCopy[MAX_PATH];
    lstrcpynA(filenameCopy, pFilename, ARRAY_SIZE(filenameCopy));

    // replate all . with _

    for(char* p=filenameCopy; *p != 0; p++)
    {
        if(*p == '.')
        {
            *p = '_';
        }
    }

    // Load the resource

    hrsrc = FindResourceA(NULL, filenameCopy, "LUA_SCRIPT");
    if(hrsrc == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto lDone;
    }

    size = SizeofResource(NULL, hrsrc);
    IF_FAILED_GOTO_LDONE(size != 0);

    hglobal = LoadResource(NULL, hrsrc);
    IF_FAILED_GOTO_LDONE(hglobal != NULL);

    presbin = (BYTE*) LockResource(hglobal);
    IF_FAILED_GOTO_LDONE(presbin != NULL);

    // Make sure buffer has enough space. 'HasRoom' will attempt to expand buffer if
    // necessary.

    if(!pScriptInfo->scriptBuffer.HasRoom(size))
    {
        goto lDone;
    }

    // Get a pointer to the buffer

    UINT32 bufferCapacity;
    BYTE* pBuffer = pScriptInfo->scriptBuffer.StartWrite(&bufferCapacity);
    Assert(bufferCapacity >= size);

    memcpy(pBuffer, presbin, size);

    pScriptInfo->scriptBuffer.EndWrite(size);

    SgEventSz(LOADING_SCRIPT, "From resource: %s", pFilename);

    hr = S_OK;

lDone:

    if(hglobal != NULL)
    {
        FreeResource(hglobal);
    }

    return hr;
}

// }}} End SgConfig goop

// {{{ Config, Init, Term, Install

// ---------------------------------------------------------------------------------------
// SgConfigWithText
// Configure SG components from a text blob containing SG config stuff
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigWithText( const char* pszConfigText)
{
    BOOL        fOk = TRUE;
    CCfgInfo    configInfo;
    DWORD       parseStatus;
    DWORD       errorLine = 0;

    // Parse config blob
    parseStatus = configInfo.Parse(pszConfigText, &errorLine);
    if(CFGERR_SUCCESS != parseStatus)
    {
        SgEventSz(CONFIG_ERROR, "Failed to parse configuration data. Line: %u", errorLine);
        fOk = FALSE;
        goto lDone;
    }

    // Use parsed config stuff to initialize SG components
    TraceSz(Config, "Begin Configuration -------------------------------------------------");
    TraceSz(Config, "");

#define CFG(f) \
    if(fOk) { \
        fOk = f(&configInfo); \
        if(!fOk) { \
            SgEventSz(CONFIG_ERROR, "Failed to config component: %s", #f); \
        } \
    }

    // SgTraceConfig should be first, so we see any subsequent tracing
    CFG(SgTraceConfig);

    CFG(SgEventConfig);
    CFG(SgPerfdataConfig);
    CFG(SgRandConfig);
    CFG(SgHashConfig);
    CFG(SgMemConfig);
    CFG(SgServiceMsgHandlerConfig);
    CFG(SgPacketConfig);
    CFG(SgTimerConfig);
#ifdef SG_FEATURE_LUA
    CFG(SgLuaConfig);
#endif
    CFG(SgRecvConfig);
#ifdef SG_FEATURE_ARP
    CFG(SgArpInfoConfig);
#endif
    CFG(SgProcBalConfig);
    CFG(SgTransInfoConfig);
    CFG(SgSiteInfoConfig);
    CFG(SgSvcInfoConfig);
    CFG(SgDstInfoConfig);
    CFG(SgSpiInfoConfig);
    CFG(SgDhInfoConfig);
    CFG(SgDatacenterConfig);
    CFG(SgClientStatsConfig);
#ifdef SG_FEATURE_LUA
    CFG(SgChalConfig);
#endif
#ifdef SG_FEATURE_LSP
    CFG(SgLspConfig);
#endif
    CFG(SgConfigWatcherConfig);
    CFG(SgNullCipherConfig);

#ifdef SG_FEATURE_ARP
    // Delay waiting for completion of ARP probes as long as possible, since they can take 
    // up to 6 seconds to complete.

    CFG(SgIpConflictConfig);
#endif

    TraceSz(Config, "");
    TraceSz(Config, "End Configuration ---------------------------------------------------");

    // Hey. This pszConfigText will have raw site keys in it. Until we find a solution for 
    // not exposing those, we're only going to dump this trace for debug builds. It's 
    // mostly a development-aiding feature anyway.
#if DBG || SG_BUILD_ONEBOX
    TraceSz(Config, "");
    TraceSz(Config, "Begin Raw Config File -----------------------------------------------");
    TraceSz(Config, "%s", pszConfigText);
    TraceSz(Config, "");
    TraceSz(Config, "End Raw Config File -------------------------------------------------");
#endif

    // Run the trace config again, which will end up resetting the sgconfig.log file and 
    // going back to whatever the user request.
    CFG(SgTraceConfigDone);

#undef CFG

#ifdef SG_FEATURE_LUA
    // Apply filter scripts
    if(fOk)
    {
        SgApplyFilterScriptAll();
    }
#endif // #ifdef SG_FEATURE_LUA

lDone:

    configInfo.Free();

    return(fOk);
}

// ---------------------------------------------------------------------------------------
// SgInit / SgTerm
// ---------------------------------------------------------------------------------------

BOOL SgInit()
{
    BOOL fOk = TRUE;

    CMemAlloc::Init();
    g_configTextLastKnownGood.SetAllocator(CMemAlloc::Default());
    g_npdbConnectionString.SetAllocator(CMemAlloc::Default());

    // SgEventInit must happen first since other Init functions may throw events
    fOk = fOk && SgTraceInit();
    fOk = fOk && TransInit();
    fOk = fOk && SgProcBalInit();
    fOk = fOk && SgPerfdataInit();
    fOk = fOk && SgRandInit();
    fOk = fOk && SgHashInit();
    fOk = fOk && SgPacketInit();
#ifdef SG_FEATURE_LUA
    fOk = fOk && SgLuaInit();
#endif
    fOk = fOk && SgRecvInit();
    fOk = fOk && SgHashInit();
#ifdef SG_FEATURE_ARP
    fOk = fOk && SgArpInfoInit();
#endif
    fOk = fOk && SgTransInfoInit();
    fOk = fOk && SgSiteInfoInit();
    fOk = fOk && SgSvcInfoInit();
    fOk = fOk && SgCliInfoInit();
    fOk = fOk && SgBlockInfoInit();
    fOk = fOk && SgDstInfoInit();
    fOk = fOk && SgNatInfoInit();
    fOk = fOk && SgSpiInfoInit();
    fOk = fOk && SgDhInfoInit();
    fOk = fOk && SgDatacenterInit();
    fOk = fOk && SgTimerInit();
    fOk = fOk && SgClientStatsInit();
#ifdef SG_FEATURE_LUA
    fOk = fOk && SgChalInit();
#endif
#ifdef SG_FEATURE_LSP
    fOk = fOk && SgLspInit();
#endif
    fOk = fOk && SgConfigWatcherInit();
    fOk = fOk && SgNullCipherInit();
#ifdef SG_FEATURE_CONFIG_DB
    fOk = fOk && SgConfigDbInit();
#endif

    return(fOk);
}

void SgTerm()
{
    SgTimerStop();
#ifdef SG_FEATURE_CONFIG_DB
    SgConfigDbTerm();
#endif
    SgNullCipherTerm();
    SgConfigWatcherTerm();
#ifdef SG_FEATURE_LSP
    SgLspTerm();
#endif
    TransStop();
    SgProcBalTerm();
#ifdef SG_FEATURE_LUA
    SgChalTerm();
#endif
    SgClientStatsTerm();
    SgDatacenterTerm();
    SgDhInfoTerm();
    SgSpiInfoTerm();
    SgNatInfoTerm();
    SgDstInfoTerm();
    SgBlockInfoTerm();
    SgCliInfoTerm();
    SgSvcInfoTerm();
    SgSiteInfoTerm();
    SgTransInfoTerm();
#ifdef SG_FEATURE_ARP
    SgArpInfoTerm();
#endif
    SgHashTerm();
    SgRecvTerm();
#ifdef SG_FEATURE_LUA
    SgLuaTerm();
#endif
    SgPacketTerm();
    SgHashTerm();
    SgRandTerm();
    SgPerfdataTerm();
    SgTimerTerm();
    TransTerm();
    SgTraceTerm();
}

// ---------------------------------------------------------------------------------------
// SgInstall/SgUninstall
// ---------------------------------------------------------------------------------------

BOOL SgInstall(OUT BOOL *pfRebootRequired)
{
    return SgEventInstall() &&
           TransInstall(pfRebootRequired);
}

BOOL SgUninstall(OUT BOOL *pfRebootRequired)
{
    return TransUninstall(pfRebootRequired);
}

// }}} End Config, Init, Term, Install

// {{{ Config building goop (npdb, file)

// ---------------------------------------------------------------------------------------
// SgConfigBuild
// Build the configuration text by merging configuration data from the Common Config
// database with the data from the configuration files
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigBuild(CStr* pConfigText)
{
    // Start from an empty string
    pConfigText->Reset();

#ifdef SG_FEATURE_CONFIG_DB

    // Read configuration from common config and translate into SG's text config format
    if(g_fUseConfigDb)
    {
        if(!SgConfigAddFromCommonConfig(pConfigText))
        {
            SgEventSz(CONFIG_ERROR, "Failed to read configuration from the common config. A previous event should contain details about the failure.");
            return FALSE;
        }

        if(Tag(Config))
        {
            // Dump config text blob. The Config trace area is initialy configured to go into
            // a initialization log, so this will be useful.

            TraceSz(Config, "Begin Common Config Text Blob -----------------------------------");
            TraceSz(Config, "");
            OutputDebugStringA(pConfigText->cstr());
            TraceSz(Config, "End Common Config Text Blob -------------------------------------");
        }
    }
    
#endif

    // Read configuration from configuration files in the sg config directory
    if(!SgConfigBuildFromFiles(pConfigText))
    {
        SgEventSz(CONFIG_ERROR, "Failed to read configuration from configuration files. A previous event should contain details about the failure.");
        return FALSE;
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------
static
BOOL ResetCurrentDirectory()
{
    BOOL ret = FALSE;
    WCHAR wszPath[MAX_PATH];
    WCHAR* pwszSlash = NULL;

    // Get the path of the SG executable. The config directory is relative to it.
    if(!GetModuleFileName( NULL, wszPath, ARRAY_SIZE(wszPath)))
    {
        SgEventSz(CONFIG_ERROR, "GetModuleFileName failed. Win32 error = %u", GetLastError());
        goto lDone;
    }
    wszPath[ARRAY_SIZE(wszPath)-1] = 0;

    // Find the last back-slash to isolate the path
    pwszSlash = wcsrchr(wszPath, L'\\');
    if(NULL == pwszSlash)
    {
        SgEventSz(CONFIG_ERROR, "GetModuleFileName returned an invalid path: '%S'", wszPath);
        goto lDone;
    }
    pwszSlash[1] = 0;
    TraceSz(Config, "Configuration base path is '%S'", wszPath);
               
    if(!SetCurrentDirectory(wszPath))
    {
        SgEventSz(CONFIG_ERROR, "SetCurrentDirectory failed for '%S'. Win32 error = %u",
                   wszPath, GetLastError());
        goto lDone;
    }
    
    ret = TRUE;

lDone:

    return ret;
}


// ---------------------------------------------------------------------------------------
// SgConfigBuildFromFiles
// Merge config text from SG config files with pConfigText
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigBuildFromFiles(CStr* pConfigText)
{
    BOOL ret = FALSE;

    if (!ResetCurrentDirectory())
    {
        // it already logged an event
        goto lDone;
    }

    if(!g_fUseConfigDb)
    {
        // Read main configuration file
        TraceSz(Config, "Reading configuration from: %S", SG_CONFIG_INI);
        if(!SgConfigBuildFromFile(SG_CONFIG_INI, FALSE, pConfigText))
        {
            SgEventSz(CONFIG_ERROR, "Failed to read configuration from: '%S'", SG_CONFIG_INI);
            goto lDone;
        }
    }

    // Read configuration files
    TraceSz(Config, "Reading configuration files from pattern: '%S'", SG_CONFIG_UNSECURE_FILES_PATTERN);
    if(!SgConfigBuildFromFilePattern(SG_CONFIG_UNSECURE_FILES_PATTERN, SG_CONFIG_UNSECURE_FILES_EXTENSION, FALSE, pConfigText))
    {
        SgEventSz(CONFIG_ERROR, "Failed to read configuration files from pattern: '%S'", SG_CONFIG_UNSECURE_FILES_PATTERN);
        goto lDone;
    }

    // Read secure (encrypted) configuration files
    TraceSz(Config, "Reading secure configuration files from pattern: '%S'", SG_CONFIG_SECURE_FILES_PATTERN);
    if(!SgConfigBuildFromFilePattern(SG_CONFIG_SECURE_FILES_PATTERN, SG_CONFIG_SECURE_FILES_EXTENSION, TRUE, pConfigText))
    {
        SgEventSz(CONFIG_ERROR, "Failed to read configuration files from pattern: '%S'", SG_CONFIG_SECURE_FILES_PATTERN);
        goto lDone;
    }

    ret = TRUE;

lDone:

    return ret;
}

// ---------------------------------------------------------------------------------------
// SgConfigBuildFromFilePattern
// Merge config text from SG config files give a file pattern. If fDecrypt is set to TRUE,
// the files will be decrypted before merged.
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigBuildFromFilePattern(
    const WCHAR*        pwzMatch,
    const WCHAR*        pwzExtension,
    BOOL                fDecrypt,
    CStr*               pConfigText
)
{
    BOOL fOk = TRUE;
    BOOL fReturn = FALSE;
    WCHAR wzPath[ MAX_PATH ];
    WCHAR* pwzSlash;
    WCHAR* pwzPeriod;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW find;
    DWORD err = NO_ERROR;

    // Make a local copy of the path so we can modify it
    wcsncpy( wzPath, pwzMatch, dimensionof( wzPath ) );
    wzPath[ dimensionof( wzPath ) - 1 ] = L'\0';

    pwzSlash = wcsrchr( wzPath, L'\\' );
    if( NULL == pwzSlash )
    {
        pwzSlash = wzPath;
    }
    else
    {
        pwzSlash++;
    }

    hFind = FindFirstFileW( wzPath, &find );
    if( INVALID_HANDLE_VALUE == hFind )
    {
        err = GetLastError();
    }

    while( NO_ERROR == err )
    {
        fOk = TRUE;

        // 42672 - Make sure that the file ends exactly in the given extension
        if (TRUE == fOk) 
        {
            pwzPeriod = wcsrchr( find.cFileName, L'.' );
            if (NULL == pwzPeriod) 
            {
                fOk = FALSE;
            }
            else
            {
                pwzPeriod++;
            }
        }

        if (TRUE == fOk && wcsicmp( pwzPeriod, pwzExtension ) != 0) 
        {
            fOk = FALSE;
        }

        if (TRUE == fOk) 
        {
            wcscpy( pwzSlash, find.cFileName );
            if( !SgConfigBuildFromFile( wzPath, fDecrypt, pConfigText ) )
            {
                SgEventSz(CONFIG_ERROR, "SGPROXY: SgIoConfigFromFilePattern() - SgConfigAddFile failed for path='%ls'", wzPath );
                goto Exit;
            }
        }

        // Get the next file in the search
        if( !FindNextFileW( hFind, &find ) )
        {
            err = GetLastError();
        }
    }

    if( ERROR_NO_MORE_FILES != err &&
        ERROR_FILE_NOT_FOUND != err &&
        ERROR_PATH_NOT_FOUND != err )
    {
        SgEventSz(CONFIG_ERROR, "SGPROXY: SgIoConfigFromFilePattern() - FindFirstFile/FindNextFile failed for path='%ls', err = 0x%08x", wzPath, err );
        goto Exit;
    }

    fReturn = TRUE;

Exit:
    if( INVALID_HANDLE_VALUE != hFind )
    {
        FindClose( hFind );
        hFind = INVALID_HANDLE_VALUE;
    }

    return fReturn;
}

// ---------------------------------------------------------------------------------------
// Entropy for decrypting configuration. Must match abEntropy in xkeymgr.
// ---------------------------------------------------------------------------------------

static BYTE abEntropy[] =
{
    0x6a, 0xd4, 0xbf, 0x5a, 0x98, 0xe3, 0x88, 0x4b, 0xbf, 0xa2, 0x20, 0x53, 0x30, 0xc0, 0x38, 0xe3,
    0x5e, 0xcb, 0x9a, 0x06, 0xe2, 0x37, 0x2c, 0x74, 0x7f, 0xd8, 0x10, 0xd7, 0x0f, 0x23, 0x89, 0x75,
    0x9b, 0x85, 0xf5, 0x82, 0x1b, 0x9b, 0xa8, 0xd7, 0x7a, 0x55, 0x25, 0xca, 0x9f, 0x93, 0xca, 0xb4,
    0x9f, 0xbd, 0x13, 0xcc, 0x64, 0xec, 0x09, 0xa1, 0xd2, 0xf8, 0x09, 0x71, 0x0d, 0x2a, 0x1b, 0x87,
    0xba, 0x0e, 0x1e, 0x4d, 0x7e, 0x52, 0x1b, 0x4d, 0xc6, 0xcc, 0x4b, 0x9d, 0xc7, 0xf3, 0x87, 0xf6,
    0x2e, 0x74, 0xea, 0xe3, 0xcd, 0x97, 0x3a, 0x49, 0x83, 0x80, 0xa4, 0xa1, 0x0c, 0xc6, 0x98, 0x97,
    0xd4, 0xd1, 0x88, 0x3c, 0xee, 0x8e, 0xb0, 0x3b, 0xb4, 0x6e, 0xb5, 0xb2, 0xed, 0x43, 0xdb, 0x7e,
    0x96, 0xf3, 0xfb, 0x60, 0x8b, 0x45, 0x5c, 0x43, 0x9d, 0x7f, 0x8f, 0x5d, 0xcf, 0xf2, 0x0d, 0x76,
    0x71, 0x0a, 0xc5, 0x29, 0x06, 0x6c, 0x85, 0xa3, 0x33, 0x0e, 0x83, 0x05, 0xa0, 0x75, 0xba, 0xc1,
    0xe5, 0xf3, 0x5a, 0x11, 0x72, 0x29, 0xd2, 0xfd, 0x7e, 0xe8, 0xbd, 0x39, 0x30, 0x95, 0x5f, 0xde,
    0xee, 0x21, 0xa8, 0x25, 0xa9, 0xcd, 0x45, 0x31, 0x12, 0x29, 0x59, 0x24, 0x19, 0x22, 0xc5, 0x6a,
    0xbc, 0x71, 0x2b, 0x16, 0x8f, 0xaf, 0x0b, 0x0d, 0x0a, 0xf5, 0xc9, 0xad, 0xe9, 0x21, 0xab, 0x0d,
    0x63, 0xea, 0xa3, 0x99, 0x99, 0x31, 0xd7, 0x4e, 0x87, 0xcb, 0x38, 0xb2, 0x33, 0xc2, 0xf7, 0xf8,
    0x32, 0x0b, 0xee, 0x09, 0xcc, 0x2f, 0xea, 0x4f, 0x0d, 0xa3, 0x5c, 0x07, 0x4a, 0x9a, 0xe0, 0x75,
    0xcb, 0x5b, 0x48, 0x01, 0x99, 0xdb, 0x4f, 0x0b, 0x54, 0xde, 0x8a, 0x18, 0xaf, 0x97, 0x4f, 0xdc,
    0x19, 0xf1, 0x7c, 0x48, 0x30, 0xcd, 0xd0, 0xe2, 0x72, 0xe1, 0x2f, 0x4b, 0x84, 0xbe, 0x2b, 0x5c
};

// ---------------------------------------------------------------------------------------
// SgConfigBuildFromFile
// Merge config text from a text file with pConfigText
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigBuildFromFile(
    const WCHAR*        pwzFile,
    BOOL                fDecrypt,
    CStr*               pConfigText
)
{
    BOOL fOk = FALSE;
    HRESULT hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFileSize;
    DWORD dwRead;
    char* pchFile = NULL;
    CCfgInfo configInfo;
    DWORD errorLine = 0;

    hFile = CreateFileW( pwzFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        SgEventSz(CONFIG_ERROR, "SGPROXY: SgConfigAddFile() - CreateFile failed for file='%ls', hr=0x%08X", pwzFile, hr );
        goto Exit;
    }

    dwFileSize = GetFileSize( hFile, NULL );

    pchFile = (char*) malloc( dwFileSize + 1 );
    if( NULL == pchFile )
    {
        SgEventSz(CONFIG_ERROR, "SGPROXY: SgConfigAddFile() - Failed to allocate %u bytes for reading file=''%ls'", dwFileSize + 1, pwzFile );
        goto Exit;
    }

    if( !ReadFile( hFile, pchFile, dwFileSize, &dwRead, NULL ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        SgEventSz(CONFIG_ERROR, "SGPROXY: SgConfigAddFile() - ReadFile failed for file='%ls', hr=0x%08X", pwzFile, hr );
        goto Exit;
    }

    if( fDecrypt )
    {
        DATA_BLOB dbIn;
        DATA_BLOB dbOut;
        DATA_BLOB dbEntropy;

        dbIn.cbData = dwFileSize;
        dbIn.pbData = (BYTE*) pchFile;

        dbEntropy.cbData = sizeof( abEntropy );
        dbEntropy.pbData = abEntropy;

        if( !CryptUnprotectData(
            &dbIn,
            NULL,
            &dbEntropy,
            NULL,
            NULL,
            CRYPTPROTECT_UI_FORBIDDEN,
            &dbOut ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            SgEventSz(CONFIG_ERROR, "SGPROXY: SgConfigAddFile() - CryptUnprotectData failed for file='%ls', hr=0x%08X", pwzFile, hr );
            goto Exit;
        }

        // Swap our file info for the decrypted version
        free( pchFile );

        // Reallocate since the Crypto API will not have made room for a NULL, and we don't want to have to track
        // which freeing function to use below.
        pchFile = (char*) malloc( dbOut.cbData + 1 );
        if( NULL == pchFile )
        {
            SecureZeroMemory( dbOut.pbData, dbOut.cbData );
            LocalFree( dbOut.pbData );
            SgEventSz(CONFIG_ERROR, "SGPROXY: SgConfigAddFile() - Failed to allocate %u bytes for reading file=''%ls'", dwFileSize + 1, pwzFile );
            goto Exit;
        }

        memcpy( pchFile, dbOut.pbData, dbOut.cbData );
        dwFileSize = dbOut.cbData;

        SecureZeroMemory( dbOut.pbData, dbOut.cbData );
        LocalFree( dbOut.pbData );
    }

    // Null terminate the file text for ease of parsing
    pchFile[ dwFileSize ] = '\0';

    // Check file's syntax
    DWORD parseStatus = configInfo.Parse(pchFile, &errorLine);
    if( parseStatus != CFGERR_SUCCESS )
    {
        char * pszErr;
        pszErr = parseStatus == CFGERR_UNCLOSED_STRING ? "Unterminated string" :
                 parseStatus == CFGERR_UNCLOSED_BRACES ? "Unterminated list" :
                 parseStatus == CFGERR_UNOPENED_BRACE ? "Extraneous close brace" :
                 parseStatus == CFGERR_INVALID_NAME ? "Illegal name in name-value pair" :
                 parseStatus == CFGERR_MISSING_VALUE ? "Missing value in name-value pair" :
                 parseStatus == CFGERR_OUT_OF_MEMORY ? "Out of memory" : "Unknown error";

        SgEventSz(CONFIG_ERROR, "Config syntax error (file %S, line %d): %s", pwzFile, errorLine, pszErr );
    }

    // Concatenate
    pConfigText->Format("\r\n");
    pConfigText->CopyFrom(CConstStr(pchFile, dwFileSize));

    fOk = TRUE;

Exit:
    if( NULL != pchFile )
    {
        SecureZeroMemory( pchFile, dwFileSize );
        free( pchFile );
        pchFile = NULL;
    }

    if( INVALID_HANDLE_VALUE != hFile )
    {
        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }

    configInfo.Free();

    return fOk;
}

// }}} End config building stuff

// ---------------------------------------------------------------------------------------
// Config Watcher
// infrastructure to watch for changes to sgconfig.ini and the sgcfg directory
// ---------------------------------------------------------------------------------------
FILETIME  g_ftConfigTimeStamp;           // Last modified date of sgconfig.ini
CTimer    g_configWatcherTimer;          // timer to pool for config file changes
CSmallStr g_configFileName;              // full path and name of config file

#define CONFIG_WATCHER_TIMER_INTERVAL_SECONDS  5

BOOL SgConfigWatcherGetTimestamp(FILETIME* pftTimeStamp)
{
    BOOL ok = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA attribdata;

    if(::GetFileAttributesExA(g_configFileName.cstr(), GetFileExInfoStandard,
                              &attribdata))
    {
        *pftTimeStamp = attribdata.ftLastWriteTime;
        ok = TRUE;
    }
    else
    {
        DWORD error = ::GetLastError();

        if(ERROR_FILE_NOT_FOUND == error)
        {
            SgEventSz(CONFIG_ERROR, "Can't find configuration file %s",
                       g_configFileName.cstr());
        }
        else
        {
            SgEventSz(CONFIG_ERROR, "Failed to open configuration file %s. Error: %u",
                       g_configFileName.cstr(), error);
        }
    }

    return ok;
}

BOOL SgConfigWatcherInit()
{
    BOOL ok = FALSE;

    ZeroMemory(&g_ftConfigTimeStamp, sizeof(g_ftConfigTimeStamp));
    g_configFileName.Reset();
    g_configWatcherTimer.Init();

    if(g_fUseConfigDb)
    {
        //
        // there is no main configuration file to be watched
        //

        return TRUE;
    }

    //
    // build the path to the config file based on the module's path
    //

    CSmallStr module;

    ok = CSystem::GetModuleName(NULL, &module);

    ok = ok && CSystem::ParseFileName(module.cstr(), CSystem::PARSE_DRIVE_AND_PATH,
                                      &g_configFileName);

    if(!ok)
    {
        SgEventSz(INIT_ERROR, "Failed to retrieve module's path. Last-error: %u",
                   ::GetLastError());
        goto Exit;
    }

    g_configFileName.Format("%S", SG_CONFIG_INI);

    ok = FALSE;

    //
    // initialize config file's timestamp
    //

    if(!SgConfigWatcherGetTimestamp(&g_ftConfigTimeStamp))
    {
        goto Exit;
    }

    ok = TRUE;

Exit:

    return ok;
}

void SgConfigWatcherTerm()
{
    // no need to cancel timer - it will be gracefully cancelled when the Sg terminates
}

void SgConfigWatcherTimer(CTimer*)
{
    FILETIME ftNewTimestamp;

    //
    // get the current timestamp of the config file. If it has been updated recently,
    // reload configuration
    //

    if(SgConfigWatcherGetTimestamp(&ftNewTimestamp))
    {
        if(*((ULONGLONG*)&ftNewTimestamp) > *((ULONGLONG*)&g_ftConfigTimeStamp))
        {
            g_ftConfigTimeStamp = ftNewTimestamp;
            SgEventSz(RELOAD_CONFIG, "%s", g_configFileName.cstr());
            SgConfig();
        }
    }

    //
    // reschedule
    //

    SgTimerSet(&g_configWatcherTimer, SgConfigWatcherTimer,
               SgTimerTick() + CONFIG_WATCHER_TIMER_INTERVAL_SECONDS * TICKS_PER_SECOND,
               TRUE);
}

BOOL SgConfigWatcherConfig(CCfgInfo*)
{
    if(g_fUseConfigDb)
    {
        //
        // there is no main configuration file to be watched
        //

        return TRUE;
    }

    Assert(!g_configFileName.IsEmpty());

    //
    // start the config timer
    //

    SgTimerSet(&g_configWatcherTimer, SgConfigWatcherTimer,
               SgTimerTick() + CONFIG_WATCHER_TIMER_INTERVAL_SECONDS * TICKS_PER_SECOND,
               TRUE);

    return TRUE;
}


#ifdef SG_FEATURE_CONFIG_DB

// ---------------------------------------------------------------------------------------
// ConfigDb
//
// Infrastructure to watch for changes to npdb. Also sets up a structured config reload
// system, so we can schedule reloads in a controlled manner. Important to note that
// SG_FEATURE_XMGMT relies on this code, but any time XMGMT is enabled,
// SG_FEATURE_CONFIG_DB should also be enabled.
// ---------------------------------------------------------------------------------------

CTimer              g_configReloadTimer;
volatile LONG       g_bConfigReloadScheduled;
CSGConfigListener*  g_pConfigListener = NULL;
CComPtr<XblConfig::IConfig> g_pConfig;

BOOL SgConfigDbInit()
{
    HRESULT hr;

    //
    // Create a single global instance of the commonconfig com object
    //
    hr = g_pConfig.CoCreateInstance( __uuidof(XblConfig::ConfigInterop) );
    if (FAILED(hr))
    {
        SgEventSz(
            CONFIG_ERROR,
            "Failed to create the common config object. Verify that "
            "commonconfig.dll is installed correctly. hr = 0x%08x",
            hr
            );
        return FALSE;
    }

    //
    // Initialize the reload timer
    //
    g_configReloadTimer.Init();
    g_bConfigReloadScheduled = 0;

    //
    // Create a new listener object
    //
    g_pConfigListener = new CSGConfigListener;
    if (g_pConfigListener == NULL)
    {
        return FALSE;
    }

    //
    // Initialize the listener
    //
    if (FAILED(g_pConfigListener->Init()))
    {
        return FALSE;
    }

    // 
    // Initialize healthcheck system. Comes along with NPDB.
    //
    CComBSTR bstrComponent;
    g_pConfig->get_ComponentName(&bstrComponent);
    if (!SgHealthInit(bstrComponent))
    {
        return FALSE;
    }

    return TRUE;
}

void SgConfigDbTerm()
{
    SgHealthTerm();

    //
    // Delete the current listener
    //
    if (g_pConfigListener)
    {
        g_pConfigListener->Term();
        g_pConfigListener->Release();
    }
    g_pConfigListener = NULL;
    
    // 
    // Delete the config com object
    //
    g_pConfig.Release();
}


// ---------------------------------------------------------------------------------------
// SgConfigAddFromCommonConfig
// Translate configuration data from common config to the configuration text format used
// by the SG and add it to pConfigText.
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddFromCommonConfig(CStr* pConfigText)
{
    BOOL ret = FALSE;
    DWORD settingValue;
    HRESULT hr;

    // Fill out g_szNpdbServer and g_szNpdbServer
    if(g_npdbConnectionString.IsEmpty())
    {
        if(!SgConfigGetNpdbInterface())
        {
            goto lDone;
        }
    }

    // Add configuration for network interfaces (NICs)
    if(!SgConfigAddInterfacesFromCommonConfig(pConfigText))
        goto lDone;


    // Add configuration for services and servers
    if(!SgConfigAddServicesFromCommonConfig(pConfigText))
        goto lDone;

    // Add configuration for notifies
    if(!SgConfigAddNotifiesFromCommonConfig(pConfigText))
        goto lDone;

    // Add configuration for event throttles
    if(!SgConfigAddEventsFromCommonConfig(pConfigText))
        goto lDone;

    // The following macro will help with the calls to SgConfigAddSettingFromCommonConfig
    // since the setting enumeration name can be derived from the setting name itself.

#define ADD_SETTING(name) \
    if(!SgConfigAddSettingFromCommonConfig(pConfigText, Setting_sg_##name, #name)) \
    goto lDone;

#define ADD_MULTISETTING(name) \
    if(!SgConfigAddMultiSettingFromCommonConfig(pConfigText, MultiSetting_sg_##name, #name)) \
    goto lDone;

    ADD_SETTING(AesMinClientVersionXbox360);
    ADD_SETTING(AesMinClientVersionPc);
    ADD_SETTING(AesProtocolEnabled);
    ADD_SETTING(ArpNegativeTimeoutInSeconds);
    ADD_SETTING(ArpPositiveTimeoutInSeconds);
    ADD_SETTING(ArpRequestRetries);
    ADD_SETTING(ArpRexmitTimeoutInSeconds);
    ADD_SETTING(BlockLimit);
    ADD_SETTING(ChalHeartbeatTimeoutInSeconds);
    ADD_SETTING(ClientHistoryLimit);
    ADD_SETTING(ClientLimit);
    ADD_SETTING(ClientPortLimit);
    ADD_SETTING(ConnectionServerPortLimit);
    ADD_SETTING(DesKeySize);
    ADD_SETTING(DhInfoCacheSize);
    ADD_SETTING(DhLimitHysteresisInMs);  // TODO: obsolete
    ADD_SETTING(DhLimitOpsPerSec);  // TODO: obsolete
    ADD_SETTING(DvdChalShiftIntervalInSeconds);
    ADD_SETTING(DnsRefreshIntervalInMinutes);
    ADD_SETTING(DnsRefreshFailureIntervalInSeconds);
    ADD_SETTING(EnableChallengeResponse);
    ADD_SETTING(EnableConnectionServices);
    ADD_SETTING(HashTableOverheadInPercent);
    ADD_SETTING(IpHdrTos);
    ADD_SETTING(IpHdrTtl);
    ADD_SETTING(KerberosApReqDeltaInMinutes);
    ADD_SETTING(KeyExBlockIntervalInSeconds);
    ADD_SETTING(KeyExDontSendIcmp);
    ADD_SETTING(KeyExIcmpVip);
    ADD_SETTING(KeyExMinRetryInMs);
    ADD_SETTING(KeyExXbToSgInitMinSize);
    ADD_SETTING(LogClientUpdates);
    ADD_SETTING(LuaStateTableSize);
    ADD_SETTING(NatDetectionDisconnectInSeconds);
    ADD_SETTING(NotifyBatchIntervalInSeconds);
    ADD_SETTING(PacketPool);
    ADD_SETTING(PacketPoolMax);
    ADD_SETTING(ProcessorQuantum);  // TODO: obsolete
    ADD_SETTING(SgToXbChallengePeriodInSeconds);
    ADD_SETTING(SgToXbKeyExTimeoutInSeconds);
    ADD_SETTING(SgToXbPulseTimeoutInSeconds);
    ADD_SETTING(SgToXbScanFrequencyInSeconds);
    ADD_SETTING(SgToXbTimeoutInSeconds);
    ADD_SETTING(ShareDatacenterNicWithWindows);
    ADD_SETTING(ShareInternetNicWithWindows);
    ADD_SETTING(SpiFlow);  // TODO: obsolete
    ADD_SETTING(SpiFlowDataLimit);
    ADD_SETTING(SpiWatchdogTimeoutInSeconds);
    ADD_SETTING(StatsConfidenceLimitInClients);
    ADD_SETTING(StatsDisconnectSigmaInterval);
    ADD_SETTING(StatsHistoryInMs);
    ADD_SETTING(StatsPenaltyTimeInSeconds);
    ADD_SETTING(StatsRefreshFrequencyInSeconds);
    ADD_SETTING(StatsReportIntervalInSeconds);
    ADD_SETTING(StatsWarningSigmaInterval);
    ADD_SETTING(XbToSgChallengeAckInSeconds);
    ADD_SETTING(XbToSgChallengeTimeoutInSeconds);
    ADD_SETTING(XbToSgPulseTimeoutInSeconds);
    ADD_SETTING(XbToSgTimeoutInSeconds);
    ADD_SETTING(XbToSgReplayWindow);

    ADD_MULTISETTING(NullMachineId);

#undef ADD_SETTING
#undef ADD_MULTISETTING

    ret = TRUE;

lDone:

    return ret;
}

// ---------------------------------------------------------------------------------------
// SgConfigAddSettingFromCommonConfig
// Add config setting from common config to pConfigText
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddSettingFromCommonConfig(
    CStr* pConfigText,
    CComBSTR& setting,
    LPCSTR pszSettingName
)
{
    CComBSTR settingValue;

    HRESULT hr = g_pConfig->GetSetting(setting, &settingValue);

    if(FAILED(hr))
    {
        SgEventSz(CONFIG_ERROR, "Failed to retrieve setting sg_%s. HR = 0x%08x", pszSettingName, hr);
        return FALSE;
    }

    pConfigText->Format("%-40s %S\r\n", pszSettingName, (LPCWSTR)settingValue);

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgConfigAddMultiSettingFromCommonConfig
// Add config multi setting from common config to pConfigText
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddMultiSettingFromCommonConfig(
    CStr* pConfigText,
    CComBSTR& setting,
    LPCSTR pszSettingName
)
{
    HRESULT hr;
    SAFEARRAY* pSafeArray = NULL;
    CComSafeArray<BSTR> saValues;
    BSTR bstrValue;

    hr = g_pConfig->GetMultiSetting(setting, &pSafeArray);
    if (FAILED(hr))
    {
        SgEventSz(CONFIG_ERROR, "Failed to retrieve multisetting sg_%s. HR = 0x%08x", pszSettingName, hr);
        return FALSE;
    }

    hr = saValues.Attach(pSafeArray);
    if (FAILED(hr))
    {
        SgEventSz(CONFIG_ERROR, "Failed to attach SafeArray for multisetting sg_%s. HR = 0x%08x", pszSettingName, hr);
        return FALSE;
    }
    pSafeArray = NULL;

    ULONG count = saValues.GetCount();
    for (ULONG i = 0; i < count; i++)
    {
        bstrValue = saValues.GetAt((LONG)i);
        pConfigText->Format("%-40s %S\r\n", pszSettingName, (LPCWSTR)bstrValue);
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgConfigGetNpdbInterface
// Fills out g_szNpdbConnectionString with the npdb connection string.
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigGetNpdbInterface()
{
    BOOL ok = FALSE;
    CComBSTR bstrConnectionString;
    HRESULT hr;

    // Get connection string from config
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->get_NpdbConnectionString(&bstrConnectionString));

    // Copy information to global
    g_npdbConnectionString.CopyFrom(bstrConnectionString);
    IF_FAILED_GOTO_LDONE(!g_npdbConnectionString.HasFailedOrTruncated());

    ok = TRUE;

lDone:

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgConfigAddInterfacesFromCommonConfig
// Appends configuration data to pConfigText for both the datacenter and the internet
// interfaces from common config
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddInterfacesFromCommonConfig(
    CStr* pConfigText
)
{
    BOOL ret = FALSE;
    CComPtr<XblConfig::IInterfaceInfo> pInternalInterface = NULL;
    CComPtr<XblConfig::IInterfaceInfo> pExternalInterface = NULL;
    DWORD ipAdmin;
    DWORD ipBegin;
    DWORD ipEnd;
    DWORD ipMask;
    LONG portBegin;
    LONG portEnd;
    DWORD ipGateway;
    CComBSTR bstrServer;
    CComBSTR bstrMac;
    HRESULT hr;

    // Get the current server name
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->get_Server(&bstrServer));

    // Configure external interface (internet)
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->GetInterface(bstrServer,
                                                       Interface_sgsvc,
                                                       &pExternalInterface));

    IF_FAILED_GOTO_LDONE_WITH_HR(pExternalInterface->get_IPAddressDword(&ipAdmin));
    IF_FAILED_GOTO_LDONE_WITH_HR(pExternalInterface->get_IPNetMaskDword(&ipMask));
    IF_FAILED_GOTO_LDONE_WITH_HR(pExternalInterface->get_IPDefaultGatewayDword(&ipGateway));
    IF_FAILED_GOTO_LDONE_WITH_HR(pExternalInterface->get_Mac(&bstrMac));

    pConfigText->Format(
            "\r\nNetworkInterface\r\n"
            "{\r\n"
            "    Type                   Internet\r\n"
            "    Ip                     %s\r\n"
            "    IpMask                 %s\r\n"
            "    IpGateway              %s\r\n",
            CStrUtil().FormatIpH(ipAdmin),
            CStrUtil().FormatIpH(ipMask),
            CStrUtil().FormatIpH(ipGateway));


    if(bstrMac != NULL &&
       bstrMac[0] != L'\0')
    {
        pConfigText->Format(
            "    Nic                    %S\r\n",
            (LPCWSTR)bstrMac);
        
        // Free the memory from the previous use of the bstrMac
        bstrMac.Empty();
    }

    pConfigText->CopyFrom(
            "}\r\n");

    // Configure internal interface (datacenter)
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->GetInterface(bstrServer,
                                                       Interface_sgsvc_int,
                                                       &pInternalInterface));

    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_IPAddressDword(&ipAdmin));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_IPNetMaskDword(&ipMask));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_IPDefaultGatewayDword(&ipGateway));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_Mac(&bstrMac));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_SgIpAddressBeginDword(&ipBegin));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_SgIpAddressEndDword(&ipEnd));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_SgPortBegin(&portBegin));
    IF_FAILED_GOTO_LDONE_WITH_HR(pInternalInterface->get_SgPortEnd(&portEnd));

    pConfigText->Format(
            "\r\nNetworkInterface\r\n"
            "{\r\n"
            "    Type                   Datacenter\r\n"
            "    Id                     1\r\n"
            "    IpAdmin                %s\r\n"
            "    IpMask                 %s\r\n"
            "    IpGateway              %s\r\n"
            "    Ip                     %s\r\n",
            CStrUtil().FormatIpH(ipAdmin),
            CStrUtil().FormatIpH(ipMask),
            CStrUtil().FormatIpH(ipGateway),
            CStrUtil().FormatIpH(ipBegin));

    if(ipEnd != 0)
    {
        pConfigText->Format(
            "    IpEnd                  %s\r\n",
            CStrUtil().FormatIpH(ipEnd));
    }

    if(portBegin != 0)
    {
        pConfigText->Format(
            "    PortBegin              %u\r\n",
            portBegin);
    }

    if(portEnd != 0)
    {
        pConfigText->Format(
            "    PortEnd                %u\r\n",
            portEnd);
    }

    if(bstrMac != NULL &&
       bstrMac[0] != L'\0')
    {
        pConfigText->Format(
            "    Nic                    %S\r\n",
            (LPCWSTR)bstrMac);
    }

    pConfigText->CopyFrom(
            "}\r\n");

    ret = TRUE;

lDone:

    return ret;
}

// ---------------------------------------------------------------------------------------
// SgConfigAddNotifiesFromCommonConfig
// Appends configuration data to pConfigText for notifications from common config
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddNotifiesFromCommonConfig(
    CStr* pConfigText
)
{
    BOOL                                      bHealthCheckFound = FALSE;
    BOOL                                      ret = FALSE;
    CComBSTR                                  bstrServiceHost;
    CComBSTR                                  bstrProtocol;
    CComBSTR                                  bstrXboxStateChangeNotificationUrl;
    CComBSTR                                  bstrXboxStateChangeNotification( L"xbox_state_change_notification_url" );
    CComBSTR                                  bstrTitleChangeNotificationUrl;
    CComBSTR                                  bstrTitleChangeNotification( L"title_change_notification_url" );
    CComBSTR                                  bstrDeadXboxNotificationUrl;
    CComBSTR                                  bstrDeadXboxNotification( L"dead_xbox_notification_url" );
    CComBSTR                                  bstrUserChangeNotificationUrl;
    CComBSTR                                  bstrUserChangeNotification( L"user_change_notification_url" );
    CComBSTR                                  bstrSpiUpdateNotificationUrl;
    CComBSTR                                  bstrSpiUpdateNotification( L"spi_update_notification_url" );
    CComBSTR                                  bstrHealthCheckUrl;
    CComPtr<XblConfig::IVirtualInterfaceInfo> pVinterface = NULL;
    CComPtr<XblConfig::IVirtualInterfaceInfo> pVinterface2 = NULL;
    CComSafeArray<IUnknown*>                  vinterfaces;
    HRESULT                                   hr;
    LONG                                      siteId;
    LONG                                      serviceId;
    LONG                                      serviceHealthId;
    LONG                                      port;
    LONG                                      servicePort;
    LONG                                      serviceHealthPort;
    SAFEARRAY*                                pSafeArray = NULL;

    // Get the list of virtual interfaces from common config. Interfaces that have a
    // non-zero internet port, specify an SG service.
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->get_SiteId(&siteId));
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->GetVirtualInterfaceInfoBySite_2(siteId, &pSafeArray));
    IF_FAILED_GOTO_LDONE_WITH_HR(vinterfaces.Attach(pSafeArray));
    pSafeArray = NULL;

    ULONG serviceCount = vinterfaces.GetCount();

    for (ULONG i=0; i < serviceCount; i++)
    {
        pVinterface = vinterfaces.GetAt((LONG)i);

        // If there are no notifications present, then we don't care
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->GetNotificationUrl(bstrXboxStateChangeNotification, &bstrXboxStateChangeNotificationUrl));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->GetNotificationUrl(bstrTitleChangeNotification,     &bstrTitleChangeNotificationUrl));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->GetNotificationUrl(bstrDeadXboxNotification,        &bstrDeadXboxNotificationUrl));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->GetNotificationUrl(bstrUserChangeNotification,      &bstrUserChangeNotificationUrl));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->GetNotificationUrl(bstrSpiUpdateNotification,       &bstrSpiUpdateNotificationUrl));
        if ( (bstrXboxStateChangeNotificationUrl == NULL || bstrXboxStateChangeNotificationUrl[0] == L'\0') &&
             (bstrTitleChangeNotificationUrl     == NULL || bstrTitleChangeNotificationUrl[0]     == L'\0') &&
             (bstrDeadXboxNotificationUrl        == NULL || bstrDeadXboxNotificationUrl[0]        == L'\0') &&
             (bstrUserChangeNotificationUrl      == NULL || bstrUserChangeNotificationUrl[0]      == L'\0') &&
             (bstrSpiUpdateNotificationUrl       == NULL || bstrSpiUpdateNotificationUrl[0]       == L'\0') )
        {
            // Clean up the BSTRs that we looked at
            bstrXboxStateChangeNotificationUrl.Empty();
            bstrTitleChangeNotificationUrl.Empty();
            bstrDeadXboxNotificationUrl.Empty();
            bstrUserChangeNotificationUrl.Empty();
            bstrSpiUpdateNotificationUrl.Empty();
            continue;
        }

        // Get the remaining data
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_InternetPort(&port));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_IPAddressString(&bstrServiceHost));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_Port(&servicePort));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_Protocol(&bstrProtocol));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_ServiceId(&serviceId));

        pConfigText->Format(
            "\r\nNotifyServer \r\n"
            "{ \r\n"
            );
        if (0 != port) 
        {
            pConfigText->Format(
                "    Id                     %u \r\n",
                port
                );
        }

        pConfigText->Format(
            "    Protocol               %S \r\n",
            (LPCWSTR) bstrProtocol
            );

        if(bstrXboxStateChangeNotificationUrl != NULL &&
           bstrXboxStateChangeNotificationUrl[0] != L'\0')
        {
            pConfigText->Format(
                "    NotifyUpdateUrl        %S \r\n",
                (LPCWSTR)bstrXboxStateChangeNotificationUrl
                );
        }

        if(bstrTitleChangeNotificationUrl != NULL &&
           bstrTitleChangeNotificationUrl[0] != L'\0')
        {
            pConfigText->Format(
                "    NotifyTitleChangeUrl   %S \r\n",
                (LPCWSTR)bstrTitleChangeNotificationUrl
                );
        }

        if(bstrDeadXboxNotificationUrl != NULL &&
           bstrDeadXboxNotificationUrl[0] != L'\0')
        {
            pConfigText->Format(
                "    NotifyDeleteUrl        %S \r\n",
                (LPCWSTR)bstrDeadXboxNotificationUrl
                );
        }

        if(bstrUserChangeNotificationUrl != NULL &&
           bstrUserChangeNotificationUrl[0] != L'\0') 
        {
            pConfigText->Format(
                "    NotifyUserChangeUrl    %S \r\n",
                (LPCWSTR)bstrUserChangeNotificationUrl
                );
        }

        if(bstrSpiUpdateNotificationUrl != NULL &&
           bstrSpiUpdateNotificationUrl[0] != L'\0') 
        {
            pConfigText->Format(
                "    NotifySpiUpdateUrl     %S \r\n",
                (LPCWSTR)bstrSpiUpdateNotificationUrl
                );
        }

        // The health interface might be on the current interface
        // Alternatively, find the _INT interface
        hr = pVinterface->get_HealthCheckUrl(&bstrHealthCheckUrl);
        if (SUCCEEDED(hr) &&
            bstrHealthCheckUrl != NULL &&
            bstrHealthCheckUrl[0] != L'\0') 
        {
            bHealthCheckFound = TRUE;
            pConfigText->Format(
                "    HealthCheckUrl         %S \r\n",
                (LPCWSTR)bstrHealthCheckUrl
                );

            // We already know what the port is
            serviceHealthPort = servicePort;
        }
        else
        {
            // Find the corresponding _INT interface.
            for (ULONG j = 0; j < serviceCount; ++j) 
            {
                pVinterface2 = vinterfaces.GetAt((LONG)j);

                // The health check interface is on a port that isn't internet facing
                IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface2->get_InternetPort(&port));
                if (0 != port)
                {
                    // This is not an internal interface
                    continue;
                }

                // The health check interface shares the same service id
                hr = pVinterface2->get_ServiceId(&serviceHealthId);
                if (FAILED(hr) || serviceHealthId != serviceId) 
                {
                    continue;
                }

                // The health check exists as its own get routine
                hr = pVinterface2->get_HealthCheckUrl(&bstrHealthCheckUrl);
                if (FAILED(hr) ||
                    bstrHealthCheckUrl == NULL ||
                    bstrHealthCheckUrl[0] == L'\0') 
                {
                    continue;
                }

                // The health check has its own port
                hr = pVinterface2->get_Port(&serviceHealthPort);
                if (FAILED(hr)) 
                {
                    continue;
                }

                bHealthCheckFound = TRUE;
                pConfigText->Format(
                    "    HealthCheckUrl         %S \r\n",
                    (LPCWSTR)bstrHealthCheckUrl);
                break;
            }
        }
        IF_FAILED_GOTO_LDONE((TRUE == bHealthCheckFound));

        in_addr inaUnused = { };
        USHORT sUnused = 0;
        LONG err = RtlIpv4StringToAddressExW( bstrServiceHost, TRUE, &inaUnused, &sUnused );

        pConfigText->Format(
            "    Address \r\n"
            "    { \r\n"
            "        InterfaceId        1  \r\n"
            "        %s            %S \r\n"
            "        Port               %u \r\n"
            "        HealthPort         %u \r\n"
            "    } \r\n"
            "} \r\n",
            err == NO_ERROR ? "Ip     " : "DnsName",
            (LPCWSTR)bstrServiceHost,
            servicePort,
            serviceHealthPort
            );

        // Cleanup BSTR
        bstrServiceHost.Empty();
        bstrProtocol.Empty();
        bstrHealthCheckUrl.Empty();
        bstrXboxStateChangeNotificationUrl.Empty();
        bstrTitleChangeNotificationUrl.Empty();
        bstrDeadXboxNotificationUrl.Empty();
        bstrUserChangeNotificationUrl.Empty();
        bstrSpiUpdateNotificationUrl.Empty();
    }

    ret = TRUE;

lDone:

    return ret;
}

// ---------------------------------------------------------------------------------------
// SgConfigAddServicesFromCommonConfig
// Appends configuration data to pConfigText for services and servers from common config
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddServicesFromCommonConfig(
    CStr* pConfigText
)
{
    BOOL                                      ret = FALSE;
    CComBSTR                                  bstrServiceName;
    CComBSTR                                  bstrServiceHost;
    CComBSTR                                  bstrProtocol;
    CComPtr<XblConfig::IVirtualInterfaceInfo> pVinterface = NULL;
    CComSafeArray<IUnknown*>                  vinterfaces;
    HRESULT                                   hr;
    LONG                                      siteId;
    LONG                                      serviceId;
    LONG                                      port;
    LONG                                      portEnd;
    LONG                                      servicePort;
    SAFEARRAY*                                pSafeArray = NULL;

    // Get the list of virtual interfaces from common config. Interfaces that have a
    // non-zero internet port, specify an SG service.

    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->get_SiteId(&siteId));
    IF_FAILED_GOTO_LDONE_WITH_HR(g_pConfig->GetVirtualInterfaceInfoBySite_2(siteId, &pSafeArray));
    IF_FAILED_GOTO_LDONE_WITH_HR(vinterfaces.Attach(pSafeArray));
    pSafeArray = NULL;

    ULONG serviceCount = vinterfaces.GetCount();

    for (ULONG i=0; i < serviceCount; i++)
    {
        pVinterface = vinterfaces.GetAt((LONG)i);

        // Get the internet port first. It will determine if this interface is an SG
        // service or not.

        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_InternetPort(&port));
        if (0 == port)
        {
            // This is not an SG service. Skip it.
            continue;
        }

        // Get the remaining data
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_InternetPortEnd(&portEnd));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_ServiceId(&serviceId));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_ServiceName(&bstrServiceName));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_Protocol(&bstrProtocol));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_IPAddressString(&bstrServiceHost));
        IF_FAILED_GOTO_LDONE_WITH_HR(pVinterface->get_Port(&servicePort));

        IF_FAILED_GOTO_LDONE(bstrServiceName != NULL);
        IF_FAILED_GOTO_LDONE(bstrProtocol != NULL);

        in_addr inaUnused = { };
        USHORT sUnused = 0;
        LONG err = RtlIpv4StringToAddressExW( bstrServiceHost, TRUE, &inaUnused, &sUnused );

        // Format notification Url settings
        pConfigText->Format(
            "\r\nService \r\n"
            "{ \r\n"
            "    Id                     %u \r\n"
            "    Name                   %S \r\n"
            "} \r\n"
            "\r\n"
            "Server \r\n"
            "{ \r\n"
            "    Id                     %u \r\n",
            serviceId,
            (LPCWSTR) bstrServiceName,
            port
            );
        if(portEnd != 0)
        {
            pConfigText->Format(
                "    IdEnd                  %u \r\n",
                portEnd
                );
        }

        pConfigText->Format(
            "    Service                %S \r\n"
            "    Protocol               %S \r\n"
            "    Address \r\n"
            "    { \r\n"
            "        InterfaceId        1  \r\n"
            "        %s            %S \r\n"
            "        Port               %u \r\n"
            "    } \r\n"
            "} \r\n",
            (LPCWSTR) bstrServiceName,
            (LPCWSTR) bstrProtocol,
            (err == NO_ERROR) ? "Ip     " : "DnsName",
            (LPCWSTR)bstrServiceHost,
            servicePort
            );

        // Cleanup BSTR
        bstrServiceName.Empty();
        bstrServiceHost.Empty();
        bstrProtocol.Empty();
    }

    ret = TRUE;

lDone:

    return ret;
}

// ---------------------------------------------------------------------------------------
// SgConfigAddEventsFromCommonConfig
// Appends configuration data to pConfigText for NT events (throttles) from common config
// ---------------------------------------------------------------------------------------
static
BOOL SgConfigAddEventsFromCommonConfig(
    CStr* pConfigText
)
{
    BOOL ret = FALSE;
    HRESULT hr;
    SAFEARRAY* pSafeArray = NULL;
    CComSafeArray<BSTR> saEvents;
    BSTR bstrValue;

    IF_FAILED_GOTO_LDONE_WITH_HR(
        g_pConfig->GetMultiSetting(MultiSetting_xmgmt_eventThrottles, &pSafeArray));

    IF_FAILED_GOTO_LDONE_WITH_HR(saEvents.Attach(pSafeArray));
    pSafeArray = NULL;

    ULONG eventCount = saEvents.GetCount();
    for (ULONG i = 0; i < eventCount; i++)
    {
        bstrValue = saEvents.GetAt((LONG)i);

        CXomNameValuePairList targetParams;
        targetParams.Parse(bstrValue);

        // Format is:
        // id=58048;freq=sometimes;alertrate=1;intervalsecs=300;intervalhns=1
        //
        // Format needs to be:
        // Event { Id 58048 Freq sometimes AlertRate 1 IntervalSecs 300 IntervalHns 1 }
        //
        // All other fields like TrackPerIp, RateUnits, and Text are ignored. If Text is 
        // set, we will ignore the event throttle.
        
        LPCSTR pId = targetParams.GetValueByName("id");
        if (pId == NULL)
            continue;
        LPCSTR pText = targetParams.GetValueByName("text");
        if (pText != NULL)
        {
            // I'd like to trace here, but we don't have tracing enabled since (since 
            // we're in the middle of parsing the config). 
            continue;
        }
        LPCSTR pFreq = targetParams.GetValueByName("freq");
        LPCSTR pAlertRate = targetParams.GetValueByName("alertrate");
        LPCSTR pIntervalSecs = targetParams.GetValueByName("intervalsecs");
        LPCSTR pIntervalHns = targetParams.GetValueByName("intervalhns");

        pConfigText->Format("Event { Id %s", pId);
        if (pFreq != NULL)
            pConfigText->Format(" Freq %s", pFreq);
        if (pAlertRate != NULL)
            pConfigText->Format(" AlertRate %s", pAlertRate);
        if (pIntervalSecs != NULL)
            pConfigText->Format(" IntervalSecs %s", pIntervalSecs);
        if (pIntervalHns != NULL)
            pConfigText->Format(" IntervalHns %s", pIntervalHns);
        pConfigText->CopyFrom(" }\r\n");
    }

    ret = TRUE;

lDone:

    return ret;
}


// ---------------------------------------------------------------------------------------
// SgConfigReloadTimer - the callback from the timer to perform the actual SgConfig work
// ---------------------------------------------------------------------------------------
VOID SgConfigReloadTimer(CTimer*)
{
    InterlockedExchange(&g_bConfigReloadScheduled, 0);
    SgConfig();
}

// ---------------------------------------------------------------------------------------
// SgConfigScheduleReload - entry point to initiate an SgConfig call. Doesn't apply for
// the initial SgConfig at startup time, but applies to all subsequent reloads.
// ---------------------------------------------------------------------------------------
VOID SgConfigScheduleReload(DWORD dwDelayInMs)
{
    // Check if reload already scheduled, but not running yet. If so, there's nothing for
    // us to do. Set to TRUE (1) only if FALSE (0).
    LONG bConfigReloadAlreadyScheduled = InterlockedCompareExchange(&g_bConfigReloadScheduled, 1, 0);

    if (bConfigReloadAlreadyScheduled == 1)
    {
        // A reload was already scheduled. Do nothing.
        return;
    }

    // Schedule a reload on the long timer.
    DWORD dwDelayInTicks = (dwDelayInMs * TICKS_PER_SECOND) / 1000;
    SgTimerSet(&g_configReloadTimer, SgConfigReloadTimer, SgTimerTick() + dwDelayInTicks, TRUE);
}


HRESULT CSGConfigListener::Init()
{
    HRESULT hr = S_OK;

    hr = g_pConfig->putref_ConfigListener( this );
    if (FAILED(hr))
    {
        SgEventSz(
            CONFIG_ERROR,
            "Failed to attach to the common config object. Verify that "
            "commonconfig.dll is installed correctly. hr = 0x%08x",
            hr
            );
        return hr;
    }

    return hr;
}

void CSGConfigListener::Term()
{
    if (g_pConfig)
    {
        g_pConfig->putref_ConfigListener(NULL);
    }
}

// ---------------------------------------------------------------------------------------
// SettingChange - this is called by CommonConfig through a convoluted COM path by way of
// ConfigInterop. In a nutshell, Config.cs calls this, using one of its threads. Do not do
// any blocking work here, as CommonConfig uses a global static lock, and you are holding
// it in this function (as a writelock, naturally).
// ---------------------------------------------------------------------------------------
HRESULT CSGConfigListener::SettingChange( struct ISettingChangeEventArgs * eventArgs )
{
    CComBSTR SettingChange;
    HRESULT  hr = S_OK;

    if (eventArgs == NULL)
    {
        return E_POINTER;
    }

    hr = eventArgs->get_Setting( &SettingChange );
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // See if a setting that we care about has changed
    // IMPORTANT: if you add a new setting that you want to be reloaded dynamically, you
    // must add it to this list.
    //
    if (SettingChange == Setting_sg_AesMinClientVersionXbox360 ||
        SettingChange == Setting_sg_AesMinClientVersionPc ||
        SettingChange == Setting_sg_AesProtocolEnabled ||
        SettingChange == Setting_sg_ArpPositiveTimeoutInSeconds ||
        SettingChange == Setting_sg_ArpRequestRetries ||
        SettingChange == Setting_sg_ArpRexmitTimeoutInSeconds ||
        SettingChange == Setting_sg_ChalHeartbeatTimeoutInSeconds ||
        SettingChange == Setting_sg_DesKeySize ||
        SettingChange == Setting_sg_DhInfoCacheSize ||
        SettingChange == Setting_sg_DnsRefreshIntervalInMinutes ||
        SettingChange == Setting_sg_DnsRefreshFailureIntervalInSeconds ||
        SettingChange == Setting_sg_DvdChalShiftIntervalInSeconds ||
        SettingChange == Setting_sg_EnableChallengeResponse ||
        SettingChange == Setting_sg_HashTableOverheadInPercent ||
        SettingChange == Setting_sg_IpHdrTos ||
        SettingChange == Setting_sg_IpHdrTtl ||
        SettingChange == Setting_sg_KerberosApReqDeltaInMinutes ||
        SettingChange == Setting_sg_KeyExBlockIntervalInSeconds ||
        SettingChange == Setting_sg_KeyExDontSendIcmp ||
        SettingChange == Setting_sg_KeyExIcmpVip ||
        SettingChange == Setting_sg_KeyExMinRetryInMs ||
        SettingChange == Setting_sg_KeyExXbToSgInitMinSize ||
        SettingChange == Setting_sg_LuaStateTableSize ||
        SettingChange == Setting_sg_NotifyBatchIntervalInSeconds ||
        SettingChange == Setting_sg_SgToXbChallengePeriodInSeconds ||
        SettingChange == Setting_sg_SgToXbKeyExTimeoutInSeconds ||
        SettingChange == Setting_sg_SgToXbPulseTimeoutInSeconds ||
        SettingChange == Setting_sg_SgToXbScanFrequencyInSeconds ||
        SettingChange == Setting_sg_SgToXbTimeoutInSeconds ||
        SettingChange == Setting_sg_SpiFlowDataLimit ||
        SettingChange == Setting_sg_SpiWatchdogTimeoutInSeconds ||
        SettingChange == Setting_sg_StatsConfidenceLimitInClients ||
        SettingChange == Setting_sg_StatsDisconnectSigmaInterval ||
        SettingChange == Setting_sg_StatsHistoryInMs ||
        SettingChange == Setting_sg_StatsPenaltyTimeInSeconds ||
        SettingChange == Setting_sg_StatsRefreshFrequencyInSeconds ||
        SettingChange == Setting_sg_StatsReportIntervalInSeconds ||
        SettingChange == Setting_sg_StatsWarningSigmaInterval ||
        SettingChange == Setting_sg_XbToSgChallengeAckInSeconds ||
        SettingChange == Setting_sg_XbToSgChallengeTimeoutInSeconds ||
        SettingChange == Setting_sg_XbToSgPulseTimeoutInSeconds ||
        SettingChange == Setting_sg_XbToSgTimeoutInSeconds ||
        SettingChange == Setting_sg_XbToSgReplayWindow ||
        SettingChange == Setting_sg_NatDetectionDisconnectInSeconds ||
        SettingChange == Setting_sg_LogClientUpdates)
    {
        // Wait 5 seconds, to account for batching. Suppose 2 settings are changed. When
        // the SG is notified of this ~ 1 minute later, this function will be called
        // twice, back-to-back. That's why we wait a bit to do the actual reload.
        SgConfigScheduleReload(SG_AUTORELOAD_DELAY_MS);
    }

    //
    // Done
    //
    return hr;
}

// ---------------------------------------------------------------------------------------
// MultiSettingChange - called when a multisetting changes. Also see SettingChange 
// comments.
// ---------------------------------------------------------------------------------------
HRESULT CSGConfigListener::MultiSettingChange( struct IMultiSettingChangeEventArgs * eventArgs )
{
    CComBSTR SettingChange;
    HRESULT  hr = S_OK;

    if (eventArgs == NULL)
    {
        return E_POINTER;
    }

    hr = eventArgs->get_MultiSetting( &SettingChange );
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // See if a setting that we care about has changed
    // IMPORTANT: if you add a new setting that you want to be reloaded dynamically, you
    // must add it to this list.
    //
    if (SettingChange == MultiSetting_xmgmt_eventThrottles ||
        SettingChange == MultiSetting_sg_NullMachineId)
    {
        // Wait 5 seconds, to account for batching. Suppose 2 settings are changed. When
        // the SG is notified of this ~ 1 minute later, this function will be called
        // twice, back-to-back. That's why we wait a bit to do the actual reload.
        SgConfigScheduleReload(SG_AUTORELOAD_DELAY_MS);
    }

    return hr;
}


// ---------------------------------------------------------------------------------------
// VirtualInterfaceChange - called when a virtual interface changes. Also see 
// SettingChange comments.
// ---------------------------------------------------------------------------------------
HRESULT CSGConfigListener::VirtualInterfaceChange( struct IVirtualInterfaceChangeEventArgs * eventArgs )
{
    // We just always schedule a reload for virtual interface changes, don't care which 
    // one changed.
    SgConfigScheduleReload(SG_AUTORELOAD_DELAY_MS);

    return S_OK;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgcrypt.cpp ===
// ---------------------------------------------------------------------------------------
// sgcrypt.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"
#include <crypto\rc4.h>
#include <crypto\sha.h>
#include <crypto\md5.h>
#include <crypto\modes.h>
#include <crypto\des.h>
#include <crypto\tripldes.h>
#include <crypto\aes.h>
#include <crypto\benaloh.h>

// ---------------------------------------------------------------------------------------
// Crypto Constants
// ---------------------------------------------------------------------------------------

extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1] =
{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x20, 0x36, 0x3A, 0xA6, 0xE9, 0x42, 0x4C, 0xF4,
    0xC6, 0x7E, 0x5E, 0x62, 0x76, 0xB5, 0x85, 0xE4,
    0x45, 0xC2, 0x51, 0x6D, 0x6D, 0x35, 0xE1, 0x4F,
    0x37, 0x14, 0x5F, 0xF2, 0x6D, 0x0A, 0x2B, 0x30,
    0x1B, 0x43, 0x3A, 0xCD, 0xB3, 0x19, 0x95, 0xEF,
    0xDD, 0x04, 0x34, 0x8E, 0x79, 0x08, 0x4A, 0x51,
    0x22, 0x9B, 0x13, 0x3B, 0xA6, 0xBE, 0x0B, 0x02,
    0x74, 0xCC, 0x67, 0x8A, 0x08, 0x4E, 0x02, 0x29,
    0xD1, 0x1C, 0xDC, 0x80, 0x8B, 0x62, 0xC6, 0xC4,
    0x34, 0xC2, 0x68, 0x21, 0xA2, 0xDA, 0x0F, 0xC9,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1] =
{
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// ---------------------------------------------------------------------------------------
// SHA
// ---------------------------------------------------------------------------------------

void XcSHAInit(IN PUCHAR pbSHAContext)
{
    A_SHAInit((A_SHA_CTX*)pbSHAContext);
}
   
void XcSHAUpdate(IN PUCHAR pbSHAContext, IN PUCHAR pbInput, IN ULONG dwInputLength)
{
    A_SHAUpdate((A_SHA_CTX*)pbSHAContext, pbInput, dwInputLength);
}
   
void XcSHAFinal(IN PUCHAR pbSHAContext, IN PUCHAR pbDigest)
{
    A_SHAFinal((A_SHA_CTX*)pbSHAContext, pbDigest);
}
   
void XcSHA(BYTE * pbSha, UINT cbSha, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3)
{
    BYTE abShaCtx[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE abSha[XC_SERVICE_DIGEST_SIZE];

    A_SHAInit((A_SHA_CTX *)abShaCtx);

    if (cb1 > 0)
    {
        A_SHAUpdate((A_SHA_CTX *)abShaCtx, pb1, cb1);
    }

    if (cb2 > 0)
    {
        A_SHAUpdate((A_SHA_CTX *)abShaCtx, pb2, cb2);
    }

    if (cb3 > 0)
    {
        A_SHAUpdate((A_SHA_CTX *)abShaCtx, pb3, cb3);
    }

    A_SHAFinal((A_SHA_CTX *)abShaCtx, abSha);

    Assert(cbSha <= sizeof(abSha));
    cbSha = min(cbSha, sizeof(abSha));
    memcpy(pbSha, abSha, cbSha);
}

// ---------------------------------------------------------------------------------------
// RC4
// ---------------------------------------------------------------------------------------

void XcRC4Key(IN PUCHAR pbKeyStruct, IN ULONG dwKeyLength, IN PUCHAR pbKey)
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void XcRC4Crypt(IN PUCHAR pbKeyStruct, IN ULONG dwInputLength, IN PUCHAR pbInput)
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}

// ---------------------------------------------------------------------------------------
// HMAC
// ---------------------------------------------------------------------------------------

#define HMAC_K_PADSIZE              64

void XcHMAC4(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbData, UINT cbData,
             BYTE * pbData2, UINT cbData2, BYTE * pbData3, UINT cbData3, BYTE * pbData4, UINT cbData4,
             BYTE * HmacData)
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    if (cbData4 != 0)
        A_SHAUpdate(&shaHash, pbData4, cbData4);

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

void XcHMACMakeKeyTable(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbKeyTable)
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    memcpy(pbKeyTable, &shaHash, sizeof(A_SHA_CTX));

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kopad, HMAC_K_PADSIZE);
    memcpy(pbKeyTable + sizeof(A_SHA_CTX), &shaHash, sizeof(A_SHA_CTX));
}

void XcHMACWithKeyTable(BYTE * pbKeyTable, BYTE * pbData, UINT cbData,
             BYTE * pbData2, UINT cbData2, BYTE * pbData3, UINT cbData3, BYTE * pbData4, UINT cbData4,
             BYTE * HmacData)
{
    A_SHA_CTX shaHash;

    memcpy(&shaHash, pbKeyTable, sizeof(A_SHA_CTX));

    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    if (cbData4 != 0)
        A_SHAUpdate(&shaHash, pbData4, cbData4);

    A_SHAFinal(&shaHash,HmacData);

    memcpy(&shaHash, pbKeyTable + sizeof(A_SHA_CTX), sizeof(A_SHA_CTX));

    A_SHAUpdate(&shaHash, HmacData, A_SHA_DIGEST_LEN);

    A_SHAFinal(&shaHash, HmacData);
}

// ---------------------------------------------------------------------------------------
// ModExp
// compute A = B ^ C mod D, N = len of params in DWORDs
// ---------------------------------------------------------------------------------------

ULONG XcModExp(IN LPDWORD pA, IN LPDWORD pB, IN LPDWORD pC, IN LPDWORD pD, IN ULONG dwN)
{
    return BenalohModExp(pA, pB, pC, pD, dwN);
}
   
// ---------------------------------------------------------------------------------------
// DES and AES crypt routines
// ---------------------------------------------------------------------------------------

void XcDESKeyParity(IN PUCHAR pbKey, IN ULONG dwKeyLength)
{
    desparityonkey(pbKey, dwKeyLength);
}
   
void XcKeyTable(IN ULONG dwCipher, OUT PUCHAR pbKeyTable, IN PUCHAR pbKey)
{
    if (dwCipher == XC_SERVICE_DES_CIPHER)
    {
        deskey((DESTable*)pbKeyTable, pbKey);
    }
    else if (dwCipher == XC_SERVICE_AES_CIPHER)
    {
        aeskey((AESTable*)pbKeyTable, pbKey, XC_SERVICE_AES_ROUNDS);
    }
    else if (dwCipher == XC_SERVICE_NULL_CIPHER)
    {
        // nothing 
    }
    else
    {
        // Assume XC_SERVICE_DES3_CIPHER:
        tripledes3key((PDES3TABLE)pbKeyTable, pbKey);
    }
}
   
void XcBlockCrypt(IN ULONG dwCipher, IN PUCHAR pbOutput, IN PUCHAR pbInput, IN PUCHAR pbKeyTable, IN ULONG dwOp)
{
    if (dwCipher == XC_SERVICE_NULL_CIPHER)
    {
        return;
    }

    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = 
        (dwCipher == XC_SERVICE_DES_CIPHER) ? des : 
        (dwCipher == XC_SERVICE_AES_CIPHER) ? aes :
        tripledes;
    (*pCipher)( pbOutput, pbInput, pbKeyTable, dwOp );
}
   
void XcBlockCryptCBC(IN ULONG dwCipher, IN ULONG dwInputLength, IN PUCHAR pbOutput, IN PUCHAR pbInput,
                     IN PUCHAR pbKeyTable, IN ULONG dwOp, IN PUCHAR pbFeedback)
{
    if (dwCipher == XC_SERVICE_NULL_CIPHER)
    {
        return;
    }

    BYTE *pbInputEnd = pbInput + dwInputLength;
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = 
        (dwCipher == XC_SERVICE_DES_CIPHER) ? des : 
        (dwCipher == XC_SERVICE_AES_CIPHER) ? aes :
        tripledes;
    UINT uiBlockLen = (dwCipher == XC_SERVICE_AES_CIPHER) ? XC_SERVICE_AES_BLOCKLEN : XC_SERVICE_DES_BLOCKLEN;
    
    while (pbInput < pbInputEnd)
    {
        CBC(pCipher, uiBlockLen, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
        pbInput += uiBlockLen;
        pbOutput += uiBlockLen;
    }
}

void XcGetCryptParamsFromKeyLength(IN UINT cbKey, OUT UINT *puiCipher, OUT UINT *puiBlockLen, OUT UINT *puiTableSize)
{
    Assert(cbKey == XC_SERVICE_DES_KEYSIZE || 
           cbKey == XC_SERVICE_DES3_KEYSIZE ||
           cbKey == XC_SERVICE_AES_KEYSIZE ||
           cbKey == XC_SERVICE_NULL_KEYSIZE);
    switch(cbKey)
    {
    case XC_SERVICE_DES_KEYSIZE:
        *puiCipher      = XC_SERVICE_DES_CIPHER;
        *puiBlockLen    = XC_SERVICE_DES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_DES_TABLESIZE;
        break;
    case XC_SERVICE_AES_KEYSIZE:
        *puiCipher      = XC_SERVICE_AES_CIPHER;
        *puiBlockLen    = XC_SERVICE_AES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_AES_TABLESIZE;
        break;
    case XC_SERVICE_NULL_KEYSIZE:
        *puiCipher      = XC_SERVICE_NULL_CIPHER;
        *puiBlockLen    = XC_SERVICE_AES_BLOCKLEN;  // so packets are identical to encrypted case (aes)
        *puiTableSize   = 0;
        break;
    case XC_SERVICE_DES3_KEYSIZE:
    default:
        // hmm.. old behavior for default was DES3, so let's stick with that
        *puiCipher      = XC_SERVICE_DES3_CIPHER;
        *puiBlockLen    = XC_SERVICE_DES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_DES3_TABLESIZE;
        break;
    }
}

void XcCrypt(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2)
{
    UINT uiCipher;
    UINT uiBlockLen;
    UINT uiTableSize;

    XcGetCryptParamsFromKeyLength(cbKey, &uiCipher, &uiBlockLen, &uiTableSize);

    if (uiCipher == XC_SERVICE_NULL_CIPHER)
    {
        return;
    }

    BYTE abTable[CBDT];
    XcKeyTable(uiCipher, abTable, pbKey);

    BYTE abFeedback[max(XC_SERVICE_DES_BLOCKLEN, XC_SERVICE_AES_BLOCKLEN)];
    memcpy(abFeedback, pbIv, uiBlockLen);

    if (cb1 > 0)
    {
        Assert(pb1 != NULL && (cb1 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb1, pb1, pb1, abTable, dwOp, abFeedback);
    }

    if (cb2 > 0)
    {
        Assert(pb2 != NULL && (cb2 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb2, pb2, pb2, abTable, dwOp, abFeedback);
    }
}

void XcCryptWithKeyTable(DWORD dwOp, BYTE * pbKeyTable, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2)
{
    UINT uiCipher;
    UINT uiBlockLen;
    UINT uiTableSize;

    XcGetCryptParamsFromKeyLength(cbKey, &uiCipher, &uiBlockLen, &uiTableSize);

    if (uiCipher == XC_SERVICE_NULL_CIPHER)
    {
        return;
    }

    BYTE abFeedback[max(XC_SERVICE_DES_BLOCKLEN, XC_SERVICE_AES_BLOCKLEN)];
    memcpy(abFeedback, pbIv, uiBlockLen);

    if (cb1 > 0)
    {
        Assert(pb1 != NULL && (cb1 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb1, pb1, pb1, pbKeyTable, dwOp, abFeedback);
    }

    if (cb2 > 0)
    {
        Assert(pb2 != NULL && (cb2 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb2, pb2, pb2, pbKeyTable, dwOp, abFeedback);
    }
}

void XcMD5Init(IN PUCHAR pbMD5Context)
{
    MD5Init((MD5_CTX*)pbMD5Context);
}
   
void XcMD5Update(IN PUCHAR pbMD5Context, IN PUCHAR pbInput, IN ULONG dwInputLength)
{
    MD5Update((MD5_CTX*)pbMD5Context, pbInput, dwInputLength);
}
   
void XcMD5Final(IN PUCHAR pbMD5Context, IN PUCHAR pbDigest)
{
    MD5Final((MD5_CTX*)pbMD5Context);
    memcpy( pbDigest, ((MD5_CTX*)pbMD5Context)->digest, MD5_LEN );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgdstinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgdstinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#include "ws2tcpip.h"

// ---------------------------------------------------------------------------------------
// CDstInfo
// ---------------------------------------------------------------------------------------

CReaderWriterLock3 g_lockDstInfo;       // Synchronizes access to DstInfo

UINT            g_cDstInfo;             // Number of CDstInfo structures allocated
CDstInfo **     g_ppDstInfoByIpPortI;   // Vector of pointers to available CDstInfo by ipportI
CTimer          g_dstInfoDnsRefreshTimer; // Timer used to refresh the mapping from dns name -> ip
UINT            g_cTicksPerDnsRefresh;     // Timer to periodically refresh the DNS entries in DstTransInfo
UINT            g_cTicksPerDnsRefreshFail; // Timer to retry DNS refresh if a previous attempt failed.

typedef struct _DnsEntry : public LIST_ENTRY
{
    char        szDnsName[MAX_DNSNAME_LEN];
    CIpAddr     ipa;
} DnsEntry;

LIST_ENTRY         g_leDnsMap;     // Temporary cache of items previously resolved, to speed multiple resolves
CReaderWriterLock3 g_DnsMapLock;   // Lock to protect access to g_leDnsMap
BOOL               g_fDnsRefreshForceWrite;

void SgDnsMapFlush()
{
    g_DnsMapLock.WriteLock();
    while (!IsListEmpty(&g_leDnsMap))
    {
        DnsEntry *pDnsEntry = (DnsEntry*)RemoveHeadList(&g_leDnsMap);
        SgMemFree(pDnsEntry);
    }
    g_DnsMapLock.WriteUnlock();
}

BOOL SgDstInfoInit()
{
    Assert(g_cDstInfo == 0);
    Assert(g_ppDstInfoByIpPortI == NULL);
    g_dstInfoDnsRefreshTimer.Init();
    InitializeListHead(&g_leDnsMap);
    g_fDnsRefreshForceWrite = FALSE;
    return(TRUE);
}

void SgDstInfoTerm()
{
    CDstInfo ** ppDstInfo = g_ppDstInfoByIpPortI;

    SgDstInfoWriteLock();
#ifdef SG_FEATURE_ARP
    SgArpInfoLock();
#endif
    for (UINT i = 0; i <= 0xFFFF && g_cDstInfo > 0; ++i, ++ppDstInfo)
    {
        if (*ppDstInfo != NULL
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
            && i == (*ppDstInfo)->_ipportI
#endif
           )
        {
            SgDstInfoFree(*ppDstInfo);
            g_cDstInfo--;
        }
    }
    Assert( 0 == g_cDstInfo );

#ifdef SG_FEATURE_ARP
    SgArpInfoUnlock();
#endif
    SgDstInfoWriteUnlock();

    SgMemFree(g_ppDstInfoByIpPortI);

    CTransInfo * pTransInfo = g_pTransInfo;
    for (UINT i = 0; i < g_cTransInfo; i++, pTransInfo++)
    {
        delete pTransInfo->_pDstTransInfoHash;
        pTransInfo->_pDstTransInfoHash = NULL;
    }

    g_ppDstInfoByIpPortI = NULL;

    SgDnsMapFlush();
}

BOOL SgDnsMapFindEntry(const CHAR* szDnsName, CIpAddr &ipa)
{
    DnsEntry* pde = NULL;
    for (pde = (DnsEntry*)g_leDnsMap.Flink; pde != &g_leDnsMap; pde = (DnsEntry*)pde->Flink)
    {
        if (_strnicmp(pde->szDnsName, szDnsName, ARRAY_SIZE(pde->szDnsName) - 1) == 0)
        {
            ipa = pde->ipa;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL SgDnsResolveNoCache(const CHAR* szDnsName, CIpAddr &ipa)
{
    BOOL fFound = FALSE;

    // No entry exists, construct new entry
    PADDRINFOA padrIPZ = NULL;
    int err = getaddrinfo(szDnsName, NULL, NULL, &padrIPZ);

    if (err != ERROR_SUCCESS)
    {
        TraceSz(DnsResolve, "Unable to resolve '%s' to an ip. err=%d", szDnsName, err);
        return FALSE;
    }

    PADDRINFOA pTemp = padrIPZ;
    while (pTemp != NULL)
    {
        if (pTemp->ai_family == AF_INET)
        {
            PSOCKADDR_IN pIn = (PSOCKADDR_IN)pTemp->ai_addr;
            ipa = pIn->sin_addr;
            break;
        }
        pTemp = pTemp->ai_next;
    }

    freeaddrinfo(padrIPZ);

    if (pTemp == NULL)
    {
        TraceSz(DnsResolve, "Unable to resolve '%s' to an ip. No IPv4 address found", szDnsName, err);
        // Set a recognizable error that will go in the event and can be traced back to here
        // According to the getaddrinfo documentation this error is only set by it in a case that we won't hit
        WSASetLastError(WSAEAFNOSUPPORT);
        return FALSE;
    }

    TraceSz(DnsResolve, "Resolved '%s' to %s", szDnsName, ipa.Str());
    return TRUE;
}

BOOL SgDnsResolveToIP(const CHAR* szDnsName, CIpAddr &ipa)
{
    // If there is no string to resolve, skip
    if (szDnsName == NULL || szDnsName[0] == '\0')
    {
        return TRUE;
    }

    g_DnsMapLock.ReadLock();

    BOOL fFound = SgDnsMapFindEntry(szDnsName, ipa);

    g_DnsMapLock.ReadUnlock();

    // Found entry?  Then return;
    if (fFound)
    {
        return TRUE;
    }

    g_DnsMapLock.WriteLock();

    // Check that the entry is still not in list

    if (SgDnsMapFindEntry(szDnsName, ipa))
    {
        fFound = TRUE;
        goto exit;
    }

    if (!SgDnsResolveNoCache(szDnsName, ipa))
    {
        fFound = FALSE;
        goto exit;
    }

    // Prepare a new entry and add to the cache
    DnsEntry* pde = (DnsEntry*)SgMemAllocZ(sizeof(DnsEntry), PTAG_DnsEntry);
    pde->ipa = ipa;
    strncpy(pde->szDnsName, szDnsName, ARRAY_SIZE(pde->szDnsName) - 1);

    InsertHeadList(&g_leDnsMap, pde);
    fFound = TRUE;
exit:
    g_DnsMapLock.WriteUnlock();    
    return fFound;
}

void SgDstInfoDnsRefreshTimer(CTimer*)
{
    BOOL fOk = TRUE;

    TraceSz(DnsResolve, "DnsRefreshTimer: Starting");

    // Step 1: Iterate through the cached DNS entries to update those values
    g_DnsMapLock.ReadLock();

    DnsEntry* pde = NULL;
    BOOL fChanged = FALSE;
    for (pde = (DnsEntry*)g_leDnsMap.Flink; pde != &g_leDnsMap; pde = (DnsEntry*)pde->Flink)
    {
        CIpAddr ipa;
        BOOL fSuccess = SgDnsResolveNoCache(pde->szDnsName, ipa);
        if (fSuccess && ipa != pde->ipa)
        {
            fChanged = TRUE;
            pde->ipa = ipa;
        }
        else if (!fSuccess)
        {
            int err = WSAGetLastError();
            SgEventSz (CONFIG_ERROR, "On DNS refresh, resolving DnsName %s failed (err=%d). "
                            " The previous value %s will remain and will attempt to resolve again at the next refresh interval.",
                            pde->szDnsName, err, pde->ipa.Str());
        }
        fOk &= fSuccess;
    }

    g_DnsMapLock.ReadUnlock();

    // Step 2: Take a read lock on the settings and attempt to resolve the DstInfo entries
    BOOL fWriteLock = fChanged || g_fDnsRefreshForceWrite;
    if (fWriteLock)
    {
        SgDstInfoWriteLock();
    }
    else
    {
        SgDstInfoReadLock();
    }

    // Reset the global refresh pointer.
    g_fDnsRefreshForceWrite = FALSE;

    for (UINT i = 0; i < 0x10000; i++)
    {
        if (g_ppDstInfoByIpPortI[i] == NULL)
        {
            continue;
        }

        CDstInfo* pDstInfo = g_ppDstInfoByIpPortI[i];

        for (UINT j = 0; j < pDstInfo->_cDstTransInfo; j++)
        {
            CDstTransInfo *pDstTransInfo = &pDstInfo->_aDstTransInfo[j];
            if (pDstTransInfo->_szDnsNameZ[0] == '\0')
            {
                continue;
            }

            CIpAddr ipaZ;
            BOOL fSuccess = SgDnsResolveToIP( pDstTransInfo->_szDnsNameZ, ipaZ );

            if (fSuccess && (ipaZ != pDstTransInfo->_ipaZ))
            {
                // Confirm that new IP port combination is not in use by another service already
                CTransInfo *pTransInfo = SgTransInfoLookup(j);

                // Can safely cast as the loop iterator is only 16 bits in value.
                CDstInfo * pDstInfoByZ = SgDstInfoLookup(pTransInfo, ipaZ, pDstTransInfo->_ipportZ);

                if (pDstInfoByZ != NULL)
                {
                    // Found an entry that already exists with the same IP/Port pairing, this is a config error
                    SgEventSz (CONFIG_ERROR, "On DNS refresh for Server Id %d, resolving DnsName %s to Ipa %s will result in a"
                                    " conflict with Server Id %d which ia already mapped the same IP and port.  The update has"
                                    " been rejected, and will attempt to resolve again at the next refresh interval.",
                                    NTOHS( pDstInfo->_ipportI ), pDstTransInfo->_szDnsNameZ, ipaZ.Str(),
                                    NTOHS( pDstInfoByZ->_ipportI ) );
                    fSuccess = FALSE;
                }
                else if (fWriteLock)
                {
                    TraceSz(DnsResolve, "Updating IP entry for service %d datacenter interface %d: %s -> %s",
                        NTOHS(pDstInfo->_ipportI), j, pDstInfo->_aDstTransInfo[j]._ipaZ.Str(), ipaZ.Str());

                    // Update the hash table entry for the TransInfo as well as the IP.
                    pTransInfo->_pDstTransInfoHash->Delete( pDstTransInfo );

#ifdef SG_FEATURE_ARP
                    // Need to ARP the new IP
                    SgArpInfoLock();
                    CArpInfo * pArpInfo = SgArpInfoInsert( pTransInfo, ipaZ, FALSE );

                    if (pArpInfo != NULL)
                    {
                        SgArpInfoRelease( pDstTransInfo->_pArpInfo, pDstTransInfo->_pArpInfo->_fPersistent );
                        pDstTransInfo->_pArpInfo = pArpInfo;
                    }
                    SgArpInfoUnlock();

                    if (NULL == pArpInfo)
                    {
                        // This should only happen on OOM, can't complete
                        TraceSz(DnsResolve, "NULL ArpInfo returned, unable to continue updating entry");
                        fOk = FALSE;
                        break;
                    }
#endif // SG_FEATURE_ARP

                    pDstTransInfo->_ipaZ = ipaZ;
                    pTransInfo->_pDstTransInfoHash->Insert( pDstTransInfo );
                }
                else
                {
                    // If this happens, it is possible that DstTransInfo IP was updated via a config refresh
                    // where there was already an existing value.  Not in writelock, so can't update the entry.
                    // Instead, schedule a writelock update in the next tick -- DNS updates aren't immediate, so no need
                    // to make this an immediate change.
                    TraceSz(DnsResolve, "Found old IP %s for service %d datacenter interface %d while in readlock refresh.  Scheduling writelock refresh",
                        pDstTransInfo->_ipaZ.Str(), NTOHS(pDstInfo->_ipportI), j);
                    g_fDnsRefreshForceWrite = TRUE;
                    break;
                }
            }
            fOk &= fSuccess;
        }

        // If I am stopping the inner loop because the lock is incorrect, break outer loop too.
        if (g_fDnsRefreshForceWrite)
        {
            break;
        }
    }

    if (fWriteLock)
    {
        SgDstInfoWriteUnlock();
    }
    else
    {
        SgDstInfoReadUnlock();
    }

    // Step 3: Trigger the refresh for the notificaton dns entries.
    fOk &= SgServiceNotifyRefreshDns();

    UINT ticks = g_fDnsRefreshForceWrite ? 1 : fOk ? g_cTicksPerDnsRefresh : g_cTicksPerDnsRefreshFail;

    // If a forced update is required, call the pass a failure.
    fOk &= !g_fDnsRefreshForceWrite;

    TraceSz(DnsResolve, "DnsRefreshTimer: Complete, Success:%d [force:%d].  Next refresh in %d tick%s.",
        fOk, g_fDnsRefreshForceWrite, ticks, ticks == 1 ? "" : "s");

    SgTimerSet(&g_dstInfoDnsRefreshTimer, SgDstInfoDnsRefreshTimer, SgTimerTick() + ticks, TRUE);
}

BOOL SgDstInfoConfig(CCfgInfo* pci)
{
    BOOL    fAnyConfig = FALSE;
    BOOL    fOk        = FALSE;
    DWORD   cServer    = pci->Count("Server");

    SgDstInfoWriteLock();

    if (g_ppDstInfoByIpPortI == NULL)
    {
        g_ppDstInfoByIpPortI = (CDstInfo **)SgMemAllocZ(0x10000 * sizeof(CDstInfo *), PTAG_CDstInfo);

        if (g_ppDstInfoByIpPortI == NULL)
        {
            TraceSz(Config, "Config error: Out of memory allocating %d CDstInfo pointers (%d bytes)",
                     0x10000, 0x10000 * sizeof(CDstInfo *));
            goto exit;
        }
    }

    if( cServer > 0 && g_cTransInfoZ == 0)
    {
        TraceSz(Config, "Config error: Cannot configure servers until datacenter network interfaces are configured");
        SgEventSz(CONFIG_ERROR, "Cannot configure servers before datacenter interfaces");
        goto exit;
    }

    CTransInfo * pTransInfo = g_pTransInfo;
    for (UINT i = 0; i < g_cTransInfo; i++, pTransInfo++)
    {
        if (   pTransInfo->_dwType != TRANSTYPE_DMZ
            || pTransInfo->_pDstTransInfoHash != NULL)
        {
            continue;
        }

        UINT cEnt = max( cServer * 2, 256 );

        pTransInfo->_pDstTransInfoHash = new CDstTransInfoHash;

        if (pTransInfo->_pDstTransInfoHash == NULL || !pTransInfo->_pDstTransInfoHash->Init(cEnt, NULL))
        {
            TraceSz(Config, "Config error: Out of memory allocating CDstTransInfoHash (%d entries)", cEnt);
            delete pTransInfo->_pDstTransInfoHash;
            pTransInfo->_pDstTransInfoHash = NULL;
            goto exit;
        }

    }

    CCfgInfo* pciServer = NULL;

    // Go through the specified servers
    for( UINT iServer = 0; iServer < cServer; iServer++ )
    {
        CCfgInfo* pciT;
        ServiceMask svcMask;
        CIpPort ipportI;
        CIpPort ipportIend = 0;
        BOOL fVdpOnly;
        DWORD dwConnGroupId = CONN_GROUP_DEFAULT;
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
        BOOL fArbitration = FALSE;
#endif

        pciServer = pci->FindList("Server", pciServer, TRUE);
        Assert(pciServer);

        if(!pciServer->GetIpPort("Id", &ipportI, TRUE))
            goto exit;

        pciServer->GetIpPort("IdEnd", &ipportIend, FALSE);

        if(ipportIend != 0 && NTOHS(ipportIend) < NTOHS(ipportI))
        {
            SgEventSz(
                CONFIG_ERROR,
                "Failed to configure server Id %u. IdEnd (i_internet_port_end) %u is "
                "invalid. It must be greater than or equal to Id (i_internet_port) %u.",
                NTOHS(ipportI), NTOHS(ipportIend), NTOHS(ipportI));

            goto exit;
        }

        pciT     = pciServer->FindNonList("Protocol", NULL, FALSE);
        fVdpOnly = pciT && pciT->_csValue.StrEql("VDP");

        // Calculate the service mask by going through all services associated to this
        // server and setting the bit in dwSvcMask corresponding to the index of the
        // CSvcInfo entry in g_pSvcInfo

        svcMask   = ServiceMask::Empty;
        pciT        = NULL;

        SgSvcInfoLock();

        while (1)
        {
            pciT = pciServer->FindNonList("Service", pciT, FALSE);

            if (pciT == NULL)
                break;

            CSvcInfo * pSvcInfo = SgSvcInfoLookup(pciT->_csValue.Str());

            if (pSvcInfo == NULL)
            {
                SgSvcInfoUnlock();
                
                SgEventSz(CONFIG_WARNING, "line %d. Service '%s' not defined.",
                           pciT->_csValue._iLine, pciT->_csValue.Str());
                goto exit;
            }

            svcMask.SetBit(pSvcInfo->_iSvcInfo);

#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
            if( XONLINE_ARBITRATION_SERVICE == pSvcInfo->_dwSvcId )
            {
                if(ipportIend == 0)
                {
                    SgSvcInfoUnlock();
                    
                    SgEventSz(
                        CONFIG_ERROR,
                        "A server that specified the XONLINE_ARBITRATION_SERVICE must "
                        "also specify the IdEnd. Look for the xarb virtual interface in "
                        "npdb..t_virtual_interfaces. The i_internet_port_end column "
                        "must be not null.");

                    goto exit;
                }

                fArbitration = TRUE;
            }
#endif

            if (XONLINE_CONNECTION_SERVICE == pSvcInfo->_dwSvcId)
            {
                // Special hack to avoid complicated configuration for a feature that may 
                // shortly die. If it doesn't, this code will *POOF* disappear.
                dwConnGroupId = CONN_GROUP_CONNECTION_SERVER;
            }
        }

        SgSvcInfoUnlock();

        if (svcMask == ServiceMask::Empty)
        {
            TraceSz( Config, "Config error: One or more 'Service' values must be supplied" );
            SgEventSz( CONFIG_WARNING, "One or more 'Service' values required for Server Id %u.", NTOHS(ipportI));
            continue;
        }

        // Loop through all the 'Address' entries. There should be one for each DMZ
        // interface.
        CDstInfo* pDstInfoNew = NULL;
        CCfgInfo* pciAddress  = NULL;
        DWORD cAddresses      = pciServer->Count("Address");

        UINT iAddress;
        for( iAddress = 0; iAddress < cAddresses; iAddress++ )
        {
            DWORD dwId;
            CIpAddr ipaZ;
            CIpPort ipportZ;
            CHAR szDnsNameZ[MAX_DNSNAME_LEN] = { };

            pDstInfoNew = NULL;

            pciAddress = pciServer->FindList("Address", pciAddress, FALSE);
            Assert(pciAddress);

            if (!pciAddress->GetNum("InterfaceId", &dwId, TRUE) ||
                 // Attempt to find DnsName first, failing that, fall back to looking for IP Address
                 (!(pciAddress->GetString("DnsName", szDnsNameZ, ARRAY_SIZE(szDnsNameZ), FALSE) && szDnsNameZ[0] != '\0') &&
                  !pciAddress->GetIpAddr("Ip", &ipaZ, TRUE)
                 ) ||
                !pciAddress->GetIpPort("Port", &ipportZ, TRUE))
            {
                SgEventSz(CONFIG_ERROR, "Invalid Address information supplied for Server Id %u.", NTOHS(ipportI)); 
                goto exit;
            }

            pTransInfo = SgTransInfoLookupZ(dwId);
            if( NULL == pTransInfo )
            {
                SgEventSz( CONFIG_ERROR, ". No Interface has Id %d.", dwId);
                goto exit;
            }

            CDstInfo * pDstInfoByI = SgDstInfoLookup(ipportI);

            // Perform a DNS lookup only if the entry is new
            if ( szDnsNameZ[0] != '\0' )
            {
                // Attempt to see if DstInfo is available
                CDstTransInfo * pDstTransInfo = pDstInfoByI != NULL ? &pDstInfoByI->_aDstTransInfo[pTransInfo->_iTransInfo] : NULL;

                // If there is an existing IP from the previous config, get that one in order to set it properly later.
                if ( pDstTransInfo != NULL )
                {
                    ipaZ = pDstTransInfo->_ipaZ;
                }

                // If the DNS names don't match or the names match and the IP has not already been set,
                // attempt to resolve.  Don't attempt to resolve if the IP has already been set, as this
                // could be a last known good reload, which assumes the old config is still valid.
                if ( ( pDstTransInfo == NULL ||
                       _strnicmp( pDstTransInfo->_szDnsNameZ, szDnsNameZ, ARRAY_SIZE(szDnsNameZ) - 1 ) != 0 ||
                       pDstTransInfo->_ipaZ == 0 ) &&
                     !SgDnsResolveToIP( szDnsNameZ, ipaZ ) )
                {
                    // Override the datacenter IP if the dns name is being set
                    SgEventSz(CONFIG_ERROR, "Invalid Address information supplied for Server Id %u. Could not resolve DnsName %s",
                        NTOHS(ipportI),
                        szDnsNameZ); 
                    goto exit;
                }
            }

            CDstInfo * pDstInfoByZ = SgDstInfoLookup(pTransInfo, ipaZ, ipportZ);

            if (pDstInfoByZ != NULL && pDstInfoByZ != pDstInfoByI)
            {
                SgEventSz( CONFIG_ERROR, ". Server Id %d is already mapped to Ipa %s Port %d",
                          NTOHS( pDstInfoByZ->_ipportI ), ipaZ.Str(), NTOHS( ipportZ ) );
                break;
            }

            if( 0 == iAddress )
            {
                // We haven't created a new CDstInfo yet.

                if (pDstInfoByI != NULL)
                {
                    // Zap the out of date CDstInfo
                    Assert(g_cDstInfo > 0);

                    SgArpInfoLock();
                    SgDstInfoFree( pDstInfoByI );
                    SgArpInfoUnlock();

                    pDstInfoByI = NULL;
                    g_cDstInfo -= 1;
                }

                // make a new CDstInfo

                UINT cbDstInfo = offsetof(CDstInfo, _aDstTransInfo) + g_cTransInfo * sizeof(CDstTransInfo);

                pDstInfoNew = (CDstInfo *)SgMemAllocZ(cbDstInfo, PTAG_CDstInfo);

                if (pDstInfoNew == NULL)
                {
                    TraceSz(Config, "Config error: Out of memory allocating CDstInfo (%d bytes)", cbDstInfo);
                    break;
                }

                pDstInfoNew->_ipportI       = ipportI;
                pDstInfoNew->_svcMask       = svcMask;
                pDstInfoNew->_fVdpOnly      = fVdpOnly;
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
                pDstInfoNew->_fArbitration  = fArbitration;
#endif
                pDstInfoNew->_dwConnGroupId = dwConnGroupId;
                pDstInfoNew->_cDstTransInfo = g_cTransInfo;
            }
            else
            {
                // We just created pDstInfoByI in an earlier iteration, and now we've looked it up.
                Assert( NULL != pDstInfoByI );
                pDstInfoNew = pDstInfoByI;
            }

            CDstTransInfo * pDstTransInfo = &pDstInfoNew->_aDstTransInfo[pTransInfo->_iTransInfo];

            if (pDstTransInfo->_ipaZ != 0)
            {
                SgEventSz( CONFIG_WARNING, ". 'InterfaceId' %d is already mapped to %s:%d.",
                           pTransInfo->_dwTransId, pDstTransInfo->_ipaZ.Str(), NTOHS( pDstTransInfo->_ipportZ ) );

                SgArpInfoLock();
                SgDstInfoFree( pDstInfoNew );
                SgArpInfoUnlock();
                pDstInfoNew = NULL;
                break;
            }

            C_ASSERT(sizeof(pDstTransInfo->_szDnsNameZ) == sizeof(szDnsNameZ) );
            memcpy( pDstTransInfo->_szDnsNameZ, szDnsNameZ, sizeof(pDstTransInfo->_szDnsNameZ) );

            pDstTransInfo->_ipportZ = ipportZ;
            pDstTransInfo->_ipaZ    = ipaZ;

#ifdef SG_FEATURE_ARP
            // Track this as another server we need ARP info for
            SgArpInfoLock();
            pDstTransInfo->_pArpInfo = SgArpInfoInsert( pTransInfo, ipaZ, FALSE );
            if( NULL == pDstTransInfo->_pArpInfo )
            {
                SgDstInfoFree( pDstInfoNew );
                pDstInfoNew = NULL;
                g_cDstInfo -= 1;
            }
            SgArpInfoUnlock();
#endif // SG_FEATURE_ARP

            if( NULL == pDstInfoNew )
            {
                break;
            }

            pTransInfo->_pDstTransInfoHash->Insert( pDstTransInfo );

            if( 0 == iAddress )
            {
                // Add new CDstInfo to the table
                g_ppDstInfoByIpPortI[ ipportI ] = pDstInfoNew;

#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
                if( pDstInfoNew->_fArbitration &&
                    0 != ipportIend)
                {
                    // Insert the same CDstInfo for all of the valid source ports
                    for( WORD iPort = NTOHS( ipportI ) + 1; iPort <= NTOHS( ipportIend ); iPort++ )
                    {
#if 0
                        // @@@ this check broke 'reload_config'. It's a nice to have but
                        // not essencial. SgDstInfoConfig only adds information, it never
                        // deletes. So if we use reload_config to change internet ports of
                        // servers and stuff, we could end up with weird results.

                        if(g_ppDstInfoByIpPortI[HTONS(iPort)])
                        {
                            SgEventSz(
                                CONFIG_ERROR,
                                "The range of ports configured for the arbitration "
                                "service [%u-%u] is conflicting with the port of "
                                "another server [%u]. Check your t_virtual_interfaces",
                                NTOHS(ipportI), NTOHS(ipportIend), iPort);
                            goto exit;
                        }
#endif

                        g_ppDstInfoByIpPortI[ HTONS( iPort ) ] = pDstInfoNew;
                    }
                }
#endif
                g_cDstInfo += 1;
                pDstInfoNew = NULL;
                fAnyConfig = TRUE;
            }
        }

        // There needs to have been an address for every DMZ interface, and we must have succeeded
        // configuring them all.
        if( iAddress != g_cTransInfoZ )
        {
            TraceSz( Config, "Config error: %d 'Address' value%s must be supplied (%d found).",
                     g_cTransInfoZ, g_cTransInfoZ == 1 ? "": "s", iAddress );
            SgEventSz( CONFIG_WARNING, ". %d 'Address' value%s must be supplied (%d found).",
                        g_cTransInfoZ, g_cTransInfoZ == 1 ? "": "s", iAddress);

            if( NULL != pDstInfoNew )
            {
                SgArpInfoLock();
                SgDstInfoFree( pDstInfoNew );
                SgArpInfoUnlock();

                pDstInfoNew = NULL;
                g_cDstInfo -= 1;
            }
        }
    }

    if (!pci->GetVar("DnsRefreshIntervalInMinutes", &g_cTicksPerDnsRefresh, 1, 24 * 60, 30) ||
        !pci->GetVar("DnsRefreshFailureIntervalInSeconds", &g_cTicksPerDnsRefreshFail, 1, 24 * 60 * 60, 60))
    {
        goto exit;
    }

    g_cTicksPerDnsRefresh *= TICKS_PER_SECOND * 60;
    g_cTicksPerDnsRefreshFail *= TICKS_PER_SECOND;

    // Toss the current DNS entries found if we are reading new entries.
    if (fAnyConfig)
    {
        SgDnsMapFlush();
    }
    // Schedule timer to run.  If any changes to config, then schedule the timer to run soon.
    UINT cTicksToAdvance = fAnyConfig ? 1 : g_cTicksPerDnsRefresh;
    SgTimerSet(&g_dstInfoDnsRefreshTimer, SgDstInfoDnsRefreshTimer, SgTimerTick() + cTicksToAdvance, TRUE);

    // If we changed something, log it
    if( fAnyConfig )
    {
        TraceSz( Config, "SgDstInfoConfig:" );

        TraceSz(Config, "    Configured dns timer to %d minutes (%d ticks)", g_cTicksPerDnsRefresh / TICKS_PER_SECOND / 60, g_cTicksPerDnsRefresh);
        TraceSz(Config, "    Configured dns timer on failure to %d seconds (%d ticks)", g_cTicksPerDnsRefreshFail / TICKS_PER_SECOND, g_cTicksPerDnsRefreshFail);
        pTransInfo = g_pTransInfo;

        for( UINT i = 0; i < g_cTransInfo; ++i, ++pTransInfo )
        {
            if( TRANSTYPE_DMZ == pTransInfo->_dwType )
            {
                UINT cServers = pTransInfo->_pDstTransInfoHash->GetCount();
                UINT cBuckets = pTransInfo->_pDstTransInfoHash->GetBucketCount();

                TraceSz( Config, "    Configured %u server%s in %u hash buckets for Interface %u",
                          cServers, cServers == 1 ? "" : "s", cBuckets, i );
            }
        }

        for(UINT i =0; i <= 0xFFFF; i++)
        {
            CDstInfo* pDstInfo = g_ppDstInfoByIpPortI[HTONS((USHORT)i)];

            if( NULL == pDstInfo )
            {
                continue;
            }

            TraceSz( Config, "    Inet Port %-5u: _svcMask   %08I64X %08I64X", i, pDstInfo->_svcMask.LowPart, pDstInfo->_svcMask.HighPart);
            TraceSz( Config, "                     _fVdpOnly    %s", pDstInfo->_fVdpOnly ? "true" : "false" );

            CDstTransInfo * pDstTransInfo = pDstInfo->_aDstTransInfo;
            for( UINT j = 0; j < pDstInfo->_cDstTransInfo; j++, pDstTransInfo++ )
            {
                if( TRANSTYPE_DMZ != g_pTransInfo[j]._dwType )
                {
                    continue;
                }

                CSmallStr dnsName;

                // If there is a DNS name, add it to the result so it can be seen
                if (pDstTransInfo->_szDnsNameZ[0] != '\0')
                {
                    dnsName.Format(" (_szDnsNameZ %s)", pDstTransInfo->_szDnsNameZ);
                }

                TraceSz( Config, "        Dmz Interface %-5u: _ipaZ    %s%s", j, pDstTransInfo->_ipaZ.Str(), dnsName.cstr() );
                TraceSz( Config, "                             _ipportZ %d", NTOHS( pDstTransInfo->_ipportZ ) );
            }

            for( UINT iBit = 0; iBit < ServiceMask::SERVICE_BITS; ++iBit )
            {
                if( pDstInfo->_svcMask.IsBitSet(iBit))
                {
                    TraceSz( Config, "        Service: (%s)", g_pSvcInfo[ iBit ]._achName );
                }
            }
        }
    }

    fOk = TRUE;

exit:
    SgDstInfoWriteUnlock();

    return(fOk);
}

CDstInfo * SgDstInfoLookup(CIpPort ipportI)
{
    if (g_ppDstInfoByIpPortI != NULL)
    {
        return(g_ppDstInfoByIpPortI[ipportI]);
    }

    return(NULL);
}

CDstInfo * SgDstInfoLookup(CTransInfo * pTransInfo, CIpAddr ipaZ, CIpPort ipportZ)
{
    CDstTransInfoHash * pDstTransInfoHash = pTransInfo->_pDstTransInfoHash;

    if (pDstTransInfoHash != NULL)
    {
        CDstTransInfo DstTransInfo;
        DstTransInfo._ipaZ = ipaZ;
        DstTransInfo._ipportZ = ipportZ;

        CDstTransInfo * pDstTransInfo = pDstTransInfoHash->Lookup(&DstTransInfo);

        if (pDstTransInfo == NULL)
            return(NULL);

        return((CDstInfo *)(pDstTransInfo - pTransInfo->_iTransInfo + 1) - 1);
    }

    return(NULL);
}

DWORD SgDstTransInfoHashCompute(CDstTransInfo * pDstTransInfo)
{
    return(pDstTransInfo->_ipaZ + pDstTransInfo->_ipportZ);
}

BOOL SgDstTransInfoHashCompare(CDstTransInfo * pDstTransInfo1, CDstTransInfo * pDstTransInfo2)
{
    return(pDstTransInfo1->_ipaZ == pDstTransInfo2->_ipaZ && pDstTransInfo1->_ipportZ == pDstTransInfo2->_ipportZ);
}

void SgDstInfoFree(CDstInfo * pDstInfo)
{
    // Note: the caller must hold the ARP lock

    if (pDstInfo != NULL)
    {
        // unmap this Server in the Internet table

        if (g_ppDstInfoByIpPortI[pDstInfo->_ipportI] == pDstInfo)
            g_ppDstInfoByIpPortI[pDstInfo->_ipportI] = NULL;

        // remove DMZ info for this server.

        CDstTransInfo * pDstTransInfo = pDstInfo->_aDstTransInfo;
        CTransInfo *    pTransInfo    = g_pTransInfo;

        for (UINT i = 0; i < g_cTransInfo; i++, pTransInfo++, pDstTransInfo++)
        {
#ifdef SG_FEATURE_ARP
            SgArpInfoRelease(pDstTransInfo->_pArpInfo, FALSE);
#endif

            if (pTransInfo->_pDstTransInfoHash && pDstTransInfo->_ipaZ != 0)
                pTransInfo->_pDstTransInfoHash->Delete(pDstTransInfo);
        }

        SgMemFree(pDstInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sghealth.cpp ===
// ---------------------------------------------------------------------------------------
// sghealth.cpp
//
// Copyright (C) Microsoft Corporation
//
// Implements all the native healthcheck stuff for the SG. This includes initialize the 
// COM interop glue, firing up the .Net HTTP listener, and registering our custom 
// healthblocks.  
//
// The custom healthblocks are also implemented here. Please use these as a reference for 
// how to implement your own custom native healthblocks. CSGHealthStatsBlock and 
// CSGNotificationsBlock are the blocks in this file.
//
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_CONFIG_DB

using namespace XblHealthcheck;

// We need to poke around the other SG pieces a lot...

void SgServiceNotifyHealthCheck(
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface
    );

extern UINT g_cSpiInfo;
extern UINT g_cSpiInfoInUse;
extern DWORD g_cPacketPoolMax;

// ---------------------------------------------------------------------------------------
// CSGHealthStatsBlock - bunch of information about the SG rolled up into a healthblock.  
//
// Warns if:
// - low on connections
// - low on packets
// - high notification queuing
//
// Fails if:
// - out of connections
// - out of packets
//
// Params:
//   spithreshold          : warn level for connections, default 1000
//   packetthreshold       : warn level for packets, default 1000
//   notificationthreshold : warn level for notification queues, default 1000
//   
// ---------------------------------------------------------------------------------------
class CSGHealthStatsBlock:
    public CComObjectRoot,
    public INativeHealthBlock
{
public:
    BEGIN_COM_MAP(CSGHealthStatsBlock)
        COM_INTERFACE_ENTRY(INativeHealthBlock)
    END_COM_MAP()

    CSGHealthStatsBlock()
    {
    }

    virtual ~CSGHealthStatsBlock()
    {
    }

    virtual HRESULT __stdcall DoCheck(
        IN  BSTR bstrBlockParams,
        OUT enum HealthStatusEnum *pHealthStatus,
        OUT BSTR *pbstrErrorDetails,
        OUT BSTR *pbstrExtendedInfo
        )
    {

        HRESULT                 hr;
        CXomNameValuePairList   params;
        DWORD                   dwSpiThreshold;
        DWORD                   dwPacketThreshold;
        DWORD                   dwNotificationThreshold;
        BOOL                    fYellow = FALSE;
        BOOL                    fRed = FALSE;

        // Allow string to grow if > 4000 characters
        CLargeStr strOut;
        CLargeStr strError;
        strOut.SetAllocator(CMemAlloc::Default());
        strError.SetAllocator(CMemAlloc::Default());

        //
        // Parse parameters. They are a comma-separated list.
        //

        // Set defaults
        dwSpiThreshold          = 1000;
        dwPacketThreshold       = 1000;
        dwNotificationThreshold = 1000;

        hr = params.Parse(bstrBlockParams, ',');
        if (FAILED(hr))
        {
            strError.Format("Failed to parse params, hr=0x%08X\n", hr);
        }
        else
        {
            LPCSTR pszValue;
            
            pszValue = params.GetValueByName("spithreshold");
            if (pszValue)
            {
                dwSpiThreshold = atoi(pszValue);
            }

            pszValue = params.GetValueByName("packetthreshold");
            if (pszValue)
            {
                dwPacketThreshold = atoi(pszValue);
            }

            pszValue = params.GetValueByName("notificationthreshold");
            if (pszValue)
            {
                dwNotificationThreshold = atoi(pszValue);
            }
        }

        // If threshold is larger than max, adjust it
        if (dwSpiThreshold > g_cSpiInfo)
        {
            dwSpiThreshold = g_cSpiInfo / 2;
        }
        if (dwPacketThreshold > g_cPacketPoolMax)
        {
            dwPacketThreshold = g_cPacketPoolMax / 2;
        }
        

        //
        // Build report, enforce stuff
        //

        // ----- CONNECTIONS -----

        DWORD dwRemainingConnections = g_cSpiInfo - g_cSpiInfoInUse;
        if (dwRemainingConnections == 0)
        {
            strError.Format("Out of connections\n");
            fRed = TRUE;
        }
        else if (dwRemainingConnections < dwSpiThreshold)
        {
            strError.Format("Low on connections\n");
            fYellow = TRUE;
        }
        
        strOut.Format("Connections: %I64u current, %u remaining\n", 
                      SgPerfdataGet(CurrentConnections), dwRemainingConnections);

        strOut.Format("ConnectionsByCipher: %I64u AES, %I64u DES3, %I64u DES, %I64u NULL\n",
                      SgPerfdataGet(ConnectionsCipherAes), SgPerfdataGet(ConnectionsCipherDes3),
                      SgPerfdataGet(ConnectionsCipherDes), SgPerfdataGet(ConnectionsCipherNull));

        // ----- PACKETS -----

        // @@@ TODO: include arp queue count once implemented (see _pqWait)
        ULONGLONG ullQueuedPackets = 
            SgPerfdataGet(QueuedProc) + SgPerfdataGet(QueuedCli) + SgPerfdataGet(QueuedSpi) +
            SgPerfdataGet(IXmitStage1Count) + SgPerfdataGet(IXmitStage2Count) +
            SgPerfdataGet(ZXmitStage1Count) + SgPerfdataGet(ZXmitStage2Count);
        ULONGLONG ullPacketsAvailable = SgPerfdataGet(PacketsAvailable);
        
        if (ullPacketsAvailable == 0)
        {
            strError.Format("Out of packets\n");
            fRed = TRUE;
        }
        else if (ullPacketsAvailable < dwPacketThreshold)
        {
            strError.Format("Low on packets\n");
            fYellow = TRUE;
        }

        strOut.Format("Packets: %I64u available, %I64u queued\n",
                      ullPacketsAvailable, ullQueuedPackets);

        // ----- NOTIFICATIONS -----

        if (SgPerfdataGet(NotificationsDeleteQueue) < dwNotificationThreshold)
        {
            strError.Format("High queueing (delete notifications)\n");
            fYellow = TRUE;
        }
        if (SgPerfdataGet(NotificationsUpdateQueue) < dwNotificationThreshold)
        {
            strError.Format("High queueing (update notifications)\n");
            fYellow = TRUE;
        }
        if (SgPerfdataGet(NotificationsTitleChangeQueue) < dwNotificationThreshold)
        {
            strError.Format("High queueing (title change notifications)\n");
            fYellow = TRUE;
        }

        strOut.Format("Notifications: %I64u delete slots, %I64u update slots, %I64u titlechange slots\n",
                     SgPerfdataGet(NotificationsDeleteQueue),
                     SgPerfdataGet(NotificationsUpdateQueue),
                     SgPerfdataGet(NotificationsTitleChangeQueue));

        // 
        // Wrap it up
        //

        if (fRed)
            *pHealthStatus = HealthStatusEnum_Red;
        else if (fYellow)
            *pHealthStatus = HealthStatusEnum_Yellow;
        else
            *pHealthStatus = HealthStatusEnum_Green;

        // Note: .Detach() is required for "out string" parameters, since we are telling 
        // .Net to handle the memory instead of us.

        if (fRed || fYellow)
        {
            *pbstrErrorDetails = CComBSTR(strError.cstr()).Detach();
        }

        *pbstrExtendedInfo = CComBSTR(strOut.cstr()).Detach();

        return S_OK;
    }

};

// ---------------------------------------------------------------------------------------
// Helper class to map an xmgmt command responder to text we can grab
// ---------------------------------------------------------------------------------------
class CHealthXomControlResponder : 
    public CXomControlResponseInterface
{
public:

    CHealthXomControlResponder()
    {
        // auto-grow the string
        strResponse.SetAllocator(CMemAlloc::Default());
    }
    
    virtual HRESULT WriteResponse(DWORD dwRequestId, BYTE* pBuffer, DWORD cbBuffer)
    {
        // Typically, people use a length of -1, which means use strlen(). We'll do the 
        // same.
        if (cbBuffer == -1)
        {
            strResponse.CopyFrom((CHAR*)pBuffer);
        }
        else
        {
            strResponse.CopyFrom((CHAR*)pBuffer, 0, cbBuffer);
        }
        return S_OK;
    }

    const CHAR* cstr()
    {
        return strResponse.cstr();
    }

private:

    CLargeStr strResponse;
};

// ---------------------------------------------------------------------------------------
// CSGNotificationsBlock - rolls up the xmgmtc "e :sg healthcheck" results, which is 
// really a call to the notification servers' health.ashx url. If any notification server 
// fails, then we report red.
//
// No params.
// ---------------------------------------------------------------------------------------
class CSGNotificationsBlock :
    public CComObjectRoot,
    public INativeHealthBlock
{
public:
    BEGIN_COM_MAP(CSGNotificationsBlock)
        COM_INTERFACE_ENTRY(INativeHealthBlock)
    END_COM_MAP()

    CSGNotificationsBlock()
    {
    }

    virtual ~CSGNotificationsBlock()
    {
    }

    virtual HRESULT __stdcall DoCheck(
        IN  BSTR bstrBlockParams,
        OUT enum HealthStatusEnum *pHealthStatus,
        OUT BSTR *pbstrErrorDetails,
        OUT BSTR *pbstrExtendedInfo
        )
    {
        CHealthXomControlResponder xomResponder;
        SgServiceNotifyHealthCheck(0, &xomResponder);

        // Report results

        CComBSTR bstrExtendedInfo(xomResponder.cstr());
        if (!bstrExtendedInfo)
        {
            return E_OUTOFMEMORY;
        }
        *pbstrExtendedInfo = bstrExtendedInfo.Detach();

        // Look for errors. This is so the hard way.
        //
        // Count attempts (lines). Then count successful replies.

        DWORD cAttempts = 0;
        DWORD cSuccesses = 0;
        const char *psz = xomResponder.cstr();

        while (psz = strstr(psz, "\n"))
        {
            cAttempts++;
            psz++;
        }

        psz = xomResponder.cstr();
        while (psz = strstr(psz, "- OK"))
        {
            cSuccesses++;
            psz++;
        }

        // Report errors or success

        if (cAttempts != cSuccesses)
        {
            CSmallStr str;
            str.Format("Error, %d notification servers but only %d good responses", cAttempts, cSuccesses);
            *pbstrErrorDetails = CComBSTR(str.cstr()).Detach();
            *pHealthStatus = HealthStatusEnum_Red;
        }
        else
        {
            *pHealthStatus = HealthStatusEnum_Green;
        }

        return S_OK;
    }

};


// ---------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------


CComPtr<IHealthInterop>                     g_healthInterop;
CComObjectNoLock<CSGHealthStatsBlock>*      g_pBlockHealthStats = NULL;
CComObjectNoLock<CSGNotificationsBlock>*    g_pBlockNotifications = NULL;

BOOL SgHealthInit(CComBSTR &bstrComponent)
{
    HRESULT hr;

    // FRAMEWORK 

    //
    // Create the healthcheck interop
    //
    hr = g_healthInterop.CoCreateInstance( __uuidof(HealthInterop) );
    if (FAILED(hr))
    {
        SgEventSz(CONFIG_ERROR,
            "Failed to create the XblHealthcheck COM object. Verify that "
            "xblhealthcheck.dll is installed correctly in the GAC and "
            "regasm.exe has been called for it. hr = 0x%08x",
            hr
            );
        return FALSE;
    }

    //
    // Initialize health framework
    //
    hr = g_healthInterop->Initialize(bstrComponent, (LONG_PTR) ::GetModuleHandle(NULL));
    if (FAILED(hr))
    {
        SgEventSz(
            CONFIG_ERROR,
            "Failed to call the XblHealthcheck Initialize function. Verify that "
            "xblhealthcheck.dll is installed correctly in the GAC. hr = 0x%08x",
            hr
            );
        return FALSE;
    }


    // CUSTOM HEALTHBLOCKS

    //
    // Create our custom healthblocks. Don't forget to AddRef() them once.
    //
    g_pBlockHealthStats = new CComObjectNoLock<CSGHealthStatsBlock>();
    if (g_pBlockHealthStats == NULL)
    {
        SgEventSz(CONFIG_ERROR, "Out of memory creating the CSGHealthStatsBlock object. hr=0x%X", hr);
        return FALSE;
    }
    g_pBlockHealthStats->AddRef();

    g_pBlockNotifications = new CComObjectNoLock<CSGNotificationsBlock>();
    if (g_pBlockNotifications == NULL)
    {
        SgEventSz(CONFIG_ERROR, "Out of memory creating the CSGNotificationsBlock object. hr=0x%X", hr);
        return FALSE;
    }
    g_pBlockNotifications->AddRef();


    //
    // Register our custom healthblocks
    //
    hr = g_healthInterop->RegisterNativeHealthBlock(
        g_pBlockHealthStats, 
        CComBSTR(L"native.sg.SgHealthStats"), 
        ResourceTypeEnum_Local);
    if (FAILED(hr))
    {
        SgEventSz(
            CONFIG_ERROR,
            "Failed to register SgHealthStats. Verify that "
            "xblhealthcheck.dll is installed correctly in the GAC. hr = 0x%08x",
            hr);
        return FALSE;
    }

    hr = g_healthInterop->RegisterNativeHealthBlock(
        g_pBlockNotifications, 
        CComBSTR(L"native.sg.SgNotifications"), 
        ResourceTypeEnum_Remote);
    if (FAILED(hr))
    {
        SgEventSz(
            CONFIG_ERROR,
            "Failed to register SgNotifications. Verify that "
            "xblhealthcheck.dll is installed correctly in the GAC. hr = 0x%08x",
            hr);
        return FALSE;
    }


    return (TRUE);
}

void SgHealthTerm()
{
    if (g_pBlockHealthStats)
    {
        g_pBlockHealthStats->Release();
    }

    if (g_pBlockNotifications)
    {
        g_pBlockNotifications->Release();
    }

    g_healthInterop.Release();
}


#endif // SG_FEATURE_CONFIG_DB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgkerb.cpp ===
// ---------------------------------------------------------------------------------------
// sgkerb.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#include "sgasn1.h"
#include "sgkrb5.h"
#include "md5.h"
#include "stdlib.h"

#ifdef SG_FEATURE_INSECURE
BOOL g_fInhibitKerbSkew;
#endif


extern UINT g_iKerbApReqTimeDeltaLimitInMinutes;

//
// a lot of the events thrown in this file use the same parameters. For better
// readability, let's define a macro
//

#define SgKerbEvent(eid, txt) \
    SgEventPacketWithText(eid, ppkt, ppkt->_pIpHdr->_ipaSrc, \
                          ppkt->_pXspHdr->_ipportSrc, 0, NULL, txt)

#define KerbString(v) \
    ((v == NULL) ? "(null1)" : \
     (v->value == NULL) ? "(null2)" : \
     (v->value))

// ---------------------------------------------------------------------------------------

#define XBOX_REALM                  "xbox.com"
#define SITE_NAME_PREFIX            "site"

#ifdef SG_FEATURE_LSP
#define SECURITY_GATEWAY_SERVICE    "ts"
#else
#define SECURITY_GATEWAY_SERVICE    "sg"
#endif

#define SCRATCH_MEMORY_SIZE_FOR_VerifyApRequest 2000
#define SCRATCH_MEMORY_SIZE_FOR_BuildApReply    2000

//+-------------------------------------------------------------------------


typedef LARGE_INTEGER TimeStamp, *PTimeStamp;

typedef struct _KERB_MESSAGE_BUFFER {
    ULONG BufferSize;
    PUCHAR Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

// ---------------------------------------------------------------------------------------
// SgConvertAuthData2ToAuthData4
// ---------------------------------------------------------------------------------------

void SgConvertAuthData2ToAuthData4( const CAuthData2* pOldAuthData, CAuthData4* pNewAuthData )
{
    ZeroMemory(pNewAuthData, sizeof(*pNewAuthData));

    // First the easy part
    pNewAuthData->wAuthDataVersion = XONLINE_XENON2_AUTHDATA_VERSION;
    pNewAuthData->wAuthDataSize = sizeof( *pNewAuthData );
    pNewAuthData->clientVersion = pOldAuthData->clientVersion;
    pNewAuthData->dwTitleID= pOldAuthData->dwTitleID;
    pNewAuthData->dwTitleVersion = pOldAuthData->dwTitleVersion;
    pNewAuthData->dwTitleRegion = pOldAuthData->dwTitleRegion;
    pNewAuthData->qwXboxID = pOldAuthData->qwXboxID;
    memcpy( pNewAuthData->users, pOldAuthData->users, sizeof( pNewAuthData->users ) );
    memcpy( pNewAuthData->afltTrustFactor, pOldAuthData->afltTrustFactor, sizeof( pNewAuthData->afltTrustFactor ) );
    memcpy( pNewAuthData->dwAltTitleID, pOldAuthData->dwAltTitleID, sizeof( pNewAuthData->dwAltTitleID ) );
    memcpy( pNewAuthData->abKey, pOldAuthData->abKey, sizeof( pNewAuthData->abKey ) );

    // Values that are new to AuthData3 set to defaults
    pNewAuthData->dwConsoleRegion = 0;
    pNewAuthData->dwMediaID = 0;
    pNewAuthData->wLanguageID = 0;
    pNewAuthData->dwAuthDataFlags = 0;
    pNewAuthData->wNumExtendedServices = 0;
    pNewAuthData->dwMachinePrivileges[0] = 0;
    memset( pNewAuthData->dwBaseServices, 0, sizeof( pNewAuthData->dwBaseServices ) );
    memset( pNewAuthData->dwExtendedServices, 0, sizeof( pNewAuthData->dwExtendedServices ) );
    memset( pNewAuthData->dwUserPrivileges, 0, sizeof( pNewAuthData->dwUserPrivileges ) );

    // Values that are new to AuthData4 set to defaults
    pNewAuthData->fltConsoleTrustFactor = 0;
    pNewAuthData->flowToken.flowToken = 0;
    memset( pNewAuthData->abReserved, 0, sizeof( pNewAuthData->abReserved) );

    // Convert AuthData2 services to AuthData3 services and privileges
    for( UINT iServiceID = 0; iServiceID < pOldAuthData->dwNumServices; iServiceID++ )
    {
        if( 0 == pOldAuthData->dwServiceID[ iServiceID ] )
        {
            continue;
        }

        if( XONLINE_MAX_BASE_SERVICES_ID > pOldAuthData->dwServiceID[ iServiceID ] )
        {
            DWORD svcId = pOldAuthData->dwServiceID[iServiceID];
            DWORD idx = svcId / (8 * sizeof(DWORD));
            DWORD shift = svcId - (idx * 8 * sizeof(DWORD));
            pNewAuthData->dwBaseServices[ idx ] |= 1 << shift;
        }
        else if( XONLINE_MAX_DWORD_SERVICEIDS > pNewAuthData->wNumExtendedServices )
        {
            // Note: this IF clause will fill in the first 4 extended services
            // from the old ticket and then no more.
            pNewAuthData->dwExtendedServices[ pNewAuthData->wNumExtendedServices ] = pOldAuthData->dwServiceID[ iServiceID ];
            pNewAuthData->wNumExtendedServices++;
        }
    }
}

// ---------------------------------------------------------------------------------------
// SgConvertAuthData3ToAuthData4
// ---------------------------------------------------------------------------------------

void SgConvertAuthData3ToAuthData4( const CAuthData3* pOldAuthData, CAuthData4* pNewAuthData )
{
    ZeroMemory(pNewAuthData, sizeof(*pNewAuthData));

    // First the easy part
    pNewAuthData->wAuthDataVersion    = XONLINE_XENON2_AUTHDATA_VERSION;
    pNewAuthData->wAuthDataSize       = sizeof( *pNewAuthData );
    pNewAuthData->clientVersion       = pOldAuthData->clientVersion;
    pNewAuthData->dwTitleID           = pOldAuthData->dwTitleID;
    pNewAuthData->dwTitleVersion      = pOldAuthData->dwTitleVersion;
    pNewAuthData->dwTitleRegion       = pOldAuthData->dwTitleRegion;
    pNewAuthData->dwConsoleRegion     = pOldAuthData->dwConsoleRegion;
    pNewAuthData->dwMediaID           = pOldAuthData->dwMediaID;
    pNewAuthData->wLanguageID         = pOldAuthData->wLanguageID;
    pNewAuthData->dwAuthDataFlags     = pOldAuthData->dwAuthDataFlags;
    pNewAuthData->qwXboxID            = pOldAuthData->qwXboxID;
    memcpy( pNewAuthData->users, pOldAuthData->users, sizeof( pNewAuthData->users ) );
    memcpy( pNewAuthData->afltTrustFactor, pOldAuthData->afltTrustFactor, sizeof( pNewAuthData->afltTrustFactor ) );
    memcpy( pNewAuthData->dwAltTitleID, pOldAuthData->dwAltTitleID, sizeof( pNewAuthData->dwAltTitleID ) );

    // Next copy the parts that changed. The big change from CAuthData3 to
    // CAuthData4 is way that privileges are handled.
    //
    // The easy part of that is the 'extended' Services. In CAuthData3, they are
    // stored in dwServiceID, with the number of active services stored in
    // wNumDwordServices. For CAuthData4, these fields are renamed to
    // dwExtendedServices and wNumExtendedServices respectively.
    //
    // The hard part is the privilege bits. In CAuthData3, 256 'privilege' bits
    // can found within dwPrivileges. However, they are effectively partitioned
    // in the following manner:
    //   bits   0 - 127 'base' services
    //   bits 128 - 159 'machine' privileges
    //   bits 160 - 255 'user' privileges
    // Note that the CAuthData3 'user' privileges were least common denomiator.
    // Either every user in the ticket had them, or the bit wasn't set.
    //
    // For CAuthData4, the 'base' services and 'machine' privileges are
    // explicitly carved out in the ticket and the 'user' privileges are
    // actually per-user. So for the conversition routine, we set the
    // user privileges to all the users.
    memcpy( pNewAuthData->dwBaseServices, pOldAuthData->dwPrivileges, sizeof( pNewAuthData->dwBaseServices ) );
    pNewAuthData->dwMachinePrivileges[0] = pOldAuthData->dwPrivileges[4];
    for ( UINT u = 0; u < XONLINE_MAX_LOGON_USERS; ++u)
    {
        if (pNewAuthData->users[u].qwUserID == 0)
        {
            continue;
        }
        memcpy( pNewAuthData->dwUserPrivileges[u], &(pOldAuthData->dwPrivileges[5]), sizeof( pNewAuthData->dwUserPrivileges[u] ) );
    }
    memcpy( pNewAuthData->dwExtendedServices, pOldAuthData->dwServiceID, sizeof( pNewAuthData->dwExtendedServices ) );
    pNewAuthData->wNumExtendedServices = pOldAuthData->wNumDwordServices;

    // Values that are new to AuthData4 set to defaults
    pNewAuthData->fltConsoleTrustFactor = 0;
    pNewAuthData->flowToken.flowToken = 0;
    memset( pNewAuthData->abReserved, 0, sizeof( pNewAuthData->abReserved) );

    // Finally the key is copied over
    memcpy( pNewAuthData->abKey, pOldAuthData->abKey, sizeof( pNewAuthData->abKey ) );
}

// ---------------------------------------------------------------------------------------
// SgConvertAuthData4ToAuthData3
// ---------------------------------------------------------------------------------------

void SgConvertAuthData4ToAuthData3( const CAuthData4* pOldAuthData, CAuthData3* pNewAuthData )
{
    ZeroMemory(pNewAuthData, sizeof(*pNewAuthData));

    // First the easy part
    pNewAuthData->wAuthDataVersion    = XONLINE_XENON_AUTHDATA_VERSION;
    pNewAuthData->wAuthDataSize       = sizeof( *pNewAuthData );
    pNewAuthData->clientVersion       = pOldAuthData->clientVersion;
    pNewAuthData->dwTitleID           = pOldAuthData->dwTitleID;
    pNewAuthData->dwTitleVersion      = pOldAuthData->dwTitleVersion;
    pNewAuthData->dwTitleRegion       = pOldAuthData->dwTitleRegion;
    pNewAuthData->dwConsoleRegion     = pOldAuthData->dwConsoleRegion;
    pNewAuthData->dwMediaID           = pOldAuthData->dwMediaID;
    pNewAuthData->wLanguageID         = pOldAuthData->wLanguageID;
    pNewAuthData->dwAuthDataFlags     = pOldAuthData->dwAuthDataFlags;
    pNewAuthData->qwXboxID            = pOldAuthData->qwXboxID;

    C_ASSERT(sizeof(pNewAuthData->users) == sizeof(pOldAuthData->users));
    C_ASSERT(sizeof(pNewAuthData->afltTrustFactor) == sizeof(pOldAuthData->afltTrustFactor));
    C_ASSERT(sizeof(pNewAuthData->dwAltTitleID) == sizeof(pOldAuthData->dwAltTitleID));

    memcpy( pNewAuthData->users, pOldAuthData->users, sizeof( pNewAuthData->users ) );
    memcpy( pNewAuthData->afltTrustFactor, pOldAuthData->afltTrustFactor, sizeof( pNewAuthData->afltTrustFactor ) );
    memcpy( pNewAuthData->dwAltTitleID, pOldAuthData->dwAltTitleID, sizeof( pNewAuthData->dwAltTitleID ) );

    // Next copy the parts that changed. The big change from CAuthData3 to
    // CAuthData4 is way that privileges are handled. See SgConvertAuthData3ToAuthData4 
    // for more info. We have to go from having per-user privileges to a single 
    // least-common set of privileges for everybody.
    //
    // dwBaseServices - 128 bits
    // dwMachinePrivileges - 32 bits
    // dwUserPrivileges - 96 bits

    UINT dwPrivilegeIdx = 0;
    memcpy( &pNewAuthData->dwPrivileges[dwPrivilegeIdx], pOldAuthData->dwBaseServices, sizeof( pOldAuthData->dwBaseServices ) );
    dwPrivilegeIdx += XONLINE_NUM_BASE_SERVICES_DWORDS;
    memcpy( &pNewAuthData->dwPrivileges[XONLINE_NUM_BASE_SERVICES_DWORDS], pOldAuthData->dwMachinePrivileges, sizeof( pOldAuthData->dwMachinePrivileges) );
    dwPrivilegeIdx += XONLINE_NUM_MACHINE_PRIVILEGES_DWORDS;
    for ( UINT i = 0; i < XONLINE_NUM_USER_PRIVILEGES_DWORDS; i++)
    {
        DWORD mask = 0xFFFFFFFF;
        DWORD dwNumUsers = 0;
        for ( UINT u = 0; u < XONLINE_MAX_LOGON_USERS; ++u)
        {
            if (pNewAuthData->users[u].qwUserID == 0)
            {
                continue;
            }
            mask = mask & pOldAuthData->dwUserPrivileges[u][i];
            dwNumUsers++;
        }
        if (dwNumUsers == 0)
        {
            mask = 0;
        }
        pNewAuthData->dwPrivileges[dwPrivilegeIdx++] = mask;
    }

    // Run through all 256 bits and count them
    pNewAuthData->wNumPrivileges = 0;
    for ( UINT i = 0; i < ARRAYSIZE(pNewAuthData->dwPrivileges); i++)
    {
        // Count bits in the DWORD
        DWORD mask = pNewAuthData->dwPrivileges[i];
        while (mask != 0)
        {
            pNewAuthData->wNumPrivileges++;
            mask &= mask - 1;
        }
    }

    // DWORD services
    C_ASSERT(sizeof(pNewAuthData->dwServiceID) == sizeof(pOldAuthData->dwExtendedServices));
    memcpy( pNewAuthData->dwServiceID, pOldAuthData->dwExtendedServices, sizeof( pNewAuthData->dwServiceID) );
    pNewAuthData->wNumDwordServices = pOldAuthData->wNumExtendedServices;

    // Finally the key is copied over
    C_ASSERT(sizeof(pNewAuthData->abKey) == sizeof(pOldAuthData->abKey));
    memcpy( pNewAuthData->abKey, pOldAuthData->abKey, sizeof( pNewAuthData->abKey ) );
}

// ---------------------------------------------------------------------------------------
// SgCrackNullApReq
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_INSECURE
BOOL SgCrackNullApReq(CPacket * ppkt)
{
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExNullApReq *   pKeyExNullApReq  = (CKeyExNullApReq *)pKeyExCtx->_pKeyExApReq;
    TimeStamp           LifeTime;

    if (pKeyExNullApReq->_cbEnt != sizeof(*pKeyExNullApReq))
    {
        TraceSz(RecvDiscard, "%s: pKeyExNullApReq->_cbEnt (%d bytes) should be %d bytes",
                 ppkt->Str(), pKeyExNullApReq->_cbEnt, sizeof(*pKeyExNullApReq));
        return(FALSE);
    }

    pKeyExCtx->_dwSiteId  = SITEID_NULL;
    BYTE        abKey[16];

    if (!SgSiteInfoLookupKey(SITEID_NULL, 0, abKey))
    {
        TraceSz(RecvDiscard, "%s: SgCrackNullApReq2 failed to find SITEID_NULL version 0 key", ppkt->Str());
        return(FALSE);
    }

    Assert(sizeof(pKeyExCtx->_abSha) == sizeof(pKeyExNullApReq->_abSha));
    memcpy(pKeyExCtx->_abSha, pKeyExNullApReq->_abSha, sizeof(pKeyExCtx->_abSha));

    KerbSetTimeInMinutes(&LifeTime, 240);
    pKeyExCtx->_liTime = pKeyExNullApReq->_liTime;
    pKeyExCtx->_liEndTime = pKeyExNullApReq->_liTime.QuadPart + LifeTime.QuadPart;
    pKeyExCtx->_dwLifetimeInSeconds = KerbGetTimeInSeconds( LifeTime );

    if (pKeyExNullApReq->_AuthData.GetCb() != sizeof(pKeyExNullApReq->_AuthData))
    {
        TraceSz(RecvDiscard, "%s: SgCrackNullApReq2 auth-data (%d bytes) is wrong size (%d bytes)",
                 ppkt->Str(), pKeyExNullApReq->_AuthData.GetCb(), sizeof(pKeyExNullApReq->_AuthData));
        return(FALSE);
    }

    pKeyExCtx->_AuthData = pKeyExNullApReq->_AuthData;

    Assert(sizeof(pKeyExCtx->_puid) == sizeof(pKeyExNullApReq->_AuthData.qwXboxID));
    memcpy(&pKeyExCtx->_puid, &pKeyExNullApReq->_AuthData.qwXboxID, sizeof(pKeyExCtx->_puid));

    memset(pKeyExCtx->_abKey, 0, sizeof(pKeyExCtx->_abKey));

    // TODO: Update for CAuthData3
/*
    TraceSz(KerbVerbose, "%s: [AuthData2]", ppkt->Str());
    TraceSz(KerbVerbose, "%s: [ wAuthDataVersion = %d]", ppkt->Str(), pKeyExCtx->_AuthData.wAuthDataVersion);
    TraceSz(KerbVerbose, "%s: [ wAuthDataSize    = %d]", ppkt->Str(), pKeyExCtx->_AuthData.wAuthDataSize);
    TraceSz(KerbVerbose, "%s: [ clientVersion    = %d.%d.%d.%d]", ppkt->Str(),
             pKeyExCtx->_AuthData.clientVersion.wMajorVersion, pKeyExCtx->_AuthData.clientVersion.wMinorVersion,
             pKeyExCtx->_AuthData.clientVersion.wBuildNumber, pKeyExCtx->_AuthData.clientVersion.wQFENumber);
    TraceSz(KerbVerbose, "%s: [ title            = %08X, %08X, %08X]", ppkt->Str(),
             pKeyExCtx->_AuthData.dwTitleID, pKeyExCtx->_AuthData.dwTitleVersion, pKeyExCtx->_AuthData.dwTitleRegion);
    TraceSz(KerbVerbose, "%s: [ qwXboxID         = %I64X]", ppkt->Str(), pKeyExCtx->_AuthData.qwXboxID);
    TraceSz(KerbVerbose, "%s: [ users            = %I64X:%X, %I64X:%X, %I64X:%X, %I64X:%X]", ppkt->Str(),
             pKeyExCtx->_AuthData.users[0].qwUserID, pKeyExCtx->_AuthData.users[0].dwUserFlags,
             pKeyExCtx->_AuthData.users[1].qwUserID, pKeyExCtx->_AuthData.users[1].dwUserFlags,
             pKeyExCtx->_AuthData.users[2].qwUserID, pKeyExCtx->_AuthData.users[2].dwUserFlags,
             pKeyExCtx->_AuthData.users[3].qwUserID, pKeyExCtx->_AuthData.users[3].dwUserFlags);
    TraceSz(KerbVerbose, "%s: [ dwNumServices    = %d]", ppkt->Str(), pKeyExCtx->_AuthData.dwNumServices);
    for (UINT i = 0; i < pKeyExCtx->_AuthData.dwNumServices; i++)
        TraceSz(KerbVerbose, "%s: [  %d]", ppkt->Str(), pKeyExCtx->_AuthData.dwServiceID[i]);
*/
//    TraceSz(KerbVerbose, "%s: [ afltTrustFactor  = %f, %f, %f, %f]", ppkt->Str(),
//             pKeyExCtx->_AuthData.afltTrustFactor[0], pKeyExCtx->_AuthData.afltTrustFactor[1],
//             pKeyExCtx->_AuthData.afltTrustFactor[2], pKeyExCtx->_AuthData.afltTrustFactor[3]);

    return(TRUE);
}
#endif // SG_FEATURE_INSECURE

// ---------------------------------------------------------------------------------------
// SgBuildNullApRep
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_INSECURE
BOOL SgBuildNullApRep(CPacket * ppkt)
{

    CKeyExCtx *         pKeyExCtx       = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExNullApRep *   pKeyExNullApRep = &pKeyExCtx->_NullApRep;

    pKeyExNullApRep->_wType = KEYEX_TYPE_NULL_APREP;
    pKeyExNullApRep->_cbEnt = sizeof(CKeyExNullApRep);
    Assert(sizeof(pKeyExNullApRep->_abSha) == sizeof(pKeyExCtx->_abSha));
    memcpy(pKeyExNullApRep->_abSha, pKeyExCtx->_abSha, sizeof(pKeyExNullApRep->_abSha));
    return(TRUE);
}
#endif // SG_FEATURE_INSECURE

// ---------------------------------------------------------------------------------------

typedef LONG KERBERR, *PKERBERR;

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;
#define                     KERB_KDC_OPTIONS_reserved 0x80000000
#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
#define                     KERB_KDC_OPTIONS_proxy 0x08000000
#define                     KERB_KDC_OPTIONS_postdated 0x02000000
#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
#define                     KERB_KDC_OPTIONS_unused7 0x01000000
#define                     KERB_KDC_OPTIONS_renewable 0x00800000
#define                     KERB_KDC_OPTIONS_unused9 0x00400000
#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
#define                     KERB_KDC_OPTIONS_renew 0x00000002
#define                     KERB_KDC_OPTIONS_validate 0x00000001


#define                     KERB_AP_OPTIONS_reserved 0x80000000
#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
#define                     KERB_AP_OPTIONS_reserved1 0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses          client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until                       renew_until
#define KERB_CRED_INFO_renew_until                                      renew_until
#define KERB_KDC_REQUEST_BODY_renew_until                       renew_until
#define KERB_KDC_REQUEST_BODY_server_name                       server_name
#define KERB_KDC_REQUEST_preauth_data                           preauth_data
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number         sequence_number
#define KERB_AUTHENTICATOR_subkey                                       subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                          subkey
#define KERB_TGT_REQUEST_server_name                            server_name
#define KERB_ERROR_client_name                                          client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_KDC_REQUEST_BODY_client_name                       client_name
#define KERB_KDC_REPLY_preauth_data                                     preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime                      starttime
#define KERB_CRED_INFO_starttime                                        starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until            renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data        authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                         starttime
#define KERB_ENCRYPTED_PRIV_sequence_number                     sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                         starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses       client_addresses

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response

//
// Name types
//

#define KRB_NT_UNKNOWN   0                // Name type not known
#define KRB_NT_PRINCIPAL 1                // Just the name of the principal as in DCE, or for users
#define KRB_NT_PRINCIPAL_AND_ID -131      // Name of the principal and its SID.
#define KRB_NT_SRV_INST  2                // Service and other unique instance (krbtgt)
#define KRB_NT_SRV_INST_AND_ID -132       // SPN and SID
#define KRB_NT_SRV_HST   3                // Service with host name as instance (telnet, rcommands)
#define KRB_NT_SRV_XHST  4                // Service with host as remaining components
#define KRB_NT_UID       5                // Unique ID
#define KRB_NT_ENTERPRISE_PRINCIPAL 10    // UPN or SPN
#define KRB_NT_ENT_PRINCIPAL_AND_ID -130  // UPN and SID

//
// MS extensions, negative according to the RFC
//

#define KRB_NT_MS_PRINCIPAL         -128        // NT4 style name

#define KRB_NT_MS_PRINCIPAL_AND_ID  -129        // nt4 style name with sid

#define KERB_IS_MS_PRINCIPAL(_x_) (((_x_) <= KRB_NT_MS_PRINCIPAL) || ((_x_) >= KRB_NT_ENTERPRISE_PRINCIPAL))

//
// Pre-auth data types
//
#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */
#define KRB5_PADATA_S4U                 129 /* S4U */
#define KRB5_PADATA_WITH_IDENTITY       130 /* authenticate multiple identities */
#define KRB5_PADATA_PAC_REQUEST_EX      131 /* allow client do request, ignore PAC or specify what sections */

//
// PAC type for PASSPORT PUID
//
#define PAC_PASSPORT_PUIDS              20

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE       64
#define KERB_AUTH_SESAME        65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC

//
// Transited realm compression types:
//

#define DOMAIN_X500_COMPRESS            1

//
// Transport information
//

#define KERB_KDC_PORT                   88
#define KERB_KPASSWD_PORT               464

//
// KDC service principal
//
#define KDC_PRINCIPAL_NAME              "krbtgt"
#define KERB_HOST_STRING                "host"
#define SECURITY_GATEWAY_STRING         "sg"

//
// address types
//

#define KERB_ADDRTYPE_INET              0x2
#define KERB_ADDRTYPE_NETBIOS           0x14    // BUGBUG: need to register

//
// Misc. Flags
//

#define KERB_EXPORT_KEY_FLAG 0x20000000

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21
#define KERB_PA_WITH_IDENTITY_SALT    1024

//
//Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2


//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5
#define KERB_DEFAULT_PREAUTH_TYPE       0

//
// BER encoding values
//

#define KERB_BER_APPLICATION_TAG 0xc0
#define KERB_BER_APPLICATION_MASK 0x1f
#define KERB_TGS_REQ_TAG 12
#define KERB_AS_REQ_TAG 10
#define KERB_TGS_REP_TAG 13
#define KERB_AS_REP_TAG 11
#define KERB_ERROR_TAG 30

//
// Common types
//

#define KerbFreeData(a,b)

#define KerbFreeTicket( Ticket )

KERBERR NTAPI
KerbMakeKey(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    );

KERBERR NTAPI
KerbCreateAuthenticator(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN PTimeStamp ptsTime,
    IN OPTIONAL PKERB_CHECKSUM Checksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackAuthenticator(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    );

#define KerbFreeAuthenticator( Authenticator )

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

#define KerbUnpackAsReply( pScratchMemoryAllocator, ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

#define KerbFreeAsReply( Request)

#define KerbUnpackTgsReply( pScratchMemoryAllocator, ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

#define KerbFreeTgsReply( Request)

#define KerbFreeKdcReplyBody( Request)

#define KerbPackAsRequest( pScratchMemoryAllocator, RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

#define KerbFreeAsRequest( Request)

#define KerbPackTgsRequest( pScratchMemoryAllocator, RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

#define KerbFreeTgsRequest( Request)

#define KerbPackEncryptedData( pScratchMemoryAllocator, EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

#define KerbUnpackEncryptedData( pScratchMemoryAllocator, EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

#define KerbFreeEncryptedData( EncryptedData)

#define KerbPackApRequest( pScratchMemoryAllocator, ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

#define KerbUnpackApRequest( pScratchMemoryAllocator, ApRequestMessage,ApRequestSize, ApRequest) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApRequestMessage), \
        (ApRequestSize), \
        KERB_AP_REQUEST_PDU, \
        (PVOID *) (ApRequest) \
        )

#define KerbFreeApRequest( Request)

#define KerbPackApReply( pScratchMemoryAllocator, ApReplyMessage, ApReplySize, MarshalledApReply ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApReplyMessage), \
        KERB_AP_REPLY_PDU, \
        (ApReplySize), \
        (MarshalledApReply) \
        )

#define KerbUnpackApReply( pScratchMemoryAllocator, ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

#define KerbFreeApReply( Reply)

#define KerbPackApReplyBody( pScratchMemoryAllocator, ApReplyBodyMessage, ApReplyBodySize, MarshalledApReplyBody ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApReplyBodyMessage), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (ApReplyBodySize), \
        (MarshalledApReplyBody) \
        )

#define KerbUnpackApReplyBody( pScratchMemoryAllocator, ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

#define KerbFreeApReplyBody( ReplyBody)

#define KerbUnmarshallTicket( pScratchMemoryAllocator, TicketMessage, TicketSize, Ticket ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (TicketMessage), \
        (TicketSize), \
        KERB_ENCRYPTED_TICKET_PDU, \
        (PVOID *) (Ticket) \
        )

#define KerbPackEncryptedCred( pScratchMemoryAllocator, EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

#define KerbUnpackEncryptedCred( pScratchMemoryAllocator, EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

#define KerbFreeEncryptedCred( EncryptedCred)

#define KerbPackKerbCred( pScratchMemoryAllocator, KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

#define KerbUnpackKerbCred( pScratchMemoryAllocator, MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

#define KerbPackKerbError( pScratchMemoryAllocator, ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

#define KerbUnpackKerbError( pScratchMemoryAllocator, ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

#define KerbFreeKerbError( Error )

#define KerbPackEncryptedTime( pScratchMemoryAllocator, EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

#define KerbUnpackEncryptedTime( pScratchMemoryAllocator, EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

#define KerbFreeEncryptedTime( EncryptedTime )

KERBERR
KerbAllocateEncryptionBuffer(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR NTAPI
KerbEncryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    );

inline
VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    )
{
}

inline
VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    )
{
}

KERBERR
KerbConstructPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN ULONG NameType,
    IN LPSTR pComp1,
    IN LPSTR pComp2 = NULL
    );

KERBERR
KerbMultiStringToPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR pMultiString,
    OUT PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbPrincipalNameToMultiString(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN DWORD dwMultiStringMaxLength,
    OUT LPSTR pMultiString
    );

BOOLEAN
KerbComparePrincipalNames(
    IN PKERB_PRINCIPAL_NAME Name1,
    IN PKERB_PRINCIPAL_NAME Name2
    );

KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    );

BOOLEAN
KerbCompareRealmNames(
    IN PKERB_REALM Realm1,
    IN PKERB_REALM Realm2
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

BOOLEAN
KerbCheckTimeSkew(
    IN PTimeStamp CurrentTime,
    IN PTimeStamp ClientTime,
    IN PTimeStamp AllowedSkew
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    );

KERBERR
KerbCreateApRequest(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM Checksum,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    );

BOOLEAN
KerbCompareObjectIds(
    IN PKERB_OBJECT_ID Object1,
    IN PKERB_OBJECT_ID Object2
    );

VOID
KerbGetCurrentTime(
    OUT PTimeStamp pCurrentTime
    );

#define DsysAssert(exp) Assert(exp)

//
//  Following macro is used to initialize UNICODE strings
//
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#define NULL_UNICODE_STRING {0 , 0, NULL }
#define EMPTY_UNICODE_STRING(s) { (s)->Buffer = NULL; (s)->Length = 0; (s)->MaximumLength = 0; }

#define KerbSetTime(_d_, _s_) (_d_)->QuadPart = (_s_)

#define KerbGetTime(_x_) ((_x_).QuadPart)
#define KerbGetTimeInSeconds(_x_) (DWORD) (((_x_).QuadPart) / (LONGLONG) 10000000)

#define KerbSetTimeInMinutes(_x_, _m_) (_x_)->QuadPart = (LONGLONG) 10000000 * 60 * (_m_)

#define KerbMapKerbNtStatusToNtStatus(x) (x)

NTSTATUS
KerbAddPacRequestPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    );

NTSTATUS
KerbAddXboxPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY ClientKey,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    );

VOID
KerbGetCurrentTime(
    OUT PTimeStamp pCurrentTime
    );

VOID
KerbUpdateCurrentTime(
    IN TimeStamp NewCurrentTime
    );

// Revision of the Kerberos Protocol.  MS uses Version 5, Revision 6
#define KERBEROS_VERSION    5
#define KERBEROS_REVISION   6

// Encryption Types:
// These encryption types are supported by the default MS KERBSUPP DLL
// as crypto systems.  Values over 127 are local values, and may be changed
// without notice.

#define KERB_ETYPE_NULL             0
#define KERB_ETYPE_DES_CBC_CRC      1
#define KERB_ETYPE_DES_CBC_MD4      2
#define KERB_ETYPE_DES_CBC_MD5      3

#define KERB_ETYPE_OLD_RC4_MD4          128
#define KERB_ETYPE_OLD_RC4_PLAIN        129
#define KERB_ETYPE_OLD_RC4_LM           130
#define KERB_ETYPE_OLD_RC4_SHA          131
#define KERB_ETYPE_OLD_DES_PLAIN        132

#define KERB_ETYPE_RC4_MD4          -128
#define KERB_ETYPE_RC4_PLAIN2       -129
#define KERB_ETYPE_RC4_LM           -130
#define KERB_ETYPE_RC4_SHA          -131
#define KERB_ETYPE_DES_PLAIN        -132
#define KERB_ETYPE_RC4_HMAC_OLD     -133
#define KERB_ETYPE_RC4_PLAIN_OLD    -134
#define KERB_ETYPE_RC4_HMAC_OLD_EXP -135
#define KERB_ETYPE_RC4_PLAIN_OLD_EXP -136
#define KERB_ETYPE_RC4_PLAIN        -140
#define KERB_ETYPE_RC4_PLAIN_EXP    -141

//
// In use types
//
#define KERB_ETYPE_DES_CBC_MD5_NT                          20
#define KERB_ETYPE_RC4_HMAC_NT                             23
#define KERB_ETYPE_RC4_HMAC_NT_EXP                         24

// Checksum algorithms.
// These algorithms are keyed internally for our use.

#define KERB_CHECKSUM_NONE  0
#define KERB_CHECKSUM_CRC32         1
#define KERB_CHECKSUM_MD4           2
#define KERB_CHECKSUM_KRB_DES_MAC   4
#define KERB_CHECKSUM_MD5           7
#define KERB_CHECKSUM_MD5_DES       8


#define KERB_CHECKSUM_LM            -130
#define KERB_CHECKSUM_SHA1          -131
#define KERB_CHECKSUM_REAL_CRC32    -132
#define KERB_CHECKSUM_DES_MAC       -133
#define KERB_CHECKSUM_DES_MAC_MD5   -134
#define KERB_CHECKSUM_MD25          -135
#define KERB_CHECKSUM_RC4_MD5       -136
#define KERB_CHECKSUM_MD5_HMAC      -137                // used by netlogon
#define KERB_CHECKSUM_HMAC_MD5      -138                // used by Kerberos

#define AUTH_REQ_ALLOW_FORWARDABLE      0x00000001
#define AUTH_REQ_ALLOW_PROXIABLE        0x00000002
#define AUTH_REQ_ALLOW_POSTDATE         0x00000004
#define AUTH_REQ_ALLOW_RENEWABLE        0x00000008
#define AUTH_REQ_ALLOW_NOADDRESS        0x00000010
#define AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY  0x00000020
#define AUTH_REQ_ALLOW_VALIDATE         0x00000040
#define AUTH_REQ_VALIDATE_CLIENT        0x00000080
#define AUTH_REQ_OK_AS_DELEGATE         0x00000100
#define AUTH_REQ_PREAUTH_REQUIRED       0x00000200


#define AUTH_REQ_PER_USER_FLAGS         (AUTH_REQ_ALLOW_FORWARDABLE \
                                         AUTH_REQ_ALLOW_PROXIABLE \
                                         AUTH_REQ_ALLOW_POSTDATE \
                                         AUTH_REQ_ALLOW_RENEWABLE \
                                         AUTH_REQ_ALLOW_VALIDATE )
//
// Ticket Flags:
//
#define KERB_TICKET_FLAGS_reserved          0x80000000
#define KERB_TICKET_FLAGS_forwardable       0x40000000
#define KERB_TICKET_FLAGS_forwarded         0x20000000
#define KERB_TICKET_FLAGS_proxiable         0x10000000
#define KERB_TICKET_FLAGS_proxy             0x08000000
#define KERB_TICKET_FLAGS_may_postdate      0x04000000
#define KERB_TICKET_FLAGS_postdated         0x02000000
#define KERB_TICKET_FLAGS_invalid           0x01000000
#define KERB_TICKET_FLAGS_renewable         0x00800000
#define KERB_TICKET_FLAGS_initial           0x00400000
#define KERB_TICKET_FLAGS_pre_authent       0x00200000
#define KERB_TICKET_FLAGS_hw_authent        0x00100000
#define KERB_TICKET_FLAGS_ok_as_delegate    0x00040000
#define KERB_TICKET_FLAGS_name_canonicalize 0x00010000
#define KERB_TICKET_FLAGS_reserved1         0x00000001


#define DS_INET_ADDRESS    1

//
// Registry driven globals (see Kerberos\readme.txt for details on these)
//

extern ULONG KerbGlobalKdcCallTimeout;
extern ULONG KerbGlobalKdcCallBackoff;
extern ULONG KerbGlobalKdcSendRetries;
extern ULONG KerbGlobalMaxDatagramSize;

//
// Useful globals
//

extern TimeStamp KerbGlobalWillNeverTime;

//
// From kerberr.h
//

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3


#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCPETED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KREBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)
//
// These are local definitions that should not be sent over the network
//

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )
#define KDC_ERR_NOT_RUNNING           ((KERBERR) 0x80000002 )

//
// From cryptdll.h
//

typedef PVOID   PCRYPT_STATE_BUFFER;

typedef NTSTATUS (NTAPI * PCRYPT_INITIALIZE_FN)(
    CScratchMemoryAllocator*,
    PUCHAR,
    ULONG,
    ULONG,
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_ENCRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DECRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DISCARD_FN)(
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_HASH_STRING_FN)(
    PUCHAR String,
    PUCHAR Buffer
    );

typedef NTSTATUS (NTAPI * PCRYPT_RANDOM_KEY_FN)(
    OPTIONAL PUCHAR Seed,
    OPTIONAL ULONG SeedLength,
    PUCHAR Key
    );

typedef NTSTATUS (NTAPI * PCRYPT_CONTROL_FN)(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    );

//
// functions for CryptControl
#define CRYPT_CONTROL_SET_INIT_VECT     0x1

typedef struct _CRYPTO_SYSTEM {
    ULONG EncryptionType;
    ULONG BlockSize;
    ULONG ExportableEncryptionType;
    ULONG KeySize;
    ULONG HeaderSize;
    ULONG PreferredCheckSum;
    ULONG Attributes;
    PWSTR Name;
    PCRYPT_INITIALIZE_FN Initialize;
    PCRYPT_ENCRYPT_FN Encrypt;
    PCRYPT_DECRYPT_FN Decrypt;
    PCRYPT_DISCARD_FN Discard;
    PCRYPT_HASH_STRING_FN HashString;
    PCRYPT_RANDOM_KEY_FN RandomKey;
    PCRYPT_CONTROL_FN Control;
} CRYPTO_SYSTEM, *PCRYPTO_SYSTEM;

#define CSYSTEM_USE_PRINCIPAL_NAME      0x01
#define CSYSTEM_EXPORT_STRENGTH         0x02
#define CSYSTEM_INTEGRITY_PROTECTED     0x04

extern PCRYPTO_SYSTEM pDefaultCryptoSystem;


//+-------------------------------------------------------------------------

ASN1octetstring_t*
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.auth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData != NULL ? &TempData->value.auth_data : NULL);
}

// ---------------------------------------------------------------------------------------
// SgCrackKerbApReq
// ---------------------------------------------------------------------------------------

BOOL SgCrackKerbApReq(CPacket * ppkt, BYTE * pb, UINT cb)
{
    KERBERR KerbErr;
    PKERB_AP_REQUEST Request = NULL;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    KERB_ENCRYPTION_KEY SiteKey;
    TimeStamp TimeNow, ClientTime, EndTime;
    TimeStamp TimePlus, TimeMinus, SkewTime;
    TimeStamp LifeTime;
    ASN1octetstring_t* pAuthData;
    DWORD TicketSize;
    DWORD AuthenticatorSize;
    DWORD dwSiteID;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    BYTE ScratchMemoryBufferMain[SCRATCH_MEMORY_SIZE_FOR_VerifyApRequest];
    BYTE ScratchMemoryBufferTemp[SCRATCH_MEMORY_SIZE_FOR_VerifyApRequest / 2];

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize(ScratchMemoryBufferMain, sizeof(ScratchMemoryBufferMain), ScratchMemoryBufferTemp, sizeof(ScratchMemoryBufferTemp) );
    if (pbScratchMemory == NULL)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_3, NULL);
        return(FALSE);
    }

    CKeyExCtx *         pKeyExCtx       = (CKeyExCtx *)ppkt->_abCtx;

    TraceSz(KerbVerbose, "%s: SgCrackKerbApReq got %d bytes", ppkt->Str(), cb );

    KerbErr = KerbUnpackApRequest(
                &ScratchMemoryAllocator,
                pb,
                cb,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_4, CSmallStr().Format(
                "KerbErr: %u", KerbErr).cstr());
        return(FALSE);
    }

    //
    // Check ticket version
    //
    if (Request->ticket.ticket_version != KERBEROS_VERSION)
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq incorrect ticket version", ppkt->Str());

        SgKerbEvent(INVALID_KERBEROS_TICKET_5, CSmallStr().Format(
                "Ticket version: %u", Request->ticket.ticket_version).cstr());

        return(FALSE);
    }

    //
    // Make sure ticket is for "sg/site?" at realm "xbox.com"
    //
    if (_stricmp(Request->ticket.realm, XBOX_REALM) != 0)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_6, CSmallStr().Format(
                "Realm: %s", Request->ticket.realm).cstr());
        return(FALSE);
    }

    if (Request->ticket.server_name.name_type != KRB_NT_SRV_INST)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_7, CSmallStr().Format(
                "Name-type: %u", Request->ticket.server_name.name_type).cstr());
        return(FALSE);
    }

    if (Request->ticket.server_name.name_string == NULL ||
        Request->ticket.server_name.name_string->value == NULL ||
        _stricmp(Request->ticket.server_name.name_string->value , SECURITY_GATEWAY_SERVICE) != 0)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_8, CSmallStr().Format(
                "Server-Name: %s",
                KerbString(Request->ticket.server_name.name_string)).cstr());
        return(FALSE);
    }

    if (Request->ticket.server_name.name_string->next == NULL ||
        Request->ticket.server_name.name_string->next->value == NULL ||
        _strnicmp(Request->ticket.server_name.name_string->next->value, SITE_NAME_PREFIX, sizeof(SITE_NAME_PREFIX)-1) != 0)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_9, CSmallStr().Format(
                "Site-Name: %s",
                KerbString(Request->ticket.server_name.name_string->next)).cstr());
        return(FALSE);
    }

    if (Request->ticket.server_name.name_string->next->next != NULL)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_10, NULL);
        return(FALSE);
    }

    if (Request->ticket.encrypted_part.encryption_type != KERB_ETYPE_RC4_HMAC_NT)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_11, CSmallStr().Format(
                "Encryption-type: %u", Request->ticket.encrypted_part.encryption_type).cstr());
        return(FALSE);
    }

    //
    // Extract the siteID from the ticket
    //
    dwSiteID = strtoul(&Request->ticket.server_name.name_string->next->value[sizeof(SITE_NAME_PREFIX)-1], NULL, 10);

    pKeyExCtx->_dwSiteId  = dwSiteID;

    BYTE abKey[16];

    if (!SgSiteInfoLookupKey(dwSiteID, Request->ticket.encrypted_part.version, abKey))
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed to find key to dwSiteId %08lX dwVersion %d",
                 ppkt->Str(), dwSiteID, Request->ticket.encrypted_part.version);

        SgKerbEvent(INVALID_KERBEROS_TICKET_12, CSmallStr().Format(
                "Site-id: 0x%x (%u) Key-version: %u", dwSiteID, dwSiteID,
                Request->ticket.encrypted_part.version).cstr());

        return(FALSE);
    }

    KerbCreateKeyFromBuffer(
            &SiteKey,
            abKey,
            sizeof(abKey),
            KERB_ETYPE_RC4_HMAC_NT
            );

    //
    // Decrypt the ticket (in place) using the key for the site
    //
    TicketSize = Request->ticket.encrypted_part.cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                &ScratchMemoryAllocator,
                &Request->ticket.encrypted_part,
                &SiteKey,
                KERB_TICKET_SALT,
                &TicketSize,
                Request->ticket.encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed to decrypt ticket for site %d", ppkt->Str(), dwSiteID);

        SgKerbEvent(INVALID_KERBEROS_TICKET_13, CSmallStr().Format(
                "KerbErr: %u", KerbErr).cstr());

        return(FALSE);
    }

    KerbErr = KerbUnpackData(
                &ScratchMemoryAllocator,
                Request->ticket.encrypted_part.cipher_text.value,
                TicketSize,
                KERB_ENCRYPTED_TICKET_PDU,
                (PVOID *) &EncryptedTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed to unpack ticket for site %d", ppkt->Str(), dwSiteID);

        SgKerbEvent(INVALID_KERBEROS_TICKET_14, CSmallStr().Format(
                "KerbErr: %u", KerbErr).cstr());

        return(FALSE);
    }

    //
    // Check the times on the ticket.
    //
    TimeNow.QuadPart = SgGetSystemTime();

    KerbSetTimeInMinutes(&SkewTime, g_iKerbApReqTimeDeltaLimitInMinutes);

    TimePlus.QuadPart = TimeNow.QuadPart + SkewTime.QuadPart;
    TimeMinus.QuadPart = TimeNow.QuadPart - SkewTime.QuadPart;

    KerbConvertGeneralizedTimeToLargeInt(
        &EndTime,
        &EncryptedTicket->endtime,
        0
        );

    //
    // Did the ticket expire already?
    //
#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitKerbSkew)
    {
        // Don't check for skew
    }
    else
#endif
    if ( EndTime.QuadPart < TimeMinus.QuadPart )
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq ticket expired to unpack ticket for site %d", ppkt->Str(), dwSiteID);

        SYSTEMTIME SysTime;
        memset(&SysTime, 0, sizeof(SysTime));
        FileTimeToSystemTime((FILETIME*)&EndTime.QuadPart, &SysTime);
        SgEventPacketLogWithText(INVALID_KERBEROS_TICKET_15, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                                 0, CTinyStr().Format(SYSTEMTIMEFMT, SYSTEMTIMEPRM(&SysTime)).cstr());

        return(FALSE);
    }

    //
    // Calculate the expiry time. Try to user the current SG time as the best
    // guess, but use the Skewed time if the ticket would count as expired.
    // 
    if (EndTime.QuadPart >= TimeNow.QuadPart) 
    {
        LifeTime.QuadPart = EndTime.QuadPart - TimeNow.QuadPart;
    }
    else if (EndTime.QuadPart >= TimeMinus.QuadPart) 
    {
        LifeTime.QuadPart = EndTime.QuadPart - TimeMinus.QuadPart;
    }
    else
    {
        //
        // Should never really happen since we would have failed cracking the ticket
        // otherwise. See above.
        // 
        LifeTime.QuadPart = 0;
    }

#ifdef NEED_TO_CHECK_FOR_POST_DATED_TICKETS
    //
    // Is the ticket valid yet?
    //
    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &StartTime,
            &EncryptedTicket->starttime,
            0
            );


        TicketFlags = KerbConvertFlagsToUlong(
                        &EncryptedTicket->flags
                        );
        //
        // Does the ticket start in the future?
        //
        if ( (StartTime.QuadPart > TimePlus.QuadPart) ||
            ((TicketFlags & KERB_TICKET_FLAGS_invalid) != 0 ))
        {
            TraceSz(RecvDiscard, "%s: SgCrackKerbApReq ticket is post dated for site %d", ppkt->Str(), dwSiteID);
            SgKerbEvent(INVALID_KERBEROS_TICKET_16, CSmallStr().Format(
                    "Start-Time: 0x%I64x Ticket-Flags: 0x%x",
                    StartTime.QuadPart, TicketFlags).cstr());

            return(FALSE);
        }
    }
#endif

    //
    // Now get the seession key from ticket
    //
    //Assert( sizeof(pKeyExCtx->_abKey) == EncryptedTicket->key.keyvalue.length );
    if ( sizeof(pKeyExCtx->_abKey) != EncryptedTicket->key.keyvalue.length )
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq session key of wrong length for site %d", ppkt->Str(), dwSiteID);

        SgKerbEvent(INVALID_KERBEROS_TICKET_17, CSmallStr().Format(
                "Key-Length: %u", EncryptedTicket->key.keyvalue.length).cstr());

        return(FALSE);
    }

    memcpy( pKeyExCtx->_abKey, EncryptedTicket->key.keyvalue.value, sizeof(pKeyExCtx->_abKey) );

    //
    // Now open up the authenticator
    //
    AuthenticatorSize = Request->authenticator.cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                &ScratchMemoryAllocator,
                &Request->authenticator,
                &EncryptedTicket->key,
                KERB_AP_REQ_AUTH_SALT,
                &AuthenticatorSize,
                Request->authenticator.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed to decrypt authenticator for site %d", ppkt->Str(), dwSiteID);
        SgKerbEvent(INVALID_KERBEROS_TICKET_18, CSmallStr().Format(
                "KerbErr: %u", KerbErr).cstr());

        return(FALSE);
    }

    //
    // Unpack authenticator
    //
    KerbErr = KerbUnpackData(
                &ScratchMemoryAllocator,
                Request->authenticator.cipher_text.value,
                AuthenticatorSize,
                KERB_AUTHENTICATOR_PDU,
                (PVOID *) &Authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed to unpack authenticator for site %d", ppkt->Str(), dwSiteID);
        SgKerbEvent(INVALID_KERBEROS_TICKET_19, CSmallStr().Format(
                "KerbErr: %u", KerbErr).cstr());

        return(FALSE);
    }

    //
    // Check the authenticator
    //
    if (Authenticator->authenticator_version != KERBEROS_VERSION)
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq bad authenticator version (%d)", ppkt->Str(), Authenticator->authenticator_version);
        SgKerbEvent(INVALID_KERBEROS_TICKET_20, CSmallStr().Format(
                "Version: %u", Authenticator->authenticator_version).cstr());

        return(FALSE);
    }

    if ((Authenticator->bit_mask & checksum_present) == 0)
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq no checksum present in authenticator", ppkt->Str());
        SgKerbEvent(INVALID_KERBEROS_TICKET_21, NULL);
        return(FALSE);
    }

    if (Authenticator->checksum.checksum_type != KERB_CHECKSUM_SHA1)
    {
        SgKerbEvent(INVALID_KERBEROS_TICKET_22, CSmallStr().Format(
                "Checksum-type: %u", Authenticator->checksum.checksum_type).cstr());
        return(FALSE);
    }

    //Assert(sizeof(pKeyExCtx->_abSha) == Authenticator->checksum.checksum.length);
    if (sizeof(pKeyExCtx->_abSha) != Authenticator->checksum.checksum.length)
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq bad authenticator checksum length (%d)", ppkt->Str(), Authenticator->checksum.checksum.length);
        SgKerbEvent(INVALID_KERBEROS_TICKET_23, CSmallStr().Format(
                "Checksum-length: %u", Authenticator->checksum.checksum.length).cstr());
        return(FALSE);
    }
    memcpy(pKeyExCtx->_abSha, Authenticator->checksum.checksum.value, sizeof(pKeyExCtx->_abSha));

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &Authenticator->client_time,
        Authenticator->client_usec
        );

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitKerbSkew)
    {
        // Don't check for skew
    }
    else
#endif
    if ( ClientTime.QuadPart < TimeMinus.QuadPart || TimePlus.QuadPart < ClientTime.QuadPart )
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq authenticator time out of skew range for site %d", ppkt->Str(), dwSiteID);
        SYSTEMTIME SysTime;
        memset(&SysTime, 0, sizeof(SysTime));
        FileTimeToSystemTime((FILETIME*)&ClientTime.QuadPart, &SysTime);
        SgEventPacketLogWithText(INVALID_KERBEROS_TICKET_24, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                                 0, CTinyStr().Format(SYSTEMTIMEFMT, SYSTEMTIMEPRM(&SysTime)).cstr());
        return(FALSE);
    }

    pKeyExCtx->_liTime = ClientTime;
    pKeyExCtx->_dwUsec = Authenticator->client_usec;
    pKeyExCtx->_liEndTime = EndTime;
    pKeyExCtx->_dwLifetimeInSeconds = KerbGetTimeInSeconds( LifeTime );

    if ((EncryptedTicket->bit_mask & KERB_AUTHENTICATOR_authorization_data_present) == 0)
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq no auth-data present", ppkt->Str());
        SgKerbEvent(INVALID_KERBEROS_TICKET_25, NULL);
        return(FALSE);
    }

    // Try to find AuthData4 first
    pAuthData = KerbFindAuthDataEntry( KERB_AUTH_DATA_XENON2, EncryptedTicket->authorization_data );
    if( NULL != pAuthData && NULL != pAuthData->value )
    {
        // The entry should be CAuthData4, validate it and copy it over

        if( sizeof( CAuthData4 ) + XONLINE_KEY_LENGTH > pAuthData->length )
        {
            TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data is too small (%d bytes, expecting %d)",
                     ppkt->Str(), pAuthData->length, sizeof( CAuthData4 ) + XONLINE_KEY_LENGTH );
            SgKerbEvent(INVALID_KERBEROS_TICKET_27, CSmallStr().Format(
                    "Authdata-length: %u", pAuthData->length).cstr());
            return(FALSE);
        }

        CAuthData4* pAuthData4 = (CAuthData4*)( pAuthData->value + XONLINE_KEY_LENGTH );
        if( pAuthData4->GetCb() != sizeof( CAuthData4 ) )
        {
            TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data claimed size (%d bytes) is different than expected (%d bytes)",
                     ppkt->Str(), pAuthData4->GetCb(), sizeof( CAuthData4 ));
            SgKerbEvent(INVALID_KERBEROS_TICKET_28, CSmallStr().Format(
                    "Authdata-Length: %u", pAuthData4->GetCb()).cstr());
            return(FALSE);
        }

        if( XONLINE_XENON2_AUTHDATA_VERSION != pAuthData4->wAuthDataVersion )
        {
            TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data is invalid version (%u)",
                     ppkt->Str(), pAuthData4->wAuthDataVersion);
            SgKerbEvent(INVALID_KERBEROS_TICKET_30, CSmallStr().Format(
                    "Authdata-version: 0x%x", pAuthData4->wAuthDataVersion).cstr());
            return(FALSE);
        }

        SgPerfdataInc(AuthdataV4, 1);
        pKeyExCtx->_AuthData = *pAuthData4;
    }
    else
    {

        // Try to find AuthData3 next
        pAuthData = KerbFindAuthDataEntry( KERB_AUTH_DATA_XENON, EncryptedTicket->authorization_data );
        if( NULL != pAuthData && NULL != pAuthData->value )
        {
            // The entry should be CAuthData3, validate it and copy it over

            if( sizeof( CAuthData3 ) + XONLINE_KEY_LENGTH > pAuthData->length )
            {
                TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data is too small (%d bytes, expecting %d)",
                         ppkt->Str(), pAuthData->length, sizeof( CAuthData3 ) + XONLINE_KEY_LENGTH );
                SgKerbEvent(INVALID_KERBEROS_TICKET_27, CSmallStr().Format(
                        "Authdata-length: %u", pAuthData->length).cstr());
                return(FALSE);
            }

            CAuthData3* pAuthData3 = (CAuthData3*)( pAuthData->value + XONLINE_KEY_LENGTH );
            if( pAuthData3->GetCb() != sizeof( CAuthData3 ) )
            {
                TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data claimed size (%d bytes) is different than expected (%d bytes)",
                         ppkt->Str(), pAuthData3->GetCb(), sizeof( CAuthData3 ));
                SgKerbEvent(INVALID_KERBEROS_TICKET_28, CSmallStr().Format(
                        "Authdata-Length: %u", pAuthData3->GetCb()).cstr());
                return(FALSE);
            }

            if( XONLINE_XENON_AUTHDATA_VERSION != pAuthData3->wAuthDataVersion )
            {
                TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data is invalid version (%u)",
                         ppkt->Str(), pAuthData3->wAuthDataVersion);
                SgKerbEvent(INVALID_KERBEROS_TICKET_30, CSmallStr().Format(
                        "Authdata-version: 0x%x", pAuthData3->wAuthDataVersion).cstr());
                return(FALSE);
            }

            SgPerfdataInc(AuthdataV3, 1);
            SgConvertAuthData3ToAuthData4( pAuthData3, &pKeyExCtx->_AuthData );
        }
        else
        {
            // We didn't find AuthData3, try for AuthData2
            pAuthData = KerbFindAuthDataEntry( KERB_AUTH_DATA_XBOX, EncryptedTicket->authorization_data );
            if( NULL != pAuthData && NULL != pAuthData->value )
            {
                // The entry should be CAuthData2, validate it and copy it over

                if( sizeof( CAuthData2 ) + XONLINE_KEY_LENGTH > pAuthData->length )
                {
                    TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data is too small (%d bytes, expecting %d)",
                             ppkt->Str(), pAuthData->length, sizeof( CAuthData2 ) + XONLINE_KEY_LENGTH );
                    SgKerbEvent(INVALID_KERBEROS_TICKET_27, CSmallStr().Format(
                            "Authdata2-Length: %u", pAuthData->length).cstr());
                    return(FALSE);
                }

                CAuthData2* pAuthData2 = (CAuthData2*)( pAuthData->value + XONLINE_KEY_LENGTH );
                if( pAuthData2->GetCb() != sizeof( CAuthData2 ) )
                {
                    TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data claimed size (%d bytes) is different than expected (%d bytes)",
                             ppkt->Str(), pAuthData2->GetCb(), sizeof( CAuthData2 ));
                    SgKerbEvent(INVALID_KERBEROS_TICKET_28, CSmallStr().Format(
                            "Authdata2-Length: %u", pAuthData2->GetCb()).cstr());
                    return(FALSE);
                }

                if( XONLINE_AUTHDATA_VERSION != pAuthData2->wAuthDataVersion )
                {
                    TraceSz(RecvDiscard, "%s: SgCrackKerbApReq auth-data is invalid version (%u)",
                             ppkt->Str(), pAuthData2->wAuthDataVersion);
                    SgKerbEvent(INVALID_KERBEROS_TICKET_30, CSmallStr().Format(
                            "Authdata-version: 0x%x", pAuthData2->wAuthDataVersion).cstr());
                    return(FALSE);
                }

                SgPerfdataInc(AuthdataV2, 1);
                SgConvertAuthData2ToAuthData4( pAuthData2, &pKeyExCtx->_AuthData );
            }
            else
            {
                TraceSz(RecvDiscard, "%s: SgCrackKerbApReq Xbox auth-data not present", ppkt->Str());
                SgKerbEvent(INVALID_KERBEROS_TICKET_26, NULL);
                return(FALSE);
            }
        }
    }

    //@@@ TODO check server signature, the first XONLINE_KEY_LENGTH bytes

    pKeyExCtx->_puid.QuadPart = pKeyExCtx->_AuthData.qwXboxID;

    if (Tag(KerbVerbose))
    {
        TraceSz(KerbVerbose, "%s: [AuthData]", ppkt->Str());
        TraceSz(KerbVerbose, "%s: [ wAuthDataVersion = %d]", ppkt->Str(),
                 pKeyExCtx->_AuthData.wAuthDataVersion);
        TraceSz(KerbVerbose, "%s: [ wAuthDataSize    = %d]", ppkt->Str(),
                 pKeyExCtx->_AuthData.wAuthDataSize);
        TraceSz(KerbVerbose, "%s: [ clientVersion    = %d.%d.%d.%d]", ppkt->Str(),
                 pKeyExCtx->_AuthData.clientVersion.wMajorVersion,
                 pKeyExCtx->_AuthData.clientVersion.wMinorVersion,
                 pKeyExCtx->_AuthData.clientVersion.wBuildNumber,
                 pKeyExCtx->_AuthData.clientVersion.wQFENumber);
        TraceSz(KerbVerbose, "%s: [ title            = %08X, %08X, %08X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.dwTitleID,
                 pKeyExCtx->_AuthData.dwTitleVersion,
                 pKeyExCtx->_AuthData.dwTitleRegion);
        TraceSz(KerbVerbose, "%s: [ ConsoleRegion    = %08X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.dwConsoleRegion);
        TraceSz(KerbVerbose, "%s: [ mediaID          = %08X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.dwMediaID);
        TraceSz(KerbVerbose, "%s: [ languageID       = %04X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.wLanguageID);
        TraceSz(KerbVerbose, "%s: [ authDataFlags    = %08X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.dwAuthDataFlags);
        TraceSz(KerbVerbose,"%s: [ base services    = %08X %08X %08X %08X]",ppkt->Str(),
                 pKeyExCtx->_AuthData.dwBaseServices[0],
                 pKeyExCtx->_AuthData.dwBaseServices[1],
                 pKeyExCtx->_AuthData.dwBaseServices[2],
                 pKeyExCtx->_AuthData.dwBaseServices[3]);
        TraceSz(KerbVerbose, "%s: [ machine privs    = %08X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.dwMachinePrivileges[0]);
        TraceSz(KerbVerbose, "%s: [ xboxID           = %I64X]", ppkt->Str(),
                 pKeyExCtx->_AuthData.qwXboxID);
        if (pKeyExCtx->_AuthData.users[0].qwUserID != 0)
        {
            TraceSz(KerbVerbose, "%s: [ user 0           = %I64X:%X %08X %08x %08x]", ppkt->Str(),
                     pKeyExCtx->_AuthData.users[0].qwUserID,
                     pKeyExCtx->_AuthData.users[0].dwUserFlags,
                     pKeyExCtx->_AuthData.dwUserPrivileges[0][0],
                     pKeyExCtx->_AuthData.dwUserPrivileges[0][1],
                     pKeyExCtx->_AuthData.dwUserPrivileges[0][2]);
        }
        if (pKeyExCtx->_AuthData.users[1].qwUserID != 0)
        {
            TraceSz(KerbVerbose, "%s: [ user 1           = %I64X:%X %08X %08x %08x]", ppkt->Str(),
                     pKeyExCtx->_AuthData.users[1].qwUserID,
                     pKeyExCtx->_AuthData.users[1].dwUserFlags,
                     pKeyExCtx->_AuthData.dwUserPrivileges[1][0],
                     pKeyExCtx->_AuthData.dwUserPrivileges[1][1],
                     pKeyExCtx->_AuthData.dwUserPrivileges[1][2]);
        }
        if (pKeyExCtx->_AuthData.users[2].qwUserID != 0)
        {
            TraceSz(KerbVerbose, "%s: [ user 2           = %I64X:%X %08X %08x %08x]", ppkt->Str(),
                     pKeyExCtx->_AuthData.users[2].qwUserID,
                     pKeyExCtx->_AuthData.users[2].dwUserFlags,
                     pKeyExCtx->_AuthData.dwUserPrivileges[2][0],
                     pKeyExCtx->_AuthData.dwUserPrivileges[2][1],
                     pKeyExCtx->_AuthData.dwUserPrivileges[2][2]);
        }
        if (pKeyExCtx->_AuthData.users[3].qwUserID != 0)
        {
            TraceSz(KerbVerbose, "%s: [ user 3           = %I64X:%X %08X %08x %08x]", ppkt->Str(),
                     pKeyExCtx->_AuthData.users[3].qwUserID,
                     pKeyExCtx->_AuthData.users[3].dwUserFlags,
                     pKeyExCtx->_AuthData.dwUserPrivileges[3][0],
                     pKeyExCtx->_AuthData.dwUserPrivileges[3][1],
                     pKeyExCtx->_AuthData.dwUserPrivileges[3][2]);
        }
        TraceSz(KerbVerbose, "%s: [ afltTrustFactor  = %f, %f, %f, %f]", ppkt->Str(),
                 pKeyExCtx->_AuthData.afltTrustFactor[0],
                 pKeyExCtx->_AuthData.afltTrustFactor[1],
                 pKeyExCtx->_AuthData.afltTrustFactor[2],
                 pKeyExCtx->_AuthData.afltTrustFactor[3]);
        TraceSz(KerbVerbose, "%s: [ #ExtendedServices= %04x]", ppkt->Str(),
                 pKeyExCtx->_AuthData.wNumExtendedServices);

        for( UINT iService = 0; iService < XONLINE_MAX_DWORD_SERVICEIDS; iService++ )
        {
                TraceSz(KerbVerbose, "%s: [  %d]", ppkt->Str(),
                         pKeyExCtx->_AuthData.dwExtendedServices[iService]);
        }

        TraceSz(KerbVerbose, "%s: [ dwAltTitleIDs: ]", ppkt->Str());

        for( UINT iAltTitleId = 0; iAltTitleId < XONLINE_MAX_ALTERNATE_TITLE_ID; iAltTitleId++)
        {
                TraceSz(KerbVerbose, "%s: [  %d]", ppkt->Str(),
                         pKeyExCtx->_AuthData.dwAltTitleID[iAltTitleId]);
        }
        TraceSz(KerbVerbose, "%s: [ dwLifeTimeInSeconds = %d]", ppkt->Str(),
                pKeyExCtx->_dwLifetimeInSeconds
                );
    }


    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// SgBuildKerbApRep
// ---------------------------------------------------------------------------------------

BOOL SgBuildKerbApRep(CPacket * ppkt)
{
    KERBERR KerbErr;
    KERB_AP_REPLY Reply;
    KERB_ENCRYPTED_AP_REPLY ReplyBody;
    DWORD PackedReplySize = 0;
    BYTE* PackedReply = NULL;
    DWORD PackedReplyBodySize = 0;
    BYTE* PackedReplyBody = NULL;
    KERB_ENCRYPTION_KEY ApReplyAppSignature;
    KERB_ENCRYPTION_KEY SessionKey;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    BYTE ScratchMemoryBufferMain[SCRATCH_MEMORY_SIZE_FOR_BuildApReply];
    BYTE ScratchMemoryBufferTemp[SCRATCH_MEMORY_SIZE_FOR_BuildApReply / 2];

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize(ScratchMemoryBufferMain, sizeof(ScratchMemoryBufferMain), ScratchMemoryBufferTemp, sizeof(ScratchMemoryBufferTemp) );
    if (pbScratchMemory == NULL)
    {
        SgEventInternalError(0, NULL);
        return(FALSE);
    }

    CKeyExCtx *         pKeyExCtx       = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExKerbApRep *   pKeyExKerbApRep = &pKeyExCtx->_KerbApRep;

    RtlZeroMemory( &Reply, sizeof(Reply) );
    RtlZeroMemory( &ReplyBody, sizeof(ReplyBody) );

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AP_REP;

    KerbConvertLargeIntToGeneralizedTime(
        &ReplyBody.client_time,
        NULL,
        &pKeyExCtx->_liTime
        );

    ReplyBody.client_usec = pKeyExCtx->_dwUsec;

    KerbCreateKeyFromBuffer(
            &ApReplyAppSignature,
            pKeyExCtx->_abSha,
            sizeof(pKeyExCtx->_abSha),
            KERB_CHECKSUM_SHA1
            );

    ReplyBody.KERB_ENCRYPTED_AP_REPLY_subkey = ApReplyAppSignature;
    ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_subkey_present;

    KerbErr = KerbPackApReplyBody(
                        &ScratchMemoryAllocator,
                        &ReplyBody,
                        &PackedReplyBodySize,
                        &PackedReplyBody
                        );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgBuildKerbApRep failed to pack Ap Reply Body", ppkt->Str() );
        SgEventInternalError(sizeof(KerbErr), &KerbErr);
        return(FALSE);
    }

    KerbCreateKeyFromBuffer(
            &SessionKey,
            pKeyExCtx->_abKey,
            sizeof(pKeyExCtx->_abKey),
            KERB_ETYPE_RC4_HMAC_NT
            );

    //
    // Now encrypt the Ap Reply
    //
    KerbErr = KerbAllocateEncryptionBufferWrapper(
                &ScratchMemoryAllocator,
                KERB_ETYPE_RC4_HMAC_NT,
                PackedReplyBodySize,
                &Reply.encrypted_part.cipher_text.length,
                &Reply.encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgBuildKerbApRep failed allocate reply memory", ppkt->Str() );
        SgEventInternalError(sizeof(KerbErr), &KerbErr);
        return(FALSE);
    }

    KerbErr = KerbEncryptDataEx(
                &ScratchMemoryAllocator,
                &Reply.encrypted_part,
                PackedReplyBodySize,
                PackedReplyBody,
                KERB_ETYPE_RC4_HMAC_NT,
                KERB_AP_REP_SALT,
                &SessionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgBuildKerbApRep failed to encrypt Ap Body", ppkt->Str() );
        SgEventInternalError(sizeof(KerbErr), &KerbErr);
        return(FALSE);
    }

    //
    // Now pack the reply into the output buffer
    //
    KerbErr = KerbPackApReply(
                &ScratchMemoryAllocator,
                &Reply,
                &PackedReplySize,
                &PackedReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz(RecvDiscard, "%s: SgBuildKerbApRep failed to pack Ap Body", ppkt->Str() );
        SgEventInternalError(sizeof(KerbErr), &KerbErr);
        return(FALSE);
    }

    pKeyExKerbApRep->_wType = KEYEX_TYPE_KERB_APREP;
    pKeyExKerbApRep->_cbEnt = (WORD)PackedReplySize + sizeof(CKeyExHdr);

    memcpy(pKeyExKerbApRep->_ab, PackedReply, PackedReplySize);

    TraceSz(KerbVerbose, "%s: SgBuildKerbApRep built %d bytes", ppkt->Str(), PackedReplySize );

    return(TRUE);
}

//
// Stuff from kerbutil.cpp
//

//+-----------------------------------------------------------------------

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    )
{

    NewKey->keytype = EncryptionType;
    NewKey->keyvalue.length = BufferSize;
    NewKey->keyvalue.value = (PUCHAR) Buffer;
    return(KDC_ERR_NONE);
}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbEncryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;

    //
    // Initialize header
    //

    EncryptedData->encryption_type = pDefaultCryptoSystem->EncryptionType;

    Status = pDefaultCryptoSystem->Initialize(
                pScratchMemoryAllocator,
                (PUCHAR) Key->keyvalue.value,
                Key->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Status =  pDefaultCryptoSystem->Encrypt(
                psbCryptBuffer,
                Data,
                DataSize,
                EncryptedData->cipher_text.value,
                &EncryptedData->cipher_text.length
                );

    (void) pDefaultCryptoSystem->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "KerbEncryptDataEx failure KerbErr %X", KerbErr );
    }
    return KerbErr;
}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbDecryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS     Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;

    if (EncryptedData->cipher_text.length & (pDefaultCryptoSystem->BlockSize - 1))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Status = pDefaultCryptoSystem->Initialize(
                pScratchMemoryAllocator,
                (PUCHAR) pkKey->keyvalue.value,
                pkKey->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Status = pDefaultCryptoSystem->Decrypt(
                psbCryptBuffer,
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                Data,
                DataSize
                );

    (VOID) pDefaultCryptoSystem->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "KerbDecryptDataEx failure KerbErr %X", KerbErr );
    }
    return KerbErr;
}

//+-------------------------------------------------------------------------

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    *Overhead = pDefaultCryptoSystem->HeaderSize;
    if (BlockSize != NULL)
    {
        *BlockSize = pDefaultCryptoSystem->BlockSize;
    }
    return(KDC_ERR_NONE);

}

//+-------------------------------------------------------------------------

KERBERR
KerbAllocateEncryptionBuffer(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG EncryptionOverhead = 0;
    ULONG BlockSize = 0;

    KerbErr = KerbGetEncryptionOverhead(
                EncryptionType,
                &EncryptionOverhead,
                &BlockSize
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    *EncryptionBufferSize = (UINT) ROUND_UP_COUNT(EncryptionOverhead + BufferSize, BlockSize);

    *EncryptionBuffer =  (PBYTE) pScratchMemoryAllocator->Alloc(*EncryptionBufferSize);
    if (*EncryptionBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "KerbAllocateEncryptionBuffer failure KerbErr %X", KerbErr );
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    unsigned int tempInt = 0;

    KerbErr = KerbAllocateEncryptionBuffer(
                pScratchMemoryAllocator,
                EncryptionType,
                BufferSize,
                &tempInt,
                EncryptionBuffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    *EncryptionBufferSize = tempInt;

Cleanup:
    return (KerbErr);
}

//
// From tickets.cpp
//

//+-------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime;
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

    RtlZeroMemory(
        &ZeroTime,
        sizeof(KERB_TIME)
        );

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/97 - no clients should send this sort of
    // zero time
    //


    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
        KerbSetTime(TimeStamp,0);
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
        KerbSetTime(TimeStamp,0);
        return;
    }
    else
    {
        TimeFields.Year = ClientTime->year;
        TimeFields.Month = ClientTime->month;
        TimeFields.Day = ClientTime->day;
        TimeFields.Hour = ClientTime->hour;
        TimeFields.Minute = ClientTime->minute;
        TimeFields.Second = ClientTime->second;
        TimeFields.Milliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.Weekday = 0;

        SgTimeFieldsToTime(
            &TimeFields,
            TimeStamp
            );

        //
        // add in any micro seconds
        //

        KerbGetTime(*TimeStamp) += ClientUsec * 10;

    }

}


//+-------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
    TIME_FIELDS TimeFields;

    //
    // This zeroing is needed or else a useless byte in the middle might be different
    //
    RtlZeroMemory(
        ClientTime,
        sizeof(KERB_TIME)
        );

    //
    // Special case zero time
    //

    if (KerbGetTime(*TimeStamp) == 0)
    {
        //
        // BUGBUG: For MIT compatibility, time zero is 1/1/70
        //

        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ClientUsec != NULL)

        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {

        SgTimeToTimeFields(
            (LARGE_INTEGER*)TimeStamp,
            &TimeFields
            );

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.Year > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.Year;
        }
        ClientTime->month = (ASN1uint8_t) TimeFields.Month;
        ClientTime->day = (ASN1uint8_t) TimeFields.Day;
        ClientTime->hour = (ASN1uint8_t) TimeFields.Hour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.Minute;
        ClientTime->second = (ASN1uint8_t) TimeFields.Second;

        // BUGBUG: MIT kerberos does not support millseconds
        //
        // ClientTime->millisec = TimeFields.Milliseconds;
        //

        ClientTime->millisecond = 0;

        if (ClientUsec != NULL)
        {
            //
            // The low part of time is 100 nanoseconds, so one 10th of that
            // is microseconds. We only want the microseconds not included
            // in the milliseconds above.
            //
            //
            // BUGBUG: since we don't includ milliseconds above, use the whole
            // thing here.
            //

            *ClientUsec = (TimeStamp->LowPart / 10) % 1000000;
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }

}

//+-------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
        int temp;

        if (ClientUsec != NULL)
        {
                KerbConvertLargeIntToGeneralizedTime(
                        ClientTime,
                        &temp,
                        TimeStamp
                        );

                *ClientUsec = temp;
        }
        else
        {
                KerbConvertLargeIntToGeneralizedTime(
                        ClientTime,
                        NULL,
                        TimeStamp
                        );
        }
}

//+-------------------------------------------------------------------------

BOOL fKRB5ModuleStarted = FALSE;

KERBERR
KerbInitAsn(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN OUT ASN1encoding_t * pEnc,
    IN OUT ASN1decoding_t * pDec
    )
{
    KERBERR KerbErr = KRB_ERR_GENERIC;
        ASN1error_e Asn1Err;

        if (!fKRB5ModuleStarted)
        {
                fKRB5ModuleStarted = TRUE;
                KRB5_Module_Startup();
        }

        if (pEnc != NULL)
        {
                Asn1Err = ASN1_CreateEncoder(
                                         pScratchMemoryAllocator,
                                         KRB5_Module,
                                         pEnc,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }
        else
        {
                Asn1Err = ASN1_CreateDecoder(
                                         pScratchMemoryAllocator,
                                         KRB5_Module,
                                         pDec,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }

        if (ASN1_SUCCESS != Asn1Err)
        {
                goto Cleanup;
        }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "KerbInitAsn failure KerbErr %X", KerbErr );
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------

VOID
KerbTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
        {
                ASN1_CloseEncoder(pEnc);
        }
        else if (pDec != NULL)
        {
                ASN1_CloseDecoder(pDec);
        }

        //KRB5_Module_Cleanup();
}

//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    int Result = 0;
    PUCHAR Buffer = NULL;
    ASN1encoding_t pEnc = NULL;
    ASN1error_e Asn1Err;
    void* pTempBuffer;

    KerbErr = KerbInitAsn(
                pScratchMemoryAllocator,
                &pEnc,          // we are encoding
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
        //
        // Encode the data type.
        //

        Assert( (*MarshalledData == NULL && *DataSize == 0) || (*MarshalledData != NULL && *DataSize != 0) );
        AssertSz( *DataSize <= 10000, "Passing buffer larger than 10K, most likely an error");

        TraceSz( KerbVerbose, "ASN encoding pdu #%d", PduValue );
        if (*MarshalledData != NULL)
        {
            Asn1Err = ASN1_Encode(
                        pEnc,
                        Data,
                        PduValue,
                        ASN1ENCODE_SETBUFFER,
                        *MarshalledData,
                        *DataSize
                        );
        }
        else
        {
            Asn1Err = ASN1_Encode(
                        pEnc,
                        Data,
                        PduValue,
                        ASN1ENCODE_ALLOCATEBUFFER,
                        NULL,                       // pbBuf
                        0                           // cbBufSize
                        );
        }
        if (!ASN1_SUCCEEDED(Asn1Err))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        else
        {
            if ( *MarshalledData != NULL )
            {
                //
                // Caller specified a destination buffer
                //
                if (*MarshalledData == pEnc->buf)
                {
                    //
                    // Caller's destination buffer was used, that's what we want
                    //
                    *DataSize = pEnc->len;
                }
                else
                {
                    //
                    // Caller's destination buffer was too small, report failure
                    //
                    *DataSize = 0;
                    *MarshalledData = NULL;
                    KerbErr = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
            else
            {
                //
                // Caller didn't specify a destination buffer
                //
                *DataSize = pEnc->len;
                *MarshalledData = pEnc->buf;
                //
                // Preserve the only piece of memory we care about
                //
                pTempBuffer = onlyPreserveThisMemory.PreserveThisMemory( (void**)MarshalledData, *DataSize );
                if (pTempBuffer == NULL)
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
        }

        KerbTermAsn(pEnc, NULL);
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "KerbPackData failure KerbErr %X", KerbErr );
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
        ASN1error_e Asn1Err;

    Assert((DataSize != 0) && (Data != NULL));

    KerbErr = KerbInitAsn(
                pScratchMemoryAllocator,
                NULL,
                &pDec           // we are decoding
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    TraceSz( KerbVerbose, "ASN decoding pdu #%d", PduValue );
    *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                pDec,
                DecodedData,
                PduValue,
                ASN1DECODE_SETBUFFER,
                (BYTE *) Data,
                DataSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {

        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            KerbErr = KDC_ERR_MORE_DATA;
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        *DecodedData = NULL;
    }

    KerbTermAsn(NULL, pDec);

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "KerbUnpackData failure KerbErr %X", KerbErr );
    }
    return(KerbErr);
}

//
// From rc4crypt.cpp
//

#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    BYTE Key[MD5_LEN];
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;


NTSTATUS NTAPI rc4HmacInitialize(CScratchMemoryAllocator*, PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinish(PCRYPT_STATE_BUFFER *);

CRYPTO_SYSTEM    csRC4_HMAC = {
    KERB_ETYPE_RC4_HMAC_NT,     // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT, // Exportable version
    MD5_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    NULL,
    NULL,
    NULL
    };

PCRYPTO_SYSTEM pDefaultCryptoSystem = &csRC4_HMAC;

//////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    RtlCopyMemory(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitialize(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;

    //
    // Compute the HMAC pad
    //

    StateBuffer = (PRC4_HMAC_STATE_BUFFER) pScratchMemoryAllocator->Alloc(sizeof(RC4_HMAC_STATE_BUFFER));
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    md5Hmac(
        pbKey,
        KeySize,
        (PBYTE) &MessageType,
        sizeof(ULONG),
        NULL,
        0,
        StateBuffer->Key
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitialize(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitialize(
                pScratchMemoryAllocator,
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG pcbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    BYTE LocalKey[MD5_LEN];
    ULONG Offset = 0;
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    Offset = sizeof(RC4_MDx_HEADER);
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *pcbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    RtlZeroMemory(
        CryptHeader->Checksum,
        MD5_LEN
        );

    if ( !SgRand( CryptHeader->Confounder, RC4_CONFOUNDER_LEN ) )
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Checksum everything but the checksum
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        pbOutput+MD5_LEN,
        *pcbOutput-MD5_LEN,
        NULL,
        0,
        CryptHeader->Checksum
        );

    //
    // HMAC the checksum into the key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        CryptHeader->Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    XcRC4Key( Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //

    XcRC4Crypt( Rc4KeyStruct, *pcbOutput-MD5_LEN, pbOutput+MD5_LEN );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecrypt( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            pcbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    BYTE TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    BYTE LocalKey[MD5_LEN];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];


    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Copy the input to the output before decrypting
    //

    RtlCopyMemory(
        &TempHeader,
        pbInput,
        Offset
        );

    *pcbOutput = cbInput - Offset;
    RtlMoveMemory(
        pbOutput,
        pbInput + Offset,
        *pcbOutput
        );


    //
    // Build the decryption key from the checksum and the
    // real key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    XcRC4Key( Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Now decrypt the two buffers
    //

    XcRC4Crypt( Rc4KeyStruct, Offset - MD5_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, *pcbOutput, pbOutput );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //


    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Confounder,
        Offset-MD5_LEN,
        pbOutput,
        *pcbOutput,
        TempChecksum
        );

    if (RtlEqualMemory(
            TempHeader.Checksum,
            TempChecksum,
            MD5_LEN
            ) != TRUE)
    {
        TraceSz( KerbWarn, "rc4HmacDecrypt failed" );
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgfilter.cpp ===
// ---------------------------------------------------------------------------------------
// sgfilter.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// Filters
// ---------------------------------------------------------------------------------------

void SgApplyFilterScriptAllWithPacket(CPacket* ppkt);
void SgApplyFilterScriptAllWithSpi(CPacket* ppkt);
int SgPApplyFilterScriptWithSpi(lua_State* pLuaState);

// ---------------------------------------------------------------------------------------
// SgApplyFilterScriptWithSpi
// Apply filter scripts to a given CSpiInfo.
//   - pSpiInfo: Pointer to attached CSpiInfo that we want to run apply the  filter
//   scripts to.
// Remarks:
// ** IMPORTANT: This must be called from a thread currently attached to this CSpiInfo
// ---------------------------------------------------------------------------------------
void SgApplyFilterScriptWithSpi(CSpiInfo* pSpiInfo)
{
    ISgLuaState* pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    if(!pLua->CCall(SgPApplyFilterScriptWithSpi, NULL, &error))
    {
        SgEventSz(FILTER_SCRIPT_FAILED, "\nSpi: 0x%x CSpiInfo*: 0x%p Error:\n%s",
                   pSpiInfo->_dwSpiRecv, pSpiInfo, error.cstr());
    }

    pLua->Release();
}

// ---------------------------------------------------------------------------------------
// SgApplyFilterScriptAll
// Apply filter scripts to all Spis
// ---------------------------------------------------------------------------------------
void SgApplyFilterScriptAll()
{
    CPacket* ppkt = SgPacketAlloc();

    if(!ppkt)
    {
        TraceSz(Warning, "SgRunScriptAgainstSpis - unable to allocate a packet");
        return;
    }

    CScriptSpiCtx* pctx = (CScriptSpiCtx*) ppkt->_abCtx;
    pctx->_pSpiInfo = g_pSpiInfo;

    SgApplyFilterScriptAllWithPacket(ppkt);
}

// ---------------------------------------------------------------------------------------
// SgApplyFilterScriptAllWithPacket
// Continues the work of SgApplyFilterScriptAll.
//   - ppkt: pointer to packet that contains the CScriptSpiCtx context
// ---------------------------------------------------------------------------------------
static void SgApplyFilterScriptAllWithPacket(CPacket* ppkt)
{
    CScriptSpiCtx* pctx = (CScriptSpiCtx*) ppkt->_abCtx;

    for (; pctx->_pSpiInfo <= g_pSpiInfoLast; pctx->_pSpiInfo++)
    {
        if (pctx->_pSpiInfo->_leFree.Flink == NULL)
        {
            SgSpiInfoAttach(ppkt, SgApplyFilterScriptAllWithSpi, pctx->_pSpiInfo->_dwSpiRecv);
            return;
        }
    }

    ppkt->Complete();
}

// ---------------------------------------------------------------------------------------
// SgApplyFilterScriptAllWithSpi
// Continues the work of SgApplyFilterScriptAllWithPacket. The only difference is this
// function is executed from a thread attached to a CSpiInfo.
//   - ppkt: pointer to packet that contains the CScriptSpiCtx context and is attached to
//   a CSpiInfo.
// ---------------------------------------------------------------------------------------
static void SgApplyFilterScriptAllWithSpi(CPacket* ppkt)
{
    // Test if we attached successfully to a Spi
    if(ppkt->_pSpiInfo)
    {
        // Do filter work
        SgApplyFilterScriptWithSpi(ppkt->_pSpiInfo);

        // Detach from the Spi so we can attach to a different one
        SgSpiInfoDetach(ppkt);
    }

    // Next Spi
    CScriptSpiCtx* pctx = (CScriptSpiCtx*) ppkt->_abCtx;
    pctx->_pSpiInfo++;
    SgApplyFilterScriptAllWithPacket(ppkt);
}

// ---------------------------------------------------------------------------------------
// SgPApplyFilterScriptWithSpi
// Lua protected function corresponding to SgApplyFilterScriptWithSpi
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// ---------------------------------------------------------------------------------------
static int SgPApplyFilterScriptWithSpi(lua_State* pLuaState)
{
    lua_getglobal(pLuaState, "FilterApply");
    lua_call(pLuaState, 0, 0);

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgdebug.cpp ===
// ---------------------------------------------------------------------------------------
// sgdebug.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#define SG_CONFIG_LOG "sgconfig.log"

//
// Define tags
//

#define DefineTag(t, s) int Tag(t) = s;

TAG_LIST();

#undef DefineTag

// ---------------------------------------------------------------------------------------
// SgTrace
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_TRACE

class CSgTraceFile
{
public:

    static HRESULT Create(const char* pszFilename, CSgTraceFile** ppTraceFile)
    {
        CSgTraceFile* pTraceFile = NULL;
        HRESULT hr = E_FAIL;

        pTraceFile = new CSgTraceFile();

        if(!pTraceFile)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = pTraceFile->Open(pszFilename);

        if(FAILED(hr))
        {
            goto Exit;
        }

        *ppTraceFile = pTraceFile;
        pTraceFile = NULL;
        hr = S_OK;

    Exit:

        if(!pTraceFile)
        {
            delete pTraceFile;
        }

        return hr;
    }

    INLINE void AddRef()
    {
        ::InterlockedIncrement(&_lRefCount);
    }

    INLINE void Release()
    {
        if(::InterlockedDecrement(&_lRefCount) == 0)
        {
            delete this;
        }
    }
    
    HRESULT Write(const char* psz)
    {
        DWORD dwWritten = 0;
        
        DBGASSERT(_hFile != INVALID_HANDLE_VALUE);

        CConstStr str(psz);
        if(!::WriteFile(_hFile, str.cstr(), str.GetLength(), &dwWritten, NULL))
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }

        return S_OK;
    }
        
protected:
    
    CSgTraceFile()
    {
        _hFile      = INVALID_HANDLE_VALUE;
        _lRefCount  = 1;
    }
    
    ~CSgTraceFile()
    {
        Term();
    }
    
    PVOID operator new(size_t cSize) 
    { 
        return (PVOID) SgMemAllocZ(cSize, PTAG_TraceFile); 
    }
    
    void operator delete(PVOID pObj)
    { 
        SgMemFree(pObj);
    }
    
    HRESULT Open(const char* pszFilename)
    {
        _hFile = ::CreateFileA(pszFilename, GENERIC_WRITE, FILE_SHARE_READ,
                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if(INVALID_HANDLE_VALUE == _hFile)
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }

        return S_OK;
    }

    void Term()
    {
        if(_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(_hFile);
            _hFile = INVALID_HANDLE_VALUE;
        }
    }
    
    HANDLE _hFile;
    volatile LONG _lRefCount;
};

CSgTraceFile*   g_pTraceFile;            // trace file
CSpinLock       g_lockTraceFile;         // lock to sync access to g_pTraceFile   
DWORD           g_fTraceToDebugOutput;   // should we log traces to debug output?
DWORD           g_fTraceToStdOut;        // should we log traces to stdout?
DWORD           g_fInitialTraceConfig;   // first config or not?

BOOL SgTraceInit()
{
    g_fInitialTraceConfig = TRUE;
    return(TRUE);
}

void SgTraceReset()
{
    //
    // close trace file
    //

    if(g_pTraceFile)
    {
        CSgTraceFile* pOldTraceFile = NULL;
        
        g_lockTraceFile.Lock();
        pOldTraceFile = g_pTraceFile;
        g_pTraceFile  = NULL;
        g_lockTraceFile.Unlock();

        //
        // release our reference to the old file so that once all threads are done with 
        // it, it can be released.
        //
        
        if(pOldTraceFile)
        {
            pOldTraceFile->Release();
        }
    }

    // 
    // reconfigure tags to default value
    //

#define DefineTag(t, s) Tag(t) = s;

    TAG_LIST();

#undef DefineTag

    MemoryBarrier();
}

BOOL SgOpenTraceFile(const char* pszFileName)
{
    BOOL ok = FALSE;
    HRESULT hr;
    CSgTraceFile* pNewTraceFile = NULL;
    
    //
    // create a new trace file
    //
    
    hr = CSgTraceFile::Create(pszFileName, &pNewTraceFile);

    if(SUCCEEDED(hr))
    {
        //
        // exchange the new for the old file
        //

        CSgTraceFile* pOldTraceFile = NULL;
        
        g_lockTraceFile.Lock();
        pOldTraceFile = g_pTraceFile;
        g_pTraceFile  = pNewTraceFile;
        g_lockTraceFile.Unlock();

        //
        // release our reference to the old file so that once all threads are done with 
        // it, it can be released.
        //
        
        if(pOldTraceFile)
        {
            pOldTraceFile->Release();
        }

        ok = TRUE;
    }
    else
    {
        SgEventSz(CONFIG_ERROR, "Failed to create trace file %s. HR: 0x%08x", 
                   pszFileName, hr);
    }

    return ok;
}

BOOL SgTraceConfigTag(char* pszTagName, int* pTag, LPCSTR pszTagMode)
{
    BOOL ok = FALSE;

    if(_stricmp(pszTagMode, "Enable") == 0 ||
       _stricmp(pszTagMode, "1") == 0)
    {
        *pTag = TAG_ENABLE;
        ok = TRUE;
    }
    else if(_stricmp(pszTagMode, "Disable") == 0 ||
            _stricmp(pszTagMode, "0") == 0)
    {
        *pTag = TAG_DISABLE;
        ok = TRUE;
    }
    else
    {
        SgEventSz(CONFIG_ERROR, 
                   "Failed to configure debug trace tag \"%s\". Unknown mode value "
                   "\"%s\". Valid mode values are 0 or 1", 
                   pszTagName, pszTagMode);
    }

    return ok;
}

BOOL SgTraceConfigFile(CCfgInfo* pci)
{
    CHAR szFileName[MAX_PATH];
    if(pci->FindNonList("TraceFile", NULL, FALSE))
    {
        if(!pci->GetString("TraceFile", szFileName, ARRAY_SIZE(szFileName)-1, TRUE) ||
           !SgOpenTraceFile(szFileName))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SgTraceConfigTags(CCfgInfo* pci)
{
    CCfgInfo* pciTags = pci->FindList("TraceTags", NULL, FALSE);
    if(pciTags)
    {
        // 
        // configure tags using l33t macro tricks. If you don't like this, maybe it's because 
        // you're not l33t enough.
        //

        CCfgInfo* pciTag = NULL;
        CHAR szTagMode[40];

#define DefineTag(t, s) \
        if(pciTags->FindNonList(#t, NULL, FALSE)) { \
            if(!pciTags->GetString(#t, szTagMode, ARRAY_SIZE(szTagMode)-1, TRUE) || \
               !SgTraceConfigTag(#t, &Tag(t), szTagMode)) { \
                return FALSE; \
            } \
        }

        TAG_LIST();

#undef DefineTag

        MemoryBarrier();
    }

    return TRUE;
}

BOOL SgTraceConfig(CCfgInfo* pci)
{
    BOOL ok = FALSE;

    //
    // start by closing a possibly existing trace-file and resetting all trace tags to 
    // default values
    //
    
    SgTraceReset();

    //
    // configure trace outputs
    //
    
    if(!pci->GetVar("TraceToDebugOutput", &g_fTraceToDebugOutput, 0, 1, 1) ||
       !pci->GetVar("TraceToStdOut", &g_fTraceToStdOut, 0, 1, 0))
    {
        goto Exit;
    }

    //
    // configure the trace file
    //
    
    if (g_fInitialTraceConfig)
    {
        // Override filename for initial config. Ok if this fails.
        SgOpenTraceFile(SG_CONFIG_LOG);
    }
    else
    {
        if (!SgTraceConfigFile(pci))
        {
            goto Exit;
        }
    }

    //
    // configure trace tags
    //
    
    if (!SgTraceConfigTags(pci))
    {
        goto Exit;
    }

    //
    // dump
    //

    TraceSz(Config, "SgTraceConfig:");
    TraceSz(Config, "  Configured trace tags:");

#define DefineTag(t, s) TraceSz(Config, "  %-30s : %s", #t, Tag(t) ? "Enabled" : "Disabled");

    TAG_LIST();

#undef DefineTag

    // Override the Config tag for initial pass
    if (g_fInitialTraceConfig)
    {
        if (!SgTraceConfigTag("Config", &Tag(Config), "1"))
        {
            goto Exit;
        }
    }
    
    ok = TRUE;

Exit:
    
    return(ok);
}

// ---------------------------------------------------------------------------------------
// SgTraceConfigDone - called when all other config is finished
// ---------------------------------------------------------------------------------------
BOOL SgTraceConfigDone(CCfgInfo* pci)
{
    bool ok = FALSE;

    if (!g_fInitialTraceConfig)
    {
        return TRUE;
    }

    g_fInitialTraceConfig = FALSE;

    // Reset original settings
    if (!SgTraceConfigFile(pci))
    {
        goto Exit;
    }

    if (!SgTraceConfigTags(pci))
    {
        goto Exit;
    }

    ok = TRUE;

Exit:

    return(ok);

}


void SgTraceTerm()
{
    SgTraceReset();
}

// ---------------------------------------------------------------------------------------
// SgDbgTrace
// format a trace line and send it to trace targets
//   - pszTag: tag name for the tag line prefix
//   - pszFmt: printf-like format string
//   - ...: printf-like format parameters
// ---------------------------------------------------------------------------------------
void __cdecl SgDbgTrace(const char * pszTag, const char * pszFmt, ...)
{
    if(!g_pTraceFile &&
       !g_fTraceToDebugOutput &&
       !g_fTraceToStdOut)
    {
        return;
    }

    //
    // get local time for the trace line time-stamp
    //
    
    SYSTEMTIME st;
    ::GetLocalTime(&st);

    //
    // write the trace line prefix
    //
    
    // unusually large strings will be the very rare exception, but we should still handle 
    // them gracefully.
    CLargeStr buffer;
    buffer.SetAllocator(CMemAlloc::Default());
    
    buffer.Format("[SG] %02u:%02u:%02u %s: ", st.wHour, st.wMinute, st.wSecond, pszTag);

    //
    // expand format string
    //
    
    va_list args;
    va_start(args, pszFmt);
    buffer.FormatV(pszFmt, args);
    va_end(args);


    //
    // send to debug targets
    //

    buffer.CopyFrom(CSTR("\r\n"));

    if(g_fTraceToDebugOutput)
    {
        OutputDebugStringA(buffer.cstr());
    }

    if(g_fTraceToStdOut)
    {
        fwrite(buffer.cstr(), 1, buffer.GetLength(), stdout);
        fflush(stdout);
    }

    if(g_pTraceFile)
    {
        //
        // get a reference to the current trace file
        //
        
        CSgTraceFile* pTraceFile;
        
        g_lockTraceFile.Lock();
        pTraceFile = g_pTraceFile;
        
        if(pTraceFile)
        {
            pTraceFile->AddRef();
        }
        
        g_lockTraceFile.Unlock();

        //
        // write the trace
        //
        
        if(pTraceFile)
        {
            pTraceFile->Write(buffer.cstr());
            pTraceFile->Release();
        }
    }
}

#else // !SG_FEATURE_TRACE

BOOL SgTraceInit()
{
    return TRUE;
}

BOOL SgTraceConfig(CCfgInfo*)
{
    return TRUE;
}

void SgTraceTerm()
{
    return;
}

#endif // SG_FEATURE_TRACE

// ---------------------------------------------------------------------------------------
// SgDbgVerifyList
// ---------------------------------------------------------------------------------------

const char * SgDbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire)
{
    LIST_ENTRY * plePrev;
    LIST_ENTRY * pleThis;
    BOOL fFound = FALSE;
    UINT cEnt = 0;

    if (ple->Flink == NULL || ple->Blink == NULL)
        return("List Flink is NULL");
    else if (ple->Blink == NULL)
        return("List Blink is NULL");

    if (ple->Flink == ple || ple->Blink == ple)
    {
        if (ple->Flink != ple->Blink)
        {
            return("List head corrupt");
        }

        return((!pleRequire) ? NULL : "Required entry not found");
    }

    plePrev = ple;
    pleThis = ple->Flink;

    while (1)
    {
        if (pleThis == NULL)
        {
            return("List entry has an Flink that points to NULL");
        }

        if (plePrev != pleThis->Blink)
        {
            return("List entry has a Blink that doesn't point to previous entry");
        }

        if (pleThis == ple)
            break;

        if (pleThis == pleRequire)
        {
            if (fFound)
            {
                return("List has required entry twice.  Cycle detected.");
            }

            fFound = TRUE;
        }

        plePrev = pleThis;
        pleThis = plePrev->Flink;

        if (++cEnt > 1000000)
        {
            return("List has cycle");
        }
    }

    return((!pleRequire || fFound) ? NULL : "Required entry not found");
}

// ---------------------------------------------------------------------------------------
// SgDbgAssertFmt
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_ASSERT
char * __cdecl SgDbgAssertFmt(char const * pszFmt, ...)
{
    STATIC_BUFFER(DbgAssert, 8, 512);
    pch[0] = 0;
    va_list va;
    va_start(va, pszFmt);
    _vsnprintf(pch, cch - 1, pszFmt, va);
    va_end(va);
    pch[cch - 1] = 0;
    return(pch);
}

void SgDbgAssert(const char* pszExpr, const char* pszFile, int iLine, const char* pszMsg)
{
    OutputDebugStringA("\nAssert Failed --------------------------------------------------------------\n");
    
    if(pszMsg)
    {
        OutputDebugStringA(pszMsg);
        OutputDebugStringA("\n");
    }
    
    OutputDebugStringA(pszExpr);
    OutputDebugStringA(CSmallStr().Format("\nFile: %s Line: %u", pszFile, iLine).cstr());

    OutputDebugStringA("\n----------------------------------------------------------------------------\n\n");
    
    SgDbgBreak();
}
#endif // #ifdef SG_FEATURE_ASSERT

// ---------------------------------------------------------------------------------------
// Trace Utilities
// ---------------------------------------------------------------------------------------

char * SgHexStr(const void * pv, size_t cb)
{
    STATIC_BUFFER(HexStr, 32, 257);
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui;

    if (cb > ((cch - 1) / 2))
        cb = ((cch - 1) / 2);

    for (; cb > 0; --cb, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
    }

    *pchDst = 0;

    return(pch);
}

char * SgHexDumpStr(const void * pv, size_t cb)
{
    STATIC_BUFFER(HexDumpStr, 32, 70);
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui, ib;

    if (cb > 16)
        cb = 16;

    for (ib = 0; ib < cb; ++ib, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        *pchDst++ = ' ';

        if (ib == 7)
        {
            *pchDst++ = ' ';
        }
    }

    for (; ib < 16; ++ib)
    {
        *pchDst++ = ' ';
        *pchDst++ = ' ';
        *pchDst++ = ' ';

        if (ib == 7)
        {
            *pchDst++ = ' ';
        }
    }

    *pchDst++ = ' ';

    for (pb = (BYTE *)pv, ib = 0; ib < cb; ++ib, ++pb)
    {
        if (*pb >= 32 && *pb < 127)
            *pchDst++ = (char)(*pb);
        else
            *pchDst++ = '.';
    }

    *pchDst = 0;

    return(pch);
}

void SgHexDumpSpiFlow(DWORD dwPktNum, DWORD dwSpi, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3)
{
    if (g_cbSpiFlowData > 0)
    {
        UINT cbOut  = g_cbSpiFlowData;
        BYTE abLine[16], * pbLine;
        UINT cbLine;
        UINT cbCopy;

        while (cbOut > 0 && cb1 + cb2 + cb3 > 0)
        {
            pbLine = abLine;
            cbLine = min(sizeof(abLine), cbOut);

            if (cbLine > 0 && cb1 > 0)
            {
                cbCopy = min(cbLine, cb1);
                memcpy(pbLine, pb1, cbCopy);
                pb1    += cbCopy;
                cb1    -= cbCopy;
                pbLine += cbCopy;
                cbLine -= cbCopy;
            }

            if (cbLine > 0 && cb2 > 0)
            {
                cbCopy = min(cbLine, cb2);
                memcpy(pbLine, pb2, cbCopy);
                pb2    += cbCopy;
                cb2    -= cbCopy;
                pbLine += cbCopy;
                cbLine -= cbCopy;
            }
            
            if (cbLine > 0 && cb3 > 0)
            {
                cbCopy = min(cbLine, cb3);
                memcpy(pbLine, pb3, cbCopy);
                pb3    += cbCopy;
                cb3    -= cbCopy;
                pbLine += cbCopy;
                cbLine -= cbCopy;
            }

            cbLine = min(sizeof(abLine), cbOut) - cbLine;
            cbOut -= cbLine;

            TraceSz(SpiFlow, "#%d %08lX     %s", dwPktNum, dwSpi, SgHexDumpStr(abLine, cbLine));
        }
    }
}

char * SgSecMsgStr(WORD wType)
{
    switch (wType)
    {
        case SECMSG_TYPE_DELETE:              return("SECMSG_TYPE_DELETE");
        case SECMSG_TYPE_PULSE:               return("SECMSG_TYPE_PULSE");
        case SECMSG_TYPE_XBTOSG_PULSE:        return("SECMSG_TYPE_XBTOSG_PULSE");
        case SECMSG_TYPE_SGTOXB_PULSE:        return("SECMSG_TYPE_SGTOXB_PULSE");
        case SECMSG_TYPE_SGTOXB_PULSE_2:      return("SECMSG_TYPE_SGTOXB_PULSE_2");
        case SECMSG_TYPE_XBTOXB_FORWARD:      return("SECMSG_TYPE_XBTOXB_FORWARD");
        case SECMSG_TYPE_CHANGE_USERS_REQ:    return("SECMSG_TYPE_CHANGE_USERS_REQ");
        case SECMSG_TYPE_CHANGE_USERS_REP:    return("SECMSG_TYPE_CHANGE_USERS_REP");
        case SECMSG_TYPE_XBTOSG_QOS_INIT:     return("SECMSG_TYPE_XBTOSG_QOS_INIT");
        case SECMSG_TYPE_SGTOXB_QOS_RESP:     return("SECMSG_TYPE_SGTOXB_QOS_RESP");
        case SECMSG_TYPE_XBTOSG_CHALRESP:     return("SECMSG_TYPE_XBTOSG_CHALRESP");
        case SECMSG_TYPE_CHANGE_USERS_NULL:   return("SECMSG_TYPE_CHANGE_USERS_NULL");
        case SECMSG_TYPE_SGTOXB_CHAL:         return("SECMSG_TYPE_SGTOXB_CHAL");
        case SECMSG_TYPE_XBTOSG_CHALRESP_2:   return("SECMSG_TYPE_XBTOSG_CHALRESP_2");
        case SECMSG_TYPE_XBTOSG_CHAL_ACK:     return("SECMSG_TYPE_XBTOSG_CHAL_ACK");
        case SECMSG_TYPE_SGTOXB_CHALRESP_ACK: return("SECMSG_TYPE_SGTOXB_CHALRESP_ACK");
        case SECMSG_TYPE_XBTOXB_FORWARD2:     return("SECMSG_TYPE_XBTOXB_FORWARD2");
    }
    if ((wType & 0xFF00) == 0x5300)
    {
        return("[Update SgSecMsgStr()]");
    }
    return("?");
}

char * SgSecMsgDelStr(DWORD dwReason)
{
    switch (dwReason)
    {
        case SECMSG_DELETE_SHUTDOWN:    return("SECMSG_DELETE_SHUTDOWN");
        case SECMSG_DELETE_UNREGISTER:  return("SECMSG_DELETE_UNREGISTER");
        case SECMSG_DELETE_KICK:        return("SECMSG_DELETE_KICK");
        case SECMSG_DELETE_QOS:         return("SECMSG_DELETE_QOS");
        case SECMSG_DELETE_KILL:        return("SECMSG_DELETE_KILL");
    }

    return("?");
}

char * SgMsgStr(WORD wType)
{
    switch (wType)
    {
        case SGMSG_TYPE_KICK_REQ:           return("SGMSG_TYPE_KICK_REQ");
        case SGMSG_TYPE_KICK_REP:           return("SGMSG_TYPE_KICK_REP");
        case SGMSG_TYPE_XBTOXB_FORWARD:     return("SGMSG_TYPE_XBTOXB_FORWARD");
        case SGMSG_TYPE_SET_QVALS_LAZY:     return("SGMSG_TYPE_SET_QVALS_LAZY");
        case SGMSG_TYPE_SET_QVALS_PUSH:     return("SGMSG_TYPE_SET_QVALS_PUSH");
        case SGMSG_TYPE_SET_QVALS_REP:      return("SGMSG_TYPE_SET_QVALS_REP");
        case SGMSG_TYPE_SPIDATA_REQ:        return("SGMSG_TYPE_SPIDATA_REQ");
        case SGMSG_TYPE_SPIDATA_REQ2:       return("SGMSG_TYPE_SPIDATA_REQ2");
        case SGMSG_TYPE_SPIDATA_REP:        return("SGMSG_TYPE_SPIDATA_REP");
        case SGMSG_TYPE_NOTIFY_CLI_DEL:     return("SGMSG_TYPE_NOTIFY_CLI_DEL");
        case SGMSG_TYPE_NOTIFY_CLI_UPD:     return("SGMSG_TYPE_NOTIFY_CLI_UPD");
        case SGMSG_TYPE_NOTIFY_CLI_TCHG:    return("SGMSG_TYPE_NOTIFY_CLI_TCHG");
        case SGMSG_TYPE_XBTOXB_FORWARD2:    return("SGMSG_TYPE_XBTOXB_FORWARD2");

        case SGMSG_TYPE_SPIDATA:            return("SGMSG_TYPE_SPIDATA");
        case SGMSG_TYPE_AUTHDATA:           return("SGMSG_TYPE_AUTHDATA");
    }

    return("?");
}

char * SgXspTypeStr(BYTE bType)
{
    switch (bType)
    {
        case XSP_TYPE_SEC:          return("XSP_TYPE_SEC");
        case XSP_TYPE_TCP_0:        return("XSP_TYPE_TCP_0");
        case XSP_TYPE_TCP_1:        return("XSP_TYPE_TCP_1");
        case XSP_TYPE_TCP_2:        return("XSP_TYPE_TCP_2");
        case XSP_TYPE_UDP_0:        return("XSP_TYPE_UDP_0");
        case XSP_TYPE_UDP_1:        return("XSP_TYPE_UDP_1");
        case XSP_TYPE_UDP_2:        return("XSP_TYPE_UDP_2");
        case XSP_TYPE_VDP_0:        return("XSP_TYPE_VDP_0");
        case XSP_TYPE_VDP_1:        return("XSP_TYPE_VDP_1");
        case XSP_TYPE_VDP_2:        return("XSP_TYPE_VDP_2");
        case XSP_TYPE_VDP_VO_0:     return("XSP_TYPE_VDP_VO_0");
        case XSP_TYPE_VDP_VO_1:     return("XSP_TYPE_VDP_VO_1");
        case XSP_TYPE_VDP_VO_2:     return("XSP_TYPE_VDP_VO_2");
        case XSP_TYPE_VDP_DO_0:     return("XSP_TYPE_VDP_DO_0");
        case XSP_TYPE_VDP_DO_1:     return("XSP_TYPE_VDP_DO_1");
        case XSP_TYPE_VDP_DO_2:     return("XSP_TYPE_VDP_DO_2");
    }
    
    return("?");
}

char * CIpAddr::Str() const
{
    STATIC_BUFFER(CIpAddrStr, 32, 16);
    _snprintf(pch, cch, "%d.%d.%d.%d", _ab[0], _ab[1], _ab[2], _ab[3]);
    return(pch);
}

char * CEnetAddr::Str() const
{
    STATIC_BUFFER(CEnetAddrStr, 32, 18);
    _snprintf(pch, cch, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgkeyex.cpp ===
// ---------------------------------------------------------------------------------------
// sgkeyex.cpp
//
// Key Exchange handlers
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// SgIRecvKeyEx
//
// This function continues processing of a key-exchange packet from SgIRecv
// ---------------------------------------------------------------------------------------

void SgIRecvKeyEx(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo *        pTransInfoRecv   = ppkt->_pTransInfoRecv;
    CKeyExXbToSgInit *  pKeyExInit       = (CKeyExXbToSgInit *)ppkt->_pb;
    WORD                wKeyExInitType   = KEYEX_TYPE_XBTOSG_INIT;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    UINT                cb               = ppkt->_cb;

#ifdef SG_FEATURE_LSP

    if(pKeyExInit->_wType == KEYEX_TYPE_XBTOTS_INIT)
    {
        // The SG-LSP build supports the legacy TS key exchange style which is slightly
        // different from the "regular" key exchange

        SgIRecvTsKeyEx(ppkt);
        return;
    }

#endif

    SgPerfdataInc(KeyExTotal, 1);

    // Verify that the key exchange payload size is within configured limits

    if (cb < g_cbKeyExXbToSgInitMin)
    {
        TraceSz(RecvDiscard, "%s: KeyEx payload (%d bytes) is smaller than minimum (%d bytes)",
                 ppkt->Str(), cb, g_cbKeyExXbToSgInitMin);
        SgEventPacketLogNoisyEx(TOOSMALL_KEYEX_PACKET, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc), 0, sizeof(UINT), &cb);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Verify that the series of payloads is well-formed and has at least one entry.

    if (cb < sizeof(CKeyExHdr) || !SgKeyExVerify(pKeyExInit, cb))
    {
        TraceSz(RecvDiscard, "%s: KeyEx packet format is invalid (cb=%d)",
                 ppkt->Str(), cb);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_0, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      min(cb, sizeof(*pKeyExInit)), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Ignore the final padding entry, if any.

    CKeyExHdr * pKeyExPad = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_PADDING);

    if (pKeyExPad != NULL)
    {
        if ((UINT)((BYTE *)pKeyExPad - (BYTE *)pKeyExInit) + pKeyExPad->_cbEnt != cb)
        {
            TraceSz(RecvDiscard, "%s: KeyEx packet padding is invalid (cb=%d)", ppkt->Str(), cb);
            SgEventPacketNoisy(INVALID_KEYEX_PACKET_1, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          min(cb, sizeof(*pKeyExInit)), pKeyExInit);
            SgPerfdataInc(DropKeyExFormat, 1);
            goto complete;
        }

        cb -= pKeyExPad->_cbEnt;
    }

    // Process the remaining entries

    if (    pKeyExInit->_wType != wKeyExInitType
        ||  pKeyExInit->_cbEnt < sizeof(*pKeyExInit)
        ||  pKeyExInit->_wVersion > KEYEX_VERSION)
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit entry is invalid (%d,%d,%d)",
                 ppkt->Str(),
                 cb >= sizeof(CKeyExHdr) && pKeyExInit->_wType != wKeyExInitType,
                 cb >= sizeof(CKeyExHdr) &&  pKeyExInit->_cbEnt < sizeof(*pKeyExInit),
                 cb >= sizeof(*pKeyExInit) && pKeyExInit->_wVersion > KEYEX_VERSION);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_2, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      min(cb, sizeof(*pKeyExInit)), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    if (pKeyExInit->_wFlags & ~(XSIF_CONNECTION_SERVICE))
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit dwFlags (%08lX) has unrecognized flags",
                 ppkt->Str(), pKeyExInit->_wFlags);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_3, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    if ((pKeyExInit->_wFlags & XSIF_CONNECTION_SERVICE) && !g_fEnableConnectionServices)
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit connection service not enabled", ppkt->Str());
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_4, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    if (   (pKeyExInit->_dwSpiInit & XSP_SPI_MASK) == 0
        || (pKeyExInit->_dwSpiInit & XSP_FLAGS_MASK) != 0)
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit dwSpiInit (%08lX) is invalid", ppkt->Str(),
                 pKeyExInit->_dwSpiInit);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_5, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Find the diffie-hellman g^X value.

    CKeyExHdr * pKeyExDhGX = pKeyExCtx->_pKeyExDhGX = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_DH_GX);

    if (    pKeyExDhGX == NULL
        ||  pKeyExDhGX->_cbEnt != sizeof(CKeyExHdr) + CBDHG1
        ||  SgKeyExDhGXIsInvalid((BYTE *)(pKeyExDhGX + 1)))
    {
        TraceSz(RecvDiscard, "%s: KeyEx DH entry is invalid (%d,%d,%d)",
                 ppkt->Str(),
                 pKeyExDhGX == NULL,
                 pKeyExDhGX != NULL && pKeyExDhGX->_cbEnt < sizeof(CKeyExHdr) + CBDHG1,
                 pKeyExDhGX != NULL && pKeyExDhGX->_cbEnt == sizeof(CKeyExHdr) + CBDHG1 && SgKeyExDhGXIsInvalid((BYTE *)(pKeyExDhGX + 1)));
        SgEventPacket(INVALID_KEYEX_PACKET_6, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      pKeyExDhGX ? pKeyExDhGX->_cbEnt : 0, pKeyExDhGX);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Find the APREQ entry.  It must be the last entry.

    pKeyExCtx->_pKeyExApReq = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_KERB_APREQ);
    CKeyExHdr * pKeyExApReq = pKeyExCtx->_pKeyExApReq;

#ifdef SG_FEATURE_INSECURE
    if (pKeyExApReq == NULL)
    {
        pKeyExCtx->_pKeyExApReq = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_NULL_APREQ);
        pKeyExApReq = pKeyExCtx->_pKeyExApReq;
    }
#endif

    if (    pKeyExApReq == NULL
        ||  (   pKeyExApReq->_wType != KEYEX_TYPE_KERB_APREQ
             && pKeyExApReq->_wType != KEYEX_TYPE_NULL_APREQ)
        ||  (UINT)((BYTE *)pKeyExApReq - (BYTE *)pKeyExInit) + pKeyExApReq->_cbEnt != cb)
    {
        TraceSz(RecvDiscard, "%s: KeyEx APREQ entry is invalid (%d,%d,%d)",
                 ppkt->Str(),
                 pKeyExApReq == NULL,
                 pKeyExApReq != NULL && (   pKeyExApReq->_wType != KEYEX_TYPE_KERB_APREQ
                                         && pKeyExApReq->_wType != KEYEX_TYPE_NULL_APREQ),
                 pKeyExApReq != NULL && ((UINT)((BYTE *)pKeyExApReq - (BYTE *)pKeyExInit) + pKeyExApReq->_cbEnt != cb));
        SgEventPacket(INVALID_KEYEX_PACKET_7, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      pKeyExApReq ? min(cb, sizeof(CKeyExHdr)) : 0, pKeyExApReq);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Crack the ApReq and fill in CKeyExCtx

#ifdef SG_FEATURE_INSECURE
    if (pKeyExApReq->_wType == KEYEX_TYPE_NULL_APREQ)
    {
        if (!SgCrackNullApReq(ppkt))
        {
            TraceSz(RecvDiscard, "%s: SgCrackNullApReq failed", ppkt->Str());
            SgEventPacket(INVALID_KERBEROS_TICKET_29, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          sizeof(*pKeyExInit), pKeyExInit);
            SgPerfdataInc(DropKeyExKerb, 1);
            goto complete;
        }
    }
    else
#endif
    {
        Assert(pKeyExApReq->_wType == KEYEX_TYPE_KERB_APREQ);

        if (!SgCrackKerbApReq(ppkt, ((CKeyExKerbApReq *)pKeyExApReq)->_ab, pKeyExApReq->_cbEnt - sizeof(CKeyExHdr)))
        {
            TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed", ppkt->Str());
            SgEventPacketLogEx(INVALID_KERBEROS_TICKET_1, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc),
                               0, sizeof(*pKeyExInit), pKeyExInit);
            SgPerfdataInc(DropKeyExKerb, 1);
            goto complete;
        }
    }

    // Reorder the users and set guest bits in auth data

    SgKeyExPermute( &pKeyExCtx->_AuthData, pKeyExInit->_dwUserPerm );

    // Trace out the KeyEx contents if requested

    if (Tag(RecvKeyEx))
    {
        TraceSz(RecvKeyEx, "%s: [KeyEx XbToSgInit Recv]", ppkt->Str());
        TraceSz(RecvKeyEx, "%s:  [_wVersion    = %04X]", ppkt->Str(), pKeyExInit->_wVersion);
        TraceSz(RecvKeyEx, "%s:  [_wFlags      = %04X]", ppkt->Str(), pKeyExInit->_wFlags);
        TraceSz(RecvKeyEx, "%s:  [_dwSpiInit   = %08X]", ppkt->Str(), pKeyExInit->_dwSpiInit);
        TraceSz(RecvKeyEx, "%s:  [_abNonceInit = %s]", ppkt->Str(), SgHexStr(pKeyExInit->_abNonceInit, sizeof(pKeyExInit->_abNonceInit)));
        TraceSz(RecvKeyEx, "%s:  [_dwUserPerm  = %08X]", ppkt->Str(), pKeyExInit->_dwUserPerm);
        TraceSz(RecvKeyEx, "%s:  [_abDhGX      = %s]", ppkt->Str(), SgHexStr(pKeyExDhGX + 1, pKeyExDhGX->_cbEnt - sizeof(CKeyExHdr)));
        TraceSz(RecvKeyEx, "%s:  [_wTypeApReq  = %d (%s)]", ppkt->Str(), pKeyExApReq->_wType, (pKeyExApReq->_wType == KEYEX_TYPE_NULL_APREQ) ? "NULL" : pKeyExApReq->_wType == KEYEX_TYPE_KERB_APREQ ? "KERB" : "?");
        TraceSz(RecvKeyEx, "%s:  [_cbApReq     = %d]", ppkt->Str(), pKeyExApReq->_cbEnt - sizeof(CKeyExHdr));
        TraceSz(RecvKeyEx, "%s:  [_liEndTime   = %s]", ppkt->Str(), SgTimeToStr( pKeyExCtx->_liEndTime.QuadPart ) );

        for (UINT i = 0; i < 4; ++i)
        {
            XUID* pxuid = &pKeyExCtx->_AuthData.users[ i ];
            TraceSz(RecvKeyEx, "%s:  [User %d       = %016I64X/%08lX]",
                     ppkt->Str(), i, pxuid->qwUserID, pxuid->dwUserFlags);
        }
    }

    // Lookup the client based on pSiteInfo and PUID

    SgCliInfoAttach(ppkt, SgIRecvKeyExWithCli, pKeyExCtx->_dwSiteId, &pKeyExCtx->_puid);
    return;

complete:
    ppkt->Complete();
    return;
}

void SgIRecvKeyExWithCli(CPacket * ppkt)
{
    CCliInfo *          pCliInfo            = ppkt->_pCliInfo;
    CKeyExCtx *         pKeyExCtx           = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExXbToSgInit *  pKeyExInit          = (CKeyExXbToSgInit *)ppkt->_pb;
    CKeyExHdr *         pKeyExApReq         = pKeyExCtx->_pKeyExApReq;

    if (pCliInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx cannot allocate CCliInfo for PUID %s in site %08lX",
                 ppkt->Str(), SgHexStr(&pKeyExCtx->_puid, sizeof(pKeyExCtx->_puid)),
                 pKeyExCtx->_dwSiteId);
        // SgCliInfoAlloc logs an event
        goto complete;
    }

    Assert(pCliInfo->_ppkt == ppkt);

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitReplayCheck)
#endif
    {
        if (g_fForceReplay ? g_fForceReplayValue : (pKeyExCtx->_liTime.QuadPart <= pCliInfo->_liTimeAuth.QuadPart))
        {
            pCliInfo->_cReplay += 1;

            TraceSz(RecvDiscard, "%s: KeyEx authenticator is replayed (%d times)",
                     ppkt->Str(), pCliInfo->_cReplay);

            struct {
                PUID            puid;
                DWORD           dwSiteId;
                LARGE_INTEGER   liTimeLast;
                LARGE_INTEGER   liTimeAuth;
                LARGE_INTEGER   liTimeDiff;
                ULONG           cReplay;
            } ReplayEventInfo;

            ReplayEventInfo.puid                = pCliInfo->_puid;
            ReplayEventInfo.dwSiteId            = pCliInfo->_dwSiteId;
            ReplayEventInfo.liTimeLast          = pCliInfo->_liTimeAuth;
            ReplayEventInfo.liTimeAuth          = pKeyExCtx->_liTime;
            ReplayEventInfo.liTimeDiff.QuadPart = pCliInfo->_liTimeAuth.QuadPart - pKeyExCtx->_liTime.QuadPart;
            ReplayEventInfo.cReplay             = pCliInfo->_cReplay;

            SgEventPacketLogNoisyEx(REPLAYED_KERBEROS_AUTHENTICATOR, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc),
                                    0, sizeof(ReplayEventInfo), &ReplayEventInfo);
            SgPerfdataInc(DropAuthenticator, 1);
            goto detach;
        }
    }

    // Is this machine puid blocked?
    ULONGLONG qwBlockTime = 0;
    if (SgBlockInfoIsBlocked( &(pCliInfo->_puid), &qwBlockTime ) == TRUE) 
    {
        TraceSz(
            RecvDiscard, 
            "%s: KeyEx from PUID %s blocked until %s", 
            ppkt->Str(), 
            SgHexStr(&(pCliInfo->_puid), sizeof(pCliInfo->_puid)),
            SgTimeToStr(qwBlockTime)
            );
        SgPerfdataInc(DropKeyExBlocked, 1);
        goto detach;
    }

    // Remember the highest authenticator time accepted for this client

    pCliInfo->_liTimeAuth.QuadPart = pKeyExCtx->_liTime.QuadPart;

    if (!g_fForceReplay && g_iKeyExMinRetryInterval > 0)
    {
        // Make sure a minimum amount of time has elapsed since the last time this client
        // attempted a key exchange.
        ULONGLONG qwTimeNow = SgGetSystemTime();
        ULONGLONG qwTimePrev = pCliInfo->_qwTimeKeyEx;
        ULONGLONG qwTimeDiff;

        pCliInfo->_qwTimeKeyEx = qwTimeNow;

        qwTimeDiff = qwTimeNow - qwTimePrev;
        if( qwTimeDiff > 0 && qwTimeDiff < g_iKeyExMinRetryInterval )
        {
            TraceSz(
                RecvDiscard, 
                "%s: KeyEx from PUID %s site %08lX only %d ms since previous (min is %d ms)",
                ppkt->Str(), 
                SgHexStr(&pKeyExCtx->_puid, sizeof(pKeyExCtx->_puid)), 
                pKeyExCtx->_dwSiteId,
                (DWORD)(qwTimeDiff / 10000), 
                g_iKeyExMinRetryInterval / 10000
                );
            TraceSz(RecvDiscard, "%s:   Prev KeyEx: %s", ppkt->Str(), SgTimeToStr(qwTimePrev));
            TraceSz(RecvDiscard, "%s:   This KeyEx: %s", ppkt->Str(), SgTimeToStr(qwTimeNow));

            struct {
                PUID            puid;
                DWORD           dwSiteId;
                ULONGLONG       qwTimePrev;
                ULONGLONG       qwTimeThis;
                ULONGLONG       qwTimeDiff;
            } TooSoonEventInfo;

            TooSoonEventInfo.puid       = pCliInfo->_puid;
            TooSoonEventInfo.dwSiteId   = pCliInfo->_dwSiteId;
            TooSoonEventInfo.qwTimePrev = qwTimePrev;
            TooSoonEventInfo.qwTimeThis = qwTimeNow;
            TooSoonEventInfo.qwTimeDiff = qwTimeDiff;

            SgEventPacketLogNoisyEx(TOOSOON_KEYEX_PACKET, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc),
                                    0, sizeof(TooSoonEventInfo), &TooSoonEventInfo);
            SgPerfdataInc(DropKeyExTooSoon, 1);
            goto detach;
        }
    }

    // Compute and verify the SHA digest of the key-exchange message

    BYTE abSha[sizeof(pKeyExCtx->_abSha)];

    XcHMAC4(pKeyExCtx->_abKey, sizeof(pKeyExCtx->_abKey),
            (BYTE *)pKeyExInit, (DWORD)((BYTE *)pKeyExApReq - (BYTE *)pKeyExInit),
            NULL, 0, NULL, 0, NULL, 0, abSha);

    if (memcmp(abSha, pKeyExCtx->_abSha, sizeof(abSha)) != 0)
    {
        TraceSz(RecvDiscard, "%s: KeyEx failed SHA authentication", ppkt->Str());
        SgEventPacket(INVALID_KEYEX_PACKET_8, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExHash, 1);
        goto detach;
    }

    // If the client is requesting connection services, verify that the authentication data
    // specifies XONLINE_PRESENCE_SERVICE or XONLINE_SIGNATURE_SERVICE.
    if (pKeyExInit->_wFlags & XSIF_CONNECTION_SERVICE)
    {
        if( !pKeyExCtx->_AuthData.IsSvcAuthorized( XONLINE_PRESENCE_SERVICE ) &&
            !pKeyExCtx->_AuthData.IsSvcAuthorized( XONLINE_SIGNATURE_SERVICE ) )
        {
            TraceSz(RecvDiscard, "%s: KeyEx requested CS services but AuthData doesn't allow it", ppkt->Str());
            SgEventPacket(CS_NOT_ALLOWED, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          sizeof(*pKeyExInit), pKeyExInit);
            SgPerfdataInc(DropDenied, 1);
            goto detach;
        }
    }

    // Attach to the CSpiInfo for this client (if any).
    SgSpiInfoAttach(ppkt, SgIRecvKeyExWithSpi, pCliInfo->_fSpiDeleted ? 0 : pCliInfo->_dwSpi);
    return;

detach:
    SgCliInfoDetach(ppkt);

complete:
    ppkt->Complete();
    return;
}

void SgIRecvKeyExWithSpi(CPacket * ppkt)
{
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CCliInfo *          pCliInfo         = ppkt->_pCliInfo;
    CKeyExXbToSgInit *  pKeyExInit       = (CKeyExXbToSgInit *)ppkt->_pb;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExHdr *         pKeyExDhGX       = pKeyExCtx->_pKeyExDhGX;

    if (pSpiInfo == NULL || pSpiInfo->_pCliInfo != pCliInfo)
    {
        // This CSpiInfo has either been deleted, is in the process of being deleted, or is currently
        // assigned to some other client.  Allocate a new CSpiInfo for this client.

        SgSpiInfoDetach(ppkt);
        SgSpiInfoAlloc(ppkt, SgIRecvKeyExBuildSpi);
        return;
    }

    Assert(pSpiInfo->_ppkt == ppkt);
    Assert(pCliInfo->_ppkt == ppkt);

    // This is probably a retransmission of the key exchange initiator from the same client.
    // Verify that everything is the same as before, and that we have never received a packet
    // from the client.  If so, we'll just retransmit the key exchange response packet.
    // If anything is different, however, free the CSpiInfo and start over.

    Assert(sizeof(pSpiInfo->_abNonceInit) == sizeof(pKeyExInit->_abNonceInit));
    Assert(sizeof(pSpiInfo->_abKeyHmac) == sizeof(pKeyExCtx->_abKey));

    BOOL fGXMatch;

    Assert(sizeof(pSpiInfo->_abDhGX) == (pKeyExDhGX->_cbEnt - sizeof(CKeyExHdr)));
    fGXMatch = (memcmp(pSpiInfo->_abDhGX, (pKeyExDhGX + 1), sizeof(pSpiInfo->_abDhGX)) == 0);

    if (    pSpiInfo->_qwTickRecv != 0
        ||  pSpiInfo->_dwSpiXmit != pKeyExInit->_dwSpiInit
        ||  pSpiInfo->_wVersionInit != pKeyExInit->_wVersion
        ||  pSpiInfo->_wFlagsInit != pKeyExInit->_wFlags
        ||  memcmp(pSpiInfo->_abNonceInit, pKeyExInit->_abNonceInit, sizeof(pSpiInfo->_abNonceInit)) != 0
        ||  memcmp(pSpiInfo->_abKeyHmac, pKeyExCtx->_abKey, sizeof(pSpiInfo->_abKeyHmac)) != 0
        ||  !fGXMatch
        ||  pSpiInfo->_AuthData.GetCb() != pKeyExCtx->_AuthData.GetCb()
        ||  memcmp(&pSpiInfo->_AuthData, &pKeyExCtx->_AuthData, pKeyExCtx->_AuthData.GetCb()) != 0
        ||  memcmp(&pSpiInfo->_eaI, &ppkt->_pEnetHdr->_eaSrc, sizeof(pSpiInfo->_eaI)) != 0
        ||  pSpiInfo->_ipaI != ppkt->_pIpHdr->_ipaSrc)
    {
        goto reinit;
    }

    if (pSpiInfo->_ipportI != ppkt->_pXspHdr->_ipportSrc)
    {
        if (!g_fKeyExDontSendIcmp)
        {
            // Looks like the client is using a NetGear router with broken firmware.  When we
            // send the ICMP port-unreachable packet in front of the KeyEx response, the router
            // closes the port mapping and drops the KeyEx response as a result.  When the client
            // retransmits the KeyEx initiator the router assigns a different external port, which
            // is unacceptable.  So what we do now is ignore this KeyEx initiator altogether.
            // The client will eventually timeout the key exchange and give up.

            pSpiInfo->_ipportI = 0;     // Special marker for the log file to diagnose this issue

            ppkt->Complete();
            return;
        }

        goto reinit;
    }

    // LSG bug 6824 - the previous time we called SgIXmitKeyExWithSpi incremented the
    // per-crypto perf counter. Only SgSpiInfoFree will decrement it. Since we're about to
    // increment it again, we should decrement it also.
    if (pSpiInfo->_qwTickKeyEx1 != 0)
    {
        switch (pSpiInfo->_cbKeyCrypt)
        {
        case XC_SERVICE_DES_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherDes);
            break;
        case XC_SERVICE_DES3_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherDes3);
            break;
        case XC_SERVICE_AES_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherAes);
            break;
        case XC_SERVICE_NULL_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherNull);
            break;
        }
    }

    SgIXmitKeyExWithSpi(ppkt);
    return;

reinit:

    // Remember what our current SPI is so that we can store in the new SPI
    DWORD dwSpiRecv = pSpiInfo->_dwSpiRecv;

    TraceSz(SpiTrace, "%08lX released PUID %s (KeyEx re-initiated %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)",
              pSpiInfo->_dwSpiRecv, SgHexStr(&pCliInfo->_puid, sizeof(pCliInfo->_puid)),
              pSpiInfo->_qwTickRecv != 0,
              pSpiInfo->_dwSpiXmit != pKeyExInit->_dwSpiInit,
              pSpiInfo->_wVersionInit != pKeyExInit->_wVersion,
              pSpiInfo->_wFlagsInit != pKeyExInit->_wFlags,
              memcmp(pSpiInfo->_abNonceInit, pKeyExInit->_abNonceInit, sizeof(pSpiInfo->_abNonceInit)) != 0,
              memcmp(pSpiInfo->_abKeyHmac, pKeyExCtx->_abKey, sizeof(pSpiInfo->_abKeyHmac)) != 0,
              !fGXMatch,
              pSpiInfo->_AuthData.GetCb() != pKeyExCtx->_AuthData.GetCb(),
              memcmp(&pSpiInfo->_AuthData, &pKeyExCtx->_AuthData, pKeyExCtx->_AuthData.GetCb()) != 0,
              memcmp(&pSpiInfo->_eaI, &ppkt->_pEnetHdr->_eaSrc, sizeof(pSpiInfo->_eaI)) != 0,
              pSpiInfo->_ipaI != ppkt->_pIpHdr->_ipaSrc,
              pSpiInfo->_ipportI != ppkt->_pXspHdr->_ipportSrc);

    SgPerfdataInc(LogoffReinit, 1);
    SgSpiInfoFree(pSpiInfo, SPIDEL_REINIT);
    pSpiInfo = NULL;

    SgSpiInfoDetach(ppkt);
    SgSpiInfoAlloc(ppkt, SgIRecvKeyExBuildSpi, dwSpiRecv);
    return;
}

void SgIRecvKeyExBuildSpi(CPacket * ppkt)
{
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CCliInfo *          pCliInfo         = ppkt->_pCliInfo;
    CTransInfo *        pTransInfoRecv   = ppkt->_pTransInfoRecv;
    CKeyExXbToSgInit *  pKeyExInit       = (CKeyExXbToSgInit *)ppkt->_pb;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExHdr *         pKeyExDhGX       = pKeyExCtx->_pKeyExDhGX;
    UINT i;

    if (pSpiInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx cannot allocate CSpiInfo", ppkt->Str());
        goto complete;
    }

    CNatInfo * pNatInfo = SgNatInfoAlloc(pSpiInfo->_dwSpiRecv);

    if (pNatInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx cannot allocate CNatInfo", ppkt->Str());
        SgSpiInfoFree(pSpiInfo, SPIDEL_ALLOC);
        goto complete;
    }

    SgCliInfoSetSpiInfo(pCliInfo, pSpiInfo);

    // Decide on what encryption method to use.
    //
    // 1. If platform is PC or Xbox360 and client version is greater than or equal to the
    // AesMinClientVersion, set to AES.
    //
    // 2. Else use DES or DES3 depending on the configured DES key length.
    //

    UINT    cbKeySize       = g_cbKeyDes;
    DWORD   dwClientVersion = pKeyExCtx->_AuthData.GetClientVersion();
    BYTE    platType        = pKeyExCtx->_AuthData.GetPlatform();
    if ((platType == XPLT_XBOX360 && dwClientVersion >= g_dwAesMinClientVersionXbox360) ||
        (platType == XPLT_PC      && dwClientVersion >= g_dwAesMinClientVersionPc))
    {
        // Look at our override list and determine if this connection should really be
        // using NULL.
        if (SgNullCipherCheckMachine(pCliInfo->_puid.QuadPart))
        {
            TraceSz(RecvKeyEx, "%s: Enabling NULL cipher for machine %016I64X", ppkt->Str(), pCliInfo->_puid.QuadPart);
            cbKeySize = XC_SERVICE_NULL_KEYSIZE;
        }
        else if (g_fAesProtocolEnabled)
        {
            cbKeySize = XC_SERVICE_AES_KEYSIZE;
        }
    }
    // else use des/des3, as already set in cbKeySize

    pSpiInfo->_pTransInfo   = pTransInfoRecv;
    pSpiInfo->_pCliInfo     = pCliInfo;
    pSpiInfo->_puid         = pCliInfo->_puid;
    pSpiInfo->_pNatInfo     = pNatInfo;
    pSpiInfo->_dwSpiXmit    = pKeyExInit->_dwSpiInit;
    pSpiInfo->_cbKeyCrypt   = cbKeySize;
    pSpiInfo->_wVersionInit = pKeyExInit->_wVersion;
    pSpiInfo->_wFlagsInit   = pKeyExInit->_wFlags;
    pSpiInfo->_svcMask    = SgSvcInfoMask(
        pKeyExCtx->_AuthData.wNumExtendedServices,
        pKeyExCtx->_AuthData.dwExtendedServices,
        ServiceMask(pKeyExCtx->_AuthData.dwBaseServices)
        );
    pSpiInfo->_svcMaskOrig = pSpiInfo->_svcMask;

    pSpiInfo->_eaI      = ppkt->_pEnetHdr->_eaSrc;
    pSpiInfo->_ipaI     = ppkt->_pIpHdr->_ipaSrc;
    pSpiInfo->_ipportI  = ppkt->_pXspHdr->_ipportSrc;

    pSpiInfo->_AuthData = pKeyExCtx->_AuthData;
#ifdef SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
    SgConvertAuthData4ToAuthData3(&pSpiInfo->_AuthData, &pSpiInfo->_AuthDataV3);
#endif
    pSpiInfo->_dwLastTitleId = pSpiInfo->_AuthData.dwTitleID;

    for (i=0; i<4; ++i)
    {
        if (!XOnlineIsUserGuest(pSpiInfo->_AuthData.users[i].dwUserFlags))
        {
            pSpiInfo->_aUserInfo[i]._qwUserId = pSpiInfo->_AuthData.users[i].qwUserID;
        }
    }

    Assert(sizeof(pSpiInfo->_abKeyHmac) == sizeof(pKeyExCtx->_abKey));
    memcpy(pSpiInfo->_abKeyHmac, pKeyExCtx->_abKey, sizeof(pSpiInfo->_abKeyHmac));

    Assert(sizeof(pSpiInfo->_abNonceInit) == sizeof(pKeyExInit->_abNonceInit));
    memcpy(pSpiInfo->_abNonceInit, pKeyExInit->_abNonceInit, sizeof(pSpiInfo->_abNonceInit));

    Assert(sizeof(pSpiInfo->_abDhGX) == (pKeyExDhGX->_cbEnt - sizeof(CKeyExHdr)));
    memcpy(pSpiInfo->_abDhGX, (pKeyExDhGX + 1), sizeof(pSpiInfo->_abDhGX));

    SgRand(pSpiInfo->_abNonceResp, sizeof(pSpiInfo->_abNonceResp));

    pSpiInfo->_qwTimeInit = SgGetSystemTime();

    if (pSpiInfo->_wFlagsInit & XSIF_CONNECTION_SERVICE)
    {
        pSpiInfo->_fCs = TRUE;
    }

    // Apply filters, which may end up blocking the client or changing the crypto params.
#ifdef SG_FEATURE_LUA
    SgApplyFilterScriptWithSpi(pSpiInfo);
    pSpiInfo->_fLuaFilterKeyEx = TRUE;
#endif

    // This builds the key material (session keys) for the spi and is quite expensive.
    // Only do it if the client isn't getting blocked.
    if (!(pSpiInfo->_dwSpiFlags & SPIFLAG_BLOCK))
    {
        SgOffloadBuildSpi(ppkt);

        if (!ppkt->_fOffloadSuccess)
        {
            goto complete;
        }
    }

    // Log the ADD
    SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_ADD, NULL, pKeyExCtx);

    TraceSz(SpiTrace, "%08lX assigned PUID %016I64X %c%d/%s:%d <-> %c%d/%s:%d%s",
              pSpiInfo->_dwSpiRecv, pCliInfo->_puid,
              (char)pSpiInfo->_pTransInfo->_dwType, pSpiInfo->_pTransInfo->_iTransInfo,
              ppkt->_pIpHdr->_ipaSrc.Str(), NTOHS(ppkt->_pXspHdr->_ipportSrc),
              (char)pNatInfo->_pTransInfo->_dwType, pNatInfo->_pTransInfo->_iTransInfo,
              pNatInfo->_ipaZ.Str(), pNatInfo->_iBasePortZ, pSpiInfo->_fCs ? " (CS)" : "");

    // Uh oh, got blocked. Free the spi and log the DEL.
    if (pSpiInfo->_dwSpiFlags & SPIFLAG_BLOCK)
    {
        TraceSz(SpiTrace, "%08lX released PUID %016I64X (AuthBlock)", pSpiInfo->_dwSpiRecv,
                 pSpiInfo->_puid);

        SgSpiInfoFree(pSpiInfo, SPIDEL_BLOCK1);
        goto complete;
    }

    // Log the FLOWMAP
    SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_FLOWMAP, NULL, NULL);

    #if DBG
    if (g_fDumpFirstKeyExResp)
    {
        pSpiInfo->_qwTickKeyEx1 = SgTimerTick();
        goto complete;
    }
    #endif

    SgIXmitKeyExWithSpi(ppkt);

    return;

complete:
    ppkt->Complete();
    return;
}

void SgIXmitKeyExWithSpi(CPacket * ppkt)
{
    CTransInfo *        pTransInfoRecv   = ppkt->_pTransInfoRecv;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CKeyExSgToXbResp *  pKeyExResp       = &pKeyExCtx->_KeyExRespSg;

    Assert(pSpiInfo != NULL);

    if (!g_fKeyExDontSendIcmp)
    {
        // Send a bogus ICMP port-unreachable packet to the sender to tickle a bug in the
        // firmware of the NetGear router, if they are using one.  This is supposed to be
        // a no-op in all other cases.

        SgIcmpXmit(ppkt);
    }

    // Fill out the CKeyExSgToXbResp response

    pKeyExResp->_wType    = KEYEX_TYPE_SGTOXB_RESP;
    pKeyExResp->_cbEnt    = sizeof(*pKeyExResp);
    pKeyExResp->_wVersion = KEYEX_VERSION;
    pKeyExResp->_wFlags   = 0;

    switch (pSpiInfo->_cbKeyCrypt)
    {
    case XC_SERVICE_DES_KEYSIZE:
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_DES;
        break;
    case XC_SERVICE_AES_KEYSIZE:
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_AES;
        break;
    case XC_SERVICE_NULL_KEYSIZE:
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_NULL;
        break;
    default:
        Assert(pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES3_KEYSIZE);
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_3DES;
        break;
    }

    pKeyExResp->_dwSpiInit = pSpiInfo->_dwSpiXmit;
    pKeyExResp->_dwSpiResp = pSpiInfo->_dwSpiRecv;

    Assert(sizeof(pKeyExResp->_abNonceInit) == sizeof(pSpiInfo->_abNonceInit));
    memcpy(pKeyExResp->_abNonceInit, pSpiInfo->_abNonceInit, sizeof(pKeyExResp->_abNonceInit));
    Assert(sizeof(pKeyExResp->_abNonceResp) == sizeof(pSpiInfo->_abNonceResp));
    memcpy(pKeyExResp->_abNonceResp, pSpiInfo->_abNonceResp, sizeof(pKeyExResp->_abNonceResp));

    SgSpiInfoToSgAddr(pSpiInfo, &pKeyExResp->_sgaddrInit);
    pKeyExResp->_inaInit = pSpiInfo->_ipaI;
    pKeyExResp->_wPortInit = pSpiInfo->_ipportI;
    pKeyExResp->_wXbToSgTimeoutInSecs = (WORD) g_cXbToSgTimeoutInSeconds;
    pKeyExResp->_wXbToSgPulseTimeoutInSecs = (WORD) g_cXbToSgPulseTimeoutInSeconds;
    pKeyExResp->_wPadZero = 0;

    // Encrypt the _sgaddrInit to _wPadZero (end of struct) members. If we're using DES or
    // DES3, we must use DES3 here for back-compat. If we're using AES, then use AES to
    // encrypt, and also make sure we're encrypting a multiple of 16 bytes.
    //

    const DWORD dwEncKeyexSize = sizeof(*pKeyExResp) - offsetof(CKeyExSgToXbResp, _sgaddrInit);
    if (pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES_KEYSIZE ||
        pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES3_KEYSIZE)
    {
        Assert((dwEncKeyexSize % 8) == 0);
        XcCrypt(XC_SERVICE_ENCRYPT,
                pSpiInfo->_keyMaterialDes._abKeyCryptXmit,
                XC_SERVICE_DES3_KEYSIZE,
                pSpiInfo->_abNonceResp,
                (BYTE *)&pKeyExResp->_sgaddrInit,
                dwEncKeyexSize,
                NULL,
                0);
    }
    else
    {
        // AES, NULL. The IV must be 16 bytes, so since our nonce is only 8 bytes, we'll
        // use the Init AND Resp nonces together.
        Assert((dwEncKeyexSize % 16) == 0);
        C_ASSERT(offsetof(CSpiInfo, _abNonceResp) - offsetof(CSpiInfo, _abNonceInit) == 8);
        XcCrypt(XC_SERVICE_ENCRYPT,
                pSpiInfo->_keyMaterialAes._abKeyCryptXmit,
                XC_SERVICE_AES_KEYSIZE,
                pSpiInfo->_abNonceInit,  // _abNonceInit + _abNonceResp
                (BYTE *)&pKeyExResp->_sgaddrInit,
                dwEncKeyexSize,
                NULL,
                0);
    }

    pKeyExCtx->_KeyExDhGY._wType = KEYEX_TYPE_DH_GX;
    pKeyExCtx->_KeyExDhGY._cbEnt = sizeof(CKeyExHdr) + sizeof(pKeyExCtx->_abDhGY);
    Assert(sizeof(pKeyExCtx->_abDhGY) == sizeof(pSpiInfo->_abDhGY));
    memcpy(pKeyExCtx->_abDhGY, pSpiInfo->_abDhGY, sizeof(pKeyExCtx->_abDhGY));

    pKeyExCtx->_KeyExSgToXbChal._cbEnt = 0;

#ifdef SG_FEATURE_LUA

    // Fill in the packet with the challenge/response parameters (if any)

    if (!SgChalAssignSyncChallenge( pSpiInfo, pKeyExCtx ))
    {
        // Perf counter?
        TraceSz(RecvDiscard, "%s: SgChalXmitKeyExWithSpi - Client Kicked", ppkt->Str());
        goto complete;
    }

#endif

    // Compute the SHA of the key-exchange response

    XcHMAC4(pSpiInfo->_abKeyHmac, sizeof(pSpiInfo->_abKeyHmac),
            (BYTE *)pKeyExResp, pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt,
            (BYTE *)&pKeyExCtx->_KeyExSgToXbChal, pKeyExCtx->_KeyExSgToXbChal._cbEnt,
            NULL, 0, NULL, 0, pKeyExCtx->_abSha);

    // Fill out the AP reply portion of the key-exchange response

#ifdef SG_FEATURE_INSECURE
    if( pKeyExCtx->_pKeyExApReq->_wType == KEYEX_TYPE_NULL_APREQ )
    {
        if (!SgBuildNullApRep(ppkt))
        {
            TraceSz(RecvDiscard, "%s: SgBuildNullApRep failed", ppkt->Str());
            // SgBuildNullApRep logs the error
            goto complete;
        }
    }
    else
#endif
    if (!SgBuildKerbApRep(ppkt))
    {
        TraceSz(RecvDiscard, "%s: SgBuildKerbApRep failed", ppkt->Str());
        // SgBuildKerbApRep logs the error
        goto complete;
    }

    // Generate the key-exchange response packet

    CEnetHdr *  pEnetHdr = ppkt->_pEnetHdr;
    CIpHdr *    pIpHdr   = ppkt->_pIpHdr;
    CXspHdr *   pXspHdr  = ppkt->_pXspHdr;

    pEnetHdr->_eaDst   = pSpiInfo->_eaI;
    pEnetHdr->_eaSrc   = pTransInfoRecv->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS(sizeof(CIpHdr) + sizeof(CXspHdr) + pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt + pKeyExCtx->_KeyExSgToXbChal._cbEnt + pKeyExCtx->_KerbApRep._cbEnt);
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc    = pTransInfoRecv->_ipa;
    pIpHdr->_ipaDst    = pSpiInfo->_ipaI;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pXspHdr->_ipportDst     = pSpiInfo->_ipportI;
    pXspHdr->_ipportSrc     = XSP_PORT;
    pXspHdr->_dwSpiAndFlags = 0;

    SgSetUdpHdrChecksum(pIpHdr, pXspHdr, sizeof(CXspHdr),
                        (BYTE *)pKeyExResp, pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt,
                        (BYTE *)&pKeyExCtx->_KeyExSgToXbChal, pKeyExCtx->_KeyExSgToXbChal._cbEnt,
                        (BYTE *)&pKeyExCtx->_KerbApRep, pKeyExCtx->_KerbApRep._cbEnt,
                        NULL, 0);

    // Trace out the KeyEx contents if requested

    if (Tag(XmitKeyEx))
    {
        TraceSz(XmitKeyEx, "%s: [KeyEx SbToXgResp Xmit]", ppkt->Str());
        TraceSz(XmitKeyEx, "%s:  [_wVersion    = %04X]", ppkt->Str(), pKeyExResp->_wVersion);
        TraceSz(XmitKeyEx, "%s:  [_wFlags      = %04X]", ppkt->Str(), pKeyExResp->_wFlags);
        TraceSz(XmitKeyEx, "%s:  [_dwSpiInit   = %08X]", ppkt->Str(), pKeyExResp->_dwSpiInit);
        TraceSz(XmitKeyEx, "%s:  [_dwSpiResp   = %08X]", ppkt->Str(), pKeyExResp->_dwSpiResp);
        TraceSz(XmitKeyEx, "%s:  [_abNonceInit = %s]", ppkt->Str(), SgHexStr(pKeyExResp->_abNonceInit, sizeof(pKeyExResp->_abNonceInit)));
        TraceSz(XmitKeyEx, "%s:  [_abNonceResp = %s]", ppkt->Str(), SgHexStr(pKeyExResp->_abNonceResp, sizeof(pKeyExResp->_abNonceResp)));
        TraceSz(XmitKeyEx, "%s:  [_abDhGY      = %s]", ppkt->Str(), SgHexStr(pKeyExCtx->_abDhGY, sizeof(pKeyExCtx->_abDhGY)));
        TraceSz(XmitKeyEx, "%s:  [_cbChal      = %d]", ppkt->Str(), pKeyExCtx->_KeyExSgToXbChal._cbEnt);
        TraceSz(XmitKeyEx, "%s:  [_wTypeApRep  = %d (%s)]", ppkt->Str(), pKeyExCtx->_KerbApRep._wType, pKeyExCtx->_KerbApRep._wType == KEYEX_TYPE_NULL_APREP ? "NULL" : pKeyExCtx->_KerbApRep._wType == KEYEX_TYPE_KERB_APREP ? "KERB" : "?");
        TraceSz(XmitKeyEx, "%s:  [_cbApRep     = %d]", ppkt->Str(), pKeyExCtx->_KerbApRep._cbEnt - sizeof(CKeyExHdr));
    }

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr);
    *ppb++ = (BYTE *)pIpHdr;
    *pcb++ = sizeof(CIpHdr);
    *ppb++ = (BYTE *)pXspHdr;
    *pcb++ = sizeof(CXspHdr);
    *ppb++ = (BYTE *)pKeyExResp;
    *pcb++ = pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt;

    if (pKeyExCtx->_KeyExSgToXbChal._cbEnt != 0)
    {
        *ppb++ = (BYTE *)&pKeyExCtx->_KeyExSgToXbChal;
        *pcb++ = pKeyExCtx->_KeyExSgToXbChal._cbEnt;
    }

    *ppb++ = (BYTE *)&pKeyExCtx->_KerbApRep;
    *pcb++ = pKeyExCtx->_KerbApRep._cbEnt;

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    pSpiInfo->_qwTickTicketStart = pSpiInfo->_qwTickKeyEx1 = SgTimerTick();
    pSpiInfo->_qwTickTicketEnd  = pSpiInfo->_qwTickTicketStart + (pKeyExCtx->_dwLifetimeInSeconds * TICKS_PER_SECOND);

    // The per-cipher perf counters are keyed off the _qwTickKeyEx1 field. This is because
    // we are responsible for both incrementing and decrementing them, and these need to
    // sum to zero.
    switch (pSpiInfo->_cbKeyCrypt)
    {
    case XC_SERVICE_DES_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherDes);
        break;
    case XC_SERVICE_DES3_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherDes3);
        break;
    case XC_SERVICE_AES_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherAes);
        break;
    case XC_SERVICE_NULL_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherNull);
        break;
    }

    //
    // This is the case where there is no challenge selected for the
    // client. In this situation, we don't want to block waiting for
    // C/R packet since we will never get one
    //

    if (pKeyExCtx->_KeyExSgToXbChal._cbEnt == 0)
    {
        pSpiInfo->_qwTickKeyEx2 = SgTimerTick();

        //
        // Determine if anytime challenges need to be enabled
        //

#ifdef SG_FEATURE_LUA
        SgChalCodeUpdateSpiInfo(pSpiInfo);
#endif
    }

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitKeyExResp)
    {
        SgSpiInfoFree(pSpiInfo, SPIDEL_INHIBIT);
    }
#endif

    SgPerfdataInc(KeyEx, 1);
    SgSpiInfoDetach(ppkt);
    SgCliInfoDetach(ppkt);

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitKeyExResp || g_fInhibitKeyExXmit)
        goto complete;
#endif

    ppkt->_pTransInfoXmit = pTransInfoRecv;
    SgXmit(ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}

#ifdef SG_FEATURE_LSP

void SgIRecvTsKeyEx(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo *        pTransInfoRecv   = ppkt->_pTransInfoRecv;
    CKeyExXbToTsInit *  pKeyExInit       = (CKeyExXbToTsInit *)ppkt->_pb;
    WORD                wKeyExInitType   = KEYEX_TYPE_XBTOTS_INIT;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    UINT                cb               = ppkt->_cb;

    SgPerfdataInc(KeyExTotal, 1);

    // Verify that the key exchange payload size is within configured limits

    if (cb < g_cbKeyExXbToSgInitMin)
    {
        TraceSz(RecvDiscard, "%s: KeyEx payload (%d bytes) is smaller than minimum (%d bytes)",
                 ppkt->Str(), cb, g_cbKeyExXbToSgInitMin);
        SgEventPacketLogNoisyEx(TOOSMALL_KEYEX_PACKET, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc), 0, sizeof(UINT), &cb);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Verify that the series of payloads is well-formed and has at least one entry.

    if (cb < sizeof(CKeyExHdr) || !SgKeyExVerify(pKeyExInit, cb))
    {
        TraceSz(RecvDiscard, "%s: KeyEx packet format is invalid (cb=%d)",
                 ppkt->Str(), cb);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_0, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      min(cb, sizeof(*pKeyExInit)), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Ignore the final padding entry, if any.

    CKeyExHdr * pKeyExPad = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_PADDING);

    if (pKeyExPad != NULL)
    {
        if ((UINT)((BYTE *)pKeyExPad - (BYTE *)pKeyExInit) + pKeyExPad->_cbEnt != cb)
        {
            TraceSz(RecvDiscard, "%s: KeyEx packet padding is invalid (cb=%d)", ppkt->Str(), cb);
            SgEventPacketNoisy(INVALID_KEYEX_PACKET_1, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          min(cb, sizeof(*pKeyExInit)), pKeyExInit);
            SgPerfdataInc(DropKeyExFormat, 1);
            goto complete;
        }

        cb -= pKeyExPad->_cbEnt;
    }

    // Process the remaining entries

    if (    pKeyExInit->_wType != wKeyExInitType
        ||  pKeyExInit->_cbEnt < sizeof(*pKeyExInit)
        ||  pKeyExInit->_wVersion > KEYEX_VERSION)
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit entry is invalid (%d,%d,%d)",
                 ppkt->Str(),
                 cb >= sizeof(CKeyExHdr) && pKeyExInit->_wType != wKeyExInitType,
                 cb >= sizeof(CKeyExHdr) &&  pKeyExInit->_cbEnt < sizeof(*pKeyExInit),
                 cb >= sizeof(*pKeyExInit) && pKeyExInit->_wVersion > KEYEX_VERSION);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_2, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      min(cb, sizeof(*pKeyExInit)), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    if (pKeyExInit->_wFlags & ~(XSIF_CONNECTION_SERVICE))
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit dwFlags (%08lX) has unrecognized flags",
                 ppkt->Str(), pKeyExInit->_wFlags);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_3, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    if ((pKeyExInit->_wFlags & XSIF_CONNECTION_SERVICE) && !g_fEnableConnectionServices)
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit connection service not enabled", ppkt->Str());
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_4, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    if (   (pKeyExInit->_dwSpiInit & XSP_SPI_MASK) == 0
        || (pKeyExInit->_dwSpiInit & XSP_FLAGS_MASK) != 0)
    {
        TraceSz(RecvDiscard, "%s: KeyEx XbToSgInit dwSpiInit (%08lX) is invalid", ppkt->Str(),
                 pKeyExInit->_dwSpiInit);
        SgEventPacketNoisy(INVALID_KEYEX_PACKET_5, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Find the diffie-hellman g^X value.

    CKeyExHdr * pKeyExDhGX = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_DH_GX);

    if (pKeyExDhGX != NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx DH is present", ppkt->Str());
        SgEventPacket(INVALID_KEYEX_PACKET_6, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      pKeyExDhGX ? pKeyExDhGX->_cbEnt : 0, pKeyExDhGX);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // the lack of the g^X is what marks this context as a TS key-exchange

    pKeyExCtx->_pKeyExDhGX = NULL;

    // Find the APREQ entry.  It must be the last entry.

    pKeyExCtx->_pKeyExApReq = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_KERB_APREQ);
    CKeyExHdr * pKeyExApReq = pKeyExCtx->_pKeyExApReq;

#ifdef SG_FEATURE_INSECURE
    if (pKeyExApReq == NULL)
    {
        pKeyExCtx->_pKeyExApReq = SgKeyExLookup(pKeyExInit, cb, KEYEX_TYPE_NULL_APREQ);
        pKeyExApReq = pKeyExCtx->_pKeyExApReq;
    }
#endif

    if (    pKeyExApReq == NULL
        ||  (   pKeyExApReq->_wType != KEYEX_TYPE_KERB_APREQ
             && pKeyExApReq->_wType != KEYEX_TYPE_NULL_APREQ)
        ||  (UINT)((BYTE *)pKeyExApReq - (BYTE *)pKeyExInit) + pKeyExApReq->_cbEnt != cb)
    {
        TraceSz(RecvDiscard, "%s: KeyEx APREQ entry is invalid (%d,%d,%d)",
                 ppkt->Str(),
                 pKeyExApReq == NULL,
                 pKeyExApReq != NULL && (   pKeyExApReq->_wType != KEYEX_TYPE_KERB_APREQ
                                         && pKeyExApReq->_wType != KEYEX_TYPE_NULL_APREQ),
                 pKeyExApReq != NULL && ((UINT)((BYTE *)pKeyExApReq - (BYTE *)pKeyExInit) + pKeyExApReq->_cbEnt != cb));
        SgEventPacket(INVALID_KEYEX_PACKET_7, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      pKeyExApReq ? min(cb, sizeof(CKeyExHdr)) : 0, pKeyExApReq);
        SgPerfdataInc(DropKeyExFormat, 1);
        goto complete;
    }

    // Crack the ApReq and fill in CKeyExCtx

#ifdef SG_FEATURE_INSECURE
    if (pKeyExApReq->_wType == KEYEX_TYPE_NULL_APREQ)
    {
        if (!SgCrackNullApReq(ppkt))
        {
            TraceSz(RecvDiscard, "%s: SgCrackNullApReq failed", ppkt->Str());
            SgEventPacket(INVALID_KERBEROS_TICKET_29, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          sizeof(*pKeyExInit), pKeyExInit);
            SgPerfdataInc(DropKeyExKerb, 1);
            goto complete;
        }
    }
    else
#endif
    {
        Assert(pKeyExApReq->_wType == KEYEX_TYPE_KERB_APREQ);

        if (!SgCrackKerbApReq(ppkt, ((CKeyExKerbApReq *)pKeyExApReq)->_ab, pKeyExApReq->_cbEnt - sizeof(CKeyExHdr)))
        {
            TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed", ppkt->Str());
            SgEventPacket(INVALID_KERBEROS_TICKET_1, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          sizeof(*pKeyExInit), pKeyExInit);
            SgPerfdataInc(DropKeyExKerb, 1);
            goto complete;
        }
    }

    // Reorder the users and set guest bits in auth data

    SgKeyExPermute( &pKeyExCtx->_AuthData, pKeyExInit->_dwUserPerm );

    // Trace out the KeyEx contents if requested

    if (Tag(RecvKeyEx))
    {
        TraceSz(RecvKeyEx, "%s: [KeyEx XbToTsInit Recv]", ppkt->Str());
        TraceSz(RecvKeyEx, "%s:  [_wVersion    = %04X]", ppkt->Str(), pKeyExInit->_wVersion);
        TraceSz(RecvKeyEx, "%s:  [_wFlags      = %04X]", ppkt->Str(), pKeyExInit->_wFlags);
        TraceSz(RecvKeyEx, "%s:  [_dwSpiInit   = %08X]", ppkt->Str(), pKeyExInit->_dwSpiInit);
        TraceSz(RecvKeyEx, "%s:  [_abNonceInit = %s]", ppkt->Str(), SgHexStr(pKeyExInit->_abNonceInit, sizeof(pKeyExInit->_abNonceInit)));
        TraceSz(RecvKeyEx, "%s:  [_dwUserPerm  = %08X]", ppkt->Str(), pKeyExInit->_dwUserPerm);
        TraceSz(RecvKeyEx, "%s:  [_wTypeApReq  = %d (%s)]", ppkt->Str(), pKeyExApReq->_wType, (pKeyExApReq->_wType == KEYEX_TYPE_NULL_APREQ) ? "NULL" : pKeyExApReq->_wType == KEYEX_TYPE_KERB_APREQ ? "KERB" : "?");
        TraceSz(RecvKeyEx, "%s:  [_cbApReq     = %d]", ppkt->Str(), pKeyExApReq->_cbEnt - sizeof(CKeyExHdr));

        for (UINT i = 0; i < 4; ++i)
        {
            XUID* pxuid = &pKeyExCtx->_AuthData.users[ i ];
            TraceSz(RecvKeyEx, "%s:  [User %d       = %s/%08lX]",
                     ppkt->Str(), i, SgHexStr(pxuid, sizeof(*pxuid)), pxuid->dwUserFlags);
        }
    }

    // Lookup the client based on pSiteInfo and PUID

    SgCliInfoAttach(ppkt, SgIRecvTsKeyExWithCli, pKeyExCtx->_dwSiteId, &pKeyExCtx->_puid);
    return;

complete:
    ppkt->Complete();
    return;
}

void SgIRecvTsKeyExWithCli(CPacket * ppkt)
{
    CCliInfo *          pCliInfo            = ppkt->_pCliInfo;
    CKeyExCtx *         pKeyExCtx           = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExXbToTsInit *  pKeyExInit          = (CKeyExXbToTsInit *)ppkt->_pb;
    CKeyExHdr *         pKeyExApReq         = pKeyExCtx->_pKeyExApReq;

    if (pCliInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx cannot allocate CCliInfo for PUID %016I64X in site %08lX",
                 ppkt->Str(), pKeyExCtx->_puid,
                 pKeyExCtx->_dwSiteId);
        // SgCliInfoAlloc logs an event
        goto complete;
    }

    Assert(pCliInfo->_ppkt == ppkt);

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitReplayCheck)
#endif
    {
        if (g_fForceReplay ? g_fForceReplayValue : (pKeyExCtx->_liTime.QuadPart <= pCliInfo->_liTimeAuth.QuadPart))
        {
            pCliInfo->_cReplay += 1;

            TraceSz(RecvDiscard, "%s: KeyEx authenticator is replayed (%d times)",
                     ppkt->Str(), pCliInfo->_cReplay);

            struct {
                PUID            puid;
                DWORD           dwSiteId;
                LARGE_INTEGER   liTimeLast;
                LARGE_INTEGER   liTimeAuth;
                LARGE_INTEGER   liTimeDiff;
                ULONG           cReplay;
            } ReplayEventInfo;

            ReplayEventInfo.puid                = pCliInfo->_puid;
            ReplayEventInfo.dwSiteId            = pCliInfo->_dwSiteId;
            ReplayEventInfo.liTimeLast          = pCliInfo->_liTimeAuth;
            ReplayEventInfo.liTimeAuth          = pKeyExCtx->_liTime;
            ReplayEventInfo.liTimeDiff.QuadPart = pCliInfo->_liTimeAuth.QuadPart - pKeyExCtx->_liTime.QuadPart;
            ReplayEventInfo.cReplay             = pCliInfo->_cReplay;

            SgEventPacketLogNoisyEx(REPLAYED_KERBEROS_AUTHENTICATOR, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc),
                                    0, sizeof(ReplayEventInfo), &ReplayEventInfo);
            SgPerfdataInc(DropAuthenticator, 1);
            goto detach;
        }
    }

    // Remember the highest authenticator time accepted for this client

    pCliInfo->_liTimeAuth.QuadPart = pKeyExCtx->_liTime.QuadPart;

    if (!g_fForceReplay && g_iKeyExMinRetryInterval > 0)
    {
        // Make sure a minimum amount of time has elapsed since the last time this client
        // attempted a key exchange.
        ULONGLONG qwTimeNow = SgGetSystemTime();
        ULONGLONG qwTimePrev = pCliInfo->_qwTimeKeyEx;
        ULONGLONG qwTimeDiff;

        pCliInfo->_qwTimeKeyEx = qwTimeNow;

        qwTimeDiff = qwTimeNow - qwTimePrev;
        if( qwTimeDiff > 0 && qwTimeDiff < g_iKeyExMinRetryInterval )
        {
            TraceSz(RecvDiscard, "%s: KeyEx from PUID %016I64X site %08lX only %d ms since previous (min is %d ms)",
                     ppkt->Str(), pKeyExCtx->_puid, pKeyExCtx->_dwSiteId,
                     (DWORD)(qwTimeDiff / 10000), g_iKeyExMinRetryInterval / 10000);
            TraceSz(RecvDiscard, "%s:   Prev KeyEx: %s", ppkt->Str(), SgTimeToStr(qwTimePrev));
            TraceSz(RecvDiscard, "%s:   This KeyEx: %s", ppkt->Str(), SgTimeToStr(qwTimeNow));

            struct {
                PUID            puid;
                DWORD           dwSiteId;
                ULONGLONG       qwTimePrev;
                ULONGLONG       qwTimeThis;
                ULONGLONG       qwTimeDiff;
            } TooSoonEventInfo;

            TooSoonEventInfo.puid       = pCliInfo->_puid;
            TooSoonEventInfo.dwSiteId   = pCliInfo->_dwSiteId;
            TooSoonEventInfo.qwTimePrev = qwTimePrev;
            TooSoonEventInfo.qwTimeThis = qwTimeNow;
            TooSoonEventInfo.qwTimeDiff = qwTimeDiff;

            SgEventPacketLogNoisyEx(TOOSOON_KEYEX_PACKET, ppkt, ppkt->_pIpHdr->_ipaSrc, NTOHS(ppkt->_pXspHdr->_ipportSrc),
                                    0, sizeof(TooSoonEventInfo), &TooSoonEventInfo);
            SgPerfdataInc(DropKeyExTooSoon, 1);
            goto detach;
        }
    }

    // Compute and verify the SHA digest of the key-exchange message

    BYTE abSha[sizeof(pKeyExCtx->_abSha)];

    XcHMAC4(pKeyExCtx->_abKey, sizeof(pKeyExCtx->_abKey),
            (BYTE *)pKeyExInit, (DWORD)((BYTE *)pKeyExApReq - (BYTE *)pKeyExInit),
            NULL, 0, NULL, 0, NULL, 0, abSha);

    if (memcmp(abSha, pKeyExCtx->_abSha, sizeof(abSha)) != 0)
    {
        TraceSz(RecvDiscard, "%s: KeyEx failed SHA authentication", ppkt->Str());
        SgEventPacket(INVALID_KEYEX_PACKET_8, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                      sizeof(*pKeyExInit), pKeyExInit);
        SgPerfdataInc(DropKeyExHash, 1);
        goto detach;
    }

    Assert(!(pKeyExInit->_wFlags & XSIF_CONNECTION_SERVICE));

    // Attach to the CSpiInfo for this client (if any).
    SgSpiInfoAttach(ppkt, SgIRecvTsKeyExWithSpi, pCliInfo->_fSpiDeleted ? 0 : pCliInfo->_dwSpi);
    return;

detach:
    SgCliInfoDetach(ppkt);

complete:
    ppkt->Complete();
    return;
}

void SgIRecvTsKeyExWithSpi(CPacket * ppkt)
{
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CCliInfo *          pCliInfo         = ppkt->_pCliInfo;
    CKeyExXbToTsInit *  pKeyExInit       = (CKeyExXbToTsInit *)ppkt->_pb;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExHdr *         pKeyExDhGX       = pKeyExCtx->_pKeyExDhGX;

    if (pSpiInfo == NULL || pSpiInfo->_pCliInfo != pCliInfo)
    {
        // This CSpiInfo has either been deleted, is in the process of being deleted, or is currently
        // assigned to some other client.  Allocate a new CSpiInfo for this client.

        SgSpiInfoDetach(ppkt);
        SgSpiInfoAlloc(ppkt, SgIRecvTsKeyExBuildSpi);
        return;
    }

    Assert(pSpiInfo->_ppkt == ppkt);
    Assert(pCliInfo->_ppkt == ppkt);

    // This is probably a retransmission of the key exchange initiator from the same client.
    // Verify that everything is the same as before, and that we have never received a packet
    // from the client.  If so, we'll just retransmit the key exchange response packet.
    // If anything is different, however, free the CSpiInfo and start over.

    Assert(sizeof(pSpiInfo->_abNonceInit) == sizeof(pKeyExInit->_abNonceInit));
    Assert(sizeof(pSpiInfo->_abKeyHmac) == sizeof(pKeyExCtx->_abKey));

    BOOL fGXMatch;

    fGXMatch = (memcmp(&pSpiInfo->_xnkid, &pKeyExInit->_xnkid, sizeof(pSpiInfo->_xnkid)) == 0);

    if (    pSpiInfo->_qwTickRecv != 0
        ||  pSpiInfo->_dwSpiXmit != pKeyExInit->_dwSpiInit
        ||  pSpiInfo->_wVersionInit != pKeyExInit->_wVersion
        ||  pSpiInfo->_wFlagsInit != pKeyExInit->_wFlags
        ||  memcmp(pSpiInfo->_abNonceInit, pKeyExInit->_abNonceInit, sizeof(pSpiInfo->_abNonceInit)) != 0
        ||  memcmp(pSpiInfo->_abKeyHmac, pKeyExCtx->_abKey, sizeof(pSpiInfo->_abKeyHmac)) != 0
        ||  !fGXMatch
        ||  pSpiInfo->_AuthData.GetCb() != pKeyExCtx->_AuthData.GetCb()
        ||  memcmp(&pSpiInfo->_AuthData, &pKeyExCtx->_AuthData, pKeyExCtx->_AuthData.GetCb()) != 0
        ||  memcmp(&pSpiInfo->_eaI, &ppkt->_pEnetHdr->_eaSrc, sizeof(pSpiInfo->_eaI)) != 0
        ||  pSpiInfo->_ipaI != ppkt->_pIpHdr->_ipaSrc)
    {
        goto reinit;
    }

    if (pSpiInfo->_ipportI != ppkt->_pXspHdr->_ipportSrc)
    {
        if (!g_fKeyExDontSendIcmp)
        {
            // Looks like the client is using a NetGear router with broken firmware.  When we
            // send the ICMP port-unreachable packet in front of the KeyEx response, the router
            // closes the port mapping and drops the KeyEx response as a result.  When the client
            // retransmits the KeyEx initiator the router assigns a different external port, which
            // is unacceptable.  So what we do now is ignore this KeyEx initiator altogether.
            // The client will eventually timeout the key exchange and give up.

            pSpiInfo->_ipportI = 0;     // Special marker for the log file to diagnose this issue

            ppkt->Complete();
            return;
        }

        goto reinit;
    }

    // LSG bug 6824 - the previous time we called SgIXmitKeyExWithSpi incremented the
    // per-crypto perf counter. Only SgSpiInfoFree will decrement it. Since we're about to
    // increment it again, we should decrement it also.
    if (pSpiInfo->_qwTickKeyEx1 != 0)
    {
        switch (pSpiInfo->_cbKeyCrypt)
        {
        case XC_SERVICE_DES_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherDes);
            break;
        case XC_SERVICE_DES3_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherDes3);
            break;
        case XC_SERVICE_AES_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherAes);
            break;
        case XC_SERVICE_NULL_KEYSIZE:
            SgPerfdataInterlockedDec(ConnectionsCipherNull);
            break;
        }
    }

    SgIXmitTsKeyExWithSpi(ppkt);
    return;

reinit:

    // Remember what our current SPI is so that we can store in the new SPI
    DWORD dwSpiRecv = pSpiInfo->_dwSpiRecv;

    TraceSz(SpiTrace, "%08lX released PUID %016I64X (KeyEx re-initiated %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)",
              pSpiInfo->_dwSpiRecv, pCliInfo->_puid,
              pSpiInfo->_qwTickRecv != 0,
              pSpiInfo->_dwSpiXmit != pKeyExInit->_dwSpiInit,
              pSpiInfo->_wVersionInit != pKeyExInit->_wVersion,
              pSpiInfo->_wFlagsInit != pKeyExInit->_wFlags,
              memcmp(pSpiInfo->_abNonceInit, pKeyExInit->_abNonceInit, sizeof(pSpiInfo->_abNonceInit)) != 0,
              memcmp(pSpiInfo->_abKeyHmac, pKeyExCtx->_abKey, sizeof(pSpiInfo->_abKeyHmac)) != 0,
              !fGXMatch,
              pSpiInfo->_AuthData.GetCb() != pKeyExCtx->_AuthData.GetCb(),
              memcmp(&pSpiInfo->_AuthData, &pKeyExCtx->_AuthData, pKeyExCtx->_AuthData.GetCb()) != 0,
              memcmp(&pSpiInfo->_eaI, &ppkt->_pEnetHdr->_eaSrc, sizeof(pSpiInfo->_eaI)) != 0,
              pSpiInfo->_ipaI != ppkt->_pIpHdr->_ipaSrc,
              pSpiInfo->_ipportI != ppkt->_pXspHdr->_ipportSrc);

    SgPerfdataInc(LogoffReinit, 1);
    SgSpiInfoFree(pSpiInfo, SPIDEL_REINIT);
    pSpiInfo = NULL;

    SgSpiInfoDetach(ppkt);
    SgSpiInfoAlloc(ppkt, SgIRecvTsKeyExBuildSpi, dwSpiRecv);
    return;
}

void SgIRecvTsKeyExBuildSpi(CPacket * ppkt)
{
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CCliInfo *          pCliInfo         = ppkt->_pCliInfo;
    CTransInfo *        pTransInfoRecv   = ppkt->_pTransInfoRecv;
    CKeyExXbToTsInit *  pKeyExInit       = (CKeyExXbToTsInit *)ppkt->_pb;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CKeyExHdr *         pKeyExDhGX       = pKeyExCtx->_pKeyExDhGX;
    UINT i;

    if (pSpiInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx cannot allocate CSpiInfo", ppkt->Str());
        goto complete;
    }

    memcpy(&pSpiInfo->_xnkid, &pKeyExInit->_xnkid, sizeof(pSpiInfo->_xnkid));
    if (!SgLspLookupQueryKey(&pSpiInfo->_xnkid, pSpiInfo->_abKeyShaKeyEx))
    {
        TraceSz(RecvDiscard, "%s: KeyEx no matching XNKID", ppkt->Str());
        SgSpiInfoFree(pSpiInfo, SPIDEL_ALLOC);
        goto complete;
    }

    CNatInfo * pNatInfo = SgNatInfoAlloc(pSpiInfo->_dwSpiRecv);

    if (pNatInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: KeyEx cannot allocate CNatInfo", ppkt->Str());
        SgSpiInfoFree(pSpiInfo, SPIDEL_ALLOC);
        goto complete;
    }

    SgCliInfoSetSpiInfo(pCliInfo, pSpiInfo);

    // Decide on what encryption method to use.
    //
    // 1. If platform is PC or Xbox360 and client version is greater than or equal to the
    // AesMinClientVersion, set to AES.
    //
    // 2. Else use DES or DES3 depending on the configured DES key length.
    //

    UINT    cbKeySize       = g_cbKeyDes;
    DWORD   dwClientVersion = pKeyExCtx->_AuthData.GetClientVersion();
    BYTE    platType        = pKeyExCtx->_AuthData.GetPlatform();
    if ((platType == XPLT_XBOX360 && dwClientVersion >= g_dwAesMinClientVersionXbox360) ||
        (platType == XPLT_PC      && dwClientVersion >= g_dwAesMinClientVersionPc))
    {
        // Look at our override list and determine if this connection should really be
        // using NULL.
        if (SgNullCipherCheckMachine(pCliInfo->_puid.QuadPart))
        {
            TraceSz(RecvKeyEx, "%s: Enabling NULL cipher for machine %016I64X", ppkt->Str(), pCliInfo->_puid.QuadPart);
            cbKeySize = XC_SERVICE_NULL_KEYSIZE;
        }
        else if (g_fAesProtocolEnabled)
        {
            cbKeySize = XC_SERVICE_AES_KEYSIZE;
        }
    }
    // else use des/des3, as already set in cbKeySize

    pSpiInfo->_pTransInfo   = pTransInfoRecv;
    pSpiInfo->_pCliInfo     = pCliInfo;
    pSpiInfo->_puid         = pCliInfo->_puid;
    pSpiInfo->_pNatInfo     = pNatInfo;
    pSpiInfo->_dwSpiXmit    = pKeyExInit->_dwSpiInit;
    pSpiInfo->_cbKeyCrypt   = cbKeySize;
    pSpiInfo->_wVersionInit = pKeyExInit->_wVersion;
    pSpiInfo->_wFlagsInit   = pKeyExInit->_wFlags;
    pSpiInfo->_svcMask    = SgSvcInfoMask(
        pKeyExCtx->_AuthData.wNumExtendedServices,
        pKeyExCtx->_AuthData.dwExtendedServices,
        ServiceMask(pKeyExCtx->_AuthData.dwBaseServices)
        );
    pSpiInfo->_svcMaskOrig = pSpiInfo->_svcMask;

    pSpiInfo->_eaI      = ppkt->_pEnetHdr->_eaSrc;
    pSpiInfo->_ipaI     = ppkt->_pIpHdr->_ipaSrc;
    pSpiInfo->_ipportI  = ppkt->_pXspHdr->_ipportSrc;

    pSpiInfo->_AuthData = pKeyExCtx->_AuthData;
#ifdef SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
    SgConvertAuthData4ToAuthData3(&pSpiInfo->_AuthData, &pSpiInfo->_AuthDataV3);
#endif
    pSpiInfo->_dwLastTitleId = pSpiInfo->_AuthData.dwTitleID;

    for (i=0; i<4; ++i)
    {
        if (!XOnlineIsUserGuest(pSpiInfo->_AuthData.users[i].dwUserFlags))
        {
            pSpiInfo->_aUserInfo[i]._qwUserId = pSpiInfo->_AuthData.users[i].qwUserID;
        }
    }

    Assert(sizeof(pSpiInfo->_abKeyHmac) == sizeof(pKeyExCtx->_abKey));
    memcpy(pSpiInfo->_abKeyHmac, pKeyExCtx->_abKey, sizeof(pSpiInfo->_abKeyHmac));

    Assert(sizeof(pSpiInfo->_abNonceInit) == sizeof(pKeyExInit->_abNonceInit));
    memcpy(pSpiInfo->_abNonceInit, pKeyExInit->_abNonceInit, sizeof(pSpiInfo->_abNonceInit));

    SgRand(pSpiInfo->_abNonceResp, sizeof(pSpiInfo->_abNonceResp));

    pSpiInfo->_qwTimeInit = SgGetSystemTime();

    SgOffloadBuildSpi(ppkt);

    if (!ppkt->_fOffloadSuccess)
    {
        goto complete;
    }

    if (pSpiInfo->_wFlagsInit & XSIF_CONNECTION_SERVICE)
    {
        pSpiInfo->_fCs = TRUE;
    }

    SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_ADD, NULL, pKeyExCtx);

    TraceSz(SpiTrace, "%08lX assigned PUID %016I64X %c%d/%s:%d <-> %c%d/%s:%d%s",
              pSpiInfo->_dwSpiRecv, pCliInfo->_puid,
              (char)pSpiInfo->_pTransInfo->_dwType, pSpiInfo->_pTransInfo->_iTransInfo,
              ppkt->_pIpHdr->_ipaSrc.Str(), NTOHS(ppkt->_pXspHdr->_ipportSrc),
              (char)pNatInfo->_pTransInfo->_dwType, pNatInfo->_pTransInfo->_iTransInfo,
              pNatInfo->_ipaZ.Str(), pNatInfo->_iBasePortZ, pSpiInfo->_fCs ? " (CS)" : "");

    if (pSpiInfo->_dwSpiFlags & SPIFLAG_BLOCK)
    {
        TraceSz(SpiTrace, "%08lX released PUID %016I64X (AuthBlock)", pSpiInfo->_dwSpiRecv,
                 pSpiInfo->_puid);

        SgSpiInfoFree(pSpiInfo, SPIDEL_BLOCK1);
        goto complete;
    }

    // Log the FLOWMAP
    SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_FLOWMAP, NULL, NULL);

    #if DBG
    if (g_fDumpFirstKeyExResp)
    {
        pSpiInfo->_qwTickKeyEx1 = SgTimerTick();
        goto complete;
    }
    #endif

    SgIXmitTsKeyExWithSpi(ppkt);

    return;

complete:
    ppkt->Complete();
    return;
}

void SgIXmitTsKeyExWithSpi(CPacket * ppkt)
{
    CTransInfo *        pTransInfoRecv   = ppkt->_pTransInfoRecv;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CKeyExTsToXbResp *  pKeyExResp       = &pKeyExCtx->_KeyExRespTs;

    Assert(pSpiInfo != NULL);

    if (!g_fKeyExDontSendIcmp)
    {
        // Send a bogus ICMP port-unreachable packet to the sender to tickle a bug in the
        // firmware of the NetGear router, if they are using one.  This is supposed to be
        // a no-op in all other cases.

        SgIcmpXmit(ppkt);
    }

    // Fill out the CKeyExSgToXbResp response

    pKeyExResp->_wType    = KEYEX_TYPE_TSTOXB_RESP;
    pKeyExResp->_cbEnt    = sizeof(*pKeyExResp);
    pKeyExResp->_wVersion = KEYEX_VERSION;
    pKeyExResp->_wFlags   = 0;

    switch (pSpiInfo->_cbKeyCrypt)
    {
    case XC_SERVICE_DES_KEYSIZE:
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_DES;
        break;
    case XC_SERVICE_AES_KEYSIZE:
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_AES;
        break;
    case XC_SERVICE_NULL_KEYSIZE:
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_NULL;
        break;
    default:
        Assert(pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES3_KEYSIZE);
        pKeyExResp->_wFlags |= SXRF_ENCRYPT_3DES;
        break;
    }

    pKeyExResp->_dwSpiInit = pSpiInfo->_dwSpiXmit;
    pKeyExResp->_dwSpiResp = pSpiInfo->_dwSpiRecv;

    Assert(sizeof(pKeyExResp->_abNonceInit) == sizeof(pSpiInfo->_abNonceInit));
    memcpy(pKeyExResp->_abNonceInit, pSpiInfo->_abNonceInit, sizeof(pKeyExResp->_abNonceInit));
    Assert(sizeof(pKeyExResp->_abNonceResp) == sizeof(pSpiInfo->_abNonceResp));
    memcpy(pKeyExResp->_abNonceResp, pSpiInfo->_abNonceResp, sizeof(pKeyExResp->_abNonceResp));

    pKeyExResp->_wXbToTsTimeoutInSecs = (WORD) g_cXbToSgTimeoutInSeconds;
    pKeyExResp->_wXbToTsPulseTimeoutInSecs = (WORD) g_cXbToSgPulseTimeoutInSeconds;

    pKeyExCtx->_KeyExSgToXbChal._cbEnt = 0;
    pKeyExCtx->_KeyExDhGY._cbEnt       = 0;

    // Compute the SHA of the key-exchange response

    XcHMAC4(pSpiInfo->_abKeyHmac, sizeof(pSpiInfo->_abKeyHmac),
            (BYTE *)pKeyExResp, pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt,
            (BYTE *)&pKeyExCtx->_KeyExSgToXbChal, pKeyExCtx->_KeyExSgToXbChal._cbEnt,
            NULL, 0, NULL, 0, pKeyExCtx->_abSha);

    // Fill out the AP reply portion of the key-exchange response

#ifdef SG_FEATURE_INSECURE
    if( pKeyExCtx->_pKeyExApReq->_wType == KEYEX_TYPE_NULL_APREQ )
    {
        if (!SgBuildNullApRep(ppkt))
        {
            TraceSz(RecvDiscard, "%s: SgBuildNullApRep failed", ppkt->Str());
            // SgBuildNullApRep logs the error
            goto complete;
        }
    }
    else
#endif
    if (!SgBuildKerbApRep(ppkt))
    {
        TraceSz(RecvDiscard, "%s: SgBuildKerbApRep failed", ppkt->Str());
        // SgBuildKerbApRep logs the error
        goto complete;
    }

    // Generate the key-exchange response packet

    CEnetHdr *  pEnetHdr = ppkt->_pEnetHdr;
    CIpHdr *    pIpHdr   = ppkt->_pIpHdr;
    CXspHdr *   pXspHdr  = ppkt->_pXspHdr;

    pEnetHdr->_eaDst   = pSpiInfo->_eaI;
    pEnetHdr->_eaSrc   = pTransInfoRecv->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS(sizeof(CIpHdr) + sizeof(CXspHdr) + pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt + pKeyExCtx->_KeyExSgToXbChal._cbEnt + pKeyExCtx->_KerbApRep._cbEnt);
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc    = pTransInfoRecv->_ipa;
    pIpHdr->_ipaDst    = pSpiInfo->_ipaI;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pXspHdr->_ipportDst     = pSpiInfo->_ipportI;
    pXspHdr->_ipportSrc     = XSP_PORT;
    pXspHdr->_dwSpiAndFlags = 0;

    SgSetUdpHdrChecksum(pIpHdr, pXspHdr, sizeof(CXspHdr),
                        (BYTE *)pKeyExResp, pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt,
                        (BYTE *)&pKeyExCtx->_KeyExSgToXbChal, pKeyExCtx->_KeyExSgToXbChal._cbEnt,
                        (BYTE *)&pKeyExCtx->_KerbApRep, pKeyExCtx->_KerbApRep._cbEnt,
                        NULL, 0);

    // Trace out the KeyEx contents if requested

    if (Tag(XmitKeyEx))
    {
        TraceSz(XmitKeyEx, "%s: [KeyEx SbToXgResp Xmit]", ppkt->Str());
        TraceSz(XmitKeyEx, "%s:  [_wVersion    = %04X]", ppkt->Str(), pKeyExResp->_wVersion);
        TraceSz(XmitKeyEx, "%s:  [_wFlags      = %04X]", ppkt->Str(), pKeyExResp->_wFlags);
        TraceSz(XmitKeyEx, "%s:  [_dwSpiInit   = %08X]", ppkt->Str(), pKeyExResp->_dwSpiInit);
        TraceSz(XmitKeyEx, "%s:  [_dwSpiResp   = %08X]", ppkt->Str(), pKeyExResp->_dwSpiResp);
        TraceSz(XmitKeyEx, "%s:  [_abNonceInit = %s]", ppkt->Str(), SgHexStr(pKeyExResp->_abNonceInit, sizeof(pKeyExResp->_abNonceInit)));
        TraceSz(XmitKeyEx, "%s:  [_abNonceResp = %s]", ppkt->Str(), SgHexStr(pKeyExResp->_abNonceResp, sizeof(pKeyExResp->_abNonceResp)));
        TraceSz(XmitKeyEx, "%s:  [_abDhGY      = %s]", ppkt->Str(), SgHexStr(pKeyExCtx->_abDhGY, sizeof(pKeyExCtx->_abDhGY)));
        TraceSz(XmitKeyEx, "%s:  [_cbChal      = %d]", ppkt->Str(), pKeyExCtx->_KeyExSgToXbChal._cbEnt);
        TraceSz(XmitKeyEx, "%s:  [_wTypeApRep  = %d (%s)]", ppkt->Str(), pKeyExCtx->_KerbApRep._wType, pKeyExCtx->_KerbApRep._wType == KEYEX_TYPE_NULL_APREP ? "NULL" : pKeyExCtx->_KerbApRep._wType == KEYEX_TYPE_KERB_APREP ? "KERB" : "?");
        TraceSz(XmitKeyEx, "%s:  [_cbApRep     = %d]", ppkt->Str(), pKeyExCtx->_KerbApRep._cbEnt - sizeof(CKeyExHdr));
    }

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr);
    *ppb++ = (BYTE *)pIpHdr;
    *pcb++ = sizeof(CIpHdr);
    *ppb++ = (BYTE *)pXspHdr;
    *pcb++ = sizeof(CXspHdr);
    *ppb++ = (BYTE *)pKeyExResp;
    *pcb++ = pKeyExResp->_cbEnt + pKeyExCtx->_KeyExDhGY._cbEnt;
    *ppb++ = (BYTE *)&pKeyExCtx->_KerbApRep;
    *pcb++ = pKeyExCtx->_KerbApRep._cbEnt;

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    pSpiInfo->_qwTickKeyEx1 = SgTimerTick();

    // The per-cipher perf counters are keyed off the _qwTickKeyEx1 field. This is because
    // we are responsible for both incrementing and decrementing them, and these need to
    // sum to zero.
    switch (pSpiInfo->_cbKeyCrypt)
    {
    case XC_SERVICE_DES_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherDes);
        break;
    case XC_SERVICE_DES3_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherDes3);
        break;
    case XC_SERVICE_AES_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherAes);
        break;
    case XC_SERVICE_NULL_KEYSIZE:
        SgPerfdataInterlockedInc(ConnectionsCipherNull);
        break;
    }

    //
    // This is the case where there is no challenge selected for the
    // client. In this situation, we don't want to block waiting for
    // C/R packet since we will never get one
    //

    pSpiInfo->_qwTickKeyEx2 = SgTimerTick();

#ifdef SG_FEATURE_LUA
    //
    // Determine if anytime challenges need to be enabled
    //

    SgChalCodeUpdateSpiInfo(pSpiInfo);
#endif

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitKeyExResp)
    {
        SgSpiInfoFree(pSpiInfo, SPIDEL_INHIBIT);
    }
#endif

    SgPerfdataInc(KeyEx, 1);
    SgSpiInfoDetach(ppkt);
    SgCliInfoDetach(ppkt);

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitKeyExResp || g_fInhibitKeyExXmit)
        goto complete;
#endif

    ppkt->_pTransInfoXmit = pTransInfoRecv;
    SgXmit(ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}

#endif // SG_FEATURE_LSP

// ---------------------------------------------------------------------------------------
// SgKeyExVerify / SgKeyExLookup
// ---------------------------------------------------------------------------------------

BOOL SgKeyExVerify(CKeyExHdr * pKeyExHdr, UINT cb)
{
    while (cb > 0)
    {
        if (cb < sizeof(CKeyExHdr) || pKeyExHdr->_cbEnt < sizeof(CKeyExHdr) || cb < pKeyExHdr->_cbEnt)
        {
            return(FALSE);
        }

        cb -= pKeyExHdr->_cbEnt;

        pKeyExHdr = (CKeyExHdr *)((BYTE *)pKeyExHdr + pKeyExHdr->_cbEnt);
    }

    return(TRUE);
}

CKeyExHdr * SgKeyExLookup(CKeyExHdr * pKeyExHdr, UINT cb, WORD wType)
{
    Assert(SgKeyExVerify(pKeyExHdr, cb));

    while (cb > 0)
    {
        if (pKeyExHdr->_wType == wType)
        {
            return(pKeyExHdr);
        }

        cb -= pKeyExHdr->_cbEnt;

        pKeyExHdr = (CKeyExHdr *)((BYTE *)pKeyExHdr + pKeyExHdr->_cbEnt);
    }

    return(NULL);
}

BOOL SgKeyExDhGXIsInvalid(const BYTE * pbDhGX)
{
    BYTE b = *pbDhGX;

    // Don't accept a g^X value of 0 or 1

    if (b <= 1 && memcmp(pbDhGX + 1, &g_abOakleyGroup1Base[1], CBDHG1 - 1) == 0)
    {
        return(TRUE);
    }

    // Don't accept a g^X value greater than or equal to the modulus minus one

    const DWORD * pdwEnd = (DWORD *)&g_abOakleyGroup1Mod[0];
    const DWORD * pdw1   = (DWORD *)&g_abOakleyGroup1Mod[CBDHG1 - sizeof(DWORD)];
    const DWORD * pdw2   = (DWORD *)&pbDhGX[CBDHG1 - sizeof(DWORD)];

    for (; pdw1 > pdwEnd; --pdw1, --pdw2)
    {
        if (*pdw1 != *pdw2)
        {
            // If the corresponding DWORD in the input is greater than in the modulus,
            // the g^X value is greater than the modulus (because all more-significant
            // DWORDs have already been tested equal).  The opposite means the
            // value g^X value is definitely less than the modulus and is thus
            // an acceptable value.

            return(*pdw1 < *pdw2);
        }
    }

    // At this point all DWORDs but the least significant ones are equal to the modulus.

    Assert(pdw1 == (DWORD *)&g_abOakleyGroup1Mod[0]);
    Assert(pdw2 == (DWORD *)pbDhGX);

    Assert(*pdw1 > 0);

    return((*pdw1 - 1) <= *pdw2);
}

void SgKeyExPermute(CAuthData4* pAuthData, DWORD dwPermuteMask)
{
    XUID    axuid[XONLINE_MAX_LOGON_USERS];
    FLOAT   atrust[XONLINE_MAX_LOGON_USERS];
    DWORD   aprivs[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_USER_PRIVILEGES_DWORDS];
    BYTE*   pb = (BYTE*) &dwPermuteMask;
    UINT    i;
    UINT    j;
    UINT    k;

    memcpy( axuid, pAuthData->users, sizeof( axuid ));
    memset( pAuthData->users, 0, sizeof( axuid ) );

    memcpy( atrust, pAuthData->afltTrustFactor, sizeof( atrust ) );
    memset( pAuthData->afltTrustFactor, 0, sizeof( atrust ) );

    memcpy( aprivs, pAuthData->dwUserPrivileges, sizeof(aprivs) );
    memset( pAuthData->dwUserPrivileges, 0, sizeof( aprivs ) );

    for( i = 0; i < XONLINE_MAX_LOGON_USERS; ++i )
    {
        BYTE b = *pb++;

        if( b & KEYEX_USER_PERMUTE_MASK )
        {
            k = (b >> KEYEX_USER_PERMUTATION_SHIFT);

            pAuthData->users[ i ]               = axuid[ k ];
            pAuthData->users[ i ].dwUserFlags  |= ( b & KEYEX_USER_GUEST_MASK );
            pAuthData->afltTrustFactor[ i ]     = atrust[ k ];
            for (j = 0; j < XONLINE_NUM_USER_PRIVILEGES_DWORDS; j++)
            {
                pAuthData->dwUserPrivileges[ i ][ j ] = aprivs[ k ][ j ];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgiocfgparse.cpp ===
// ---------------------------------------------------------------------------------------
// sgiocfgparse.cpp
//
// Proxy API for SG transport
// Configuration Layer
// ---------------------------------------------------------------------------------------

#include "sg.h"


// ---------------------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------------------

struct CCfgLex
{
    // Definitions -----------------------------------------------------------------------

    #define CFGTOK_EOS              0           // End-of-string reached
    #define CFGTOK_UNCLOSED_STRING  1           // Quoted string without closing quote
    #define CFGTOK_UNCLOSED_BRACES  2           // Braced string without closing brace
    #define CFGTOK_UNOPENED_BRACE   3           // Stray close-brace without opening brace
    #define CFGTOK_STRING           4           // Regular unquoted string
    #define CFGTOK_QUOTED_STRING    5           // Quoted string "..."
    #define CFGTOK_BRACED_STRING    6           // Braced string {...}

    // Functions -------------------------------------------------------------------------

    void            Init(CCfgStr * pcs);
    UINT            NextToken(CCfgStr * pcs);

    // Data ------------------------------------------------------------------------------

    const char *    _pch;                       // Current buffer pointer
    UINT            _cch;                       // Remaining characters in buffer
    UINT            _iLine;                     // Current line number
};

// ---------------------------------------------------------------------------------------
// CCfgStr
// ---------------------------------------------------------------------------------------

BOOL CCfgStr::GetNum( WORD* pwNum )
{
    ULONGLONG qw;
    if( !GetNum( &qw ) )
    {
        return FALSE;
    }

    if( USHRT_MAX < qw )
    {
        return FALSE;
    }

    *pwNum = (WORD) qw;

    return TRUE;
}

BOOL CCfgStr::GetNum( DWORD* pdwNum )
{
    ULONGLONG qw;
    if( !GetNum( &qw ) )
    {
        return FALSE;
    }

    if( UINT_MAX < qw )
    {
        return FALSE;
    }

    *pdwNum = (DWORD) qw;

    return TRUE;
}

BOOL CCfgStr::GetNum( ULONGLONG* pqwNum )
{
    const char *        pch    = _pch;
    const char *        pchEnd = pch + _cch;
    ULONGLONG           qwNum  = 0;
    BOOL                fNegative = FALSE;

    // We support negative 64-bit numbers. If they are "too negative", then we return an 
    // error. If we're actually parsing a 32 or 16-bit number, then this won't work 
    // correctly -- a negative number of one of those will return an error, since the 
    // above checks for "too big for the # of bits" will fire.  

    if (_cch > 2 && pch[0] == '0' && (pch[1] == 'x' || pch[1] == 'X'))
    {
        if (_cch > 18)
        {
            return(FALSE);
        }

        for (pch += 2; pch < pchEnd; ++pch)
        {
            if (*pch >= '0' && *pch <= '9')
                qwNum = (qwNum << 4) | (*pch - '0');
            else if (*pch >= 'A' && *pch <= 'F')
                qwNum = (qwNum << 4) | (*pch - 'A' + 10);
            else if (*pch >= 'a' && *pch <= 'f')
                qwNum = (qwNum << 4) | (*pch - 'a' + 10);
            else
            {
                return(FALSE);
            }
        }
    }
    else if (_cch > 0)
    {
        if (*pch == '-')
        {
            fNegative = TRUE;
            ++pch;
        }
        for (; pch < pchEnd; ++pch)
        {
            if (*pch >= '0' && *pch <= '9')
                qwNum = (qwNum * 10) + (*pch - '0');
            else
            {
                return(FALSE);
            }
        }
    }
    else
    {
        return(FALSE);
    }

    if (fNegative)
    {
        // too negative?
        if (qwNum & 0x8000000000000000)
        {
            return(FALSE);
        }
        // Perform twos-complement. Invert all bits, add 1.
        qwNum ^= 0xFFFFFFFFFFFFFFFF;
        qwNum++;
    }

    *pqwNum = qwNum;
    return(TRUE);
}

BOOL CCfgStr::GetHex( BYTE* pb, DWORD cb )
{
    if ((_cch % 1) == 1 || _cch != cb * 2)
    {
        return(FALSE);
    }

    const char * pch = _pch;

    for (; cb > 0; --cb, ++pb, ++pch)
    {
        *pb = 0;

        if (*pch >= '0' && *pch <= '9')
            *pb |= (*pch - '0');
        else if (*pch >= 'A' && *pch <= 'F')
            *pb |= (*pch - 'A' + 10);
        else if (*pch >= 'a' && *pch <= 'f')
            *pb |= (*pch - 'a' + 10);
        else
            return(FALSE);

        (*pb) <<= 4;
        pch += 1;

        if (*pch >= '0' && *pch <= '9')
            *pb |= (*pch - '0');
        else if (*pch >= 'A' && *pch <= 'F')
            *pb |= (*pch - 'A' + 10);
        else if (*pch >= 'a' && *pch <= 'f')
            *pb |= (*pch - 'a' + 10);
        else
            return(FALSE);
    }

    return(TRUE);
}

BOOL CCfgStr::GetIpAddr( CIpAddr* pIp )
{
    char ach[32];

    if (_cch >= sizeof(ach))
    {
        return(FALSE);
    }

    memcpy(ach, _pch, _cch);
    ach[_cch] = 0;

    ULONG fields[4], addr;
    UINT fieldcnt = 0;
    const UCHAR* p = (const UCHAR*) ach;

    while (TRUE) {
        // skip leading spaces
        while (*p == ' ') p++;
        if (fieldcnt >= 4 || *p == 0) break;
    
        addr = 0;
        if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
            // hex number
            const UCHAR* q = (p += 2);

            while (TRUE) {
                if (*p >= '0' && *p <= '9')
                    addr = (addr << 4) + (*p - '0');
                else if (*p >= 'a' && *p <= 'f')
                    addr = (addr << 4) + 10 + (*p - 'a');
                else if (*p >= 'A' && *p <= 'F')
                    addr = (addr << 4) + 10 + (*p - 'A');
                else
                    break;
                p++;
            }

            if (q == p) return FALSE;

        } else if (*p == '0') {
            // octal number
            do {
                addr = (addr << 3) + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '7');
        } else if (*p >= '1' && *p <= '9') {
            // decimal number
            do {
                addr = addr*10 + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '9');
        } else {
            // invalid character
            break;
        }

        // skip trailing spaces and . separator
        while (*p == ' ') p++;
        if (*p == '.') p++;

        fields[fieldcnt++] = addr;
    }

    if (*p) return FALSE;

    switch (fieldcnt) {
    case 1:
        addr = fields[0];
        break;
    case 2:
        addr = ((fields[0] & 0xff) << 24) |
               (fields[1] & 0xffffff);
        break;
    case 3:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               (fields[2] & 0xffff);
        break;
    case 4:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               ((fields[2] & 0xff) <<  8) |
               (fields[3] & 0xff);
        break;

    default:
        addr = 0;
        break;
    }

    *pIp = HTONL(addr);
    
    return(TRUE);
}

BOOL CCfgStr::StrEql( const char* pch )
{
    return(strlen(pch) == _cch && _strnicmp(pch, _pch, _cch) == 0);
}

const char* CCfgStr::Str() const
{
    STATIC_BUFFER(CCfgStr, 8, 64);
    cch -= 1;
    if (cch > _cch)
        cch = _cch;
    memcpy(pch, _pch, cch);
    pch[cch] = 0;
    return(pch);
}

// ---------------------------------------------------------------------------------------
// CCfgLex
// ---------------------------------------------------------------------------------------

void CCfgLex::Init(CCfgStr * pcs)
{
    _pch   = pcs->_pch;
    _cch   = pcs->_cch;
    _iLine = pcs->_iLine;
}

UINT CCfgLex::NextToken(CCfgStr * pcs)
{
    while (_cch > 0)
    {
        // Skip whitespace characters before the token

        for (; _cch > 0; ++_pch, --_cch)
        {
            if (*_pch != ' ' && *_pch != '\t' && *_pch != '\r')
                break;
        }

        if (_cch == 0)
            break;

        if (*_pch == ';')
        {
            // Skip all characters to the end of the current line

            for (++_pch, --_cch; _cch > 0; ++_pch, --_cch)
            {
                if  (*_pch == '\n')
                    break;
            }
        }

        if (_cch == 0)
            break;

        // Handle the end-of-line character and advance to the next line

        if (*_pch == '\n')
        {
            _iLine += 1;
            _pch   += 1;
            _cch   -= 1;
        }
        else
        {
            // Anything else means we've found the beginning of a token
            break;
        }
    }

    // Remember the current position as the beginning of the token

    pcs->_pch   = _pch;
    pcs->_cch   = _cch;
    pcs->_iLine = _iLine;

    if (_cch == 0)
    {
        return(CFGTOK_EOS);
    }

    if (*_pch == '"')
    {
        // Advance to the next double-quote, but not further than the end of line

        for (++_pch, --_cch; _cch > 0; ++_pch, --_cch)
        {
            if (*_pch == '"' || *_pch == '\n')
                break;
        }

        if (_cch  == 0 || *_pch == '\n')
        {
            return(CFGTOK_UNCLOSED_STRING);
        }

        pcs->_cch = (DWORD)(_pch - pcs->_pch - 1);
        pcs->_pch = pcs->_pch + 1;
        _pch += 1;
        _cch -= 1;

        return(CFGTOK_QUOTED_STRING);
    }

    if (*_pch == '}')
    {
        // Stray unclosed brace is an error

        return(CFGTOK_UNOPENED_BRACE);
    }

    if (*_pch == '{')
    {
        // Advance to the matching close-brace.  If there are quoted strings in between, we
        // don't worry if they are unterminated, as that will be handled when the contents
        // of this token are parsed.

        UINT cBrace = 1;

        for (++_pch, --_cch; _cch > 0; ++_pch, --_cch)
        {
            if (*_pch == '}')
            {
                if (--cBrace == 0)
                    break;
            }
            else if (*_pch == '"')
            {
                for (++_pch, --_cch; _cch > 0; ++_pch, --_cch)
                {
                    if (*_pch == '"' || *_pch == '\n')
                    {
                        _iLine += (*_pch == '\n');
                        break;
                    }
                }

                if (_cch == 0)
                    break;
            }
            else if (*_pch == '{')
            {
                cBrace += 1;
            }
            else if (*_pch == '\n')
            {
                _iLine += 1;
            }
        }

        if (cBrace > 0)
        {
            Assert(_cch == 0);
            return(CFGTOK_UNCLOSED_BRACES);
        }

        Assert(_cch > 0);

        pcs->_cch = (DWORD)(_pch - pcs->_pch - 1);
        pcs->_pch = pcs->_pch + 1;
        _pch += 1;
        _cch -= 1;

        return(CFGTOK_BRACED_STRING);
    }

    // For anything else, we scan the unquoted string until we come to whitespace,
    // and open or close brace, a double-quote, the end of line, or the end of the string.

    for (++_pch, --_cch; _cch > 0; ++_pch, --_cch)
    {
        if (    *_pch == ' ' || *_pch == '\t' || *_pch == '\r'
            ||  *_pch == '{' || *_pch == '}'
            ||  *_pch == '\n')
            break;
    }

    pcs->_cch = (DWORD)(_pch - pcs->_pch);

    return(CFGTOK_STRING);
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::Parse
// ---------------------------------------------------------------------------------------

DWORD CCfgInfo::Parse( const char* pch, DWORD* piLineErr )
{
    memset(this, 0, sizeof(*this));
    _dwFlags        = CFGF_LIST;
    _csValue._pch   = pch;
    _csValue._cch   = NULL == pch ? 0 : strlen(pch);
    _csValue._iLine = 1;
    return(Parse(piLineErr));
}

DWORD CCfgInfo::Parse( DWORD* piLineErr )
{
    CCfgLex     CfgLex;
    UINT        iStatus;
    CCfgInfo *  pci;
    CCfgInfo *  pciTodoHead = this;
    CCfgInfo *  pciTodoTail = this;

    _pciTodoNext = NULL;

    while (1)
    {

    nextpci:

        pci = pciTodoHead;

        if (pci == NULL)
            break;

        pciTodoHead = pci->_pciTodoNext;

        if (pciTodoHead == NULL)
            pciTodoTail = NULL;

        Assert(pci->IsList());

        CfgLex.Init(&pci->_csValue);

        while (1)
        {
            CCfgStr csName, csValue;

            iStatus = CfgLex.NextToken(&csName);

            switch (iStatus)
            {
                case CFGTOK_EOS:
                    goto nextpci;

                case CFGTOK_UNCLOSED_STRING:
                case CFGTOK_UNCLOSED_BRACES:
                case CFGTOK_UNOPENED_BRACE:
                    *piLineErr = csName._iLine;
                    return(iStatus);

                case CFGTOK_QUOTED_STRING:
                case CFGTOK_BRACED_STRING:
                    *piLineErr = csName._iLine;
                    return(CFGERR_INVALID_NAME);
            }

            Assert(iStatus == CFGTOK_STRING);

            iStatus = CfgLex.NextToken(&csValue);

            switch (iStatus)
            {
                case CFGTOK_EOS:
                    *piLineErr = csValue._iLine;
                    return(CFGERR_MISSING_VALUE);

                case CFGTOK_UNCLOSED_STRING:
                case CFGTOK_UNCLOSED_BRACES:
                case CFGTOK_UNOPENED_BRACE:
                    *piLineErr = csValue._iLine;
                    return(iStatus);
            }

            Assert(iStatus == CFGTOK_QUOTED_STRING || iStatus == CFGTOK_BRACED_STRING || iStatus == CFGTOK_STRING);

            CCfgInfo * pciNew = new CCfgInfo();

            if (pciNew == NULL)
            {
                *piLineErr = csValue._iLine;
                return(CFGERR_OUT_OF_MEMORY);
            }

            memset( pciNew, 0, sizeof( *pciNew ) );

            pciNew->_dwFlags = (iStatus == CFGTOK_BRACED_STRING) ? CFGF_ALLOC|CFGF_LIST : CFGF_ALLOC;
            pciNew->_csName  = csName;
            pciNew->_csValue = csValue;
            pciNew->_pciNext = NULL;
            
            if (pci->_pciTail != NULL)
            {
                pci->_pciTail->_pciNext = pciNew;
                pci->_pciTail = pciNew;
            }
            else
            {
                pci->_pciHead = pci->_pciTail = pciNew;
            }

            if (iStatus == CFGTOK_BRACED_STRING)
            {
                pciNew->_pciTodoNext = NULL;

                if (pciTodoTail != NULL)
                {
                    pciTodoTail->_pciTodoNext = pciNew;
                    pciTodoTail = pciNew;
                }
                else
                {
                    pciTodoHead = pciTodoTail = pciNew;
                }
            }
        }
    }

    *piLineErr = 0;
    return(CFGERR_SUCCESS);
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::Free
// ---------------------------------------------------------------------------------------

void CCfgInfo::Free()
{
    CCfgInfo *  pci;
    CCfgInfo *  pciTodoHead = this;
    CCfgInfo *  pciTodoTail = this;

    _pciTodoNext = NULL;

    while (pciTodoHead != NULL)
    {
        pci         = pciTodoHead;
        pciTodoHead = pci->_pciTodoNext;

        if (pciTodoHead == NULL)
            pciTodoTail = NULL;

        while (pci->_pciHead != NULL)
        {
            CCfgInfo * pciSub = pci->_pciHead;
            pci->_pciHead = pciSub->_pciNext;

            if (pci->_pciHead == NULL)
                pci->_pciTail = NULL;
            
            pciSub->_pciTodoNext = NULL;

            if (pciTodoTail != NULL)
            {
                pciTodoTail->_pciTodoNext = pciSub;
                pciTodoTail = pciSub;
            }
            else
            {
                pciTodoHead = pciTodoTail = pciSub;
            }
        }

        if (pci->_dwFlags & CFGF_ALLOC)
        {
            delete pci;
        }
    }
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::Find
// ---------------------------------------------------------------------------------------

CCfgInfo* CCfgInfo::Find( const char* pchName, CCfgInfo* pciAfter, BOOL fMustExist )
{
    Assert(IsList());

    CCfgInfo * pciStart = (pciAfter != NULL) ? pciAfter->_pciNext : _pciHead;

    for (CCfgInfo * pci = pciStart; pci != NULL; pci = pci->_pciNext)
    {
        if (pci->_csName.StrEql(pchName))
            return(pci);
    }

    if (fMustExist)
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::Find() - SG config error (line %d): '%hs' expects '%hs' in its list of values",
                 _csValue._iLine, _csName.Str(), pchName );
    }

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::FindList
// ---------------------------------------------------------------------------------------

CCfgInfo* CCfgInfo::FindList( const char* pchName, CCfgInfo* pciAfter, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "FindList|%s|%s|%d", _csName.Str(), pchName, (fMustExist ? 1 : 0));

    CCfgInfo* pci = Find( pchName, pciAfter, fMustExist );

    if( NULL != pci && 
        !pci->IsList() )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::FindList() - SG config error (line %d): '%hs' must specify a list of values",
                 pci->_csName._iLine, pchName );
        pci = NULL;
    }

    return pci;
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::FindNonList
// ---------------------------------------------------------------------------------------

CCfgInfo* CCfgInfo::FindNonList( const char* pchName, CCfgInfo* pciAfter, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "FindNonList|%s|%s|%d", _csName.Str(), pchName, (fMustExist ? 1 : 0));

    CCfgInfo* pci = Find( pchName, pciAfter, fMustExist );

    if( NULL != pci && 
        pci->IsList() )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::FindNonList() - SG config error (line %d): '%hs' must not specify a list of values",
                 pci->_csName._iLine, pchName );
        pci = NULL;
    }

    return pci;
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::Count
// ---------------------------------------------------------------------------------------

DWORD CCfgInfo::Count( const char* pchName )
{
    CCfgInfo *  pci = NULL;
    UINT        cci = 0;

    TraceSz(CConfigInfoDbg, "Count|%s|%s", _csName.Str(), pchName);

    while( 1 )
    {
        pci = Find( pchName, pci, FALSE );
        if( NULL == pci )
        {
            break;
        }

        cci++;
    }

    return cci;
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::GetNum
// ---------------------------------------------------------------------------------------

BOOL CCfgInfo::GetNum( const char* pchName, WORD* pwNum, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "GetNum(WORD)|%s|%s|%d|", _csName.Str(), pchName, (fMustExist ? 1 : 0));

    CCfgInfo* pciNum = FindNonList( pchName, NULL, fMustExist );
    if( NULL == pciNum )
    {
        return !fMustExist;
    }

    if( NULL != Find( pchName, pciNum, FALSE ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetNum() - SG config error (line %d): '%hs' must only occur once in the list",
                   pciNum->_csName._iLine, pchName );
        return FALSE;
    }

    if( !pciNum->_csValue.GetNum( pwNum ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetNum() - SG config error (line %d): '%hs' must have a value which is a number",
                 _csValue._iLine, _csName.Str() );
        return FALSE;
    }

    return TRUE;
}

BOOL CCfgInfo::GetNum( const char* pchName, UINT* pNum, BOOL fMustExist )
{
    // Unfortunatelly the use of UINT and DWORD is not very consistent accross the SG 
    // code. Until we fix that, this is a workaround to make things look less ugly.

    return GetNum(pchName, (DWORD*) pNum, fMustExist);
}

BOOL CCfgInfo::GetNum( const char* pchName, DWORD* pdwNum, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "GetNum(DWORD)|%s|%s|%d|", _csName.Str(), pchName, (fMustExist ? 1 : 0));

    CCfgInfo* pciNum = FindNonList( pchName, NULL, fMustExist );
    if( NULL == pciNum )
    {
        return !fMustExist;
    }

    if( NULL != Find( pchName, pciNum, FALSE ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetNum() - SG config error (line %d): '%hs' must only occur once in the list",
                   pciNum->_csName._iLine, pchName );
        return FALSE;
    }

    if( !pciNum->_csValue.GetNum( pdwNum ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetNum() - SG config error (line %d): '%hs' must have a value which is a number",
                 _csValue._iLine, _csName.Str() );
        return FALSE;
    }

    return TRUE;
}

BOOL CCfgInfo::GetNum( const char* pchName, ULONGLONG* pqwNum, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "GetNum(ULONGLONG)|%s|%s|%d|", _csName.Str(), pchName, (fMustExist ? 1 : 0));

    CCfgInfo * pciNum = FindNonList( pchName, NULL, fMustExist );
    if( NULL == pciNum )
    {
        return !fMustExist;
    }

    if( NULL != Find( pchName, pciNum, FALSE ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetNum() - SG config error (line %d): '%hs' must only occur once in the list",
                   pciNum->_csName._iLine, pchName );
        return FALSE;
    }

    if( !pciNum->_csValue.GetNum( pqwNum ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetNum() - SG config error (line %d): '%hs' must have a value which is a number",
                 _csValue._iLine, _csName.Str() );
        return FALSE;
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::GetHex
// ---------------------------------------------------------------------------------------

BOOL CCfgInfo::GetHex( const char* pchName, BYTE* pb, DWORD* pcb, DWORD cbMax, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "GetHex|%s|%s|cbMax=%d|%d|", _csName.Str(), pchName, cbMax, (fMustExist ? 1 : 0));

    CCfgInfo* pci = FindNonList( pchName, NULL, fMustExist );
    if( NULL == pci )
    {
        return !fMustExist;
    }

    if( NULL != Find( pchName, pci, FALSE ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetHex() - SG config error (line %d): '%s' must only occur once in the list",
                     pci->_csName._iLine, pchName );
        return FALSE;
    }

    if( pci->_csValue._cch / 2 > cbMax )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetHex() - SG config error (line %d): Hex value '%s' too large. max = %d < %d",
                 pci->_csName._iLine, pchName, cbMax, pci->_csValue._cch / 2 );
        return FALSE;
    }

    *pcb = pci->_csValue._cch / 2;

    if( !pci->_csValue.GetHex( pb, *pcb ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetHex() - SG config error (line %d): '%hs' must have a value which is a %u byte hex number",
                 _csValue._iLine, pchName, *pcb );
        return FALSE;
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::GetIpAddr
// ---------------------------------------------------------------------------------------

BOOL CCfgInfo::GetIpAddr( const char* pchName, CIpAddr* pIp, BOOL fMustExist, BOOL fZeroOk )
{
    TraceSz(CConfigInfoDbg, "GetIpAddr|%s|%s|fZeroOk=%d|%d|", _csName.Str(), pchName, (fZeroOk ? 1 : 0), (fMustExist ? 1 : 0));

    CCfgInfo* pci = FindNonList(pchName, NULL, fMustExist );
    if( NULL == pci )
    {
        return !fMustExist;
    }

    if( NULL != Find( pchName, pci, FALSE ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetIpAddr() - SG config error (line %d): '%s' must only occur once in the list",
                     pci->_csName._iLine, pchName);
        return FALSE;
    }

    if( !pci->_csValue.GetIpAddr( pIp ) ||
        !fZeroOk && 0 == *pIp )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetIpAddr() - SG config error (line %d): '%s' is not a valid IP address",
                     pci->_csName._iLine, pchName );
        return FALSE;
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::GetIpPort
// ---------------------------------------------------------------------------------------

BOOL CCfgInfo::GetIpPort(char * pchName, CIpPort * pipport, BOOL fMustExist)
{
    TraceSz(CConfigInfoDbg, "GetHex|%s|%s|%d|", _csName.Str(), pchName, (fMustExist ? 1 : 0));

    CCfgInfo * pci = FindNonList(pchName, NULL, fMustExist);

    if (pci == NULL)
    {
        return(FALSE);
    }

    if (Find(pchName, pci, FALSE) != NULL)
    {
        SgEventSz(CONFIG_ERROR, "CCfgInfo::GetIpPort() - SG config error (line %d): '%s' must only occur once in the list",
                   pci->_csName._iLine, pchName);
        return(FALSE);
    }

    WORD iNum;

    if (!pci->_csValue.GetNum(&iNum) || iNum == 0 || iNum >= 0xFFFF)
    {
        SgEventSz(CONFIG_ERROR, "CCfgInfo::GetIpPort() - SG config error (line %d): '%s' %d is not a valid IP port",
                   pci->_csName._iLine, pchName, iNum);
        return(FALSE);
    }

    *pipport = HTONS((USHORT) iNum);

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// CCfgInfo::GetString
// ---------------------------------------------------------------------------------------

BOOL CCfgInfo::GetString( const char* pchName, char* pch, DWORD cchMax, BOOL fMustExist )
{
    TraceSz(CConfigInfoDbg, "GetString|%s|%s|cchMax=%d|%d|", _csName.Str(), pchName, cchMax, (fMustExist ? 1 : 0));

    CCfgInfo* pci = FindNonList( pchName, NULL, fMustExist );
    if( NULL == pci )
    {
        return !fMustExist;
    }

    if( NULL != Find( pchName, pci, FALSE ) )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetString() - SG config error (line %d): '%s' must only occur once in the list",
                     pci->_csName._iLine, pchName);
        return FALSE;
    }

    if( pci->_csValue._cch > cchMax )
    {
        SgEventSz( CONFIG_ERROR, "CCfgInfo::GetString() - SG config error (line %d): String value '%s' too large. max = %d < %d",
                 pci->_csName._iLine, pchName, cchMax, pci->_csValue._cch );
        return FALSE;
    }

    // The tokens are not null terminated, so copy by size
    strncpy( pch, pci->_csValue._pch, pci->_csValue._cch );
    pch[ pci->_csValue._cch ] = '\0';

    return TRUE;
}


// ---------------------------------------------------------------------------------------
// CCfgInfo::GetVar
// ---------------------------------------------------------------------------------------

BOOL CCfgInfo::GetVar( const char* pchName, WORD* piVar, WORD iMin, WORD iMax, WORD iDef )
{
    DWORD iVar = *piVar;

    if( !GetVar( pchName, &iVar, iMin, iMax, iDef ) )
    {
        return FALSE;
    }

    *piVar = (WORD) iVar;

    return TRUE;
}

BOOL CCfgInfo::GetVar( const char* pchName, UINT* piVar, UINT iMin, UINT iMax, UINT iDef )
{
    // Unfortunatelly the use of UINT and DWORD is not very consistent accross the SG 
    // code. Until we fix that, this is a workaround to make things look less ugly.
    
    return GetVar(pchName, (DWORD*) piVar, (DWORD)iMin, (DWORD)iMax, (DWORD)iDef);
}

BOOL CCfgInfo::GetVar( const char* pchName, DWORD* piVar, DWORD iMin, DWORD iMax, DWORD iDef )
{
    Assert(IsList());

    // Start with the default
    DWORD iVar = iDef;

    TraceSz(CConfigInfoDbg, "GetVar|%s|%s|iMin=%d|iMax=%d|iDef=%d|", _csName.Str(), pchName, iMin, iMax, iDef);

    CCfgInfo* pciNum = FindNonList( pchName, NULL, FALSE );
    if( NULL == pciNum )
    {
        // Not found, return the default
        goto Exit;
    }

    if( NULL != Find( pchName, pciNum, FALSE ) )
    {
        SgEventSz( CONFIG_WARNING, "CCfgInfo::GetVar() - SG config error (line %d): '%hs' must only occur once in the list. {{ min [%u] max [%u] default [%u] }}",
                   pciNum->_csName._iLine, pchName, iMin, iMax, iDef );
        return FALSE;
    }

    if( !pciNum->_csValue.GetNum( &iVar ) )
    {
        SgEventSz( CONFIG_WARNING, "CCfgInfo::GetVar() - SG config error (line %d): '%hs' must have a value which is a number. '%hs' is invalid. {{ min [%u] max [%u] default [%u] }}",
                 pciNum->_csValue._iLine, pciNum->_csName.Str(), pciNum->_csValue.Str(), iMin, iMax, iDef );
        return FALSE;
    }

    if( iVar < iMin )
    {
        SgEventSz( CONFIG_WARNING, "CCfgInfo::GetVar() - SG config error (line %d): '%hs' (%u) must be greater than or equal to %u. {{ min [%u] max [%u] default [%u] }}",
                 pciNum->_csValue._iLine, pciNum->_csName.Str(), iVar, iMin, iMin, iMax, iDef );
        return FALSE;
    }

    if( iVar > iMax )
    {
        SgEventSz( CONFIG_WARNING, "CCfgInfo::GetVar() - SG config error (line %d): '%hs' (%u) must be less than or equal to %u. {{ min [%u] max [%u] default [%u] }}",
                 pciNum->_csValue._iLine, pciNum->_csName.Str(), iVar, iMax, iMin, iMax, iDef );
        return FALSE;
    }

Exit:
    *piVar = iVar;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgkrb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s * PKERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_COMPOUND_IDENTITY_s * PKERB_PA_COMPOUND_IDENTITY;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1int32_t KERB_PA_PAC_REQUEST_EX_pac_sections_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s {
    PKERB_PA_PAC_REQUEST_EX_pac_sections next;
    KERB_PA_PAC_REQUEST_EX_pac_sections_Seq value;
} KERB_PA_PAC_REQUEST_EX_pac_sections_Element, *KERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;
#define KERB_TYPED_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_TYPED_DATA)

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(KERB_EXT_ERROR)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_PA_PAC_REQUEST_EX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t include_pac;
#   define pac_sections_present 0x80
    PKERB_PA_PAC_REQUEST_EX_pac_sections pac_sections;
} KERB_PA_PAC_REQUEST_EX;
#define KERB_PA_PAC_REQUEST_EX_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_PA_PAC_REQUEST_EX)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    //KERB_SEQUENCE_NUMBER_LARGE sequence_number;
    KERB_SEQUENCE_NUMBER sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_COMPOUND_IDENTITY_s {
    PKERB_PA_COMPOUND_IDENTITY next;
    KERB_TICKET value;
} KERB_PA_COMPOUND_IDENTITY_Element, *KERB_PA_COMPOUND_IDENTITY;
#define KERB_PA_COMPOUND_IDENTITY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_PA_COMPOUND_IDENTITY_Element)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 49
#define SIZE_KRB5_Module_PDU_49 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 50
#define SIZE_KRB5_Module_PDU_50 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgkrb5.cpp ===
#include "sg.h"
#include "sgasn1.h"
#include "sgkrb5.h"

int
MyStrlenA(
    LPCSTR lpString
    )
{
    if (!lpString)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return strlen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return strlen(lpString);
#endif
}


ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[51] = {
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TYPED_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PAC_REQUEST_EX,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TICKET,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AUTHENTICATOR,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AP_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CRED,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_COMPOUND_IDENTITY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AS_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGS_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[51] = {
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TYPED_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PAC_REQUEST_EX,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_COMPOUND_IDENTITY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[51] = {
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
};
static const ULONG sizetab[51] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
    SIZE_KRB5_Module_PDU_49,
    SIZE_KRB5_Module_PDU_50,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(void)
{
    KRB5_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 51, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
    ASN1_CloseModule(KRB5_Module);
    KRB5_Module = NULL;
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PAC_REQUEST_EX_pac_sections f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PAC_REQUEST_EX_pac_sections)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	t = MyStrlenA(f->value);
	if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1ztcharstring_free(f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	t = MyStrlenA((val)->client_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = MyStrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1ztcharstring_free((val)->client_realm);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x8) {
	    ASN1charstring_free(&(val)->error_text);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1octetstring_free(&(val)->error_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->salt);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = MyStrlenA((val)->server_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->server_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
	ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.dh_signed_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.key_package);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000001:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->subject_public_key);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->kdc_cert);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->encryption_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = MyStrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = MyStrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
	ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
	ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_KERB_SIGNATURE(&(val)->checksum);
	ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = MyStrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
	}
	ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = MyStrlenA((val)->target_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->new_password);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->target_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->data_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = MyStrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = MyStrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
	ASN1ztcharstring_free((val)->userRealm);
	ASN1Free_KERB_CHECKSUM(&(val)->cksum);
	ASN1ztcharstring_free((val)->authentication_package);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(enc, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(dd, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(&(val)->pac_sections);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = MyStrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
#ifdef TODO_LATER
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
#endif
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = MyStrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->flags);
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = MyStrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	//if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	//if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
	/*
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequence_number);
	}
	*/
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = MyStrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x2;
	if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->kdc_options);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    t = MyStrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
	}
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = MyStrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
	ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
	if ((val)->o[0] & 0x80) {
	}
	ASN1bitstring_free(&(val)->flags);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	ASN1ztcharstring_free((val)->server_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->ap_options);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
	ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
	ASN1Free_KERB_CRED_tickets(&(val)->tickets);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = MyStrlenA((val)->principal_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	t = MyStrlenA((val)->service_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x2;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x1;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[1] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[1] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->principal_realm);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
	if ((val)->o[0] & 0x4) {
	}
	if ((val)->o[0] & 0x2) {
	}
	if ((val)->o[0] & 0x1) {
	    ASN1ztcharstring_free((val)->service_realm);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
	ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
	ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
	ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.ca_name);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.issuer_and_serial);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_COMPOUND_IDENTITY)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TRUSTED_CAS(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CRED_INFO(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
	}
	ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
	}
	ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
	ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    RtlZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
	ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglbuffer.cpp ===
// ---------------------------------------------------------------------------------------
// sglbuffer.cpp
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

//
//
// Maximum buffer size
//
#define SG_LUA_BUFFER_MAXIMUM_SIZE   (64 * 1024)

//
// SG LUA Buffer Implementation
//
typedef struct {
    ULONG    _cbBuffer;
    BYTE    *_pbBuffer;
    BOOL     _bReadOnly;
} SgLuaBuffer;

//
// Private Worker Functions
//
SgLuaBuffer *SgLuaBufferToPointer(lua_State *L, int narg );
static int SgLuaBufferGetElement(lua_State *L, ULONG elemSize, BOOL bNetwork);
static int SgLuaBufferLastElement(lua_State *L, ULONG elemSize);
static int SgLuaBufferLogicElement(lua_State *L,ULONG elemSize, BOOL bNetwork, DWORD dwOp);
static int SgLuaBufferSetElement(lua_State *L, ULONG elemSize, BOOL bNetwork);

//
// LUA exported Functions
//

//
// AND functions
//
static int SgLuaBufferAnd(lua_State *L);
static int SgLuaBufferAndWord(lua_State *L);
static int SgLuaBufferAndWordN(lua_State *L);
static int SgLuaBufferAndDWord(lua_State *L);
static int SgLuaBufferAndDWordN(lua_State *L);
static int SgLuaBufferAndQWord(lua_State *L);
static int SgLuaBufferAndQWordN(lua_State *L);

//
// GET functions
//
static int SgLuaBufferGetString(lua_State *L);
static int SgLuaBufferGet(lua_State *L);
static int SgLuaBufferGetWord(lua_State *L);
static int SgLuaBufferGetDWord(lua_State *L);
static int SgLuaBufferGetQWord(lua_State *L);
static int SgLuaBufferGetWordN(lua_State *L);
static int SgLuaBufferGetDWordN(lua_State *L);
static int SgLuaBufferGetQWordN(lua_State *L);

//
// Last functions
//
static int SgLuaBufferLast(lua_State *L);
static int SgLuaBufferLastWord(lua_State *L);
static int SgLuaBufferLastDWord(lua_State *L);
static int SgLuaBufferLastQWord(lua_State *L);

//
// Memory functions
//
static int SgLuaBufferNew(lua_State *L);
static int SgLuaBufferCompare(lua_State *L);
static int SgLuaBufferCopy(lua_State *L);

//
// NOT functions
//
static int SgLuaBufferNot(lua_State *L);
static int SgLuaBufferNotWord(lua_State *L);
static int SgLuaBufferNotWordN(lua_State *L);
static int SgLuaBufferNotDWord(lua_State *L);
static int SgLuaBufferNotDWordN(lua_State *L);
static int SgLuaBufferNotQWord(lua_State *L);
static int SgLuaBufferNotQWordN(lua_State *L);


//
// OR functions
//
static int SgLuaBufferOr(lua_State *L);
static int SgLuaBufferOrWord(lua_State *L);
static int SgLuaBufferOrWordN(lua_State *L);
static int SgLuaBufferOrDWord(lua_State *L);
static int SgLuaBufferOrDWordN(lua_State *L);
static int SgLuaBufferOrQWord(lua_State *L);
static int SgLuaBufferOrQWordN(lua_State *L);

//
// Rand functions
//
static int SgLuaBufferRand(lua_State *L);

//
// SET functions
//
static int SgLuaBufferSet(lua_State *L);
static int SgLuaBufferSetWord(lua_State *L);
static int SgLuaBufferSetDWord(lua_State *L);
static int SgLuaBufferSetQWord(lua_State *L);
static int SgLuaBufferSetWordN(lua_State *L);
static int SgLuaBufferSetDWordN(lua_State *L);
static int SgLuaBufferSetQWordN(lua_State *L);


//
// SIZE functions
//
static int SgLuaBufferSize(lua_State *L);

//
// TOSTRING functions
//
static int SgLuaBufferToString(lua_State *L);

//
// XOR functions
//
static int SgLuaBufferXOr(lua_State *L);
static int SgLuaBufferXOrWord(lua_State *L);
static int SgLuaBufferXOrWordN(lua_State *L);
static int SgLuaBufferXOrDWord(lua_State *L);
static int SgLuaBufferXOrDWordN(lua_State *L);
static int SgLuaBufferXOrQWord(lua_State *L);
static int SgLuaBufferXOrQWordN(lua_State *L);

//
// Registration Tables
//
static const struct luaL_reg SgLuaBufferLibF[] = {
    { "new", SgLuaBufferNew },
    { "copy", SgLuaBufferCopy },
    { "compare", SgLuaBufferCompare },
    { NULL, NULL },
};

static const struct luaL_reg SgLuaBufferLibM[] = {
    //
    // Meta functions
    //
    { "__tostring", SgLuaBufferToString },
    { "__len",      SgLuaBufferSize },

    //
    // And functions
    //
    { "andbyte",   SgLuaBufferAnd },
    { "andword",   SgLuaBufferAndWord },
    { "andwordn",  SgLuaBufferAndWordN },
    { "anddword",  SgLuaBufferAndDWord },
    { "anddwordn", SgLuaBufferAndDWordN },
    { "andqword",  SgLuaBufferAndQWord },
    { "andqwordn", SgLuaBufferAndQWordN },

    //
    // Get Functions
    //
    { "getstring", SgLuaBufferGetString },
    { "getbyte",   SgLuaBufferGet },
    { "getword",   SgLuaBufferGetWord },
    { "getdword",  SgLuaBufferGetDWord },
    { "getqword",  SgLuaBufferGetQWord },
    { "getwordn",  SgLuaBufferGetWordN },
    { "getdwordn", SgLuaBufferGetDWordN },
    { "getqwordn", SgLuaBufferGetQWordN },

    //
    // Last Functions
    //
    { "lastbyte",  SgLuaBufferLast },
    { "lastword",  SgLuaBufferLastWord },
    { "lastdword", SgLuaBufferLastDWord },
    { "lastqword", SgLuaBufferLastQWord },

    //
    // Not Functions
    //
    { "notbyte",   SgLuaBufferNot },
    { "notword",   SgLuaBufferNotWord },
    { "notwordn",  SgLuaBufferNotWordN },
    { "notdword",  SgLuaBufferNotDWord },
    { "notdwordn", SgLuaBufferNotDWordN },
    { "notqword",  SgLuaBufferNotQWord },
    { "notqwordn", SgLuaBufferNotQWordN },

    //
    // Or Functions
    //
    { "orbyte",   SgLuaBufferOr },
    { "orword",   SgLuaBufferOrWord },
    { "orwordn",  SgLuaBufferOrWordN },
    { "ordword",  SgLuaBufferOrDWord },
    { "ordwordn", SgLuaBufferOrDWordN },
    { "orqword",  SgLuaBufferOrQWord },
    { "orqwordn", SgLuaBufferOrQWordN },

    //
    // Rand functions
    //
    { "rand",     SgLuaBufferRand },

    //
    // SET functions
    //
    { "setbyte",   SgLuaBufferSet },
    { "setword",   SgLuaBufferSetWord },
    { "setdword",  SgLuaBufferSetDWord },
    { "setqword",  SgLuaBufferSetQWord },
    { "setwordn",  SgLuaBufferSetWordN },
    { "setdwordn", SgLuaBufferSetDWordN },
    { "setqwordn", SgLuaBufferSetQWordN },

    //
    // Size function
    //
    { "size", SgLuaBufferSize },

    //
    // Or Functions
    //
    { "xorbyte",   SgLuaBufferXOr },
    { "xorword",   SgLuaBufferXOrWord },
    { "xorwordn",  SgLuaBufferXOrWordN },
    { "xordword",  SgLuaBufferXOrDWord },
    { "xordwordn", SgLuaBufferXOrDWordN },
    { "xorqword",  SgLuaBufferXOrQWord },
    { "xorqwordn", SgLuaBufferXOrQWordN },

    //
    // Terminator
    //
    { NULL, NULL },
};

//
// Name for the metatable
//
#define BUFFER_METATABLE        "SG.Buffer"
#define BUFFER_LOGICOP_NOT      0
#define BUFFER_LOGICOP_AND      1
#define BUFFER_LOGICOP_OR       2
#define BUFFER_LOGICOP_XOR      3

//---------------------------------------------------------------------------//
//                                                                           //
// PUBLIC Worker Routines                                                    //
//                                                                           //
//---------------------------------------------------------------------------//

int SgLuaBufferInitialize( lua_State *L, BYTE *pbBuffer, ULONG cbBuffer, BOOL bReadOnly, BOOL bCopy )
{
    size_t       cbBytes;
    SgLuaBuffer *b;

    //
    // Calculate the number of bytes we need for the record pointer
    //
    cbBytes = sizeof(SgLuaBuffer);
    if (bCopy)
    {
        cbBytes += cbBuffer;
    }

    //
    // Allocate the user data and set the metatable for it
    //
    b = (SgLuaBuffer *) lua_newuserdata(L, cbBytes );
    luaL_getmetatable(L, BUFFER_METATABLE );
    lua_setmetatable(L, -2);

    //
    // Setup the user buffer to point to the supplied pointer and set it to
    // read only mode (if required)
    //
    b->_cbBuffer = cbBuffer;
    b->_bReadOnly = bReadOnly;
    if (bCopy)
    {
        b->_pbBuffer = (BYTE *) (b + 1);
        memcpy( b->_pbBuffer, pbBuffer, cbBuffer );
    }
    else
    {
        b->_pbBuffer = pbBuffer;
    }

    //
    // new user data on the stack
    //
    return 1;
}

void SgLuaBufferRegister( lua_State *L )
{
    //
    // Register the buffer metatable
    //
    luaL_newmetatable(L, BUFFER_METATABLE);
    lua_pushstring(L,"__index");
    lua_pushvalue(L, -2);
    lua_settable(L, -3);

    //
    // Register the buffer library handler
    //
    luaL_register(L, NULL, SgLuaBufferLibM );
    luaL_register(L, "Buffer", SgLuaBufferLibF );
}

void SgLuaBufferCheck(
    lua_State* pLuaState,
    int narg,
    OUT BYTE** ppBuffer,
    OUT UINT32* pcbBuffer
    )
// ---------------------------------------------------------------------------------------
// SgLuaBufferCheck
// Retrieve the pointer and the size of a lua-buffer given its index in the stack
//   - pLuaState: pointer to lua_State
//   - narg: stack index of the user-data argument
//   - ppBuffer: (OUT) pointer to receive pointer to buffer
//   - pcbBuffer: (OUT) pointer to receive size of buffer
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
{
    SgLuaBuffer* pLuaBuffer = SgLuaBufferToPointer(pLuaState, narg);

    *ppBuffer  = pLuaBuffer->_pbBuffer;
    *pcbBuffer = pLuaBuffer->_cbBuffer;
}

//---------------------------------------------------------------------------//
//                                                                           //
// PRIVATE Worker Routines                                                   //
//                                                                           //
//---------------------------------------------------------------------------//

static SgLuaBuffer *SgLuaBufferToPointer(lua_State *L, int narg)
//
// Worker routine to find the userdata from the stack
//
{
    void *b = luaL_checkudata( L, narg, BUFFER_METATABLE );
    luaL_argcheck(L, b != NULL, narg, "'SG.Buffer' expected");
    return (SgLuaBuffer *)b;
}

static int SgLuaBufferGetElement(lua_State *L, ULONG elemSize, BOOL bNetwork)
//
// Worker routine for :get()
//
{
    ULONG       index;
    UINT64      value;
    SgLuaBuffer *b;

    if (lua_gettop(L) < 2)
    {
        return luaL_error(L,"getelement(offset) - too few arguments");
    }

    //
    // 2 Param -> Index to read from
    //
    index = (ULONG) luaL_checkint(L, 2 );

    //
    // 1 Param -> Buffer to read from
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Range Check
    //
    luaL_argcheck(
        L,
        b->_cbBuffer >= elemSize && index < (b->_cbBuffer - (elemSize - 1)),
        2,
        "index out of range"
        );

    //
    // Answer depends on element size
    //
    switch (elemSize)
    {
    case 2:
        value =  * ( (USHORT *) (b->_pbBuffer + index)   );
        if (bNetwork)
        {
            value = HTONS( (USHORT) value );
        }
        lua_pushnumber(L, (lua_Number) (USHORT) value );
        break;
    case 4:
        value = * ( (ULONG *)   (b->_pbBuffer + index)   );
        if (bNetwork)
        {
            value = HTONL( (ULONG) value );
        }
        lua_pushnumber(L, (lua_Number) (ULONG) value );
        break;
    case 8:
        value = * ( (UINT64 *)  (b->_pbBuffer + index)    );
        if (bNetwork)
        {
            value = HTONQ( value );
        }
        return SgLuaQwordInitialize(L, value );
        break;
    default:
        value = * ( (UCHAR *)  (b->_pbBuffer + index)    );
        lua_pushnumber(L, (lua_Number) (UCHAR) value );
        break;
    }

    //
    // we normally push one element onto the stack
    //
    return 1;
}

static int SgLuaBufferLastElement(lua_State *L, ULONG elemSize)
//
// Worker routine for :get()
//
{
    BYTE        *pb;
    SgLuaBuffer *b;
    ULONG        i;
    USHORT      *pw;
    ULONG       *pl;
    UINT64      *pll;

    if (lua_gettop(L) < 1)
    {
        return luaL_error(L,"lastelement() - too few arguments");
    }

    //
    // 1 Param -> Buffer to read from
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Answer depends on element size
    //
    switch (elemSize)
    {
    case 2:
        pw = (USHORT *) (b->_pbBuffer);
        for (i = (b->_cbBuffer / sizeof(USHORT) ); i > 0; i--)
        {
            if (pw[i-1] != 0)
            {
                break;
            }
        }
        break;

    case 4:
        pl = (ULONG *) (b->_pbBuffer);
        for (i = (b->_cbBuffer / sizeof(ULONG) ); i > 0; i--)
        {
            if (pl[i-1] != 0)
            {
                break;
            }
        }
        break;

    case 8:
        pll = (UINT64 *) (b->_pbBuffer);
        for (i = (b->_cbBuffer / sizeof(UINT64) ); i > 0; i--)
        {
            if (pll[i-1] != 0)
            {
                break;
            }
        }
        break;

    default:
        pb = (b->_pbBuffer);
        for (i = (b->_cbBuffer / sizeof(BYTE) ); i > 0; i--)
        {
            if (pb[i-1] != 0)
            {
                break;
            }
        }
        break;
    }

    //
    // If we went through the entire array without finding a non-zero value
    // then return -1
    //
    if (i == 0)
    {
        lua_pushinteger(L, -1);
    }
    else
    {
        lua_pushinteger(L, ( (i - 1) * elemSize) );
    }

    //
    // 1 pushed onto the stack
    //
    return 1;
}

static int SgLuaBufferLogicElement(lua_State *L, ULONG elemSize, BOOL bNetwork, DWORD dwOp)
//
// Worker routine for :and, xor, and or()
//
{
    int         retNum = 1;
    UINT64      mask = 0;
    UINT64      value;
    ULONG       index;
    SgLuaBuffer *b;

    if (dwOp != BUFFER_LOGICOP_NOT)
    {
        if (lua_gettop(L) < 3)
        {
            return luaL_error(L,"logic(offset,<number|qword>) - too few arguments");
        }

        //
        // 3 Param -> Mask to use
        //
        if (SgLuaQwordPresent(L,3))
        {
            mask = SgLuaQwordCheck(L, 3);
        }
        else
        {
            mask = (UINT64) luaL_checknumber(L, 3 );
        }
    }
    else
    {
        if (lua_gettop(L) < 2)
        {
            return luaL_error(L,"not(offset) - too few arguments");
        }
    }

    //
    // 2 Param -> Index to read from
    //
    index = luaL_checkint(L, 2 );

    //
    // 1 Param -> Buffer to read from
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Range Check
    //
    luaL_argcheck(
        L,
        b->_cbBuffer >= elemSize && index < (b->_cbBuffer - (elemSize - 1)),
        2,
        "index out of range"
        );

    //
    // Fetch the correct amount of data from the table
    //
    switch (elemSize)
    {
    case 2:
        value =  * ( (USHORT *) (b->_pbBuffer + index)   );
        if (bNetwork)
        {
            value = HTONS( (USHORT) value );
        }
        break;
    case 4:
        value = * ( (ULONG *)   (b->_pbBuffer + index)   );
        if (bNetwork)
        {
            value = HTONL( (ULONG) value );
        }
        break;
    case 8:
        value = * ( (UINT64 *)  (b->_pbBuffer + index)    );
        if (bNetwork)
        {
            value = HTONQ( value );
        }
        break;
    default:
        value = * ( (UCHAR *)  (b->_pbBuffer + index)    );
        break;
    }

    //
    // Perform the operation
    //
    switch (dwOp)
    {
    case BUFFER_LOGICOP_AND:
        value &= mask;
        break;
    case BUFFER_LOGICOP_XOR:
        value ^= mask;
        break;
    case BUFFER_LOGICOP_OR:
        value |= mask;
        break;
    case BUFFER_LOGICOP_NOT:
    default:
        value = ~value;
        break;
    }

    //
    // Push the correct amount of data onto the stack
    //
    switch (elemSize)
    {
    case 2:
        lua_pushnumber(L, (lua_Number) (USHORT) value );
        break;
    case 4:
        lua_pushnumber(L, (lua_Number) (ULONG) value );
        break;
    case 8:
        return SgLuaQwordInitialize(L, value );
    default:
        lua_pushnumber(L, (lua_Number) (UCHAR) value );
        break;
    }

    //
    // 1 Number pushed onto the stack
    //
    return 1;
}

static int SgLuaBufferSetElement(lua_State *L, ULONG elemSize, BOOL bNetwork)
//
// Worker routine for :set()
//
{
    UINT64      value;
    ULONG       index;
    SgLuaBuffer *b;


    if (lua_gettop(L) < 3)
    {
        return luaL_error(L,"setelement(offset,<number|qword>) - too few arguments");
    }

    //
    // 3 Param -> Value to set
    //
    if (SgLuaQwordPresent(L,3))
    {
        value = SgLuaQwordCheck(L, 3);
    }
    else
    {
        value = (UINT64) luaL_checknumber(L, 3 );
    }

    //
    // 2 Param -> Index to read from
    //
    index = luaL_checkint(L, 2 );

    //
    // 1 Param -> Buffer to read from
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Range Check
    //
    luaL_argcheck(
        L,
        b->_cbBuffer >= elemSize && index < (b->_cbBuffer - (elemSize - 1)),
        2,
        "index out of range"
        );

    //
    // Read only Check
    //
    luaL_argcheck(
        L,
        b->_bReadOnly == FALSE,
        1,
        "'SG.Buffer' is read-only"
        );

    //
    // Action depends on element size
    //
    switch (elemSize)
    {
    case 2:
        if (bNetwork)
        {
            value = HTONS( (USHORT) value);
        }
        * ( ( (USHORT *) (b->_pbBuffer + index)     ) ) = (USHORT) (value & 0xFFFF);
        break;
    case 4:
        if (bNetwork)
        {
            value = HTONL( (ULONG) value);
        }
        * ( ( (ULONG *)  (b->_pbBuffer + index)     ) ) = (ULONG) value;
        break;
    case 8:
        if (bNetwork)
        {
            value = HTONQ( value );
        }
        * ( ( (UINT64 *)  (b->_pbBuffer + index)    ) ) = value;
        break;
    default:
        * ( ( (UCHAR *)  (b->_pbBuffer + index)     ) ) = (UCHAR) (value & 0xFF);
        break;
    }

    //
    // Nothing pushed onto the stack
    //
    return 0;
}

//---------------------------------------------------------------------------//
//                                                                           //
// LUA Visible Routines                                                      //
//                                                                           //
//---------------------------------------------------------------------------//

//---------------------------------------------------------------------------//
//                                                                           //
// AND Routines                                                              //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferAnd(lua_State *L)
//
// Sample Usage: a = SgBuffer:and(1,0x70);
//
{
    return SgLuaBufferLogicElement(L, 1, FALSE, BUFFER_LOGICOP_AND);
}

static int SgLuaBufferAndWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:andword(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, FALSE, BUFFER_LOGICOP_AND);
}

static int SgLuaBufferAndWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:andwordn(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, TRUE, BUFFER_LOGICOP_AND);
}

static int SgLuaBufferAndDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:anddword(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, FALSE, BUFFER_LOGICOP_AND);
}

static int SgLuaBufferAndDWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:anddwordn(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, TRUE, BUFFER_LOGICOP_AND);
}

static int SgLuaBufferAndQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:andqword(1,qword<0x7070707070707070>);
//
{
    return SgLuaBufferLogicElement(L, 8, FALSE, BUFFER_LOGICOP_AND);
}

static int SgLuaBufferAndQWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:andqword(1,qword<0x7070707070707070>);
//
{
    return SgLuaBufferLogicElement(L, 8, TRUE, BUFFER_LOGICOP_AND);
}

//---------------------------------------------------------------------------//
//                                                                           //
// GET Routines                                                              //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferGetString(lua_State *L)
//
// Sample Usage: a = SgBuffer:getstring(1)
// Sample Usage: a = SgBuffer:getstring(1,10)
//
{
    ULONG       index;
    ULONG       length;
    ULONG       temp;
    char        *pbStr;
    SgLuaBuffer *b;

    if (lua_gettop(L) < 2)
    {
        return luaL_error(L,"getstring(offset) - too few arguments");
    }

    //
    // 2 Param -> Index to read from
    //
    index = (ULONG) luaL_checkint(L, 2 );

    //
    // 1 Param -> Buffer to read from
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Range Check
    //
    luaL_argcheck(
        L,
        b->_cbBuffer >= 1 && index < (b->_cbBuffer),
        2,
        "index out of range"
        );

    //
    // Grab the ptr
    //
    pbStr = ( (char *)  (b->_pbBuffer + index)    );

    //
    // Is there a hint on the length?
    //
    if (lua_gettop(L) >= 3)
    {
        length = (ULONG) luaL_checkint(L, 3);
        luaL_argcheck(
            L,
            b->_cbBuffer >= length && (index + length) <= (b->_cbBuffer),
            3,
            "length out of range"
            );

    }
    else
    {
        length = b->_cbBuffer - index;
    }

    //
    // Find the last non-printable character
    //
    for (temp = 0; temp < length; temp++)
    {
        if (!isprint(*(pbStr + temp)))
        {
            break;
        }
    }
    length = temp;

    //
    // Push the string onto the stack
    //
    if (length == 0)
    {
        lua_pushnil(L);
    }
    else
    {
        lua_pushlstring(L,pbStr,length);
    }

    //
    // we pushed one element onto the stack
    //
    return 1;
}

static int SgLuaBufferGet(lua_State *L)
//
// Sample Usage: a = SgBuffer:get(1);
//
{
    return SgLuaBufferGetElement(L, 1, FALSE);
}

static int SgLuaBufferGetWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:getword(1);
//
{
    return SgLuaBufferGetElement(L, 2, FALSE);
}

static int SgLuaBufferGetWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:getwordn(1);
//
{
    return SgLuaBufferGetElement(L, 2, TRUE);
}

static int SgLuaBufferGetDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:getdword(1);
//
{
    return SgLuaBufferGetElement(L, 4, FALSE);
}

static int SgLuaBufferGetDWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:getdwordn(1);
//
{
    return SgLuaBufferGetElement(L, 4, TRUE);
}

static int SgLuaBufferGetQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:getqword(1);
//
{
    return SgLuaBufferGetElement(L, 8, FALSE);
}

static int SgLuaBufferGetQWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:getqword(1);
//
{
    return SgLuaBufferGetElement(L, 8, TRUE);
}

//---------------------------------------------------------------------------//
//                                                                           //
// LAST Routines                                                             //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferLast(lua_State *L)
//
// Sample Usage: a = SgBuffer:last()
//
{
    return SgLuaBufferLastElement(L, 1);
}

static int SgLuaBufferLastWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:lastword()
//
{
    return SgLuaBufferLastElement(L, 2);
}

static int SgLuaBufferLastDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:lastdword()
//
{
    return SgLuaBufferLastElement(L, 4);
}

static int SgLuaBufferLastQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:lastqword()
//
{
    return SgLuaBufferLastElement(L, 8);
}

//---------------------------------------------------------------------------//
//                                                                           //
// Memory Management Routines                                                //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferNew(lua_State *L)
//
// Sample Usage: a = SgBuffer.new(1024);
// Sample Usage: a = SgBUffer.new('0x123456789abcdef')
// Sample Usage: a = SbBuffer.new('0x123456789abcdef',true)
//
{
    const char  *luaString = NULL;
    int          luaBoolean = FALSE;
    int          luaType;
    size_t       cbBytes;
    size_t       cbBuffer;
    SgLuaBuffer *b;

    //
    // Make sure that the lua stack has at least one element
    //
    if (lua_gettop(L) == 0)
    {
        return luaL_error(L,"New: called with 0 arguments");
    }

    //
    // The argument we want is at stack location (1). This can be either
    // a LUA_TSTRING or a LUA_TNUMBER
    //
    luaType = lua_type(L,1);
    if (luaType != LUA_TNUMBER && luaType != LUA_TSTRING)
    {
        return luaL_error(L,"New: argument 0 is type %s", lua_typename(L,luaType));
    }

    //
    // Look at the argument to see how big of a buffer is required
    //
    if (luaType == LUA_TNUMBER)
    {
        //
        // Make sure that we have integer at the top of the stack
        //
        cbBuffer = luaL_checkint(L, 1);
    }
    else
    {
        //
        // Get a pointer to the string. This string is in hex format and null
        // terminated. So the real amount of space required by the buffer
        // is (cbBuffer / 2)
        //
        luaString = lua_tolstring( L, 1, &cbBuffer );

        //
        // Make sure that the string is correctly sized
        //
        luaL_argcheck(
            L,
            (cbBuffer % 2 == 0),
            1,
            "New: string is not a multiple of 2"
            );
        luaL_argcheck(
            L,
            cbBuffer >= 2,
            1,
            "New: string must contain at least 1 byte"
            );

        cbBuffer = (cbBuffer / 2);
    }

    //
    // Sanity check for the maximum buffer size
    //
    if (cbBuffer > SG_LUA_BUFFER_MAXIMUM_SIZE)
    {
        return luaL_error(L,"New: size must be less than %d bytes", SG_LUA_BUFFER_MAXIMUM_SIZE );
    }

    //
    // See if we have anything at index 2
    //
    if (lua_gettop(L) >= 2)
    {
        //
        // Yes. This will control wether or not we are readonly
        //
        luaBoolean = lua_toboolean( L, 2 );
    }

    //
    // Calculate the number of bytes we need for the array
    //
    cbBytes = sizeof(SgLuaBuffer) + cbBuffer * sizeof(char);

    //
    // Allocate the userdata and set the metable for it
    //
    b = (SgLuaBuffer *) lua_newuserdata(L, cbBytes );
    luaL_getmetatable(L, BUFFER_METATABLE );
    lua_setmetatable(L, -2);

    //
    // Set the user buffer to empty bytes and setup the pointer to the
    // buffer array
    //
    memset( b, 0, sizeof(SgLuaBuffer) );
    b->_cbBuffer = cbBuffer;
    b->_pbBuffer = (BYTE *) (b + 1);
    b->_bReadOnly = (BOOL) (luaBoolean ? TRUE : FALSE);

    //
    // Initialize the buffer properly
    //
    if (luaType == LUA_TNUMBER)
    {
        //
        // Zero the buffer
        //
        memset( b->_pbBuffer, 0, cbBuffer );
    }
    else
    {
        BYTE *pb = b->_pbBuffer;

        //
        // Convert the string to hexidecimal
        //
        for (; cbBuffer > 0; --cbBuffer, ++pb )
        {
            BYTE bValue = 0;
            int i;

            for (i = 0; i < 2; i++)
            {
                bValue <<= 4;
                if (*luaString >= '0' && *luaString <= '9')
                {
                    bValue |= (*luaString - '0');
                }
                else if (*luaString >= 'a' && *luaString <= 'f')
                {
                    bValue |= (*luaString - 'a') + 10;
                }
                else if (*luaString >= 'A' && *luaString <= 'F')
                {
                    bValue |= (*luaString - 'A') + 10;
                }
                else
                {
                    return luaL_error(L, "New: string contains non-hex character");
                }
                luaString++;
            }
            *pb = bValue;
        }
    }

    //
    // new userdata on the stack
    //
    return 1;
}

static int SgLuaBufferCompare(lua_State *L)
//
// Sample Usage: SgBuffer.compare(ToBuffer, ToOffset, FromBuffer, FromOffset, Length )
//
{
    int         result;
    ULONG       toIndex;
    ULONG       fromIndex;
    ULONG       length;
    SgLuaBuffer *to;
    SgLuaBuffer *from;

    //
    // Argument check
    //
    if (lua_gettop(L) < 5)
    {
        return luaL_error(L,"compare(to,tooffset,from,fromoffset,length) - too few arguments");
    }

    //
    // 5 Length of the buffer to copy
    //
    length = luaL_checkint(L, 5 );

    //
    // 4 FromOffset
    //
    fromIndex = luaL_checkint(L, 4 );

    //
    // 3 From Buffer
    //
    from = SgLuaBufferToPointer(L, 3 );

    //
    // 2 ToOffset
    //
    toIndex = luaL_checkint(L, 2 );

    //
    // 1 To
    //
    to = SgLuaBufferToPointer(L, 1 );

    //
    // Argument checks
    //
    luaL_argcheck(
        L,
        length <= SG_LUA_BUFFER_MAXIMUM_SIZE,
        5,
        "length over maximum buffer limit"
        );
    luaL_argcheck(
        L,
        toIndex < to->_cbBuffer &&
        toIndex + length <= to->_cbBuffer,
        2,
        "index out of bounds for to buffer"
        );
    luaL_argcheck(
        L,
        fromIndex < from->_cbBuffer &&
        fromIndex + length <= from->_cbBuffer,
        4,
        "index out of bounds for from buffer"
        );

    //
    // Compare the memory
    //
    result = memcmp(
        to->_pbBuffer + toIndex,
        from->_pbBuffer + fromIndex,
        length
        );

    //
    // Answer pushed onto the stack
    //
    lua_pushinteger( L, result );
    return 1;
}

static int SgLuaBufferCopy(lua_State *L)
//
// Sample Usage: SgBuffer.copy(ToBuffer, ToOffset, FromBuffer, FromOffset, Length )
//
{
    int         stackTop = -1;
    ULONG       toIndex;
    ULONG       fromIndex;
    ULONG       length;
    SgLuaBuffer *to;
    SgLuaBuffer *from;

    //
    // Argument check
    //
    if (lua_gettop(L) < 5)
    {
        return luaL_error(L,"copy(to,tooffset,from,fromoffset,length) - too few arguments");
    }

    //
    // 5 Length of the buffer to copy
    //
    length = luaL_checkint(L, 5 );

    //
    // 4 FromOffset
    //
    fromIndex = luaL_checkint(L, 4 );

    //
    // 3 From Buffer
    //
    from = SgLuaBufferToPointer(L, 3 );

    //
    // 2 ToOffset
    //
    toIndex = luaL_checkint(L, 2 );

    //
    // 1 To
    //
    to = SgLuaBufferToPointer(L, 1 );

    //
    // Argument checks
    //
    luaL_argcheck(
        L,
        length <= SG_LUA_BUFFER_MAXIMUM_SIZE,
        5,
        "length over maximum buffer limit"
        );
    luaL_argcheck(
        L,
        to->_bReadOnly == FALSE,
        1,
        "destination buffer is read-only"
        );
    luaL_argcheck(
        L,
        toIndex < to->_cbBuffer &&
        toIndex + length <= to->_cbBuffer,
        2,
        "destination buffer too small"
        );
    luaL_argcheck(
        L,
        fromIndex < from->_cbBuffer &&
        fromIndex + length <= from->_cbBuffer,
        4,
        "index out of bounds for from buffer"
        );

    //
    // Copy the memory
    //
    memcpy(
        to->_pbBuffer + toIndex,
        from->_pbBuffer + fromIndex,
        length
        );

    //
    // Nothing pushed onto the stack
    //
    return 0;
}

//---------------------------------------------------------------------------//
//                                                                           //
// NOT Routines                                                              //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferNot(lua_State *L)
//
// Sample Usage: a = SgBuffer:notbyte(1,0x70);
//
{
    return SgLuaBufferLogicElement(L, 1, FALSE, BUFFER_LOGICOP_NOT);
}

static int SgLuaBufferNotWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:notword(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, FALSE, BUFFER_LOGICOP_NOT);
}

static int SgLuaBufferNotWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:notwordn(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, TRUE, BUFFER_LOGICOP_NOT);
}

static int SgLuaBufferNotDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:notdword(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, FALSE, BUFFER_LOGICOP_NOT);
}

static int SgLuaBufferNotDWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:notdwordn(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, TRUE, BUFFER_LOGICOP_NOT);
}

static int SgLuaBufferNotQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:notqword(1,qword.new('0x7070707070707070'));
//
{
    return SgLuaBufferLogicElement(L, 8, FALSE, BUFFER_LOGICOP_NOT);
}

static int SgLuaBufferNotQWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:notqword(1,qword.new('0x7070707070707070'));
//
{
    return SgLuaBufferLogicElement(L, 8, TRUE, BUFFER_LOGICOP_NOT);
}

//---------------------------------------------------------------------------//
//                                                                           //
// OR Routines                                                               //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferOr(lua_State *L)
//
// Sample Usage: a = SgBuffer:orbyte(1,0x70);
//
{
    return SgLuaBufferLogicElement(L, 1, FALSE, BUFFER_LOGICOP_OR);
}

static int SgLuaBufferOrWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:orword(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, FALSE, BUFFER_LOGICOP_OR);
}

static int SgLuaBufferOrWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:orwordn(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, TRUE, BUFFER_LOGICOP_OR);
}

static int SgLuaBufferOrDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:ordword(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, FALSE, BUFFER_LOGICOP_OR);
}

static int SgLuaBufferOrDWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:ordwordn(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, TRUE, BUFFER_LOGICOP_OR);
}

static int SgLuaBufferOrQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:orqword(1,qword.new('0x7070707070707070'));
//
{
    return SgLuaBufferLogicElement(L, 8, FALSE, BUFFER_LOGICOP_OR);
}

static int SgLuaBufferOrQWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:orqword(1,qword.new('0x7070707070707070'));
//
{
    return SgLuaBufferLogicElement(L, 8, TRUE, BUFFER_LOGICOP_OR);
}

//---------------------------------------------------------------------------//
//                                                                           //
// RAND Routines                                                             //
//                                                                           //
//---------------------------------------------------------------------------//
static int SgLuaBufferRand(lua_State *L)
//
// Sample Usage: SgBuffer:rand()       -- Fills entire buffer
//               SgBuffer:rand(100)    -- Fills from specified offset
//               SgBuffer:rand(100,16) -- Fills from specified offset for s
//                                        pecified elements
{
    BYTE        *pb;
    SgLuaBuffer *b;
    ULONG        index;
    ULONG        size;

    //
    // 1 Param -> Buffer to modify
    //
    b = SgLuaBufferToPointer(L, 1);

    //
    // Read only Check
    //
    luaL_argcheck(
        L,
        b->_bReadOnly == FALSE,
        1,
        "'SG.Buffer' is read-only"
        );

    //
    // Figure out where the start of the area to randomize is. If param 2 is
    // present, use that value
    //
    if (lua_gettop(L) >= 2)
    {
        index = luaL_checkint(L, 2);
    }
    else
    {
        index = 0;
    }

    //
    // Offset start check
    //
    luaL_argcheck(
        L,
        index < b->_cbBuffer,
        2,
        "index out of bounds"
        );

    //
    // Figure out the number of bytes to randomize. If param 3 is present,
    // use that value
    //
    if (lua_gettop(L) >= 3)
    {
        size = luaL_checkint(L, 3);
    }
    else
    {
        // Otherwise rand from the start to the end
        size = b->_cbBuffer - index;
    }

    //
    // Size check
    //
    luaL_argcheck(
        L,
        size <= b->_cbBuffer,
        3,
        "size out of bounds"
        );
    luaL_argcheck(
        L,
        index + size <= b->_cbBuffer,
        3,
        "index + size out of bounds"
        );

    //
    // Randomsize the memory
    //
    SgRand( b->_pbBuffer + index, size );

    //
    // Nothing pushed onto the stack
    //
    return 0;
}

//---------------------------------------------------------------------------//
//                                                                           //
// SET Routines                                                              //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferSet(lua_State *L)
//
// Sample Usage: a = SgBuffer.set(1,1);
//
{
    return SgLuaBufferSetElement(L, 1, FALSE);
}

static int SgLuaBufferSetWord(lua_State *L)
//
// Sample Usage: a = SgBuffer.setword(1,1);
//
{
    return SgLuaBufferSetElement(L, 2, FALSE);
}

static int SgLuaBufferSetWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer.setwordn(1,1);
//
{
    return SgLuaBufferSetElement(L, 2, TRUE);
}

static int SgLuaBufferSetDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer.setdword(1,1);
//
{
    return SgLuaBufferSetElement(L, 4, FALSE);
}

static int SgLuaBufferSetDWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer.setdwordn(1,1);
//
{
    return SgLuaBufferSetElement(L, 4, TRUE);
}

static int SgLuaBufferSetQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer.setqword(1,1);
//
{
    return SgLuaBufferSetElement(L, 8, FALSE);
}

static int SgLuaBufferSetQWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer.setqwordn(1,1);
//
{
    return SgLuaBufferSetElement(L, 8, TRUE);
}

//---------------------------------------------------------------------------//
//                                                                           //
// SIZE Routines                                                             //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferSize(lua_State *L)
{
    SgLuaBuffer *b;

    //
    // 1 Param -> Buffer we need the size for
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Answer
    //
    lua_pushinteger(L, b->_cbBuffer );

    //
    // 1 Number pushed onto the stack
    //
    return 1;
}

//---------------------------------------------------------------------------//
//                                                                           //
// STRING Routines                                                           //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferToString(lua_State *L)
{
    char *buffer;
    char *temp;
    ULONG i;
    SgLuaBuffer *b;

    //
    // 1 Param -> Buffer we need the size for
    //
    b = SgLuaBufferToPointer(L, 1 );

    //
    // Allocate storage and setup pointers for the string we will dynamically
    // build
    //
    buffer = (char *) malloc((b->_cbBuffer * 2) + 1);
    temp = buffer;

    //
    // Iterate over all of the bytes in the array
    //
    for (i = 0; i < b->_cbBuffer; i++)
    {
        temp += sprintf(temp,"%02x",b->_pbBuffer[i]);
    }

    //
    // Answer
    //
    lua_pushstring( L, buffer );

    //
    // Free the allocated memory
    //
    free(buffer);

    //
    // 1 string pushed onto the stack
    //
    return 1;
}

//---------------------------------------------------------------------------//
//                                                                           //
// XOR Routines                                                               //
//                                                                           //
//---------------------------------------------------------------------------//

static int SgLuaBufferXOr(lua_State *L)
//
// Sample Usage: a = SgBuffer:xorbyte(1,0x70);
//
{
    return SgLuaBufferLogicElement(L, 1, FALSE, BUFFER_LOGICOP_XOR);
}

static int SgLuaBufferXOrWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:xorword(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, FALSE, BUFFER_LOGICOP_XOR);
}

static int SgLuaBufferXOrWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:xorwordn(1,0x7070);
//
{
    return SgLuaBufferLogicElement(L, 2, TRUE, BUFFER_LOGICOP_XOR);
}

static int SgLuaBufferXOrDWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:xordword(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, FALSE, BUFFER_LOGICOP_XOR);
}

static int SgLuaBufferXOrDWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:xordwordn(1,0x70707070);
//
{
    return SgLuaBufferLogicElement(L, 4, TRUE, BUFFER_LOGICOP_XOR);
}

static int SgLuaBufferXOrQWord(lua_State *L)
//
// Sample Usage: a = SgBuffer:xorqword(1,qword.new('0x7070707070707070'));
//
{
    return SgLuaBufferLogicElement(L, 8, FALSE, BUFFER_LOGICOP_XOR);
}

static int SgLuaBufferXOrQWordN(lua_State *L)
//
// Sample Usage: a = SgBuffer:xorqword(1,qword.new('0x7070707070707070'));
//
{
    return SgLuaBufferLogicElement(L, 8, TRUE, BUFFER_LOGICOP_XOR);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglbinary.cpp ===
// ---------------------------------------------------------------------------------------
// sglbinary.cpp
//
// Lua extension for binary operators
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// ----------------------------------------------------------------------------------------
// SG Binary Class
// ----------------------------------------------------------------------------------------

static int SgLuaBinaryAnd(lua_State *L)
{
    BOOL   bQword = FALSE;
    UINT64 num1;
    UINT64 num2;

    //
    // Argument check
    //
    if (lua_gettop(L) < 2)
    {
        return luaL_error(L,"bAnd(<num1>,<num2>) - too few arguments");
    }

    //
    // Read the parameters
    //
    if (SgLuaQwordPresent(L,1))
    {
        bQword = TRUE;
        num1 = SgLuaQwordCheck(L, 1);
    }
    else
    {
        num1 = (UINT64) luaL_checknumber(L, 1 );
    }
    if (SgLuaQwordPresent(L,2))
    {
        bQword = TRUE;
        num2 = SgLuaQwordCheck(L, 2);
    }
    else
    {
        num2 = (UINT64) luaL_checknumber(L, 2 );
    }

    //
    // Operation
    //
    num1 &= num2;

    //
    // return value
    //
    if (bQword)
    {
        return SgLuaQwordInitialize(L, num1 );        
    }

    //
    // Force the value to a 32-bit value
    //
    num1 &= 0xFFFFFFFF;

    //
    // Push the answer onto the stack
    //
    lua_pushnumber(L, (lua_Number) num1);
    return 1;
}

static int SgLuaBinaryOr(lua_State *L)
{
    BOOL   bQword = FALSE;
    UINT64 num1;
    UINT64 num2;

    //
    // Argument check
    //
    if (lua_gettop(L) < 2)
    {
        return luaL_error(L,"bOr(<num1>,<num2>) - too few arguments");
    }

    //
    // Read the parameters
    //
    if (SgLuaQwordPresent(L,1))
    {
        bQword = TRUE;
        num1 = SgLuaQwordCheck(L, 1);
    }
    else
    {
        num1 = (UINT64) luaL_checknumber(L, 1 );
    }
    if (SgLuaQwordPresent(L,2))
    {
        bQword = TRUE;
        num2 = SgLuaQwordCheck(L, 2);
    }
    else
    {
        num2 = (UINT64) luaL_checknumber(L, 2 );
    }

    //
    // Operation
    //
    num1 |= num2;

    //
    // return value
    //
    if (bQword)
    {
        return SgLuaQwordInitialize(L, num1 );        
    }

    //
    // Force the value to a 32-bit value
    //
    num1 &= 0xFFFFFFFF;

    //
    // Push the answer onto the stack
    //
    lua_pushnumber(L, (lua_Number) num1);
    return 1;
}

static int SgLuaBinaryXor(lua_State *L)
{
    BOOL   bQword = FALSE;
    UINT64 num1;
    UINT64 num2;

    //
    // Argument check
    //
    if (lua_gettop(L) < 2)
    {
        return luaL_error(L,"bXor(<num1>,<num2>) - too few arguments");
    }

    //
    // Read the parameters
    //
    if (SgLuaQwordPresent(L,1))
    {
        bQword = TRUE;
        num1 = SgLuaQwordCheck(L, 1);
    }
    else
    {
        num1 = (UINT64) luaL_checknumber(L, 1 );
    }
    if (SgLuaQwordPresent(L,2))
    {
        bQword = TRUE;
        num2 = SgLuaQwordCheck(L, 2);
    }
    else
    {
        num2 = (UINT64) luaL_checknumber(L, 2 );
    }

    //
    // Operation
    //
    num1 ^= num2;

    //
    // return value
    //
    if (bQword)
    {
        return SgLuaQwordInitialize(L, num1 );        
    }

    //
    // Force the value to a 32-bit value
    //
    num1 &= 0xFFFFFFFF;

    //
    // Push the answer onto the stack
    //
    lua_pushnumber(L, (lua_Number) num1);
    return 1;
}

static int SgLuaBinaryNot(lua_State *L)
{
    BOOL   bQword = FALSE;
    UINT64 num;

    //
    // Argument check
    //
    if (lua_gettop(L) < 1)
    {
        return luaL_error(L,"bNot(<num1>) - too few arguments");
    }

    //
    // Read the parameters
    //
    if (SgLuaQwordPresent(L,1))
    {
        bQword = TRUE;
        num = SgLuaQwordCheck(L, 1);
    }
    else
    {
        num = (UINT64) luaL_checknumber(L, 1 );
    }

    //
    // Operation
    //
    num = ~num;

    //
    // return value
    //
    if (bQword)
    {
        return SgLuaQwordInitialize(L, num );        
    }

    //
    // Force the value to a 32-bit value
    //
    num &= 0xFFFFFFFF;

    //
    // Push the answer onto the stack
    //
    lua_pushnumber(L, (lua_Number) num);
    return 1;
}


// This is the table of extensions. The left column is the name of the API as it's 
// registered in lua. The right column is the corresponding C api.
static const luaL_Reg g_SgLuaBinary[] = {
    {"band",               SgLuaBinaryAnd },
    {"bor",                SgLuaBinaryOr },
    {"bxor",               SgLuaBinaryXor },
    {"bnot",               SgLuaBinaryNot },
    {NULL,                 NULL}
};

// ---------------------------------------------------------------------------------------
// SgLuaBinaryRegister
// Register lua binary extensions
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaBinaryRegister(lua_State* pLuaState)
{
    luaL_register(pLuaState, "Binary", g_SgLuaBinary);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgldebug.cpp ===
// ---------------------------------------------------------------------------------------
// sgldebug.cpp
//
// SG lua extension for debugging
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// Sgl_DebugTrace
// lua: trace(tracemsg)
// Send a debug trace message to the LuaScript trace area in the SG.
//   - tracemsg (string): trace message to be logged
// ---------------------------------------------------------------------------------------
int Sgl_DebugTrace(lua_State* pLuaState)
{
#ifdef SG_FEATURE_TRACE

    if(Tag(LuaScript))
    {
        const char* pTraceMsg = lua_tostring(pLuaState, 1);
        CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState, FALSE /*don't throw on error*/);

        if (pSpiInfo)
        {
            TraceSz(
                LuaScript,
                "[%08X] %s",
                pSpiInfo->_dwSpiRecv,
                pTraceMsg ? pTraceMsg : "nil"
                );
        }
    }

#endif

    return 0;
}

// This is the table of extensions. The left column is the name of the API as it's
// registered in lua. The right column is the corresponding C api.
static const luaL_Reg g_SgLuaDebug[] = {
    {"trace", Sgl_DebugTrace},
    {NULL,    NULL}
};

// ---------------------------------------------------------------------------------------
// SgLuaDebugRegister
// Register lua debug extensions for the SG
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaDebugRegister(lua_State* pLuaState)
{
    // Register functions as globals (no module/namespace)
    lua_pushvalue(pLuaState, LUA_GLOBALSINDEX);
    luaL_register(pLuaState, NULL, g_SgLuaDebug);
    lua_pop(pLuaState, 2);
}

// ---------------------------------------------------------------------------------------
// Sgl_DebugTrace
// lua: trace(tracemsg)
// Send a debug trace message to the LuaScript trace area in the SG.
//   - tracemsg (string): trace message to be logged
// ---------------------------------------------------------------------------------------
int Sgl_DebugTraceMaster(lua_State* pLuaState)
{
#ifdef SG_FEATURE_TRACE

    if(Tag(LuaScript))
    {
        const char* pTraceMsg = lua_tostring(pLuaState, 1);
        CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState, FALSE /*don't throw on error*/);

        if (pSpiInfo)
        {
            TraceSz(
                LuaScript,
                "[%08X] %s",
                pSpiInfo->_dwSpiRecv,
                pTraceMsg ? pTraceMsg : "nil"
                );
        }
        else
        {
            TraceSz(
                LuaScript,
                "[No Spi] %s",
                pTraceMsg ? pTraceMsg : "nil"
                );
        }
    }

#endif

    return 0;
}

// This is the table of extensions. The left column is the name of the API as it's
// registered in lua. The right column is the corresponding C api.
static const luaL_Reg g_SgLuaDebugMaster[] = {
    {"trace", Sgl_DebugTraceMaster},
    {NULL,    NULL}
};

// ---------------------------------------------------------------------------------------
// SgLuaDebugRegister
// Register lua debug extensions for the SG
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaDebugMasterRegister(lua_State* pLuaState)
{
    // Register functions as globals (no module/namespace)
    lua_pushvalue(pLuaState, LUA_GLOBALSINDEX);
    luaL_register(pLuaState, NULL, g_SgLuaDebugMaster);
    lua_pop(pLuaState, 2);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglchal.cpp ===
// ---------------------------------------------------------------------------------------
// sglchal.cpp
//
// LUA specific code for challenge response
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// Public Code
// ---------------------------------------------------------------------------------------

#define LUACHAL_REPORT_IF_FAIL(ok) \
    if (!ok) \
    { \
        SgEventSz( \
            CHAL_SCRIPT_FAILED, \
            "[%s] Spi: 0x%x CSpiInfo*: 0x%p LUA State: [%x:%x:%x] LUA Error: %s", \
            __FUNCTION__, \
            pSpiInfo->_dwSpiRecv, \
            pSpiInfo->_dwLuaChalCodeId, \
            pSpiInfo->_dwLuaChalCodeParamId, \
            pSpiInfo->_dwLuaChalState, \
            pSpiInfo, \
            error.cstr()); \
    }


void SgLuaChalAnalyze(CSpiInfo *pSpiInfo, BYTE *pbBuffer, ULONG cbBuffer)
{
    BOOL fOk = TRUE;
    ISgLuaState *pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    //
    // Make the protected mode call
    //
    fOk = fOk && pLua->LCall_va(
        "ChallengeAnalyze",
        "b",
        &error,
        &CConstBuffer(pbBuffer, cbBuffer)
        );

    //
    // Release the interface
    //
    pLua->Release();

    LUACHAL_REPORT_IF_FAIL(fOk);
}

void SgLuaChalAssign(CSpiInfo *pSpiInfo, BOOL bAsync)
{
    BOOL fOk = TRUE;
    ISgLuaState *pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    //
    // Setup the fact that we need a sync challenge or an async challenge
    //
    SgLuaChalStateSetAsync( pSpiInfo, bAsync );

    //
    // Make the protected mode call
    //
    fOk = fOk && pLua->LCall_va(
        "ChallengeSelect",
        "",
        &error
        );

    //
    // Release the interface
    //
    pLua->Release();

    LUACHAL_REPORT_IF_FAIL(fOk);
}

void SgLuaChalDropped(CSpiInfo *pSpiInfo)
{
    BOOL fOk = TRUE;
    ISgLuaState *pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    //
    // Make the protected mode call
    //
    fOk = fOk && pLua->LCall_va(
        "ChallengeDropped",
        "",
        &error
        );

    //
    // Release the interface
    //
    pLua->Release();

    LUACHAL_REPORT_IF_FAIL(fOk);
}

BOOL
SgLuaChalGetBinary(
    CSpiInfo* pSpiInfo,
    CBuffer* pCode,
    CBuffer* pParam
    )
{
    BOOL fOk = TRUE;
    ISgLuaState *pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    //
    // Execute the ChallengeGetBinaryFunction to fill in the buffer
    //
    fOk = pLua->LCall_va(
        "ChallengeGetBinary",
        ">bb",
        &error,
        pCode,
        pParam
        );

    //
    // Release the interface
    //
    pLua->Release();

    LUACHAL_REPORT_IF_FAIL(fOk);

    //
    // Did we get back 0 length code blocks or param blocks?
    //
    if (pCode->GetSize() == 0 || pParam->GetSize() == 0)
    {
        //
        // We specifically don't event in this case because this condition
        // can occur while a reload_config operation is in progress.
        //

        //
        // Clear the fact that a challenge was enabled
        //
        SgLuaChalStateSetEnabled( pSpiInfo, FALSE );

        //
        // An empty buffer means that as far as our caller is concerned, we
        // have failed.
        //
        fOk = FALSE;
    }

    return fOk;
}

void SgLuaChalWaitForAckTimeout( CSpiInfo * pSpiInfo )
{
    BOOL fOk = TRUE;
    ISgLuaState *pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    //
    // Make the protected mode call
    //
    fOk = fOk && pLua->LCall_va(
        "ChallengeWaitForAckTimeout",
        "",
        &error
        );

    //
    // Release the interface
    //
    pLua->Release();

    LUACHAL_REPORT_IF_FAIL(fOk);
}

void SgLuaChalWaitForRespTimeout( CSpiInfo * pSpiInfo )
{
    BOOL fOk = TRUE;
    ISgLuaState *pLua = SgLuaGetState(pSpiInfo);
    CLargeStr error;

    //
    // Make the protected mode call
    //
    fOk = fOk && pLua->LCall_va(
        "ChallengeWaitForRespTimeout",
        "",
        &error
        );

    //
    // Release the interface
    //
    pLua->Release();

    LUACHAL_REPORT_IF_FAIL(fOk);
}

void SgpLuaChalStateSet(CSpiInfo *pSpiInfo, DWORD dwFlag, BOOL bEnable)
{
    if (bEnable)
    {
        pSpiInfo->_dwLuaChalState |= dwFlag;
    }
    else
    {
        pSpiInfo->_dwLuaChalState &= ~dwFlag;
    }
}

BOOL SgpLuaChalStateTest(CSpiInfo *pSpiInfo, DWORD dwFlag )
{
    return ((pSpiInfo->_dwLuaChalState & dwFlag) == dwFlag );
}

BOOL SgLuaChalStateAsync(CSpiInfo *pSpiInfo)
{
    return SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_ASYNC);
}

BOOL SgLuaChalStateBlock(CSpiInfo *pSpiInfo)
{
    return SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_BLOCK);
}

BOOL SgLuaChalStateEnabled(CSpiInfo *pSpiInfo)
{
    return SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_ENABLED);
}

BOOL SgLuaChalStateKick(CSpiInfo *pSpiInfo)
{
    return SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_KICK);
}

BOOL SgLuaChalStateLog(CSpiInfo *pSpiInfo)
{
    return SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_LOG);
}

BOOL SgLuaChalStateResend(CSpiInfo *pSpiInfo)
{
    return SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_RESEND);
}

void SgLuaChalStateClear(CSpiInfo *pSpiInfo)
{
    pSpiInfo->_dwLuaChalState = 0;
}

void SgLuaChalSetAsyncStateActive(CSpiInfo *pSpiInfo )
{
    UINT64 qwTicks = SgTimerTick();

    //
    // Move the State Engine
    //
    pSpiInfo->_dwChalAsyncState = SPI_CHAL_ASYNC_STATE_IDLE;
    pSpiInfo->_qwTickChalAsync = qwTicks;

    //
    // Let the world know
    //
    TraceSz( ChalTrace, "[%08lX] Next Send in 0 seconds", pSpiInfo->_dwSpiRecv );
}

void SgLuaChalSetAsyncStateIdle(CSpiInfo *pSpiInfo )
{
    UINT64 qwTicks = g_cTicksPerSpiInfoChalResp;

    //
    // Check for overrides
    //
    if (SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_CUSTOM_SEND))
    {
        qwTicks = pSpiInfo->_dwLuaChalSendTicks;
    }

    //
    // Check for enable
    //
    if (qwTicks)
    {
        qwTicks += SgTimerTick();
    }

    //
    // Move the State Engine
    //
    pSpiInfo->_dwChalAsyncState = SPI_CHAL_ASYNC_STATE_IDLE;
    pSpiInfo->_qwTickChalAsync = qwTicks;

    //
    // Let the world know
    //
    TraceSz(
        ChalTrace,
        "[%08lX] Next Send in %d seconds",
        pSpiInfo->_dwSpiRecv,
        SgTickElapsedInSeconds( SgTimerTick(), qwTicks )
        );
}

void SgLuaChalSetAsyncStateWaitForAck(CSpiInfo *pSpiInfo )
{
    UINT64 qwTicks = g_cTicksPerSpiInfoChalRespAck;

    //
    // Check for overrides
    //
    if (SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_CUSTOM_RESEND))
    {
        qwTicks = pSpiInfo->_dwLuaChalResendTicks;
    }

    //
    // Always enable this timer. Challenges cannot leave SPIs in this
    // state.
    //
    qwTicks += SgTimerTick();

    //
    // Move the State Engine
    //
    pSpiInfo->_dwChalAsyncState = SPI_CHAL_ASYNC_STATE_WAIT_FOR_ACK;
    pSpiInfo->_qwTickChalAsync = qwTicks;

    //
    // Let the world know
    //
    TraceSz(
        ChalTrace,
        "[%08lX] Next Resend in %d seconds",
        pSpiInfo->_dwSpiRecv,
        SgTickElapsedInSeconds( SgTimerTick(), qwTicks )
        );
}

void SgLuaChalSetAsyncStateWaitForResp(CSpiInfo *pSpiInfo )
{
    UINT64 qwTicks = g_cTicksPerSpiInfoChalRespTimeout;

    //
    // Check for overrides
    //
    if (SgpLuaChalStateTest(pSpiInfo, SPI_LUA_CHAL_STATE_CUSTOM_TIMEOUT))
    {
        qwTicks = pSpiInfo->_dwLuaChalTimeoutTicks;
    }

    //
    // Always enable this timer. Challenges cannot leave SPIs in this
    // state.
    //
    qwTicks += SgTimerTick();

    //
    // Move the State Engine
    //
    pSpiInfo->_dwChalAsyncState = SPI_CHAL_ASYNC_STATE_WAIT_FOR_RESP;
    pSpiInfo->_qwTickChalAsync = qwTicks;

    //
    // Let the world know
    //
    TraceSz(
        ChalTrace,
        "[%08lX] Next Timeout in %d seconds",
        pSpiInfo->_dwSpiRecv,
        SgTickElapsedInSeconds( SgTimerTick(), qwTicks )
        );
}

void SgLuaChalSetAsyncStateOff(CSpiInfo *pSpiInfo)
{
    //
    // Move the State Engine
    //
    pSpiInfo->_dwChalAsyncState = SPI_CHAL_ASYNC_STATE_OFF;
    pSpiInfo->_qwTickChalAsync = 0;

    //
    // Let the world know
    //
    TraceSz(
        ChalTrace,
        "[%08lX] Async Challenges Disabled",
        pSpiInfo->_dwSpiRecv
        );
}

void SgLuaChalStateSetAsync(CSpiInfo *pSpiInfo, BOOL bEnable)
{
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_ASYNC, bEnable );
}

void SgLuaChalStateSetBlock(CSpiInfo *pSpiInfo, BOOL bEnable)
{
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_BLOCK, bEnable );
}

void SgLuaChalStateSetEnabled(CSpiInfo *pSpiInfo, BOOL bEnable)
{
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_ENABLED, bEnable );
}

void SgLuaChalStateSetKick(CSpiInfo *pSpiInfo, BOOL bEnable)
{
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_KICK, bEnable );
}

void SgLuaChalStateSetLog(CSpiInfo *pSpiInfo, BOOL bEnable)
{
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_LOG, bEnable );
}

void SgLuaChalStateSetResend(CSpiInfo *pSpiInfo, BOOL bEnable)
{
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_RESEND, bEnable );
}

void SgLuaChalStateSetCustomSendTicks(CSpiInfo *pSpiInfo, DWORD dwTicks)
{
    pSpiInfo->_dwLuaChalSendTicks = dwTicks * TICKS_PER_SECOND;
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_CUSTOM_SEND, TRUE );
}

void SgLuaChalStateSetCustomResendTicks(CSpiInfo *pSpiInfo, DWORD dwTicks)
{
    pSpiInfo->_dwLuaChalResendTicks = dwTicks * TICKS_PER_SECOND;
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_CUSTOM_RESEND, TRUE );
}

void SgLuaChalStateSetCustomTimeoutTicks(CSpiInfo *pSpiInfo, DWORD dwTicks)
{
    pSpiInfo->_dwLuaChalTimeoutTicks = dwTicks * TICKS_PER_SECOND;
    SgpLuaChalStateSet( pSpiInfo, SPI_LUA_CHAL_STATE_CUSTOM_TIMEOUT, TRUE );
}


// -----------------------------------------------------------------------------
// Lua Extensions
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Sgl_ChallengetAsyncMode
// lua: Sgext.ChallengetAsyncMode()
// Returns whether or not the challenge should be in async mode
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeAsyncMode(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    DWORD     state        = SgLuaChalStateAsync( pSpiInfo );

    //
    // Push whether or not this is an async mode challenge
    //
    lua_pushboolean(pLuaState, state ? 1 : 0 );

    //
    // returning 1 argument on the stack
    //
    return 1;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengeBlock
// lua: Sgext.ChallengetBlock(boolean)
// Determine whether or not to block the current connection
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeBlock(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    DWORD     state;

    //
    // -1 Param -> Boolean
    //
    state = lua_toboolean( pLuaState, -1 );

    //
    // Set the new state
    //
    SgLuaChalStateSetBlock( pSpiInfo, (BOOL) state );

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetGetIdFromSpi
// lua: Sgext.ChallengetGetIdForSpi()
// Obtains what the previously selected challenge id was
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeGetIdFromSpi(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);

    //
    // Read the currently challenge code it and push it onto the stack
    //
    lua_pushnumber(pLuaState, pSpiInfo->_dwLuaChalCodeId );

    //
    // returning 1 argument on the stack
    //
    return 1;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetGetParamId
// lua: Sgext.ChallengetGetParamId()
// Obtains what the previously selected challenge param id was
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeGetParamId(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);

    //
    // Read the currently challenge code it and push it onto the stack
    //
    lua_pushnumber(pLuaState, pSpiInfo->_dwLuaChalCodeParamId );

    //
    // returning 1 argument on the stack
    //
    return 1;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengeKick
// lua: Sgext.ChallengetKick(boolean)
// Determine whether or not to kick the current connection
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeKick(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    DWORD     state;

    //
    // -1 Param -> Boolean
    //
    state = lua_toboolean( pLuaState, -1 );

    //
    // Set the new state
    //
    SgLuaChalStateSetKick( pSpiInfo, (BOOL) state );

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengeLog
// lua: Sgext.ChallengeLog(boolean)
// Determine whether or not to log the current connection
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeLog(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    DWORD     state;

    //
    // -1 Param -> Boolean
    //
    state = lua_toboolean( pLuaState, -1 );

    //
    // Set the new state
    //
    SgLuaChalStateSetLog( pSpiInfo, (BOOL) state );

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSetEnable
// lua: Sgext.ChallengetSetEnable
// Indicates that the LUA challenge has been enabled/disabled
// Returns:
//   nothing
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSetEnable(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    DWORD     state;

    //
    // -1 Param -> Boolean
    //
    state = lua_toboolean( pLuaState, -1 );

    //
    // Also remember that we have a LUA challenge enabled
    //
    SgLuaChalStateSetEnabled( pSpiInfo, (BOOL) state );

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSetIdForSpi
// lua: Sgext.ChallengetSetIdForSpi()
// Indicates which LUA challenge has been selected
// Returns:
//   nothing
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSetIdForSpi(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    ULONGLONG id;

    //
    // -1 Param -> New Id
    //
    id = (ULONGLONG) luaL_checknumber(pLuaState, -1);

    //
    // Set the new selected challenge
    //
    pSpiInfo->_dwLuaChalCodeId = (DWORD) id;

    //
    // Also remember that we have a LUA challenge enabled
    //
    SgLuaChalStateSetEnabled( pSpiInfo, TRUE );

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSetParamId
// lua: Sgext.ChallengetSetParamId()
// Indicates which LUA challenge param has been selected
// Returns:
//   nothing
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSetParamId(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    ULONGLONG id;

    //
    // -1 Param -> New Id
    //
    id = (ULONGLONG) luaL_checknumber(pLuaState, -1);

    //
    // Set the new selected challenge
    //
    pSpiInfo->_dwLuaChalCodeParamId = (DWORD) id;

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSetResendPeriod
// lua: Sgext.ChallengetSetResendPeriod()
// Indicates the period until the next challenge resend
// Returns:
//   nothing
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSetResendPeriod(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    UINT64    qwTicks;

    //
    // -1 Param -> new period
    //
    if (lua_gettop(pLuaState) < 1)
    {
        return luaL_error(
            pLuaState,
            "SetResendPeriod(period) - too few arguments"
            );
    }
    qwTicks = (UINT64) luaL_checknumber( pLuaState, -1 );

    // Let the world know
    TraceSz(
        ChalTrace,
        "[%08lX] Chal id 0x%X - New Resend %ds ",
        pSpiInfo->_dwSpiRecv,
        pSpiInfo->_dwLuaChalCodeId,
        (DWORD) qwTicks
        );

    //
    // Set the new selected challenge
    //
    SgLuaChalStateSetCustomResendTicks(pSpiInfo, (DWORD) qwTicks);

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSetSendPeriod
// lua: Sgext.ChallengetSetSendPeriod()
// Indicates the period until the next challenge
// Returns:
//   nothing
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSetSendPeriod(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    UINT64    qwTicks;

    //
    // -1 Param -> new period
    //
    if (lua_gettop(pLuaState) < 1)
    {
        return luaL_error(
            pLuaState,
            "SetSendPeriod(period) - too few arguments"
            );
    }
    qwTicks = (UINT64) luaL_checknumber( pLuaState, -1 );

    // Let the world know
    TraceSz(
        ChalTrace,
        "[%08lX] Chal id 0x%X - New Send %ds ",
        pSpiInfo->_dwSpiRecv,
        pSpiInfo->_dwLuaChalCodeId,
        (DWORD) qwTicks
        );

    //
    // Set the new selected challenge
    //
    SgLuaChalStateSetCustomSendTicks(pSpiInfo, (DWORD) qwTicks);

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSetTimeoutPeriod
// lua: Sgext.ChallengetSetTimeoutPeriod()
// Indicates the period until the challenge timeout
// Returns:
//   nothing
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSetTimeoutPeriod(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    UINT64    qwTicks;

    //
    // -1 Param -> new period
    //
    if (lua_gettop(pLuaState) < 1)
    {
        return luaL_error(
            pLuaState,
            "SetTimeoutPeriod(period) - too few arguments"
            );
    }
    qwTicks = (UINT64) luaL_checknumber( pLuaState, -1 );

    // Let the world know
    TraceSz(
        ChalTrace,
        "[%08lX] Chal id 0x%X - New Timeout %ds ",
        pSpiInfo->_dwSpiRecv,
        pSpiInfo->_dwLuaChalCodeId,
        (DWORD) qwTicks
        );

    //
    // Set the new selected challenge
    //
    SgLuaChalStateSetCustomTimeoutTicks(pSpiInfo, (DWORD) qwTicks);

    //
    // Nothing returned
    //
    return 0;
}

// -----------------------------------------------------------------------------
// Sgl_ChallengetSyncMode
// lua: Sgext.ChallengetSyncMode()
// Returns whether or not the challenge should be in async mode
// Returns:
//   integer
// -----------------------------------------------------------------------------
static int Sgl_ChallengeSyncMode(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    DWORD     state        = SgLuaChalStateAsync( pSpiInfo );

    //
    // Push whether or not this is an sync mode challenge
    //
    lua_pushboolean(pLuaState, state ? 0 : 1 );

    //
    // returning 1 argument on the stack
    //
    return 1;
}

// This is the table of extensions. The left column is the name of the API as
// it's registered in lua. The right column is the corresponding C api.
static const luaL_Reg g_SgLuaChallenge[] = {
    {"AsyncMode",        Sgl_ChallengeAsyncMode},
    {"BlockForSpi",      Sgl_ChallengeBlock},
    {"GetIdFromSpi",     Sgl_ChallengeGetIdFromSpi},
    {"GetParamId",       Sgl_ChallengeGetParamId},
    {"KickForSpi",       Sgl_ChallengeKick},
    {"Log",              Sgl_ChallengeLog},
    {"SetEnable",        Sgl_ChallengeSetEnable},
    {"SetIdForSpi",      Sgl_ChallengeSetIdForSpi},
    {"SetParamId",       Sgl_ChallengeSetParamId},
    {"SetResendPeriod",  Sgl_ChallengeSetResendPeriod},
    {"SetSendPeriod",    Sgl_ChallengeSetSendPeriod},
    {"SetTimeoutPeriod", Sgl_ChallengeSetTimeoutPeriod},
    {"SyncMode",         Sgl_ChallengeSyncMode},
    {NULL,               NULL}
};

// -----------------------------------------------------------------------------
// SgLuaChalRegister
// Register lua challenge extensions
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// -----------------------------------------------------------------------------
void SgLuaChalRegister(lua_State* pLuaState)
{
    luaL_register(pLuaState, "Chal", g_SgLuaChallenge);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgllog.cpp ===
// -----------------------------------------------------------------------------
// sgllog.cpp
//
// SG Lua Logging extension
//
// Xbox Security Gateway
//
// Copyright (C) Microsoft Corporation
// -----------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

int Sgl_Log( lua_State * pLuaState )
{

    //
    // Make sure we have a spi, otherwise we can't deal with this message
    //

    CSpiInfo * pSpiInfo = SgLuaGetSpiInfo( pLuaState, FALSE );
    if (pSpiInfo == NULL)
    {
        return 0;
    }

    //
    // Get the message to print as a string
    //

    const char * pTraceMsg = lua_tostring( pLuaState, 1 );

    //
    // Was there something to print?
    //

    if (pTraceMsg != NULL)
    {
        //
        // Log the message
        //

        SgIndicateSgSvcClient(
            pSpiInfo,
            SGSVC_TYPE_CLIENT_LOGLUA,
            NULL,
            (PVOID) pTraceMsg
            );
    }

    //
    // No arguments returned
    //

    return 0;
}

//
// This is the table of extensions. The left column is the name of the API as
// it is registered in LUA. The right column is the corresponding C api.
// This table is NULL terminated.
//

static const luaL_Reg g_SgLuaLog[] = {
    { "log",  Sgl_Log },
    { NULL,   NULL }
};

// -----------------------------------------------------------------------------
// SgLuaLogRegister
// Register LUA Log extensions for the SG
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// -----------------------------------------------------------------------------

void SgLuaLogRegister( lua_State * pLuaState )
{
    //
    // Register functions as globals (no module / namespace )
    //

    lua_pushvalue(pLuaState, LUA_GLOBALSINDEX );
    luaL_register(pLuaState, NULL, g_SgLuaLog );
    lua_pop(pLuaState, 2 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglfilter.cpp ===
// ---------------------------------------------------------------------------------------
// sglspi.cpp
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// globals from sgrecv.cpp
extern DWORD g_dwAesMinClientVersionXbox360; // Minimum client version for Xbox360 that supports AES and NULL ciphers
extern DWORD g_dwAesMinClientVersionPc;      // Minimum client version for PC that supports AES and NULL ciphers

// ---------------------------------------------------------------------------------------
// Sgl_FilterBlock
// lua: Sgext.FilterBlock
// Block/Kick the client corresponding to the attached CSpiInfo
// ---------------------------------------------------------------------------------------
static int Sgl_FilterBlock(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo     = SgLuaGetSpiInfo(pLuaState);
    pSpiInfo->_dwSpiFlags |= SPIFLAG_BLOCK;
    
    if (pSpiInfo->_qwTickKeyEx2 != 0)
    {
        // Key exchange has completed, so kill the session.
        SgSpiInfoKick(pSpiInfo, SECMSG_DELETE_KILL, SPIDEL_BLOCK2);
    }

    // Perfdata
    SgPerfdataInterlockedInc( FilterKick );

    return 0;
}

// ---------------------------------------------------------------------------------------
// Sgl_Setcipher
// lua: Sgext.FilterSetCipher
// Override the SG's decision on which cipher to use for XSP. Valid values are 0=des, 
// 1=des3, 2=aes, 3=null. It's really intended only for setting the NULL cipher.
// ---------------------------------------------------------------------------------------
static int Sgl_FilterSetCipher(lua_State* pLuaState)
{
    // Argument check
    if (lua_gettop(pLuaState) != 1)
    {
        return luaL_error(pLuaState,"SetCipher(<cipher>) - incorrect arguments");
    }

    // @@@64 lua_Integer is a ptrdiff_t, which is either 32 or 64 bits. That means the 
    // size of a LUA integer changes depending on your platform. This seems dangerous.
    UINT      uiCipher        = (UINT)luaL_checkinteger(pLuaState, 1);
    CSpiInfo* pSpiInfo        = SgLuaGetSpiInfo(pLuaState);
    UINT      cbKeyCryptOld   = pSpiInfo->_cbKeyCrypt;
    DWORD     clientVersion   = pSpiInfo->_AuthData.GetClientVersion();
    BYTE      platType        = pSpiInfo->_AuthData.GetPlatform();
    BOOL      fSupportsXspV2  = 
        ((platType == XPLT_XBOX360 && clientVersion >= g_dwAesMinClientVersionXbox360) ||
         (platType == XPLT_PC      && clientVersion >= g_dwAesMinClientVersionPc));

    // Have we applied a filter already?
    if (pSpiInfo->_fLuaFilterKeyEx)
    {
        // Not allowed to change the cipher after a key exchange. All kinds of things will 
        // break on both the client and server.
        return 0;
    }

    switch (uiCipher)
    {
    case XC_SERVICE_DES_CIPHER:
        pSpiInfo->_cbKeyCrypt = XC_SERVICE_DES_KEYSIZE;
        SgPerfdataInterlockedInc( FilterSetDES );
        break;
    case XC_SERVICE_DES3_CIPHER:
        pSpiInfo->_cbKeyCrypt = XC_SERVICE_DES3_KEYSIZE;
        SgPerfdataInterlockedInc( FilterSetDES3 );
        break;
    case XC_SERVICE_AES_CIPHER:
        if (fSupportsXspV2)
        {
            pSpiInfo->_cbKeyCrypt = XC_SERVICE_AES_KEYSIZE;
            SgPerfdataInterlockedInc( FilterSetAES );
        }
        break;
    case XC_SERVICE_NULL_CIPHER:
        if (fSupportsXspV2)
        {
            pSpiInfo->_cbKeyCrypt = XC_SERVICE_NULL_KEYSIZE;
            SgPerfdataInterlockedInc( FilterSetNULL );
        }
        break;
    }
        
    TraceSz(LuaScript, "[%08lX] FilterSetCipher: changed keylength from %d to %d (xspv2:%d)",
             pSpiInfo->_dwSpiRecv, cbKeyCryptOld, pSpiInfo->_cbKeyCrypt, fSupportsXspV2);
    
    // no return values
    return 0;
}
    
// ---------------------------------------------------------------------------------------
// Sgl_FilterGetServiceAuthorized
// lua: Filter.GetServiceAuthorized(serviceId)
// Returns boolean indicating whether the given service id is authorized for this client.
// Returns:
//   boolean
// ---------------------------------------------------------------------------------------
static int Sgl_FilterGetServiceAuthorized(lua_State* pLuaState)
{
    // Argument check
    if (lua_gettop(pLuaState) != 1)
    {
        return luaL_error(pLuaState,"GetServiceAuthorized(<serviceId>) - incorrect number of arguments");
    }

    double dServiceId = luaL_checknumber(pLuaState, 1);
    if (dServiceId > 0xFFFFFFFF)
    {
        return luaL_error(pLuaState, "GetServiceAuthorized(<serviceId>) - invalid argument");
    }

    DWORD     dwServiceId   = (DWORD)dServiceId;
    CSpiInfo* pSpiInfo      = SgLuaGetSpiInfo(pLuaState);
    BOOL      bAuthorized   = 0;

    // Authorized?

    ServiceMask const mask = SgSvcInfoMask(dwServiceId);
    bAuthorized = pSpiInfo->_svcMask.HasAnyBits(mask);

    lua_pushboolean(pLuaState, bAuthorized);
    return 1;
}

    
// ---------------------------------------------------------------------------------------
// Sgl_FilterSetServiceAuthorized
// lua: Filter.SetServiceAuthorized(serviceId)
// Overrides whether a given service is authorized for this client or not. Extremely 
// dangerous to use this to add a service, less so to remove a service.
// Returns:
//   boolean indicating previous authorization state of service
// ---------------------------------------------------------------------------------------
static int Sgl_FilterSetServiceAuthorized(lua_State* pLuaState)
{
    // Argument check
    if (lua_gettop(pLuaState) != 2)
    {
        return luaL_error(pLuaState,"SetServiceAuthorized(<serviceId>, <authorized>) - incorrect number of arguments");
    }

    // LUA uses signed numbers. lua_integer can thus only represent 31 bits, and when you 
    // use that 32nd bit, lua truncates at 0x80000000 instead of going negative, as 
    // expected. that is why we use lua_number (a double), for services like 0xFnnnnnnn.

    double dServiceId = luaL_checknumber(pLuaState, 1);
    if (dServiceId > 0xFFFFFFFF)
    {
        return luaL_error(pLuaState, "SetServiceAuthorized(<serviceId>, <authorized>) - invalid arguments");
    }

    DWORD     dwServiceId   = (DWORD)dServiceId;
    BOOL      bAuthorized   = !!luaL_checkinteger(pLuaState, 2);
    CSpiInfo* pSpiInfo      = SgLuaGetSpiInfo(pLuaState);

    ServiceMask   svcMask   = SgSvcInfoMask(dwServiceId);
    BOOL const bWasAuthorized = pSpiInfo->_svcMask.HasAllBits(svcMask);

    if (bAuthorized)
    {
        pSpiInfo->_svcMask |= svcMask;
    }
    else
    {
        pSpiInfo->_svcMask &= ~svcMask;
    }

    lua_pushboolean(pLuaState, bWasAuthorized);
    return 1;
}

// This is the table of extensions. The left column is the name of the API as it's 
// registered in lua. The right column is the corresponding C api.
static const luaL_Reg g_SgLuaFilter[] = {
    {"Block",                   Sgl_FilterBlock},
    {"SetCipher",               Sgl_FilterSetCipher},
    {"GetServiceAuthorized",    Sgl_FilterGetServiceAuthorized},
    {"SetServiceAuthorized",    Sgl_FilterSetServiceAuthorized},
    {NULL,           NULL}
};

// ---------------------------------------------------------------------------------------
// SgLuaFilterRegister
// Register lua filter extensions
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaFilterRegister(lua_State* pLuaState)
{
    luaL_register(pLuaState, "Filter", g_SgLuaFilter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglperf.cpp ===
// -----------------------------------------------------------------------------
// sglperf.cpp
//
// SG Lua Perf extension
//
// Xbox Security Gateway
//
// Copyright (C) Microsoft Corporation
// -----------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

int Sgl_PerfDecrement( lua_State * pLuaState )
{

    //
    // Make sure we have a spi, otherwise we can't deal with this message
    //

    CSpiInfo * pSpiInfo = SgLuaGetSpiInfo( pLuaState, FALSE );
    if (pSpiInfo == NULL)
    {
        return 0;
    }

    //
    // Get the counter name that we need to decrement
    //

    const char * pCounter = lua_tostring( pLuaState, 1 );

    //
    // Decrement the appropriate counter
    //

    if (stricmp(pCounter, "active" ) == 0) 
    {
        SgPerfdataInterlockedDec( ChalActive );
    }
    else if (stricmp(pCounter, "retry") == 0)
    {
        SgPerfdataInterlockedDec( ChalRetry );
    }
    else if (stricmp(pCounter, "retryack1") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryAck1 );
    }
    else if (stricmp(pCounter, "retryack2") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryAck2 );
    }
    else if (stricmp(pCounter, "retryack3") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryAck3 );
    }
    else if (stricmp(pCounter, "retryack4") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryAck4 );
    }
    else if (stricmp(pCounter, "retryack5") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryAck5 );
    }
    else if (stricmp(pCounter, "retryresp1") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryResp1 );
    }
    else if (stricmp(pCounter, "retryresp2") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryResp2 );
    }
    else if (stricmp(pCounter, "retryresp3") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryResp3 );
    }
    else if (stricmp(pCounter, "retryresp4") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryResp4 );
    }
    else if (stricmp(pCounter, "retryresp5") == 0) 
    {
        SgPerfdataInterlockedDec( ChalRetryResp5 );
    }

    //
    // No arguments returned
    //

    return 0;
}

int Sgl_PerfIncrement( lua_State * pLuaState )
{

    //
    // Make sure we have a spi, otherwise we can't deal with this message
    //

    CSpiInfo * pSpiInfo = SgLuaGetSpiInfo( pLuaState, FALSE );
    if (pSpiInfo == NULL)
    {
        return 0;
    }

    //
    // Get the counter name that we need to increment
    //

    const char * pCounter = lua_tostring( pLuaState, 1 );

    //
    // Increment the appropriate counter
    //

    if (stricmp(pCounter, "active" ) == 0) 
    {
        SgPerfdataInterlockedInc( ChalActive );
    }
    else if (stricmp(pCounter, "retry") == 0)
    {
        SgPerfdataInterlockedInc( ChalRetry );
    }
    else if (stricmp(pCounter, "retryack1") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryAck1 );
    }
    else if (stricmp(pCounter, "retryack2") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryAck2 );
    }
    else if (stricmp(pCounter, "retryack3") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryAck3 );
    }
    else if (stricmp(pCounter, "retryack4") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryAck4 );
    }
    else if (stricmp(pCounter, "retryack5") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryAck5 );
    }
    else if (stricmp(pCounter, "retryresp1") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryResp1 );
    }
    else if (stricmp(pCounter, "retryresp2") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryResp2 );
    }
    else if (stricmp(pCounter, "retryresp3") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryResp3 );
    }
    else if (stricmp(pCounter, "retryresp4") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryResp4 );
    }
    else if (stricmp(pCounter, "retryresp5") == 0) 
    {
        SgPerfdataInterlockedInc( ChalRetryResp5 );
    }

    //
    // No arguments returned
    //

    return 0;
}

void SgLuaPerfReset()
{
    // Best Effort to reset the counters to 0
    SgPerfdataSet( ChalActive, 0 );
    SgPerfdataSet( ChalRetry, 0 );
    SgPerfdataSet( ChalRetryAck1, 0 );
    SgPerfdataSet( ChalRetryAck2, 0 );
    SgPerfdataSet( ChalRetryAck3, 0 );
    SgPerfdataSet( ChalRetryAck4, 0 );
    SgPerfdataSet( ChalRetryAck5, 0 );
    SgPerfdataSet( ChalRetryResp1, 0 );
    SgPerfdataSet( ChalRetryResp2, 0 );
    SgPerfdataSet( ChalRetryResp3, 0 );
    SgPerfdataSet( ChalRetryResp4, 0 );
    SgPerfdataSet( ChalRetryResp5, 0 );
}

//
// This is the table of extensions. The left column is the name of the API as
// it is registered in LUA. The right column is the corresponding C api.
// This table is NULL terminated.
//

static const luaL_Reg g_SgLuaPerf[] = {
    { "Increment",  Sgl_PerfIncrement },
    { "Decrement",  Sgl_PerfDecrement },
    { NULL,   NULL }
};

// -----------------------------------------------------------------------------
// SgLuaLogRegister
// Register LUA Log extensions for the SG
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// -----------------------------------------------------------------------------

void SgLuaPerfRegister( lua_State * pLuaState )
{
    luaL_register(pLuaState, "Perf", g_SgLuaPerf);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglqword.cpp ===
// ---------------------------------------------------------------------------------------
// sglqword.cpp
//
// Lua extension for 64-bit unsigned numbers (Qword)
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

#define QWORD_METATABLE "SG.Qword"

// ---------------------------------------------------------------------------------------
// SgLuaQwordCheck
// Checks if an argument in the stack is a Qword user-data and return the UIN64 value. An error will 
// be thrown if the argument is not a Qword user-data.
//   - pLuaState : pointer to lua_State
//   - narg: stack index of the Qword user-data argument
// Returns:
//   The UINT64 value of the Qword user-data
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
UINT64 SgLuaQwordCheck(lua_State* pLuaState, int narg)
{
    UINT64* pQword = (UINT64*) luaL_checkudata(pLuaState, narg, QWORD_METATABLE);
    return *pQword;
}

// ---------------------------------------------------------------------------------------
// SgLuaQwordInitialize
// Lua extension for pushing a new Qword onto the stack
// Where:
//   value is the 64 bit number to initialize the QWord to
// ---------------------------------------------------------------------------------------
int SgLuaQwordInitialize(lua_State* pLuaState, UINT64 value)
{
    //
    // Allocate user data and set the Qword metatable 
    //
    // @@@64 Code review this
    UINT64* pQword = (UINT64*) lua_newuserdata(pLuaState, sizeof(UINT64));
    luaL_getmetatable(pLuaState, QWORD_METATABLE);
    lua_setmetatable(pLuaState, -2);

    //
    // Set the value
    //
    *pQword = value;

    //
    // Qword user-data on the stack
    //
    return 1;
}

// ---------------------------------------------------------------------------------------
// SgLuaQwordPresent
// Lua extension for determining if the entry at a particular stack location is
// is a qword or not
//    - pLuaState: point to lua_State
//    - narg: stack index of the potential QWord user-data
// Return:
//   true if QWORD, false otherwise
// ---------------------------------------------------------------------------------------
BOOL SgLuaQwordPresent(lua_State* pLuaState, int narg)
{
    void *userdata = lua_touserdata(pLuaState, narg);

    if (userdata != NULL)
    {
        if (lua_getmetatable(pLuaState,narg))
        {
            BOOL bResult;

            lua_getfield(pLuaState, LUA_REGISTRYINDEX, QWORD_METATABLE );
            bResult = lua_rawequal(pLuaState,-1, -2);
            lua_pop(pLuaState, 2);

            return bResult;
        }
    }
    return FALSE;
}


// ---------------------------------------------------------------------------------------
// SgLuaQwordNew
// Lua extension for: Qword.new(<qword-string>)
// Where:
//   qword-string: is a string with the unsigned 64-bit number representation. The number 
//   can be specified in decimal or hexadecimal with the 0x prefix.
// Examples:
//   q = Qword.new('1')
//   q = Qword.new('0xdeadbeefcafebabe')
// ---------------------------------------------------------------------------------------
static int SgLuaQwordNew(lua_State* pLuaState)
{
    UINT64 value = 0;

    // One parameter expected

    if(lua_gettop(pLuaState) == 0)
    {
        luaL_error(pLuaState, "Qword.new: called with 0 arguments");
        return 0;
    }

    // Must be a string

    int luaType = lua_type(pLuaState, 1);

    if(luaType != LUA_TSTRING)
    {
        luaL_error(pLuaState, "Qword.new: argument is not a string");
        return 0;
    }

    // Convert string value to number

    const char* pValueStr = luaL_checkstring(pLuaState, 1);
    char* pEndPtr = NULL;

    value = _strtoui64(pValueStr, &pEndPtr, 0);

    if(!pEndPtr || *pEndPtr != '\0')
    {
        luaL_error(pLuaState, "Qword.new: %s cannot be converted to a number", pValueStr);
        return 0;
    }

    // Put the Qword onto the stack
    return SgLuaQwordInitialize(pLuaState, value );
}

// ---------------------------------------------------------------------------------------
// SgLuaQwordToString
// Lua extension for converting a Qword user-data to a string
// Examples:
//   q = Qword.new('1')
//   print(q) -- conversion happens implicitly
// ---------------------------------------------------------------------------------------
static int SgLuaQwordToString(lua_State* pLuaState)
{
    UINT64 value = SgLuaQwordCheck(pLuaState, 1);
    
    // unfortunatelly lua_pushfstring doesn't support 64-bit numbers. While we could 
    // still use it, it would be a bit hacky. We're going to use TLocalStr instead. While 
    // it's an object we're declaring in the stack, there are no resources being 
    // allocated and the destructor is not important.
    
    TLocalStr<30> str;
    str.Format("0x%I64x", value);
    
    // Push the formated number on the stack
    
    lua_pushstring(pLuaState, str.cstr());

    return 1;
}

// ---------------------------------------------------------------------------------------
// SgLuaQwordOpEq
// Lua extension for comparing Qword user-datas
// Examples:
//   print(Qword.new('1') == Qword.new('1')) -- true
//   print(Qword.new('1') == Qword.new('2')) -- false
//   print(Qword.new('1') ~= Qword.new('1')) -- false
//   print(Qword.new('1') ~= Qword.new('2')) -- true
// ---------------------------------------------------------------------------------------
static int SgLuaQwordOpEq(lua_State* pLuaState)
{
    UINT64 value1 = SgLuaQwordCheck(pLuaState, 1);
    UINT64 value2 = SgLuaQwordCheck(pLuaState, 2);

    lua_pushboolean(pLuaState, value1 == value2);

    return 1;
}

// ---------------------------------------------------------------------------------------
// SgLuaQwordHidword
// Returns the high dword of a Qword user-data as a lua number.
// Lua extension for: <qword>:Hidword()
// Where:
//   qword: is a Qword user-data created with Qword.new()
// Examples:
//   q = Qword.new('0xdeadbeefcafebabe')
//   print(string.format('0x%x', q:Hidword())) -- 0xdeadbeef
// ---------------------------------------------------------------------------------------
static int SgLuaQwordHidword(lua_State* pLuaState)
{
    UINT64 value = SgLuaQwordCheck(pLuaState, 1);
    lua_pushnumber(pLuaState, (lua_Number) ((value >> 32) & 0xFFFFFFFF));
    return 1;
}

// ---------------------------------------------------------------------------------------
// SgLuaQwordLodword
// Returns the low dword of a Qword user-data as a lua number.
// Lua extension for: <qword>:Lodword()
// Where:
//   qword: is a Qword user-data created with Qword.new()
// Examples:
//   q = Qword.new('0xdeadbeefcafebabe')
//   print(string.format('0x%x', q:Lodword())) -- 0xcafebabe
// ---------------------------------------------------------------------------------------
static int SgLuaQwordLodword(lua_State* pLuaState)
{
    UINT64 value = SgLuaQwordCheck(pLuaState, 1);
    lua_pushnumber(pLuaState, (lua_Number) (value & 0xFFFFFFFF));
    return 1;
}

// Qword static methods
static const struct luaL_reg g_SgLuaQwordF[] = {
    { "new", SgLuaQwordNew },
    { NULL, NULL }
};

// Qword instance methods
static const struct luaL_reg g_SgLuaQwordM[] = {
    { "__tostring", SgLuaQwordToString },
    { "__eq", SgLuaQwordOpEq },
    { "Hidword", SgLuaQwordHidword },
    { "Lodword", SgLuaQwordLodword },
    { NULL, NULL }
};

// ---------------------------------------------------------------------------------------
// SgLuaQwordRegister
// Registers the Qword extension
//   - pLuaState: pointer to pLuaState
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaQwordRegister(lua_State* pLuaState)
{
    // Create a new metatable to uniquely identify a qword

    luaL_newmetatable(pLuaState, QWORD_METATABLE);
    
    // Set the metatable __index to itself, so that we can define methods in this 
    // metatable to make it work like an object. This is equivalent to:
    // mt.__index = mt
    // Where mt is the metatable created above.
    
    lua_pushstring(pLuaState, "__index");
    lua_pushvalue(pLuaState, -2);
    lua_settable(pLuaState, -3);
    
    // Register Qword instance methods. These methods are called using the ':' notation 
    // on a Qword instance. For example:
    // q = Qword.new('0xFA00000000000001')
    // print(string.format('Hi: %x, Lo: %x', q:Hidword, q:Lodword))
    // The NULL in luaL_register means it will assign the methods to the table in the 
    // stack position -1 which is the metatable we just created.

    luaL_register(pLuaState, NULL, g_SgLuaQwordM);

    // Register Qword static methods. These methods are called using the Qword namespace. 
    // For example: 
    // q = Qword.new('0xFA00000000000001')
    
    luaL_register(pLuaState, "Qword", g_SgLuaQwordF);
}
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglspi.cpp ===
// ---------------------------------------------------------------------------------------
// sglspi.cpp
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// Lua registry keys
// Lua has a registry - a table where the hosting C application can write stuff to.  This
// has nothing to do with the Windows registry. The following are the keys that we use in
// that table to store our information.
// ---------------------------------------------------------------------------------------

// Stores the pointer to the CSpiInfo structure currently bound to the lua_State
#define LUA_REGISTRY_SPI            "SG_SPI"

// Stores a table indexed by dwSpiRecv which is used to to create a per Spi storage
#define LUA_REGISTRY_SPI_STORAGE    "SG_SPI_STORAGE"

// ---------------------------------------------------------------------------------------
// SgpLuaSpiStorageInit
// This function allocates a new lua table and stores it in the table
// LUA_REGISTRY_SPI_STORAGE indexed by dwSpiRecv.
//   - pLuaState: pointer to lua state
//   - pSpiInfo: pointer to the spi to create the storage for
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgpLuaSpiStorageInit(lua_State *pLuaState, CSpiInfo *pSpiInfo)
{
    // Retrieve the table where we're storing per spi storage tables

    lua_pushstring(pLuaState, LUA_REGISTRY_SPI_STORAGE);
    lua_gettable(pLuaState, LUA_REGISTRYINDEX);

    // Create a new table to for storage purposes for this Spi and store it in the
    // LUA_REGISTRY_SPI_STORAGE table indexed by pSpiInfo->dwSpiRecv.

    lua_pushnumber(pLuaState, pSpiInfo->_dwSpiRecv);
    lua_newtable(pLuaState);
    lua_settable(pLuaState, -3);

    // Pop off the LUA_REGISTRYINDEX table
    lua_pop( pLuaState, 1);
}

// ---------------------------------------------------------------------------------------
// SgLuaSpiStorageTerm
// Release a Spi's storage in Lua. Must be called when the Spi is being deleted.
//   - pLuaState: pointer to lua_State
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
int SgLuaSpiStorageTerm(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = (CSpiInfo*) lua_touserdata(pLuaState, 1);

    // Retrieve the table where we're storing per spi storage tables

    lua_pushstring(pLuaState, LUA_REGISTRY_SPI_STORAGE);
    lua_gettable(pLuaState, LUA_REGISTRYINDEX);

    // Set this spi's entry value to nil - effectively releasing everything that was
    // stored in that spot.

    lua_pushnumber(pLuaState, pSpiInfo->_dwSpiRecv);
    lua_pushnil(pLuaState);
    lua_settable(pLuaState, -3);

    return 0;
}

// ---------------------------------------------------------------------------------------
// SgLuaSetSpiInfo
// Set the CSpiInfo in the lua_State's registry. This allows other apis to retrieve it
// using SgLuaGetSpiInfo.
//  - pLuaState : pointer to lua_State
//  - pSpiInfo : pointer to CSpiInfo to store in the lua_State's registry
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaSetSpiInfo(lua_State* pLuaState, CSpiInfo* pSpiInfo)
{
    lua_pushstring(pLuaState, LUA_REGISTRY_SPI);

    if(pSpiInfo)
    {
        lua_pushlightuserdata(pLuaState, (void*) pSpiInfo);
    }
    else
    {
        lua_pushnil(pLuaState);
    }

    lua_settable(pLuaState, LUA_REGISTRYINDEX);
}

// ---------------------------------------------------------------------------------------
// SgLuaGetSpiInfo
// Utility function to retrieve the CSpiInfo pointer from the lua registry.
//   - pLuaState: pointer to lua state
//   - throwOnError: if TRUE, this function will throw a lua error if the Spi was not set
//   for this state. If FALSE, it doesn't throw and returns NULL.
// Returns:
//   - Pointer to CSpiInfo.
// ---------------------------------------------------------------------------------------
CSpiInfo* SgLuaGetSpiInfo(lua_State* pLuaState, BOOL throwOnError)
{
    CSpiInfo* pSpiInfo;

    lua_pushstring(pLuaState, LUA_REGISTRY_SPI);
    lua_gettable(pLuaState, LUA_REGISTRYINDEX);
    pSpiInfo = (CSpiInfo*) lua_touserdata(pLuaState, -1);
    lua_pop(pLuaState, 1);

    if (!pSpiInfo && throwOnError)
    {
        luaL_error(pLuaState, "CSpiInfo was not set for this lua_State");
    }

    return pSpiInfo;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetAuthData3
// lua: Sgext.SpiGetAuthData3
// Retrieves the whole SPI (in read-only format)
// Returns:
//   buffer
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetAuthData3(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    return SgLuaBufferInitialize( pLuaState, (BYTE *) &(pSpiInfo->_AuthData), sizeof(CAuthData3), TRUE, TRUE );
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetAuthData3Table
// lua: Sgext.SpiGetAuthData3Table
// Retrieves the whole SPI as a table
// Returns:
//   buffer
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetAuthData3Table(lua_State* pLuaState)
{
    DWORD     i;
    DWORD     j;
    DWORD     k;
    DWORD     mask;
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    char      buffer[28];
    int       result;

    // Create the new table
    lua_newtable(pLuaState);

    // Set the version
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.wAuthDataVersion );
    lua_setfield(pLuaState, -2, "Version" );

    // Set the size
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.wAuthDataSize );
    lua_setfield(pLuaState, -2, "Size" );

    // Set the client version
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wMajorVersion );
    lua_setfield(pLuaState, -2, "Major" );
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wMinorVersion );
    lua_setfield(pLuaState, -2, "Minor" );
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wBuildNumber );
    lua_setfield(pLuaState, -2, "Build" );
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wQFENumber );
    lua_setfield(pLuaState, -2, "Qfe" );

    // Set the Title Information
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwTitleID );
    lua_setfield(pLuaState, -2, "TitleId" );
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwTitleVersion );
    lua_setfield(pLuaState, -2, "TitleVersion" );
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwTitleRegion );
    lua_setfield(pLuaState, -2, "TitleRegion" );

    // Set the console region
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwConsoleRegion );
    lua_setfield(pLuaState, -2, "ConsoleRegion" );

    // Set the MediaId
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwMediaID );
    lua_setfield(pLuaState, -2, "MediaId" );

    // Set the LanguageId
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.wLanguageID );
    lua_setfield(pLuaState, -2, "LanguageId" );

    // Set the AuthFlags
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwAuthDataFlags );
    lua_setfield(pLuaState, -2, "AuthFlags" );

    // Convert some of those flags to easy to check booleans
    result = 0;
    if (pSpiInfo->_AuthData.GetPlatform() == XPLT_XBOX1 &&
        !(pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsXbox" );

    result = 0;
    if (pSpiInfo->_AuthData.GetPlatform() == XPLT_XBOX360 &&
        !(pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsXbox360" );

    result = 0;
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsXboxEmulation" );

    result = 0;
    if (pSpiInfo->_AuthData.GetPlatform() == XPLT_PC)
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsPc" );

    result = 0;
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISDEVKIT) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsDevkit" );

    result = 0;
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISTESTKIT) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsTestkit" );

    result = 1;
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISDEVKIT) )
    {
        result = 0;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsRetail" );

    result = 0;
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsLimited" );

    result = 0;
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE) )
    {
        result = 1;
    }
    lua_pushboolean( pLuaState, result );
    lua_setfield(pLuaState, -2, "IsBetaMachine" );

    // Create the Privilege Table
    lua_newtable(pLuaState);

    // Do the Multiplayer Privileges first
    for (j = 0; j < sizeof(DWORD) * 8; j++)
    {
        if ((pSpiInfo->_AuthData.dwMachinePrivileges[0] & BIT(j)) == 0)
        {
            continue;
        }

        // Create the proper name for this privilege element
        sprintf( buffer, "%d", (XONLINE_MAX_BASE_SERVICES_ID + j) );
        lua_pushboolean( pLuaState, 1 );
        lua_setfield(pLuaState, -2, buffer );
    }

    // Now do each of the Per User privileges, but only if a user is logged in
    // We have to do this expensive lookup because we don't actually store
    // the least common privileges in the spi anymore. We only stored there
    // in CAuthData3 and we want to preserve the ability to see those effective
    // privileges
    if (pSpiInfo->_AuthData.users[0].qwUserID != 0 ||
        pSpiInfo->_AuthData.users[1].qwUserID != 0 ||
        pSpiInfo->_AuthData.users[2].qwUserID != 0 ||
        pSpiInfo->_AuthData.users[3].qwUserID != 0)
    {
        for (k = 0; k < XONLINE_NUM_USER_PRIVILEGES_DWORDS; ++k)
        {
            mask = 0xFFFFFFFF;
            for (j = 0; j < XONLINE_MAX_LOGON_USERS; ++j)
            {
                if (pSpiInfo->_AuthData.users[j].qwUserID == 0)
                {
                    continue;
                }
                mask &= pSpiInfo->_AuthData.dwUserPrivileges[j][k];
            }
            if (mask == 0)
            {
                continue;
            }

            // Determine which bits are set
            for (j = 0; j < sizeof(DWORD) * 8; j++)
            {
                if ((mask & BIT(j)) == 0)
                {
                    continue;
                }

                // Create the proper name for this privilege element
                sprintf( buffer, "%d", (XONLINE_MAX_MACHINE_PRIVILEGES_ID + (k * sizeof(DWORD) * 8) + j) );
                lua_pushboolean( pLuaState, 1 );
                lua_setfield(pLuaState, -2, buffer );
            }
        }
    }

    // Set the Privilege Table
    lua_setfield(pLuaState, -2, "Privileges" );

    // Set the xboxid
    SgLuaQwordInitialize( pLuaState, pSpiInfo->_AuthData.qwXboxID );
    lua_setfield(pLuaState, -2, "XboxId" );

    // Create the User Table
    lua_newtable(pLuaState);
    for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
    {
        if (pSpiInfo->_AuthData.users[i].qwUserID == 0)
        {
            continue;
        }

        // Create the new table for this user
        lua_newtable(pLuaState);

        // Set the interesting bits
        lua_pushnumber( pLuaState, pSpiInfo->_AuthData.users[i].dwUserFlags );
        lua_setfield(pLuaState, -2, "UserFlags" );

        // Set the interesting bits
        lua_pushnumber(
            pLuaState,
            XOnlineUserCountryId( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "CountryId" );

        // Guest number
        lua_pushnumber(
            pLuaState,
            XOnlineUserGuestNumber( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "GuestId" );

        // VoiceAllowed
        lua_pushboolean(
            pLuaState,
            XOnlineIsUserVoiceAllowed( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "IsVoiceAllowed");

        // PurchaseAllowed
        lua_pushboolean(
            pLuaState,
            XOnlineIsUserPurchaseAllowed( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "IsPurchaseAllowed");

        // NicknameAllowed
        lua_pushboolean(
            pLuaState,
            XOnlineIsUserNicknameAllowed( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "IsNicknameAllowed");

        // SharedContentAllowed
        lua_pushboolean(
            pLuaState,
            XOnlineIsUserSharedContentAllowed( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "IsSharedContentAllowed");

        // NoShowRating
        lua_pushnumber(
            pLuaState,
            XOnlineUserNoShowRating( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "NoShowRating");

        // DisconnectRating
        lua_pushnumber(
            pLuaState,
            XOnlineUserDisconnectRating( pSpiInfo->_AuthData.users[i].dwUserFlags )
            );
        lua_setfield(pLuaState, -2, "DisconnectRating");

        // Set the userid
        SgLuaQwordInitialize( pLuaState, pSpiInfo->_AuthData.users[i].qwUserID );
        lua_setfield(pLuaState, -2, "UserId" );

        // Trust Vector
        lua_pushnumber( pLuaState, pSpiInfo->_AuthData.afltTrustFactor[i] );
        lua_setfield(pLuaState, -2, "TrustFactor" );

        // Create the Privilege Table
        lua_newtable(pLuaState);
        for (k = 0; k < XONLINE_NUM_USER_PRIVILEGES_DWORDS; ++k)
        {
            // Look at each bit in the > 128 range and see which ones are set
            for (j = 0; j < sizeof(DWORD) * 8; j++)
            {
                if ((pSpiInfo->_AuthData.dwUserPrivileges[i][k] & BIT(j)) == 0)
                {
                    continue;
                }

                // Create the proper name for this privilege element
                sprintf( buffer, "%d", (XONLINE_MAX_MACHINE_PRIVILEGES_ID + (k * sizeof(DWORD) * 8) + j) );
                lua_pushboolean( pLuaState, 1 );
                lua_setfield(pLuaState, -2, buffer );
            }
        }
        lua_setfield(pLuaState, -2, "Privileges" );

        // Set the User table
        sprintf( buffer, "%d", i );
        lua_setfield(pLuaState, -2, buffer );
    }

    // Set the Users Table
    lua_setfield(pLuaState, -2, "Users" );

    // Services
    lua_newtable(pLuaState);
    for (i = 0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
    {
        if (pSpiInfo->_AuthData.dwExtendedServices[i] == 0)
        {
            continue;
        }

        // Set the services
        sprintf( buffer, "%d", pSpiInfo->_AuthData.dwExtendedServices[i] );
        lua_pushboolean( pLuaState, 1 );
        lua_setfield(pLuaState, -2, buffer );
    }
    for (i = 0; i < XONLINE_NUM_BASE_SERVICES_DWORDS; i++)
    {
        // Look at each bit in the < 128 range and see which ones are set
        for (j = 0; j < sizeof(DWORD) * 8; j++)
        {
            if ((pSpiInfo->_AuthData.dwBaseServices[i] & BIT(j)) == 0)
            {
                continue;
            }

            // Create the proper name for this privilege element
            sprintf( buffer, "%d", ((i * sizeof(DWORD) * 8) + j) );
            lua_pushboolean( pLuaState, 1 );
            lua_setfield(pLuaState, -2, buffer );
        }

    }

    // Set the Services Field
    lua_setfield(pLuaState, -2, "Services" );

    // Create the AltTitleId table
    lua_newtable(pLuaState);
    for (i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
    {
        // Set the AltTitleId
        sprintf( buffer, "%d", i );
        lua_pushnumber( pLuaState, pSpiInfo->_AuthData.dwAltTitleID[i] );
        lua_setfield(pLuaState, -2, buffer );
    }

    // Set the AltTitleId field
    lua_setfield(pLuaState, -2, "AltTitleId" );

    return 1;
}


// ---------------------------------------------------------------------------------------
// Sgl_SpiGetClientIpAddr
// lua: Sgext.SpiGetClientIpAddr()
// Retrieves the client Ip Address as 4 numbers
// Returns:
//   buffer
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetClientIpAddr(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);

    lua_pushnumber(pLuaState, pSpiInfo->_ipaI._ab[0] );
    lua_pushnumber(pLuaState, pSpiInfo->_ipaI._ab[1] );
    lua_pushnumber(pLuaState, pSpiInfo->_ipaI._ab[2] );
    lua_pushnumber(pLuaState, pSpiInfo->_ipaI._ab[3] );
    return 4;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetClientMajor
// lua: Sgext.SpiGetClientMajor()
// Retrieves the Major version of the client
// Returns:
//   number: major-version
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetClientMajor(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wMajorVersion);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetClientMinor
// lua: Sgext.SpiGetClientMinor()
// Retrieves the Minor version of the client
// Returns:
//   number: minor-version
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetClientMinor(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wMinorVersion);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetClientBuild
// lua: Sgext.SpiGetClientBuild()
// Retrieves the Build version of the client
// Returns:
//   number: build-version
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetClientBuild(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wBuildNumber);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetClientQfe
// lua: Sgext.SpiGetClientQfe()
// Retrieves the Qfe version of the client
// Returns:
//   number: qfe-version
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetClientQfe(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.clientVersion.wQFENumber);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetConsoleRegion
// lua: Sgext.SpiGetConsoleRegion()
// Retrieves the Region of the console
// Returns:
//   number: region code
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetConsoleRegion(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwConsoleRegion);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetTitleId
// lua: Sgext.SpiGetTitleId()
// Retrieves the title id from the authdata in the attached CSpiInfo
// Returns:
//   number: title-id
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetTitleId(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwTitleID);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetTitleVersion
// lua: Sgext.SpiGetTitleVersion()
// Retrieves the title version from the authdata in the attached CSpiInfo
// Returns:
//   number: title-version
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetTitleVersion(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwTitleVersion);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetTitleRegion
// lua: Sgext.SpiGetTitleRegion()
// Retrieves the title region from the authdata in the attached CSpiInfo
// Returns:
//   number: title-region
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetTitleRegion(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    lua_pushnumber(pLuaState, pSpiInfo->_AuthData.dwTitleRegion);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetUserCountryId
// lua: Sgext.SpiGetUserCountryId(slot)
// Retrieves the CountryId from the specified slot in the authdata
//   for the attached CSpiInfo
// Returns:
//  qword.new<UserId> | nil
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetUserCountryId(lua_State* pLuaState)
{
    ULONG fromSlot;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);

    if (lua_gettop(pLuaState) <1)
    {
        return luaL_error(pLuaState, "GetUserCountryId(slot) - too few arguments");
    }

    // Argument Check
    fromSlot = luaL_checkint(pLuaState, 1);
    luaL_argcheck(
        pLuaState,
        fromSlot <= XONLINE_MAX_LOGON_USERS,
        1,
        "GetUserCountryId(slot) - no such slot"
        );

    // Is there really such a user?
    if (pSpiInfo->_AuthData.users[fromSlot].qwUserID == 0)
    {
        // No, so push nil
        lua_pushnil(pLuaState);
        return 1;
    }

    // return the user
    lua_pushnumber(
        pLuaState,
        XOnlineUserCountryId( pSpiInfo->_AuthData.users[fromSlot].dwUserFlags )
        );
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetUserId
// lua: Sgext.SpiGetUserId(slot)
// Retrieves the UserId from the specified slot in the authdata
//   for the attached CSpiInfo
// Returns:
//  qword.new<UserId> | nil
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetUserId(lua_State* pLuaState)
{
    ULONG fromSlot;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);

    if (lua_gettop(pLuaState) <1)
    {
        return luaL_error(pLuaState, "GetUserId(slot) - too few arguments");
    }

    // Argument Check
    fromSlot = luaL_checkint(pLuaState, 1);
    luaL_argcheck(
        pLuaState,
        fromSlot <= XONLINE_MAX_LOGON_USERS,
        1,
        "GetUserId(slot) - no such slot"
        );

    // Is there really such a user?
    if (pSpiInfo->_AuthData.users[fromSlot].qwUserID == 0)
    {
        // No, so push nil
        lua_pushnil(pLuaState);
        return 1;
    }

    // return the user
    return SgLuaQwordInitialize(pLuaState, pSpiInfo->_AuthData.users[fromSlot].qwUserID );
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetXboxId
// lua: Sgext.SpiGetXboxId()
// Retrieves the XboxID from the authdata in the attached CSpiInfo
// Returns:
//  qword.new<XboxId>
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetXboxId(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    return SgLuaQwordInitialize(pLuaState, pSpiInfo->_AuthData.qwXboxID );
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsXbox
// lua: Sgext.SpiIsXbox()
// Determines if the associated SPI is for an Xbox
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsXbox(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.GetPlatform() == XPLT_XBOX1 &&
        !(pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT))
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsXbox360
// lua: Sgext.SpiIsXbox360()
// Determines if the associated SPI is for an Xbox 360
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsXbox360(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.GetPlatform() == XPLT_XBOX360 &&
        !(pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT))
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsXboxEmulation
// lua: Sgext.SpiIsXboxEmulation()
// Determines if the associated SPI is for an Xbox emulation
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsXboxEmulation(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if ((pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT))
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsDevKit
// lua: Sgext.SpiIsDevKit()
// Determines if the associated SPI is for a DevKit
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsDevKit(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISDEVKIT)
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsTestKit
// lua: Sgext.SpiIsTestKit()
// Determines if the associated SPI is for TestKit
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsTestKit(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISTESTKIT)
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsPc
// lua: Sgext.SpiIsPc()
// Determines if the associated SPI is for a PC
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsPc(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.GetPlatform() == XPLT_PC)
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiIsLimited
// lua: Sgext.SpiIsLimited()
// Determines if the associated SPI is for a Limited PC
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsLimited(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE)
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}


// ---------------------------------------------------------------------------------------
// Sgl_SpiIsBetaMachine
// lua: Sgext.SpiIsBetaMachine()
// Determines if the associated SPI is for a machine marked as 'beta'
// Returns:
//   boolean: true / false
// ---------------------------------------------------------------------------------------
static int Sgl_SpiIsBetaMachine(lua_State* pLuaState)
{
    int result = 0;

    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);
    if (pSpiInfo->_AuthData.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE)
    {
        result = 1;
    }
    lua_pushboolean(pLuaState, result);
    return 1;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetStorage
// lua: Spi.GetStorage()
// Returns the Spi's private storage table
// ---------------------------------------------------------------------------------------
static int Sgl_SpiGetStorage(lua_State* pLuaState)
{
    int i;
    CSpiInfo* pSpiInfo = SgLuaGetSpiInfo(pLuaState);

    // Push the registry table onto the stack

    lua_pushstring(pLuaState, LUA_REGISTRY_SPI_STORAGE);
    lua_gettable(pLuaState, LUA_REGISTRYINDEX);

    // Attempt to do the following at most twice
    for (i = 0; i < 2; i++)
    {
        // Retrieve the table where we're storing per spi storage tables

        lua_pushnumber(pLuaState, pSpiInfo->_dwSpiRecv);
        lua_gettable(pLuaState, -2);

        // At this point, the top of the stack should be a table. If it isn't
        // then we need to create the per-spi storage

        if (lua_istable(pLuaState, -1))
        {
            // We have successfully found our element
            return 1;
        }

        // Pop the nil off the stack
        lua_pop( pLuaState, 1 );

        // Recreate the table (but only the 1st time)
        if (i == 0)
        {
            SgpLuaSpiStorageInit(pLuaState, pSpiInfo );
        }
    }

    luaL_error(pLuaState, "Could not find Per-SPI storage for this lua_State");
    return 0;
}

// ---------------------------------------------------------------------------------------
// Sgl_SpiGetStorage
// lua: Spi.GetStorage()
// Returns the Spi's private storage table
// ---------------------------------------------------------------------------------------
#if DBG
static int Sgl_SpiGetStorageTable(lua_State* pLuaState)
{
    // Retrieve the table where we're storing per spi storage tables

    lua_pushstring(pLuaState, LUA_REGISTRY_SPI_STORAGE);
    lua_gettable(pLuaState, LUA_REGISTRYINDEX);

    // Return the storage table
    return 1;
}
#endif

// This is the table of extensions. The left column is the name of the API as it's
// registered in lua. The right column is the corresponding C api.
static const luaL_Reg g_SgLuaSpi[] = {
    {"GetAuthData3",        Sgl_SpiGetAuthData3},
    {"GetAuthData3Table",   Sgl_SpiGetAuthData3Table},
    {"GetClientIpAddr",     Sgl_SpiGetClientIpAddr},
    {"GetClientMajor",      Sgl_SpiGetClientMajor},
    {"GetClientMinor",      Sgl_SpiGetClientMinor},
    {"GetClientBuild",      Sgl_SpiGetClientBuild},
    {"GetClientQfe",        Sgl_SpiGetClientQfe},
    {"GetConsoleRegion",    Sgl_SpiGetConsoleRegion},
    {"GetTitleId",          Sgl_SpiGetTitleId},
    {"GetTitleVersion",     Sgl_SpiGetTitleVersion},
    {"GetTitleRegion",      Sgl_SpiGetTitleRegion},
    {"GetUserCountryId",    Sgl_SpiGetUserCountryId},
    {"GetUserId",           Sgl_SpiGetUserId},
    {"GetXboxId",           Sgl_SpiGetXboxId},
    {"IsBetaMachine",       Sgl_SpiIsBetaMachine},
    {"IsDevKit",            Sgl_SpiIsDevKit},
    {"IsPc",                Sgl_SpiIsPc},
    {"IsLimited",           Sgl_SpiIsLimited},
    {"IsTestKit",           Sgl_SpiIsTestKit},
    {"IsXbox",              Sgl_SpiIsXbox},
    {"IsXbox360",           Sgl_SpiIsXbox360},
    {"IsXboxEmulation",     Sgl_SpiIsXboxEmulation},
    {"GetStorage",          Sgl_SpiGetStorage},
#if DBG
    {"GetStorageTable",     Sgl_SpiGetStorageTable},
#endif
    {NULL,              NULL}
};

// ---------------------------------------------------------------------------------------
// SgLuaSpiRegister
// Register lua spi extensions
// Remarks:
//   Don't call this directly. This must be called from lua_pcall
// ---------------------------------------------------------------------------------------
void SgLuaSpiRegister(lua_State* pLuaState)
{
    // Register extensions

    luaL_register(pLuaState, "Spi", g_SgLuaSpi);

    // Allocate table in the registry to track per spi storage

    lua_pushstring(pLuaState, LUA_REGISTRY_SPI_STORAGE);
    lua_newtable(pLuaState);
    lua_settable(pLuaState, LUA_REGISTRYINDEX);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglua.cpp ===
// ---------------------------------------------------------------------------------------
// sglua.cpp
//
// Xbox security gateway
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_LUA

#define LUA_INIT_SCRIPT "init.lua"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

class CSgLuaState;
class CSgLuaStateTable;

BOOL SgLuaLoadScript(CSgLuaStateTable* pLuaStateTable, LPCSTR pScript, CStr* pScriptLocation);

UINT  g_cLuaStateTableSize; // Number of entries in the state table

// ---------------------------------------------------------------------------------------
// CSgLuaState
// Encapsulates a lua_State. Don't used it directly. Use the ISgLuaState interface
// retrieved from SgLuaGetState.
// ---------------------------------------------------------------------------------------
class CSgLuaState : public ISgLuaState
{
public:

    DECLARE_NEW_DELETE(CSgLuaState);

    CSgLuaState();

    virtual ~CSgLuaState();

    BOOL Init(CSgLuaStateTable* pLuaStateTable, int index, CStr* perror);

    void Term();

    BOOL LoadChunkFromBuffer(
        LPCSTR pChunkName,
        CHAR* pChunkBuffer,
        UINT32 chunkSize,
        CStr* perror);

    virtual void Lock();

    virtual BOOL LinkLuaStateToSpi(CSpiInfo* pSpiInfo, CStr* perror);

    virtual lua_State* GetLuaState();

    virtual BOOL SetGlobalBuffer(LPCSTR pName, BYTE *pbBuffer, ULONG cbBuffer, BOOL bReadOnly, BOOL bCopy, CStr* perror);

    virtual BOOL SetGlobalInteger(LPCSTR pName, DWORD dwValue, CStr* perror);

    virtual BOOL UnsetGlobal(LPCSTR pName, CStr *perror);

    virtual void Release();

    virtual BOOL CCall(lua_CFunction func, void *ud, CStr* perror);

    virtual BOOL LCall_va(const char *pFunc, const char *pSig, CStr* perror, ... );

protected:

    static int PLoadLibs(lua_State* pLuaState);
    static int PLoadLibsMaster(lua_State* pLuaState);

    // Parameters for PLoadChunkFromBuffer
    struct LOAD_CHUNK_FROM_BUFFER
    {
        CSgLuaState*   pThis;
        const CHAR*    pChunk;
        UINT32         chunkSize;
        LPCSTR         pChunkName;
    };

    static int PLoadChunkFromBuffer(lua_State* pLuaState);

    // Parameters for SetGlobalBuffer/SetGlobalInteger/UnsetGlobal
    struct SET_GLOBAL_USER_DATA
    {
        CSgLuaState*   pThis;
        LPCSTR         pName;
        BYTE*          pbBuffer;
        ULONG          cbBuffer;
        BOOL           bReadOnly;
        BOOL           bCopy;
    };

    static int PSetGlobalBuffer(lua_State* pLuaState);
    static int PSetGlobalInteger(lua_State* pLuaState);

    // Parameters for LCall_va
    struct LCALL_VA
    {
        const char * pFunc;
        const char * pSig;
        va_list      args;
    };

    static int PLCall_va(lua_State* pLuaState );

    static int PLinkLuaStateToSpi(lua_State* pLuaState);

    static int PReset(lua_State* pLuaState);

    lua_State*          _pLuaState;             // lua state
    CSgLuaStateTable*   _pLuaStateTable;        // parent lua state table
    CSpinLock           _lock;                  // lock to synchronize access to this object
    LARGE_INTEGER       _liStart;               // tracks time spent in lua
};

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable
//
// Table of lua states.
//
// Even though the lua engine itself is reentrant, a single lua_State is not.  Thefore,
// the SG uses an array of lua_States to minimize contention.  The state to be used will
// depend on a deterministic key - like the dwSpiRecv in CSpiInfo. This key will be used
// to produce a hash which will be mapped to one of the lua_States that was allocated. A
// single key will always map to the same lua_State and therefore state can be preserved
// for the same context.
// ---------------------------------------------------------------------------------------
class CSgLuaStateTable
{
public:
    DECLARE_NEW_DELETE(CSgLuaStateTable);

    CSgLuaStateTable();

    ~CSgLuaStateTable();

    BOOL Init(UINT32 sizeLuaStateTable, CStr* perror);

    void Term();

    BOOL LoadChunkFromBuffer(
        LPCSTR pChunkName,
        CHAR* pChunkBuffer,
        UINT32 chunkSize,
        CStr* perror);

    ISgLuaState* GetLuaStateForSpi(CSpiInfo* pSpiInfo);

    ISgLuaState* GetLuaStateByIndex(UINT32 dwIndex);

    BOOL SetGlobalBuffer(LPCSTR pName, BYTE *pbBuffer, ULONG cbBuffer, BOOL bReadOnly, BOOL bCopy, CStr* perror);

    BOOL SetGlobalInteger(LPCSTR pName, DWORD dwValue, CStr* perror);

    BOOL UnsetGlobal(LPCSTR pName, CStr *perror);

    void AddRef();

    void Release();

    UINT32 GetStateTableSize() { return _luaStateTableSize; }

protected:

    // CSgLuaState is our friend
    friend CSgLuaState;

    static void* l_alloc (void* userData, void* ptr, size_t osize, size_t nsize);

    UINT32       _luaStateTableSize;    // number of entries in _pLuaStateTable
    CSgLuaState* _pLuaStateTable;       // array of CSgLuaState
    UINT32       _usedMemory;           // memory used by all states
    volatile LONG _refcount;            // this object's reference count
};

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::CSgLuaStateTable
// constructor
// ---------------------------------------------------------------------------------------
CSgLuaStateTable::CSgLuaStateTable() :
    _luaStateTableSize(0),
    _pLuaStateTable(NULL),
    _refcount(0),
    _usedMemory(0)
{
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::~CSgLuaStateTable
// destructor
// ---------------------------------------------------------------------------------------
CSgLuaStateTable::~CSgLuaStateTable()
{
    Term();
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::Init
// Allocates array of CSgLuaStates and initialize them.
//   - sizeLuaStateTable: number of CSgLuaStates to allocate and initialize
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaStateTable::Init(UINT32 sizeLuaStateTable, CStr* perror)
{
    Assert(sizeLuaStateTable != 0);

    int     status  = 0;
    BOOL    ok      = FALSE;

    _luaStateTableSize = sizeLuaStateTable;
    _pLuaStateTable = new CSgLuaState[_luaStateTableSize];

    if(!_pLuaStateTable)
    {
        perror->Format("Failed to allocate _pLuaStateTable");
        goto Exit;
    }

    // Initialize array of lua_States

    for(unsigned int i=0; i < _luaStateTableSize; i++)
    {
        if(!_pLuaStateTable[i].Init(this, i, perror))
        {
            goto Exit;
        }
    }

    ok = TRUE;

Exit:

    return ok;
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::Term
// Release resources
// ---------------------------------------------------------------------------------------
void CSgLuaStateTable::Term()
{
    if(_pLuaStateTable)
    {
        // The destructors of each CSgLuaState will be called
        delete[] _pLuaStateTable;
        _pLuaStateTable = NULL;
        _luaStateTableSize = 0;
    }
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::LoadChunkFromBuffer
// Loads a lua chunk on all lua states in the table.
// A chunk is essencially a script or a nameless function.
//   - pChunkName: name of the chunk for error reporting purposes. If the script is being
//   loaded from a file, the name of the file should be used. The name is only important
//   while the chunk is being loaded and processed.
//   - pChunkBuffer: pointer to buffer containing the chunk
//   - chunkSize: size of buffer pointed by pChunkBuffer in bytes.
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaStateTable::LoadChunkFromBuffer(
    LPCSTR pChunkName,
    CHAR* pChunkBuffer,
    UINT32 chunkSize,
    CStr* perror
    )
{
    Assert(_luaStateTableSize != 0);

    for (unsigned int i=0; i < _luaStateTableSize; i++)
    {
        BOOL success = _pLuaStateTable[i].LoadChunkFromBuffer(
            pChunkName,
            pChunkBuffer,
            chunkSize,
            perror
            );
        if (!success)
        {
            return FALSE;
        }
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::SetGlobalBuffer
// Set a global variable in all states in the table
//   - pName: name of the global variable
//   - pbBuffer: pointer to the buffer to store in the user data
//   - cbBuffer: size of the buffer
//   - bReadOnly: whether or not the buffer is readonly from LUA
//   - bCopy: whether or not to copy the buffer to LUA memory
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaStateTable::SetGlobalBuffer(
    LPCSTR pName,
    BYTE  *pbBuffer,
    DWORD  cbBuffer,
    BOOL   bReadOnly,
    BOOL   bCopy,
    CStr  *perror
    )
{
    Assert(_luaStateTableSize != 0);

    for (unsigned int i=0; i < _luaStateTableSize; i++)
    {
        BOOL success = _pLuaStateTable[i].SetGlobalBuffer(
            pName,
            pbBuffer,
            cbBuffer,
            bReadOnly,
            bCopy,
            perror
            );

        if (!success)
        {
            return FALSE;
        }
    }

    return TRUE;
}


// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::SetGlobalInteger
// Set a global variable in all states in the table
//   - pName: name of the global variable
//   - dwValue: value to set
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaStateTable::SetGlobalInteger(
    LPCSTR pName,
    DWORD  dwValue,
    CStr  *perror
    )
{
    Assert(_luaStateTableSize != 0);

    for (unsigned int i=0; i < _luaStateTableSize; i++)
    {
        BOOL success = _pLuaStateTable[i].SetGlobalInteger(
            pName,
            dwValue,
            perror
            );

        if (!success)
        {
            return FALSE;
        }
    }

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::UnsetGlobal
// Remove a global variable in a lua_state
//   - pName: name of the global variable
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaStateTable::UnsetGlobal(
    LPCSTR pName,
    CStr  *perror
    )
{
    Assert(_luaStateTableSize != 0);

    for (unsigned int i=0; i < _luaStateTableSize; i++)
    {
        BOOL success = _pLuaStateTable[i].UnsetGlobal(
            pName,
            perror
            );
        if (!success)
        {
            return FALSE;
        }
    }

    return TRUE;
}


// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::GetLuaStateByIndex
// Get a ISgLuaState interface pointer given index.
//   Index: Which ISgLuaState* to retrieve.
// Returns:
//   Pointer to ISgLuaState. It can return NULL if the index is out bounds
// ---------------------------------------------------------------------------------------
ISgLuaState* CSgLuaStateTable::GetLuaStateByIndex(UINT32 dwIndex)
{
    Assert(_luaStateTableSize != 0);

    // If we are past all of the valid indexes, then don't return anything

    if (dwIndex >= _luaStateTableSize)
    {
        return NULL;
    }

    // Increment ref-count indicating that somebody is using a lua_State. It will be
    // decremented in ReleaseLuaState.

    AddRef();

    // Grab a pointer to the lua state we will be returning

    CSgLuaState* pSgLuaState = &_pLuaStateTable[dwIndex];

    // Note that in this scenario, no SPI info was linked to the LuaState
    // Just return the state

    return (ISgLuaState*) pSgLuaState;
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::GetLuaStateForSpi
// Get a ISgLuaState interface pointer given a pointer to CSpiInfo. The _dwSpiRecv field
// of the CSpiInfo will be used to generate a hash that is mapped into the table of
// CSgLuaStates. The same CSpiInfo will always receive the same ISgLuaState.
// This will also link the CSpiInfo to the lua_State so that SgLuaGetSpiInfo() is able to
// access it.
//   pSpiInfo: pointer to CSpiInfo to retrieve a ISgLuaState* for.
// Returns:
//   Pointer to ISgLuaState.  It always succeeds.
//   ---------------------------------------------------------------------------------------
ISgLuaState* CSgLuaStateTable::GetLuaStateForSpi(CSpiInfo* pSpiInfo)
{
    Assert(_luaStateTableSize != 0);
    Assert(pSpiInfo != NULL);

    // @@@ bit unsure if this is always true. what about in the middle of a key exchange
    // and something goes awry and the spi gets dropped?
    Assert(pSpiInfo->_AuthData.qwXboxID != 0);

    ULONGLONG key = pSpiInfo ? pSpiInfo->_AuthData.qwXboxID : 0;

    // Increment ref-count indicating that somebody is using a lua_State. It will be
    // decremented in ReleaseLuaState.

    AddRef();

    // Calculate the hash of key to determine which entry in table to use

    DWORD hash = (DWORD) (key % _luaStateTableSize);
    CSgLuaState* pSgLuaState = &_pLuaStateTable[hash];

    return (ISgLuaState*) pSgLuaState;
}

// ---------------------------------------------------------------------------------------
// SgLuaReleaseSpiStorage
// Release Spi storage. This must be called when a Spi is deleted.
//   - pSpiInfo: pointer to CSpiInfo that is about to be deleted.
// ---------------------------------------------------------------------------------------
void SgLuaReleaseSpiStorage(CSpiInfo* pSpiInfo)
{
    ISgLuaState* pLuaState = SgLuaGetState(pSpiInfo);
    pLuaState->CCall(SgLuaSpiStorageTerm, pSpiInfo, NULL);
    pLuaState->Release();
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::AddRef
// Increments the object's reference count.
// ---------------------------------------------------------------------------------------
void CSgLuaStateTable::AddRef()
{
    ::InterlockedIncrement(&_refcount);
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::Release
// Decrements the object's reference count. Once it reaches zero, the object is released.
// ---------------------------------------------------------------------------------------
void CSgLuaStateTable::Release()
{
    Assert(_refcount > 0);
    if(::InterlockedDecrement(&_refcount) == 0)
    {
        TraceSz(Config, "CSgLuaStateTable::Release() - deleting object");
        delete this;
    }
}

// ---------------------------------------------------------------------------------------
// CSgLuaStateTable::l_alloc
// Provices memory allocation for lua. It also provides us with a way to monitor memory
// usage. This method should not get called directly. Only lua should call it.
//   - userData: this is the parameter that was passed in to lua_newstate. In our case
//   it's the pointer to the CSgLuaStateTable instance.
//   - ptr: pointer to buffer to be reallocated or released.
//   - osize: old size (if ptr is not null)
//   - nsize: size of the new buffer. If it's zero and ptr is not null, it should be
//   released.
// Returns:
//   Pointer to newly allocated buffer or NULL on failure and if the buffer was being
//   released.
// ---------------------------------------------------------------------------------------
void* CSgLuaStateTable::l_alloc (void* userData, void* ptr, size_t osize, size_t nsize)
{
    CSgLuaStateTable* pthis = (CSgLuaStateTable*) userData;

    if(osize != 0)
    {
        LONGLONG s = (LONGLONG)osize;
        s *= -1;
        SgPerfdataInterlockedAdd(LuaMemoryUsageBytes, s);
        pthis->_usedMemory -= osize;
    }

    if(nsize != 0)
    {
        SgPerfdataInterlockedAdd(LuaMemoryUsageBytes, nsize);
        pthis->_usedMemory += nsize;
    }

    if (nsize == 0)
    {
        if(ptr)
        {
            SgMemFree(ptr);
        }

        return NULL;
    }
    else
    {
        if(!ptr)
        {
            return SgMemAlloc(nsize, PTAG_Lua);
        }
        else
        {
            return SgMemReAlloc(ptr, nsize, PTAG_Lua);
        }
    }
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::CSgLuaState
// constructor
// ---------------------------------------------------------------------------------------
CSgLuaState::CSgLuaState() :
    _pLuaState(NULL),
    _pLuaStateTable(NULL)
{
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::~CSgLuaState
// destructor
// ---------------------------------------------------------------------------------------
CSgLuaState::~CSgLuaState()
{
    Term();
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::CCall
// Wrapper for lua_cpcall to format an error into a string
//   * pLuaState: pointer to lua_State
//   * func: pointer to C function to call
//   * ud: user-data
//   * perror: pointer to CStr to receive formatted error
// Returns:
//   TRUE if succeeded, FALSE otherwise
// Remarks:
//   Just like with lua_cpcall, be carefull of C++ objects or other resources allocated
//   by the function. Calling lua methods may longjmp out of the function without
//   processing destructors or clean-up code blocks.
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::CCall(lua_CFunction func, void *ud, CStr* perror)
{
    // Perfcounter - this function is our top-level entry into lua, whether it be
    // executing a lua script function or a c-code lua function.

    // Invoke the C-function
    int status = lua_cpcall(_pLuaState, func, ud);

    if(status != 0)
    {
        const char* pszError = lua_tostring(_pLuaState, -1);

        if(perror)
        {
            perror->Format("Failed to call function at '0x%p'. Error:\n%s", func, pszError);
        }

        lua_pop(_pLuaState, 1);
    }

    return status == 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::GetLuaState
// Returns the pointer to the lua_State encapsultated in this object
// ---------------------------------------------------------------------------------------
lua_State* CSgLuaState::GetLuaState()
{
    return _pLuaState;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::Init
// Initializes this object. Creates a new lua_State and loads the standard libraries and
// our extensions
//   - pLuaStateTable: pointer to parent lua state table
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::Init(
    CSgLuaStateTable* pLuaStateTable,
    int index,
    CStr* perror)
{
    BOOL ok = FALSE;

    _pLuaStateTable = pLuaStateTable;

    // Create new state

    _pLuaState = lua_newstate(CSgLuaStateTable::l_alloc, pLuaStateTable);

    if(!_pLuaState)
    {
        perror->Format("Failed to create lua_State");
        goto Exit;
    }

    // Load libraries
    if (index == 0) 
    {
        if (!CCall(PLoadLibsMaster, this, perror))
        {
            goto Exit;
        }
    }
    else if(!CCall(PLoadLibs, this, perror))
    {
        goto Exit;
    }


    ok = TRUE;

Exit:

    if(!ok)
    {
        Term();
    }

    return ok;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::LinkLuaStateToSpi
// Writes the pointer to a CSpiInfo on the lua registry to be accessed by SgLuaGetSpiInfo().
//   - pSpiInfo: pointer to CSpiInfo
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::LinkLuaStateToSpi(CSpiInfo* pSpiInfo, CStr* perror)
{
    return CCall(PLinkLuaStateToSpi, pSpiInfo, perror);
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::LoadChunkFromBuffer
// Loads a lua chunk.
// A chunk is essencially a script or a nameless function.
//   - pChunkName: name of the chunk for error reporting purposes. If the script is being
//   loaded from a file, the name of the file should be used. The name is only important
//   while the chunk is being loaded and processed.
//   - pChunkBuffer: pointer to buffer containing the chunk
//   - chunkSize: size of buffer pointed by pChunkBuffer in bytes.
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::LoadChunkFromBuffer(
    LPCSTR pChunkName,
    CHAR* pChunkBuffer,
    UINT32 chunkSize,
    CStr* perror)
{
    LOAD_CHUNK_FROM_BUFFER params;

    params.pThis        = this;
    params.pChunk       = pChunkBuffer;
    params.chunkSize    = chunkSize;
    params.pChunkName   = pChunkName;

    BOOL success = CCall(
        PLoadChunkFromBuffer,
        &params,
        perror);

    return success;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::Lock
// Locks this object.
// ---------------------------------------------------------------------------------------
void CSgLuaState::Lock()
{
    // Start time
    _liStart = SgQueryPerformanceCounter(NULL);

    _lock.Lock();

    // Perf counter
    LARGE_INTEGER liNow = SgQueryPerformanceCounter(NULL);
    ULONGLONG elapsed = (liNow.QuadPart - _liStart.QuadPart);
    SgPerfdataInterlockedAdd(LuaStateLockTime, elapsed);
    SgPerfdataInterlockedInc(LuaStateAcquire);
    SgPerfdataInterlockedInc(LuaStateInUse);

    // Reset timer
    _liStart = liNow;

}


// ---------------------------------------------------------------------------------------
// CSgLuaState::PLinkLuaStateToSpi
// Corresponding protected function to LinkLuaStateToSpi
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PLinkLuaStateToSpi(lua_State* pLuaState)
{
    CSpiInfo* pSpiInfo = (CSpiInfo*) lua_touserdata(pLuaState, 1);
    SgLuaSetSpiInfo(pLuaState, pSpiInfo);
    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PLoadChunkFromBuffer
// Protected function to load a lua chunk
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PLoadChunkFromBuffer(lua_State* pLuaState)
{
    int                     err = 0;
    LOAD_CHUNK_FROM_BUFFER* pParams =
        (LOAD_CHUNK_FROM_BUFFER*) lua_touserdata(pLuaState, 1);

    err = luaL_loadbuffer(
        pLuaState,
        pParams->pChunk,
        pParams->chunkSize,
        pParams->pChunkName);
    if (err != 0)
    {
        // SgLuaStackDump( pLuaState, "PLoadChunkFromBuffer - Failure");
        return lua_error(pLuaState);
    }

    // Load the chunk
    lua_call(pLuaState, 0, 0);

    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PLoadLibs
// Protected function load system libraries and SG extensions
// Called from any LUA state other than the master
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PLoadLibs(lua_State* pLuaState)
{
    // Load System libs

    luaopen_base(pLuaState);
    luaopen_math(pLuaState);
    luaopen_string(pLuaState);
    luaopen_table(pLuaState);
    luaopen_os(pLuaState);

    // Load our extensions

    SgLuaBufferRegister(pLuaState);
    SgLuaQwordRegister(pLuaState);
    SgLuaBinaryRegister(pLuaState);
    SgLuaSpiRegister(pLuaState);
    SgLuaFilterRegister(pLuaState);
    SgLuaChalRegister(pLuaState);
    SgLuaDebugRegister(pLuaState);
    SgLuaLogRegister(pLuaState);
    SgLuaPerfRegister(pLuaState);

    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PLoadLibs
// Protected function load system libraries and SG extensions
// Called from the master (0) lua_State
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PLoadLibsMaster(lua_State* pLuaState)
{
    // Load System libs

    luaopen_base(pLuaState);
    luaopen_math(pLuaState);
    luaopen_string(pLuaState);
    luaopen_table(pLuaState);
    luaopen_os(pLuaState);

    // Load our extensions

    SgLuaBufferRegister(pLuaState);
    SgLuaQwordRegister(pLuaState);
    SgLuaBinaryRegister(pLuaState);
    SgLuaSpiRegister(pLuaState);
    SgLuaFilterRegister(pLuaState);
    SgLuaChalRegister(pLuaState);
    SgLuaDebugMasterRegister(pLuaState);
    SgLuaLogRegister(pLuaState);
    SgLuaPerfRegister(pLuaState);

    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PReset
// Protected function to remove the pointer to CSpiInfo from this lua_State's registry.
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PReset(lua_State* pLuaState)
{
    // Reset CSpiInfo

    SgLuaSetSpiInfo(pLuaState, NULL);

    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PSetGlobalBuffer
// Corresponding protected function to SetGlobalBuffer and UnsetGlobal
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PSetGlobalBuffer(lua_State* pLuaState)
{
    SET_GLOBAL_USER_DATA *pParams =
        (SET_GLOBAL_USER_DATA *) lua_touserdata(pLuaState, 1 );

    if (!pParams)
        return 1;

    // SgLuaStackDump( pLuaState, "SetGlobalBuffer - Enter");

    //
    // First step is to obtain the "global" pointer and push that onto the stack
    //
    lua_getglobal( pLuaState, "globals" );

    //
    // Next action depends on whether or not a buffer was part of the arguments
    //
    if (pParams->pbBuffer != NULL && pParams->cbBuffer != 0)
    {
        SgLuaBufferInitialize(
            pLuaState,
            pParams->pbBuffer,
            pParams->cbBuffer,
            pParams->bReadOnly,
            pParams->bCopy
            );
    }
    else
    {
        lua_pushnil( pLuaState );
    }

    //
    // Stack [Top  ] = <value>
    // Stack [Top-1] = <table>
    //
    // SgLuaStackDump( pLuaState, "SetGlobalBuffer - SetField");
    lua_setfield( pLuaState, -2, pParams->pName );
    // SgLuaStackDump( pLuaState, "SetGlobalBuffer - Exit");

    //
    // BUGBUG: IS THIS CORRECT?
    //
    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PSetGlobalInteger
// Corresponding protected function to SetGlobalInteger
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call directly from the SG!
// ---------------------------------------------------------------------------------------
int CSgLuaState::PSetGlobalInteger(lua_State* pLuaState)
{
    SET_GLOBAL_USER_DATA *pParams =
        (SET_GLOBAL_USER_DATA *) lua_touserdata(pLuaState, 1 );
    DWORD dwValue = *((DWORD*)(pParams->pbBuffer));

    // SgLuaStackDump( pLuaState, "SetGlobalInteger - Enter");

    //
    // First step is to obtain the "global" pointer and push that onto the stack
    //
    lua_getglobal( pLuaState, "globals" );
    lua_pushinteger( pLuaState, dwValue );

    // SgLuaStackDump( pLuaState, "SetGlobalInteger - SetField");
    lua_setfield( pLuaState, -2, pParams->pName );
    // SgLuaStackDump( pLuaState, "SetGlobalInteger - Exit");

    return 0;
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::Release
// Release lock to object. Also releases reference on the parent lua state table.
// ---------------------------------------------------------------------------------------
void CSgLuaState::Release()
{
    // Reset state - remove CSpiInfo from registry
    CCall(PReset, NULL, NULL);

    // Unlock this state
    _lock.Unlock();

    // Perf counter
    LARGE_INTEGER liNow = SgQueryPerformanceCounter(NULL);
    ULONGLONG elapsed = (liNow.QuadPart - _liStart.QuadPart);
    SgPerfdataInterlockedAdd(LuaStateTime, elapsed);
    SgPerfdataInterlockedDec(LuaStateInUse);

    // Remove reference to the state table
    _pLuaStateTable->Release();

}

// ---------------------------------------------------------------------------------------
// CSgLuaState::SetGlobalBuffer
// Set a global variable in a lua_state
//   - pName: name of the global variable
//   - pbBuffer: pointer to the buffer to store in the user data
//   - cbBuffer: size of the buffer
//   - bReadOnly: whether or not the buffer is readonly from LUA
//   - bCopy: whether or not to copy the buffer to LUA memory
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::SetGlobalBuffer(
    LPCSTR pName,
    BYTE  *pbBuffer,
    DWORD  cbBuffer,
    BOOL   bReadOnly,
    BOOL   bCopy,
    CStr  *perror
    )
{
    SET_GLOBAL_USER_DATA params;

    //
    // Setup the parameters
    //
    params.pThis        = this;
    params.pName        = pName;
    params.pbBuffer     = pbBuffer;
    params.cbBuffer     = cbBuffer;
    params.bReadOnly    = bReadOnly;
    params.bCopy        = bCopy;

    //
    // Make the call
    //
    return CCall( PSetGlobalBuffer, &params, perror );
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::SetGlobalInteger
// Set a global variable in a lua_state
//   - pName: name of the global variable
//   - dwValue: value to set
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::SetGlobalInteger(
    LPCSTR pName,
    DWORD  dwValue,
    CStr  *perror
    )
{
    SET_GLOBAL_USER_DATA params;

    //
    // Setup the parameters
    //
    params.pThis        = this;
    params.pName        = pName;
    params.pbBuffer     = (BYTE*)&dwValue;
    params.cbBuffer     = sizeof(DWORD);

    //
    // Make the call
    //
    return CCall( PSetGlobalInteger, &params, perror );
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::Term
// Release resources
// ---------------------------------------------------------------------------------------
void CSgLuaState::Term()
{
    if(_pLuaState)
    {
        lua_close(_pLuaState);
        _pLuaState = NULL;
    }
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::UnSetGlobal
// Remove a global variable in a lua_state
//   - pName: name of the global variable
//   - perror: string object to receive error information if the call fails
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::UnsetGlobal(
    LPCSTR pName,
    CStr  *perror
    )
{
    SET_GLOBAL_USER_DATA params;

    //
    // Setup the parameters
    //
    params.pThis        = this;
    params.pName        = pName;
    params.pbBuffer     = NULL;
    params.cbBuffer     = NULL;
    params.bReadOnly    = 0;
    params.bCopy        = 0;

    //
    // Make the call
    //
    return CCall( PSetGlobalBuffer, &params, perror );
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::LCall_va
// Makes safe lua calls (no need for lua_pcall) handling parameters and results
//   - pFunc: name of the function to call
//   - pSig: signature of the function that specifies parameters and results.
//   - perror (OPTIONAL): pointer to CStr to receive error information if the function
//   fails.
//   - ...: variable parameter to function call. Must match signature specified in pSig.
// Returns:
//   TRUE if succeeds and FALSE if it fails and perror contains the details
// Example:
//
//     TLocalStr<200>     error;
//     double             doubleResult;
//     int                intResult;
//     TLocalStr<40>      stringResult;
//
//     ok = pLua->Call_va(
//         "FilterApply",
//         "dis>dis",
//         &error,
//         3.1415,
//         0xdeadbeef,
//         "Hello World",
//         &doubleResult,
//         &intResult,
//         (CStr*)&stringResult);
//
// ---------------------------------------------------------------------------------------
BOOL CSgLuaState::LCall_va(const char* pFunc, const char* pSig, CStr* perror, ...)
{
    LCALL_VA params;
    params.pFunc  = pFunc;
    params.pSig   = pSig;
    va_start(params.args, perror);

    return CCall(PLCall_va, &params, perror);
}

// ---------------------------------------------------------------------------------------
// CSgLuaState::PCall_va
// Lua C function corresponding to Call_va
//   - pLuaState: pointer to lua_State
// Returns:
//   0
// Remarks:
//   Don't call this directly.
// ---------------------------------------------------------------------------------------
int CSgLuaState::PLCall_va(lua_State* pLuaState)
{
    LCALL_VA* pParams = (LCALL_VA*) lua_touserdata(pLuaState, -1);

    int narg = 0;
    int nres = 0;

    // Push function
    lua_getglobal(pLuaState, pParams->pFunc);

    // Push arguments
    const char* pSig = pParams->pSig;
    for(narg=0;
        *pSig != 0;
        narg++, pSig++)
    {
        // check stack space
        luaL_checkstack(pLuaState, 1, "too many arguments");

        switch(*pSig)
        {
        case 'd':   // double argument
            lua_pushnumber(pLuaState, va_arg(pParams->args, double));
            break;

        case 'i':   // int argument
            lua_pushnumber(pLuaState, va_arg(pParams->args, int));
            break;

        case 's':   // string argument
            lua_pushstring(pLuaState, va_arg(pParams->args, char*));
            break;

        case 'b':   // buffer argument
            {
                CConstBuffer* pBufferArg = va_arg(pParams->args, CConstBuffer*);
                SgLuaBufferInitialize(
                    pLuaState,
                    (BYTE*) pBufferArg->GetConstPtr(),
                    pBufferArg->GetSize(),
                    TRUE,  // bReadOnly
                    TRUE); // bCopy
            }
            break;

        case '>':   // end of arguments
            pSig++;
            goto EndArgs;

        default:
            luaL_error(pLuaState, "Invalid option (%c)", *pSig);
        }
    }

EndArgs:

    // Debug Spew
    // SgLuaStackDump( pLuaState, "Before Call");

    // Number of expected arguments is the number of characters after the '>'. If there
    // was no '>', pSig points to the end of the string and nres will be zero.
    nres = strlen(pSig);

    // Perfcounter - this function is used to call into a LUA script
    SgPerfdataInterlockedInc( LuaCalls );

    // Call the lua function. Pop function and arguments from the stack.
    if(lua_pcall(pLuaState, narg, nres, 0) != 0)
    {
        luaL_error(pLuaState, "Error calling '%s': %s", pParams->pFunc,
              lua_tostring(pLuaState, -1));
    }

    // Debug Spew
    // SgLuaStackDump( pLuaState, "After call");

    // Process results. The negative of nres is the index of the first result in the
    // stack.
    nres = -nres;

    for(; *pSig != 0; pSig++, nres++)
    {
        switch(*pSig)
        {
        case 'd':   // double result
            {
                if(!lua_isnumber(pLuaState, nres))
                {
                    luaL_error(pLuaState, "Wrong result type - double expected got '%s'", lua_typename(pLuaState,nres));
                }
                *va_arg(pParams->args, double*) = lua_tonumber(pLuaState, nres);
                break;
            }

        case 'i':   // int result
            {
                if(!lua_isnumber(pLuaState, nres))
                {
                    luaL_error(pLuaState, "Wrong result type - integer expected got '%s'", lua_typename(pLuaState,nres));
                }
                *va_arg(pParams->args, int*) = (int) lua_tonumber(pLuaState, nres);
                break;
            }

        case 's':   // string result
            {
                if(!lua_isstring(pLuaState, nres))
                {
                    luaL_error(pLuaState, "Wrong result type - string expected got '%s'", lua_typename(pLuaState,nres));
                }
                const char* pResult = lua_tostring(pLuaState, nres);
                CStr* pOutArg = va_arg(pParams->args, CStr*);
                pOutArg->CopyFrom(pResult);
                break;
            }

        case 'b':   // buffer result
            {
                CBuffer* pOutArg = va_arg(pParams->args, CBuffer*);
                BYTE*    pBuffer  = NULL;
                UINT32   cbBuffer = 0;

                // We can get nil back in some cases
                if (!lua_isnil(pLuaState, nres))
                {
                    SgLuaBufferCheck(pLuaState, nres, &pBuffer, &cbBuffer);
                }

                // Is there any data in this buffer to copy?
                if (cbBuffer != 0)
                {
                    pOutArg->CopyFrom(pBuffer, cbBuffer);
                }
                else
                {
                    // Indicate that this buffer is empty
                    pOutArg->SetSize(0);
                }
                break;
            }

        default:

            luaL_error(pLuaState, "Invalid result option (%c)", *pSig);
        }
    }

    if(nres != 0)
    {
        // Pop results from the stack
        lua_pop(pLuaState, nres);
    }

    return 0;
}

CReaderWriterLock3 g_SgLuaStateTableLock;
CSgLuaStateTable* g_pSgLuaStateTable;

// ---------------------------------------------------------------------------------------
// SgLuaInit
// Called by the SG during initialization and before calling SgLuaConfig.
// There is currently nothing to be initialized.
// ---------------------------------------------------------------------------------------
BOOL SgLuaInit()
{
    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgLuaTerm
// Called by the SG to terminate and release resources.
// At the point when SgLuaTerm is called, all
// ---------------------------------------------------------------------------------------
void SgLuaTerm()
{
    if(g_pSgLuaStateTable)
    {
        g_pSgLuaStateTable->Release();
        g_pSgLuaStateTable = NULL;
    }
}

// ---------------------------------------------------------------------------------------
// SgLuaConfig
// Initialize the lua state table and load scripts from the database and the sgcfg
// directory.
// ---------------------------------------------------------------------------------------

BOOL SgLuaConfig(CCfgInfo* pci)
{
    BOOL ok = FALSE;

    TraceSz( Config, "SgLuaConfig:" );

    if(!pci->GetVar("LuaStateTableSize", &g_cLuaStateTableSize, 1, 10000, 10))
    {
        goto Exit;
    }

    ok = SgLuaReloadChallenges();
Exit:
    return ok;
}

BOOL SgLuaReloadChallenges()
{
    BOOL ok = FALSE;
    CSgLuaStateTable* pLuaStateTable = NULL;
    TLocalStr<MAX_PATH> moduleName;
    TLocalStr<MAX_PATH> path;
    TLocalStr<MAX_PATH> scriptLocation;
    TLocalStr<512> errorstr;
    CArenaAlloc alloc;
    THashtable<LPCSTR, BYTE, CStringHashClass> scripts;
    THashtable<LPCSTR, BYTE, CStringHashClass>::Iterator it;
    HRESULT hr;

    // Create a new CSgLuaStateTable object.

    pLuaStateTable = new CSgLuaStateTable();

    if(!pLuaStateTable)
    {
        SgEventSz(CONFIG_ERROR, "Failed to allocate CSgLuaStateTable");
        goto Exit;
    }

    // Initialize it

    if(!pLuaStateTable->Init(g_cLuaStateTableSize, &errorstr))
    {
        SgEventSz(CONFIG_ERROR, "Failed initialize CSgLuaStateTable. Error: %s", errorstr.cstr());
        goto Exit;
    }

    // Retrieve the list of available scripts

    alloc.Init(CSgMemAlloc::GetAlloc(), 2048);
    scripts.SetAllocator(CSgMemAlloc::GetAlloc());
    scripts.Grow(100);

    // Get Module Path
    if (!CSystem::GetModuleName(NULL, &moduleName) ||
        !CSystem::ParseFileName(moduleName.cstr(), CSystem::PARSE_DRIVE_AND_PATH, &path))
    {
        SgEventSz(CONFIG_ERROR, "Failed to get module name. Win32 error = %u", GetLastError());
        goto Exit;
    }
    scriptLocation.Format("%s%s",path.cstr(), SG_CONFIG_SCRIPT_LOCATION );

    if(!SgConfigGetScriptList(&alloc, &scripts, &scriptLocation, CONFIG_SCRIPT_ALL))
    {
        SgEventSz(CONFIG_ERROR, "SgConfigGetScriptList failed.");
        goto Exit;
    }

    // First load init.lua if available

    if(scripts.Get(LUA_INIT_SCRIPT, NULL))
    {
        if(!SgLuaLoadScript(pLuaStateTable, LUA_INIT_SCRIPT, &scriptLocation))
        {
            goto Exit;
        }

        scripts.Remove(LUA_INIT_SCRIPT, NULL);
    }

    // Process remaining scripts

    scripts.InitializeIterator(&it);

    LPCSTR pScript;
    while(it.GetNext(&pScript, NULL))
    {
        // Ignore errors loading or parsing LUA scripts. Events will still be generated, 
        // but SgConfig won't fail. You can always fix your script and reload the SG 
        // again.
        SgLuaLoadScript(pLuaStateTable, pScript, &scriptLocation);
    }

    // This CSgLuaStateTable is a keeper. Addref it.

    pLuaStateTable->AddRef();

    // Replace previous instance (if any)

    CSgLuaStateTable* pPrevTable;
    g_SgLuaStateTableLock.WriteLock();

    pPrevTable = g_pSgLuaStateTable;
    g_pSgLuaStateTable = pLuaStateTable;

    // Reset the perf counters while we have the lock
    // Note: the only way to really improve this is to add logic that counts the number
    // of active lua states and wait until they get to zero...
    SgLuaPerfReset();

    g_SgLuaStateTableLock.WriteUnlock();

    if(pPrevTable)
    {
        // Release the original reference to this old table. It will be deleted when the
        // reference count reaches zero.
        pPrevTable->Release();
    }

    pLuaStateTable = NULL;

    ok = TRUE;

Exit:

    if(pLuaStateTable)
    {
        delete pLuaStateTable;
    }

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgLuaLoadScript
// Utility function to load a script on a lua state table
//   - pLuaStateTable: pointer to CSgLuaStateTable
//   - pScript: null-terminated string with the script name
//   - pScriptLocation: directory location of the script
// Returns:
//   TRUE if succeeded, FALSE if it failed
// ---------------------------------------------------------------------------------------
static BOOL SgLuaLoadScript(CSgLuaStateTable* pLuaStateTable, LPCSTR pScript, CStr* pScriptLocation)
{
#define IF_FAILED_GOTO_EXIT(op) \
    if(!(op)) { \
        SgEventSz(CONFIG_ERROR, "LUA operation failed for script %s:\n%s\nError: %s\n", pScript, #op, errorstr.cstr()); \
        goto Exit; \
    }

    CScriptInfo scriptInfo;
    HRESULT hr;
    TLocalStr<512> errorstr;
    BOOL ok = FALSE;

    scriptInfo.scriptName.CopyFrom(pScript);
    hr = SgConfigGetScript(pScript, &scriptInfo, pScriptLocation, CONFIG_SCRIPT_ALL);

    if(hr != S_OK)
    {
        SgEventSz(CONFIG_ERROR, "Failed to load script file %s. hr = 0x%08x",
                   pScript, hr);
        goto Exit;
    }

    // init.lua is special. it always has been, and probably always will be. why not
    // special case it?  Calling SetGlobal* without having loaded init.lua causes a crash.
    if (_stricmp(pScript, LUA_INIT_SCRIPT) == 0)
    {
        //
        // Load the script into all of the luastates
        //
        IF_FAILED_GOTO_EXIT(pLuaStateTable->LoadChunkFromBuffer(
                pScript,
                (CHAR*) scriptInfo.scriptBuffer.GetConstPtr(),
                scriptInfo.scriptBuffer.GetSize(),
                &errorstr));
    }
    else
    {
        // Any challenges and filters get processed here

        //
        // If there is a binary blob, set a global variable. The script (or init.lua) will
        // have to be responsible for assigning this global value to a local value. This is
        // how we provide info to the chhalenge states themselves.
        //
        if (scriptInfo.blobBuffer.GetSize())
        {
            IF_FAILED_GOTO_EXIT(pLuaStateTable->SetGlobalBuffer(
                    "BinaryData",
                    (BYTE *) scriptInfo.blobBuffer.GetConstPtr(),
                    scriptInfo.blobBuffer.GetSize(),
                    TRUE,
                    TRUE,
                    &errorstr
                    ));
        }


        // Load any settings into global state, so they can be pulled into local state
        // when we run the script

        IF_FAILED_GOTO_EXIT(pLuaStateTable->SetGlobalInteger(
                "KickEnabled",
                scriptInfo.bKickEnabled,
                &errorstr
                ));

        IF_FAILED_GOTO_EXIT(pLuaStateTable->SetGlobalInteger(
                "TimeoutEnabled",
                scriptInfo.bTimeoutEnabled,
                &errorstr
                ));

        //
        // Load the script into all of the luastates
        //
        IF_FAILED_GOTO_EXIT(pLuaStateTable->LoadChunkFromBuffer(
                pScript,
                (CHAR*) scriptInfo.scriptBuffer.GetConstPtr(),
                scriptInfo.scriptBuffer.GetSize(),
                &errorstr));

        TraceSz(Config, "    Script %s: KickEnabled=%u, TimeoutEnabled=%u, BinaryData size=%u",
                 pScript,
                 scriptInfo.bKickEnabled,
                 scriptInfo.bTimeoutEnabled,
                 scriptInfo.blobBuffer.GetSize());

        //
        // Clear the global from all the luastates. This is a like an environment variable,
        // and it was only needed while we were initializing this challenge.
        //
        if (scriptInfo.blobBuffer.GetSize())
        {
            IF_FAILED_GOTO_EXIT(pLuaStateTable->UnsetGlobal( "BinaryData", &errorstr ));
        }
        IF_FAILED_GOTO_EXIT(pLuaStateTable->UnsetGlobal( "KickEnabled", &errorstr ));
        IF_FAILED_GOTO_EXIT(pLuaStateTable->UnsetGlobal( "TimeoutEnabled", &errorstr ));
    }

    ok = TRUE;

Exit:

    return ok;
}

// ---------------------------------------------------------------------------------------
// SgLuaGetState
// Retrieves a ISgLuaState interface pointer for a given CSpiInfo*.
//   - pSpiInfo: pointer to CSpiInfo to retrieve the ISgLuaState* for.
// Returns:
//   Pointer to ISgLuaState. It always succeed.
// ---------------------------------------------------------------------------------------
ISgLuaState* SgLuaGetState(CSpiInfo* pSpiInfo)
{
    Assert(g_pSgLuaStateTable);

    g_SgLuaStateTableLock.ReadLock();
    ISgLuaState* pLuaState = g_pSgLuaStateTable->GetLuaStateForSpi(pSpiInfo);
    g_SgLuaStateTableLock.ReadUnlock();

    // lock entry to prevent concurrent use. do it outside the state table lock!
    if (pLuaState)
    {
        pLuaState->Lock();

        // Make this CSpiInfo available to this lua state. It will be used by our extensions
        // that depend on it - like the authdata extension.

        pLuaState->LinkLuaStateToSpi(pSpiInfo, NULL);
    }

    return pLuaState;
}

// ---------------------------------------------------------------------------------------
// SgLuaGetState
// Retrieves a ISgLuaState interface pointer for a given Index
//   - Index: index to retrieve the ISgLuaState* for.
// Returns:
//   Pointer to ISgLuaState. It can fail with NULL.
// ---------------------------------------------------------------------------------------
ISgLuaState* SgLuaGetState(UINT32 dwIndex)
{
    Assert(g_pSgLuaStateTable);

    g_SgLuaStateTableLock.ReadLock();
    ISgLuaState* pLuaState = g_pSgLuaStateTable->GetLuaStateByIndex(dwIndex);
    g_SgLuaStateTableLock.ReadUnlock();

    // lock entry to prevent concurrent use. do it outside the state table lock!
    if (pLuaState)
    {
        pLuaState->Lock();
    }

    return pLuaState;
}

// ---------------------------------------------------------------------------------------
// SgLuaDumpStack
// Note: can only be called in a protected environment
//
// Dump all of the elements on a lua_State's stack
//   - lua_State: state whose stack we should dump
//   - pMessage: message to prepend to the stack dump
// Returns:
//   Void
// ---------------------------------------------------------------------------------------
void SgLuaStackDump( lua_State *L, LPCSTR pMessage)
{
    int i;
    int top = lua_gettop(L);

    if (pMessage)
    {
        TraceSz(Config,"%08x: %s", L, pMessage);
    }
    else
    {
        TraceSz(Config,"%08x: ", L);
    }

    for (i = top; i >= 1; i--)
    {
        int t = lua_type(L, i);
        switch (t)
        {
        case LUA_TSTRING:
            TraceSz(Config, "    %2d: TSTRING '%s'", i, lua_tostring(L,i));
            break;
        case LUA_TBOOLEAN:
            TraceSz(Config, "    %2d: TBOOLEAN %s", i, lua_toboolean(L,i) ? "true" : "false" );
            break;
        case LUA_TNUMBER:
            TraceSz(Config, "    %2d: TNUMBER %g", i, lua_tonumber(L,i) );
            break;
        default:
            TraceSz(Config, "    %2d: <%s>", i, lua_typename(L,t));
            break;
        }
    }
    TraceSz(Config,"%08x: ---", L );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglsp.cpp ===
// -------------------------------------------------------------------------------------
// lspclient.cpp
// Copyright (C) Microsoft Corporation
// -------------------------------------------------------------------------------------
#include "sg.h"
#include <winhttp.h>

#ifdef SG_FEATURE_LSP

// -------------------------------------------------------------------------------------
// Forward Declarations
// -------------------------------------------------------------------------------------

DWORD WINAPI SgLspTimer(VOID*);

void SgLspRefreshSiteInfo();

bool SgLspRefreshAdvertisement();

bool SgLspAdvertise(DWORD dwTitleId, DWORD dwIpSgLsp, DWORD dwTtlInSeconds, 
                    XNKID* pXnkid, XNKEY* pXnkey, LPCSTR pszUserData);

bool SgLspCopyRecentSiteKey(DWORD dwSiteId, BYTE* pbSiteKey);

bool SgLspPostHttpRequest(LPCWSTR pszPath, DWORD cbRequest, void* pbRequest, 
                          DWORD cbResponse, void* pbResponse, 
                          DWORD* pcbResponseRead);

LPCSTR SgLspWinHttpErrorStr(DWORD err);

// -------------------------------------------------------------------------------------
// Globals
// -------------------------------------------------------------------------------------

struct SGLSP_GLOBALS
{
    CLspProxy     lspproxy;             // proxy-info (ip, port, site)
    CSpinLock     lockProxy;            // synchronize access to lspproxy
    UINT          cRefreshIntervalInTicks; // how often should we refresh site info
    UINT          cRetryIntervalInTicks;// and if it fails, how often should we retry
    HINTERNET     hInternet;            // handle to WinHTTP client
    CKeyReg       keyreg;               // key registered in live for KeyEx (legacy)
    CSpinLock     lockKeyReg;           // synchronize access to keyreg
    UINT          cTitleInfo;           // size of array in pTitleInfo
    CTitleInfo *  pTitleInfo;           // array of title-info
    CSpinLock     lockTitleInfo;        // synchronize access to pTitleInfo
    DWORD         fAdvertiseOnLive;     // should we advertise ourselves in Live
    DWORD         fGetSiteInfoFromLive; // should we get our site keys from Live?
    CIpAddr       ipaAdvertise;         // if so, which IP should we advertise?
    CTimer        refreshTimer;         // timer to refresh keys and advertisement
    // Logging
    DWORD              fLoggingEnabled; // is logging enabled?
    CCompletionPort *  pIOCP;           // completion port for async file logger
    CXomFileTarget     xomLogfile;      // "borrowing" the xmgmt logfile system
} g_SgLspGlobals;

extern ULONGLONG g_qwSystemTimeOffset;

// -------------------------------------------------------------------------------------
// SgLspInit
// Initialize LSP specific data-structures and objects
// -------------------------------------------------------------------------------------

BOOL SgLspInit()
{
    HRESULT hr = S_OK;
    BOOL ret = FALSE;
    
    memset(&g_SgLspGlobals, 0, sizeof(g_SgLspGlobals));

    // Create completion port for logging
    
    hr = CCompletionPort::CreateInstance(
        0,                          // Concurrency
        1,                          // Max thread count
        THREAD_PRIORITY_HIGHEST,    // Priority
        &g_SgLspGlobals.pIOCP);     // out
    if (FAILED(hr))
    {
        TraceSz(Config, "SgLspInit: Failed to create completion port, hr=0x%08X", hr);
        goto Exit;
    }
    
    ret = TRUE;

Exit: 
    return ret;
}

// -------------------------------------------------------------------------------------
// SgLspConfig
// Configure LSP data-structures and objects
// -------------------------------------------------------------------------------------

BOOL SgLspConfig(CCfgInfo* pci)
{

#ifdef SG_FEATURE_INSTRUMENTATION
    return TRUE;
#endif
    
    TraceSz(Config, "SgLspConfig:");

    BOOL        ret         = FALSE;
    HRESULT     hr          = S_OK;
    CTitleInfo* pTitleInfo  = NULL;
    CLspProxy   lspproxy;

    BOOL        fLoggingEnabled             = FALSE;
    DWORD       dwLogRotationTimeInMinutes  = 0;
    DWORD       dwLogRotationSizeInBytes    = 0;
    CHAR        szLoggingPath[MAX_PATH];
    CSmallStr   strLogParams;

    //
    // Get some settings:
    //
    // RefreshIntervalInSeconds
    // RefreshRetryIntervalInSeconds
    // GetSiteInfoFromLive
    // AdvertiseOnLive
    // AdvertiseIp
    // 

    UINT cRefreshIntervalInTicks;
    if(!pci->GetVar("RefreshIntervalInSeconds", &cRefreshIntervalInTicks, 10, 60 * 60, 60))
    {
        goto Exit;
    }
    g_SgLspGlobals.cRefreshIntervalInTicks = cRefreshIntervalInTicks * TICKS_PER_SECOND;
    
    TraceSz(Config, "  Configured site and presence refresh interval to %u seconds",
             g_SgLspGlobals.cRefreshIntervalInTicks / TICKS_PER_SECOND);


    UINT cRetryIntervalInSeconds;
    if(!pci->GetVar("RefreshRetryIntervalInSeconds", &cRetryIntervalInSeconds, 5, 60 * 60, 10))
    {
        goto Exit;
    }
    g_SgLspGlobals.cRetryIntervalInTicks = cRetryIntervalInSeconds * TICKS_PER_SECOND;

    TraceSz(Config, "  Configured site and presence retry interval to %u seconds",
             g_SgLspGlobals.cRetryIntervalInTicks / TICKS_PER_SECOND);

    
    if(!pci->GetVar("GetSiteInfoFromLive", &g_SgLspGlobals.fGetSiteInfoFromLive, 0, 1, 1))
    {
        goto Exit;
    }

    TraceSz(Config, "  Configured server to%s get site info from Live (GetSiteInfoFromLive)",
             g_SgLspGlobals.fGetSiteInfoFromLive ? "" : " NOT");
    
   
    if(!pci->GetVar("AdvertiseOnLive", &g_SgLspGlobals.fAdvertiseOnLive, 0, 1, 1))
    {
        goto Exit;
    }

    TraceSz(Config, "  Configured server to%s advertise on Live (AdvertiseOnLive)",
             g_SgLspGlobals.fAdvertiseOnLive ? "" : " NOT");
   

    g_SgLspGlobals.ipaAdvertise = 0;

    if (g_SgLspGlobals.fAdvertiseOnLive)
    {
        if(pci->FindNonList("AdvertiseIp", NULL, FALSE))
        {
            if(!pci->GetIpAddr("AdvertiseIp", &g_SgLspGlobals.ipaAdvertise, FALSE, FALSE))
            {
                goto Exit;
            }
        }
        else
        {
            // if config did not specify which IP should be used to advertise, 
            // we're going to use the ip of the first Internet transport

            for (UINT iTrans = 0; iTrans < g_cTransInfo; ++iTrans)
            {
                CTransInfo * ptrans = &g_pTransInfo[iTrans];

                if (ptrans->_dwType == TRANSTYPE_INTERNET)
                {
                    g_SgLspGlobals.ipaAdvertise = ptrans->_ipa;
                    break;
                }
            }
        }

        TraceSz(Config, "  Configured server to advertise as %s", 
                 g_SgLspGlobals.ipaAdvertise.Str());
    }

    //
    // read title configuration
    //
    
    UINT cTitleInfo = pci->Count("Title");
    if (cTitleInfo == 0 && g_SgLspGlobals.fAdvertiseOnLive)
    {
        // No titles only fatal if trying to advertise on live. Otherwise optional.
        SgEventSz(CONFIG_WARNING, "line %d. No 'Title' entries found. This is fatal "
                   "only if AdvertiseOnLive is set.", 
                   pci->_csName._iLine);
        goto Exit;
    }
    else if (cTitleInfo == 0)
    {
        TraceSz(Config, "  No titles found."); 
    }
    else if (cTitleInfo > 0)
    {

        pTitleInfo = (CTitleInfo *)SgMemAllocZ(cTitleInfo*sizeof(CTitleInfo), 
                                               PTAG_CTitleInfo);

        if (!pTitleInfo)
        {
            SgEventSz(CONFIG_WARNING, 
                       "Failed to allocate title-info structures for %u items", cTitleInfo);
            goto Exit;
        }

        CCfgInfo * pciT = NULL;
        for (UINT i = 0; i < cTitleInfo; i++)
        {
            pciT = pci->FindList("Title", pciT, TRUE);
            if (!pciT->GetNum("TitleId", (UINT *)&pTitleInfo[i]._dwTitleId, TRUE))
            {
                goto Exit;
            }

            CCfgInfo * pciUser = pciT->FindNonList("UserData", NULL, FALSE);
            if (pciUser != NULL)
            {
                if (pciUser->_csValue._cch >= ARRAY_SIZE(pTitleInfo[i]._szUserData))
                {
                    SgEventSz(CONFIG_ERROR, "line %u. UserData exceeds %u characters.",
                               pci->_csName._iLine, ARRAY_SIZE(pTitleInfo[i]._szUserData)-1);
                    goto Exit;
                }

                memcpy(pTitleInfo[i]._szUserData, pciUser->_csValue._pch, 
                       pciUser->_csValue._cch * sizeof(WCHAR));

                pTitleInfo[i]._szUserData[pciUser->_csValue._cch] = 0;
            }
        }

        g_SgLspGlobals.lockTitleInfo.Lock();
        if (g_SgLspGlobals.pTitleInfo)
        {
            SgMemFree(g_SgLspGlobals.pTitleInfo);
        }
        g_SgLspGlobals.pTitleInfo = pTitleInfo;
        g_SgLspGlobals.cTitleInfo = cTitleInfo;
        pTitleInfo = NULL;
        g_SgLspGlobals.lockTitleInfo.Unlock();

        if(Tag(Config))
        {
            TraceSz(Config, "  Titles:");

            for(UINT i = 0; i < g_SgLspGlobals.cTitleInfo; i++)
            {
                TraceSz(Config, "    0x%08x : %s", 
                         g_SgLspGlobals.pTitleInfo[i]._dwTitleId,
                         g_SgLspGlobals.pTitleInfo[i]._szUserData);
            }
        }
    }

    //
    // read LSP-proxy configuration
    //

    CCfgInfo * pciProxy = pci->FindList("LspProxy", NULL, FALSE);

    if (pciProxy == NULL && 
        (g_SgLspGlobals.fAdvertiseOnLive ||
         g_SgLspGlobals.fGetSiteInfoFromLive))
    {
        SgEventSz(CONFIG_ERROR, "line %u. No LspProxy section found. This is required "
                   "in order to communicate with Live.", pci->_csName._iLine);
        goto Exit;
    }
    else if (pciProxy == NULL)
    {
        // Optional, but you'd better specify a local site key, and not be trying to 
        // communicate with Live.
        TraceSz(Config, "  No LspProxy section found.");
    }
    else
    {

        if (!pciProxy->GetIpAddr("Ip", &lspproxy._ipa, TRUE))
        {
            goto Exit;
        }

        if (!pciProxy->GetIpPort("Port", &lspproxy._ipport, FALSE))
        {
            lspproxy._ipport = HTONS(8000);
        }

        DWORD dwSiteId;
        if (!pciProxy->GetNum("SiteId", &dwSiteId, TRUE))
        {
            goto Exit;
        }

        if(dwSiteId < 100)
        {
            SgEventSz(CONFIG_ERROR, "LspProxy.SiteId must be >= 100");
            goto Exit;
        }
        lspproxy._dwSiteId = dwSiteId;

        // Has something changed (new config, or reconfig)?
        if (0 != memcmp(&lspproxy, &g_SgLspGlobals.lspproxy, sizeof(CLspProxy)))
        {
            // Set the global
            g_SgLspGlobals.lockProxy.Lock();
            g_SgLspGlobals.lspproxy = lspproxy;
            g_SgLspGlobals.lockProxy.Unlock();
        }

        TraceSz(Config,  "  LSP Proxy:");
        TraceSz(Config, "    _ipa      %s", lspproxy._ipa.Str());
        TraceSz(Config, "    _ipport   %u", HTONS(lspproxy._ipport));
        TraceSz(Config, "    _dwSiteId %u (0x%X)", lspproxy._dwSiteId, lspproxy._dwSiteId);
    }

    //
    // Configure logging. It's optional, based on the "LoggingEnabled setting".
    //
   
    // Get settings:
    // LoggingEnabled
    // LoggingPath
    // LoggingRotationTimeInMinutes
    // LoggingRotationSizeInBytes


    if(!pci->GetVar("LoggingEnabled", &g_SgLspGlobals.fLoggingEnabled, 0, 1, 0))
    {
        goto Exit;
    }

    TraceSz(Config, "  Logging is%s enabled (LoggingEnabled)",
             g_SgLspGlobals.fLoggingEnabled ? "" : " NOT");

    if (g_SgLspGlobals.fLoggingEnabled)
    {
        if(!pci->GetString("LoggingPath", szLoggingPath, ARRAY_SIZE(szLoggingPath)-1, TRUE))
        {
            SgEventSz(CONFIG_ERROR, "Setting LoggingPath not found. It is required if LoggingEnabled=1.");
            goto Exit;
        }

        // Min is 1 minute, max is 28 days, default is 1 hour
        if(!pci->GetVar("LoggingRotationTimeInMinutes", &dwLogRotationTimeInMinutes, 1, 40320, 60))
        {
            goto Exit;
        }
        TraceSz(Config, "  Logging rotation time is %u minutes (LoggingRotationTimeInMinutes)", dwLogRotationTimeInMinutes);

        // Min is 1KB (really?), max is 2GB (really?), default is 1GB
        if(!pci->GetVar("LoggingRotationSizeInBytes", &dwLogRotationSizeInBytes, 1000, 2000000000, 1000000000))
        {
            goto Exit;
        }
        TraceSz(Config, "  Logging rotation size is %u bytes (%u MB) (LoggingRotationSizeInBytes)", dwLogRotationSizeInBytes, dwLogRotationSizeInBytes / 1000000);

        // Build params string for the XomFileTarget. This is kind of ghetto, but 
        // minimizes changes to CXomFileTarget.

        // Sample xmgmt log target param:
        // Prefix=#LOGROOT#\app\#COMPONENT#\#MACHINE#.#COMPONENT#.;RotationTime=60;RotationSize=1000000000
        strLogParams.Format("Prefix=%s\\LSPSG.;RotationTime=%u;RotationSize=%u",
                            szLoggingPath,
                            dwLogRotationTimeInMinutes,
                            dwLogRotationSizeInBytes);

        // Initialize or re-initialize the log target... almost there!
        if (!g_SgLspGlobals.xomLogfile.IsInitialized())
        {
            // First-time intialization
            hr = g_SgLspGlobals.xomLogfile.Init(g_SgLspGlobals.pIOCP, strLogParams.cstr());
            if (FAILED(hr))
            {
                SgEventSz(CONFIG_ERROR, "Failed to initialize CXomFileTarget. Params: %s, hr: 0x%X",
                          strLogParams.cstr(), hr);
                goto Exit;
            }
            TraceSz(Config, "  Successfully initialized logfile. Params:");
            TraceSz(Config, "    %s", strLogParams.cstr());
        }
        else
        {
            // Re-initialization
            hr = g_SgLspGlobals.xomLogfile.ResetTargetWithParams(strLogParams.cstr());
            if (FAILED(hr))
            {
                SgEventSz(CONFIG_ERROR, "Failed to re-initialize CXomFileTarget. Params: %s, hr: 0x%X",
                          strLogParams.cstr(), hr);
                goto Exit;
            }
            TraceSz(Config, "  Successfully re-initialized logfile. Params:");
            TraceSz(Config, "    %s", strLogParams.cstr());
        }

    }

    //
    // if we need to talk to Live, then we need to initialize winhttp (only once), and 
    // reschedule the refresh timer, since we may have never scheduled it in the first 
    // place.
    //

    if (g_SgLspGlobals.fAdvertiseOnLive ||
        g_SgLspGlobals.fGetSiteInfoFromLive)
    {
        //
        // Initialize WinHTTP client
        //

        if(g_SgLspGlobals.hInternet == NULL)
        {
            g_SgLspGlobals.hInternet = WinHttpOpen(L"LSP Security Gateway", 
                                                   WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 
                                                   NULL,  NULL, 0 );

            if (g_SgLspGlobals.hInternet == NULL)
            {
                DWORD dwErr = GetLastError();
                SgEventSz(INTERNAL_ERROR, "Couldn't open wininet handle. Error = %u %s",
                           dwErr, SgLspWinHttpErrorStr(dwErr));
                goto Exit;
            }
        }

        //
        // schedule the refresh timer to execute as soon as possible. this will cancel any 
        // prior appointments.
        //

        SgTimerSet(&g_SgLspGlobals.refreshTimer, SgLspTimer, 
                   SgTimerTick(), TRUE);
    }

    ret = TRUE;

Exit:

    if(pTitleInfo)
    {
        SgMemFree(pTitleInfo);
    }

    return ret;
}

// -------------------------------------------------------------------------------------
// SgLspTerm
// Terminate LSP specific stuff
// -------------------------------------------------------------------------------------
void SgLspTerm()
{
    // release resources

    if (g_SgLspGlobals.hInternet != NULL)
    {
        WinHttpCloseHandle(g_SgLspGlobals.hInternet);
        g_SgLspGlobals.hInternet = NULL;
    }

    if (g_SgLspGlobals.pTitleInfo != NULL)
    {
        SgMemFree(g_SgLspGlobals.pTitleInfo);
        g_SgLspGlobals.pTitleInfo = NULL;
        g_SgLspGlobals.cTitleInfo = 0;
    }

    // reset

    memset(&g_SgLspGlobals, 0, sizeof(g_SgLspGlobals));

    // there is no need to cancel the timer. It will be gracefully cancelled when the SG 
    // shuts down.
}

// -------------------------------------------------------------------------------------
// SgLspLookupQueryKey
// Look up legacy key to be used in Ts key-exchange
// -------------------------------------------------------------------------------------
BOOL SgLspLookupQueryKey(XNKID * pxnkid, BYTE * pbkey)
{
    BOOL ret = FALSE;

    g_SgLspGlobals.lockKeyReg.Lock();

    if(memcmp(pxnkid, &g_SgLspGlobals.keyreg._xnkid, sizeof(*pxnkid)) == 0)
    {
        memcpy(pbkey, g_SgLspGlobals.keyreg._abKeySha, 
               sizeof(g_SgLspGlobals.keyreg._abKeySha));

        ret = TRUE;
    }

    g_SgLspGlobals.lockKeyReg.Unlock();

    return ret;
}

// -------------------------------------------------------------------------------------
// SgLspTimer
// Executes periodically to refresh site info and Live advertisement
// -------------------------------------------------------------------------------------
void SgLspTimer(CTimer* pTimer)
{
    DWORD cRefreshIntervalInTicks = g_SgLspGlobals.cRefreshIntervalInTicks;

    //
    // refresh site information
    //

    SgLspRefreshSiteInfo();

    if(g_cSiteInfo != 0)
    {
        //
        // refresh advertisement on Live - but only do that if we were able to retrieve 
        // site information at least once, otherwise we wouldn't be able to connect to the 
        // consoles that discovered this SG
        //

        if(!SgLspRefreshAdvertisement())
        {
            //
            // we want to try again as soon as possible - otherwise our current 
            // advertisement could expire and new consoles wouldn't be able to discover 
            // this SG
            //

            cRefreshIntervalInTicks = g_SgLspGlobals.cRetryIntervalInTicks;
        }
    }
    else
    {
        // 
        // we don't have any keys - until we do, the SG can't connect to 
        // consoles. Try again as soon as possible.
        //

        cRefreshIntervalInTicks = g_SgLspGlobals.cRetryIntervalInTicks;
    }

    //
    // reschedule
    //

    SgTimerSet(&g_SgLspGlobals.refreshTimer, SgLspTimer, 
               SgTimerTick() + cRefreshIntervalInTicks, TRUE);

    return;
}

// -------------------------------------------------------------------------------------
// SgLspRefreshSiteInfo
// Refresh site keys
// -------------------------------------------------------------------------------------
static void SgLspRefreshSiteInfo()
{
    TraceSz(LspRefresh, "Refreshing site information:");

    if(!g_SgLspGlobals.fGetSiteInfoFromLive)
    {
        TraceSz(LspRefresh, "  GetSiteInfo is disabled. %u site(s) currently configured.", g_cSiteInfo);
        return;
    }

    LspSiteInfo siteInfo;
    DWORD cbRead;
    ULONGLONG qwNow;
    BOOL ok;

    memset(&siteInfo, 0, sizeof(siteInfo));

    //
    // Make the request. The request body is a single DWORD with the site id in 
    // little-endian
    //
    
    g_SgLspGlobals.lockProxy.Lock();
    DWORD dwSite = g_SgLspGlobals.lspproxy._dwSiteId;
    g_SgLspGlobals.lockProxy.Unlock();

    ok = SgLspPostHttpRequest(L"/LiveProxy/GetSiteInfo.aspx", sizeof(dwSite), &dwSite,
                              sizeof(siteInfo), &siteInfo, &cbRead);

    if(!ok)
    {
        SgEventSz(LSP_REFRESH_SITE_INFO_ERROR, 
                  "A previous event should contain more information");
        return;
    }
    
    DWORD dwSizeGoodResponse = offsetof(LspSiteInfo, _aKeys) +
                               siteInfo._cKeys * sizeof(LspKeyInfo);

    if(cbRead < offsetof(LspSiteInfo, _aKeys) ||
       cbRead != dwSizeGoodResponse)
    {
        SgEventDataSz(LSP_REFRESH_SITE_INFO_ERROR, cbRead, &siteInfo, 
                       "Live returned response with invalid size %u", cbRead);
        return;
    }
   
    //
    // adjust the clock - the SG-LSP clock must be in sync with Live otherwise 
    // we might start seeing problems cracking open the KDC tickets
    //
    
    qwNow = SgGetSystemTime();

    g_qwSystemTimeOffset += siteInfo._liTime.QuadPart - qwNow;
    
    TraceSz(LspRefresh, "  Local time %I64X, LSP time %I64X, cKeys %d", 
             qwNow, siteInfo._liTime, siteInfo._cKeys);

    //
    // update the site keys. These are the keys used to crack open the Kerberos 
    // tickets
    //

    if (siteInfo._cKeys == 0 || siteInfo._cKeys > ARRAY_SIZE(siteInfo._aKeys))
    {
        SgEventSz(LSP_REFRESH_SITE_INFO_ERROR, 
                   "SiteInfo: Received %u keys from Live (1-%u expected)",
                   siteInfo._cKeys, ARRAY_SIZE(siteInfo._aKeys));
        return;
    }

    // build a new list of keys
    LIST_ENTRY  lh;
    CSiteInfo * pSiteInfo;
    
    InitializeListHead(&lh);

    for (UINT i = 0; i < siteInfo._cKeys; i++)
    {
        LspKeyInfo* pKeyInfo = &siteInfo._aKeys[i];

        pSiteInfo = (CSiteInfo *)SgMemAllocZ(sizeof(CSiteInfo), PTAG_CSiteInfo);

        if (pSiteInfo == NULL)
        {
            SgEventSz(LSP_REFRESH_SITE_INFO_ERROR, 
                       "Out of memory allocating CSiteInfo (%d bytes)", sizeof(CSiteInfo));
            return;
        }

        pSiteInfo->_dwSiteId    = dwSite;
        pSiteInfo->_dwVersion   = pKeyInfo->_dwVersion;
        
        C_ASSERT(sizeof(pSiteInfo->_abKey) == sizeof(pKeyInfo->_abKey));
        memcpy(pSiteInfo->_abKey, pKeyInfo->_abKey, sizeof(pSiteInfo->_abKey));

        TraceSz(LspRefresh, "  Site %u (0x%x), Version %u key configured", dwSite, dwSite, pSiteInfo->_dwVersion);

        InsertTailList(&lh, &pSiteInfo->_le);
    }

    LIST_ENTRY   lhOldKeys;
    LIST_ENTRY * ple;

    InitializeListHead(&lhOldKeys);
    
    g_lockSiteInfo.AcquireDpc();

    // remove the old keys

    while (!IsListEmpty(&g_leSiteInfo))
    {
        ple = RemoveHeadList(&g_leSiteInfo);
        InsertTailList(&lhOldKeys, ple);
    }

    // add the new keys

    while (!IsListEmpty(&lh))
    {
        ple = RemoveHeadList(&lh);
        InsertTailList(&g_leSiteInfo, ple);
    }

    g_cSiteInfo = siteInfo._cKeys;
    
    g_lockSiteInfo.ReleaseDpc();

    // release resources consumed by old keys

    while (!IsListEmpty(&lhOldKeys))
    {
        ple       = RemoveHeadList(&lhOldKeys);
        pSiteInfo = CONTAINING_RECORD(ple, CSiteInfo, _le);
        SgMemFree(pSiteInfo);
    }
}

// -------------------------------------------------------------------------------------
// SgLspRefreshAdvertisement
// Called periodically to refresh advertisement on Live
// -------------------------------------------------------------------------------------
static bool SgLspRefreshAdvertisement()
{
    TraceSz(LspRefresh, "Advertising on Live:");

    if(!g_SgLspGlobals.fAdvertiseOnLive)
    {
        TraceSz(LspRefresh, "  Advertise is disabled.");
        return true;
    }
    
    XNKID xnkid;
    XNKEY xnkey;
    BYTE abSiteKey[CBSITEKEY];
    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    DWORD dwSalt;
    DWORD ipaAdvertise = g_SgLspGlobals.ipaAdvertise;
    bool ok;

    //
    // Generate legacy key-exchange-key
    //
    // In a previous release of SG-LSP, this key was randomly generated on every refresh.  
    // We're changing this scheme to a deterministic model to support load-balancers: the 
    // console must be able to use the same key to connect to SGs behind the same VIP.
    //
    // Great, so the key has two components: the XNKID (8 bytes) which uniquely identifies 
    // the key and is sent in the clear during key-exchange and the XNKEY (16 bytes) which 
    // is the key itself. The following scheme will be used to generate this two 
    // components:
    //
    // xnkid = first 8 bytes of Hmac-Sha1(site-key, SALT_LSP_XNKID | advertise-ip)
    // xnkey = first 16 bytes of Hmac-Sha1(site-key, SALT_LSP_XNKEY | advertise_ip)
    //
    // Where:
    //
    //   site-key: is the the most recent site-key for this site
    //   advertise-ip: is the 4-byte ip address in big-endian (network) byte order that's 
    //   beging advertised to Live.
    //

    C_ASSERT(sizeof(abSiteKey) == sizeof(((CSiteInfo*)0)->_abKey));

    g_SgLspGlobals.lockProxy.Lock();
    DWORD dwSite = g_SgLspGlobals.lspproxy._dwSiteId;
    g_SgLspGlobals.lockProxy.Unlock();

    if(!SgLspCopyRecentSiteKey(dwSite, abSiteKey))
    {
        SgEventSz(INTERNAL_ERROR, "Can't find a site-key to generate legacy key for site %u (0x%X)", 
                  dwSite, dwSite);
        return false;
    }

    // generate XNKID

    dwSalt = SALT_LSP_XNKID;
    XcHMAC4(abSiteKey,              sizeof(abSiteKey),
            (BYTE*)&dwSalt,         sizeof(dwSalt),
            (BYTE*)&ipaAdvertise,   sizeof(ipaAdvertise),
            NULL,                   0,
            NULL,                   0,
            abHash);

    C_ASSERT(sizeof(abHash) >= sizeof(xnkid));
    memcpy(&xnkid, abHash, sizeof(xnkid));

    xnkid.ab[0] = XNET_XNKID_ONLINE_TITLESERVER;

    // generate XNKEY

    dwSalt = SALT_LSP_XNKEY;

    XcHMAC4(abSiteKey,              sizeof(abSiteKey),
            (BYTE*)&dwSalt,         sizeof(dwSalt),
            (BYTE*)&ipaAdvertise,   sizeof(ipaAdvertise),
            NULL,                   0,
            NULL,                   0,
            abHash);

    C_ASSERT(sizeof(abHash) >= sizeof(xnkey));
    memcpy(&xnkey, abHash, sizeof(xnkey));

    // the XNKID and the XNKEY is what we send up the wire, but what it's really used in 
    // the key-exchange is Hmac-Sha1(xnkey, xnkid | xnkey)

    XcHMAC4((BYTE*)&xnkey,          sizeof(xnkey),
            (BYTE*)&xnkid,          sizeof(xnkid),
            (BYTE*)&xnkey,          sizeof(xnkey),
            NULL,                   0,
            NULL,                   0,
            abHash);

    // replace legacy key
    
    g_SgLspGlobals.lockKeyReg.Lock();
    CKeyReg* pKeyReg = &g_SgLspGlobals.keyreg;
    
    memcpy(&pKeyReg->_xnkid,    &xnkid, sizeof(xnkid));
    memcpy(&pKeyReg->_xnkey,    &xnkey, sizeof(xnkey));
    memcpy(pKeyReg->_abKeySha,  abHash, sizeof(pKeyReg->_abKeySha));

    g_SgLspGlobals.lockKeyReg.Unlock();
    
    // advertise

    ok = true;
    for (UINT i = 0; i < g_SgLspGlobals.cTitleInfo; i++)
    {
        // Make a local copy of each CTitleInfo. We don't want to hold the lock across the 
        // SgLspAdvertise call, as it is an HTTP post and could take a while. The cost of 
        // a small number of memcpys is acceptable. Each CTitleInfo is 204 bytes.
        
        g_SgLspGlobals.lockTitleInfo.Lock();
        if (g_SgLspGlobals.pTitleInfo == NULL || i >= g_SgLspGlobals.cTitleInfo)
        {
            // This array could have changed upon each iteration here; catch those cases 
            // and bail if the array shrunk. If it grew, or our 'future' entries changed, 
            // that's ok -- just process them.
            g_SgLspGlobals.lockTitleInfo.Unlock();
            break;
        }
        CTitleInfo localTitleInfo = g_SgLspGlobals.pTitleInfo[i]; 
        g_SgLspGlobals.lockTitleInfo.Unlock();

        CTitleInfo* pTitleInfo = &localTitleInfo;

        DWORD dwTtlInSeconds;
        dwTtlInSeconds = (2 * g_SgLspGlobals.cRefreshIntervalInTicks) / TICKS_PER_SECOND;

        TraceSz(LspRefresh, 
                 "  Advertising title-id 0x%08x, ip %s, ttl %u user-data '%s'",
                 pTitleInfo->_dwTitleId, 
                 g_SgLspGlobals.ipaAdvertise.Str(),
                 dwTtlInSeconds,
                 pTitleInfo->_szUserData);

        if(!SgLspAdvertise(pTitleInfo->_dwTitleId,
                           NTOHL(g_SgLspGlobals.ipaAdvertise),
                           dwTtlInSeconds,
                           &xnkid,
                           &xnkey,
                           pTitleInfo->_szUserData))
        {
            //
            // one of the advertisements failed and we want to return that. But 
            // let's keep going. Maybe the other ones will succeed.
            //

            ok = false;
        }
    }

    return ok;
}

#pragma pack(push, 1)
struct LspAdvertiseRequest
{
#define XONLINE_LSP_MAX_USER_DATA_LEN         199
#define XONLINE_LSP_MAX_LSP_INFO              100
#define XONLINE_LSP_XNKID_LEN                 8
#define XONLINE_LSP_XNKEY_LEN                 16
    
    DWORD dwTitleId;
    DWORD dwIpSgLsp;
    DWORD dwTtlInSeconds;
    DWORD dwFlags;
    BYTE  xnkid[XONLINE_LSP_XNKID_LEN];
    BYTE  xnkey[XONLINE_LSP_XNKEY_LEN];
    WORD  wUserDataLength;
    CHAR  achUserData[XONLINE_LSP_MAX_USER_DATA_LEN];
};
#pragma pack(pop)

// -------------------------------------------------------------------------------------
// SgLspAdvertise
// Send request to Live to update advertisement information
// -------------------------------------------------------------------------------------
static bool SgLspAdvertise(
    DWORD dwTitleId,
    DWORD dwIpSgLsp,
    DWORD dwTtlInSeconds,
    XNKID* pXnkid,
    XNKEY* pXnkey,
    LPCSTR pszUserData
)
{
    bool ok;
    DWORD cbRead;

    //
    // fill out request
    //

    LspAdvertiseRequest request;
    memset(&request, 0, sizeof(request));

    request.dwTitleId       = dwTitleId;
    request.dwIpSgLsp       = dwIpSgLsp;
    request.dwTtlInSeconds  = dwTtlInSeconds;
    request.dwFlags         = 0; // reserved
    
    C_ASSERT(sizeof(request.xnkid) == sizeof(XNKID));
    memcpy(request.xnkid, pXnkid, sizeof(request.xnkid));
    
    C_ASSERT(sizeof(request.xnkey) == sizeof(XNKEY));
    memcpy(request.xnkey, pXnkey, sizeof(request.xnkey));

    request.wUserDataLength = strlen(pszUserData);
    Assert(request.wUserDataLength <= ARRAY_SIZE(request.achUserData));
    memcpy(request.achUserData, pszUserData, request.wUserDataLength);

    //
    // post the request
    //
   
    ok = SgLspPostHttpRequest(L"/LiveProxy/LspAdvertise.aspx", sizeof(request), &request,
                              0, NULL, &cbRead);

    if(!ok)
    {
        SgEventSz(LSP_ADVERTISE_ERROR,
                  "A previous event should contain more information");
    }

    return ok;
}

// -------------------------------------------------------------------------------------
// SgLspCopyRecentSiteKey
// Copy to pbSiteKey the key for dwSiteId with biggest version
// -------------------------------------------------------------------------------------
bool SgLspCopyRecentSiteKey(DWORD dwSiteId, BYTE* pbSiteKey)
{
    LIST_ENTRY* ple         = NULL;
    CSiteInfo*  pSiteInfo   = NULL;
    CSiteInfo*  pWinner     = NULL;
    DWORD       i;

    g_lockSiteInfo.AcquireDpc();

    //
    // iterate through the list of sites and select the entry with the biggest version for 
    // dwSiteId
    //

    ple = g_leSiteInfo.Flink;

    for(i=0; i < g_cSiteInfo; i++)
    {
        pSiteInfo = CONTAINING_RECORD(ple, CSiteInfo, _le);

        if(pSiteInfo->_dwSiteId == dwSiteId)
        {
            if(!pWinner || pSiteInfo->_dwVersion > pWinner->_dwVersion)
            {
                pWinner = pSiteInfo;
            }
        }

        ple = ple->Flink;   
    }
    
    g_lockSiteInfo.ReleaseDpc();

    if(pWinner)
    {
        // copy the key
        memcpy(pbSiteKey, pSiteInfo->_abKey, ARRAY_SIZE(pSiteInfo->_abKey));
        return true;
    }
    else
    {
        // no entries found for dwSiteId
        return false;
    }
}

// ----------------------------------------------------------------------------
// SgLspPostHttpRequest
// Post HTTP request to LSP-Proxy
// ----------------------------------------------------------------------------
static bool SgLspPostHttpRequest(
    LPCWSTR     pszPath,
    DWORD       cbRequest,
    void*       pbRequest,
    DWORD       cbResponse,
    void*       pbResponse,
    DWORD*      pcbResponseRead
)
{
    HINTERNET       hConnect = NULL;
    HINTERNET       hRequest = NULL;
    WCHAR           szResponseData[2000];
    DWORD           cbRead;
    BOOL            ok;
    CLargeStr       errorInfo;
    DWORD           error = ERROR_SUCCESS;    

    g_SgLspGlobals.lockProxy.Lock();
    CIpAddr ipaProxy = g_SgLspGlobals.lspproxy._ipa; 
    CIpPort ipportProxy = g_SgLspGlobals.lspproxy._ipport; 
    g_SgLspGlobals.lockProxy.Unlock();

    // 
    // specify the HTTP server
    //
    
    CSmallWStr  host;
    host.Format(L"%S", CStrUtil().FormatIpN(ipaProxy));
    hConnect = WinHttpConnect(g_SgLspGlobals.hInternet, host.cstr(), 
                              NTOHS(ipportProxy), 0);

    if(!hConnect)
    {
        error = GetLastError();
        goto Exit;
    }

    //
    // create an HTTP request handle
    //
    
    hRequest = WinHttpOpenRequest(hConnect, L"POST", pszPath,
                                  L"HTTP/1.1", WINHTTP_NO_REFERER, 
                                  WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    if(!hRequest)
    {
        error = GetLastError();
        goto Exit;
    }

    // We don't want keep-alive for the SG to PROXY link. The proxy expects the connection 
    // to go away each time, and in fact enforces it by closing the socket. We need the SG 
    // (WinHttp) to follow the same protocol. This is how we do that.
    DWORD dwFeature = WINHTTP_DISABLE_KEEP_ALIVE;
    if (!WinHttpSetOption(
            hRequest,
            WINHTTP_OPTION_DISABLE_FEATURE,
            &dwFeature,
            sizeof(dwFeature)))
    {
        DWORD dwErr = GetLastError();
        SgEventSz(INTERNAL_ERROR, 
                   "Failed to set option WINHTTP_DISABLE_KEEP_ALIVE. This is non-fatal but "
                   "may make the connection to the proxy unreliable. Please investigate. "
                   "Error = %u %s",
                   dwErr, SgLspWinHttpErrorStr(dwErr));
    }

    //
    // send the request data
    //
    
    ok = WinHttpSendRequest(hRequest, L"Content-Type: xon/0\r\n", -1L, pbRequest, 
                            cbRequest, cbRequest, NULL);

    if(!ok)
    {
        error = GetLastError();
        goto Exit;
    }
    
    //
    // wait for the response
    //
    
    ok = WinHttpReceiveResponse(hRequest, NULL);
    if(!ok)
    {
        error = GetLastError();
        goto Exit;
    }

    //
    // read status from the response
    //
    
    cbRead = sizeof(szResponseData);
    ok = WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE, WINHTTP_HEADER_NAME_BY_INDEX,
                             szResponseData, &cbRead, 0);

    if(!ok)
    {
        error = GetLastError();
        goto Exit;
    }
    szResponseData[ARRAY_SIZE(szResponseData)-1] = 0;

    if(!CWSTR(L"200").IsEqualTo(szResponseData))
    {
        errorInfo.Format("Request-Status: %S\n", szResponseData);

        //
        // read the whole response header for logging
        //

        cbRead = sizeof(szResponseData);
        ok = WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                                 WINHTTP_HEADER_NAME_BY_INDEX, szResponseData, &cbRead,
                                 WINHTTP_NO_HEADER_INDEX);

        if(ok)
        {
            szResponseData[ARRAY_SIZE(szResponseData)-1] = 0;
            errorInfo.Format("%S\n", szResponseData);

            ok = WinHttpReadData(hRequest, szResponseData, sizeof(szResponseData), 
                                 &cbRead);

            if(ok)
            {
                szResponseData[__min(cbRead, sizeof(szResponseData)-1)] = 0;
                errorInfo.CopyFrom((LPCSTR)szResponseData);
            }
        }

        error = ERROR_FUNCTION_FAILED;
        goto Exit;
    }
    
    //
    // read response bytes
    //

    ok = WinHttpReadData(hRequest, pbResponse, cbResponse, pcbResponseRead);

    if(!ok)
    {
        error = GetLastError();
        goto Exit;
    }

    error = ERROR_SUCCESS;

Exit:

    if(hRequest != NULL)
    {
        WinHttpCloseHandle(hRequest);
    }

    if(hConnect != NULL)
    {
        WinHttpCloseHandle(hConnect);
    }

    if(error != ERROR_SUCCESS)
    {
        //
        // log an error message with as much detail as we were able to gather
        //
        
        CLargeStr errorMessage;
        
        errorMessage.Format("Win32-Error: %u %s\n",
                            error, SgLspWinHttpErrorStr(error));
                            
        errorMessage.Format("Proxy: %s\n",
                            CStrUtil().FormatIpPortN(ipaProxy, 
                                                     ipportProxy));
        
        errorMessage.Format("Path: %S\n", pszPath);

        errorMessage.CopyFrom(errorInfo);

        SgEventSz(LSP_PROXY_FAIL, "%s", errorMessage.cstr());
    }

    return ERROR_SUCCESS == error;
}

// ----------------------------------------------------------------------------
// SgLspWinHttpErrorStr
// Return the "name" of a WinHTTP error
// ----------------------------------------------------------------------------

static LPCSTR SgLspWinHttpErrorStr(DWORD err)
{
#define DE(x) case (x): return "("#x")"
    switch (err)
    {
        DE(ERROR_WINHTTP_OUT_OF_HANDLES);
        DE(ERROR_WINHTTP_TIMEOUT);
        DE(ERROR_WINHTTP_INTERNAL_ERROR);
        DE(ERROR_WINHTTP_INVALID_URL);
        DE(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
        DE(ERROR_WINHTTP_NAME_NOT_RESOLVED);
        DE(ERROR_WINHTTP_INVALID_OPTION);
        DE(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
        DE(ERROR_WINHTTP_SHUTDOWN);
        DE(ERROR_WINHTTP_LOGIN_FAILURE);
        DE(ERROR_WINHTTP_OPERATION_CANCELLED);
        DE(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
        DE(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
        DE(ERROR_WINHTTP_CANNOT_CONNECT);
        DE(ERROR_WINHTTP_CONNECTION_ERROR);
        DE(ERROR_WINHTTP_RESEND_REQUEST);
        DE(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
        DE(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
        DE(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
        DE(ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND);
        DE(ERROR_WINHTTP_HEADER_NOT_FOUND);
        DE(ERROR_WINHTTP_INVALID_SERVER_RESPONSE);
        DE(ERROR_WINHTTP_INVALID_QUERY_REQUEST);
        DE(ERROR_WINHTTP_HEADER_ALREADY_EXISTS);
        DE(ERROR_WINHTTP_REDIRECT_FAILED);
        DE(ERROR_WINHTTP_NOT_INITIALIZED);
        DE(ERROR_WINHTTP_SECURE_FAILURE);
    default:
        return("");
    }
#undef DE
}

// -------------------------------------------------------------------------------------
// SgLspLog
// Write a logline entry to the configured logfile. Currently, the pszArea parameter is 
// ignored, but it could be used in the future if needed.
// -------------------------------------------------------------------------------------
void SgLspLog(
    LPCSTR pszArea,
    LPCSTR pszFmt,
    ...
)
{
    FLOKEN NoFloken = { 0 };
    va_list args;
    va_start(args, pszFmt);
    SgLspLogFT(pszArea, NoFloken, pszFmt, args);
    va_end(args);
}

void SgLspLogFT(
    LPCSTR pszArea,
    FLOKEN& flowToken,
    LPCSTR pszFmt,
    ...
)
{
    // If logging is disabled, bail
    if (!g_SgLspGlobals.fLoggingEnabled)
    {
        return;
    }

    // Format the message
    va_list args;
    CLogFormatedMessage oMsg(flowToken, NULL);

    va_start(args, pszFmt);
    oMsg.FormatEx(pszFmt, args);
    va_end(args);

    // Log it
    g_SgLspGlobals.xomLogfile.Log(&oMsg);

}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgnatinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgnatinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// CNatInfo
// ---------------------------------------------------------------------------------------

BOOL         g_fPortTranslation;    // TRUE if source port translation is used
UINT         g_cPortsPerNatInfo;    // Number of source ports a CNatInfo can have mapped
UINT         g_cNatInfoPerIpAddr;   // Number of CNatInfo mapped by an IP address
UINT         g_cNatInfoPerTransInfo;// Number of CNatInfo mapped per trans info (typically 1 DMZ trans info)
UINT         g_cNatInfo;            // Number of CNatInfo structures allocated
UINT         g_cNatInfoValid;       // Number of valid CNatInfo structures
UINT         g_cTotalIpa;           // Number of total IP addresses configured
UINT         g_cValidIpa;           // Number of valid IP addresses configured
CNatInfo *   g_pNatInfo;            // Vector of all CNatInfo structures
DWORD        g_dwConnectionServerPortLimit; // Number of ports reserved for CONNECTION_SERVER traffic

BOOL SgNatInfoInit()
{
    Assert(g_fPortTranslation == FALSE);
    Assert(g_cPortsPerNatInfo == 0);
    Assert(g_cNatInfoPerIpAddr == 0);
    Assert(g_cNatInfoPerTransInfo == 0);
    Assert(g_cNatInfo == 0);
    Assert(g_cNatInfoValid == 0);
    Assert(g_cTotalIpa == 0);
    Assert(g_cValidIpa == 0);
    Assert(g_pNatInfo == NULL);
    return(TRUE);
}

void SgNatInfoTerm()
{
    SgMemFree(g_pNatInfo);

    g_fPortTranslation      = FALSE;
    g_cPortsPerNatInfo      = 0;
    g_cNatInfoPerIpAddr     = 0;
    g_cNatInfoPerTransInfo  = 0;
    g_cNatInfo              = 0;
    g_cNatInfoValid         = 0;
    g_cTotalIpa             = 0;
    g_cValidIpa             = 0;
    g_pNatInfo              = NULL;
}

BOOL SgNatInfoConfig(UINT cSpiInfo, UINT cPortsPerNatInfo)
{
    // Find all datacenter transports and count the number of IP addresses available.  Note
    // that if not all of the IP addresses in the range are valid for use, we will end up
    // with some CNatInfo that will not be placed on the free list for use.

    CTransInfo * pTransInfo;
    UINT         iTransInfo;
    UINT         cipaValid;

    UINT         cipaPerTrans = 0xFFFF;
    UINT         cPortsPerIpAddr = 65534; // Initially assume all except 0 (invalid) and 65535 (used for SGMSG traffic)

    // Figure out how many valid IP addresses we have per transport, and take the lowest where the number per
    // transport differs across network interfaces.
    for (iTransInfo = 0, pTransInfo = g_pTransInfo; iTransInfo < g_cTransInfo; ++iTransInfo, ++pTransInfo)
    {
        if (pTransInfo->_dwType == TRANSTYPE_DMZ)
        {
            UINT cipaValidTrans = 0;

            for (DWORD dwIpa = pTransInfo->_dwIpaBeg; dwIpa <= pTransInfo->_dwIpaEnd; ++dwIpa)
            {
                if (CIpAddr(HTONL(dwIpa)).IsValidAddr(pTransInfo->_ipaMask))
                    cipaValidTrans += 1;
            }

            if (cipaValidTrans == 0)
            {
                TraceSz(Config, "Config error: Network interface %d has no valid addresses configured.",
                         pTransInfo->_dwTransId);
                SgEventSz(CONFIG_ERROR, "Network interface %d has no valid addresses configured.",
                           pTransInfo->_dwTransId);
                return(FALSE);
            }

            cPortsPerIpAddr = min(cPortsPerIpAddr, (WORD)( pTransInfo->_wIpportEnd - pTransInfo->_wIpportBeg + 1 ) );

            // We must be able to hold an entire NatInfo's ports on a single IP address
            if (cPortsPerIpAddr < cPortsPerNatInfo)
            {
                TraceSz(Config, "Config error: Network interface %d does not have enough ports for the requested value of 'ClientPortLimit' (%u < %u).",
                         pTransInfo->_dwTransId, cPortsPerIpAddr, cPortsPerNatInfo);
                SgEventSz(CONFIG_ERROR, "Network interface %d does not have enough ports for the requested value of 'ClientPortLimit' (%u < %u).",
                           pTransInfo->_dwTransId, cPortsPerIpAddr, cPortsPerNatInfo);
                return(FALSE);
            }

            cipaPerTrans = min(cipaPerTrans, cipaValidTrans);
        }
    }

    Assert(cipaPerTrans < 0x10000);
    Assert(cPortsPerIpAddr < 65535);

    // The total number of valid IPs is the number per transport times the number of transports on the DMZ side
    cipaValid = cipaPerTrans * g_cTransInfoZ;

    // If the number of available IP addresses is not enough to handle the requested number
    // of clients, we need to turn on port translation.

    UINT    cNatInfoValid = 0;
    UINT    cbExtra1      = 0;
    UINT    cbExtra2      = 0;

    // cSpiInfo represents the requested number of clients that this SG should handle, a single CNatInfo represents
    // a single client, and cPortsPerNatInfo represents how many simultaneous requests a single client will be allowed
    // to have outstanding.
    if (cipaValid < cSpiInfo)
    {
        Assert(cPortsPerNatInfo > 0 && cPortsPerNatInfo <= (0x10000 - 2));

        // Turn on port translation since we don't have enough IP addresses to have a 1:1 mapping with clients
        g_fPortTranslation  = TRUE;
        g_cPortsPerNatInfo  = cPortsPerNatInfo;
        g_cNatInfoPerIpAddr = cPortsPerIpAddr / g_cPortsPerNatInfo;
        cNatInfoValid       = cipaValid * g_cNatInfoPerIpAddr;
        cbExtra1            = cPortsPerNatInfo * sizeof(CNatPort);
        cbExtra2            = cPortsPerNatInfo * sizeof(CNatPort *);

        // Fail if we still can't handle the requested number of clients, even with port translation
        if (cSpiInfo > cNatInfoValid)
        {
            TraceSz(Config, "Config error: The specified IP and port range is not enough to support the requested client limit (%u < %u).",
                     cNatInfoValid, cSpiInfo);
            SgEventSz(CONFIG_ERROR, "Config error: The specified IP and port range is not enough to support the requested client limit (%u < %u).",
                       cNatInfoValid, cSpiInfo);
            return(FALSE);
        }
    }
    else
    {
        g_fPortTranslation  = FALSE;
        g_cNatInfoPerIpAddr = 1; // Each client will get its very own IP address
        cNatInfoValid       = cipaValid;
    }

    // Limit the number of CNatInfo to twice the requested number of clients for each DMZ interface.
    // TODO: Why not limit to exactly cSpiInfo?
    cNatInfoValid = min(cNatInfoValid, cSpiInfo * 2 * g_cTransInfoZ);

    // Divide cNatInfoValid by g_cTransInfoZ and round up
    UINT cMaxNatInfoPerTrans = (cNatInfoValid + g_cTransInfoZ - 1) / g_cTransInfoZ;

    // Now compute the number of CNatInfo to allocate to generate cNatInfoValid
    // NOTE: cNatInfoValid is now used to track how many NatInfo are left to allocate among interfaces, cNatInfo tracks how
    // many NatInfo to allocate altogether.

    UINT cNatInfo = 0;

    for (iTransInfo = 0, pTransInfo = g_pTransInfo; iTransInfo < g_cTransInfo; ++iTransInfo, ++pTransInfo)
    {
        if (pTransInfo->_dwType == TRANSTYPE_DMZ)
        {
            UINT cMaxNatInfo = cMaxNatInfoPerTrans;

            for (DWORD dwIpa = pTransInfo->_dwIpaBeg; dwIpa <= pTransInfo->_dwIpaEnd; ++dwIpa)
            {
                if (CIpAddr(HTONL(dwIpa)).IsValidAddr(pTransInfo->_ipaMask))
                {
                    UINT cNatInfoThisAddr = min(min(cNatInfoValid, g_cNatInfoPerIpAddr), cMaxNatInfo);

                    cMaxNatInfo       -= cNatInfoThisAddr;
                    cNatInfoValid     -= cNatInfoThisAddr;
                    cNatInfo          += cNatInfoThisAddr;

                    if (cNatInfoValid == 0 || cMaxNatInfo == 0)
                        break;
                }
                else
                {
                    // We do this so that lookup can be accomplished by a simple offset calculation rather than a search.  There will
                    // be g_cNatInfoPerIpAddr on every address up to the last one we use.
                    cNatInfo += g_cNatInfoPerIpAddr;
                }
            }

            // Check for completion
            if (cNatInfoValid == 0)
                break;
        }
    }

    Assert(cNatInfoValid == 0);

    // Allocate the vector of CNatInfo now that we know how many we'll need

    g_pNatInfo = (CNatInfo *)SgMemAllocZ(cNatInfo * (sizeof(CNatInfo) + cbExtra1 + cbExtra2), PTAG_CNatInfo);

    if (g_pNatInfo == NULL)
    {
        TraceSz(Config, "Config error: Out of memory allocating vector of %d CNatInfo (%d bytes)",
                 cNatInfo, cNatInfo * (sizeof(CNatInfo) + cbExtra1 + cbExtra2));
        return(FALSE);
    }

    g_cNatInfo = cNatInfo;
    g_cNatInfoPerTransInfo = g_cNatInfo / g_cTransInfoZ;

    // Finally, initialize each of the CNatInfo.  Place the valid ones on the transport's free list.

    CNatInfo * pNatInfo = g_pNatInfo;
    BYTE *     pbExtra  = (BYTE *)(g_pNatInfo + g_cNatInfo);
    UINT       iNatInfo = 0;

    for (iTransInfo = 0, pTransInfo = g_pTransInfo; iTransInfo < g_cTransInfo; ++iTransInfo, ++pTransInfo)
    {
        if (pTransInfo->_dwType != TRANSTYPE_DMZ)
            continue;

        pTransInfo->_iNatInfoBase = iNatInfo;
        pTransInfo->_cNatInfo = 0;

        // For transports we aren't using, we still want to get to here to initialize their cNatInfo to zero
        if (iNatInfo == g_cNatInfo)
            continue;

        for (DWORD dwIpa = pTransInfo->_dwIpaBeg; dwIpa <= pTransInfo->_dwIpaEnd; ++dwIpa)
        {
            if (iNatInfo == g_cNatInfo || pTransInfo->_cNatInfoFree == cMaxNatInfoPerTrans)
                break;

            CIpAddr ipaZ   = HTONL(dwIpa);
            BOOL    fValid = ipaZ.IsValidAddr(pTransInfo->_ipaMask);

            g_cTotalIpa++;
            if (fValid)
            {
                g_cValidIpa++;
            }

            for (UINT i = 0; i < g_cNatInfoPerIpAddr; ++i)
            {
                if (iNatInfo == g_cNatInfo || pTransInfo->_cNatInfoFree == cMaxNatInfoPerTrans)
                    break;

                pNatInfo->_iNatInfo     = iNatInfo;
                pNatInfo->_pTransInfo   = pTransInfo;
                pNatInfo->_ipaZ         = ipaZ;
                pNatInfo->_iBasePortZ   = pTransInfo->_wIpportBeg + (i * g_cPortsPerNatInfo);
                pNatInfo->_dwSpi        = 0;

                if (g_fPortTranslation)
                {
                    pNatInfo->_pNatPort     = (CNatPort *)pbExtra;  pbExtra += cbExtra1;
                    pNatInfo->_ppNatPortByI = (CNatPort **)pbExtra; pbExtra += cbExtra2;

                    for (UINT iPort = 0; iPort < g_cPortsPerNatInfo; iPort++)
                    {
                        pNatInfo->_pNatPort[iPort]._ipportZ = HTONS(pNatInfo->_iBasePortZ + iPort);
                        pNatInfo->_ppNatPortByI[iPort] = &pNatInfo->_pNatPort[iPort];
                    }
                }

                // TODO: Shouldn't we do them all for each transport and add them in one swoop?
                if (fValid)
                {
                    pTransInfo->_lockNatInfoFree.AcquireDpc();

                    InsertTailList(&pTransInfo->_leNatInfoFree, &pNatInfo->_leFree);
                    pTransInfo->_cNatInfoFree += 1;

                    pTransInfo->_lockNatInfoFree.ReleaseDpc();

                    g_cNatInfoValid += 1;
                }

                pTransInfo->_cNatInfo += 1;

                iNatInfo += 1;
                pNatInfo += 1;
            }
        }
    }

    Assert(iNatInfo == g_cNatInfo);

    TraceSz(Config, "    Configured NAT Info on %u DMZ transports:", g_cTransInfoZ);
    TraceSz(Config, "        g_fPortTranslation  %s", g_fPortTranslation ? "TRUE" : "FALSE");
    TraceSz(Config, "        g_cPortsPerNatInfo  %u", g_cPortsPerNatInfo);
    TraceSz(Config, "        g_cNatInfoPerIpAddr %u", g_cNatInfoPerIpAddr);
    TraceSz(Config, "        g_cNatInfo          %u", g_cNatInfo);
    TraceSz(Config, "        g_cNatInfoValid     %u", g_cNatInfoValid);
    TraceSz(Config, "        g_cTotalIpa         %u", g_cTotalIpa);
    TraceSz(Config, "        g_cValidIpa         %u", g_cValidIpa);

#ifdef SG_FEATURE_ARP
    // Start probing for the client ip range
    SgTimerSet(&g_timerPoolProbe, SgArpInfoPoolTimer, SgTimerTick(), TRUE);
#endif

    return(TRUE);
}

// Look up the NAT port to use on the Datacenter side for an incoming Internet packet
CIpPort SgNatInfoLookupI(CNatInfo * pNatInfo, CIpPort ipportI, UINT iNatPortWindowBegin, UINT iNatPortWindowEnd)
{
    // these are useful helpers, but we must keep them in sync
    // if we change the original values from whence they came
    CIpPort ipportIintel = NTOHS(ipportI);
    UINT cNatPort = iNatPortWindowEnd - iNatPortWindowBegin;
    CNatPort** ppNatPortBegin = pNatInfo->_ppNatPortByI + iNatPortWindowBegin;
    CNatPort** ppNatPortEnd = ppNatPortBegin + cNatPort;

    // other locals used at various scopes
    CNatPort* pNatPort;
    int iInsert;

    if (cNatPort < 8)
    {
        // not very many, just scan the sorted list
        // note the list is in descending order

        CNatPort** ppNatPort;
        for (ppNatPort = ppNatPortBegin; ppNatPort < ppNatPortEnd; ppNatPort++)
        {
            pNatPort = *ppNatPort;

            if (pNatPort->_ipportI == ipportI)
                goto assign;

            if (NTOHS(pNatPort->_ipportI) < ipportIintel)
                break;
        }

        iInsert = (int)(ppNatPort - ppNatPortBegin);
    }
    else
    {
        // could be lots, do a binary search
        // note the list is in descending order
        int iLo, iHi;
        for (iLo = 0, iHi = (int)cNatPort; iLo < iHi; )
        {
            int iMid = (iLo + iHi) >> 1;
            pNatPort = ppNatPortBegin[iMid];

            if (pNatPort->_ipportI == ipportI)
                goto assign;

            if (NTOHS(pNatPort->_ipportI) > ipportIintel)
                iLo = iMid + 1;
            else
                iHi = iMid;
        }

        iInsert = iLo;
    }

    // No unused CNatPort entries, so steal the least-recently-used one. This means
    // that if there are more than 'ClientPortLimit' active "connections" going on for
    // this Spi at the same time, we are going to screw with the oldest one. Hopefully
    // ClientPortLimit was configured with enough of a buffer to prevent this scenario
    // from happening.

    CNatPort ** ppNatPortMin = ppNatPortBegin;
    UINT64      qwTickMin    = TIMER_INFINITE;

    // first we find the LRU entry
    for (CNatPort** ppNatPort = ppNatPortBegin; ppNatPort < ppNatPortEnd; ppNatPort++)
    {
        pNatPort = *ppNatPort;

        if (qwTickMin > pNatPort->_qwTick)
        {
            qwTickMin = pNatPort->_qwTick;
            ppNatPortMin = ppNatPort;
        }
    }

    // save the value before we nuke it
    pNatPort = *ppNatPortMin;

    // shift the right side left to nuke the LRU entry
    int cMove = (int)(ppNatPortEnd - (ppNatPortMin + 1));
    memmove(ppNatPortMin, ppNatPortMin + 1, cMove * sizeof(CNatPort *));

    // if the insert point was in the block we shifted left, also shift the
    // insert point left one
    int iNatPort = (int)(ppNatPortMin - ppNatPortBegin);
    if (iInsert > iNatPort)
        iInsert -= 1;

    // and note that we have 1 less entry now
    cNatPort -= 1;

    // iInsert is where it goes in the sorted list, just need to actually insert the entry.
    CNatPort** ppNatPortInsert = ppNatPortBegin + iInsert;

    if ((UINT)iInsert < cNatPort)
    {
        // the insert point is within the list, need to shift right to make room
        int cMove = cNatPort - iInsert;
        memmove(ppNatPortInsert + 1, ppNatPortInsert, cMove * sizeof(CNatPort *));
    }

    // assign the address to the correct spot in the sorted list
    *ppNatPortInsert = pNatPort;

    if (Tag(NatInfo))
    {
        CSpiInfo *pSpiInfo = &g_pSpiInfo[(pNatInfo->_dwSpi >> 8) % g_cSpiInfo];

        TraceSz(NatInfo,
                "%08lX [%s:%d]/#%d -> [%s:%d]/#%d %s%d secs %d/I",
                pNatInfo->_dwSpi,                                   // connection id
                pSpiInfo->_ipaI.Str(), NTOHS(ipportI),              // internet ip & source port (inner)
                iInsert,                                            // index (vector by portI)
                pNatInfo->_ipaZ.Str(), NTOHS(pNatPort->_ipportZ),   // datacenter ip & source port
                (pNatPort - pNatInfo->_pNatPort),                   // index (vector by portZ)
                pNatPort->_ipportI == 0 ? "NEW "                    // new mapping or reused one?
                : pNatPort->_ipportI != ipportI ? "REUSE " : "",
                pNatPort->_ipportI == 0 ? 0 : SgTickElapsedInSeconds(pNatPort->_qwTick), // last used time
                NTOHS(pNatPort->_ipportI));                         // the stomped internet port
    }

    // finally, initialize it to the port we want
    pNatPort->_ipportI = ipportI;

assign:

    pNatPort->_qwTick = SgTimerTick();
    return(pNatPort->_ipportZ);
}

// Look up the NAT port to use on the Datacenter side for an incoming Internet packet.  
// This is a temporary function for our connection server port partitioning solution, 
// until we come up with a fuller-featured solution.
CIpPort SgNatInfoLookupI(CNatInfo * pNatInfo, CIpPort ipportI, CDstInfo *pDstInfo)
{
    // Default values for the main bucket
    UINT iNatPortBegin;
    UINT iNatPortEnd;

    if (pDstInfo->_dwConnGroupId == CONN_GROUP_CONNECTION_SERVER &&
        g_dwConnectionServerPortLimit > 0)
    {
        // Special hack for XONLINE_CONNECTION_SERVER traffic
        iNatPortBegin = g_cPortsPerNatInfo - g_dwConnectionServerPortLimit;
        iNatPortEnd   = g_cPortsPerNatInfo;
    }
    else
    {
        // Default partition for everyone else
        iNatPortBegin = 0;
        iNatPortEnd   = g_cPortsPerNatInfo - g_dwConnectionServerPortLimit;
    }

    return SgNatInfoLookupI(pNatInfo, ipportI, iNatPortBegin, iNatPortEnd);
}

// Look up NatInfo based on the IP and port a datacenter packet came in on
CNatInfo * SgNatInfoLookupZ(CTransInfo * pTransInfo, DWORD dwIpaDst, UINT iPortDst)
{
    // note the unsignededness
    UINT iNatInfo = 0;

    // NOTE: AuthData requests come down this path and could come in with a completely bogus IP
    // and/or port, so we must validate both.
    if( dwIpaDst < pTransInfo->_dwIpaBeg ||
        dwIpaDst > pTransInfo->_dwIpaEnd )
    {
        // IP address is out of range, no NAT info
        return NULL;
    }

    if (g_fPortTranslation)
    {
        // Get the offset based on the port. It's ok to wrap.
        iNatInfo = (iPortDst - pTransInfo->_wIpportBeg) / g_cPortsPerNatInfo;

        // In range? Note iNatInfo could easily have wrapped around and become a very 
        // large number. That's ok.
        if (iNatInfo >= g_cNatInfoPerIpAddr)
        {
            // Port is out of range, no NAT info
            return NULL;
        }
    }

    // Add on the offset based on the IP address. Difference in ip address is 0xFFFF at 
    // most (enforced in config code).  g_cNatInfoPerIpAddr is at most 4095.  So 16 bits 
    // plus 12 bits is 28 bits. No wraparound issues.
    iNatInfo += (dwIpaDst - pTransInfo->_dwIpaBeg) * g_cNatInfoPerIpAddr;

    // If you configured 64K ip addresses and 70K clients, port translation will be 
    // enabled and WAY less than 64K ip addresses will be used. Packets sent to those 
    // unused slots are invalid.
    if (iNatInfo >= g_cNatInfoPerTransInfo)
    {
        return NULL;
    }

    // Add on the offset based on the trans info
    iNatInfo += pTransInfo->_iNatInfoBase;

    Assert( iNatInfo < g_cNatInfo );

    // Make sure the NatInfo we found still represents an actual client
    if( g_pNatInfo[iNatInfo]._dwSpi != 0 )
    {
        // This will trace every packet. SgNatInfoLookupI only traces new port mappings.  
        // Thus we're commenting this out for now, but keeping it for debugging.

#ifdef SG_FEATURE_INSTRUMENTATION 
        if (Tag(NatInfo))
        {
            CNatInfo *pNatInfo = &g_pNatInfo[iNatInfo];
            CSpiInfo *pSpiInfo = &g_pSpiInfo[(pNatInfo->_dwSpi >> 8) % g_cSpiInfo];

            // Defaults for no port translation
            WORD ipportI = (WORD)iPortDst;
            CSmallStr strExtra;

            if (g_fPortTranslation)
            {
                UINT iNatPort = iPortDst - pNatInfo->_iBasePortZ;
                CNatPort *pNatPort = &pNatInfo->_pNatPort[iNatPort];

                ipportI = pNatPort->_ipportI;
                strExtra.Format(" #%d %d secs",
                                iNatPort,
                                (SgTimerTick() - pNatPort->_dwTick) / TICKS_PER_SECOND);
            }

            Assert(ipportI > 0);
            TraceSz(NatInfo,
                    "%08lX [%s:%d] <- [%s:%d]%s",
                    pNatInfo->_dwSpi,
                    pSpiInfo->_ipaI.Str(), NTOHS(ipportI),
                    pNatInfo->_ipaZ.Str(), iPortDst,
                    strExtra.cstr());
        }
#endif

        return(&g_pNatInfo[iNatInfo]);
    }

    return(NULL);
}


UINT g_iNextTransInfo = 0;

CNatInfo * SgNatInfoAlloc(DWORD dwSpi)
{
    // find an active CTransInfo with a free CNatInfo

    CNatInfo * pNatInfo   = NULL;
    UINT       iTransInfo = g_iNextTransInfo;
    Assert(iTransInfo < g_cTransInfo);

    do
    {
        CTransInfo * pTransInfo = &g_pTransInfo[iTransInfo];

        if (SgTransInfoIsActive(pTransInfo) && pTransInfo->_dwType == TRANSTYPE_DMZ)
        {
            pTransInfo->_lockNatInfoFree.AcquireDpc();

            if (pTransInfo->_cNatInfoFree > 0)
            {
                pNatInfo = (CNatInfo *)RemoveHeadList(&pTransInfo->_leNatInfoFree);
                pTransInfo->_cNatInfoFree -= 1;
            }

            pTransInfo->_lockNatInfoFree.ReleaseDpc();
        }

        iTransInfo++;
        if (iTransInfo == g_cTransInfo)
            iTransInfo = 0;

    } while (pNatInfo == NULL && iTransInfo != g_iNextTransInfo);

    g_iNextTransInfo = iTransInfo;

    if (pNatInfo == NULL)
    {
        return(NULL);
    }

    pNatInfo->_leFree.Flink = NULL;
    pNatInfo->_dwSpi        = dwSpi;

    // Reset all internet ports just in case a rogue packet comes from the datacenter -- 
    // we don't want old mappings causing packets to go to the client. Also reset the LRU 
    // to the oldest value, since we now assume all mappings are "in use" from the get-go.
    for (UINT iNatPort = 0; iNatPort < g_cPortsPerNatInfo; iNatPort++)
    {
        CNatPort *pNatPort = &pNatInfo->_pNatPort[iNatPort];
        pNatPort->_ipportI = 0;
        pNatPort->_qwTick = 0;

        // Reset pointers. Not really necessary, but "neater".
        pNatInfo->_ppNatPortByI[iNatPort] = pNatPort;
    }

    return(pNatInfo);
}

void SgNatInfoFree(CNatInfo * pNatInfo)
{
    if (pNatInfo)
    {
        Assert(pNatInfo->_leFree.Flink == NULL);
        CTransInfo * pTransInfo = pNatInfo->_pTransInfo;

        pNatInfo->_dwSpi = 0;

        pTransInfo->_lockNatInfoFree.AcquireDpc();

        InsertTailList(&pTransInfo->_leNatInfoFree, &pNatInfo->_leFree);
        pTransInfo->_cNatInfoFree += 1;
        Assert(pTransInfo->_cNatInfoFree <= pTransInfo->_cNatInfo);

        pTransInfo->_lockNatInfoFree.ReleaseDpc();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgoffload.cpp ===
// ---------------------------------------------------------------------------------------
// sgoffload.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_INSECURE
BOOL g_fInhibitSha;
BOOL g_fInhibitDes;
BOOL g_fInhibitKeyTable;
#endif

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------



// ---------------------------------------------------------------------------------------
// SgOffloadEncodePacket
// ---------------------------------------------------------------------------------------

void SgOffloadEncodePacket(CPacket * ppkt)
{
    CSpiInfo *    pSpiInfo    = ppkt->_pSpiInfo;
    CXspCtx *     pXspCtx     = (CXspCtx *)ppkt->_abCtx;
    BYTE          abHmacData[20];

    Assert(pSpiInfo != NULL);

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitDes)
#endif
    {
        if (pXspCtx->_cb3 > 0 || pXspCtx->_cb4 > 0)
        {
        #ifdef SG_FEATURE_INSECURE
            if (g_fInhibitKeyTable)
            {
                XcCrypt(XC_SERVICE_ENCRYPT, 
                        KEYMATERIAL(pSpiInfo, _abKeyCryptXmit), pSpiInfo->_cbKeyCrypt,
                        pXspCtx->_abIv, 
                        pXspCtx->_pb3, pXspCtx->_cb3, 
                        pXspCtx->_pb4, pXspCtx->_cb4);
            }
            else
        #endif
            {
                XcCryptWithKeyTable(XC_SERVICE_ENCRYPT, 
                                    pSpiInfo->_abKeyTblCryptXmit, pSpiInfo->_cbKeyCrypt,
                                    pXspCtx->_abIv, 
                                    pXspCtx->_pb3, pXspCtx->_cb3, 
                                    pXspCtx->_pb4, pXspCtx->_cb4);
            }
        }
    }

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitSha)
#endif
    {
    #ifdef SG_FEATURE_INSECURE
        if (g_fInhibitKeyTable)
        {
            XcHMAC4(KEYMATERIAL(pSpiInfo, _abKeyShaXmit), SESSION_KEY_SHA_SIZE,
                    pXspCtx->_pb1, pXspCtx->_cb1, 
                    pXspCtx->_pb2, pXspCtx->_cb2,
                    pXspCtx->_pb3, pXspCtx->_cb3, 
                    pXspCtx->_pb4, pXspCtx->_cb4,
                    abHmacData);
        }
        else
    #endif
        {
            XcHMACWithKeyTable(pSpiInfo->_abKeyTblShaXmit,
                               pXspCtx->_pb1, pXspCtx->_cb1, 
                               pXspCtx->_pb2, pXspCtx->_cb2,
                               pXspCtx->_pb3, pXspCtx->_cb3, 
                               pXspCtx->_pb4, pXspCtx->_cb4,
                               abHmacData);
        }

        Assert(sizeof(pXspCtx->_XspTail._abHash) <= sizeof(abHmacData));
        memcpy(pXspCtx->_XspTail._abHash, abHmacData, sizeof(pXspCtx->_XspTail._abHash));
    }

    ppkt->_fOffloadSuccess = TRUE;
}

// ---------------------------------------------------------------------------------------
// SgOffloadDecodePacket
// ---------------------------------------------------------------------------------------

void SgOffloadDecodePacket(CPacket * ppkt)
{
    CSpiInfo *    pSpiInfo    = ppkt->_pSpiInfo;
    CXspCtx *     pXspCtx     = (CXspCtx *)ppkt->_abCtx;
    BYTE          abHmacData[20];

    Assert(pSpiInfo != NULL);

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitSha)
#endif
    {
    #ifdef SG_FEATURE_INSECURE
        if (g_fInhibitKeyTable)
        {
            XcHMAC4(KEYMATERIAL(pSpiInfo, _abKeyShaRecv), SESSION_KEY_SHA_SIZE,
                    pXspCtx->_pb1, pXspCtx->_cb1, 
                    pXspCtx->_pb2, pXspCtx->_cb2, 
                    NULL, 0, 
                    NULL, 0,
                    abHmacData);
        }
        else
    #endif
        {
            XcHMACWithKeyTable(pSpiInfo->_abKeyTblShaRecv, 
                               pXspCtx->_pb1, pXspCtx->_cb1, 
                               pXspCtx->_pb2, pXspCtx->_cb2, 
                               NULL, 0, 
                               NULL, 0, 
                               abHmacData);
        }

        if (memcmp(pXspCtx->_abHash, abHmacData, sizeof(pXspCtx->_abHash)) != 0)
        {
            TraceSz(RecvDiscard, "%s #%d: authentication failed", ppkt->Str(), ppkt->_dwSeq);
            SgEventPacketLog(INVALID_IPSEC_PACKET_1, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc, PEVT_FILTER_XSP);
            ppkt->_fOffloadSuccess = FALSE;
            goto complete;
        }
    }

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitDes)
#endif
    {
        if (pXspCtx->_cb2 > 0)
        {
        #ifdef SG_FEATURE_INSECURE
            if (g_fInhibitKeyTable)
            {
                XcCrypt(XC_SERVICE_DECRYPT, 
                        KEYMATERIAL(pSpiInfo, _abKeyCryptRecv), pSpiInfo->_cbKeyCrypt,
                        pXspCtx->_abIv, 
                        pXspCtx->_pb2, pXspCtx->_cb2, 
                        NULL, 0);
            }
            else
        #endif
            {
                XcCryptWithKeyTable(XC_SERVICE_DECRYPT, 
                                    pSpiInfo->_abKeyTblCryptRecv, pSpiInfo->_cbKeyCrypt,
                                    pXspCtx->_abIv, 
                                    pXspCtx->_pb2, pXspCtx->_cb2, 
                                    NULL, 0);
            }
        }
    }

    ppkt->_fOffloadSuccess = TRUE;

complete:
    return;
}

// ---------------------------------------------------------------------------------------
// SgOffloadBuildSpi
// Does all the heavy-lifting-math required in the key-exchange.  
// ---------------------------------------------------------------------------------------

void SgOffloadBuildSpi(CPacket * ppkt)
{
    CSpiInfo *          pSpiInfo         = ppkt->_pSpiInfo;
    CKeyExCtx *         pKeyExCtx        = (CKeyExCtx *)ppkt->_abCtx;

#if 0
    // dcaiafa: I'm keeping this code here for reference. An earlier version of the SG 
    // would short-circuit the diffie-hellman part of the key-exchange when it detected 
    // that the CPU was really busy.

    // Short-circuit diffie-hellman by picking Y = 1 so that g^Y = g.  This means
    // that (g^Y)^X = g^X, which is what the client just sent us.  By sending back
    // g^Y = g, we signal the client to not bother computing (g^Y)^X either, since
    // it has already computed g^X.

    memset(pKeyExCtx->_abDhY, 0, sizeof(pKeyExCtx->_abDhY));
    pKeyExCtx->_abDhY[0] = 0x01;

    Assert(sizeof(pSpiInfo->_abDhGY) == sizeof(g_abOakleyGroup1Base));
    memcpy(pSpiInfo->_abDhGY, g_abOakleyGroup1Base, sizeof(pSpiInfo->_abDhGY));

    Assert(sizeof(pKeyExCtx->_abDhGXY) == sizeof(pSpiInfo->_abDhGX));
    memcpy(pKeyExCtx->_abDhGXY, pSpiInfo->_abDhGX, sizeof(pKeyExCtx->_abDhGXY));
#endif

    // Depending on the build of the SG, two types of key-exchange are supported. The Live 
    // SG build supports the key-exchange with diffe-hellman. The SG LSP build supports 
    // the SG key-exchange in addition to an old LSP legacy key-exchange method with a 
    // key-exchange-key retrieved from Live instead of the diffe-hellman.

    UINT uiCipher = 
        (pSpiInfo->_cbKeyCrypt == XC_SERVICE_DES_KEYSIZE) ? XC_SERVICE_DES_CIPHER : 
        (pSpiInfo->_cbKeyCrypt == XC_SERVICE_AES_KEYSIZE) ? XC_SERVICE_AES_CIPHER :
        (pSpiInfo->_cbKeyCrypt == XC_SERVICE_NULL_KEYSIZE) ? XC_SERVICE_NULL_CIPHER :
        XC_SERVICE_DES3_CIPHER;

    if(pKeyExCtx->_pKeyExDhGX)
    {
        // Assign a diffie-hellman Y and g^Y and compute g^XY

        SgDhInfoAssign(pKeyExCtx->_abDhY, pSpiInfo->_abDhGY);

        XcModExp((DWORD *)pKeyExCtx->_abDhGXY, (DWORD *)pSpiInfo->_abDhGX,
                 (DWORD *)pKeyExCtx->_abDhY, (DWORD *)g_abOakleyGroup1Mod,
                 CBDHG1 / sizeof(DWORD));

        // Compute the SHA and crypt keys and IV's
        // Hmac-Sha(ticket-key, diffie-hellman-key | NonceInit | NonceResp)

        BYTE * pbKeyOut = (BYTE*)&pSpiInfo->_keyMaterialDes;  // doesn't matter which union member

        for (int i = 0; i < SESSION_KEY_NUMBER_OF_DIGESTS; ++i)
        {
            XcHMAC4(pSpiInfo->_abKeyHmac, sizeof(pSpiInfo->_abKeyHmac),
                    pKeyExCtx->_abDhGXY, sizeof(pKeyExCtx->_abDhGXY),
                    pSpiInfo->_abNonceInit, sizeof(pSpiInfo->_abNonceInit),
                    pSpiInfo->_abNonceResp, sizeof(pSpiInfo->_abNonceResp),
                    NULL, 0, pbKeyOut);
            pbKeyOut += XC_SERVICE_DIGEST_SIZE;
            pKeyExCtx->_abDhGXY[0] += 1;
        }

    }
    else
    {
#ifdef SG_FEATURE_LSP
        
        // set up title server keys
        // Hmac-Sha(Key-Exchange-Key, ticket-key | NonceInit | NonceResp)

        BYTE * pbKeyOut     = (BYTE*)&pSpiInfo->_keyMaterialDes;  // doesn't matter which union member
        BYTE   bKeySession0 = pKeyExCtx->_abKey[0];

        for (int i = 0; i < SESSION_KEY_NUMBER_OF_DIGESTS; ++i)
        {
            XcHMAC4((BYTE *)&pSpiInfo->_abKeyShaKeyEx, sizeof(pSpiInfo->_abKeyShaKeyEx),
                    pKeyExCtx->_abKey, sizeof(pKeyExCtx->_abKey), 
                    pSpiInfo->_abNonceInit, sizeof(pSpiInfo->_abNonceInit),
                    pSpiInfo->_abNonceResp, sizeof(pSpiInfo->_abNonceResp),
                    NULL, 0, pbKeyOut);
            pbKeyOut += XC_SERVICE_DIGEST_SIZE;
            pKeyExCtx->_abKey[0] += 1;
        }

        pKeyExCtx->_abKey[0] = bKeySession0;

#else
        
        Assert(!"This code should have never been executed");
        ppkt->_fOffloadSuccess = FALSE;
        return;

#endif // SG_FEATURE_LSP
    }

    // Set parity bits for DES/DES3 keys

    if (uiCipher == XC_SERVICE_DES_CIPHER || uiCipher == XC_SERVICE_DES3_CIPHER)
    {
        XcDESKeyParity(pSpiInfo->_keyMaterialDes._abKeyCryptXmit, sizeof(pSpiInfo->_keyMaterialDes._abKeyCryptXmit));
        XcDESKeyParity(pSpiInfo->_keyMaterialDes._abKeyCryptRecv, sizeof(pSpiInfo->_keyMaterialDes._abKeyCryptRecv));
    }

    // Precompute SHA and crypt key tables

    XcHMACMakeKeyTable(KEYMATERIAL(pSpiInfo, _abKeyShaRecv), SESSION_KEY_SHA_SIZE, pSpiInfo->_abKeyTblShaRecv);
    XcHMACMakeKeyTable(KEYMATERIAL(pSpiInfo, _abKeyShaXmit), SESSION_KEY_SHA_SIZE, pSpiInfo->_abKeyTblShaXmit);

    XcKeyTable(uiCipher, pSpiInfo->_abKeyTblCryptRecv, KEYMATERIAL(pSpiInfo, _abKeyCryptRecv));
    XcKeyTable(uiCipher, pSpiInfo->_abKeyTblCryptXmit, KEYMATERIAL(pSpiInfo, _abKeyCryptXmit));

    ppkt->_fOffloadSuccess = TRUE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgperfdata.cpp ===
// ----------------------------------------------------------------------------
// sgperfdata.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "sg.h"

CSgPerfData g_Perfdata;
extern UINT g_cSpiInfoInUse;
extern UINT g_cSpiInfoFree;

BOOL SgPerfdataInit()
{
    //@@@ get rid of processor specific counters
    UINT cProcs = 1;

    memset( &g_Perfdata, 0, sizeof( g_Perfdata ) );

    return TRUE;
}

BOOL SgPerfdataConfig(CCfgInfo* pci)
{
    UNREFERENCED_PARAMETER(pci);
    TraceSz( Config, "SgPerfdataConfig:" );
    return TRUE;
}

void SgPerfdataTerm()
{
}

void SgPerfdataQuery( CSgPerfData* pData )
{
    g_Perfdata._ullCurrentConnections = g_cSpiInfoInUse - g_cSpiInfoFree;
    g_Perfdata._ullFreeConnections    = g_cSpiInfo - (g_cSpiInfoInUse - g_cSpiInfoFree);
    g_Perfdata._ullMaximumConnections = g_cSpiInfo;

    SgProcBalQueryCounters(&g_Perfdata);

    g_Perfdata._ullSpinLockLocks      = CSpinLock::GetGlobalLockCount();
    g_Perfdata._ullSpinLockCollisions = CSpinLock::GetGlobalCollisionCount();
    g_Perfdata._ullSpinLockSleeps     = CSpinLock::GetGlobalSleepCount();

    // Get TransInfo counters
    UINT nTransInfo;
    for(nTransInfo=0; nTransInfo < g_cTransInfo; nTransInfo++)
    {
        CTransInfoCounters counters;

        TransQueryCounters(&g_pTransInfo[nTransInfo], &counters);

        if(g_pTransInfo[nTransInfo]._dwType == TRANSTYPE_INTERNET)
        {
            g_Perfdata._ullIRecvDriverCalls    = counters.adapter.cReceiveCalls;
            g_Perfdata._ullIRecvPacketsDriver  = counters.adapter.cPacketReceived;
            g_Perfdata._ullIRecvBatchThreshold = counters.adapter.cRecvBatchThreshold;
            g_Perfdata._ullIDropPacketsDriver  = counters.adapter.cPacketDropped;
            g_Perfdata._ullIXmitDriverCalls    = counters.adapter.cSendCalls;
            g_Perfdata._ullIXmitPacketsDriver  = counters.adapter.cPacketSent;
            g_Perfdata._ullIXmitStage1Count    = counters.adapter.cXmitStage1;
            g_Perfdata._ullIXmitStage2Count    = counters.adapter.cXmitStage2;
            g_Perfdata._ullIXmitInProgress     = counters.adapter.cOverlappedsAllocated;
        }
        else
        {
            g_Perfdata._ullZRecvDriverCalls    = counters.adapter.cReceiveCalls;
            g_Perfdata._ullZRecvPacketsDriver  = counters.adapter.cPacketReceived;
            g_Perfdata._ullZRecvBatchThreshold = counters.adapter.cRecvBatchThreshold;
            g_Perfdata._ullZDropPacketsDriver  = counters.adapter.cPacketDropped;
            g_Perfdata._ullZXmitDriverCalls    = counters.adapter.cSendCalls;
            g_Perfdata._ullZXmitPacketsDriver  = counters.adapter.cPacketSent;
            g_Perfdata._ullZXmitStage1Count    = counters.adapter.cXmitStage1;
            g_Perfdata._ullZXmitStage2Count    = counters.adapter.cXmitStage2;
            g_Perfdata._ullZXmitInProgress     = counters.adapter.cOverlappedsAllocated;
        }

        g_Perfdata._ullDriverProtocolReceivePacketCalls     = counters.global.cProtocolReceivePacket;
        g_Perfdata._ullDriverProtocolReceivePacketCopyCalls = counters.global.cProtocolReceivePacketCopy;
        g_Perfdata._ullDriverProtocolReceiveIndicationCalls = counters.global.cProtocolReceiveIndication;
        g_Perfdata._ullDriverProtocolReceiveIndicationDiscard = counters.global.cProtocolReceiveIndicationDiscard;
        g_Perfdata._ullDriverProtocolReceiveCompleteCalls   = counters.global.cProtocolReceiveComplete;
        g_Perfdata._ullDriverPacketsInUse                   = counters.global.cPacketsInUse;
    }

    // Copy from global to output
    memcpy(pData, &g_Perfdata, sizeof(g_Perfdata));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgprocbal.cpp ===
// ---------------------------------------------------------------------------------------
// sgprocbal.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Forwards
// ---------------------------------------------------------------------------------------

static void CALLBACK SgProcBalProcessWorkCompletion(void* param);

static DWORD CALLBACK SgProcBalProcessWin32Completion(void* param);

static void CALLBACK SgProcBalProcessIoCompletion(
    DWORD error, 
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped);


int SgProcBalGetWin32ThreadPriorityFromSetting(DWORD prioritySetting);

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

CThreadPool     g_SgProcBalThreadPool;
CIoThreadPool   g_SgProcBalHybridThreadPool;
CIoThreadPool   g_SgProcBalIoThreadPool;
DWORD           g_SgProcBalThreadPoolType;

BOOL g_fProcBalInit = FALSE;

// ---------------------------------------------------------------------------------------
// SgProcBalInit
// ---------------------------------------------------------------------------------------
BOOL SgProcBalInit()
{
    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgProcBalConfig
// Configure thread pool
// ---------------------------------------------------------------------------------------
BOOL SgProcBalConfig(CCfgInfo* pci)
{
    UNREFERENCED_PARAMETER(pci);
    TraceSz( Config, "SgProcBalConfig:" );
    BOOL ok = FALSE;

    if(g_fProcBalInit)
    {
        // no reconfig beyond this point
        ok = TRUE;
        goto Exit;
    }

    DWORD workThreadCount;
    DWORD workThreadBatch;
    DWORD workThreadPriority;
    DWORD workThreadAffinityLimit;
    DWORD ioThreadCount;
    DWORD ioThreadPriority;
    DWORD ioThreadDisablePriorityBoost;
    DWORD recvProcessPackets;

    if(!pci->GetVar("ThreadPoolType", &g_SgProcBalThreadPoolType, 0, SGPROCBAL_THREADPOOL_MAXVALID, 0) ||
       !pci->GetVar("WorkThreadCount", &workThreadCount, 0, 100, 0) ||
       !pci->GetVar("WorkThreadBatch", &workThreadBatch, 0, 1, 1) ||
       !pci->GetVar("WorkThreadPriority", &workThreadPriority, 0, 2, 1) ||
       !pci->GetVar("WorkThreadAffinityLimit", &workThreadAffinityLimit, 0, 100000, 100) ||
       !pci->GetVar("IoThreadCount", &ioThreadCount, 0, 100, 0) ||
       !pci->GetVar("IoThreadPriority", &ioThreadPriority, 0, 2, 1) ||
       !pci->GetVar("IoThreadDisablePriorityBoost", &ioThreadDisablePriorityBoost, 0, 1, 0) ||
       !pci->GetVar("DriverRecvProcessPackets", &recvProcessPackets, 0, 1, 1))
    {
        goto Exit;
    }

    // Tweak default settings if not overridden
    if(g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_NORMAL && recvProcessPackets)
    {
        SYSTEM_INFO si;
        ::GetSystemInfo(&si);
        DWORD numProcs = si.dwNumberOfProcessors;
        
        // If DriverRecvProcessPackets is enabled, we're using the regular dual thread 
        // pool, and the thread count hasn't been overridden, we will use the following 
        // numbers:
        //
        // The idea is:
        // 2 io threads in reserve
        // WorkThreads plus MaxConcurrency equals NumProcs
        //
        //               Number of Processors
        //                  1   2   4   8
        //                 === === === ===
        //    WorkThreads:  1   1   2   2
        //      IoThreads:  1   2   4   8
        // MaxConcurrency:  1   1   2   6
        //
        //

        if (workThreadCount == 0)
        {
            if (numProcs > 2)
                workThreadCount = 2;
            else
                workThreadCount = 1;
        }
        if (ioThreadCount == 0)
        {
            ioThreadCount = numProcs;
        }
    }

    TraceSz(Config, "    ThreadPoolType: %u", g_SgProcBalThreadPoolType);

    if(g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_NORMAL)
    {
        if(!g_SgProcBalThreadPool.Init(workThreadCount, 
                                       workThreadBatch, 
                                       workThreadAffinityLimit,
                                       CSgMemAlloc::GetAlloc()))
        {
            SgEventSz(INIT_ERROR, "Failed to initialize thread pool.");
            goto Exit;
        }

        g_SgProcBalThreadPool.SetPriority(
            SgProcBalGetWin32ThreadPriorityFromSetting(workThreadPriority));

        TraceSz(Config, "    Worker thread pool: thread-count: %u", g_SgProcBalThreadPool.GetNumThreads());
        TraceSz(Config, "    Worker thread pool: batch: %u", workThreadBatch);
        TraceSz(Config, "    Worker thread pool: priority: %u", workThreadPriority);
        TraceSz(Config, "    Worker thread pool: affinity-limit: %u", workThreadAffinityLimit);

    }
    else if(g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_HYBRID)
    {
        if(!g_SgProcBalHybridThreadPool.Init(workThreadCount, CSgMemAlloc::GetAlloc()))
        {
            SgEventSz(INIT_ERROR, "Failed to initialize hybrid thread pool.");
            goto Exit;
        }

        g_SgProcBalHybridThreadPool.SetPriority(
            SgProcBalGetWin32ThreadPriorityFromSetting(workThreadPriority));
        
        TraceSz(Config, "    Configured Hybrid Thread Pool: thread-count(%u), priority(%u)",
                 workThreadCount, workThreadPriority);
    }


    if(g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_NORMAL || 
       g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_UNIFIED ||
       g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_HYBRID)
    {
        if(!g_SgProcBalIoThreadPool.Init(ioThreadCount, CSgMemAlloc::GetAlloc()))
        {
            SgEventSz(INIT_ERROR, "Failed to initialize thread pool.");
            goto Exit;
        }

        g_SgProcBalIoThreadPool.SetPriority(
            SgProcBalGetWin32ThreadPriorityFromSetting(ioThreadPriority));

        if(ioThreadDisablePriorityBoost)
        {
            g_SgProcBalIoThreadPool.SetPriorityBoost(TRUE);
        }
        
        TraceSz(Config, "    Io thread pool: thread-count: %u", g_SgProcBalIoThreadPool.GetNumThreads());
        TraceSz(Config, "    Io thread pool: priority: %u", ioThreadPriority);
        TraceSz(Config, "    Io thread pool: disable-priority-boost: %u", ioThreadDisablePriorityBoost);
    }

    g_fProcBalInit = TRUE;
    ok = TRUE;
    
Exit:

    return(ok);
}

// ---------------------------------------------------------------------------------------
// SgProcBalTerm
// Terminate thread pool after processing all pending packets
// ---------------------------------------------------------------------------------------
void SgProcBalTerm()
{
    g_SgProcBalIoThreadPool.Term();
    g_SgProcBalHybridThreadPool.Term();
    g_SgProcBalThreadPool.Term();
}

BOOL SgProcBalBindHandle(HANDLE hFile, PFNIOCOMPLETED pCallback)
{
    switch(g_SgProcBalThreadPoolType)
    {
    case SGPROCBAL_THREADPOOL_NORMAL:
    case SGPROCBAL_THREADPOOL_UNIFIED:
    case SGPROCBAL_THREADPOOL_HYBRID:
        return g_SgProcBalIoThreadPool.Bind(hFile, pCallback) == true;

    case SGPROCBAL_THREADPOOL_WIN32:
        return BindIoCompletionCallback(hFile, pCallback, 0);

    default:
        Assert(false);
        return FALSE;
    }
}

// ---------------------------------------------------------------------------------------
// GetWorkItemPriorityFromPacket
// Converts a packet priority to a work item priority
// ---------------------------------------------------------------------------------------
INLINE CThreadPool::WorkItemPriority GetWorkItemPriorityFromPacket(CPacket * ppkt)
{
    Assert(ppkt);
    switch (ppkt->_priority)
    {
    case PACKET_PRIORITY_LOW:
        return CThreadPool::PriorityLow;
    case PACKET_PRIORITY_NORMAL:
        return CThreadPool::PriorityNormal;
    case PACKET_PRIORITY_HIGH:
        return CThreadPool::PriorityHigh;
    default:
        return CThreadPool::PriorityNormal;
    }
}

// ---------------------------------------------------------------------------------------
// SgProcBalQueuePacket
// Queue a packet to be completed in the thread pool
// ---------------------------------------------------------------------------------------
void SgProcBalQueuePacket(CPacket * ppkt)
{
    Assert(ppkt);
    Assert(ppkt->_cpfn > 0);

    switch(g_SgProcBalThreadPoolType)
    {
    case SGPROCBAL_THREADPOOL_NORMAL:
    {
        CThreadPool::WorkItemPriority priority = GetWorkItemPriorityFromPacket(ppkt);

        if(!g_SgProcBalThreadPool.AddWorkItem(SgProcBalProcessWorkCompletion, (void*) ppkt, priority))
        {
            goto lDiscard;
        }
        SgPerfdataInterlockedInc(QueuedProc);
        break;
    }
    case SGPROCBAL_THREADPOOL_HYBRID:
        if(!g_SgProcBalHybridThreadPool.Post(0, SgProcBalProcessIoCompletion, (OVERLAPPED*) ppkt))
        {
            goto lDiscard;
        }
        SgPerfdataInterlockedInc(QueuedProc);
        break;

    case SGPROCBAL_THREADPOOL_UNIFIED:
        if(!g_SgProcBalIoThreadPool.Post(0, SgProcBalProcessIoCompletion, (OVERLAPPED*) ppkt))
        {
            goto lDiscard;
        }
        SgPerfdataInterlockedInc(QueuedProc);
        break;

    case SGPROCBAL_THREADPOOL_WIN32:
        if(!QueueUserWorkItem(SgProcBalProcessWin32Completion, ppkt, 0))
        {
            goto lDiscard;
        }
        SgPerfdataInterlockedInc(QueuedProc);
        break;

    default:
        goto lDiscard;
    }

    return;

lDiscard:
    
    // @@@ dcaiafa: test
    // Remove the callback that were supposed to be dispatched from the 
    // packet's completion stack otherwise calling complete would result in the 
    // packet being processed on the spot. Can't get away without calling 
    // complete either since there might be resources that need to be released.

    ppkt->_cpfn--;
    ppkt->Complete();
    
    return;
}

void SgProcBalQueryCounters(CSgPerfData* pPerfData)
{
    if(g_SgProcBalThreadPoolType == SGPROCBAL_THREADPOOL_NORMAL)
    {
        pPerfData->_ullThreadPoolWaitCount               = g_SgProcBalThreadPool.GetWaitCount();
        pPerfData->_ullThreadPoolActiveCount             = g_SgProcBalThreadPool.GetActiveThreadCount();
        pPerfData->_ullThreadPoolWorkItemsMissCount      = g_SgProcBalThreadPool.GetWorkItemsCallsMiss();
        pPerfData->_ullThreadPoolWorkItemsHitCount       = g_SgProcBalThreadPool.GetWorkItemsCallsHit();
        pPerfData->_ullThreadPoolWorkItemsRetrievedCount = g_SgProcBalThreadPool.GetWorkItemsRetrieved();
    }
}

static void CALLBACK SgProcBalProcessWorkCompletion(void* param)
{
    SgPerfdataInterlockedDec(QueuedProc);
    Assert(param);
    CPacket* ppkt = (CPacket*)param;
    ppkt->Complete();
}

static DWORD CALLBACK SgProcBalProcessWin32Completion(void* param)
{
    SgPerfdataInterlockedDec(QueuedProc);
    Assert(param);
    CPacket* ppkt = (CPacket*)param;
    ppkt->Complete();
    
    return 0;
}

static void CALLBACK SgProcBalProcessIoCompletion(
    DWORD error, 
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped)
{
    SgPerfdataInterlockedDec(QueuedProc);
    Assert(pOverlapped);
    CPacket* ppkt = (CPacket*)pOverlapped;
    ppkt->Complete();
}

static int SgProcBalGetWin32ThreadPriorityFromSetting(DWORD prioritySetting)
{
    int threadPriority;
    
    switch(prioritySetting)
    {
    case 0:
        threadPriority = THREAD_PRIORITY_LOWEST;
        break;
    case 1:
        threadPriority = THREAD_PRIORITY_NORMAL;
        break;
    case 2:
        threadPriority = THREAD_PRIORITY_HIGHEST;
        break;

    default:
        threadPriority = THREAD_PRIORITY_NORMAL;
        break;
    };

    return threadPriority;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvc.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvc.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#include "sg.h"


// ---------------------------------------------------------------------------------------
// Management output areas
// ---------------------------------------------------------------------------------------

XomDefineArea(lua);
XomDefineArea(log);
XomDefineArea(LogCode);
XomDefineArea(LogCodeWindows);
XomDefineArea(LogTitle);
XomDefineArea(LogWindows);
XomDefineArea(Debug);
XomDefineArea(Integration);
XomDefineArea(SgClientStats);
XomDefineArea(Reporting);


// ---------------------------------------------------------------------------------------
// CSgService - an NT service built on the CNTService common code
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_LSP
#define SERVICE_SHORT_NAME L"SGLSP"
#define SERVICE_LONG_NAME  L"XLSP Security Gateway"
#else
#define SERVICE_SHORT_NAME L"SGSVC"
#define SERVICE_LONG_NAME  L"XBox Security Gateway"
#endif

class CSgService : public CNTService
{
public:

    // Constructor / Destructor ----------------------------------------------------------

    CSgService() :
        CNTService(
            SERVICE_SHORT_NAME,
            SERVICE_LONG_NAME,
            L"Provides secure communication Xbox consoles and servers",
            L"SGPerf",
            Component_sgsvc 
            )
    {
    }

    // CNTService ------------------------------------------------------------------------

    virtual HRESULT InitService( DWORD dwArgc, LPTSTR* ppszArgv )
    {
        if( !SgServiceInit( ShutdownEvent() ) )
        {
            return E_FAIL;
        }

        return S_OK;
    }

    virtual HRESULT RunService( BOOL* pfServiceRan )
    {
        SgEvent(SERVICE_STARTED);

        while( TRUE )
        {
            // Wake up periodically and allow the service layer to do work
            DWORD dwRes = WaitForSingleObject( ShutdownEvent(), 100 );
            if( WAIT_TIMEOUT != dwRes )
            {
                // Shutting down
                break;
            }

            SgServiceHeartbeat();
        }

        SgEvent(SERVICE_SHUTTING_DOWN);

        // Clean up
        SgServiceTerm();

        return S_OK;
    }

    // Install / Uninstall return codes:
    //
    // 0: success
    // 1: success, but reboot required
    // 2: failure, reboot required then try again
    // 3: failure, driver install (rawnic) failed
    // 4: failure, service install failed, see install output
    //
    
#define SG_ERROR_SUCCESS                 0
#define SG_ERROR_SUCCESS_REBOOT_REQUIRED 1
#define SG_ERROR_FAILURE_REBOOT_REQUIRED 2
#define SG_ERROR_FAILURE_DRIVER          3
#define SG_ERROR_FAILURE_SERVICE         4

    DWORD MapToReturnCode(BOOL fServiceSucceeded, BOOL fDriverSucceeded, BOOL fRebootRequired)
    {
        // Map error conditions to return codes
        if (fRebootRequired)
        {
            return fDriverSucceeded && fServiceSucceeded 
                ? SG_ERROR_SUCCESS_REBOOT_REQUIRED 
                : SG_ERROR_FAILURE_REBOOT_REQUIRED;
        }
        else
        {
            if (!fServiceSucceeded)
                return SG_ERROR_FAILURE_SERVICE;
            else if (!fDriverSucceeded)
                return SG_ERROR_FAILURE_DRIVER;
            else
                return SG_ERROR_SUCCESS;
        }
    }

    virtual DWORD Install() 
    { 
        DWORD dwRes;
        BOOL fRebootRequired   = FALSE;
        BOOL fDriverSucceeded  = TRUE;
        BOOL fServiceSucceeded = TRUE;

        // This mostly does the driver, also does events
        fDriverSucceeded = SgServiceInstall(&fRebootRequired);
        if (!fDriverSucceeded)
        {
            InstallInfo("Warning: RAWNIC driver install failed (reboot is%s required)", fRebootRequired ? "" : " not");
            InstallInfo("The SG will not function without the RAWNIC driver, but it may be installed later.");
        }

        // Install the sg service
        dwRes = CNTService::Install();
        if( ERROR_SUCCESS != dwRes )
        {
            InstallInfo("Warning: Service install failed with Win32 error %d", dwRes);
            fServiceSucceeded = FALSE;
        }

        return MapToReturnCode(fServiceSucceeded, fDriverSucceeded, fRebootRequired);
    }

    virtual DWORD Uninstall() 
    { 
        DWORD dwRes;
        BOOL fRebootRequired   = FALSE;
        BOOL fDriverSucceeded  = TRUE;
        BOOL fServiceSucceeded = TRUE;

        // Uninstall sg service
        dwRes = CNTService::Uninstall();
        if( ERROR_FILE_NOT_FOUND == dwRes )
        {
            InstallInfo("Warning: SG service appears to not be installed, skipping");
        }
        else if( ERROR_SUCCESS != dwRes )
        {
            InstallInfo("Error: Service uninstall failed with Win32 error %d", dwRes);
            fServiceSucceeded = FALSE;
        }

        // Uninstall rawnic
        fDriverSucceeded = SgServiceUninstall(&fRebootRequired);
        if (!fDriverSucceeded)
        {
            InstallInfo("Warning: RAWNIC driver uninstall failed (reboot is%s required)", fRebootRequired ? "" : " not");
        }

        return MapToReturnCode(fServiceSucceeded, fDriverSucceeded, fRebootRequired);
    }
};


// ---------------------------------------------------------------------------------------
// Main entrypoint
// ---------------------------------------------------------------------------------------

CSgService   g_SgService;
CNTService * g_pService = &g_SgService;
int __cdecl wmain(int argc, WCHAR ** argv)
{
    // Pass control to the service layer
    return g_SgService.ProcessMain( argc, argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsecmsg.cpp ===
// ---------------------------------------------------------------------------------------
// sgsecmsg.cpp
//
// Security Message Handlers
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiChalAck(CPacket * ppkt);
void SgIRecvSecMsgWithSpiChalResp(CPacket * ppkt);
void SgIRecvSecMsgWithSpiChalResp2(CPacket * ppkt);
void SgIRecvSecMsgWithSpiChalResp3(CPacket * ppkt);
void SgIRecvSecMsgWithSpiChangeUsers(CPacket * ppkt);
void SgIRecvSecMsgWithSpiForward(CPacket * ppkt);
void SgIRecvSecMsgWithSpiForward2(CPacket * ppkt);
void SgIRecvSecMsgWithSpiNatDetection(CPacket * ppkt);
void SgIRecvSecMsgWithSpiPulse(CPacket * ppkt);
void SgIRecvSecMsgWithSpiQosInit(CPacket * ppkt);


// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpi
//
// This function continues processing of a security-message packet from SgIRecv
// ---------------------------------------------------------------------------------------

void SgIRecvSecMsgWithSpi(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo != NULL);

    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    if (ppkt->_cb < sizeof(CSecMsgHdr) || ppkt->_cb < pSecMsgHdr->_cbEnt)
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg packet has wrong size (UDP %d, cbEnt %d)",
                 ppkt->Str(), ppkt->_dwSeq, ppkt->_cb,
                 ppkt->_cb < sizeof(CSecMsgHdr) ? 0 : pSecMsgHdr->_cbEnt);
        SgEventPacket(INVALID_SECMSG, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc, ppkt->_cb, ppkt->_pb);
        goto complete;
    }

    TraceSz(RecvSecMsg, "%s #%d: [SecMsg %04X/%s]{+%d}",
             ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
             SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);

    if (Tag(SpiFlow))
    {
        CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;

        TraceSz(SpiFlow, "#%d %08lX SEC << %c%d [%s:%d %s:%d] %04X/%s (+%d)",
                  ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                  pTransInfoRecv ? (char)pTransInfoRecv->_dwType : 'L', pTransInfoRecv->_iTransInfo,
                  pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI),
                  pTransInfoRecv->_ipa.Str(), NTOHS(XSP_PORT), pSecMsgHdr->_wType,
                  SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb - sizeof(CSecMsgHdr));

        SgHexDumpSpiFlow(ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv, (BYTE *)(pSecMsgHdr + 1), ppkt->_cb - sizeof(CSecMsgHdr), NULL, 0, NULL, 0);
    }

    //
    // Process packet statistics for instrusion detection, DoS prevention, reporting, etc.
    // Function should be very quick.
    //
    SgClientStatsProcessPacket(ppkt, NULL);

    if (pSecMsgHdr->_wType == SECMSG_TYPE_DELETE)
    {
        if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgDelete))
        {
            TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                     SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
            goto complete;
        }

#ifdef SG_FEATURE_LUA
        //
        // If we have sent the Key-Ex packet to the client and got back a delete
        // before we got the answer, then notify the challenges
        //
        // Alternatively, if we are in the middle of an async challenge, then
        // notity the challenges. Note that the Async bit is set as soon as we
        // assign a challenge to the SPI and cleared when we receive a 
        // response. It is not set while we are waiting to issue another
        // challenge
        // 
        SgChalDropped(pSpiInfo);
#endif

        SgPerfdataInc(SecDelete, 1);

        CSecMsgDelete * pSecMsgDelete = (CSecMsgDelete *)pSecMsgHdr;

        TraceSz(SpiTrace, "%08lX released PUID %016I64X (%s)", pSpiInfo->_dwSpiRecv,
                 pSpiInfo->_puid,
                 SgSecMsgDelStr(pSecMsgDelete->_dwReason));
        SgSpiInfoFree(pSpiInfo, SPIDEL_CLIENT);
        goto complete;
    }

    //
    // Key Exchange Response Handling
    // 
    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP)
    {
        SgIRecvSecMsgWithSpiChalResp( ppkt );
        return;
    }
    else if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP_3) 
    {
        SgIRecvSecMsgWithSpiChalResp3( ppkt );
        return;
    }


    //
    // If we haven't gotten an XBTOSG_CHALRESP at this point, ignore the message.
    // The caller must answer the challenge in order to continue
    // 
    if (pSpiInfo->_qwTickKeyEx2 == 0)
    {
        TraceSz(RecvDiscard, "%s: SecMsg %04X/%s before challenge response",
                 ppkt->Str(), pSecMsgHdr->_wType, SgSecMsgStr(pSecMsgHdr->_wType));
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_PULSE)
    {
        if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgPulse))
        {
            TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                     SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
            goto complete;
        }

        SgPerfdataInc(SecPulse, 1);

        // Nothing else to do with this message.  It was only sent to let us know that the
        // other side is still alive.

        goto complete;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_PULSE)
    {
        SgIRecvSecMsgWithSpiPulse( ppkt );
        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOXB_FORWARD && g_fEnableConnectionServices)
    {
        SgIRecvSecMsgWithSpiForward( ppkt );
        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOXB_FORWARD2 && g_fEnableConnectionServices)
    {
        SgIRecvSecMsgWithSpiForward2( ppkt );
        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_QOS_INIT)
    {
        SgIRecvSecMsgWithSpiQosInit( ppkt );
        return;
    }

    if (   pSecMsgHdr->_wType == SECMSG_TYPE_CHANGE_USERS_REQ
#ifdef SG_FEATURE_INSECURE
        || pSecMsgHdr->_wType == SECMSG_TYPE_CHANGE_USERS_NULL
#endif
        )
    {
        SgIRecvSecMsgWithSpiChangeUsers( ppkt );
        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_NATDET_REQ)
    {
        SgIRecvSecMsgWithSpiNatDetection( ppkt );
        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHAL_ACK)
    {
        SgIRecvSecMsgWithSpiChalAck( ppkt );
        return;
    }

#ifdef SG_FEATURE_LUA
    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP_2)
    {
        SgIRecvSecMsgWithSpiChalResp2( ppkt );
        return;
    }
#endif // #ifdef SG_FEATURE_LUA

    TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s not supported (payload %d bytes)",
             ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
             SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);

    goto complete;

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiChalAck
//
// This function handles SECMSG_TYPE_XBTOSG_CHAL_ACK
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiChalAck(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;


    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgChalAck))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

#ifdef SG_FEATURE_LUA
    CSecMsgXbToSgChalAck * pSecMsgChalAck = (CSecMsgXbToSgChalAck *)pSecMsgHdr;

    //
    // See if the client has acknowledged our chal message
    //

    if (pSecMsgChalAck->_dwChallengeNonce == pSpiInfo->_dwChallengeNonce)
    {
        //
        // Yes, it has, so disable the resend the timer
        //

        if (pSpiInfo->_dwChalAsyncState == SPI_CHAL_ASYNC_STATE_WAIT_FOR_ACK) 
        {
            SgLuaChalSetAsyncStateWaitForResp( pSpiInfo );

            TraceSz(
                ChalTrace,
                "[%08lX] ack received at %08lx for nonce %08lx",
                pSpiInfo->_dwSpiRecv,
                SgTimerTick(),
                pSpiInfo->_dwChallengeNonce
                );
        }
        else
        {
            TraceSz(
                ChalTrace,
                "[%08lX] ack received at %08lx for nonce %08lx in non-ack state %d",
                pSpiInfo->_dwSpiRecv,
                SgTimerTick(),
                pSpiInfo->_dwChallengeNonce,
                pSpiInfo->_dwChalAsyncState
                );
        }

    }
    else
    {
        TraceSz(
            ChalTrace,
            "[%08lX] incorrect ack received for nonce %08lx != %08x",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwChallengeNonce,
            pSecMsgChalAck->_dwChallengeNonce
            );
    }
#endif

    //
    // Nothing more to do with this message. Maybe have some kinds of
    // stats tracking or similar code here?
    //

complete:
    ppkt->Complete();
    return;

}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiChalResp
//
// This function handles SECMSG_TYPE_XBTOSG_CHALRESP
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiChalResp(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgChalResp))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    //
    // We will only process this message during key exchange
    //

    if (pSpiInfo->_qwTickKeyEx2 != 0)
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s received during non key-ex",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType));
        goto complete;
    }

    //
    // Note: we can't get here without LUA enabled, so falling thru to the Complete
    // stage if LUA isn't compiled in shouldn't do anything different
    // 

#ifdef SG_FEATURE_LUA

    SgChalProcessSyncResponse( ppkt );
    return;

#endif // #ifdef SG_FEATURE_LUA

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiChalResp2
//
// This function handles SECMSG_TYPE_XBTOSG_CHALRESP_2
// ---------------------------------------------------------------------------------------
#ifdef SG_FEATURE_LUA
void SgIRecvSecMsgWithSpiChalResp2(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;


    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgChalResp2))
    {
        TraceSz(
            RecvDiscard,
            "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
            ppkt->Str(),
            ppkt->_dwSeq,
            pSecMsgHdr->_wType,
            SgSecMsgStr(pSecMsgHdr->_wType),
            ppkt->_cb
            );
        goto complete;
    }

    //
    // Validate the challenge response.
    //

    BOOL fKickCode = FALSE;
    DWORD dwReason = SPIDEL_CHALLENGE_LUA;
    DWORD dwChallengeNonce = 0;
    DWORD dwChalCodeId = 0;
    DWORD dwChalCodeParamId = 0;

    CSecMsgXbToSgChalResp2 * pSecMsgChalResp = (CSecMsgXbToSgChalResp2 *)pSecMsgHdr;

    //
    // Sanity check that the nonce matches
    //

    if (pSecMsgChalResp->_dwChallengeNonce != pSpiInfo->_dwChallengeNonce)
    {
        TraceSz(
            ChalTrace,
            "[%08lX] incorrect chalresp for nonce %08lx != %08lx",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwChallengeNonce,
            pSecMsgChalResp->_dwChallengeNonce
            );
        goto complete;
    }
    dwChallengeNonce = pSpiInfo->_dwChallengeNonce;

    //
    // Did we already process this answer?
    //

    if (SgLuaChalStateEnabled(pSpiInfo) == FALSE)
    {
        SgIXmitSecMsgSgToXbChallengeRespAck(pSpiInfo, ppkt, dwChallengeNonce);
        return;
    }

    //
    // Remember what the code id and param id was for logging
    //

    dwChalCodeId = pSpiInfo->_dwLuaChalCodeId;
    dwChalCodeParamId = pSpiInfo->_dwLuaChalCodeParamId;

    //
    // At this point, we have a valid response
    // 

    SgPerfdataInterlockedInc( ChalAsyncResponse );

    //
    // Yes. So call into the lua engine to process the response
    //

    SgLuaChalAnalyze(
        pSpiInfo,
        pSecMsgChalResp->_abExecute,
        sizeof(pSecMsgChalResp->_abExecute)
        );

    //
    // Grab the flags that result from that operation
    //

    if (SgLuaChalStateBlock(pSpiInfo) == TRUE) 
    {
        TraceSz(
            SpiTrace,
            "%08lX: nonce %08lx block",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwChallengeNonce
            );

        fKickCode = true;

        SgPerfdataInterlockedInc( ChalAsyncBlock );
        SgBlockInfoBlockPuid( &(pSpiInfo->_puid) );
    }
    else if (SgLuaChalStateKick(pSpiInfo) == TRUE) 
    {
        TraceSz(
            SpiTrace,
            "%08lX: nonce %08lx kick",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwChallengeNonce
            );

        fKickCode = true;
        SgPerfdataInterlockedInc( ChalAsyncFail );
    }
    else
    {
        //
        // At this point, we consider this challenge as having passed
        // 

        SgPerfdataInterlockedInc( ChalAsyncPass );
    }

    if (SgLuaChalStateLog(pSpiInfo) == TRUE)
    {
        TraceSz(
            ChalTrace,
            "[%08lX] nonce %08lx log code %s",
            pSpiInfo->_dwSpiRecv,
            pSpiInfo->_dwChallengeNonce,
            SgHexDumpStr(pSecMsgChalResp->_abExecute, sizeof(pSecMsgChalResp->_abExecute))
            );

        CLogChallenge lc;

        lc._fCodeLog        = TRUE;
        lc._fCodeKick       = fKickCode;
        lc._dwChalCodeId    = dwChalCodeId;
        lc._iChalCodeParam  = dwChalCodeParamId;

        SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_LOGCHAL, &lc, pSecMsgChalResp);
    }

    //
    // Set the timer for the next challenge
    //

    SgLuaChalSetAsyncStateIdle(pSpiInfo);

    //
    // Reset the lua state
    //

    SgLuaChalStateClear(pSpiInfo);

    //
    // Kick the client if necessary
    //

    if (fKickCode)
    {
        //
        // free and detach will "silently" drop a client, without telling him what
        // happened. This spams our event log with "unknown spi" messages. May be
        // better to call SgSpiInfoKick(), which will send a SECMSG_DELETE to the
        // client, forcing him to disconnect immediately.
        // 

        SgSpiInfoFree(pSpiInfo, dwReason);
        SgSpiInfoDetach(ppkt);
        goto complete;

    }

    //
    // Send the client an ack
    //

    SgIXmitSecMsgSgToXbChallengeRespAck(pSpiInfo, ppkt, dwChallengeNonce);
    return;

complete:
    ppkt->Complete();
    return;

}
#endif

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiChalResp3
//
// This function handles SECMSG_TYPE_XBTOSG_CHALRESP_3
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiChalResp3(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgChalResp3))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    //
    // We will only process this message during key exchange
    //

    if (pSpiInfo->_qwTickKeyEx2 != 0)
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s received during non key-ex",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType));
        goto complete;
    }

    //
    // Note: we can't get here without LUA enabled, so falling thru to the Complete
    // stage if LUA isn't compiled in shouldn't do anything different
    // 

#ifdef SG_FEATURE_LUA

    SgChalProcessSyncResponse( ppkt );
    return;

#endif // #ifdef SG_FEATURE_LUA

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiChangeUsers
//
// This function handles SECMSG_TYPE_XBTOSG_CHANGE_USERS_REQ and
//                       SECMSG_TYPE_XBTOSG_CHANGE_USERS_NULL
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiChangeUsers(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;


    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgChangeUsersReq))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    SgPerfdataInc(SecChangeUsers, 1);

    CSecMsgChangeUsersReq * pSecMsgChangeUsersReq = (CSecMsgChangeUsersReq *)pSecMsgHdr;

    CKeyExCtx * pKeyExCtx = (CKeyExCtx *)ppkt->_abCtx;
    CUserInfo   aUserInfo[4];
    UINT        i, j;

    pKeyExCtx->_pKeyExApReq = (CKeyExHdr*)( pSecMsgChangeUsersReq + 1 );

#ifdef SG_FEATURE_INSECURE
    if( SECMSG_TYPE_CHANGE_USERS_NULL == pSecMsgHdr->_wType )
    {
        if( !SgCrackNullApReq( ppkt ) )
        {
            TraceSz(RecvDiscard, "%s: SgCrackNullApReq failed processing SecMsg %04X/%s", ppkt->Str(),
                     pSecMsgChangeUsersReq->_wType, SgSecMsgStr(pSecMsgChangeUsersReq->_wType));
            SgEventPacket(INVALID_KERBEROS_TICKET_2, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                          pSecMsgChangeUsersReq->_cbEnt, pSecMsgChangeUsersReq);
            goto complete;
        }
    }
    else
#endif
    if (!SgCrackKerbApReq(ppkt, (BYTE *)(pSecMsgChangeUsersReq + 1), pSecMsgChangeUsersReq->_cbEnt - sizeof(CSecMsgChangeUsersReq)))
    {
        TraceSz(RecvDiscard, "%s: SgCrackKerbApReq failed processing SecMsg %04X/%s", ppkt->Str(),
                 pSecMsgChangeUsersReq->_wType, SgSecMsgStr(pSecMsgChangeUsersReq->_wType));
        SgEventPacket(INVALID_KERBEROS_TICKET_2, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                     pSecMsgChangeUsersReq->_cbEnt, pSecMsgChangeUsersReq);
        goto complete;
    }

    // Reorder the users and set guest bits in auth data
    SgKeyExPermute( &pKeyExCtx->_AuthData, pSecMsgChangeUsersReq->_dwUserPerm );

    // Remember the ticket expiry time
    pSpiInfo->_qwTickTicketStart = SgTimerTick();
    pSpiInfo->_qwTickTicketEnd   = pSpiInfo->_qwTickTicketStart + (pKeyExCtx->_dwLifetimeInSeconds * TICKS_PER_SECOND);

#ifdef SG_FEATURE_LUA

    // Determine now if we need to apply the filters later. We do this now because we need to determine
    // if the ticket has changed in interesting ways before we copy the new ticket over the old ticket

    bool fNeedFilter = false;
    if (memcmp( &(pSpiInfo->_AuthData), &(pKeyExCtx->_AuthData), offsetof( XKERB_AD_XENON2, abReserved ) ) != 0)
    {
        fNeedFilter = true;
    }
#endif

    // The SpiInfo does not contain the new user information yet, so it is not possible to actually
    // send a log entry at this point.  So, just tracking that the users information has changed in
    // the ticket, and later in the function, when the SpiInfo is correct, send the log.

    bool fUsersChanged = false;
    // Log the new users appearing in the system.
    for (i = 0; i < XONLINE_MAX_LOGON_USERS; ++i)
    {
        // If the users are different, or the guest status changes, log the change
        if ( pKeyExCtx->_AuthData.users[i].qwUserID != pSpiInfo->_AuthData.users[i].qwUserID)
        {
            fUsersChanged = true;
            break;
        }

        if (XOnlineIsUserGuest(pSpiInfo->_AuthData.users[i].dwUserFlags) !=
            XOnlineIsUserGuest(pKeyExCtx->_AuthData.users[i].dwUserFlags) ||
            XOnlineUserCountryId(pSpiInfo->_AuthData.users[i].dwUserFlags) !=
            XOnlineUserCountryId(pKeyExCtx->_AuthData.users[i].dwUserFlags) ) 
        {
            fUsersChanged = true;
            break;
        }
    }

    // The flow token should never change during an existing session, but who knows -- 
    // client bug? -- we should catch it just in case.
    bool fFlowTokenChanged = false;
    if (pKeyExCtx->_AuthData.flowToken.flowToken != pSpiInfo->_AuthData.flowToken.flowToken)
    {
        fFlowTokenChanged = true;
    }

    bool fVersionChanged = false;
    DWORD dwOldClientVer = CLIENTVERSION_TO_DWORD(pSpiInfo->_AuthData.clientVersion);
    DWORD dwNewClientVer = CLIENTVERSION_TO_DWORD(pKeyExCtx->_AuthData.clientVersion);
    if (pKeyExCtx->_AuthData.dwTitleVersion != pSpiInfo->_AuthData.dwTitleVersion ||
        dwNewClientVer != dwOldClientVer)
    {
        fVersionChanged = true;
    }

    bool fServicesChanged = false;
    if (pSpiInfo->_AuthData.dwAuthDataFlags != pKeyExCtx->_AuthData.dwAuthDataFlags ||
        memcmp( pSpiInfo->_AuthData.dwBaseServices, pKeyExCtx->_AuthData.dwBaseServices, XONLINE_NUM_BASE_SERVICES_DWORDS * sizeof(DWORD) ) != 0 ||
        memcmp( pSpiInfo->_AuthData.dwExtendedServices, pKeyExCtx->_AuthData.dwExtendedServices, XONLINE_MAX_DWORD_SERVICEIDS * sizeof(DWORD) ) != 0)
    {
        fServicesChanged = true;
    }

    // Copy the new AuthData into the SpiInfo
    pSpiInfo->_AuthData = pKeyExCtx->_AuthData;
#ifdef SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
    SgConvertAuthData4ToAuthData3(&pSpiInfo->_AuthData, &pSpiInfo->_AuthDataV3);
#endif

    pSpiInfo->_svcMask = SgSvcInfoMask(
        pKeyExCtx->_AuthData.wNumExtendedServices,
        pKeyExCtx->_AuthData.dwExtendedServices,
        ServiceMask(pKeyExCtx->_AuthData.dwBaseServices) );
    pSpiInfo->_svcMaskOrig = pSpiInfo->_svcMask;

    // If users have moved around, move their information in the SpiInfo
    memcpy(aUserInfo, pSpiInfo->_aUserInfo, sizeof(aUserInfo));
    memset(pSpiInfo->_aUserInfo, 0, sizeof(pSpiInfo->_aUserInfo));

    for (i = 0; i < XONLINE_MAX_LOGON_USERS; ++i)
    {
        if (!XOnlineIsUserGuest(pSpiInfo->_AuthData.users[i].dwUserFlags))
        {
            pSpiInfo->_aUserInfo[i]._qwUserId = pSpiInfo->_AuthData.users[i].qwUserID;
            for (j = 0; j < XONLINE_MAX_LOGON_USERS; ++j)
            {
                if (pSpiInfo->_aUserInfo[i]._qwUserId == aUserInfo[j]._qwUserId)
                {
                    memcpy(&pSpiInfo->_aUserInfo[i], &aUserInfo[j], sizeof(pSpiInfo->_aUserInfo[i]));
                    break;
                }
            }

            Assert(pSpiInfo->_aUserInfo[i]._qwUserId == pSpiInfo->_AuthData.users[i].qwUserID);
        }
    }

#ifdef SG_FEATURE_LUA

    // if we determined that we needed to apply the filter, then do so now. Note that
    // this will prevent TCHG and UCHG entries from being logged if the filter's block
    // is applied. This is desirable behavior.

    if (fNeedFilter)
    {
        SgApplyFilterScriptWithSpi( pSpiInfo );
        if (pSpiInfo->_dwSpiFlags & SPIFLAG_BLOCK)
        {
            // FilterBlock() will apply the kick...
            SgIndicateSgSvcClient( pSpiInfo, SGSVC_TYPE_CLIENT_CHG, NULL, pKeyExCtx );
            TraceSz(SpiTrace, "%08lx released PUID %016I64X (AuthBlock)",
                     pSpiInfo->_dwSpiRecv, pSpiInfo->_puid);
            goto complete;
        }
    }

#endif

    // If the title ID changed, notify interested services
    bool fTitleChanged = false;
    if( pSpiInfo->_AuthData.dwTitleID != pSpiInfo->_dwLastTitleId )
    {
        fTitleChanged = true;
        // Panorama? Bad! Bad Panorama!
        if (pSpiInfo->_AuthData.GetPlatform() == XPLT_PC)
        {
            TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s PC client changing title from 0x%08X to 0x%08X",
                ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType, SgSecMsgStr(pSecMsgHdr->_wType),
                pSpiInfo->_dwLastTitleId, pSpiInfo->_AuthData.dwTitleID);

            CTinyStr logtext;
            logtext.Format("Original title: 0x%08X, new title: 0x%08X", pSpiInfo->_dwLastTitleId, pSpiInfo->_AuthData.dwTitleID);
            SgEventPacketWithText(POLICY_PC_TITLE_CHANGE, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pXspHdr->_ipportSrc,
                     pSecMsgChangeUsersReq->_cbEnt, pSecMsgChangeUsersReq, logtext.cstr());

            // SgSpiInfoKick sends a friendly SECMSG_DELETE to the client
            // SgSpiInfoDetach separates the packet from the spi
            // ppkt->Complete is important so we don't leak packets, it will end up
            // calling SgPacketComplete() to return it to the free list.
            SgSpiInfoKick(pSpiInfo, SECMSG_DELETE_KICK, SPIDEL_POLICY);
            SgSpiInfoDetach(ppkt);
            pSpiInfo = NULL;
            goto complete;
        }
    }

    // If something (title, users, nonce) has changed that we care about, log the 
    // appropriate loglines.
    if (fUsersChanged || fTitleChanged || fFlowTokenChanged || fVersionChanged || fServicesChanged)
    {
        if (fUsersChanged)
        {
            SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_UCHG, NULL, aUserInfo);
        }
        if (fTitleChanged) 
        {
            SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_TCHG, NULL, NULL);
        }
        if (fServicesChanged) 
        {
            SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_SCHG, NULL, NULL);
        }

        SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_FLOWMAP, NULL, NULL);

#ifdef SG_FEATURE_LUA

        // If anything changed at all, then updated the Async Challenge state
        // to indicate that this spi needs a new challenge
        SgChalCodeUpdateSpiInfo(pSpiInfo);

#endif

    }

    CSecMsgChangeUsersRep * pSecMsgChangeUsersRep = (CSecMsgChangeUsersRep *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];

    pSecMsgChangeUsersRep->_wType  = SECMSG_TYPE_CHANGE_USERS_REP;
    pSecMsgChangeUsersRep->_cbEnt  = sizeof(CSecMsgChangeUsersRep);
    pSecMsgChangeUsersRep->_liTime = pSecMsgChangeUsersReq->_liTime;

    ppkt->_pb = (BYTE *)pSecMsgChangeUsersRep;
    ppkt->_cb = sizeof(CSecMsgChangeUsersRep);

    SgIXmitSecMsgWithSpi(ppkt);

    return;

complete:
    ppkt->Complete();
    return;

}


// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiForward
//
// This function handles SECMSG_TYPE_XBTOSG_FORWARD
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiForward(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToXbForward))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    if (!pSpiInfo->_fCs)
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s requested by non-CS client",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    SgPerfdataInc(SecForward, 1);

    CSecMsgXbToXbForward * pSecMsgXbToXbForward = (CSecMsgXbToXbForward *)pSecMsgHdr;
    CTransInfo *           pTransInfoXmit       = pSpiInfo->_pNatInfo->_pTransInfo;

    SgSpiInfoDetach(ppkt);
    pSpiInfo = NULL;

    if (SgTransInfoLookupZ(pSecMsgXbToXbForward->_sgaddr.inaSg) != NULL)
        SgSpiInfoAttach(ppkt, SgIRecvSecMsgForwardWithSpi, pSecMsgXbToXbForward->_sgaddr.dwSpiSg);
    else
        SgZXmitSgMsgForward(ppkt, pTransInfoXmit, &pSecMsgXbToXbForward->_sgaddr,
                            (BYTE *)pSecMsgXbToXbForward + sizeof(CSecMsgXbToXbForward),
                            pSecMsgXbToXbForward->_cbEnt - sizeof(CSecMsgXbToXbForward));
    return;

complete:
    ppkt->Complete();
    return;

}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiForward2
//
// This function handles SECMSG_TYPE_XBTOSG_FORWARD2
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiForward2(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToXbForward2))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    if (!pSpiInfo->_fCs)
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s requested by non-CS client",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType));
        goto complete;
    }

    SgPerfdataInc(SecForward2, 1);

    CSecMsgXbToXbForward2 * pSecMsgXbToXbForward2 = (CSecMsgXbToXbForward2 *)pSecMsgHdr;
    CTransInfo *            pTransInfoXmit        = pSpiInfo->_pNatInfo->_pTransInfo;

    // Verify that the sender SGADDR matches the one associated with this SPI

    if(!SgSpiInfoMatchesSgAddr(pSpiInfo, &pSecMsgXbToXbForward2->_sgaSender))
    {
        SGADDR ourSgAddr;
        SgSpiInfoToSgAddr(pSpiInfo, &ourSgAddr);
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s invalid sgaSender %s != %s",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType),
                 SgHexStr(&pSecMsgXbToXbForward2->_sgaSender,
                          sizeof(pSecMsgXbToXbForward2->_sgaSender)),
                 SgHexStr(&ourSgAddr,
                          sizeof(ourSgAddr)));
        goto complete;
    }

    SgSpiInfoDetach(ppkt);
    pSpiInfo = NULL;

    if (SgTransInfoLookupZ(pSecMsgXbToXbForward2->_sgaTarget.inaSg) != NULL)
    {
        SgSpiInfoAttach(ppkt, SgIRecvSecMsgForward2WithSpi, pSecMsgXbToXbForward2->_sgaTarget.dwSpiSg);
    }
    else
    {
        SgZXmitSgMsgForward2(ppkt, pTransInfoXmit, &pSecMsgXbToXbForward2->_sgaSender,
                             &pSecMsgXbToXbForward2->_sgaTarget,
                             (BYTE *)pSecMsgXbToXbForward2 + sizeof(CSecMsgXbToXbForward2),
                             pSecMsgXbToXbForward2->_cbEnt - sizeof(CSecMsgXbToXbForward2));
    }
    return;

complete:
    ppkt->Complete();
    return;

}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiNatDetection
//
// This function handles SECMSG_TYPE_XBTOSG_NATDET_REQ
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiNatDetection(CPacket * ppkt)
{
    CSpiInfo   * pSpiInfo      = ppkt->_pSpiInfo;
    CSecMsgHdr * pSecMsgHdrRep = (CSecMsgHdr *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];

    pSecMsgHdrRep->_wType = SECMSG_TYPE_SGTOXB_NATDET_REP;
    pSecMsgHdrRep->_cbEnt = sizeof(CSecMsgHdr);

    ppkt->_pb = (BYTE *)pSecMsgHdrRep;
    ppkt->_cb = pSecMsgHdrRep->_cbEnt;

    if(!pSpiInfo->_fCs)
    {
        // Get the clock ticking for the Nat detection disconnect (if
        // configured)
        pSpiInfo->_qwTickNatDetect = SgTimerTick();
    }

    SgIXmitSecMsgWithSpi(ppkt);
    return;
}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiPulse
//
// This function handles SECMSG_TYPE_XBTOSG_PULSE
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiPulse(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    if (!pSpiInfo->_fCs)
    {
        if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgPulse))
        {
            TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                     SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
            goto complete;
        }

        goto complete;
    }

    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgPulse))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    SgPerfdataInc(SecDataPulse, 1);

    // Protect against packet reordering by ignoring any XbToSg pulse that isn't newer than
    // the last one processed.

    if (ppkt->_dwSeq < pSpiInfo->_dwSeqXbToSgHigh)
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s dwSeq less than highest processed (#%d)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType, SgSecMsgStr(pSecMsgHdr->_wType),
                 pSpiInfo->_dwSeqXbToSgHigh);
        goto complete;
    }

    pSpiInfo->_dwSeqXbToSgHigh = ppkt->_dwSeq;

    CSecMsgXbToSgPulse * pSecMsgXbToSgPulse = (CSecMsgXbToSgPulse *)pSecMsgHdr;
    BOOL                 fUpdated           = FALSE;
    UINT                 cb                 = pSecMsgXbToSgPulse->_cbEnt - sizeof(CSecMsgXbToSgPulse);

    if (pSpiInfo->_dwSeqSgToXb > 0 && pSecMsgXbToSgPulse->_dwSeqAck >= pSpiInfo->_dwSeqSgToXb)
    {
        // The client has acknowledged receiving our most recent SgToXb pulse that contained
        // any CQVal changes.  We can now clear each user's bitmask of values in transit.

        pSpiInfo->_dwSeqSgToXb  = 0;
        pSpiInfo->_fSgToXbPulse = FALSE;

        CUserInfo * pUserInfo    = pSpiInfo->_aUserInfo;
        CUserInfo * pUserInfoEnd = pSpiInfo->_aUserInfo + dimensionof(pSpiInfo->_aUserInfo);

        for (; pUserInfo < pUserInfoEnd; ++pUserInfo)
        {
            pUserInfo->_dwQValTransmit = 0;

            if (pUserInfo->_dwQValModified != 0)
            {
                // This user has one or values that have been modified since the last time
                // we sent an SgToXb pulse.  As a result, we need to keep the _fSgToXbPulse
                // flag set to TRUE to force these values to be sent at the next opportunity.

                pSpiInfo->_fSgToXbPulse = TRUE;
            }
        }
    }

    // See if the client is sending any data up on the pulse
    if (cb > 0)
    {
        BYTE * pb = (BYTE *)(pSecMsgXbToSgPulse + 1);

        while (cb > 0)
        {
            BYTE b = *pb++;
            cb    -= 1;

            if (    (b & ~(XBPULSE_STATE_CHANGE|XBPULSE_XNKID_CHANGE|XBPULSE_TDATA_CHANGE|XBPULSE_TITLE_CHANGE)) != 0
                ||  (b &  (XBPULSE_STATE_CHANGE|XBPULSE_XNKID_CHANGE|XBPULSE_TDATA_CHANGE|XBPULSE_TITLE_CHANGE)) == 0)
            {
                TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has bad control byte (%02X)",
                         ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                         SgSecMsgStr(pSecMsgHdr->_wType), b);
                break;
            }

            if (cb < sizeof(ULONGLONG))
            {
                TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s ends prematurely (USERID) (cb=%d,cbReq=%d)",
                         ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                         SgSecMsgStr(pSecMsgHdr->_wType), cb, sizeof(ULONGLONG));
                break;
            }

            ULONGLONG qwUserId = *(ULONGLONG *)pb;
            pb += sizeof(ULONGLONG);
            cb -= sizeof(ULONGLONG);

            CUserInfo   UserInfoNull;
            CUserInfo * pUserInfo    = pSpiInfo->_aUserInfo;
            CUserInfo * pUserInfoEnd = pSpiInfo->_aUserInfo + dimensionof(pSpiInfo->_aUserInfo);

            for (; pUserInfo < pUserInfoEnd; ++pUserInfo)
            {
                if (pUserInfo->_qwUserId == qwUserId)
                    break;
            }

            if (pUserInfo == pUserInfoEnd)
            {
                // Can't find the user.  We might be out of sync with the client.  Just ignore the
                // update to this user.

                TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s can't find qwUserId %016I64X",
                         ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                         SgSecMsgStr(pSecMsgHdr->_wType), qwUserId);

                pUserInfo = &UserInfoNull;
            }
            else
            {
                fUpdated = TRUE;
                pUserInfo->_fUpdated = TRUE;
            }

            if (b & XBPULSE_STATE_CHANGE)
            {
                if (cb < sizeof(DWORD))
                {
                    TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s ends prematurely (STATE) (cb=%d,cbReq=%d)",
                             ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                             SgSecMsgStr(pSecMsgHdr->_wType), cb, sizeof(DWORD));
                    break;
                }

                DWORD dwPState = pUserInfo->_dwPState;

                pUserInfo->_dwPState = *(DWORD *)pb;
                pb += sizeof(DWORD);
                cb -= sizeof(DWORD);

                TraceSz(Pulse, "%s #%d: SecMsg %04X/%s user %I64X STATE_CHANGE %X => %X",
                        ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                        SgSecMsgStr(pSecMsgHdr->_wType),
                        qwUserId,
                        dwPState,
                        pUserInfo->_dwPState
                        );
            }

            if (b & XBPULSE_XNKID_CHANGE)
            {
                if (cb < sizeof(XNKID))
                {
                    TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s ends prematurely (XNKID) (cb=%d,cbReq=%d)",
                             ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                             SgSecMsgStr(pSecMsgHdr->_wType), cb, sizeof(XNKID));
                    break;
                }

                XNKID xnkid = pUserInfo->_xnkid;

                pUserInfo->_xnkid = *(XNKID *)pb;
                pb += sizeof(XNKID);
                cb -= sizeof(XNKID);

                TraceSz(Pulse, "%s #%d: SecMsg %04X/%s user %I64X XNKID_CHANGE %I64X => %I64X",
                        ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                        SgSecMsgStr(pSecMsgHdr->_wType),
                        qwUserId,
                        xnkid,
                        pUserInfo->_xnkid
                        );
            }

            if (b & XBPULSE_TDATA_CHANGE)
            {
                if (cb < 1 || (cb - 1) < *pb)
                {
                    TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s ends prematurely (TDATA) (cb=%d,cbReq=%d)",
                             ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                             SgSecMsgStr(pSecMsgHdr->_wType), cb, cb < 1 ? 1 : *pb + 1);
                    break;
                }

                pUserInfo->_cbData = *pb;
                memcpy(pUserInfo->_abData, pb + 1, *pb);
                cb -= *pb + 1;
                pb += *pb + 1;

                TraceSz(Pulse, "%s #%d: SecMsg %04X/%s user %I64X TDATA_CHANGE {+d}",
                        ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                        SgSecMsgStr(pSecMsgHdr->_wType),
                        qwUserId,
                        pUserInfo->_cbData
                        );
            }

            if (b & XBPULSE_TITLE_CHANGE)
            {
                if (cb < sizeof(DWORD))
                {
                    TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s ends prematurely (TITLE) (cb=%d,cbReq=%d)",
                             ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                             SgSecMsgStr(pSecMsgHdr->_wType), cb, sizeof(DWORD));
                    break;
                }

                DWORD dwTitleId = pUserInfo->_dwTitleId;

                pUserInfo->_dwTitleId = *(DWORD *)pb;
                pb += sizeof(DWORD);
                cb -= sizeof(DWORD);

                TraceSz(Pulse, "%s #%d: SecMsg %04X/%s user %I64X TITLE_CHANGE %X => %X",
                        ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                        SgSecMsgStr(pSecMsgHdr->_wType),
                        qwUserId,
                        dwTitleId,
                        pUserInfo->_dwTitleId
                        );
            }
        }

        pSpiInfo->_dwSeqXbToSg = ppkt->_dwSeq;
    }

    if (fUpdated)
    {
        SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_UPD, NULL, NULL);
    }

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgIRecvSecMsgWithSpiQosInit
//
// This function handles SECMSG_TYPE_XBTOSG_QOS_INIT
// ---------------------------------------------------------------------------------------
void SgIRecvSecMsgWithSpiQosInit(CPacket * ppkt)
{
    CSpiInfo *      pSpiInfo   = ppkt->_pSpiInfo;
    CSecMsgHdr *    pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

    LARGE_INTEGER liTscNow, liTscFreq;
    liTscNow = SgQueryPerformanceCounter(&liTscFreq);

    if (pSecMsgHdr->_cbEnt < sizeof(CSecMsgXbToSgQosInit))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s has incorrect payload size (%d bytes)",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                 SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb);
        goto complete;
    }

    SgPerfdataInc(SecQos, 1);

    CSecMsgXbToSgQosInit * pSecMsgXbToSgQosInit = (CSecMsgXbToSgQosInit *)pSecMsgHdr;
    CSecMsgSgToXbQosResp * pSecMsgSgToXbQosResp;

    if ((pSecMsgXbToSgQosInit->_bFlags & QPF_DATA_REQ) == 0)
    {
        CQosProbe * pQosProbe = pSpiInfo->_aQosProbe;
        UINT        cQosProbe = dimensionof(pSpiInfo->_aQosProbe);

        for (; cQosProbe > 0; --cQosProbe, ++pQosProbe)
        {
            if (pQosProbe->_bPktIdx != pSecMsgXbToSgQosInit->_bPktIdx)
                continue;

            if (pQosProbe->_wQosIdx != pSecMsgXbToSgQosInit->_wQosIdx)
                continue;

            Assert(sizeof(pQosProbe->_abNonce) == sizeof(pSecMsgXbToSgQosInit->_abNonce));

            if (memcmp(pQosProbe->_abNonce, pSecMsgXbToSgQosInit->_abNonce, sizeof(pQosProbe->_abNonce)) != 0)
                continue;

            break;
        }

        if (pSecMsgXbToSgQosInit->_bFlags & QPF_PAIR_TWO)
        {
            if (cQosProbe == 0 || !pQosProbe->_fWaiting)
            {
                TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s second packet failed to find match for %s/%d #%d",
                         ppkt->Str(), ppkt->_dwSeq, pSecMsgHdr->_wType,
                         SgSecMsgStr(pSecMsgHdr->_wType),
                         SgHexStr(pSecMsgXbToSgQosInit->_abNonce, sizeof(pSecMsgXbToSgQosInit->_abNonce)),
                         pSecMsgXbToSgQosInit->_wQosIdx, pSecMsgXbToSgQosInit->_bPktIdx);
                goto complete;
            }

            CPacket * ppktTwo = SgPacketAlloc();

            if (ppktTwo == NULL)
            {
                TraceSz(Warning, "Unable to allocate a packet for Qos packet pair response");
                goto complete;
            }

            DWORD dwus = ((DWORD)((liTscNow.QuadPart - pQosProbe->_liTscRecv.QuadPart) * 1000000i64 / liTscFreq.QuadPart));

            pQosProbe->_fWaiting = FALSE;

            pSecMsgSgToXbQosResp = (CSecMsgSgToXbQosResp *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];

            pSecMsgSgToXbQosResp->_wType   = SECMSG_TYPE_SGTOXB_QOS_RESP;
            pSecMsgSgToXbQosResp->_cbEnt   = sizeof(CSecMsgSgToXbQosResp);
            memcpy(pSecMsgSgToXbQosResp->_abNonce, pSecMsgXbToSgQosInit->_abNonce, sizeof(pSecMsgSgToXbQosResp->_abNonce));
            pSecMsgSgToXbQosResp->_wQosIdx = pSecMsgXbToSgQosInit->_wQosIdx;
            pSecMsgSgToXbQosResp->_bPktIdx = pSecMsgXbToSgQosInit->_bPktIdx;
            pSecMsgSgToXbQosResp->_bFlags  = 0;
            pSecMsgSgToXbQosResp->_dwusRtt = dwus;
            pSecMsgSgToXbQosResp->_dwusGap = 0;

            ppkt->_pb = (BYTE *)pSecMsgSgToXbQosResp;
            ppkt->_cb = sizeof(CSecMsgSgToXbQosResp);

            CSecMsgSgToXbQosResp * pSecMsgSgToXbQosRespTwo = (CSecMsgSgToXbQosResp *)&ppktTwo->_abCtx[CBCTX_SKIP_SECMSG];

            memcpy(pSecMsgSgToXbQosRespTwo, pSecMsgSgToXbQosResp, sizeof(CSecMsgSgToXbQosResp));
            pSecMsgSgToXbQosRespTwo->_bFlags  = QPF_PAIR_TWO|QPF_DATA_NONE;
            pSecMsgSgToXbQosRespTwo->_dwusRtt = 0;
            pSecMsgSgToXbQosRespTwo->_dwusGap = dwus;

            ppktTwo->_pb = (BYTE *)pSecMsgSgToXbQosRespTwo;
            ppktTwo->_cb = sizeof(CSecMsgSgToXbQosResp);

            SgSpiInfoAttach(ppktTwo, SgIXmitSecMsgWithSpi, pSpiInfo->_dwSpiRecv);
            SgIXmitSecMsgWithSpi(ppkt);
            return;
        }

        if (cQosProbe == 0)
        {
            pSpiInfo->_iQosProbe = (pSpiInfo->_iQosProbe + 1) % dimensionof(pSpiInfo->_aQosProbe);

            pQosProbe = &pSpiInfo->_aQosProbe[pSpiInfo->_iQosProbe];

            memcpy(pQosProbe->_abNonce, pSecMsgXbToSgQosInit->_abNonce, sizeof(pQosProbe->_abNonce));
            pQosProbe->_wQosIdx = pSecMsgXbToSgQosInit->_wQosIdx;
            pQosProbe->_bPktIdx = pSecMsgXbToSgQosInit->_bPktIdx;
        }

        // This is the first of the pair of Qos packets.  Just remember the time this
        // one arrived and wait for the matching one to arrive before transmitting a
        // pair of our own.

        pQosProbe->_fWaiting  = TRUE;
        pQosProbe->_liTscRecv = liTscNow;
        goto complete;
    }

    // This is a request for Qos data.  Currently security gateways don't provide any
    // data, but we do respond to the client request (else it would retry a few times).

    pSecMsgSgToXbQosResp = (CSecMsgSgToXbQosResp *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];

    pSecMsgSgToXbQosResp->_wType   = SECMSG_TYPE_SGTOXB_QOS_RESP;
    pSecMsgSgToXbQosResp->_cbEnt   = sizeof(CSecMsgSgToXbQosResp);
    memcpy(pSecMsgSgToXbQosResp->_abNonce, pSecMsgXbToSgQosInit->_abNonce, sizeof(pSecMsgSgToXbQosResp->_abNonce));
    pSecMsgSgToXbQosResp->_wQosIdx = pSecMsgXbToSgQosInit->_wQosIdx;
    pSecMsgSgToXbQosResp->_bPktIdx = pSecMsgXbToSgQosInit->_bPktIdx;
    pSecMsgSgToXbQosResp->_bFlags  = QPF_DATA_REP;
    pSecMsgSgToXbQosResp->_dwusRtt = 0;
    pSecMsgSgToXbQosResp->_dwusGap = 0;

    ppkt->_pb = (BYTE *)pSecMsgSgToXbQosResp;
    ppkt->_cb = sizeof(CSecMsgSgToXbQosResp);

    SgIXmitSecMsgWithSpi(ppkt);
    return;

complete:
    ppkt->Complete();
    return;

}

void SgIRecvSecMsgForwardWithSpi(CPacket * ppkt)
{
    CSpiInfo *              pSpiInfo             = ppkt->_pSpiInfo;
    CSecMsgXbToXbForward *  pSecMsgXbToXbForward = (CSecMsgXbToXbForward *)ppkt->_pb;

    if (!pSpiInfo || !SgSpiInfoMatchesSgAddr(pSpiInfo, &pSecMsgXbToXbForward->_sgaddr))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s cannot find SGADDR %s",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgXbToXbForward->_wType,
                 SgSecMsgStr(pSecMsgXbToXbForward->_wType),
                 SgHexStr(&pSecMsgXbToXbForward->_sgaddr, sizeof(pSecMsgXbToXbForward->_sgaddr)));
        goto complete;
    }

    SgIXmitSecMsgWithSpi(ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}

void SgIRecvSecMsgForward2WithSpi(CPacket * ppkt)
{
    CSpiInfo *              pSpiInfo             = ppkt->_pSpiInfo;
    CSecMsgXbToXbForward2 *  pSecMsgXbToXbForward2 = (CSecMsgXbToXbForward2 *)ppkt->_pb;

    if (!pSpiInfo || !SgSpiInfoMatchesSgAddr(pSpiInfo, &pSecMsgXbToXbForward2->_sgaTarget))
    {
        TraceSz(RecvDiscard, "%s #%d: SecMsg %04X/%s cannot find SGADDR %s",
                 ppkt->Str(), ppkt->_dwSeq, pSecMsgXbToXbForward2->_wType,
                 SgSecMsgStr(pSecMsgXbToXbForward2->_wType),
                 SgHexStr(&pSecMsgXbToXbForward2->_sgaTarget, sizeof(pSecMsgXbToXbForward2->_sgaTarget)));
        goto complete;
    }

    SgIXmitSecMsgWithSpi(ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgIXmitSecMsgWithSpi
//
// This function transmits a SecMsg packet to a client given by the pSpiInfo.
// ---------------------------------------------------------------------------------------

void SgIXmitSecMsgWithSpi(CPacket * ppkt)
{
    CSpiInfo * pSpiInfo = ppkt->_pSpiInfo;

    if (pSpiInfo == NULL)
    {
        // The CSpiInfo has been deleted. There is no longer a client to recieve this
        // message.

        goto complete;
    }

    CEnetHdr * pEnetHdr = ppkt->_pEnetHdr = (CEnetHdr *)&ppkt->_abCtx[CBCTX_SKIP_IXMIT];
    CIpHdr *   pIpHdr   = ppkt->_pIpHdr   = (CIpHdr *)(pEnetHdr + 1);

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS(sizeof(CIpHdr) + ppkt->_cb);
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_SECMSG;
    pIpHdr->_ipaSrc    = pSpiInfo->_pTransInfo->_ipa;
    pIpHdr->_ipaDst    = pSpiInfo->_ipaI;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    if (Tag(SpiFlow))
    {
        CTransInfo * pTransInfoXmit = pSpiInfo->_pTransInfo;
        CSecMsgHdr * pSecMsgHdr     = (CSecMsgHdr *)ppkt->_pb;

        TraceSz(SpiFlow, "#%d %08lX SEC >> %c%d [%s:%d %s:%d] %04X/%s (+%d)",
                  ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                  pTransInfoXmit ? (char)pTransInfoXmit->_dwType : 'L', pTransInfoXmit->_iTransInfo,
                  pTransInfoXmit->_ipa.Str(), NTOHS(XSP_PORT),
                  pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI),
                  pSecMsgHdr->_wType, SgSecMsgStr(pSecMsgHdr->_wType), ppkt->_cb - sizeof(CSecMsgHdr));

        SgHexDumpSpiFlow(ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv, (BYTE *)(pSecMsgHdr + 1), ppkt->_cb - sizeof(CSecMsgHdr), NULL, 0, NULL, 0);
    }

    SgIXmitWithSpi(ppkt);
    return;

complete:
    ppkt->Complete();
    return;

}

// ---------------------------------------------------------------------------------------
// SgIXmitSecMsgSgToXbPulse
//
// This function sends a SECMSG_TYPE_SGTOXB_PULSE_2 packet to a client given by the pSpiInfo.
// ---------------------------------------------------------------------------------------

void SgIXmitSecMsgSgToXbPulse(CSpiInfo * pSpiInfo, CPacket * ppktWithSpi)
{
    CPacket * ppkt = ppktWithSpi;

    if (ppkt == NULL)
    {
        ppkt = SgPacketAlloc();

        if (ppkt == NULL)
        {
            TraceSz(Warning, "SgIXmitSecMsgSgToXbPulse - Unable to allocate a packet");
            return;
        }
    }

    CSecMsgSgToXbPulse *    pSecMsgSgToXbPulse  = (CSecMsgSgToXbPulse *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];
    BYTE *                  pb                  = (BYTE *)(pSecMsgSgToXbPulse + 1);

    if (pSpiInfo->_fCs)
    {
        pSecMsgSgToXbPulse->_dwSeqAck = pSpiInfo->_dwSeqXbToSg;

        if (pSpiInfo->_fSgToXbPulse)
        {
            CUserInfo * pUserInfo     = pSpiInfo->_aUserInfo;
            CUserInfo * pUserInfoEnd  = pUserInfo + dimensionof(pSpiInfo->_aUserInfo);

            for (; pUserInfo < pUserInfoEnd; ++pUserInfo)
            {
                pUserInfo->_dwQValTransmit |= pUserInfo->_dwQValModified;
                pUserInfo->_dwQValModified  = 0;

                if (pUserInfo->_dwQValTransmit)
                {
                    *(ULONGLONG *)pb = pUserInfo->_qwUserId;
                    pb += sizeof(ULONGLONG);

                    CQVal * pQVal  = pUserInfo->_aQVal;
                    UINT    iQVal  = 0;
                    UINT    cQVal  = dimensionof(pUserInfo->_aQVal);
                    DWORD   dwMask = pUserInfo->_dwQValTransmit;

                    while (dwMask && iQVal < cQVal)
                    {
                        UINT cdw = 1;

                        if (dwMask & 1)
                        {
                            cdw += QVAL_DSIZE(pQVal->_dw);

                            if (QVAL_SEQ(pQVal->_dw) == 0 || QVAL_INDEX(pQVal->_dw) != iQVal || iQVal + cdw > cQVal)
                            {
                                TraceSz(Warning, "SgIXmitSecMsgSgToXbPulse - aQVal[%d]=%08lX qwUserId=%016I64X SPI=%08lX; value is corrupt",
                                         iQVal, pQVal->_dw, pUserInfo->_qwUserId,
                                         pSpiInfo->_dwSpiRecv);
                                cdw = 1;
                            }
                            else
                            {
                                memcpy(pb, pQVal, cdw * sizeof(CQVal));
                                pb += cdw * sizeof(CQVal);
                            }
                        }

                        dwMask >>= cdw;
                        iQVal   += cdw;
                        pQVal   += cdw;
                    }

                    // Add a zero CQVal to mark the end of list of values for this user

                    *(DWORD *)pb = 0;
                    pb += sizeof(DWORD);

                    TraceSz(Pulse, "%s #%d: SecMsg %04X/%s %I64X QValXmit = %X",
                            ppkt->Str(), (pSpiInfo->_dwSeqXmit + 1), pSecMsgSgToXbPulse->_wType,
                            SgSecMsgStr(pSecMsgSgToXbPulse->_wType),
                            pUserInfo->_qwUserId,
                            pUserInfo->_dwQValTransmit
                            );

                }
            }
        }
    }
    else
    {
        pSecMsgSgToXbPulse->_dwSeqAck = 0;
    }

    pSecMsgSgToXbPulse->_wType = SECMSG_TYPE_SGTOXB_PULSE_2;
    pSecMsgSgToXbPulse->_cbEnt = (WORD)(pb - (BYTE *)pSecMsgSgToXbPulse);

    ppkt->_pb = (BYTE *)pSecMsgSgToXbPulse;
    ppkt->_cb = pSecMsgSgToXbPulse->_cbEnt;

    TraceSz(Pulse, "%s #%d: SecMsg %04X/%s fCs=%s SeqXbToSg=%X SgToXbPulse=%d SeqSgToXb=%X",
            ppkt->Str(), (pSpiInfo->_dwSeqXmit + 1), pSecMsgSgToXbPulse->_wType,
            SgSecMsgStr(pSecMsgSgToXbPulse->_wType),
            (pSpiInfo->_fCs == 0 ? "False" : "True"),
            pSpiInfo->_dwSeqXbToSg,
            pSpiInfo->_fSgToXbPulse,
            (pSpiInfo->_fSgToXbPulse != FALSE ? pSpiInfo->_dwSeqXmit + 1 : pSpiInfo->_dwSeqSgToXb)
            );

    if (pSpiInfo->_fCs)
    {
        pSpiInfo->_dwSeqXbToSg = 0;

        if (pSpiInfo->_fSgToXbPulse)
        {
            pSpiInfo->_dwSeqSgToXb = pSpiInfo->_dwSeqXmit + 1;
        }
    }

    pSpiInfo->_qwTickPulse = SgTimerTick();

    if (ppktWithSpi == NULL)
        SgSpiInfoAttach(ppkt, SgIXmitSecMsgWithSpi, pSpiInfo->_dwSpiRecv);
    else
        SgIXmitSecMsgWithSpi(ppktWithSpi);
}


// ---------------------------------------------------------------------------------------
// SgIXmitSecMsgSgToXbChallenge
//
// This function sends a SECMSG_TYPE_SGTOXB_CHAL packet to a client given by the pSpiInfo.
// ---------------------------------------------------------------------------------------
#ifdef SG_FEATURE_LUA
void SgIXmitSecMsgSgToXbChallenge(CSpiInfo * pSpiInfo, CPacket * ppktWithSpi)
{
    CPacket * ppkt = ppktWithSpi;

    Assert( ppkt != NULL );

    //
    // Assume that we can't get here without providing connections services to
    // the client
    //

    Assert( pSpiInfo->_fCs != FALSE );

    //
    // Grab a point to the secmsg that we want filled in
    //

    CSecMsgSgToXbChal * pSecMsgSgToXbChal = (CSecMsgSgToXbChal *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];
    BOOL                bResult;

    //
    // Call into the challenge engine to fill the actual challenge
    //

    bResult = SgChalAssignAsyncChallenge(pSpiInfo, pSecMsgSgToXbChal );

    //
    // If we didn't find a challenge, that's not an issue. Wait the
    // specified amount of time and try again
    // 

    if (!bResult)
    {
        //
        // Have we been asked to kick or block this client? 
        // 

        if ( SgLuaChalStateBlock( pSpiInfo ) == TRUE || 
             SgLuaChalStateKick( pSpiInfo ) == TRUE ) 
        {

            SgSpiInfoFree( pSpiInfo, SPIDEL_CHALLENGE_LUA );
            SgSpiInfoDetach( ppkt );
            ppkt->Complete();
            return;

        }

        //
        // If we don't have a code challenge, then send down a pulse...
        //

        SgIXmitSecMsgSgToXbPulse( pSpiInfo, ppktWithSpi );
        return;

    }

    //
    // Craft the rest of the packet properly
    //

    ppkt->_pb = (BYTE *)pSecMsgSgToXbChal;
    ppkt->_cb = pSecMsgSgToXbChal->_cbEnt;

    //
    // Send the challenge
    //

    SgIXmitSecMsgWithSpi(ppktWithSpi);
}
#endif // #ifdef SG_FEATURE_LUA

// ---------------------------------------------------------------------------------------
// SgIXmitSecMsgSgToXbChallengeRespAck
//
// This function sends a SECMSG_TYPE_SGTOXB_CHALRESP_ACK packet to a client given by the pSpiInfo.
// ---------------------------------------------------------------------------------------
#ifdef SG_FEATURE_LUA
void SgIXmitSecMsgSgToXbChallengeRespAck(CSpiInfo * pSpiInfo, CPacket * ppktWithSpi, DWORD dwChallengeNonce)
{
    CPacket * ppkt = ppktWithSpi;

    if (ppkt == NULL)
    {
        ppkt = SgPacketAlloc();

        if (ppkt == NULL)
        {
            TraceSz(Warning, "SgIXmitSecMsgSgToXbChallengeRespAck - Unable to allocate a packet");
            return;
        }
    }

    //
    // Assume that we can't get here without providing connections services to
    // the client
    //

    Assert( pSpiInfo->_fCs != FALSE );

    //
    // Build a message
    //

    CSecMsgSgToXbChalRespAck * pSecMsgSgToXbChalRespAck = (CSecMsgSgToXbChalRespAck *)&ppkt->_abCtx[CBCTX_SKIP_SECMSG];
    BYTE *                     pb                       = (BYTE *)(pSecMsgSgToXbChalRespAck + 1);

    //
    // Setup the sequence number for the ACK
    //

    pSecMsgSgToXbChalRespAck->_dwChallengeNonce = dwChallengeNonce;

    //
    // Craft the rest of the packet properly
    //

    pSecMsgSgToXbChalRespAck->_wType = SECMSG_TYPE_SGTOXB_CHALRESP_ACK;
    pSecMsgSgToXbChalRespAck->_cbEnt = (WORD)(pb - (BYTE *)pSecMsgSgToXbChalRespAck);

    ppkt->_pb = (BYTE *)pSecMsgSgToXbChalRespAck;
    ppkt->_cb = pSecMsgSgToXbChalRespAck->_cbEnt;

    //
    // Information output
    //

    TraceSz(
        ChalTrace,
        "[%08lX] sending chalresp_ack for nonce %08lx",
        pSpiInfo->_dwSpiRecv,
        pSpiInfo->_dwChallengeNonce
        );

    //
    // Send the challenge
    //
    if (ppktWithSpi == NULL)
    {
        SgSpiInfoAttach(ppkt, SgIXmitSecMsgWithSpi, pSpiInfo->_dwSpiRecv);
    }
    else
    {
        SgIXmitSecMsgWithSpi(ppktWithSpi);
    }
}
#endif // #ifdef SG_FEATURE_LUA
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgrecv.cpp ===
// ---------------------------------------------------------------------------------------
// sgrecv.cpp
//
// Receive handler for Transports
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_INSECURE
BOOL g_fInhibitKeyExResp;
BOOL g_fInhibitKeyExXmit;
BOOL g_fInhibitZXmit;
BOOL g_fInhibitIXmit;
BOOL g_fInhibitReplayCheck;
#endif

// ---------------------------------------------------------------------------------------
// Configuration Globals
// ---------------------------------------------------------------------------------------

UINT  g_iIpHdrTtl;                              // IP header Ttl
UINT  g_iIpHdrTos;                              // IP header Tos
UINT  g_iXspReplayWindow;                       // How far ahead sender dwSeq can get
UINT  g_iKerbApReqTimeDeltaLimitInMinutes;      // Kerberos ApReq limit
UINT  g_cbKeyDes;                               // DES encryption key length (decide between DES or DES3, but not AES)
DWORD g_dwAesMinClientVersionXbox360;           // Minimum client version for Xbox360 that supports AES and NULL ciphers
DWORD g_dwAesMinClientVersionPc;                // Minimum client version for PC that supports AES and NULL ciphers
BOOL  g_fAesProtocolEnabled;                    // Is the AES/NULL protocol enabled for clients that support it?
UINT  g_cbSpiFlowData;                          // Maximum amount of packet data to trace
UINT  g_iKeyExMinRetryInterval;                 // In 100 nanosecond units
UINT  g_cbKeyExXbToSgInitMin;                   // Minimum size of KeyExXbToSgInit payload
BOOL  g_fKeyExDontSendIcmp;                     // TRUE to prevent sending ICMP before KeyExResp
DWORD g_ipaKeyExIcmpVip;                        // IP address to spoof when sending ICMP before KeyExResp
BOOL  g_fForceReplay;                           // TRUE to allow key exchange replay
BOOL  g_fForceReplayValue;                      // TRUE to force replay check to succeed

#if DBG
BOOL g_fDumpFirstKeyExResp;                     // TRUE to force client to retransmit KeyEx
#endif

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void        SgIRecv(CPacket * ppkt);
void        SgIRecvWithSpi(CPacket * ppkt);

void        SgZRecv(CPacket * ppkt);
void        SgZRecvWithSpi(CPacket * ppkt);
void        SgZRecvSgMsg(CPacket * ppkt);
void        SgZRecvSgMsgWithSpi(CPacket * ppkt);
void        SgIcmpRecv(CPacket * ppkt);

void        SgIRecvXspEcho(CPacket * ppkt);
void        SgIRecvUdpEcho(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// SgRecv
//
// This is the main entry point for incoming packets from all packet transports
// ---------------------------------------------------------------------------------------

void SgRecv(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;

    // Verify that the entire packet is received in one contiguous buffer

    if (ppkt->_cpb != 1)
    {
        TraceSz(RecvDiscard, "%s: Received packet is not in one single buffer (cpb=%d)",
                 ppkt->Str(), ppkt->_cpb);
        SgEventInternalError(sizeof(ppkt->_cpb), &ppkt->_cpb);
        goto complete;
    }

    // The pb/cb variables scan down the buffer as headers are validated.  They always
    // specify the amount of the original data is remaining to be processed.

    BYTE *  pb = ppkt->_pb = ppkt->_apb[0];
    UINT    cb = ppkt->_cb = ppkt->_acb[0];

    //
    // Process the Ethernet header
    //

    CEnetHdr * pEnetHdr = ppkt->_pEnetHdr = (CEnetHdr *)pb;

    if (cb < sizeof(CEnetHdr))
    {
        TraceSz(RecvIgnore, "%s: Frame (%d bytes) is smaller than CEnetHdr (%d bytes)",
                 ppkt->Str(), cb, sizeof(CEnetHdr));
        // These types of packets are expected, so no need to add an event log entry.
        SgPerfdataInc(DropEnetHdr, 1);
        goto complete;
    }

    USHORT usType = pEnetHdr->_wType;

    if (NTOHS(usType) <= ENET_DATA_MAXSIZE)
    {
        CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;

        if (cb < sizeof(CIeeeHdr))
        {
            TraceSz(RecvIgnore, "%s: Frame (%d bytes) is smaller than CIeeeHdr (%d bytes)",
                     ppkt->Str(), cb, sizeof(CIeeeHdr));
            // These types of packets are expected, so no need to add an event log entry.
            SgPerfdataInc(DropEnetHdr, 1);
            goto complete;
        }

        if (!pIeeeHdr->IsEnetFrame())
        {
            TraceSz(RecvIgnore, "%s: Frame has unrecognized ethernet header (%s)",
                     ppkt->Str(), SgHexStr(pIeeeHdr, sizeof(CIeeeHdr)));
            // These types of packets are expected, so no need to add an event log entry.
            SgPerfdataInc(DropEnetHdr, 1);
            goto complete;
        }

        // Update the frame type from the IEEE header

        usType = pIeeeHdr->_wTypeIeee;

        // Skip over the difference between the IEEE header and the normal ethernet header

        ppkt->_pb = (pb += sizeof(CIeeeHdr));
        ppkt->_cb = (cb -= sizeof(CIeeeHdr));
    }
    else
    {
        ppkt->_pb = (pb += sizeof(CEnetHdr));
        ppkt->_cb = (cb -= sizeof(CEnetHdr));
    }

    TraceSz(RecvEnet, "%s: [ENET %s %s %04X]{+%d}",
             ppkt->Str(), pEnetHdr->_eaDst.Str(), pEnetHdr->_eaSrc.Str(), NTOHS(usType), cb);

    // Dispatch ARP packets (either broadcast or unicast)

#ifdef SG_FEATURE_ARP
    if (usType == ENET_TYPE_ARP)
    {
        SgArpInfoRecv(ppkt);
        goto exit;
    }
#endif // SG_FEATURE_ARP

    // A broadcast packet must be an ARP packet.  Ignore all else.

    if (pEnetHdr->_eaDst.IsBroadcast())
    {
        TraceSz(RecvIgnore, "%s: Non-ARP packet (wType=%04X) received via broadcast from %s",
                 ppkt->Str(), NTOHS(usType), pEnetHdr->_eaSrc.Str());
        // These types of packets are expected, so no need to add an event log entry.
        SgPerfdataInc(DropEnetHdr, 1);
        goto complete;
    }

    // The only acceptable unicast packet is an IP packet.  Ignore all else.

    if (usType != ENET_TYPE_IP)
    {
        TraceSz(RecvIgnore, "%s: Non-IP packet (wType=%04X) received via unicast from %s",
                 ppkt->Str(), NTOHS(usType), pEnetHdr->_eaSrc.Str());
        // These types of packets are expected, so no need to add an event log entry.
        SgPerfdataInc(DropEnetHdr, 1);
        goto complete;
    }

    //
    // Process the IP header
    //

    if (cb < sizeof(CIpHdr))
    {
        TraceSz(RecvDiscard, "%s: IP packet size (%d bytes) is smaller than CIpHdr (%d bytes)",
                 ppkt->Str(), cb, sizeof(CIpHdr));
        SgEventPacketNoisy(INVALID_PACKET_0, ppkt, 0, 0, sizeof(CEnetHdr) + cb, pEnetHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    CIpHdr * pIpHdr = ppkt->_pIpHdr = (CIpHdr *)pb;
    UINT cbIpHdrLen = pIpHdr->_bVerHdr;
    UINT cbIpLen    = NTOHS(pIpHdr->_wLen);

    if ((cbIpHdrLen & 0xF0) != 0x40)
    {
        TraceSz(RecvDiscard, "%s: IP version (%d) is not IPv4", ppkt->Str(), cbIpHdrLen >> 4);
        SgEventPacketNoisy(INVALID_PACKET_1, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CEnetHdr) + sizeof(CIpHdr), pEnetHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    cbIpHdrLen = (cbIpHdrLen & 0x0F) << 2;

    if (cbIpHdrLen < sizeof(CIpHdr))
    {
        TraceSz(RecvDiscard, "%s: IP header size (%d bytes) is smaller than CIpHdr (%d bytes)",
                 ppkt->Str(), cbIpHdrLen, sizeof(CIpHdr));
        SgEventPacketNoisy(INVALID_PACKET_2, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CEnetHdr) + sizeof(CIpHdr), pEnetHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    if (cbIpHdrLen > cbIpLen)
    {
        TraceSz(RecvDiscard, "%s: IP header size (%d bytes) is greater than IP size in header (%d bytes)",
                 ppkt->Str(), cbIpHdrLen, cbIpLen);
        SgEventPacketNoisy(INVALID_PACKET_3, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CEnetHdr) + sizeof(CIpHdr), pEnetHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    if (cbIpLen != cb)
    {
        if (cbIpLen > cb)
        {
            TraceSz(RecvDiscard, "%s: IP size in header (%d bytes) is greater than the frame size (%d bytes)",
                     ppkt->Str(), cbIpLen, cb);
            SgEventPacketNoisy(INVALID_PACKET_4, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CEnetHdr) + sizeof(CIpHdr), pEnetHdr);
            SgPerfdataInc(DropIpHdr, 1);
            goto complete;
        }

        // Change the size of the packet to match the size specified in the IP header.  An
        // ethernet frame, especially a small one, can sometimes be longer than the IP
        // packet length.  We've already checked above that the ethernet frame is at least
        // as big as cb.

        cb = cbIpLen;
    }

    // IP header options are not supported

    if (cbIpHdrLen > sizeof(CIpHdr))
    {
        TraceSz(RecvDiscard, "%s: IP header options (%d bytes) are not supported",
                 ppkt->Str(), cbIpHdrLen - sizeof(CIpHdr));
        SgEventPacketNoisy(INVALID_PACKET_5, ppkt, pIpHdr->_ipaSrc, 0, cb, pIpHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    // Verify the IP header checksum. 0x0000 checksum for UDP means "don't do it". We're
    // going to apply the same logic for other packet types as well, since W2K8 seems to
    // be sending us TCP packets with a zero checksum.

    if (pIpHdr->_wChecksum != 0)
    {
        if (tcpipxsum(0, pIpHdr, cbIpHdrLen) != 0xFFFF)
        {
            TraceSz(RecvDiscard, "%s: IP header checksum failed", ppkt->Str());
            SgEventPacketNoisy(INVALID_PACKET_6, ppkt, pIpHdr->_ipaSrc, 0, cb, pIpHdr);
            SgPerfdataInc(DropIpHdr, 1);
            goto complete;
        }
    }
    else
    {
        TraceSz(Warning, "%s: IP header checksum is 0x0000", ppkt->Str());
    }

    if (pIpHdr->_ipaSrc == 0 || pIpHdr->_ipaSrc.IsBroadcast())
    {
        TraceSz(RecvDiscard, "%s: IP header has ipaSrc %s", ppkt->Str(), pIpHdr->_ipaSrc.Str());
        SgEventPacketNoisy(INVALID_PACKET_7, ppkt, pIpHdr->_ipaSrc, 0, cb, pIpHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    if (pIpHdr->_wFragOff & HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK))
    {
        TraceSz(RecvDiscard, "%s: IP packet fragmentation (wFragOff=%04X) is not supported",
                 ppkt->Str(), pIpHdr->_wFragOff);
        SgEventPacketLogNoisy(INVALID_PACKET_8, ppkt, pIpHdr->_ipaSrc, 0, PEVT_FILTER_IP);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    ppkt->_pb = (pb += sizeof(CIpHdr));
    ppkt->_cb = (cb -= sizeof(CIpHdr));

    TraceSz(RecvIp, "%s: [IP %s %s (%d %d %04X %04X) %d]{+%d}",
             ppkt->Str(), pIpHdr->_ipaDst.Str(), pIpHdr->_ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
             NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol, cb);

    SgPerfdataInc(RecvTotal, 1);
    SgPerfdataInc(RecvTotalBytes, ppkt->_acb[0]);

    if (pTransInfoRecv->_dwType == TRANSTYPE_INTERNET)
    {
        SgPerfdataInc(IRecv, 1);
        SgPerfdataInc(IRecvBytes, ppkt->_acb[0]);
        SgIRecv(ppkt);
        goto exit;
    }

    if (pTransInfoRecv->_dwType == TRANSTYPE_DMZ)
    {
        SgPerfdataInc(ZRecv, 1);
        SgPerfdataInc(ZRecvBytes, ppkt->_acb[0]);
        SgZRecv(ppkt);
        goto exit;
    }

    TraceSz(RecvDiscard, "%s: CTransInfo has unexpected TRANSTYPE (%d)",
             ppkt->Str(), pTransInfoRecv->_dwType);
    SgEventSz(INTERNAL_ERROR, "%s:%d", __FILE__, __LINE__);
    SgEventInternalError(sizeof(pTransInfoRecv->_dwType), &pTransInfoRecv->_dwType);
    goto complete;

complete:
    ppkt->Complete();

exit:

    return;
}

// ---------------------------------------------------------------------------------------
// SgIRecv
//
// This function continues processing of a packet from SgRecv that arrives on a
// transport connected to the Internet.
// ---------------------------------------------------------------------------------------

void SgIRecv(CPacket * ppkt)