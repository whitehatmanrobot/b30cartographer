Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val);
static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val);
static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val);
static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val);
static void ASN1CALL ASN1Free_DHset(DHset *val);
static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val);
static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val);
static void ASN1CALL ASN1Free_ClearToken(ClearToken *val);
static void ASN1CALL ASN1Free_Params(Params *val);
static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val);
static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val);
static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val);
static void ASN1CALL ASN1Free_ICV(ICV *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val);
static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val);
static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val);
static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val);
static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val);
static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val);
static void ASN1CALL ASN1Free_HASHED(HASHED *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val);
static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val);
static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val);
static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val);
static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val);
static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val);
static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val);
static void ASN1CALL ASN1Free_H245Security(H245Security *val);
static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val);
static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val);
static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val);
static void ASN1CALL ASN1Free_FastStartToken(FastStartToken *val);
static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_DataRate(DataRate *val);
static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val);
static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val);
static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val);
static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val);
static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val);
static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val);
static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val);
static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val);
static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val);
static void ASN1CALL ASN1Free_LocationReject(LocationReject *val);
static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val);
static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val);
static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val);
static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val);
static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val);
static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val);
static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val);
static void ASN1CALL ASN1Free_H310Caps(H310Caps *val);
static void ASN1CALL ASN1Free_H320Caps(H320Caps *val);
static void ASN1CALL ASN1Free_H321Caps(H321Caps *val);
static void ASN1CALL ASN1Free_H322Caps(H322Caps *val);
static void ASN1CALL ASN1Free_H323Caps(H323Caps *val);
static void ASN1CALL ASN1Free_H324Caps(H324Caps *val);
static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val);
static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val);
static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val);
static void ASN1CALL ASN1Free_McuInfo(McuInfo *val);
static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val);
static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val);
static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val);
static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val);
static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val);
static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val);
static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val);
static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val);
static void ASN1CALL ASN1Free_RTPSession(RTPSession *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val);
static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val);
static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val);
static void ASN1CALL ASN1Free_EndpointType(EndpointType *val);
static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_Endpoint(Endpoint *val);
static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val);
static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val);
static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val);
static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val);
static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val);
static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val);
static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val);
static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val);
static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val);
static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val);
static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val);
static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val);
static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val);
static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val);
static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val);
static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val);
static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val);
static void ASN1CALL ASN1Free_RasMessage(RasMessage *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val);
static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val);
static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_RasMessage,
    (ASN1EncFun_t) ASN1Enc_H323_UserInformation,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_RasMessage,
    (ASN1DecFun_t) ASN1Dec_H323_UserInformation,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_RasMessage,
    (ASN1FreeFun_t) ASN1Free_H323_UserInformation,
};
static const ULONG sizetab[2] = {
    SIZE_H225ASN_Module_PDU_0,
    SIZE_H225ASN_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H225ASN_Module_Startup(void)
{
    H225ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35323268);
}

void ASN1CALL H225ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(H225ASN_Module);
    H225ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 16))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPSession_associatedSessionIds_ElmFn);
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PEREncBitVal(enc, 8, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPSession_associatedSessionIds_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PERDecU16Val(dec, 8, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPSession_associatedSessionIds_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->makeCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToMakeCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToAnswer))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->makeCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToMakeCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToAnswer))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val)
{
    if (val) {
	ASN1objectidentifier_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCRV_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h245Control_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h245Control_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h245Control_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->protocol_discriminator))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->protocol_discriminator))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->halfkey).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->halfkey).length, ((val)->halfkey).value))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->modSize).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->modSize).length, ((val)->modSize).value))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->generator).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->generator).length, ((val)->generator).value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->halfkey).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->halfkey).length, &((val)->halfkey).value))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->modSize).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->modSize).length, &((val)->modSize).value))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->generator).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->generator).length, &((val)->generator).value))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DHset(DHset *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->halfkey);
	ASN1bitstring_free(&(val)->modSize);
	ASN1bitstring_free(&(val)->generator);
    }
}

static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->type))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->certificate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->type))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->certificate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->type);
	ASN1octetstring_free(&(val)->certificate);
    }
}

static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_H235NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->timeStamp - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->password).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->password).length, ((val)->password).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_DHset(enc, &(val)->dhkey))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncInteger(enc, (val)->random))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TypedCertificate(enc, &(val)->certificate))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->generalID).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->generalID).length, ((val)->generalID).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	    return 0;
	(val)->timeStamp += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->password).length))
	    return 0;
	((val)->password).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->password).length, &((val)->password).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_DHset(dec, &(val)->dhkey))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecInteger(dec, &(val)->random))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TypedCertificate(dec, &(val)->certificate))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->generalID).length))
	    return 0;
	((val)->generalID).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->generalID).length, &((val)->generalID).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ClearToken(ClearToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->password);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_DHset(&(val)->dhkey);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TypedCertificate(&(val)->certificate);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1char16string_free(&(val)->generalID);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_H235NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncInteger(enc, (val)->ranInt))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->iv8, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecInteger(dec, &(val)->ranInt))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->iv8, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Params(Params *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_ClearToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val)
{
    if (!ASN1Enc_ClearToken(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val)
{
    if (!ASN1Dec_ClearToken(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val)
{
    if (val) {
	ASN1Free_ClearToken(val);
    }
}

static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_PwdCertToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_PwdCertToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_PwdCertToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_AltGKInfo_alternateGatekeeper(enc, &(val)->alternateGatekeeper))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->altGKisPermanent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_AltGKInfo_alternateGatekeeper(dec, &(val)->alternateGatekeeper))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->altGKisPermanent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val)
{
    if (val) {
	ASN1Free_AltGKInfo_alternateGatekeeper(&(val)->alternateGatekeeper);
    }
}

static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conferenceCalling))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threePartyService))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conferenceCalling))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threePartyService))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->icv).length, ((val)->icv).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->icv).length, &((val)->icv).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ICV(ICV *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1bitstring_free(&(val)->icv);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_RegistrationRejectReason_duplicateAlias(enc, &(val)->u.duplicateAlias))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_RegistrationRejectReason_duplicateAlias(dec, &(val)->u.duplicateAlias))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_RegistrationRejectReason_duplicateAlias(&(val)->u.duplicateAlias);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->setup))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->callProceeding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->connect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alerting))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->information))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->releaseComplete))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->facility))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->empty))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->setup))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->callProceeding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->connect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alerting))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->information))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->releaseComplete))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->facility))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->empty))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_UnknownMessageResponse_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1Enc_UnknownMessageResponse_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnknownMessageResponse_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnknownMessageResponse_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_UnknownMessageResponse_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_UnknownMessageResponse_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Enc_AuthenticationMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Dec_AuthenticationMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val)
{
    if (val) {
	ASN1Free_AuthenticationMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Enc_EncodedGeneralToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Dec_EncodedGeneralToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val)
{
    if (val) {
	ASN1Free_EncodedGeneralToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->encryptedData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->encryptedData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1octetstring_free(&(val)->encryptedData);
    }
}

static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->hash).length, ((val)->hash).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->hash).length, &((val)->hash).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HASHED(HASHED *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->hash);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Enc_EncodedPwdCertToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Dec_EncodedPwdCertToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val)
{
    if (val) {
	ASN1Free_EncodedPwdCertToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_ReleaseCompleteReason(enc, &(val)->reason))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReleaseCompleteReason(dec, &(val)->reason))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_H221NonStandard(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_H221NonStandard(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val)
{
    if (!ASN1Enc_H225NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val)
{
    if (!ASN1Dec_H225NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val)
{
    if (val) {
	ASN1Free_H225NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t PublicPartyNumber_publicNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PublicPartyNumber_publicNumberDigits_StringTable = {
    4, PublicPartyNumber_publicNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PublicTypeOfNumber(enc, &(val)->publicTypeOfNumber))
	return 0;
    t = lstrlenA((val)->publicNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PublicTypeOfNumber(dec, &(val)->publicTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val)
{
    if (val) {
    }
}

static ASN1stringtableentry_t PrivatePartyNumber_privateNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PrivatePartyNumber_privateNumberDigits_StringTable = {
    4, PrivatePartyNumber_privateNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PrivateTypeOfNumber(enc, &(val)->privateTypeOfNumber))
	return 0;
    t = lstrlenA((val)->privateNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PrivateTypeOfNumber(dec, &(val)->privateTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->encryption))
	return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->authenticaton))
	return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->integrity))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->encryption))
	return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->authenticaton))
	return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->integrity))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandard);
	}
	ASN1Free_SecurityServiceMode(&(val)->encryption);
	ASN1Free_SecurityServiceMode(&(val)->authenticaton);
	ASN1Free_SecurityServiceMode(&(val)->integrity);
    }
}

static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.tls))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.ipsec))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.tls))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.ipsec))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245Security(H245Security *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SecurityCapabilities(&(val)->u.tls);
	    break;
	case 4:
	    ASN1Free_SecurityCapabilities(&(val)->u.ipsec);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q932Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q951Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q952Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q953Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q955Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q956Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q957Full))
	return 0;
    if (!ASN1Enc_Q954Details(enc, &(val)->q954Info))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q932Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q951Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q952Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q953Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q955Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q956Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q957Full))
	return 0;
    if (!ASN1Dec_Q954Details(dec, &(val)->q954Info))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.isoAlgorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.isoAlgorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1objectidentifier_free(&(val)->u.isoAlgorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_s))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_l))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.hMAC_iso10118_3))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_s))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_l))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.hMAC_iso10118_3))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_s);
	    break;
	case 3:
	    ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_l);
	    break;
	case 4:
	    ASN1objectidentifier_free(&(val)->u.hMAC_iso10118_3);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.iso9797))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_NonIsoIntegrityMechanism(enc, &(val)->u.nonIsoIM))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.iso9797))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_NonIsoIntegrityMechanism(dec, &(val)->u.nonIsoIM))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1objectidentifier_free(&(val)->u.iso9797);
	    break;
	case 4:
	    ASN1Free_NonIsoIntegrityMechanism(&(val)->u.nonIsoIM);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FastStartToken(ASN1encoding_t enc, FastStartToken *val)
{
    if (!ASN1Enc_ClearToken(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FastStartToken(ASN1decoding_t dec, FastStartToken *val)
{
    if (!ASN1Dec_ClearToken(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FastStartToken(FastStartToken *val)
{
    if (val) {
	ASN1Free_ClearToken(val);
    }
}

static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_FastStartToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_FastStartToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_FastStartToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->channelRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->channelRate))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->channelMultiplier - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->channelRate))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->channelMultiplier))
	    return 0;
	(val)->channelMultiplier += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataRate(DataRate *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_GatekeeperRejectReason(enc, &(val)->rejectReason))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_GatekeeperReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_GatekeeperRejectReason(dec, &(val)->rejectReason))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_GatekeeperReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_RegistrationConfirm_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_RegistrationConfirm_terminalAlias(enc, &(val)->terminalAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_RegistrationConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    l = ASN1uint32_uoctets((val)->timeToLive - 1);
	    if (!ASN1PEREncBitVal(ee, 2, l - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_RegistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_RegistrationConfirm_preGrantedARQ(ee, &(val)->preGrantedARQ))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_RegistrationConfirm_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RegistrationConfirm_terminalAlias(dec, &(val)->terminalAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 2, &l))
		return 0;
	    l += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
		return 0;
	    (val)->timeToLive += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_preGrantedARQ(dd, &(val)->preGrantedARQ))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationConfirm_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RegistrationConfirm_terminalAlias(&(val)->terminalAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RegistrationConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_RegistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_RegistrationRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_RegistrationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_RegistrationRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationRejectReason(&(val)->rejectReason);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_RegistrationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_UnregistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_UnregistrationRequest_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_UnregistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_UnregistrationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_UnregistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_UnregRequestReason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_UnregistrationRequest_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	    return 0;
	((val)->endpointIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregRequestReason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val)
{
    if (val) {
	ASN1Free_UnregistrationRequest_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_UnregistrationRequest_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_UnregistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_UnregistrationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_UnregistrationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_UnregistrationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_UnregistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_UnregistrationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_UnregistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_UnregRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_UnregistrationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_UnregistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_UnregistrationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_UnregistrationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_AdmissionRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AdmissionReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_AdmissionReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionReject_callSignalAddress(ee, &(val)->callSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_AdmissionRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_callSignalAddress(dd, &(val)->callSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AdmissionReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AdmissionReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionReject_callSignalAddress(&(val)->callSignalAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_CallType(enc, &(val)->callType))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_BandwidthRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_BandwidthRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallType(dec, &(val)->callType))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_BandwidthRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_BandwidthRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_BandwidthConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_BandwidthConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_BandwidthConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_BandwidthConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_BandRejectReason(enc, &(val)->rejectReason))
	return 0;
    l = ASN1uint32_uoctets((val)->allowedBandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->allowedBandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_BandwidthReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_BandwidthReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_BandRejectReason(dec, &(val)->rejectReason))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->allowedBandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_BandwidthReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_BandwidthReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_LocationRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_LocationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_LocationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_LocationRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject(LocationReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_LocationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_LocationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (!ASN1Enc_DisengageReason(enc, &(val)->disengageReason))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_DisengageRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_DisengageRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if (!ASN1Dec_DisengageReason(dec, &(val)->disengageReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_DisengageRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_DisengageRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_DisengageConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_DisengageConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_DisengageConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_DisengageConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_DisengageRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_DisengageReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_DisengageReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_DisengageRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_DisengageReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_DisengageReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_InfoRequestAck_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestAck_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InfoRequestAck_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestAck_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InfoRequestAck_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestAck_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_InfoRequestNakReason(enc, &(val)->nakReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AltGKInfo(enc, &(val)->altGKInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestNak_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_InfoRequestNak_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_InfoRequestNakReason(dec, &(val)->nakReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AltGKInfo(dec, &(val)->altGKInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestNak_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_InfoRequestNak_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestNak_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_InfoRequestNak_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_H225NonStandardMessage_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1Enc_H225NonStandardMessage_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H225NonStandardMessage_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H225NonStandardMessage_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val)
{
    if (val) {
	ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardMessage_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardMessage_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RequestInProgress_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RequestInProgress_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->delay - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RequestInProgress_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RequestInProgress_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->delay))
	return 0;
    (val)->delay += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RequestInProgress_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RequestInProgress_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Enc_ResourcesAvailableIndicate_protocols(enc, &(val)->protocols))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->almostOutOfResources))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ResourcesAvailableIndicate_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Dec_ResourcesAvailableIndicate_protocols(dec, &(val)->protocols))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->almostOutOfResources))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ResourcesAvailableIndicate_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1char16string_free(&(val)->endpointIdentifier);
	ASN1Free_ResourcesAvailableIndicate_protocols(&(val)->protocols);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ResourcesAvailableIndicate_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ResourcesAvailableIndicate_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ResourcesAvailableConfirm_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ResourcesAvailableConfirm_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ResourcesAvailableConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ResourcesAvailableConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val)
{
    if (val) {
	ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val)
{
    if (val) {
	ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperId).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperId).length, ((val)->gatekeeperId).value, 16))
	return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperId).length))
	return 0;
    ((val)->gatekeeperId).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperId).length, &((val)->gatekeeperId).value, 16))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val)
{
    if (val) {
	ASN1char16string_free(&(val)->gatekeeperId);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Enc_H245Security(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Dec_H245Security(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val)
{
    if (val) {
	ASN1Free_H245Security(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Enc_H225NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Dec_H225NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val)
{
    if (val) {
	ASN1Free_H225NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->hashedVals))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->hashedVals))
	return 0;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_ClearToken(&(val)->hashedVals);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_SIGNED_EncodedGeneralToken(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_SIGNED_EncodedGeneralToken(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_SIGNED_EncodedGeneralToken(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_ENCRYPTED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CryptoToken_cryptoEncryptedToken(enc, &(val)->u.cryptoEncryptedToken))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CryptoToken_cryptoSignedToken(enc, &(val)->u.cryptoSignedToken))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CryptoToken_cryptoHashedToken(enc, &(val)->u.cryptoHashedToken))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoPwdEncr))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CryptoToken_cryptoEncryptedToken(dec, &(val)->u.cryptoEncryptedToken))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CryptoToken_cryptoSignedToken(dec, &(val)->u.cryptoSignedToken))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CryptoToken_cryptoHashedToken(dec, &(val)->u.cryptoHashedToken))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoPwdEncr))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CryptoToken_cryptoEncryptedToken(&(val)->u.cryptoEncryptedToken);
	    break;
	case 2:
	    ASN1Free_CryptoToken_cryptoSignedToken(&(val)->u.cryptoSignedToken);
	    break;
	case 3:
	    ASN1Free_CryptoToken_cryptoHashedToken(&(val)->u.cryptoHashedToken);
	    break;
	case 4:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoPwdEncr);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Enc_EncodedFastStartToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Dec_EncodedFastStartToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val)
{
    if (val) {
	ASN1Free_EncodedFastStartToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
	    break;
	case 2:
	    ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
	    break;
	case 3:
	    ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
	    break;
	case 4:
	    ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
	    break;
	case 5:
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GatewayInfo_protocol(enc, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GatewayInfo_protocol(dec, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GatewayInfo_protocol(&(val)->protocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H310Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H310Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H310Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H310Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps(H310Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H310Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H310Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H320Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H320Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H320Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H320Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps(H320Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H320Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H320Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H321Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H321Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H321Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H321Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps(H321Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H321Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H321Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H322Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H322Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H322Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H322Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps(H322Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H322Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H322Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H323Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H323Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps(H323Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H323Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H323Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H324Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H324Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H324Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H324Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps(H324Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H324Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H324Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_VoiceCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_VoiceCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_VoiceCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_VoiceCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_VoiceCaps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_VoiceCaps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_T120OnlyCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_T120OnlyCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_T120OnlyCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_T120OnlyCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_T120OnlyCaps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_T120OnlyCaps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_NonStandardProtocol_dataRatesSupported(enc, &(val)->dataRatesSupported))
	    return 0;
    }
    if (!ASN1Enc_NonStandardProtocol_supportedPrefixes(enc, &(val)->supportedPrefixes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_NonStandardProtocol_dataRatesSupported(dec, &(val)->dataRatesSupported))
	    return 0;
    }
    if (!ASN1Dec_NonStandardProtocol_supportedPrefixes(dec, &(val)->supportedPrefixes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_NonStandardProtocol_dataRatesSupported(&(val)->dataRatesSupported);
	}
	ASN1Free_NonStandardProtocol_supportedPrefixes(&(val)->supportedPrefixes);
    }
}

static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_McuInfo(McuInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static ASN1stringtableentry_t PartyNumber_dataPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_dataPartyNumber_StringTable = {
    4, PartyNumber_dataPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_telexPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_telexPartyNumber_StringTable = {
    4, PartyNumber_telexPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_nationalStandardPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_nationalStandardPartyNumber_StringTable = {
    4, PartyNumber_nationalStandardPartyNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PublicPartyNumber(enc, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.dataPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	t = lstrlenA((val)->u.telexPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_PrivatePartyNumber(enc, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	t = lstrlenA((val)->u.nationalStandardPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PublicPartyNumber(dec, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_PrivatePartyNumber(dec, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PublicPartyNumber(&(val)->u.publicNumber);
	    break;
	case 2:
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_PrivatePartyNumber(&(val)->u.privateNumber);
	    break;
	case 5:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->needToRegister))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->needToRegister))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AuthenticationMechanism(ee, &(val)->authenticationMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_GatekeeperConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PEREncObjectIdentifier(ee, &(val)->algorithmOID))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_GatekeeperConfirm_integrity(ee, &(val)->integrity))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AuthenticationMechanism(dd, &(val)->authenticationMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecObjectIdentifier(dd, &(val)->algorithmOID))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_integrity(dd, &(val)->integrity))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_GatekeeperConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AuthenticationMechanism(&(val)->authenticationMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_GatekeeperConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1objectidentifier_free(&(val)->algorithmOID);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_GatekeeperConfirm_integrity(&(val)->integrity);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x80;
    o[1] |= 0x40;
    o[2] |= 0x40;
    y = ASN1PEREncCheckExtensions(10, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_AdmissionRequest_destinationInfo(enc, &(val)->destinationInfo))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_AdmissionRequest_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (!ASN1Enc_AdmissionRequest_srcInfo(enc, &(val)->srcInfo))
	return 0;
    if (o[0] & 0x8) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->srcCallSignalAddress))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x4) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 10, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_AdmissionRequest_srcAlternatives(ee, &(val)->srcAlternatives))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionRequest_destAlternatives(ee, &(val)->destAlternatives))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_AdmissionRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_AdmissionRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AdmissionRequest_destinationInfo(dec, &(val)->destinationInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_AdmissionRequest_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (!ASN1Dec_AdmissionRequest_srcInfo(dec, &(val)->srcInfo))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->srcCallSignalAddress))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 10, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_srcAlternatives(dd, &(val)->srcAlternatives))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_destAlternatives(dd, &(val)->destAlternatives))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AdmissionRequest_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_AdmissionRequest_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	ASN1Free_AdmissionRequest_srcInfo(&(val)->srcInfo);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TransportAddress(&(val)->srcCallSignalAddress);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AdmissionRequest_srcAlternatives(&(val)->srcAlternatives);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionRequest_destAlternatives(&(val)->destAlternatives);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_AdmissionRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_AdmissionRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_LocationRequest_destinationInfo(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_LocationRequest_sourceInfo(ee, &(val)->sourceInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_LocationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_LocationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	    return 0;
	((val)->endpointIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_LocationRequest_destinationInfo(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_sourceInfo(dd, &(val)->sourceInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
	ASN1Free_LocationRequest_destinationInfo(&(val)->destinationInfo);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_TransportAddress(&(val)->replyAddress);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_LocationRequest_sourceInfo(&(val)->sourceInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_LocationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_LocationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_InfoRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportAddress(&(val)->replyAddress);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_InfoRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->sendAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->recvAddress))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->sendAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->recvAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sendAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportAddress(&(val)->recvAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val)
{
    ASN1uint32_t t;
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtpAddress))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtcpAddress))
	return 0;
    t = lstrlenA((val)->cname);
    if (!ASN1PEREncFragmentedCharString(enc, t, (val)->cname, 8))
	return 0;
    l = ASN1uint32_uoctets((val)->ssrc - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->ssrc - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionId - 1))
	return 0;
    if (!ASN1Enc_RTPSession_associatedSessionIds(enc, &(val)->associatedSessionIds))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtpAddress))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtcpAddress))
	return 0;
    if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->cname, 8))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->ssrc))
	return 0;
    (val)->ssrc += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionId))
	return 0;
    (val)->sessionId += 1;
    if (!ASN1Dec_RTPSession_associatedSessionIds(dec, &(val)->associatedSessionIds))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession(RTPSession *val)
{
    if (val) {
	ASN1Free_TransportChannelInfo(&(val)->rtpAddress);
	ASN1Free_TransportChannelInfo(&(val)->rtcpAddress);
	ASN1ztcharstring_free((val)->cname);
	ASN1Free_RTPSession_associatedSessionIds(&(val)->associatedSessionIds);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Enc_TransportChannelInfo(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Dec_TransportChannelInfo(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (val) {
	ASN1Free_TransportChannelInfo(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (val) {
	ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (val) {
	ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 5, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1PEREncBoolean(enc, (val)->originator))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(enc, &(val)->audio))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(enc, &(val)->video))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(enc, &(val)->data))
	    return 0;
    }
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->h245))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->callSignaling))
	return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ee, &(val)->substituteConfIDs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ee, &(val)->pdu))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecBoolean(dec, &(val)->originator))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(dec, &(val)->audio))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(dec, &(val)->video))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(dec, &(val)->data))
	    return 0;
    }
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->h245))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->callSignaling))
	return 0;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(dd, &(val)->substituteConfIDs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(dd, &(val)->pdu))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(&(val)->audio);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(&(val)->video);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(&(val)->data);
	}
	ASN1Free_TransportChannelInfo(&(val)->h245);
	ASN1Free_TransportChannelInfo(&(val)->callSignaling);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(&(val)->substituteConfIDs);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(&(val)->pdu);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val)
{
    if (val) {
	ASN1Free_InfoRequestResponse_perCallInfo_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VendorIdentifier(enc, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GatekeeperInfo(enc, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatewayInfo(enc, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_McuInfo(enc, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TerminalInfo(enc, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->mc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->undefinedNode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VendorIdentifier(dec, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_GatekeeperInfo(dec, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatewayInfo(dec, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_McuInfo(dec, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TerminalInfo(dec, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->mc))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->undefinedNode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointType(EndpointType *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_VendorIdentifier(&(val)->vendor);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GatekeeperInfo(&(val)->gatekeeper);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatewayInfo(&(val)->gateway);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_McuInfo(&(val)->mcu);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TerminalInfo(&(val)->terminal);
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 9))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H310Caps(enc, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H320Caps(enc, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H321Caps(enc, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_H322Caps(enc, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_H323Caps(enc, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H324Caps(enc, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_VoiceCaps(enc, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_T120OnlyCaps(enc, &(val)->u.t120_only))
	    return 0;
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardProtocol(ee, &(val)->u.nonStandardProtocol))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 9))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H310Caps(dec, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H320Caps(dec, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H321Caps(dec, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_H322Caps(dec, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_H323Caps(dec, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H324Caps(dec, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_VoiceCaps(dec, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_T120OnlyCaps(dec, &(val)->u.t120_only))
	    return 0;
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardProtocol(dd, &(val)->u.nonStandardProtocol))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	case 2:
	    ASN1Free_H310Caps(&(val)->u.h310);
	    break;
	case 3:
	    ASN1Free_H320Caps(&(val)->u.h320);
	    break;
	case 4:
	    ASN1Free_H321Caps(&(val)->u.h321);
	    break;
	case 5:
	    ASN1Free_H322Caps(&(val)->u.h322);
	    break;
	case 6:
	    ASN1Free_H323Caps(&(val)->u.h323);
	    break;
	case 7:
	    ASN1Free_H324Caps(&(val)->u.h324);
	    break;
	case 8:
	    ASN1Free_VoiceCaps(&(val)->u.voice);
	    break;
	case 9:
	    ASN1Free_T120OnlyCaps(&(val)->u.t120_only);
	    break;
	case 10:
	    ASN1Free_NonStandardProtocol(&(val)->u.nonStandardProtocol);
	    break;
	}
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.e164);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.url_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.url_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportAddress(ee, &(val)->u.transportID))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.email_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.email_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_PartyNumber(ee, &(val)->u.partyNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
	    return 0;
	((val)->u.h323_ID).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.url_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TransportAddress(dd, &(val)->u.transportID))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.email_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_PartyNumber(dd, &(val)->u.partyNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.h323_ID);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_TransportAddress(&(val)->u.transportID);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_PartyNumber(&(val)->u.partyNumber);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Endpoint_aliasAddress(enc, &(val)->aliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Endpoint_callSignalAddress(enc, &(val)->callSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_Endpoint_rasAddress(enc, &(val)->rasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_Endpoint_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_Endpoint_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1Enc_Endpoint_remoteExtensionAddress(enc, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_Endpoint_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Endpoint_aliasAddress(dec, &(val)->aliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Endpoint_callSignalAddress(dec, &(val)->callSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_Endpoint_rasAddress(dec, &(val)->rasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Endpoint_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_Endpoint_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1Dec_Endpoint_remoteExtensionAddress(dec, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_Endpoint_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint(Endpoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Endpoint_aliasAddress(&(val)->aliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Endpoint_callSignalAddress(&(val)->callSignalAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Endpoint_rasAddress(&(val)->rasAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_EndpointType(&(val)->endpointType);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Endpoint_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_Endpoint_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_Endpoint_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_Endpoint_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_AliasAddress(enc, &(val)->prefix))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_AliasAddress(dec, &(val)->prefix))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_AliasAddress(&(val)->prefix);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatekeeperRequest_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_GatekeeperRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_GatekeeperRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_GatekeeperRequest_authenticationCapability(ee, &(val)->authenticationCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_GatekeeperRequest_algorithmOIDs(ee, &(val)->algorithmOIDs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_GatekeeperRequest_integrity(ee, &(val)->integrity))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatekeeperRequest_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_authenticationCapability(dd, &(val)->authenticationCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_algorithmOIDs(dd, &(val)->algorithmOIDs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_integrity(dd, &(val)->integrity))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_TransportAddress(&(val)->rasAddress);
	ASN1Free_EndpointType(&(val)->endpointType);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatekeeperRequest_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_GatekeeperRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_GatekeeperRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_GatekeeperRequest_authenticationCapability(&(val)->authenticationCapability);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_GatekeeperRequest_algorithmOIDs(&(val)->algorithmOIDs);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_GatekeeperRequest_integrity(&(val)->integrity);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    o[1] |= 0x1;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->discoveryComplete))
	return 0;
    if (!ASN1Enc_RegistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Enc_RegistrationRequest_rasAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->terminalType))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_RegistrationRequest_terminalAlias(enc, &(val)->terminalAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_VendorIdentifier(enc, &(val)->endpointVendor))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_RegistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    l = ASN1uint32_uoctets((val)->timeToLive - 1);
	    if (!ASN1PEREncBitVal(ee, 2, l - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_RegistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->keepAlive))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->endpointIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->discoveryComplete))
	return 0;
    if (!ASN1Dec_RegistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Dec_RegistrationRequest_rasAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->terminalType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RegistrationRequest_terminalAlias(dec, &(val)->terminalAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_VendorIdentifier(dec, &(val)->endpointVendor))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 2, &l))
		return 0;
	    l += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
		return 0;
	    (val)->timeToLive += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->keepAlive))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->endpointIdentifier).length))
		return 0;
	    ((val)->endpointIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationRequest_callSignalAddress(&(val)->callSignalAddress);
	ASN1Free_RegistrationRequest_rasAddress(&(val)->rasAddress);
	ASN1Free_EndpointType(&(val)->terminalType);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RegistrationRequest_terminalAlias(&(val)->terminalAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1Free_VendorIdentifier(&(val)->endpointVendor);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RegistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_RegistrationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[2] |= 0x40;
    o[2] |= 0x20;
    y = ASN1PEREncCheckExtensions(11, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->irrFrequency - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 11, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_AdmissionConfirm_destinationInfo(ee, &(val)->destinationInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_AdmissionConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_AdmissionConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_AdmissionConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_AdmissionConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x20) {
	    if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->irrFrequency))
	    return 0;
	(val)->irrFrequency += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 11, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_destinationInfo(dd, &(val)->destinationInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AdmissionConfirm_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AdmissionConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EndpointType(&(val)->destinationType);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_AdmissionConfirm_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_AdmissionConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_AdmissionConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_LocationConfirm_destinationInfo(ee, &(val)->destinationInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_LocationConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_LocationConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_LocationConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_LocationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_LocationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_TransportAddress(dec, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_destinationInfo(dd, &(val)->destinationInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->callSignalAddress);
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_LocationConfirm_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_LocationConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EndpointType(&(val)->destinationType);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_LocationConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_LocationConfirm_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_LocationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_LocationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_InfoRequestResponse_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_InfoRequestResponse_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo(enc, &(val)->perCallInfo))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_InfoRequestResponse_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequestResponse_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncBoolean(ee, (val)->needResponse))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_InfoRequestResponse_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InfoRequestResponse_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo(dec, &(val)->perCallInfo))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->needResponse))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_EndpointType(&(val)->endpointType);
	ASN1char16string_free(&(val)->endpointIdentifier);
	ASN1Free_TransportAddress(&(val)->rasAddress);
	ASN1Free_InfoRequestResponse_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InfoRequestResponse_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo(&(val)->perCallInfo);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_InfoRequestResponse_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequestResponse_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_sourceInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_sourceInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_sourceInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Enc_AliasAddress(enc, &(val)->alias))
	return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_AliasAddress(dec, &(val)->alias))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val)
{
    if (val) {
	ASN1Free_AliasAddress(&(val)->alias);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_aliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_aliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_aliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatewayInfo_protocol_ElmFn);
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatewayInfo_protocol_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatewayInfo_protocol_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_sourceAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_sourceAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_sourceAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_Alerting_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Alerting_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Alerting_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_Alerting_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Alerting_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Alerting_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_CallProceeding_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_CallProceeding_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_CallProceeding_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_CallProceeding_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_CallProceeding_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_CallProceeding_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_Connect_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Connect_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Connect_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_Connect_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Connect_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Connect_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x20;
    o[1] |= 0x1;
    o[2] |= 0x80;
    y = ASN1PEREncCheckExtensions(9, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_Setup_UUIE_sourceAddress(enc, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->sourceInfo))
	return 0;
    if (o[0] & 0x20) {
	if (!ASN1Enc_Setup_UUIE_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1Enc_Setup_UUIE_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (o[0] & 0x4) {
	if (!ASN1Enc_Setup_UUIE_destExtraCRV(enc, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Enc_Setup_UUIE_conferenceGoal(enc, &(val)->conferenceGoal))
	return 0;
    if (o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 9, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->sourceCallSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Setup_UUIE_h245SecurityCapability(ee, &(val)->h245SecurityCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Setup_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_Setup_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_Setup_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1PEREncBoolean(ee, (val)->mediaWaitForConnect))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->canOverlapSend))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Setup_UUIE_sourceAddress(dec, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->sourceInfo))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Setup_UUIE_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Setup_UUIE_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Setup_UUIE_destExtraCRV(dec, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Dec_Setup_UUIE_conferenceGoal(dec, &(val)->conferenceGoal))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 9, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->sourceCallSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_h245SecurityCapability(dd, &(val)->h245SecurityCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->mediaWaitForConnect))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canOverlapSend))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Setup_UUIE_sourceAddress(&(val)->sourceAddress);
	}
	ASN1Free_EndpointType(&(val)->sourceInfo);
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Setup_UUIE_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Setup_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Setup_UUIE_destExtraCRV(&(val)->destExtraCRV);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sourceCallSignalAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Setup_UUIE_h245SecurityCapability(&(val)->h245SecurityCapability);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Setup_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_Setup_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_Setup_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->alternativeAddress))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_Facility_UUIE_alternativeAliasAddress(enc, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Enc_FacilityReason(enc, &(val)->reason))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_Facility_UUIE_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Facility_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Facility_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_Facility_UUIE_conferences(ee, &(val)->conferences))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->h245Address))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_Facility_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->alternativeAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Facility_UUIE_alternativeAliasAddress(dec, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Dec_FacilityReason(dec, &(val)->reason))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_conferences(dd, &(val)->conferences))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->h245Address))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->alternativeAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Facility_UUIE_alternativeAliasAddress(&(val)->alternativeAliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_Facility_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Facility_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Facility_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_Facility_UUIE_conferences(&(val)->conferences);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_Facility_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AliasAddress(enc, &(val)->conferenceAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AliasAddress(dec, &(val)->conferenceAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->conferenceAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callIdentifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H245Security(enc, &(val)->h245SecurityMode))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Progress_UUIE_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_Progress_UUIE_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_Progress_UUIE_fastStart(enc, &(val)->fastStart))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callIdentifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H245Security(dec, &(val)->h245SecurityMode))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Progress_UUIE_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_Progress_UUIE_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Progress_UUIE_fastStart(dec, &(val)->fastStart))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_CallIdentifier(&(val)->callIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Progress_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Progress_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Progress_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CryptoH323Token_cryptoEPPwdHash(enc, &(val)->u.cryptoEPPwdHash))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CryptoH323Token_cryptoGKPwdHash(enc, &(val)->u.cryptoGKPwdHash))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoEPPwdEncr))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoGKPwdEncr))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoEPCert))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoGKCert))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_SIGNED_EncodedFastStartToken(enc, &(val)->u.cryptoFastStart))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CryptoToken(enc, &(val)->u.nestedcryptoToken))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CryptoH323Token_cryptoEPPwdHash(dec, &(val)->u.cryptoEPPwdHash))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CryptoH323Token_cryptoGKPwdHash(dec, &(val)->u.cryptoGKPwdHash))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoEPPwdEncr))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoGKPwdEncr))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoEPCert))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoGKCert))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_SIGNED_EncodedFastStartToken(dec, &(val)->u.cryptoFastStart))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CryptoToken(dec, &(val)->u.nestedcryptoToken))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CryptoH323Token_cryptoEPPwdHash(&(val)->u.cryptoEPPwdHash);
	    break;
	case 2:
	    ASN1Free_CryptoH323Token_cryptoGKPwdHash(&(val)->u.cryptoGKPwdHash);
	    break;
	case 3:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoEPPwdEncr);
	    break;
	case 4:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoGKPwdEncr);
	    break;
	case 5:
	    ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoEPCert);
	    break;
	case 6:
	    ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoGKCert);
	    break;
	case 7:
	    ASN1Free_SIGNED_EncodedFastStartToken(&(val)->u.cryptoFastStart);
	    break;
	case 8:
	    ASN1Free_CryptoToken(&(val)->u.nestedcryptoToken);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 25))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_GatekeeperRequest(enc, &(val)->u.gatekeeperRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_GatekeeperConfirm(enc, &(val)->u.gatekeeperConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_GatekeeperReject(enc, &(val)->u.gatekeeperReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_RegistrationRequest(enc, &(val)->u.registrationRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_RegistrationConfirm(enc, &(val)->u.registrationConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RegistrationReject(enc, &(val)->u.registrationReject))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_UnregistrationRequest(enc, &(val)->u.unregistrationRequest))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_UnregistrationConfirm(enc, &(val)->u.unregistrationConfirm))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_UnregistrationReject(enc, &(val)->u.unregistrationReject))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_AdmissionRequest(enc, &(val)->u.admissionRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_AdmissionConfirm(enc, &(val)->u.admissionConfirm))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_AdmissionReject(enc, &(val)->u.admissionReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_BandwidthRequest(enc, &(val)->u.bandwidthRequest))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_BandwidthConfirm(enc, &(val)->u.bandwidthConfirm))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_BandwidthReject(enc, &(val)->u.bandwidthReject))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_DisengageRequest(enc, &(val)->u.disengageRequest))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_DisengageConfirm(enc, &(val)->u.disengageConfirm))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_DisengageReject(enc, &(val)->u.disengageReject))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_LocationRequest(enc, &(val)->u.locationRequest))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_LocationConfirm(enc, &(val)->u.locationConfirm))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_LocationReject(enc, &(val)->u.locationReject))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_InfoRequest(enc, &(val)->u.infoRequest))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_InfoRequestResponse(enc, &(val)->u.infoRequestResponse))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_H225NonStandardMessage(enc, &(val)->u.nonStandardMessage))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_UnknownMessageResponse(enc, &(val)->u.unknownMessageResponse))
	    return 0;
	break;
    case 26:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RequestInProgress(ee, &(val)->u.requestInProgress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 27:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ResourcesAvailableIndicate(ee, &(val)->u.resourcesAvailableIndicate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 28:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ResourcesAvailableConfirm(ee, &(val)->u.resourcesAvailableConfirm))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 29:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_InfoRequestAck(ee, &(val)->u.infoRequestAck))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 30:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_InfoRequestNak(ee, &(val)->u.infoRequestNak))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 25))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_GatekeeperRequest(dec, &(val)->u.gatekeeperRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_GatekeeperConfirm(dec, &(val)->u.gatekeeperConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_GatekeeperReject(dec, &(val)->u.gatekeeperReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_RegistrationRequest(dec, &(val)->u.registrationRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_RegistrationConfirm(dec, &(val)->u.registrationConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RegistrationReject(dec, &(val)->u.registrationReject))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_UnregistrationRequest(dec, &(val)->u.unregistrationRequest))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_UnregistrationConfirm(dec, &(val)->u.unregistrationConfirm))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_UnregistrationReject(dec, &(val)->u.unregistrationReject))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_AdmissionRequest(dec, &(val)->u.admissionRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_AdmissionConfirm(dec, &(val)->u.admissionConfirm))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_AdmissionReject(dec, &(val)->u.admissionReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_BandwidthRequest(dec, &(val)->u.bandwidthRequest))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_BandwidthConfirm(dec, &(val)->u.bandwidthConfirm))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_BandwidthReject(dec, &(val)->u.bandwidthReject))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_DisengageRequest(dec, &(val)->u.disengageRequest))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_DisengageConfirm(dec, &(val)->u.disengageConfirm))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_DisengageReject(dec, &(val)->u.disengageReject))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_LocationRequest(dec, &(val)->u.locationRequest))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_LocationConfirm(dec, &(val)->u.locationConfirm))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_LocationReject(dec, &(val)->u.locationReject))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_InfoRequest(dec, &(val)->u.infoRequest))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_InfoRequestResponse(dec, &(val)->u.infoRequestResponse))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_H225NonStandardMessage(dec, &(val)->u.nonStandardMessage))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_UnknownMessageResponse(dec, &(val)->u.unknownMessageResponse))
	    return 0;
	break;
    case 26:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RequestInProgress(dd, &(val)->u.requestInProgress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 27:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ResourcesAvailableIndicate(dd, &(val)->u.resourcesAvailableIndicate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 28:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ResourcesAvailableConfirm(dd, &(val)->u.resourcesAvailableConfirm))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 29:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_InfoRequestAck(dd, &(val)->u.infoRequestAck))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 30:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_InfoRequestNak(dd, &(val)->u.infoRequestNak))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RasMessage(RasMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_GatekeeperRequest(&(val)->u.gatekeeperRequest);
	    break;
	case 2:
	    ASN1Free_GatekeeperConfirm(&(val)->u.gatekeeperConfirm);
	    break;
	case 3:
	    ASN1Free_GatekeeperReject(&(val)->u.gatekeeperReject);
	    break;
	case 4:
	    ASN1Free_RegistrationRequest(&(val)->u.registrationRequest);
	    break;
	case 5:
	    ASN1Free_RegistrationConfirm(&(val)->u.registrationConfirm);
	    break;
	case 6:
	    ASN1Free_RegistrationReject(&(val)->u.registrationReject);
	    break;
	case 7:
	    ASN1Free_UnregistrationRequest(&(val)->u.unregistrationRequest);
	    break;
	case 8:
	    ASN1Free_UnregistrationConfirm(&(val)->u.unregistrationConfirm);
	    break;
	case 9:
	    ASN1Free_UnregistrationReject(&(val)->u.unregistrationReject);
	    break;
	case 10:
	    ASN1Free_AdmissionRequest(&(val)->u.admissionRequest);
	    break;
	case 11:
	    ASN1Free_AdmissionConfirm(&(val)->u.admissionConfirm);
	    break;
	case 12:
	    ASN1Free_AdmissionReject(&(val)->u.admissionReject);
	    break;
	case 13:
	    ASN1Free_BandwidthRequest(&(val)->u.bandwidthRequest);
	    break;
	case 14:
	    ASN1Free_BandwidthConfirm(&(val)->u.bandwidthConfirm);
	    break;
	case 15:
	    ASN1Free_BandwidthReject(&(val)->u.bandwidthReject);
	    break;
	case 16:
	    ASN1Free_DisengageRequest(&(val)->u.disengageRequest);
	    break;
	case 17:
	    ASN1Free_DisengageConfirm(&(val)->u.disengageConfirm);
	    break;
	case 18:
	    ASN1Free_DisengageReject(&(val)->u.disengageReject);
	    break;
	case 19:
	    ASN1Free_LocationRequest(&(val)->u.locationRequest);
	    break;
	case 20:
	    ASN1Free_LocationConfirm(&(val)->u.locationConfirm);
	    break;
	case 21:
	    ASN1Free_LocationReject(&(val)->u.locationReject);
	    break;
	case 22:
	    ASN1Free_InfoRequest(&(val)->u.infoRequest);
	    break;
	case 23:
	    ASN1Free_InfoRequestResponse(&(val)->u.infoRequestResponse);
	    break;
	case 24:
	    ASN1Free_H225NonStandardMessage(&(val)->u.nonStandardMessage);
	    break;
	case 25:
	    ASN1Free_UnknownMessageResponse(&(val)->u.unknownMessageResponse);
	    break;
	case 26:
	    ASN1Free_RequestInProgress(&(val)->u.requestInProgress);
	    break;
	case 27:
	    ASN1Free_ResourcesAvailableIndicate(&(val)->u.resourcesAvailableIndicate);
	    break;
	case 28:
	    ASN1Free_ResourcesAvailableConfirm(&(val)->u.resourcesAvailableConfirm);
	    break;
	case 29:
	    ASN1Free_InfoRequestAck(&(val)->u.infoRequestAck);
	    break;
	case 30:
	    ASN1Free_InfoRequestNak(&(val)->u.infoRequestNak);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_conferences_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val)
{
    if (!ASN1Enc_ConferenceList(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_conferences_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val)
{
    if (!ASN1Dec_ConferenceList(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_conferences_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val)
{
    if (val) {
	ASN1Free_ConferenceList(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Setup_UUIE(enc, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CallProceeding_UUIE(enc, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Connect_UUIE(enc, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Alerting_UUIE(enc, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_Information_UUIE(enc, &(val)->u.information))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ReleaseComplete_UUIE(enc, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_Facility_UUIE(enc, &(val)->u.facility))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_Progress_UUIE(ee, &(val)->u.progress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Setup_UUIE(dec, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CallProceeding_UUIE(dec, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Connect_UUIE(dec, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Alerting_UUIE(dec, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_Information_UUIE(dec, &(val)->u.information))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ReleaseComplete_UUIE(dec, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_Facility_UUIE(dec, &(val)->u.facility))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_Progress_UUIE(dd, &(val)->u.progress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Setup_UUIE(&(val)->u.setup);
	    break;
	case 2:
	    ASN1Free_CallProceeding_UUIE(&(val)->u.callProceeding);
	    break;
	case 3:
	    ASN1Free_Connect_UUIE(&(val)->u.connect);
	    break;
	case 4:
	    ASN1Free_Alerting_UUIE(&(val)->u.alerting);
	    break;
	case 5:
	    ASN1Free_Information_UUIE(&(val)->u.information);
	    break;
	case 6:
	    ASN1Free_ReleaseComplete_UUIE(&(val)->u.releaseComplete);
	    break;
	case 7:
	    ASN1Free_Facility_UUIE(&(val)->u.facility);
	    break;
	case 8:
	    ASN1Free_Progress_UUIE(&(val)->u.progress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU_h323_message_body(enc, &(val)->h323_message_body))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ee, &(val)->h4501SupplementaryService))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->h245Tunneling))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_H323_UU_PDU_h245Control(ee, &(val)->h245Control))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_H323_UU_PDU_nonStandardControl(ee, &(val)->nonStandardControl))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU_h323_message_body(dec, &(val)->h323_message_body))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_h4501SupplementaryService(dd, &(val)->h4501SupplementaryService))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->h245Tunneling))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_h245Control(dd, &(val)->h245Control))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_nonStandardControl(dd, &(val)->nonStandardControl))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU_h323_message_body(&(val)->h323_message_body);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H323_UU_PDU_h4501SupplementaryService(&(val)->h4501SupplementaryService);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_H323_UU_PDU_h245Control(&(val)->h245Control);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_H323_UU_PDU_nonStandardControl(&(val)->nonStandardControl);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323pdu))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323pdu))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sent))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323pdu);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (val) {
	ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H323_UserInformation_user_data(enc, &(val)->user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H323_UserInformation_user_data(dec, &(val)->user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323_uu_pdu);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H323_UserInformation_user_data(&(val)->user_data);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245asnv3.h ===
#ifndef _H245ASNV3_Module_H_
#define _H245ASNV3_Module_H_

#include "nmasn1.h"
#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation * PRequestAllTerminalIDsResponse_terminalInformation;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;

typedef ASN1uint16_t MediaPacketizationCapability_rtpPayloadType_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart_repeatCount {
    ASN1choice_t choice;
#   define doOneProgression_chosen 1
#   define doContinuousProgressions_chosen 2
#   define doOneIndependentProgression_chosen 3
#   define doContinuousIndependentProgressions_chosen 4
} MiscellaneousCommand_type_progressiveRefinementStart_repeatCount;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart {
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount repeatCount;
} MiscellaneousCommand_type_progressiveRefinementStart;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_reverseParameters_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_reverseParameters_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_reverseParameters_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_reverseParameters_multiplex_programStream_chosen 3
} NewATMVCIndication_reverseParameters_multiplex;

typedef struct UserInputIndication_signal_rtp {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define timestamp_present 0x80
    ASN1uint32_t timestamp;
#   define expirationTime_present 0x40
    ASN1uint32_t expirationTime;
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signal_rtp;

typedef struct UserInputIndication_signalUpdate_rtp {
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signalUpdate_rtp;

typedef struct UserInputIndication_signalUpdate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t duration;
#   define UserInputIndication_signalUpdate_rtp_present 0x80
    UserInputIndication_signalUpdate_rtp rtp;
} UserInputIndication_signalUpdate;

typedef struct UserInputIndication_signal {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char_t signalType[2];
#   define duration_present 0x80
    ASN1uint16_t duration;
#   define UserInputIndication_signal_rtp_present 0x40
    UserInputIndication_signal_rtp rtp;
} UserInputIndication_signal;

typedef struct NewATMVCIndication_reverseParameters {
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_reverseParameters_multiplex multiplex;
} NewATMVCIndication_reverseParameters;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_multiplex_programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct H223MultiplexReconfiguration_h223AnnexADoubleFlag {
    ASN1choice_t choice;
#   define start_chosen 1
#   define stop_chosen 2
} H223MultiplexReconfiguration_h223AnnexADoubleFlag;

typedef struct H223MultiplexReconfiguration_h223ModeChange {
    ASN1choice_t choice;
#   define toLevel0_chosen 1
#   define toLevel1_chosen 2
#   define toLevel2_chosen 3
#   define toLevel2withOptionalHeader_chosen 4
} H223MultiplexReconfiguration_h223ModeChange;

typedef struct EndSessionCommand_isdnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_isdnOptions_telephonyMode_chosen 1
#   define v108_chosen 2
} EndSessionCommand_isdnOptions;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_gstnOptions_telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct RemoteMCResponse_reject {
    ASN1choice_t choice;
#   define RemoteMCResponse_reject_unspecified_chosen 1
#   define RemoteMCResponse_reject_functionNotSupported_chosen 2
} RemoteMCResponse_reject;

typedef struct ConferenceResponse_sendThisSourceResponse {
    ASN1choice_t choice;
#   define grantedSendThisSource_chosen 1
#   define deniedSendThisSource_chosen 2
} ConferenceResponse_sendThisSourceResponse;

typedef struct ConferenceResponse_makeTerminalBroadcasterResponse {
    ASN1choice_t choice;
#   define grantedMakeTerminalBroadcaster_chosen 1
#   define deniedMakeTerminalBroadcaster_chosen 2
} ConferenceResponse_makeTerminalBroadcasterResponse;

typedef struct ConferenceResponse_broadcastMyLogicalChannelResponse {
    ASN1choice_t choice;
#   define grantedBroadcastMyLogicalChannel_chosen 1
#   define deniedBroadcastMyLogicalChannel_chosen 2
} ConferenceResponse_broadcastMyLogicalChannelResponse;

typedef struct ConferenceResponse_extensionAddressResponse {
    TerminalID extensionAddress;
} ConferenceResponse_extensionAddressResponse;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct RequestChannelClose_reason {
    ASN1choice_t choice;
#   define RequestChannelClose_reason_unknown_chosen 1
#   define normal_chosen 2
#   define RequestChannelClose_reason_reopen_chosen 3
#   define RequestChannelClose_reason_reservationFailure_chosen 4
} RequestChannelClose_reason;

typedef struct CloseLogicalChannel_reason {
    ASN1choice_t choice;
#   define CloseLogicalChannel_reason_unknown_chosen 1
#   define CloseLogicalChannel_reason_reopen_chosen 2
#   define CloseLogicalChannel_reason_reservationFailure_chosen 3
} CloseLogicalChannel_reason;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
#   define waitForCommunicationMode_chosen 12
#   define invalidDependentChannel_chosen 13
#   define replacementForRejected_chosen 14
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
    union {
#	define h261aVideoPacketization_chosen 1
#	define rtpPayloadType_chosen 2
	ASN1uint16_t rtpPayloadType;
    } u;
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define noSuspendResume_chosen 1
#   define V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen 2
#   define V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen 3
} V76LogicalChannelParameters_suspendResume;

typedef struct H223AnnexCArqParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define H223AnnexCArqParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} H223AnnexCArqParameters_numberOfRetransmissions;

typedef struct H223AL3MParameters_fecType {
    ASN1choice_t choice;
#   define H223AL3MParameters_fecType_rcpcRate8by8_chosen 1
#   define H223AL3MParameters_fecType_rcpcRate8by9_chosen 2
#   define H223AL3MParameters_fecType_rcpcRate8by10_chosen 3
#   define H223AL3MParameters_fecType_rcpcRate8by12_chosen 4
#   define H223AL3MParameters_fecType_rcpcRate8by16_chosen 5
#   define H223AL3MParameters_fecType_rcpcRate8by20_chosen 6
#   define H223AL3MParameters_fecType_rcpcRate8by24_chosen 7
#   define H223AL3MParameters_fecType_rcpcRate8by32_chosen 8
} H223AL3MParameters_fecType;

typedef struct H223AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL3MParameters_crcLength_crc4bit_chosen 1
#   define H223AL3MParameters_crcLength_crc12bit_chosen 2
#   define H223AL3MParameters_crcLength_crc20bit_chosen 3
#   define H223AL3MParameters_crcLength_crc28bit_chosen 4
} H223AL3MParameters_crcLength;

typedef struct H223AL3MParameters_headerFormat {
    ASN1choice_t choice;
#   define sebch16_7_chosen 1
#   define golay24_12_chosen 2
} H223AL3MParameters_headerFormat;

typedef struct H223AL2MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_5_chosen 1
#   define golay24_12_chosen 2
} H223AL2MParameters_headerFEC;

typedef struct H223AL1MParameters_fecType {
    ASN1choice_t choice;
#   define H223AL1MParameters_fecType_rcpcRate8by8_chosen 1
#   define H223AL1MParameters_fecType_rcpcRate8by9_chosen 2
#   define H223AL1MParameters_fecType_rcpcRate8by10_chosen 3
#   define H223AL1MParameters_fecType_rcpcRate8by12_chosen 4
#   define H223AL1MParameters_fecType_rcpcRate8by16_chosen 5
#   define H223AL1MParameters_fecType_rcpcRate8by20_chosen 6
#   define H223AL1MParameters_fecType_rcpcRate8by24_chosen 7
#   define H223AL1MParameters_fecType_rcpcRate8by32_chosen 8
} H223AL1MParameters_fecType;

typedef struct H223AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL1MParameters_crcLength_crc4bit_chosen 1
#   define H223AL1MParameters_crcLength_crc12bit_chosen 2
#   define H223AL1MParameters_crcLength_crc20bit_chosen 3
#   define H223AL1MParameters_crcLength_crc28bit_chosen 4
} H223AL1MParameters_crcLength;

typedef struct H223AL1MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_7_chosen 1
#   define golay24_12_chosen 2
} H223AL1MParameters_headerFEC;

typedef struct H223AL1MParameters_transferMode {
    ASN1choice_t choice;
#   define framed_chosen 1
#   define unframed_chosen 2
} H223AL1MParameters_transferMode;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_t120SetupProcedure {
    ASN1choice_t choice;
#   define issueJoin_chosen 1
#   define issueQueryAndJoin_chosen 2
#   define issueCreate_chosen 3
#   define issueInvite_chosen 4
#   define waitForInvite_chosen 5
} NetworkAccessParameters_t120SetupProcedure;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} RedundancyEncodingCapability_secondaryEncoding;

typedef struct MediaPacketizationCapability_rtpPayloadType {
    ASN1uint32_t count;
    MediaPacketizationCapability_rtpPayloadType_Seq value[256];
} MediaPacketizationCapability_rtpPayloadType;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_mobileOperationTransmitCapability {
    ASN1bool_t modeChangeCapability;
    ASN1bool_t h223AnnexA;
    ASN1bool_t h223AnnexADoubleFlag;
    ASN1bool_t h223AnnexB;
    ASN1bool_t h223AnnexBwithHeader;
} H223Capability_mobileOperationTransmitCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define basic_chosen 1
#	define enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223AnnexCCapability {
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1bool_t alpduInterleaving;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
} H223AnnexCCapability;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct MediaPacketizationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t h261aVideoPacketization;
#   define rtpPayloadType_present 0x80
    MediaPacketizationCapability_rtpPayloadType rtpPayloadType;
} MediaPacketizationCapability;

typedef struct QOSMode {
    ASN1choice_t choice;
    union {
#	define guaranteedQOS_chosen 1
	ASN1bool_t guaranteedQOS;
#	define controlledLoad_chosen 2
	ASN1bool_t controlledLoad;
    } u;
} QOSMode;

typedef struct ATMParameters {
    ASN1uint16_t maxNTUSize;
    ASN1bool_t atmUBR;
    ASN1bool_t atmrtVBR;
    ASN1bool_t atmnrtVBR;
    ASN1bool_t atmABR;
    ASN1bool_t atmCBR;
} ATMParameters;

typedef struct MediaTransportType {
    ASN1choice_t choice;
#   define ip_UDP_chosen 1
#   define ip_TCP_chosen 2
#   define atm_AAL5_UNIDIR_chosen 3
#   define atm_AAL5_BIDIR_chosen 4
} MediaTransportType;

typedef struct MediaChannelCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define mediaTransport_present 0x80
    MediaTransportType mediaTransport;
} MediaChannelCapability;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;

typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceCapability_nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct H223AL2MParameters {
    H223AL2MParameters_headerFEC headerFEC;
    ASN1bool_t alpduInterleaving;
} H223AL2MParameters;

typedef struct H223AnnexCArqParameters {
    H223AnnexCArqParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} H223AnnexCArqParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct EscrowData {
    ASN1objectidentifier_t escrowID;
    ASN1bitstring_t escrowValue;
} EscrowData;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
#   define CloseLogicalChannel_reason_present 0x80
    CloseLogicalChannel_reason reason;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define V76ModeParameters_suspendResumewAddress_chosen 1
#   define V76ModeParameters_suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct Criteria {
    ASN1objectidentifier_t field;
    struct Criteria_value_value {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } value;
} Criteria;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct RequestAllTerminalIDsResponse {
    PRequestAllTerminalIDsResponse_terminalInformation terminalInformation;
} RequestAllTerminalIDsResponse;

typedef struct TerminalInformation {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} TerminalInformation;

typedef struct RemoteMCRequest {
    ASN1choice_t choice;
#   define masterActivate_chosen 1
#   define slaveActivate_chosen 2
#   define deActivate_chosen 3
} RemoteMCRequest;

typedef struct RemoteMCResponse {
    ASN1choice_t choice;
    union {
#	define accept_chosen 1
#	define reject_chosen 2
	RemoteMCResponse_reject reject;
    } u;
} RemoteMCResponse;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct SubstituteConferenceIDCommand {
    struct SubstituteConferenceIDCommand_conferenceIdentifier_conferenceIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } conferenceIdentifier;
} SubstituteConferenceIDCommand;

typedef struct KeyProtectionMethod {
    ASN1bool_t secureChannel;
    ASN1bool_t sharedSecret;
    ASN1bool_t certProtectedKey;
} KeyProtectionMethod;

typedef struct EncryptionUpdateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define keyProtectionMethod_present 0x80
    KeyProtectionMethod keyProtectionMethod;
} EncryptionUpdateRequest;

typedef struct H223MultiplexReconfiguration {
    ASN1choice_t choice;
    union {
#	define h223ModeChange_chosen 1
	H223MultiplexReconfiguration_h223ModeChange h223ModeChange;
#	define h223AnnexADoubleFlag_chosen 2
	H223MultiplexReconfiguration_h223AnnexADoubleFlag h223AnnexADoubleFlag;
    } u;
} H223MultiplexReconfiguration;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
#	define withdrawChairToken_chosen 11
#	define floorRequested_chosen 12
	TerminalLabel floorRequested;
    } u;
} ConferenceIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
#   define reverseParameters_present 0x80
    NewATMVCIndication_reverseParameters reverseParameters;
} NewATMVCIndication;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping value[256];
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation {
    PRequestAllTerminalIDsResponse_terminalInformation next;
    TerminalInformation value;
} RequestAllTerminalIDsResponse_terminalInformation_Element;

typedef struct ConferenceResponse_terminalCertificateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceResponse_terminalCertificateResponse_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certificateResponse_present 0x40
    struct ConferenceResponse_terminalCertificateResponse_certificateResponse_certificateResponse {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } certificateResponse;
} ConferenceResponse_terminalCertificateResponse;

typedef struct ConferenceResponse_chairTokenOwnerResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_chairTokenOwnerResponse;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct EncryptionSync_escrowentry {
    ASN1uint32_t count;
    EscrowData value[256];
} EncryptionSync_escrowentry;

typedef struct H223AL3MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL3MParameters_arqType_noArq_chosen 1
#	define H223AL3MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL3MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL3MParameters_arqType;

typedef struct H223AL1MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL1MParameters_arqType_noArq_chosen 1
#	define H223AL1MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL1MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL1MParameters_arqType;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    ASN1uint32_t count;
    CustomPictureFormat value[16];
} H263Options_customPictureFormat;

typedef struct H263Options_customPictureClockFrequency {
    ASN1uint32_t count;
    CustomPictureClockFrequency value[16];
} H263Options_customPictureClockFrequency;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct TransportCapability_mediaChannelCapabilities {
    ASN1uint32_t count;
    MediaChannelCapability value[256];
} TransportCapability_mediaChannelCapabilities;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H223Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
#   define maxMUXPDUSizeCapability_present 0x80
    ASN1bool_t maxMUXPDUSizeCapability;
#   define nsrpSupport_present 0x40
    ASN1bool_t nsrpSupport;
#   define mobileOperationTransmitCapability_present 0x20
    H223Capability_mobileOperationTransmitCapability mobileOperationTransmitCapability;
#   define h223AnnexCCapability_present 0x10
    H223AnnexCCapability h223AnnexCCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct RSVPParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define qosMode_present 0x80
    QOSMode qosMode;
#   define tokenRate_present 0x40
    ASN1uint32_t tokenRate;
#   define bucketSize_present 0x20
    ASN1uint32_t bucketSize;
#   define peakRate_present 0x10
    ASN1uint32_t peakRate;
#   define minPoliced_present 0x8
    ASN1uint32_t minPoliced;
#   define maxPktSize_present 0x4
    ASN1uint32_t maxPktSize;
} RSVPParameters;

typedef struct QOSCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define QOSCapability_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define rsvpParameters_present 0x40
    RSVPParameters rsvpParameters;
#   define atmParameters_present 0x20
    ATMParameters atmParameters;
} QOSCapability;

typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct MediaEncryptionAlgorithm {
    ASN1choice_t choice;
    union {
#	define MediaEncryptionAlgorithm_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define algorithm_chosen 2
	ASN1objectidentifier_t algorithm;
    } u;
} MediaEncryptionAlgorithm;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct H223AL1MParameters {
    H223AL1MParameters_transferMode transferMode;
    H223AL1MParameters_headerFEC headerFEC;
    H223AL1MParameters_crcLength crcLength;
    H223AL1MParameters_fecType fecType;
    H223AL1MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
    ASN1bool_t alsduSegmentation;
} H223AL1MParameters;

typedef struct H223AL3MParameters {
    H223AL3MParameters_headerFormat headerFormat;
    H223AL3MParameters_crcLength crcLength;
    H223AL3MParameters_fecType fecType;
    H223AL3MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
} H223AL3MParameters;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct EncryptionSync {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EncryptionSync_nonStandard_present 0x80
    NonStandardParameter nonStandard;
    ASN1uint16_t synchFlag;
    struct EncryptionSync_h235Key_h235Key {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } h235Key;
#   define escrowentry_present 0x40
    EncryptionSync_escrowentry escrowentry;
} EncryptionSync;

typedef struct RequestChannelClose {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define qosCapability_present 0x80
    QOSCapability qosCapability;
#   define RequestChannelClose_reason_present 0x40
    RequestChannelClose_reason reason;
} RequestChannelClose;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define g722_64k_chosen 6
#	define g722_56k_chosen 7
#	define g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct CertSelectionCriteria {
    ASN1uint32_t count;
    Criteria value[16];
} CertSelectionCriteria;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
#	define extensionAddressResponse_chosen 9
	ConferenceResponse_extensionAddressResponse extensionAddressResponse;
#	define chairTokenOwnerResponse_chosen 10
	ConferenceResponse_chairTokenOwnerResponse chairTokenOwnerResponse;
#	define terminalCertificateResponse_chosen 11
	ConferenceResponse_terminalCertificateResponse terminalCertificateResponse;
#	define broadcastMyLogicalChannelResponse_chosen 12
	ConferenceResponse_broadcastMyLogicalChannelResponse broadcastMyLogicalChannelResponse;
#	define makeTerminalBroadcasterResponse_chosen 13
	ConferenceResponse_makeTerminalBroadcasterResponse makeTerminalBroadcasterResponse;
#	define sendThisSourceResponse_chosen 14
	ConferenceResponse_sendThisSourceResponse sendThisSourceResponse;
#	define requestAllTerminalIDsResponse_chosen 15
	RequestAllTerminalIDsResponse requestAllTerminalIDsResponse;
#	define remoteMCResponse_chosen 16
	RemoteMCResponse remoteMCResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
#	define isdnOptions_chosen 4
	EndSessionCommand_isdnOptions isdnOptions;
    } u;
} EndSessionCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define ConferenceCommand_broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define ConferenceCommand_makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define ConferenceCommand_sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
#	define substituteConferenceIDCommand_chosen 8
	SubstituteConferenceIDCommand substituteConferenceIDCommand;
    } u;
} ConferenceCommand;

typedef struct UserInputIndication_userInputSupportIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_userInputSupportIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define UserInputIndication_userInputSupportIndication_basicString_chosen 2
#	define UserInputIndication_userInputSupportIndication_iA5String_chosen 3
#	define UserInputIndication_userInputSupportIndication_generalString_chosen 4
    } u;
} UserInputIndication_userInputSupportIndication;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
#	define maxH223MUXPDUsize_chosen 12
	ASN1uint16_t maxH223MUXPDUsize;
#	define encryptionUpdate_chosen 13
	EncryptionSync encryptionUpdate;
#	define encryptionUpdateRequest_chosen 14
	EncryptionUpdateRequest encryptionUpdateRequest;
#	define switchReceiveMediaOff_chosen 15
#	define switchReceiveMediaOn_chosen 16
#	define progressiveRefinementStart_chosen 17
	MiscellaneousCommand_type_progressiveRefinementStart progressiveRefinementStart;
#	define progressiveRefinementAbortOne_chosen 18
#	define progressiveRefinementAbortContinuous_chosen 19
    } u;
} MiscellaneousCommand_type;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct ConferenceRequest_requestTerminalCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceRequest_requestTerminalCertificate_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certSelectionCriteria_present 0x40
    CertSelectionCriteria certSelectionCriteria;
#   define sRandom_present 0x20
    ASN1uint32_t sRandom;
} ConferenceRequest_requestTerminalCertificate;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct RedundancyEncodingMode_secondaryEncoding {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMode_secondaryEncoding_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define RedundancyEncodingMode_secondaryEncoding_audioData_chosen 2
	AudioMode audioData;
    } u;
} RedundancyEncodingMode_secondaryEncoding;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
#	define H223ModeParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223ModeParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223ModeParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
#	define H223LogicalChannelParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223LogicalChannelParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223LogicalChannelParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct UserInputCapability_nonStandard {
    ASN1uint32_t count;
    NonStandardParameter value[16];
} UserInputCapability_nonStandard;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct H263Options_modeCombos {
    ASN1uint32_t count;
    H263VideoModeCombos value[16];
} H263Options_modeCombos;

typedef struct TransportCapability_qOSCapabilities {
    ASN1uint32_t count;
    QOSCapability value[256];
} TransportCapability_qOSCapabilities;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct TransportCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TransportCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
#   define qOSCapabilities_present 0x40
    TransportCapability_qOSCapabilities qOSCapabilities;
#   define mediaChannelCapabilities_present 0x20
    TransportCapability_mediaChannelCapabilities mediaChannelCapabilities;
} TransportCapability;

typedef struct RedundancyEncodingMethod {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMethod_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define rtpAudioRedundancyEncoding_chosen 2
#	define rtpH263VideoRedundancyEncoding_chosen 3
	RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding;
    } u;
} RedundancyEncodingMethod;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    H263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    H263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    H263Options_modeCombos modeCombos;
} H263Options;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;

typedef struct EncryptionCapability {
    ASN1uint32_t count;
    MediaEncryptionAlgorithm value[256];
} EncryptionCapability;

typedef struct UserInputCapability {
    ASN1choice_t choice;
    union {
#	define UserInputCapability_nonStandard_chosen 1
	UserInputCapability_nonStandard nonStandard;
#	define UserInputCapability_basicString_chosen 2
#	define UserInputCapability_iA5String_chosen 3
#	define UserInputCapability_generalString_chosen 4
#	define dtmf_chosen 5
#	define hookflash_chosen 6
    } u;
} UserInputCapability;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} TransportAddress;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
#   define flowControlToZero_present 0x8000
    ASN1bool_t flowControlToZero;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct RedundancyEncodingMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncodingMode_secondaryEncoding_present 0x80
    RedundancyEncodingMode_secondaryEncoding secondaryEncoding;
} RedundancyEncodingMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
#	define enterExtensionAddress_chosen 9
#	define requestChairTokenOwner_chosen 10
#	define requestTerminalCertificate_chosen 11
	ConferenceRequest_requestTerminalCertificate requestTerminalCertificate;
#	define ConferenceRequest_broadcastMyLogicalChannel_chosen 12
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define ConferenceRequest_makeTerminalBroadcaster_chosen 13
	TerminalLabel makeTerminalBroadcaster;
#	define ConferenceRequest_sendThisSource_chosen 14
	TerminalLabel sendThisSource;
#	define requestAllTerminalIDs_chosen 15
#	define remoteMCRequest_chosen 16
	RemoteMCRequest remoteMCRequest;
    } u;
} ConferenceRequest;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct MCLocationIndication {
    TransportAddress signalAddress;
} MCLocationIndication;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
#	define userInputSupportIndication_chosen 3
	UserInputIndication_userInputSupportIndication userInputSupportIndication;
#	define signal_chosen 4
	UserInputIndication_signal signal;
#	define signalUpdate_chosen 5
	UserInputIndication_signalUpdate signalUpdate;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
#	define transportCapability_chosen 12
	TransportCapability transportCapability;
    } u;
} MiscellaneousIndication_type;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataApplicationCapability_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataApplicationCapability_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataApplicationCapability_application;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
#	define h223MultiplexReconfiguration_chosen 10
	H223MultiplexReconfiguration h223MultiplexReconfiguration;
    } u;
} CommandMessage;

typedef struct RedundancyEncodingCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
    CapabilityTableEntryNumber primaryEncoding;
#   define RedundancyEncodingCapability_secondaryEncoding_present 0x80
    RedundancyEncodingCapability_secondaryEncoding secondaryEncoding;
} RedundancyEncodingCapability;

typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    EncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
#   define t120SetupProcedure_present 0x8000
    NetworkAccessParameters_t120SetupProcedure t120SetupProcedure;
} NetworkAccessParameters;

typedef struct H2250ModeParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define redundancyEncodingMode_present 0x80
    RedundancyEncodingMode redundancyEncodingMode;
} H2250ModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct EnhancementLayerInfo_spatialEnhancement {
    ASN1uint32_t count;
    EnhancementOptions value[14];
} EnhancementLayerInfo_spatialEnhancement;

typedef struct EnhancementLayerInfo_snrEnhancement {
    ASN1uint32_t count;
    EnhancementOptions value[14];
} EnhancementLayerInfo_snrEnhancement;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct H2250Capability_redundancyEncodingCapability {
    ASN1uint32_t count;
    RedundancyEncodingCapability value[256];
} H2250Capability_redundancyEncodingCapability;

typedef struct H235SecurityCapability {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    CapabilityTableEntryNumber mediaCapability;
} H235SecurityCapability;

typedef struct H2250Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
#   define H2250Capability_transportCapability_present 0x80
    TransportCapability transportCapability;
#   define redundancyEncodingCapability_present 0x40
    H2250Capability_redundancyEncodingCapability redundancyEncodingCapability;
#   define logicalChannelSwitchingCapability_present 0x20
    ASN1bool_t logicalChannelSwitchingCapability;
#   define t120DynamicPortCapability_present 0x10
    ASN1bool_t t120DynamicPortCapability;
} H2250Capability;

typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    ASN1uint32_t count;
    BEnhancementParameters value[14];
} EnhancementLayerInfo_bPictureEnhancement;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
    } u;
} MultiplexCapability;

typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    EnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    EnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    EnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

typedef struct H235Media_mediaType {
    ASN1choice_t choice;
    union {
#	define H235Media_mediaType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Media_mediaType_videoData_chosen 2
	VideoCapability videoData;
#	define H235Media_mediaType_audioData_chosen 3
	AudioCapability audioData;
#	define H235Media_mediaType_data_chosen 4
	DataApplicationCapability data;
    } u;
} H235Media_mediaType;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
#	define h235SecurityCapability_chosen 14
	H235SecurityCapability h235SecurityCapability;
#	define maxPendingReplacementFor_chosen 15
	ASN1uint16_t maxPendingReplacementFor;
#	define receiveUserInputCapability_chosen 16
	UserInputCapability receiveUserInputCapability;
#	define transmitUserInputCapability_chosen 17
	UserInputCapability transmitUserInputCapability;
#	define receiveAndTransmitUserInputCapability_chosen 18
	UserInputCapability receiveAndTransmitUserInputCapability;
    } u;
} Capability;

typedef struct H235Media {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Media_mediaType mediaType;
} H235Media;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h2250ModeParameters_present 0x4000
    H2250ModeParameters h2250ModeParameters;
} ModeElement;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
#	define h235Control_chosen 7
	NonStandardParameter h235Control;
#	define h235Media_chosen 8
	H235Media h235Media;
    } u;
} DataType;

typedef struct RedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncoding_secondaryEncoding_present 0x80
    DataType secondaryEncoding;
} RedundancyEncoding;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define CommunicationModeTableEntry_terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define CommunicationModeTableEntry_redundancyEncoding_present 0x8000
    RedundancyEncoding redundancyEncoding;
#   define sessionDependency_present 0x4000
    ASN1uint16_t sessionDependency;
} CommunicationModeTableEntry;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    ASN1uint32_t count;
    CapabilityTableEntry value[256];
} TerminalCapabilitySet_capabilityTable;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    TerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
#   define H2250LogicalChannelParameters_transportCapability_present 0x800000
    TransportCapability transportCapability;
#   define H2250LogicalChannelParameters_redundancyEncoding_present 0x400000
    RedundancyEncoding redundancyEncoding;
#   define source_present 0x200000
    TerminalLabel source;
} H2250LogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none_chosen 5
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor_present 0x8000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define reverseLogicalChannelDependency_present 0x8000
    LogicalChannelNumber reverseLogicalChannelDependency;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define forwardLogicalChannelDependency_present 0x8000
    LogicalChannelNumber forwardLogicalChannelDependency;
#   define OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define OpenLogicalChannel_encryptionSync_present 0x4000
    EncryptionSync encryptionSync;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
#   define OpenLogicalChannelAck_encryptionSync_present 0x2000
    EncryptionSync encryptionSync;
} OpenLogicalChannelAck;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
    } u;
} ResponseMessage;

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define IndicationMessage_functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 0
#define SIZE_H245ASNV3_Module_PDU_0 sizeof(MultimediaSystemControlMessage)

extern ASN1module_t H245ASNV3_Module;
extern void ASN1CALL H245ASNV3_Module_init();
extern void ASN1CALL H245ASNV3_Module_finit();

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
    extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
    extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
    extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
    extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
    extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
    extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
    extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
    extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
    extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
    extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
    extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
    extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
    extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245ASNV3_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245com.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.			
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245com.h  $						
 *  $Revision:   1.6  $							
 *  $Modtime:   Mar 04 1997 17:38:42  $					
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/h245com.h_v  $	
 * 
 *    Rev 1.6   Mar 04 1997 17:53:24   tomitowx
 * process detach fix
 * 
 *    Rev 1.5   12 Dec 1996 15:53:48   EHOWARDX
 * 
 * Master Slave Determination kludge.
 * 
 *    Rev 1.4   10 Jun 1996 16:51:20   EHOWARDX
 * Added Configuration parameter to InstanceCreate().
 * 
 *    Rev 1.3   04 Jun 1996 13:24:38   EHOWARDX
 * Fixed warnings in Release build.
 * 
 *    Rev 1.2   29 May 1996 15:21:30   EHOWARDX
 * No change.
 * 
 *    Rev 1.1   28 May 1996 14:10:00   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:04:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17   09 May 1996 19:38:10   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.16   04 Apr 1996 18:06:30   cjutzi
 * - added shutdown lock
 * 
 *    Rev 1.15   26 Mar 1996 13:39:56   cjutzi
 * - fixed ASSERT warning message
 * 
 *    Rev 1.14   26 Mar 1996 13:24:26   cjutzi
 * 
 * - added pragma for release code.. to disable warning messages
 *   from H245TRACE
 * 
 *    Rev 1.13   26 Mar 1996 09:49:34   cjutzi
 * 
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 * 
 *    Rev 1.12   26 Mar 1996 08:40:44   cjutzi
 * 
 * 
 *    Rev 1.11   25 Mar 1996 17:54:44   cjutzi
 * 
 * - broke build.. backstep
 * 
 *    Rev 1.10   25 Mar 1996 17:21:32   cjutzi
 * 
 * - added h245sys.x to the global includes for the enter critical 
 *   section stuff
 * 
 *    Rev 1.9   18 Mar 1996 09:14:10   cjutzi
 * 
 * - sorry.. removed timer lock.. not needed. 
 * 
 *    Rev 1.8   18 Mar 1996 08:48:38   cjutzi
 * - added timer lock
 * 
 *    Rev 1.7   13 Mar 1996 14:08:20   cjutzi
 * - removed ASSERT when NDEBUG is defined
 * 
 * 
 *    Rev 1.6   13 Mar 1996 09:50:16   dabrown1
 * added winspox.h for CRITICAL_SECTION definition
 * 
 *    Rev 1.5   12 Mar 1996 15:48:24   cjutzi
 * 
 * - added instance table lock
 * 
 *    Rev 1.4   28 Feb 1996 09:36:22   cjutzi
 * 
 * - added ossGlobal p_ossWorld for debug PDU tracing and PDU verification
 * 
 *    Rev 1.3   21 Feb 1996 12:18:52   EHOWARDX
 * Added parenthesis around n in H245ASSERT() macro.
 * Note: Logical not (!) has higher operator precedence than equal/not equal
 * (== or !=). Therefore, in many places this ASSERT was not acting as the
 * author intended. It is always a good idea to fully parenthesize expressions
 * in macros!
 * 
 *    Rev 1.2   09 Feb 1996 16:19:52   cjutzi
 * 
 * - Added export InstanceTbl to module.. from h245init.x
 * - added trace
 * - added Assert define's
 *  $Ident$
 *
 *****************************************************************************/

#ifndef _H245COM_H_
#define _H245COM_H_
#include "h245api.h"
#include "h245sys.x"		/* critical section stuff */
#include "api.h"		/* api includes */
#include "sendrcv.x"
#include "h245fsm.h"

#ifndef OIL
# define RESULT unsigned long
#endif

void H245Panic  (LPSTR, int);
#ifndef NDEBUG
#define H245PANIC()   { H245Panic(__FILE__,__LINE__); }
#else
#define H245PANIC()
#endif

/*
 * Trace Level Definitions:
 * 
 *	0 - no trace on at all
 *	1 - only errors
 *	2 - PDU tracking
 *	3 - PDU and SendReceive packet tracing
 *	4 - Main API Module level tracing
 *	5 - Inter Module level tacing #1
 *	6 - Inter Module level tacing #2
 *	7 - <Undefined>
 *	8 - <Undefined>
 *	9 - <Undefined>
 *	10- and above.. free for all
 */
#ifndef NDEBUG
void H245TRACE (H245_INST_T inst, DWORD level, LPSTR format, ...);
#else
/* disable H245TRACE warning message too may parameters for macro */
#pragma warning (disable:4002)
#define H245TRACE()
#endif

#define MAXINST	16

extern  DWORD TraceLevel;

typedef struct TimerList 
{
  struct TimerList    * pNext;
  void		      * pContext;
  H245TIMERCALLBACK     pfnCallBack;
  DWORD                 dwAlarm;

} TimerList_T;

typedef struct InstanceStruct 
{
  DWORD		    dwPhysId;           // Physical Identifier
  DWORD		    dwInst;             // H.245 client instance Identifier
  H245_CONFIG_T	    Configuration;      // Client type
  ASN1_CODER_INFO *pWorld;	        // Context for ASN.1 encode/decode

  /* context for subsystems */
  API_STRUCT_T      API;                // API subsystem substructure
  hSRINSTANCE       SendReceive;        // Send/Receive subsystem substructure
  Fsm_Struct_t      StateMachine;       // State Machine subsystem substructure

  TimerList_T      *pTimerList;         // Linked list of running timeout timers
  char              fDelete;            // TRUE to delete instance
  char              LockCount;          // Nested critical section count
  char              bMasterSlaveKludge; // TRUE if remote is same version
  char              bReserved;
};

struct InstanceStruct * InstanceCreate(DWORD dwPhysId, H245_CONFIG_T Configuration);
struct InstanceStruct * InstanceLock(H245_INST_T dwInst);
int InstanceUnlock(struct InstanceStruct *pInstance);
int InstanceDelete(struct InstanceStruct *pInstance);
int InstanceUnlock_ProcessDetach(struct InstanceStruct *pInstance, BOOL fProcessDetach);

BOOL H245SysInit();
VOID H245SysDeInit();
#endif /* _H245COM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245deb.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				   
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245deb.c  $						
 *  $Revision:   1.5  $							
 *  $Modtime:   14 Oct 1996 13:25:50  $					
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245deb.c_v  $	
 * 
 *    Rev 1.5   14 Oct 1996 14:01:32   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.4   14 Oct 1996 12:08:08   EHOWARDX
 * Backed out Mike's changes.
 * 
 *    Rev 1.3   01 Oct 1996 11:05:54   MANDREWS
 * Removed ISR_ trace statements for operation under Windows NT.
 * 
 *    Rev 1.2   01 Jul 1996 16:13:34   EHOWARDX
 * Changed to use wvsprintf to stop bounds checker from complaining
 * about too many arguements.
 * 
 *    Rev 1.1   28 May 1996 14:25:46   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:20   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.12.1.3   09 May 1996 19:40:10   EHOWARDX
 * Changed trace to append linefeeds so trace string need not include them.
 * 
 *    Rev 1.13   29 Apr 1996 12:54:48   EHOWARDX
 * Added timestamps and instance-specific short name.
 * 
 *    Rev 1.12.1.2   25 Apr 1996 20:05:08   EHOWARDX
 * Changed mapping between H.245 trace level and ISRDBG32 trace level.
 * 
 *    Rev 1.12.1.1   15 Apr 1996 15:16:16   unknown
 * Updated.
 * 
 *    Rev 1.12.1.0   02 Apr 1996 15:34:02   EHOWARDX
 * Changed to use ISRDBG32 if not _IA_SPOX_.
 * 
 *    Rev 1.12   01 Apr 1996 08:47:30   cjutzi
 * 
 * - fixed NDEBUG build problem
 * 
 *    Rev 1.11   18 Mar 1996 14:59:00   cjutzi
 * 
 * - fixed and verified ring zero tracking.. 
 * 
 *    Rev 1.10   18 Mar 1996 13:40:32   cjutzi
 * - fixed spox trace
 * 
 *    Rev 1.9   15 Mar 1996 16:07:44   DABROWN1
 * 
 * SYS_printf format changes
 * 
 *    Rev 1.8   13 Mar 1996 14:09:08   cjutzi
 * 
 * - added ASSERT Printout to the trace when it occurs.. 
 * 
 *    Rev 1.7   13 Mar 1996 09:46:00   dabrown1
 * 
 * modified Sys__printf to SYS_printf for Ring0
 * 
 *    Rev 1.6   11 Mar 1996 14:27:46   cjutzi
 * 
 * - addes sys_printf for SPOX 
 * - removed oildebug et.al..
 * 
 *    Rev 1.5   06 Mar 1996 12:10:40   cjutzi
 * - put ifndef SPOX around check_pdu, and dump_pdu..
 * 
 *    Rev 1.4   05 Mar 1996 16:49:46   cjutzi
 * - removed check_pdu from dump_pdu
 * 
 *    Rev 1.3   29 Feb 1996 08:22:04   cjutzi
 * - added pdu check constraints.. and (start but not complete.. )
 *   pdu tracing.. (tbd when Init includes print function )
 * 
 *    Rev 1.2   21 Feb 1996 12:14:20   EHOWARDX
 * 
 * Changed TraceLevel to DWORD.
 * 
 *    Rev 1.1   15 Feb 1996 14:42:20   cjutzi
 * - fixed the inst/Trace stuff.. 
 * 
 *    Rev 1.0   13 Feb 1996 15:00:42   DABROWN1
 * Initial revision.
 * 
 *    Rev 1.4   09 Feb 1996 15:45:08   cjutzi
 * - added h245trace
 * - added h245Assert
 *  $Ident$
 *
 *****************************************************************************/
#undef UNICODE
#ifndef STRICT 
#define STRICT 
#endif 

#include "precomp.h"

#include "h245asn1.h"
#include "isrg.h"
#include "h245com.h"

DWORD TraceLevel = 9;

#ifdef _DEBUG

/*****************************************************************************
 *									      
 * TYPE:	Global System
 *									      
 * PROCEDURE: 	H245TRACE 
 *
 * DESCRIPTION:	
 *
 *		Trace function for H245
 *		
 *		INPUT:
 *			inst   - dwInst
 *			level  - qualify trace level
 *			format - printf/sprintf string format 1-N parameters
 *
 * 			Trace Level Definitions:
 * 
 *			0 - no trace on at all
 *			1 - only errors
 *			2 - PDU tracking
 *			3 - PDU and SendReceive packet tracing
 *			4 - Main API Module level tracing
 *			5 - Inter Module level tracing #1
 *			6 - Inter Module level tracing #2
 *			7 - <Undefined>
 *			8 - <Undefined>
 *			9 - <Undefined>
 *			10- and above.. free for all, you call .. i'll haul
 *
 * RETURN:								      
 *		N/A
 *									      
 *****************************************************************************/

#if !defined(NDEBUG)
void H245TRACE (DWORD dwInst, DWORD dwLevel, LPSTR pszFormat, ...)
{
   char                 szBuffer[256];

#ifdef _IA_SPOX_
   /* Use SPOX printf */
   va_list              pParams;

  if (dwLevel <= TraceLevel)
    {
      va_start( pParams, pszFormat );
      SYS_vsprintf(szBuffer, pszFormat, pParams);

      switch (dwLevel)
      {
      case 0:
        SYS_printf("[ H245-%1d: MESSAGE ] %s\n",dwInst,szBuffer); 
        break;

      case 1:
        SYS_printf("[ H245-%1d: ERROR   ] %s\n",dwInst,szBuffer); 
        break;

      default:
        SYS_printf("[ H245-%1d: MSG-%02d  ] %s\n",dwInst,dwLevel,szBuffer); 
    }
#else
   va_list              pParams;
   BYTE                 byLevel;
   static WORD          wIsrInst = 0xFFFF;
   char                 szName[] = "H.245-1";

   /* Use ISRDBG32 output */

   if (dwLevel <= TraceLevel)
   {
      switch (dwLevel)
      {
      case 0:
         byLevel = kISRNotify;
         break;

      case 1:
         byLevel = kISRCritical;
         break;

      default:
         byLevel = kISRTrace;
      } // switch

      if (wIsrInst == 0xFFFF)
      {
	      UINT        hMod;
	      ptISRModule	pMod;

	      for (hMod = 0; hMod < kMaxModules; ++hMod)
	      {
		      pMod = ISR_GetModule(hMod);
		      if (pMod)
            {
		         if (memcmp(szName, pMod->zSName, sizeof(szName)) == 0)
		         {
                  szName[6] += 1;
               }
		      }
	      }
         ISR_RegisterModule(&wIsrInst, szName, szName);
      }
      wsprintf(szBuffer, "%9d:", GetTickCount());
      va_start( pParams, pszFormat );
      wvsprintf(&szBuffer[10], pszFormat, pParams);
      ISR_HookDbgStr((UINT)dwInst, wIsrInst, byLevel, szBuffer, 0);
   }
#endif
} // H245TRACE()

#endif //  && !defined(NDEBUG)
/*****************************************************************************
 *									      
 * TYPE:	Global System
 *									      
 * PROCEDURE: 	H245Assert
 *
 * DESCRIPTION:	
 *	
 *		H245Assert that will only pop up a dialog box, does not
 *		stop system with fault.
 *
 *		FOR WINDOWS ONLY (Ring3 development) at this point
 *
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/


void H245Panic (LPSTR file, int line)
{
#if !defined(SPOX) && defined(H324)
  int i;

  char Buffer[256];

  for (
       i=strlen(file);
       ((i) && (file[i] != '\\'));
       i--);
       wsprintf(Buffer,"file:%s line:%d",&file[i],line);
  MessageBox(GetTopWindow(NULL), Buffer, "H245 PANIC", MB_OK);
#endif
  H245TRACE(0,1,"<<< PANIC >>> file:%s line:%d",file,line);
}

/*****************************************************************************
 *									      
 * TYPE:	GLOBAL
 *									      
 * PROCEDURE: 	check_pdu
 *
 * DESCRIPTION:	
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/
int check_pdu (struct InstanceStruct *pInstance, MltmdSystmCntrlMssg *p_pdu)
{
  int error = H245_ERROR_OK;
#if 0 // legacy
#ifndef SPOX

  if (pInstance->pWorld) 
    {
      error = ossCheckConstraints(pInstance->pWorld, 1,(void *) p_pdu);

      switch (error)
	{
	case 0:
	  break;
	case  14: 
	  H245TRACE(0,1,"<<PDU ERROR>> - User constraint function returned error");
	  break;
	case  15: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a signed integer");
	  break;
	case  16: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for an unsigned integer");         
	  break;
	case  17: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a floating point number");     
	  break;
	case  18: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a string");                    
	  break;
	case  19: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a complex type");              
	  break;
	case  20: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value range constraint violated  for a signed integer");            
	  break;
	case  21: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value range constraint violated  for an unsigned integer");         
	  break;
	case  22: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value range constraint violated  for a floating point number");     
	  break;
	case  23: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Size constraint violated for a string");                    
	  break;
	case  24: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Size constraint violated for a SET OF/SEQUENCE OF");        
	  break;
	case  25: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Permitted alphabet constraint violated");                           
	  break;
	case  26: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Absence constraint violated");                                      
	  break;
	case  27: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Presence constraint violated");                                     
	  break;
	case  28: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Error in encoding an open type");                                   
	  break;
	case  29: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Table constraint violated");                                        
	  break;
	case  30: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Component relation constraint violated");                           
	  break;
	case  31: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value not among the ENUMERATED");                                   
	  break;
	case  36: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Type constraint violated");                                         
	  break;
	case  50: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Unexpected NULL pointer in input");                                 
	  break;
	default:
	  H245TRACE(0,1,"<<PDU ERROR>> - ***UNKNOWN ***");
	  break;

	} /* switch */

    } /* if */
#endif
#endif // 0
  return error;
}

#if 0
/*****************************************************************************
 *									      
 * TYPE:	GLOBAL
 *									      
 * PROCEDURE: 	dump_pdu
 *
 * DESCRIPTION:	
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/
void dump_pdu (struct InstanceStruct *pInstance, MltmdSystmCntrlMssg 	*p_pdu)
{
#ifndef SPOX
  if (pInstance->pWorld)
    {
      ossPrintPDU (pInstance->pWorld, 1, p_pdu);
    }
#endif
}
#endif // NEVER

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245fsm.h ===
/***********************************************************************
 *                                                                     *
 * Filename: h245fsm.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   H245FSM.H  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/H245FSM.H_v  $
 *
 *    Rev 1.6   09 Dec 1996 13:40:52   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.5   29 Jul 1996 16:57:14   EHOWARDX
 * Added H.223 Annex A Reconfiguration events.
 *
 *    Rev 1.4   01 Jul 1996 22:08:32   EHOWARDX
 *
 * Updated stateless events.
 *
 *    Rev 1.3   30 May 1996 23:38:20   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.2   29 May 1996 15:21:34   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.1   28 May 1996 14:10:04   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:04:50   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.12.1.3   09 May 1996 19:43:58   EHOWARDX
 * Eliminated two events for B-LCSE gratuitous state and changed
 * 2 macros.
 *
 *    Rev 1.12.1.2   15 Apr 1996 10:43:34   EHOWARDX
 * Update.
 *
 *    Rev 1.12.1.1   10 Apr 1996 21:06:10   EHOWARDX
 * Added 5 new state entitys.
 *
 *    Rev 1.12.1.0   05 Apr 1996 11:47:14   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#ifndef H245FSM_H
#define H245FSM_H

#include <stdlib.h>
#include "fsmexpor.h"
#include "sr_api.h"

#define MAXSTATES  4

#define SUCCESS 0
#define FAIL   -1

#define BAD                 (Output_t) -1
#ifdef IGNORE
#undef IGNORE
#endif
#define IGNORE              (Output_t) NUM_OUTPUTS

typedef MltmdSystmCntrlMssg PDU_t;



// Signalling Entity definitions
typedef unsigned char Entity_t;

// Per-channel Signalling Entities
#define LCSE_OUT    (Entity_t) 0 // Uni-directional Logical Channel signalling Signalling Entity - Out-going
#define LCSE_IN     (Entity_t) 1 // Uni-directional Logical Channel signalling Signalling Entity - In-coming
#define BLCSE_OUT   (Entity_t) 2 // Bi-directional  Logical Channel signalling Signalling Entity - Out-going
#define BLCSE_IN    (Entity_t) 3 // Bi-directional  Logical Channel signalling Signalling Entity - In-coming
#define CLCSE_OUT   (Entity_t) 4 // Close           Logical Channel signalling Signalling Entity - Out-going
#define CLCSE_IN    (Entity_t) 5 // Close           Logical Channel signalling Signalling Entity - In-coming

// Per H.245 Instance Signalling Entities
#define CESE_OUT    (Entity_t) 6 // Capability Exchange Signalling Entity - Out-going
#define CESE_IN     (Entity_t) 7 // Capability Exchange Signalling Entity - In-coming
#define MTSE_OUT    (Entity_t) 8 // Multiplex Table Signalling Entity - Out-going
#define MTSE_IN     (Entity_t) 9 // Multiplex Table Signalling Entity - In-coming
#define RMESE_OUT   (Entity_t)10 // Request Multiplex Entry Signalling Entity - Out-going
#define RMESE_IN    (Entity_t)11 // Request Multiplex Entry Signalling Entity - In-coming
#define MRSE_OUT    (Entity_t)12 // Mode Request Signalling Entity - Out-going
#define MRSE_IN     (Entity_t)13 // Mode Request Signalling Entity - In-coming
#define MLSE_OUT    (Entity_t)14 // Maintenance Loop Signalling Entity - Out-going
#define MLSE_IN     (Entity_t)15 // Maintenance Loop Signalling Entity - In-coming
#define MSDSE       (Entity_t)16 // Master Slave Determination Signalling Entity
#define RTDSE       (Entity_t)17 // Round Trip Delay Signalling Entity
#define STATELESS   (Entity_t)18 // No state machine associated with PDU

#define NUM_ENTITYS           19



// Event definitions
typedef unsigned int Event_t;

// Out-going Uni-directional Logical Channel (LCSE_OUT) events
#define ReqUEstablish                   (Event_t)  0
#define OpenUChAckPDU                   (Event_t)  1
#define OpenUChRejectPDU                (Event_t)  2
#define CloseUChAckPDU                  (Event_t)  3
#define ReqURelease                     (Event_t)  4
#define T103Expiry                      (Event_t)  5

// In-coming Uni-directional Logical Channel (LCSE_IN) events
#define OpenUChPDU                      (Event_t)  6
#define CloseUChPDU                     (Event_t)  7
#define ResponseUEstablish              (Event_t)  8
#define EstablishUReject                (Event_t)  9

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
#define ReqBEstablish                   (Event_t) 10
#define OpenBChAckPDU                   (Event_t) 11
#define OpenBChRejectPDU                (Event_t) 12
#define CloseBChAckPDU                  (Event_t) 13
#define ReqClsBLCSE                     (Event_t) 14
#define RspConfirmBLCSE                 (Event_t) 15
#define T103OutExpiry                   (Event_t) 16

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
#define OpenBChPDU                      (Event_t) 17
#define CloseBChPDU                     (Event_t) 18
#define ResponseBEstablish              (Event_t) 19
#define OpenBChConfirmPDU               (Event_t) 20
#define OpenRejectBLCSE                 (Event_t) 21
#define T103InExpiry                    (Event_t) 22

// Out-going Request Close Logical Channel (CLCSE_OUT) events
#define ReqClose                        (Event_t) 23
#define ReqChCloseAckPDU                (Event_t) 24
#define ReqChCloseRejectPDU             (Event_t) 25
#define T108Expiry                      (Event_t) 26

// In-coming Request Close Logical Channel (CLCSE_IN) events
#define ReqChClosePDU                   (Event_t) 27
#define ReqChCloseReleasePDU            (Event_t) 28
#define CLCSE_CLOSE_response            (Event_t) 29
#define CLCSE_REJECT_request            (Event_t) 30

// Out-going Terminal Capablity Exchange (CESE_OUT) events
#define TransferCapRequest              (Event_t) 31
#define TermCapSetAckPDU                (Event_t) 32
#define TermCapSetRejectPDU             (Event_t) 33
#define T101Expiry                      (Event_t) 34

// In-coming Terminal Capablity Exchange (CESE_IN) events
#define TermCapSetPDU                   (Event_t) 35
#define TermCapSetReleasePDU            (Event_t) 36
#define CESE_TRANSFER_response          (Event_t) 37
#define CESE_REJECT_request             (Event_t) 38

// Out-going Multiplex Table (MTSE_OUT) events
#define MTSE_TRANSFER_request           (Event_t) 39
#define MultiplexEntrySendAckPDU        (Event_t) 40
#define MultiplexEntrySendRejectPDU     (Event_t) 41
#define T104Expiry                      (Event_t) 42

// In-coming Multiplex Table (MTSE_IN) events
#define MultiplexEntrySendPDU           (Event_t) 43
#define MultiplexEntrySendReleasePDU    (Event_t) 44
#define MTSE_TRANSFER_response          (Event_t) 45
#define MTSE_REJECT_request             (Event_t) 46

// Out-going Request Multiplex Entry (RMESE_OUT) events
#define RMESE_SEND_request              (Event_t) 47
#define RequestMultiplexEntryAckPDU     (Event_t) 48
#define RequestMultiplexEntryRejectPDU  (Event_t) 49
#define T107Expiry                      (Event_t) 50

// In-coming Request Multiplex Entry (RMESE_IN) events
#define RequestMultiplexEntryPDU        (Event_t) 51
#define RequestMultiplexEntryReleasePDU (Event_t) 52
#define RMESE_SEND_response             (Event_t) 53
#define RMESE_REJECT_request            (Event_t) 54

// Out-going Mode Request (MRSE_OUT) events
#define MRSE_TRANSFER_request           (Event_t) 55
#define RequestModeAckPDU               (Event_t) 56
#define RequestModeRejectPDU            (Event_t) 57
#define T109Expiry                      (Event_t) 58

// In-coming Mode Request (MRSE_IN) events
#define RequestModePDU                  (Event_t) 59
#define RequestModeReleasePDU           (Event_t) 60
#define MRSE_TRANSFER_response          (Event_t) 61
#define MRSE_REJECT_request             (Event_t) 62

// Out-going Maintenance Loop (MLSE_OUT) events
#define MLSE_LOOP_request               (Event_t) 63
#define MLSE_OUT_RELEASE_request        (Event_t) 64
#define MaintenanceLoopAckPDU           (Event_t) 65
#define MaintenanceLoopRejectPDU        (Event_t) 66
#define T102Expiry                      (Event_t) 67

// In-coming Maintenance Loop (MLSE_IN) events
#define MaintenanceLoopRequestPDU       (Event_t) 68
#define MaintenanceLoopOffCommandPDU    (Event_t) 69
#define MLSE_LOOP_response              (Event_t) 70
#define MLSE_IN_RELEASE_request         (Event_t) 71

// Master Slave Determination (MSDSE) events
#define MSDetReq                        (Event_t) 72
#define MSDetPDU                        (Event_t) 73
#define MSDetAckPDU                     (Event_t) 74
#define MSDetRejectPDU                  (Event_t) 75
#define MSDetReleasePDU                 (Event_t) 76
#define T106Expiry                      (Event_t) 77

// Round Trip Delay Delay (RTDSE) events
#define RTDSE_TRANSFER_request          (Event_t) 78
#define RoundTripDelayRequestPDU        (Event_t) 79
#define RoundTripDelayResponsePDU       (Event_t) 80
#define T105Expiry                      (Event_t) 81

#define NUM_STATE_EVENTS                          82

// Events with no associated state entity
#define NonStandardRequestPDU           (Event_t) 82
#define NonStandardResponsePDU          (Event_t) 83
#define NonStandardCommandPDU           (Event_t) 84
#define NonStandardIndicationPDU        (Event_t) 85
#define MiscellaneousCommandPDU         (Event_t) 86
#define MiscellaneousIndicationPDU      (Event_t) 87
#define CommunicationModeRequestPDU     (Event_t) 88
#define CommunicationModeResponsePDU    (Event_t) 89
#define CommunicationModeCommandPDU     (Event_t) 90
#define ConferenceRequestPDU            (Event_t) 91
#define ConferenceResponsePDU           (Event_t) 92
#define ConferenceCommandPDU            (Event_t) 93
#define ConferenceIndicationPDU         (Event_t) 94
#define SendTerminalCapabilitySetPDU    (Event_t) 95
#define EncryptionCommandPDU            (Event_t) 96
#define FlowControlCommandPDU           (Event_t) 97
#define EndSessionCommandPDU            (Event_t) 98
#define FunctionNotUnderstoodPDU        (Event_t) 99
#define JitterIndicationPDU             (Event_t)100
#define H223SkewIndicationPDU           (Event_t)101
#define NewATMVCIndicationPDU           (Event_t)102
#define UserInputIndicationPDU          (Event_t)103
#define H2250MaximumSkewIndicationPDU   (Event_t)104
#define MCLocationIndicationPDU         (Event_t)105
#define VendorIdentificationPDU         (Event_t) 106
#define FunctionNotSupportedPDU         (Event_t) 107
#define H223ReconfigPDU                 (Event_t)108
#define H223ReconfigAckPDU              (Event_t)109
#define H223ReconfigRejectPDU           (Event_t)110

#define NUM_EVENTS                               111



// Output function definitions
typedef unsigned char Output_t;

// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
#define EstablishReleased               (Output_t)  0
#define OpenAckAwaitingE                (Output_t)  1
#define OpenRejAwaitingE                (Output_t)  2
#define ReleaseAwaitingE                (Output_t)  3
#define T103AwaitingE                   (Output_t)  4
#define ReleaseEstablished              (Output_t)  5
#define OpenRejEstablished              (Output_t)  6
#define CloseAckEstablished             (Output_t)  7
#define CloseAckAwaitingR               (Output_t)  8
#define OpenRejAwaitingR                (Output_t)  9
#define T103AwaitingR                   (Output_t) 10
#define EstablishAwaitingR              (Output_t) 11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
#define OpenReleased                    (Output_t) 12
#define CloseReleased                   (Output_t) 13
#define ResponseAwaiting                (Output_t) 14
#define ReleaseAwaiting                 (Output_t) 15
#define CloseAwaiting                   (Output_t) 16
#define OpenAwaiting                    (Output_t) 17
#define CloseEstablished                (Output_t) 18
#define OpenEstablished                 (Output_t) 19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
#define EstablishReqBReleased           (Output_t) 20
#define OpenChannelAckBAwaitingE        (Output_t) 21
#define OpenChannelRejBAwaitingE        (Output_t) 22
#define ReleaseReqBOutAwaitingE         (Output_t) 23
#define T103ExpiryBAwaitingE            (Output_t) 24
#define ReleaseReqBEstablished          (Output_t) 25
#define OpenChannelRejBEstablished      (Output_t) 26
#define CloseChannelAckBEstablished     (Output_t) 27
#define CloseChannelAckAwaitingR        (Output_t) 28
#define OpenChannelRejBAwaitingR        (Output_t) 29
#define T103ExpiryBAwaitingR            (Output_t) 30
#define EstablishReqAwaitingR           (Output_t) 31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
#define OpenChannelBReleased            (Output_t) 32
#define CloseChannelBReleased           (Output_t) 33
#define EstablishResBAwaitingE          (Output_t) 34
#define ReleaseReqBInAwaitingE          (Output_t) 35
#define CloseChannelBAwaitingE          (Output_t) 36
#define OpenChannelBAwaitingE           (Output_t) 37
#define OpenChannelConfirmBAwaitingE    (Output_t) 38
#define T103ExpiryBAwaitingC            (Output_t) 39
#define OpenChannelConfirmBAwaitingC    (Output_t) 40
#define CloseChannelBAwaitingC          (Output_t) 41
#define OpenChannelBAwaitingC           (Output_t) 42
#define CloseChannelBEstablished        (Output_t) 43
#define OpenChannelBEstablished         (Output_t) 44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
#define CloseRequestIdle                (Output_t) 45
#define RequestCloseAckAwaitingR        (Output_t) 46
#define RequestCloseRejAwaitingR        (Output_t) 47
#define T108ExpiryAwaitingR             (Output_t) 48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
#define RequestCloseIdle                (Output_t) 49
#define CloseResponseAwaitingR          (Output_t) 50
#define RejectRequestAwaitingR          (Output_t) 51
#define RequestCloseReleaseAwaitingR    (Output_t) 52
#define RequestCloseAwaitingR           (Output_t) 53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
#define RequestCapIdle                  (Output_t) 54
#define TermCapAckAwaiting              (Output_t) 55
#define TermCapRejAwaiting              (Output_t) 56
#define T101ExpiryAwaiting              (Output_t) 57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
#define TermCapSetIdle                  (Output_t) 58
#define ResponseCapAwaiting             (Output_t) 59
#define RejectCapAwaiting               (Output_t) 60
#define TermCapReleaseAwaiting          (Output_t) 61
#define TermCapSetAwaiting              (Output_t) 62

// Out-going Multiplex Table (MTSE_OUT) state functions
#define MTSE0_TRANSFER_request          (Output_t) 63
#define MTSE1_TRANSFER_request          (Output_t) 64
#define MTSE1_MultiplexEntrySendAck     (Output_t) 65
#define MTSE1_MultiplexEntrySendRej     (Output_t) 66
#define MTSE1_T104Expiry                (Output_t) 67

// In-coming Multiplex Table (MTSE_IN) state functions
#define MTSE0_MultiplexEntrySend        (Output_t) 68
#define MTSE1_MultiplexEntrySend        (Output_t) 69
#define MTSE1_MultiplexEntrySendRelease (Output_t) 70
#define MTSE1_TRANSFER_response         (Output_t) 71
#define MTSE1_REJECT_request            (Output_t) 72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
#define RMESE0_SEND_request             (Output_t) 73
#define RMESE1_SEND_request             (Output_t) 74
#define RMESE1_RequestMuxEntryAck       (Output_t) 75
#define RMESE1_RequestMuxEntryRej       (Output_t) 76
#define RMESE1_T107Expiry               (Output_t) 77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
#define RMESE0_RequestMuxEntry          (Output_t) 78
#define RMESE1_RequestMuxEntry          (Output_t) 79
#define RMESE1_RequestMuxEntryRelease   (Output_t) 80
#define RMESE1_SEND_response            (Output_t) 81
#define RMESE1_REJECT_request           (Output_t) 82

// Out-going Request Mode (MRSE_OUT) state functions
#define MRSE0_TRANSFER_request          (Output_t) 83
#define MRSE1_TRANSFER_request          (Output_t) 84
#define MRSE1_RequestModeAck            (Output_t) 85
#define MRSE1_RequestModeRej            (Output_t) 86
#define MRSE1_T109Expiry                (Output_t) 87

// In-coming Request Mode (MRSE_OUT) state functions
#define MRSE0_RequestMode               (Output_t) 88
#define MRSE1_RequestMode               (Output_t) 89
#define MRSE1_RequestModeRelease        (Output_t) 90
#define MRSE1_TRANSFER_response         (Output_t) 91
#define MRSE1_REJECT_request            (Output_t) 92

// Out-going Request Mode (MLSE_OUT) state functions
#define MLSE0_LOOP_request              (Output_t) 93
#define MLSE1_MaintenanceLoopAck        (Output_t) 94
#define MLSE1_MaintenanceLoopRej        (Output_t) 95
#define MLSE1_OUT_RELEASE_request       (Output_t) 96
#define MLSE1_T102Expiry                (Output_t) 97
#define MLSE2_MaintenanceLoopRej        (Output_t) 98
#define MLSE2_OUT_RELEASE_request       (Output_t) 99

// In-coming Request Mode (MLSE_IN) state functions
#define MLSE0_MaintenanceLoopRequest    (Output_t)100
#define MLSE1_MaintenanceLoopRequest    (Output_t)101
#define MLSE1_MaintenanceLoopOffCommand (Output_t)102
#define MLSE1_LOOP_response             (Output_t)103
#define MLSE1_IN_RELEASE_request        (Output_t)104
#define MLSE2_MaintenanceLoopRequest    (Output_t)105
#define MLSE2_MaintenanceLoopOffCommand (Output_t)106

// Master Slave Determination (MSDSE) state functions
#define DetRequestIdle                  (Output_t)107
#define MSDetIdle                       (Output_t)108
#define MSDetAckOutgoing                (Output_t)109
#define MSDetOutgoing                   (Output_t)110
#define MSDetRejOutgoing                (Output_t)111
#define MSDetReleaseOutgoing            (Output_t)112
#define T106ExpiryOutgoing              (Output_t)113
#define MSDetAckIncoming                (Output_t)114
#define MSDetIncoming                   (Output_t)115
#define MSDetRejIncoming                (Output_t)116
#define MSDetReleaseIncoming            (Output_t)117
#define T106ExpiryIncoming              (Output_t)118

// Round Trip Delay (RTDSE) state functions
#define RTDSE0_TRANSFER_request         (Output_t)119
#define RTDSE0_RoundTripDelayRequest    (Output_t)120
#define RTDSE1_TRANSFER_request         (Output_t)121
#define RTDSE1_RoundTripDelayRequest    (Output_t)122
#define RTDSE1_RoundTripDelayResponse   (Output_t)123
#define RTDSE1_T105Expiry               (Output_t)124

#define NUM_OUTPUTS                               125



// State definitions
typedef unsigned char State_t;



// Lookup Key definition
typedef unsigned long Key_t;



typedef enum
{
    INDETERMINATE,
    MASTER,
    SLAVE
} MS_Status_t;

typedef struct Object_tag
{
    struct Object_tag *pNext;           // Linked list pointer
    struct InstanceStruct *pInstance;   // H.245 instance structure pointer
    DWORD           dwInst;             // H.245 instance identifier
    unsigned int    uNestLevel;         // StateMachine recursive calls
    DWORD_PTR       dwTransId;          // Transaction Id from API
    DWORD_PTR       dwTimerId;          // Associated timer id
    Key_t           Key;                // Lookup key, e.g. channel number
    Entity_t        Entity;             // State Entity type, e.g. LCSE_OUT
    State_t         State;              // Current Entity state
    unsigned char   byInSequence;       // In-coming sequence number
    union
    {
        struct
        {
            unsigned short  wLoopType;
        } mlse;
        struct
        {
            unsigned int    sv_SDNUM;
            unsigned int    sv_NCOUNT;
        } msdse;
        MultiplexEntrySendRelease       mtse;
        RequestMultiplexEntryRelease    rmese;
    } u;                                // Entity-specific data
} Object_t;



/*  an instance will carry a table of object pointers     */
/*  to be allocated in fsminit by calloc.                 */
/*  Each dwInst passed from API or SRP should invoke the  */
/*  appropriate instance that contain the object table of */
/*  the protocol entities for this H.245 instance       */

typedef struct Fsm_Struct_tag
{
    Object_t *          Object_tbl[NUM_ENTITYS];// H.245 Signalling Entities
    DWORD               dwInst;                 // H.245 Instance Identifier
    MS_Status_t         sv_STATUS;              // MSDSE Status
    unsigned char       sv_TT;                  // MSDSE Terminal Type
    unsigned char       byCeseOutSequence;      // CESE_OUT sequence number
    unsigned char       byMtseOutSequence;      // MTSE_OUT sequence number
    unsigned char       byMrseOutSequence;      // MRSE_OUT sequence number
    unsigned char       byRtdseSequence;        // RTDSE sequence number
} Fsm_Struct_t;



/* FSM function prototypes */

HRESULT
PduParseOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu,
               Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate);

HRESULT
PduParseIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu,
               Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate);

int
ObjectDestroy    (Object_t *pObject);

Object_t *
ObjectFind(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key);

HRESULT
StateMachine     (Object_t *pObject, PDU_t *pPdu, Event_t Event);

HRESULT
FsmTimerEvent(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, Object_t *pObject, Event_t Event);

#define FsmStartTimer(pObject,pfnCallback,uTicks) \
    {ASSERT((pObject)->dwTimerId == 0);       \
     (pObject)->dwTimerId=H245StartTimer((pObject)->pInstance,pObject,pfnCallback,uTicks);}

#define FsmStopTimer(pObject) \
    {H245StopTimer((pObject)->pInstance,(pObject)->dwTimerId); (pObject)->dwTimerId = 0;}

#endif // H245FSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245man.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/h245man.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.13  $
 *	$Date:   Aug 27 1996 11:07:30  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitH245Manager();

HRESULT DeInitH245Manager();

HRESULT MakeH245PhysicalID(			DWORD					*pdwH245PhysicalID);

HRESULT H245Callback(				H245_CONF_IND_T			*pH245ConfIndData,
									void					*pMisc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245main.c ===
//---------------------------------------------------------------------------
//  File:  H245Main.C
//
//  This file contains the DLL's entry and exit points.
//
// INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//---------------------------------------------------------------------------

#ifndef STRICT 
#define STRICT 
#endif

#include "precomp.h"


#define H245DLL_EXPORT
#include "h245com.h"

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
LPInteropLogger H245Logger = NULL;
#endif  // (PCS_COMPLIANCE)

extern CRITICAL_SECTION         TimerLock;
extern CRITICAL_SECTION         InstanceCreateLock;
extern CRITICAL_SECTION         InstanceLocks[MAXINST];
extern struct InstanceStruct *  InstanceTable[MAXINST];

BOOL H245SysInit()
{
    register unsigned int           uIndex;

    /* initialize memory resources */
    H245TRACE(0, 0, "***** Loading H.245 DLL %s - %s",  
              __DATE__, __TIME__);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    H245Logger = InteropLoad(H245LOG_PROTOCOL);
#endif  // (PCS_COMPLIANCE)
    InitializeCriticalSection(&TimerLock);
    InitializeCriticalSection(&InstanceCreateLock);
    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      InitializeCriticalSection(&InstanceLocks[uIndex]);
    }
    return TRUE;
}
VOID H245SysDeInit()
{
    register unsigned int           uIndex;
    H245TRACE(0, 0, "***** Unloading H.245 DLL");

    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      if (InstanceTable[uIndex])
      {
        register struct InstanceStruct *pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          H245TRACE(uIndex+1,0,"DLLMain: Calling H245ShutDown");
          H245ShutDown(uIndex + 1);
		  InstanceUnlock_ProcessDetach(pInstance,TRUE);
        }
      }
      ASSERT(InstanceTable[uIndex] == NULL);
      DeleteCriticalSection(&InstanceLocks[uIndex]);
    }
    DeleteCriticalSection(&InstanceCreateLock);
    DeleteCriticalSection(&TimerLock);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    if (H245Logger)
    {
      H245TRACE(0, 4, "Unloading interop logger");
      InteropUnload(H245Logger);
      H245Logger = NULL;
    }
#endif  // (PCS_COMPLIANCE)
}
#if(0)
//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
//	Inputs:
//    			hInstDll	: DLL instance.
//    			fdwReason	: Reason the main function is called.
//    			lpReserved	: Reserved.
//
//	Return: 	TRUE		: OK
//			FALSE		: Error, DLL won't load
//---------------------------------------------------------------------------
BOOL WINAPI DllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
  extern CRITICAL_SECTION         TimerLock;
  extern CRITICAL_SECTION         InstanceCreateLock;
  extern CRITICAL_SECTION         InstanceLocks[MAXINST];
  extern struct InstanceStruct *  InstanceTable[MAXINST];
  register unsigned int           uIndex;

  switch (fdwReason)
  {
  case DLL_PROCESS_ATTACH:
    DBG_INIT_MEMORY_TRACKING(hInstDll);

    /* initialize memory resources */
    H245TRACE(0, 0, "***** Loading H.245 DLL %s - %s",  
              __DATE__, __TIME__);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    H245Logger = InteropLoad(H245LOG_PROTOCOL);
#endif  // (PCS_COMPLIANCE)
    InitializeCriticalSection(&TimerLock);
    InitializeCriticalSection(&InstanceCreateLock);
    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      InitializeCriticalSection(&InstanceLocks[uIndex]);
    }
   break;

  case DLL_PROCESS_DETACH:
    /* release memory resources */
    H245TRACE(0, 0, "***** Unloading H.245 DLL");
    H245TRACE(0, 0, "***** fProcessDetach = TRUE");

    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      if (InstanceTable[uIndex])
      {
        register struct InstanceStruct *pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          H245TRACE(uIndex+1,0,"DLLMain: Calling H245ShutDown");
          H245ShutDown(uIndex + 1);
		  InstanceUnlock_ProcessDetach(pInstance,TRUE);
        }
      }
      ASSERT(InstanceTable[uIndex] == NULL);
      DeleteCriticalSection(&InstanceLocks[uIndex]);
    }
    DeleteCriticalSection(&InstanceCreateLock);
    DeleteCriticalSection(&TimerLock);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    if (H245Logger)
    {
      H245TRACE(0, 4, "Unloading interop logger");
      InteropUnload(H245Logger);
      H245Logger = NULL;
    }
#endif  // (PCS_COMPLIANCE)

    DBG_CHECK_MEMORY_TRACKING(hInstDll);
    break;
  }

  return TRUE;
}
#endif // if(0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245init.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				
 *									
 *   This listing is supplied under the terms of a license agreement	
 *   with INTEL Corporation and may not be used, copied, nor disclosed	
 *   except in accordance with the terms of that agreement.		
 *
 *****************************************************************************/

/******************************************************************************
 *									
 *  $Workfile:   h245init.c  $						
 *  $Revision:   1.2  $							
 *  $Modtime:   29 May 1996 13:12:46  $					
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245init.c_v  $	
 *
 *    Rev 1.2   29 May 1996 15:20:18   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.1   28 May 1996 14:25:40   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:22   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.16   09 May 1996 19:35:34   EHOWARDX
 * Added new locking logic and changed timer.
 *
 *    Rev 1.15   09 Apr 1996 15:53:36   dabrown1
 *
 * Added srflush.x for queue flush bitmap
 *
 *    Rev 1.14   05 Apr 1996 10:56:58   dabrown1
 * Asynchronous/Synchronous shutdown support
 *
 *    Rev 1.13   04 Apr 1996 18:17:06   dabrown1
 *
 * - changed parameter for DeInitTimer..
 *
 *    Rev 1.12   02 Apr 1996 15:00:12   dabrown1
 *
 * SendRcv EndSession asynchronous support
 *
 *    Rev 1.11   18 Mar 1996 12:36:28   cjutzi
 * - added timer init and de-init
 *
 *    Rev 1.10   13 Mar 1996 15:08:26   helgebax
 * added Fsm_shutdown(Instance) to clear FSM context
 *
 *    Rev 1.9   06 Mar 1996 13:10:42   DABROWN1
 * Flush send receive transmit buffers at system shutdown
 *
 *    Rev 1.8   28 Feb 1996 17:23:38   EHOWARDX
 * Added #include "fsmexpor.h" for Fsm_init prototype.
 *
 *    Rev 1.7   27 Feb 1996 13:41:56   DABROWN1
 * removed mal/h223 initialization code
 *
 *    Rev 1.6   26 Feb 1996 11:17:36   cjutzi
 * - moved api_deinit.. to EndSystemClose
 *
 *    Rev 1.5   21 Feb 1996 13:23:12   DABROWN1
 *
 * check return codes for SR and FSM on initialization
 *
 *    Rev 1.4   13 Feb 1996 14:48:50   DABROWN1
 *
 * Removed SPOX only include files from mainline path
 *
 *    Rev 1.3   09 Feb 1996 16:00:22   cjutzi
 *
 * - cleaned up the startup...
 * - added the mal and h223 startup to the configuration as was
 *   determined to be correct.. (still some issues with handles)
 *  $Ident$
 *
 *****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "sr_api.h"
//#include "h223api.h"
#include "fsmexpor.h"
#include "h245sys.x"

#if defined(H324)
/*****************************************************************************
 *									
 * Type:	LOCAL							
 *									
 * PROCEDURE: 	setup_from_H245_ini - setup using conmgr.ini file
 *									
 * DESCRIPTION:							      	
 *									
 *****************************************************************************/

static
void setup_from_H245_ini (int *p_dbg_lvl)
{
  char		*p_ini = "h245.ini";			
  char		*p_H245 ="H245";

  p_ini        	= "h245.ini";				
  p_H245       	= "H245";				

#ifdef OIL
  OIL_GetPrivateProfileInt(p_H245, "TraceLvl", 0, p_ini, p_dbg_lvl);
#else
  *p_dbg_lvl = GetPrivateProfileInt (p_H245, "TraceLvl", 0, p_ini);	
#endif
}
#endif  // (H324)

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSystemInitilize - Initialize Sub Systems
 *									
 * DESCRIPTION:							      	
 *
 *		This is called on entry to the H245_Init API Call
 *
 *
 *		This procedure initializes all the subsystems in H245. Errors
 *		must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSystemInit (struct InstanceStruct *pInstance)
{
  HRESULT lError;

  /* Timer Initialization */
//  H245InitTimer(pInstance);

  /* API Subsystem Initialization */
  lError = api_init(pInstance);
  if (lError != H245_ERROR_OK)
    return lError;

  /* Send Receive Subsystem Initialization */
  lError = sendRcvInit(pInstance);
  if (lError != H245_ERROR_OK)
    return lError;

  /* State Machine Subsystem Initialization */
  return Fsm_init(pInstance);
}

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	EndSystemInitilize - Initialize Sub Systems
 *									
 * DESCRIPTION:							      	
 *
 *		This is called on exit from H245 System Initialization
 *
 *
 *		This procedure initializes all the subsystems in H245. Errors
 *		must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSystemInit (struct InstanceStruct *pInstance)
{
  /* API Subsystem Initialization */

  // -- TBD

  /* Send Receive Subsystem Initialization */

  // -- TBD

  /* State Machine Subsystem Initialization */

  // -- TBD

  return H245_ERROR_OK;
}


/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_Shutdown occurs
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSystemClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Shutdown Initiation */

  // TBD

  /* Send Receive Shutdown Initiation */

  // TBD

  /* State Machine Shutdown Initiation */
  Fsm_shutdown(pInstance);

  return (H245_ERROR_OK);
}


/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_Shutdown completes asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSystemClose (struct InstanceStruct *pInstance)
{

  /* Send Receive Shutdown Completion */
  sendRcvShutdown(pInstance);

  /* API Subsystem Shutdown Completion */

  api_deinit(pInstance);

  /* State Machine Shutdown Completion */

  // -- TBD

  /* Timer Shutdown */
//  H245DeInitTimer(pInstance);

  return (H245_ERROR_OK);
}



/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionInit
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when an H245_BeginConnection is called.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSessionInit (struct InstanceStruct *pInstance)
{

  /* API Subsystem Initialization */


  /* Send Receive  Initialization */


  /* State Machine Initialization */


  return H245_ERROR_OK;
}

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	EndSessionInit
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when an H245_BeginConnection call is
 *		completed.. Asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSessionInit (struct InstanceStruct *pInstance)
{

  /* API Subsystem Initialization */


  /* Send Receive Initialization */


  /* Master Slave Initialization */


  return H245_ERROR_OK;
}

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_EndConnection occurs
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSessionClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Session Close */

  /* Send Receive Session Close */
  /* Dequeue any buffers posted in the data link transmit queue */
  if (sendRcvFlushPDUs(pInstance,
		       DATALINK_TRANSMIT,
		       TRUE))				{
    H245TRACE(pInstance->dwInst, 1, "Flush Buffer Failure");
  }

  /* State Machine Session Close */

  return H245_ERROR_OK;
}


/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	EndSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_EndConnection completes
 *		asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSessionClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Session Close */


  /* Send Receive  Session Close */


  /* State Machine Session Close */

  return H245_ERROR_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245pdu.c ===
/******************************************************************************
 *
 *  File:  h245send.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245asn.c  $
 *  $Revision:   1.4  $
 *  $Modtime:   17 Jan 1997 14:31:20  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\h245asn.c_v  $
 *
 *    Rev 1.2   28 May 1996 14:25:22   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   21 May 1996 13:39:28   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.0   09 May 1996 21:06:20   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.5.1.2   09 May 1996 19:34:44   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.5.1.0   23 Apr 1996 14:42:44   EHOWARDX
 * Added check for ASN.1 initialized.
 *
 *    Rev 1.5   13 Mar 1996 11:33:06   DABROWN1
 * Enable logging for ring0
 *
 *    Rev 1.4   07 Mar 1996 23:20:14   dabrown1
 *
 * Modifications required for ring0/ring3 compatiblity
 *
 *    Rev 1.3   06 Mar 1996 13:13:52   DABROWN1
 *
 * added #define _DLL for SPOX build
 *
 *    Rev 1.2   23 Feb 1996 13:54:42   DABROWN1
 *
 * added tracing functions
 *
 *    Rev 1.1   21 Feb 1996 16:52:08   DABROWN1
 *
 * Removed call to h245_asn1free, now uses generic MemFree
 *
 *    Rev 1.0   09 Feb 1996 17:35:20   cjutzi
 * Initial revision.
 *
 *****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef  _IA_SPOX_
# define _DLL
#endif //_IA_SPOX_

#include "h245asn1.h"
#include "h245sys.x"
#include "sendrcv.x"
#include "h245com.h"

/***********************/
/*    ASN1 INCLUDES    */
/***********************/

/***********************/
/*     S/R GLOBALS     */
/***********************/
#ifdef  _IA_SPOX_
# define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
# define HWND    void*
# undef _DLL
#endif //_IA_SPOX



#define ASN1_FLAGS   0

int initializeASN1(ASN1_CODER_INFO *pWorld)
{
    int         nResult;

    nResult = H245_InitWorld(pWorld);

    return (MAKELONG(nResult, 0));
}

int terminateASN1(ASN1_CODER_INFO *pWorld)
{
    H245_TermWorld(pWorld);

    H245TRACE(0, 10, "Unloading ASN.1 libraries", 0);

    return 0;
}


// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

int H245_InitModule(void)
{
    H245ASN_Module_Startup();
    return (H245ASN_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int H245_TermModule(void)
{
    H245ASN_Module_Cleanup();
    return ASN1_SUCCESS;
}

int H245_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H245ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H245ASN_Module,         // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H245ASN_Module,         // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        H245_TermWorld(pWorld);
    }

    return rc;
}

int H245_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H245ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                //  buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if (fBufferSupplied)
        {
            ASSERT(pBuf->value == pEncInfo->buf);
            ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
        ASSERT(FALSE);
    }
    return rc;
}

int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
        ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245man.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/h245man.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.225  $
 *	$Date:   03 Mar 1997 09:08:10  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "h245man.h"
#include "chanman.h"
#include "hangman.h"
#include "ccutils.h"
#include "linkapi.h"
#include "h245com.h"

extern CALL_CONTROL_STATE	CallControlState;
extern THREADCOUNT			ThreadCount;

static BOOL		bH245ManagerInited = FALSE;

static struct {
	DWORD				dwPhysicalID;
	LOCK				Lock;
} PhysicalID;



HRESULT InitH245Manager()
{
	ASSERT(bH245ManagerInited == FALSE);

	// Note -- don't use a physical ID of 0; the physical ID gets mapped
	// to an H245 instance of the same value, and an H245 instance of
	// 0 is invalid
	PhysicalID.dwPhysicalID = 1;
	InitializeLock(&PhysicalID.Lock);
	bH245ManagerInited = H245SysInit();
	return CC_OK;
}



HRESULT DeInitH245Manager()
{
	if (bH245ManagerInited == FALSE)
		return CC_OK;

    H245SysDeInit();
    H245WSShutdown();
	DeleteLock(&PhysicalID.Lock);
	bH245ManagerInited = FALSE;
	return CC_OK;
}



HRESULT MakeH245PhysicalID(			DWORD					*pdwH245PhysicalID)
{
	AcquireLock(&PhysicalID.Lock);
	*pdwH245PhysicalID = PhysicalID.dwPhysicalID++;
	RelinquishLock(&PhysicalID.Lock);
	return CC_OK;
}



HRESULT _ConstructTermCapList(		PCC_TERMCAPLIST			*ppTermCapList,
									PCC_TERMCAP				*ppH2250MuxCap,
									PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors,
									PCALL					pCall)
{
#define MAX_TERM_CAPS		257
#define MAX_TERM_CAP_DESC	255
H245_TOTCAP_T *				pTermCapArray[MAX_TERM_CAPS];
H245_TOTCAPDESC_T *			pTermCapDescriptorArray[MAX_TERM_CAP_DESC];
unsigned long				CapArrayLength;
unsigned long				CapDescriptorArrayLength;
unsigned long				i, j;
HRESULT						status;

	ASSERT(ppTermCapList != NULL);
	ASSERT(*ppTermCapList == NULL);
	ASSERT(ppH2250MuxCap != NULL);
	ASSERT(*ppH2250MuxCap == NULL);
	ASSERT(ppTermCapDescriptors != NULL);
	ASSERT(*ppTermCapDescriptors == NULL);
	ASSERT(pCall != NULL);

	CapArrayLength = MAX_TERM_CAPS;
	CapDescriptorArrayLength = MAX_TERM_CAP_DESC;

	status = H245GetCaps(pCall->H245Instance,
		                 H245_CAPDIR_RMTRXTX,
					     H245_DATA_DONTCARE,
					     H245_CLIENT_DONTCARE,
					     pTermCapArray,
					     &CapArrayLength,
					     pTermCapDescriptorArray,
					     &CapDescriptorArrayLength);
	if (status != H245_ERROR_OK) {
		*ppTermCapList = NULL;
		*ppH2250MuxCap = NULL;
		*ppTermCapDescriptors = NULL;
		return status;
	}

	// Check the term cap list to see if an H.225.0 mux capability is present;
	// this capability is treated as a special case
	*ppH2250MuxCap = NULL;
	for (i = 0; i < CapArrayLength; i++) {
		ASSERT(pTermCapArray[i] != NULL);
		if (pTermCapArray[i]->CapId == 0) {
			*ppH2250MuxCap = pTermCapArray[i];
			--CapArrayLength;
			for (j = i; j < CapArrayLength; j++)
				pTermCapArray[j] = pTermCapArray[j+1];
			break;
		}
	}

	if (CapArrayLength == 0)
		*ppTermCapList = NULL;
	else {
		*ppTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
		if (*ppTermCapList == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			return CC_NO_MEMORY;
		}

		(*ppTermCapList)->wLength = (WORD)CapArrayLength;
		(*ppTermCapList)->pTermCapArray =
			(H245_TOTCAP_T **)MemAlloc(sizeof(H245_TOTCAP_T *) * CapArrayLength);
		if ((*ppTermCapList)->pTermCapArray == NULL) {
			MemFree(*ppTermCapList);
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		for (i = 0; i < CapArrayLength; i++)
			(*ppTermCapList)->pTermCapArray[i] = pTermCapArray[i];
	}

	if (CapDescriptorArrayLength == 0)
		*ppTermCapDescriptors = NULL;
	else {
		*ppTermCapDescriptors = (PCC_TERMCAPDESCRIPTORS)MemAlloc(sizeof(CC_TERMCAPDESCRIPTORS));
		if (*ppTermCapDescriptors == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			if (*ppTermCapList != NULL) {
				MemFree((*ppTermCapList)->pTermCapArray);
				MemFree(*ppTermCapList);
			}
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		(*ppTermCapDescriptors)->wLength = (WORD)CapDescriptorArrayLength;
		(*ppTermCapDescriptors)->pTermCapDescriptorArray =
			(H245_TOTCAPDESC_T **)MemAlloc(sizeof(H245_TOTCAPDESC_T *) * CapDescriptorArrayLength);
		if ((*ppTermCapDescriptors)->pTermCapDescriptorArray == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			if (*ppTermCapList != NULL) {
				MemFree((*ppTermCapList)->pTermCapArray);
				MemFree(*ppTermCapList);
			}
			MemFree(*ppTermCapDescriptors);
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		for (i = 0; i < CapDescriptorArrayLength; i++)
			(*ppTermCapDescriptors)->pTermCapDescriptorArray[i] = pTermCapDescriptorArray[i];
	}
	return CC_OK;
}



HRESULT _ProcessConnectionComplete(	PCONFERENCE				pConference,
									PCALL					pCall)
{
CC_HCONFERENCE						hConference;
CC_HCALL							hCall;
HQ931CALL							hQ931Call;
HQ931CALL							hQ931CallInvitor;
HRESULT								status;
CC_CONNECT_CALLBACK_PARAMS			ConnectCallbackParams;
CC_MULTIPOINT_CALLBACK_PARAMS		MultipointCallbackParams;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
CC_PEER_ADD_CALLBACK_PARAMS			PeerAddCallbackParams;
WORD								i;
BOOL								bMultipointConference;
H245_TRANSPORT_ADDRESS_T			Q931Address;
PDU_T								Pdu;
CALLTYPE							CallType;
WORD								wNumCalls;
PCC_HCALL							CallList;
WORD								wNumChannels;
PCC_HCHANNEL						ChannelList;
PCHANNEL							pChannel;
PCALL								pOldCall;
CC_HCALL							hOldCall;
BYTE								bNewTerminalNumber;
BYTE								bNewMCUNumber;
CC_ENDPOINTTYPE						DestinationEndpointType;
H245_COMM_MODE_ENTRY_T				*pH245CommunicationTable;
BYTE								bCommunicationTableCount;
BOOL								bSessionTableChanged;
CONFMODE							PreviousConferenceMode;
CC_ADDR								MCAddress;
BOOL								bConferenceTermCapsChanged;
H245_INST_T							H245Instance;
PCC_TERMCAP							pTxTermCap;
PCC_TERMCAP							pRxTermCap;
H245_MUX_T							*pTxMuxTable;
H245_MUX_T							*pRxMuxTable;

// caution: the size of PDU_T is ~70K because of the size of
// OpenLogicalChannel, because of struct EncryptionSync
// If there is a way to tweak the ASN to make this a pointer,
// then it needs to be done

    ASSERT(pConference != NULL);
	ASSERT(pCall != NULL);
	ASSERT(pCall->hConference == pConference->hConference);
	
	hConference = pConference->hConference;
	hCall = pCall->hCall;
	hQ931Call = pCall->hQ931Call;
	hQ931CallInvitor = pCall->hQ931CallInvitor;
	H245Instance = pCall->H245Instance;
	CallType = pCall->CallType;

	// Note that pConference->ConferenceMode refers to the conference mode BEFORE
	// this connection attempt completes.  If the current conference mode is
	// point-to-point, this connection (if successful) will result in a multipoint
	// conference.  We want to reflect in the CONNECT callback the connection mode
	// that would exist if the connect attempt is successful.
	if ((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		(pConference->ConferenceMode == MULTIPOINT_MODE) ||
		(pCall->bCallerIsMC))
		bMultipointConference = TRUE;
	else
		bMultipointConference = FALSE;

	// Initialize all fields of ConnectCallbackParams now
	ConnectCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = pCall->pszPeerDisplay;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
	ConnectCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
	ConnectCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
	ConnectCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = bMultipointConference;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	status = AddEstablishedCallToConference(pCall, pConference);
	if (status != CC_OK) {
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY)
			Q931RejectCall(hQ931CallInvitor,
						   CC_REJECT_UNDEFINED_REASON,
						   &pCall->ConferenceID,
						   NULL,	// alternate address
						   pCall->pPeerNonStandardData);

		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return status;
	}

	if (((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		 (pConference->ConferenceMode == MULTIPOINT_MODE)) &&
		(pConference->tsMultipointController == TS_TRUE))
		status = CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else {
		status = CC_OK;
		bConferenceTermCapsChanged = FALSE;
	}
	if (status != CC_OK) {
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY)
			Q931RejectCall(pCall->hQ931CallInvitor,
						   CC_REJECT_UNDEFINED_REASON,
						   &pCall->ConferenceID,
						   NULL,	// alternate address
						   pCall->pPeerNonStandardData);

		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return status;
	}

	if (pConference->tsMultipointController == TS_TRUE) {
		// Send MCLocationIndication
		status = GetLastListenAddress(&MCAddress);
		if (status == CC_OK) {
			ASSERT(MCAddress.nAddrType == CC_IP_BINARY);
			Q931Address.type = H245_IP_UNICAST;
			Q931Address.u.ip.tsapIdentifier =
				MCAddress.Addr.IP_Binary.wPort;
			HostToH245IPNetwork(Q931Address.u.ip.network,
							    MCAddress.Addr.IP_Binary.dwAddr);
			H245MCLocationIndication(pCall->H245Instance,
									 &Q931Address);
		}
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	if (pConference->ConferenceMode == UNCONNECTED_MODE) {
		ASSERT(pConference->pSessionTable == NULL);
		ASSERT(wNumCalls == 1);

		pConference->ConferenceMode = POINT_TO_POINT_MODE;
	} else { // we're currently in point-to-point mode or multipoint mode

		if (pConference->tsMultipointController == TS_TRUE) {
			PreviousConferenceMode = pConference->ConferenceMode;
			pConference->ConferenceMode = MULTIPOINT_MODE;

			// In the future, we may want to construct a new session table
			// each time a new peer is added to the conference
			if (PreviousConferenceMode == POINT_TO_POINT_MODE) {
				// Assign a terminal label to ourselves
				// Note that we reserve a terminal number of 0 for ourselves
				// if we're the MC
				ASSERT(pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber == 255);
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 0;

				// Create a new session table
				CreateConferenceSessionTable(
							pConference,
							&bSessionTableChanged);
			} else
				// For the current implementation, don't cause a new
				// CommunicationModeCommand to be issued when a new peer is added
				// unless we're switching from point-to-point to multipoint mode
				// (in which case bSessionTableChanged is ignored)
				bSessionTableChanged = FALSE;

			if (bSessionTableChanged)
				SessionTableToH245CommunicationTable(pConference->pSessionTable,
													 &pH245CommunicationTable,
													 &bCommunicationTableCount);
			else
				pH245CommunicationTable = NULL;

			// Send MultipointModeCommand to new call
			Pdu.choice = MSCMg_cmmnd_chosen;
			Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
			// logical channel number is irrelavent but needs to be filled in
			Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = 1;
			Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.type.choice = multipointModeCommand_chosen;
			H245SendPDU(pCall->H245Instance, &Pdu);

			status = AllocatePeerParticipantInfo(pConference, &pCall->pPeerParticipantInfo);
			if (status == CC_OK) {
				bNewMCUNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
				bNewTerminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
				// Send TerminalNumberAssign to new call
				H245ConferenceIndication(pCall->H245Instance,
										 H245_IND_TERMINAL_NUMBER_ASSIGN,// Indication Type
										 0,							// SBE number; ignored here
										 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,			// MCU number
										 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);		// terminal number
				
				// Send EnterH243TerminalID to new call
				H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_ENTER_H243_TERMINAL_ID,
									  pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
									  pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
				pCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
			} else {
				// Unable to assign a terminal number to the new call
				bNewMCUNumber = 0;
				bNewTerminalNumber = 0;
			}

			if (pH245CommunicationTable != NULL) {
				// Send CommunicationModeCommand to new call
				status = H245CommunicationModeCommand(pCall->H245Instance,
													  pH245CommunicationTable,
													  bCommunicationTableCount);
			}

			if (PreviousConferenceMode == POINT_TO_POINT_MODE) {
				// Generate MULTIPOINT callback
				MultipointCallbackParams.pTerminalInfo = &pConference->LocalParticipantInfo.ParticipantInfo;
				MultipointCallbackParams.pSessionTable = pConference->pSessionTable;
				InvokeUserConferenceCallback(pConference,
											 CC_MULTIPOINT_INDICATION,
											 CC_OK,
											 &MultipointCallbackParams);
				if (ValidateConference(hConference) != CC_OK) {
					if (ValidateCall(hCall) == CC_OK) {
						pCall->CallState = CALL_COMPLETE;
						UnlockCall(pCall);
					}
					MemFree(CallList);
					return CC_OK;
				}

				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
				if (ValidateConference(hConference) != CC_OK) {
					if (ValidateCall(hCall) == CC_OK) {
						pCall->CallState = CALL_COMPLETE;
						UnlockCall(pCall);
					}
					MemFree(CallList);
					return CC_OK;
				}

				ASSERT(wNumCalls == 2); // one existing call and new call
				if (CallList[0] == hCall)
					hOldCall = CallList[1];
				else
					hOldCall = CallList[0];

				if (LockCall(hOldCall, &pOldCall) == CC_OK) {
					// Send MultipointModeCommand to old call
					Pdu.choice = MSCMg_cmmnd_chosen;
					Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
					// logical channel number is irrelavent but needs to be filled in
					Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = 1;
					Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.type.choice = multipointModeCommand_chosen;
					H245SendPDU(pOldCall->H245Instance, &Pdu);

					status = AllocatePeerParticipantInfo(pConference,
														 &pOldCall->pPeerParticipantInfo);
					if (status == CC_OK) {
						// Send TerminalNumberAssign to old call
						H245ConferenceIndication(pOldCall->H245Instance,
												 H245_IND_TERMINAL_NUMBER_ASSIGN,// Indication Type
												 0,							// SBE number; ignored here
												 pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,				// MCU number
												 pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);	// terminal number
						
						// Send EnterH243TerminalID to old call
						H245ConferenceRequest(pOldCall->H245Instance,
											  H245_REQ_ENTER_H243_TERMINAL_ID,
											  pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
											  pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
						pOldCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
					}

					if (pH245CommunicationTable != NULL) {
						// Send CommunicationModeCommand to old call
						status = H245CommunicationModeCommand(pOldCall->H245Instance,
															  pH245CommunicationTable,
															  bCommunicationTableCount);
	
						FreeH245CommunicationTable(pH245CommunicationTable,
												   bCommunicationTableCount);
					}

					// Send TerminalJoinedConference (this call) to old call
					H245ConferenceIndication(pOldCall->H245Instance,
											 H245_IND_TERMINAL_JOINED,	// Indication Type
											 0,							// SBE number; ignored here
											 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,			// MCU number
											 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);	// terminal number					// terminal number of MC

					if (bNewTerminalNumber != 0) {
						// Send TerminalJoinedConference (new call) to old call
						H245ConferenceIndication(pOldCall->H245Instance,
												 H245_IND_TERMINAL_JOINED,	// Indication Type
												 0,							// SBE number; ignored here
												 bNewMCUNumber,				// MCU number
												 bNewTerminalNumber);		// terminal number

						// Generate PEER_ADD callback for old call
						PeerAddCallbackParams.hCall = pOldCall->hCall;
						PeerAddCallbackParams.TerminalLabel =
							pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerAddCallbackParams.pPeerTerminalID = NULL;
						InvokeUserConferenceCallback(pConference,
											 CC_PEER_ADD_INDICATION,
											 CC_OK,
											 &PeerAddCallbackParams);
						if (ValidateConference(hConference) != CC_OK) {
							if (ValidateCall(hOldCall) == CC_OK)
								UnlockCall(pCall);
							if (ValidateCall(hCall) == CC_OK) {
								pCall->CallState = CALL_COMPLETE;
								UnlockCall(pCall);
							}
							MemFree(CallList);
							return CC_OK;
						}
					}

					// Send new term caps to old call
					SendTermCaps(pOldCall, pConference);

					UnlockCall(pOldCall);
				}
			} else { // we're currently in multipoint mode
				EnumerateChannelsInConference(&wNumChannels,
											  &ChannelList,
											  pConference,
											  TX_CHANNEL | PROXY_CHANNEL | TXRX_CHANNEL);
				for (i = 0; i < wNumChannels; i++) {
					if (LockChannel(ChannelList[i], &pChannel) == CC_OK) {
						if (pChannel->bMultipointChannel) {
							if ((pChannel->bChannelType == TX_CHANNEL) ||
								((pChannel->bChannelType == TXRX_CHANNEL) &&
								 (pChannel->bLocallyOpened == TRUE))) {
								pTxTermCap = pChannel->pTxH245TermCap;
								pTxMuxTable = pChannel->pTxMuxTable;
								pRxTermCap = pChannel->pRxH245TermCap;
								pRxMuxTable = pChannel->pRxMuxTable;
							} else {
								// Note: since this is a proxy or remotely-opened
								// bi-directional channel, RxTermCap and RxMuxTable
								// contain the channel's term cap and mux table,
								// and must be sent to other endpoints as the
								// Tx term cap and mux table;
								// TxTermCap and TxMuxTable should be NULL
								pTxTermCap = pChannel->pRxH245TermCap;
								pTxMuxTable = pChannel->pRxMuxTable;
								pRxTermCap = pChannel->pTxH245TermCap;
								pRxMuxTable = pChannel->pTxMuxTable;
							}
	
							status = H245OpenChannel(
										pCall->H245Instance,
										pChannel->hChannel,		// dwTransId
										pChannel->wLocalChannelNumber,
										pTxTermCap,				// TxMode
										pTxMuxTable,			// TxMux
										H245_INVALID_PORT_NUMBER,	// TxPort
										pRxTermCap,				// RxMode
										pRxMuxTable,			// RxMux
										pChannel->pSeparateStack);
							if ((status == CC_OK) && (pChannel->wNumOutstandingRequests != 0))
								(pChannel->wNumOutstandingRequests)++;
						}
						UnlockChannel(pChannel);
					}
				}
				MemFree(ChannelList);

				for (i = 0; i < wNumCalls; i++) {
					// Don't send a message to the endpoint that just joined the conference!
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							if (bNewTerminalNumber != 0)
								// Send TerminalJoinedConference (new call) to old call
								H245ConferenceIndication(pOldCall->H245Instance,
														 H245_IND_TERMINAL_JOINED,	// Indication Type
														 0,							// SBE number; ignored here
														 bNewMCUNumber,				// MCU number
														 bNewTerminalNumber);		// terminal number
							// Send CommunicationModeCommand, if necessary
							if (pH245CommunicationTable != NULL)
								status = H245CommunicationModeCommand(pOldCall->H245Instance,
																	  pH245CommunicationTable,
																	  bCommunicationTableCount);
							if (bConferenceTermCapsChanged)
								// Send new term caps
								SendTermCaps(pOldCall, pConference);

							UnlockCall(pOldCall);
						}
					}
				}
				if (bConferenceTermCapsChanged) {
					// Generate CC_PEER_CHANGE_CAP callback
					PeerChangeCapCallbackParams.pTermCapList =
						pConference->pConferenceTermCapList;
					PeerChangeCapCallbackParams.pH2250MuxCapability =
						pConference->pConferenceH245H2250MuxCapability;
					PeerChangeCapCallbackParams.pTermCapDescriptors =
						pConference->pConferenceTermCapDescriptors;
					InvokeUserConferenceCallback(pConference,
												 CC_PEER_CHANGE_CAP_INDICATION,
												 CC_OK,
												 &PeerChangeCapCallbackParams);
					if (ValidateConference(hConference) != CC_OK) {
						if (ValidateCall(hCall) == CC_OK) {
							pCall->CallState = CALL_COMPLETE;
							UnlockCall(pCall);
						}
						MemFree(CallList);
						return CC_OK;
					}
				}
			}

			// Generate PEER_ADD callback
			PeerAddCallbackParams.hCall = pCall->hCall;
			PeerAddCallbackParams.TerminalLabel =
				pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			PeerAddCallbackParams.pPeerTerminalID = NULL;
			InvokeUserConferenceCallback(pConference,
								 CC_PEER_ADD_INDICATION,
								 CC_OK,
								 &PeerAddCallbackParams);
			if (ValidateConference(hConference) != CC_OK) {
				if (ValidateCall(hCall) == CC_OK) {
					pCall->CallState = CALL_COMPLETE;
					UnlockCall(pCall);
					MemFree(CallList);
					return CC_OK;
				}
			}

			if (CallType == THIRD_PARTY_INTERMEDIARY) {
				DestinationEndpointType.pVendorInfo = pCall->pPeerVendorInfo;
				DestinationEndpointType.bIsTerminal = TRUE;
				DestinationEndpointType.bIsGateway = FALSE;

				status = Q931AcceptCall(pCall->hQ931CallInvitor,
										pCall->pszPeerDisplay,
										pCall->pPeerNonStandardData,
										&DestinationEndpointType,
										NULL,
										pCall->hCall);
				Q931Hangup(pCall->hQ931CallInvitor, CC_REJECT_NORMAL_CALL_CLEARING);
			}
		} // if (pConference->tsMultipointController == TS_TRUE)
	}

	MemFree(CallList);

	if (ValidateConference(hConference) == CC_OK)
		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
			// This CONNECT must apply to the local endpoint
			pConference->LocalEndpointAttached = ATTACHED;
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 CC_OK,
										 &ConnectCallbackParams);
		}
	// Need to validate the conference and call handles; the associated
	// objects may have been deleted during user callback on this thread
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	if (ValidateCall(hCall) == CC_OK) {
		pCall->CallState = CALL_COMPLETE;
		UnlockCall(pCall);
	}
	return status;
}



HRESULT _IndUnimplemented(			H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_NOSUP;
}



HRESULT _IndFlowControl(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT								status;
CC_HCALL							hCall;
PCALL								pCall;
PCONFERENCE							pConference;
CC_HCONFERENCE						hConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_FLOW_CONTROL_CALLBACK_PARAMS		FlowControlCallbackParams;

	if (pH245ConfIndData->u.Indication.u.IndFlowControl.Scope != H245_SCOPE_CHANNEL_NUMBER)
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndFlowControl.Channel,
								TRUE,	// local channel number
		                        TX_CHANNEL | PROXY_CHANNEL,
								CC_INVALID_HANDLE,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if (pChannel->bChannelType == TX_CHANNEL) {
		UnlockChannel(pChannel);
		FlowControlCallbackParams.hChannel = hChannel;
		FlowControlCallbackParams.dwRate =
			pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction;
		InvokeUserConferenceCallback(pConference,
									 CC_FLOW_CONTROL_INDICATION,
									 CC_OK,
									 &FlowControlCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel->bChannelType == PROXY_CHANNEL
		if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			H245FlowControl(pCall->H245Instance,
							pH245ConfIndData->u.Indication.u.IndFlowControl.Scope,
							pChannel->wRemoteChannelNumber,
							pH245ConfIndData->u.Indication.u.IndFlowControl.wResourceID,
							pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction);
			UnlockCall(pCall);
		}
		UnlockChannel(pChannel);
		UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}



HRESULT _IndEndSession(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL	hCall;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (hCall != CC_INVALID_HANDLE)
		ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_NORMAL_CALL_CLEARING);
	return H245_ERROR_OK;
}



HRESULT _IndCapability(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
HRESULT								status;
PCONFERENCE							pConference;
CC_HCONFERENCE						hConference;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
BOOL								bConferenceTermCapsChanged;
WORD								wNumCalls;
PCC_HCALL							CallList;
PCALL								pOldCall;
WORD								i;

	// We received a TerminalCapabilitySet message from a peer

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = FALSE;

	pCall->bLinkEstablished = TRUE;

	pCall->IncomingTermCapState = TERMCAP_COMPLETE;

	if (pCall->CallState == TERMCAP) {
		ASSERT(pCall->pPeerH245TermCapList == NULL);
		ASSERT(pCall->pPeerH245H2250MuxCapability == NULL);
		ASSERT(pCall->pPeerH245TermCapDescriptors == NULL);
	} else {
		DestroyH245TermCapList(&pCall->pPeerH245TermCapList);
		DestroyH245TermCap(&pCall->pPeerH245H2250MuxCapability);
		DestroyH245TermCapDescriptors(&pCall->pPeerH245TermCapDescriptors);
	}

	_ConstructTermCapList(&(pCall->pPeerH245TermCapList),
			              &(pCall->pPeerH245H2250MuxCapability),
						  &(pCall->pPeerH245TermCapDescriptors),
			              pCall);

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}

	if (pCall->CallState == CALL_COMPLETE) {
		if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
			(pConference->tsMultipointController == TS_TRUE)) {
			CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
			if (bConferenceTermCapsChanged) {
				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					// Don't send a message to the endpoint that just joined the conference!
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							// Send new term caps
							SendTermCaps(pOldCall, pConference);
							UnlockCall(pOldCall);
						}
					}
				}
				if (CallList != NULL)
					MemFree(CallList);

				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
			}
		} else {
			PeerChangeCapCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
			PeerChangeCapCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
			PeerChangeCapCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
			InvokeUserConferenceCallback(pConference,
										 CC_PEER_CHANGE_CAP_INDICATION,
										 CC_OK,
										 &PeerChangeCapCallbackParams);
		}
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateCall(hCall) == CC_OK)
			UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndOpenT120(				H245_CONF_IND_T			*pH245ConfIndData)
{
BOOL									bFailed;
CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS	T120ChannelRequestCallbackParams;
CC_HCALL								hCall;
PCALL									pCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
CC_HCHANNEL								hChannel;
PCHANNEL								pChannel;
CC_TERMCAP								RxTermCap;
CC_TERMCAP								TxTermCap;
H245_MUX_T								RxH245MuxTable;
H245_MUX_T								TxH245MuxTable;
CC_ADDR									T120Addr;
CC_OCTETSTRING							ExternalReference;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	
	if (pH245ConfIndData->u.Indication.u.IndOpen.RxDataType != H245_DATA_DATA ||
	    pH245ConfIndData->u.Indication.u.IndOpen.RxClientType != H245_CLIENT_DAT_T120 ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap == NULL ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap->H245Dat_T120.application.choice != DACy_applctn_t120_chosen ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap->H245Dat_T120.application.u.DACy_applctn_t120.choice != separateLANStack_chosen ||
 	    pH245ConfIndData->u.Indication.u.IndOpen.TxDataType != H245_DATA_DATA ||
	    pH245ConfIndData->u.Indication.u.IndOpen.TxClientType != H245_CLIENT_DAT_T120 ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap == NULL ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap->H245Dat_T120.application.choice != DACy_applctn_t120_chosen ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap->H245Dat_T120.application.u.DACy_applctn_t120.choice != separateLANStack_chosen) {
		bFailed = TRUE;
    } else {
	    bFailed = FALSE;
    }

	if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack) {
		if ((pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.choice == localAreaAddress_chosen) &&
			(pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
			(pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.choice == UnicastAddress_iPAddress_chosen)) {
			T120Addr.nAddrType = CC_IP_BINARY;
			T120Addr.bMulticast = FALSE;
			T120Addr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier;
			H245IPNetworkToHost(&T120Addr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value);
		} else {
			bFailed = TRUE;
		}
	}

	if (bFailed) {
 		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	RxTermCap.Dir = H245_CAPDIR_RMTTX;
	RxTermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.RxDataType;
	RxTermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.RxClientType;
	RxTermCap.CapId = 0;	// not used for channels
	RxTermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pRxCap;

	TxTermCap.Dir = H245_CAPDIR_RMTTX;
	TxTermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.TxDataType;
	TxTermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.TxClientType;
	TxTermCap.CapId = 0;	// not used for channels
	TxTermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pTxCap;

	RxH245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pRxMux;
	if ((pCall->pPeerParticipantInfo != NULL) &&
		(pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)) {
		RxH245MuxTable.u.H2250.destinationPresent = TRUE;
		RxH245MuxTable.u.H2250.destination.mcuNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
		RxH245MuxTable.u.H2250.destination.terminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
	} else
		RxH245MuxTable.u.H2250.destinationPresent = FALSE;

    if(pH245ConfIndData->u.Indication.u.IndOpen.pTxMux)
    {
	    TxH245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pTxMux;
		TxH245MuxTable.u.H2250.destinationPresent = FALSE;
	}

	if (AllocAndLockChannel(&hChannel,
							pConference,
							hCall,
							&TxTermCap,			// Tx terminal capability
							&RxTermCap,			// Rx terminal capability
							(pH245ConfIndData->u.Indication.u.IndOpen.pTxMux)?
							    &TxH245MuxTable: NULL,	// Tx H245 mux table
							&RxH245MuxTable,	// Rx H245 mux table
							pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack, // separate stack
							0,					// user token
							TXRX_CHANNEL,		// channel type
							0,					// session ID
							0,					// associated session ID
							pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,	// remote bi-dir channel number
							NULL,				// pLocalRTPAddr
							NULL,				// pLocalRTCPAddr
							NULL,				// pPeerRTPAddr
							NULL,				// pPeerRTCPAddr
							FALSE,				// locally opened
							&pChannel) != CC_OK) {

		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (AddChannelToConference(pChannel, pConference) != CC_OK) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		FreeChannel(pChannel);
		return H245_ERROR_OK;
	}

	T120ChannelRequestCallbackParams.hChannel = hChannel;
	if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack == NULL) {
		T120ChannelRequestCallbackParams.bAssociateConference = FALSE;
		T120ChannelRequestCallbackParams.pExternalReference = NULL;
		T120ChannelRequestCallbackParams.pAddr = NULL;
	} else {
		T120ChannelRequestCallbackParams.bAssociateConference =
			pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->associateConference;		
		if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->bit_mask & externalReference_present) {
			ExternalReference.wOctetStringLength = (WORD)
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->externalReference.length;
			ExternalReference.pOctetString =
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->externalReference.value;
			T120ChannelRequestCallbackParams.pExternalReference = &ExternalReference;
		} else
			T120ChannelRequestCallbackParams.pExternalReference = NULL;
		T120ChannelRequestCallbackParams.pAddr = &T120Addr;
	}
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		T120ChannelRequestCallbackParams.bMultipointController = TRUE;
	else
		T120ChannelRequestCallbackParams.bMultipointController = FALSE;
	if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destinationPresent) {
		T120ChannelRequestCallbackParams.TerminalLabel.bMCUNumber =
			(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.mcuNumber;
		T120ChannelRequestCallbackParams.TerminalLabel.bTerminalNumber =
			(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.terminalNumber;
	} else {
		T120ChannelRequestCallbackParams.TerminalLabel.bMCUNumber = 255;
		T120ChannelRequestCallbackParams.TerminalLabel.bTerminalNumber = 255;
	}

	pChannel->wNumOutstandingRequests = 1;

	InvokeUserConferenceCallback(pConference,
		                         CC_T120_CHANNEL_REQUEST_INDICATION,
								 CC_OK,
								 &T120ChannelRequestCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		UnlockChannel(pChannel);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndOpen(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL								hCall;
PCALL									pCall;
PCALL									pOldCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
WORD									wNumCalls;
PCC_HCALL								CallList;
CC_HCHANNEL								hChannel;
PCHANNEL								pChannel;
CC_TERMCAP								TermCap;
CC_ADDR									PeerRTPAddr;
CC_ADDR									PeerRTCPAddr;
CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS	RxChannelRequestCallbackParams;
BYTE									bChannelType;
WORD									i;
H245_MUX_T								H245MuxTable;
PCC_ADDR								pLocalRTPAddr;
PCC_ADDR								pLocalRTCPAddr;
PCC_ADDR								pPeerRTPAddr;
PCC_ADDR								pPeerRTCPAddr;
BOOL									bFoundSession;
HRESULT									status;

	// First check to see if this is a T.120 channel request,
	// as T.120 channels are handled differently then other channels
	if (pH245ConfIndData->u.Indication.u.IndOpen.RxClientType == H245_CLIENT_DAT_T120) {
		status = _IndOpenT120(pH245ConfIndData);
		return status;
	}

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	// Make sure that this is not a bi-directional channel
	if (pH245ConfIndData->u.Indication.u.IndOpen.pTxMux != NULL) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	
	TermCap.Dir = H245_CAPDIR_RMTTX;
	TermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.RxDataType;
	TermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.RxClientType;
	TermCap.CapId = 0;	// not used for Rx channels
	TermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pRxCap;
	
	RxChannelRequestCallbackParams.pChannelCapability = &TermCap;

	if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux != NULL) &&
		(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->Kind == H245_H2250)) {
		RxChannelRequestCallbackParams.bSessionID =
			pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID;
		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.associatedSessionIDPresent)
			RxChannelRequestCallbackParams.bAssociatedSessionID =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.associatedSessionID;
		else
			RxChannelRequestCallbackParams.bAssociatedSessionID = 0;
		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.silenceSuppressionPresent)
			RxChannelRequestCallbackParams.bSilenceSuppression =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.silenceSuppression;
		else
			RxChannelRequestCallbackParams.bSilenceSuppression = FALSE;
		if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannelPresent) &&
			((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_MULTICAST) ||
			(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_UNICAST))) {
			RxChannelRequestCallbackParams.pPeerRTPAddr = &PeerRTPAddr;
			PeerRTPAddr.nAddrType = CC_IP_BINARY;
			if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_MULTICAST)
				PeerRTPAddr.bMulticast = TRUE;
			else
				PeerRTPAddr.bMulticast = FALSE;
			PeerRTPAddr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&PeerRTPAddr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.u.ip.network);
		} else
			RxChannelRequestCallbackParams.pPeerRTPAddr = NULL;

		if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannelPresent) &&
			((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_MULTICAST) ||
			(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_UNICAST))) {
			RxChannelRequestCallbackParams.pPeerRTCPAddr = &PeerRTCPAddr;
			PeerRTCPAddr.nAddrType = CC_IP_BINARY;
			if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_MULTICAST)
				PeerRTCPAddr.bMulticast = TRUE;
			else
				PeerRTCPAddr.bMulticast = FALSE;
			PeerRTCPAddr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&PeerRTCPAddr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.u.ip.network);
		} else
			RxChannelRequestCallbackParams.pPeerRTCPAddr = NULL;

		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destinationPresent) {
			RxChannelRequestCallbackParams.TerminalLabel.bMCUNumber =
				(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.mcuNumber;
			RxChannelRequestCallbackParams.TerminalLabel.bTerminalNumber =
				(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.terminalNumber;
		} else {
			RxChannelRequestCallbackParams.TerminalLabel.bMCUNumber = 255;
			RxChannelRequestCallbackParams.TerminalLabel.bTerminalNumber = 255;
		}

		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.dynamicRTPPayloadTypePresent)
			RxChannelRequestCallbackParams.bRTPPayloadType =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.dynamicRTPPayloadType;
		else
			RxChannelRequestCallbackParams.bRTPPayloadType = 0;
	} else {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	// XXX -- someday we should allow dynamic sessions to be created on the MC
	if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID == 0) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (pConference->ConferenceMode == MULTIPOINT_MODE) {
		if ((pConference->tsMultipointController == TS_TRUE) &&
			((RxChannelRequestCallbackParams.pPeerRTPAddr != NULL) ||
			 (RxChannelRequestCallbackParams.pPeerRTCPAddr != NULL)) ||
		    ((pConference->tsMultipointController == TS_FALSE) &&
			 ((RxChannelRequestCallbackParams.pPeerRTPAddr == NULL) ||
			  (RxChannelRequestCallbackParams.pPeerRTCPAddr == NULL) ||
			  (RxChannelRequestCallbackParams.bSessionID == 0)))) {
  			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			return H245_ERROR_OK;
		}

		// Validate session ID
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		bFoundSession = FALSE;
		if (pConference->pSessionTable != NULL) {
			for (i = 0; i < pConference->pSessionTable->wLength; i++) {
				if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID ==
					pConference->pSessionTable->SessionInfoArray[i].bSessionID) {
					bFoundSession = TRUE;
					pLocalRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
					pLocalRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
					break;
				}
			}
		}
		if (bFoundSession == FALSE)	{
			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			return H245_ERROR_OK;
		}

		ASSERT(pLocalRTPAddr != NULL);
		ASSERT(pLocalRTCPAddr != NULL);

		if (pConference->tsMultipointController == TS_TRUE) {
			pPeerRTPAddr = pLocalRTPAddr;
			pPeerRTCPAddr = pLocalRTCPAddr;
			RxChannelRequestCallbackParams.pPeerRTPAddr = pLocalRTPAddr;
			RxChannelRequestCallbackParams.pPeerRTCPAddr = pLocalRTCPAddr;
			bChannelType = PROXY_CHANNEL;
		} else { // multipoint mode, not MC
			pLocalRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
			pLocalRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
			pPeerRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
			pPeerRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
			bChannelType = RX_CHANNEL;
		}
	} else { // not multipoint mode
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		pPeerRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
		pPeerRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
		bChannelType = RX_CHANNEL;
	}

	H245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pRxMux;
	if ((pCall->pPeerParticipantInfo != NULL) &&
		(pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)) {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
	} else
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	if (pLocalRTPAddr != NULL) {
		if (pLocalRTPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaChannel.u.ip.tsapIdentifier =
			pLocalRTPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaChannel.u.ip.network,
							pLocalRTPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	if (pLocalRTCPAddr != NULL) {
		if (pLocalRTCPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaControlChannel.u.ip.tsapIdentifier =
			pLocalRTCPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaControlChannel.u.ip.network,
							pLocalRTCPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaControlChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;

	if (AllocAndLockChannel(&hChannel,
							pConference,
							hCall,
							NULL,				// Tx terminal capability
							&TermCap,			// Rx terminal capability
							NULL,				// Tx H245 mux table
							&H245MuxTable,		// Rx H245 mux table
							NULL,				// separate stack
							0,					// user token
							bChannelType,
							pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID,
							RxChannelRequestCallbackParams.bAssociatedSessionID,
							pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							pLocalRTPAddr,		// pLocalRTPAddr
							pLocalRTCPAddr,		// pLocalRTCPAddr
							pPeerRTPAddr,		// pPeerRTPAddr
							pPeerRTCPAddr,		// pPeerRTCPAddr
							FALSE,				// locally opened
							&pChannel) != CC_OK) {

		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (AddChannelToConference(pChannel, pConference) != CC_OK) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		FreeChannel(pChannel);
		return H245_ERROR_OK;
	}

	RxChannelRequestCallbackParams.hChannel = hChannel;
	
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		// Open this channel to each peer in the conference (except the peer
		// that requested this channel)
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pOldCall) == CC_OK) {
					ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
					// Note: since this is a proxy channel, RxTermCap and RxMuxTable
					// contain the channel's term cap and mux table, and must be sent
					// to other endpoints as the Tx term cap and mux table;
					// TxTermCap and TxMuxTable should be NULL
					if (H245OpenChannel(pOldCall->H245Instance,
										pChannel->hChannel,		// dwTransId
										pChannel->wLocalChannelNumber,
										pChannel->pRxH245TermCap,	// TxMode
										pChannel->pRxMuxTable,		// TxMux
										H245_INVALID_PORT_NUMBER,	// TxPort
										pChannel->pTxH245TermCap,	// RxMode
										pChannel->pTxMuxTable,		// RxMux
										pChannel->pSeparateStack) == CC_OK)
						(pChannel->wNumOutstandingRequests)++;
					UnlockCall(pOldCall);
				}
			}
		}
		MemFree(CallList);
		if (pConference->LocalEndpointAttached == ATTACHED)
			(pChannel->wNumOutstandingRequests)++;
		if (pChannel->wNumOutstandingRequests == 0) {
			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			FreeChannel(pChannel);
			return H245_ERROR_OK;
		}
	} else
		pChannel->wNumOutstandingRequests = 1;
	
	InvokeUserConferenceCallback(pConference,
		                         CC_RX_CHANNEL_REQUEST_INDICATION,
								 CC_OK,
								 &RxChannelRequestCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		UnlockChannel(pChannel);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndOpenConf(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL								hCall;
PCALL									pCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
CC_HCHANNEL								hChannel;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS	    AcceptChannelCallbackParams;

    // Bi-directional channel open initiated by remote peer is now complete.
    // Local peer may now send data over this channel.

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndOpenConf.TxChannel,
								FALSE,	// remote channel number
		                        TXRX_CHANNEL,
								hCall,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	AcceptChannelCallbackParams.hChannel = hChannel;
	
	InvokeUserConferenceCallback(pConference,
		                         CC_ACCEPT_CHANNEL_INDICATION,
								 CC_OK,
								 &AcceptChannelCallbackParams);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndMstslv(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CC_HCALL					hEnqueuedCall;
PCALL						pEnqueuedCall;
CC_HCONFERENCE				hConference;
HRESULT						status;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	ASSERT(pCall->MasterSlaveState != MASTER_SLAVE_COMPLETE);

	switch (pH245ConfIndData->u.Indication.u.IndMstSlv) {
	    case H245_MASTER:
		    pConference->tsMaster = TS_TRUE;
		    if (pConference->tsMultipointController == TS_UNKNOWN) {
			    ASSERT(pConference->bMultipointCapable == TRUE);
			    pConference->tsMultipointController = TS_TRUE;

			    // place all calls enqueued on this conference object
			    for ( ; ; ) {
				    // Start up all enqueued calls, if any exist
				    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
				    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
					    break;

				    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
				    if (status == CC_OK) {
					    pEnqueuedCall->CallState = PLACED;

					    status = PlaceCall(pEnqueuedCall, pConference);
					    UnlockCall(pEnqueuedCall);
				    }
			    }
		    }
	        break;

	    case H245_SLAVE:
		    ASSERT(pConference->tsMaster != TS_TRUE);
		    ASSERT(pConference->tsMultipointController != TS_TRUE);
		    pConference->tsMaster = TS_FALSE;
		    pConference->tsMultipointController = TS_FALSE;

		    // XXX -- we may eventually want to re-enqueue these requests
		    // and set an expiration timer
		    hConference = pConference->hConference;
				
		    for ( ; ; ) {
			    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
			    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
				    break;

			    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
			    if (status == CC_OK) {
				    MarkCallForDeletion(pEnqueuedCall);
				    ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				    ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				    ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				    ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				    ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				    ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				    ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	                if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	                else
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				    ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				    ConnectCallbackParams.bMultipointConference = TRUE;
				    ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				    ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
					ConnectCallbackParams.pAlternateAddress = NULL;
				    ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				    InvokeUserConferenceCallback(pConference,
									    CC_CONNECT_INDICATION,
									    CC_NOT_MULTIPOINT_CAPABLE,
									    &ConnectCallbackParams);
				    if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					    FreeCall(pEnqueuedCall);
				    if (ValidateConference(hConference) != CC_OK) {
					    if (ValidateCall(hCall) == CC_OK)
						    UnlockCall(pCall);
					    return H245_ERROR_OK;
				    }
			    }
		    }
	        break;

	    default: // H245_INDETERMINATE
			UnlockConference(pConference);
			if (++pCall->wMasterSlaveRetry < MASTER_SLAVE_RETRY_MAX) {
				H245InitMasterSlave(pCall->H245Instance, pCall->H245Instance);
			    UnlockCall(pCall);
			} else {
			    UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
			}
			return H245_ERROR_OK;
	} // switch

	pCall->MasterSlaveState = MASTER_SLAVE_COMPLETE;

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}
	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndClose(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
WORD								i;
WORD								wNumCalls;
PCC_HCALL							CallList;
CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS	RxChannelCloseCallbackParams;
#ifdef    GATEKEEPER
unsigned                            uBandwidth;
#endif // GATEKEEPER

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndClose.Channel,
							    FALSE,	// remote channel number
		                        RX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL,
								hCall,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK)
		return H245_ERROR_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	if (pChannel->bChannelType != TXRX_CHANNEL)
    	{
    		uBandwidth = pChannel->dwChannelBitRate / 100;
    		for (i = 0; i < wNumCalls; i++)
    		{
    			if (LockCall(CallList[i], &pCall) == CC_OK)
    			{
    				if (uBandwidth && pCall->GkiCall.uBandwidthUsed >= uBandwidth)
    				{
    					if (GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel) == CC_OK)
    					{
    						uBandwidth = 0;
    						UnlockCall(pCall);
    						break;
    					}
    				}
    				UnlockCall(pCall);
    			}
    		} // for
    	}
	}
#endif // GATEKEEPER

	if (pChannel->bChannelType == PROXY_CHANNEL) {
		ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
		ASSERT(pConference->tsMultipointController == TS_TRUE);
		ASSERT(pChannel->bMultipointChannel == TRUE);

		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pCall) == CC_OK) {
					H245CloseChannel(pCall->H245Instance,	// H245 instance
				                     0,						// dwTransId
							         pChannel->wLocalChannelNumber);
					UnlockCall(pCall);
				}
			}
		}
	}

	if (CallList != NULL)
	    MemFree(CallList);

	if (pChannel->tsAccepted == TS_TRUE) {
		RxChannelCloseCallbackParams.hChannel = hChannel;
		InvokeUserConferenceCallback(pConference,
									 CC_RX_CHANNEL_CLOSE_INDICATION,
									 CC_OK,
									 &RxChannelCloseCallbackParams);
	}

	if (ValidateChannel(hChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndRequestClose(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS	TxChannelCloseRequestCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndClose.Channel,
								TRUE,	// local channel number
		                        TX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL,
								CC_INVALID_HANDLE,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if ((pChannel->bChannelType == TX_CHANNEL) ||
	    (pChannel->bChannelType == TXRX_CHANNEL)) {
		EnqueueRequest(&pChannel->pCloseRequests, hCall);
		UnlockChannel(pChannel);
		TxChannelCloseRequestCallbackParams.hChannel = hChannel;
		InvokeUserConferenceCallback(pConference,
							 CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION,
							 CC_OK,
							 &TxChannelCloseRequestCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel->bChannelType == PROXY_CHANNEL
		if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			// Note that dwTransID is set to the call handle of the peer who
			// initiated the close channel request. When the close channel response
			// is received, the dwTransID gives us back the call handle to which
			// the response must be forwarded
			H245CloseChannelReq(pCall->H245Instance,
								hCall,	// dwTransID
								pChannel->wRemoteChannelNumber);
			UnlockCall(pCall);
		}
		UnlockChannel(pChannel);
		UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}


	
HRESULT _IndNonStandard(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL									hCall;
PCALL										pCall;
CC_HCONFERENCE								hConference;
PCONFERENCE									pConference;
CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS	RxNonStandardMessageCallbackParams;

	// We only handle H221 non-standard messages; if pwObjectId is non-NULL,
	// ignore the message
	if (pH245ConfIndData->u.Indication.u.IndNonstandard.pwObjectId != NULL)
		return H245_ERROR_OK;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	switch (pH245ConfIndData->u.Indication.Indicator) {
		case H245_IND_NONSTANDARD_REQUEST:
			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_REQUEST;
			break;
		case H245_IND_NONSTANDARD_RESPONSE:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_RESPONSE;
			break;
		case H245_IND_NONSTANDARD_COMMAND:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_COMMAND;
			break;
		case H245_IND_NONSTANDARD:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_INDICATION;
			break;
		default:
			UnlockConference(pConference);
			return H245_ERROR_NOSUP;
	}

	RxNonStandardMessageCallbackParams.NonStandardData.sData.pOctetString =
		pH245ConfIndData->u.Indication.u.IndNonstandard.pData;
	RxNonStandardMessageCallbackParams.NonStandardData.sData.wOctetStringLength =
		(WORD)pH245ConfIndData->u.Indication.u.IndNonstandard.dwDataLength;
	RxNonStandardMessageCallbackParams.NonStandardData.bCountryCode =
		pH245ConfIndData->u.Indication.u.IndNonstandard.byCountryCode;	
	RxNonStandardMessageCallbackParams.NonStandardData.bExtension =
		pH245ConfIndData->u.Indication.u.IndNonstandard.byExtension;
	RxNonStandardMessageCallbackParams.NonStandardData.wManufacturerCode =
		pH245ConfIndData->u.Indication.u.IndNonstandard.wManufacturerCode;
	RxNonStandardMessageCallbackParams.hCall = pCall->hCall;
	if (pCall->pPeerParticipantInfo != NULL)
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	else {
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	}
				
	InvokeUserConferenceCallback(pConference,
		                         CC_RX_NONSTANDARD_MESSAGE_INDICATION,
								 CC_OK,
								 &RxNonStandardMessageCallbackParams);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	return H245_ERROR_OK;
}



HRESULT _IndMiscellaneous(			H245_CONF_IND_T			*pH245ConfIndData,
									MiscellaneousIndication	*pMiscellaneousIndication)
{
HRESULT						status = CC_OK;
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pOldCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
CC_HCHANNEL					hChannel;
PCHANNEL					pChannel;
WORD						i;
WORD						wNumCalls;
PCC_HCALL					CallList;
PDU_T						Pdu;
CC_MUTE_CALLBACK_PARAMS		MuteCallbackParams;
CC_UNMUTE_CALLBACK_PARAMS	UnMuteCallbackParams;
CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS	H245MiscellaneousIndicationCallbackParams;

	if (pMiscellaneousIndication == NULL)
		// Should never hit this case
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	switch (pMiscellaneousIndication->type.choice) {
		case logicalChannelActive_chosen:
		case logicalChannelInactive_chosen:

			UnlockCall(pCall);

			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "logical channel inactive" (mute) or "logical channel active" (unmute)
				Pdu.choice = indication_chosen;
				Pdu.u.indication.choice = miscellaneousIndication_chosen;
				Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
					pChannel->wLocalChannelNumber;
				Pdu.u.indication.u.miscellaneousIndication.type.choice =
					pMiscellaneousIndication->type.choice;

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pCall) == CC_OK) {
							H245SendPDU(pCall->H245Instance, &Pdu);
							UnlockCall(pCall);
						}
					}
				}
				MemFree(CallList);
			}

			if (pMiscellaneousIndication->type.choice == logicalChannelActive_chosen) {
				if (pChannel->tsAccepted == TS_TRUE) {
					UnMuteCallbackParams.hChannel = hChannel;
					InvokeUserConferenceCallback(pConference,
												 CC_UNMUTE_INDICATION,
												 CC_OK,
												 &UnMuteCallbackParams);
				}
			} else {
				if (pChannel->tsAccepted == TS_TRUE) {
					MuteCallbackParams.hChannel = hChannel;
					InvokeUserConferenceCallback(pConference,
												 CC_MUTE_INDICATION,
												 CC_OK,
												 &MuteCallbackParams);
				}
			}

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			status = H245_ERROR_OK;
			break;

		case multipointConference_chosen:
		case cnclMltpntCnfrnc_chosen:
			// We're required to support receipt of this indication, but I have no
			// idea what we're supposed to do with it
			UnlockCall(pCall);
			UnlockConference(pConference);
			status = H245_ERROR_OK;
			break;

		case vdIndctRdyTActvt_chosen:
		case MIn_tp_vdTmprlSptlTrdOff_chosen:
			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "video indicate ready to activate" or
				// "video temporal spatial tradeoff"
				Pdu.choice = indication_chosen;
				Pdu.u.indication.choice = miscellaneousIndication_chosen;
				Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
					pChannel->wLocalChannelNumber;
				Pdu.u.indication.u.miscellaneousIndication.type.choice =
					pMiscellaneousIndication->type.choice;

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							H245SendPDU(pOldCall->H245Instance, &Pdu);
							UnlockCall(pOldCall);
						}
					}
				}
				MemFree(CallList);
			}

			if (pChannel->tsAccepted == TS_TRUE) {
				H245MiscellaneousIndicationCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousIndicationCallbackParams.hChannel = hChannel;
				H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
					pMiscellaneousIndication;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
											 CC_OK,
											 &H245MiscellaneousIndicationCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;
			} else
				status = H245_ERROR_OK;

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			break;

		case videoNotDecodedMBs_chosen:
			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										TRUE,	// local channel number
										TX_CHANNEL | PROXY_CHANNEL,
										CC_INVALID_HANDLE,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == TX_CHANNEL) {
				H245MiscellaneousIndicationCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousIndicationCallbackParams.hChannel = hChannel;
				H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
					pMiscellaneousIndication;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
											 CC_OK,
											 &H245MiscellaneousIndicationCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;

				if (ValidateChannel(hChannel) == CC_OK)
					UnlockChannel(pChannel);
				if (ValidateCall(hCall) == CC_OK)
					UnlockCall(pCall);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				return H245_ERROR_OK;
			} else {
				// Proxy channel; forward the request to the transmitter
  				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "video not decoded MBs"
				Pdu.choice = indication_chosen;
				Pdu.u.indication.choice = miscellaneousIndication_chosen;
				Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
					pChannel->wRemoteChannelNumber;
				Pdu.u.indication.u.miscellaneousIndication.type.choice =
					pMiscellaneousIndication->type.choice;

				if (LockCall(pChannel->hCall, &pOldCall) == CC_OK) {
					H245SendPDU(pOldCall->H245Instance, &Pdu);
					UnlockCall(pOldCall);
				}
				UnlockChannel(pChannel);
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			// We should never reach here
			ASSERT(0);

		default:
			// Miscellaneous indication	not containing channel information
			// Pass it up to the client
			H245MiscellaneousIndicationCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245MiscellaneousIndicationCallbackParams.hChannel = CC_INVALID_HANDLE;;
			H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
				pMiscellaneousIndication;

			status = InvokeUserConferenceCallback(pConference,
										 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
										 CC_OK,
										 &H245MiscellaneousIndicationCallbackParams);

			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			break;
	}

	return status;

	// We should never reach this point
	ASSERT(0);
}



HRESULT _IndMiscellaneousCommand(	H245_CONF_IND_T			*pH245ConfIndData,
									MiscellaneousCommand	*pMiscellaneousCommand)
{
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pOldCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status = CC_OK;
WORD						wChoice;
CC_HCHANNEL					hChannel;
PCHANNEL					pChannel;
PDU_T						Pdu;
CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS	H245MiscellaneousCommandCallbackParams;

	if (pMiscellaneousCommand == NULL)
		// Should never hit this case
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pMiscellaneousCommand->type.choice) {
		case multipointModeCommand_chosen:
		//
		// from this point on, expect CommunicationModeCommand
		// also, theoretically, channels shouldn't be opened until at
		// least one CommunicationModeCommand is received.
		// It's only by examining CommunicationModeCommand contents
		// that we can determine if a conference has decentralized
		// media.

		// I'm commenting this out on 6/4/98 because it's bogus: all
		// endpoints have centralized media distribution.  Set
		// pConference->ConferenceMode = MULTIPOINT_MODE; only after
		// CommunicationModeCommand is received and the multiplex table has
		// been examined and decentralized media is found
#if(0)		
			if (pConference->bMultipointCapable == FALSE) {
				// We can't support multipoint operation, so treat this as if
				// we received a remote hangup indication
				UnlockConference(pConference);
				UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_NORMAL_CALL_CLEARING);
				return H245_ERROR_OK;
			} else {
				pConference->ConferenceMode = MULTIPOINT_MODE;

				// Send TerminalListRequest
				H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_TERMINAL_LIST,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
			}
#else
            // Send TerminalListRequest
			H245ConferenceRequest(pCall->H245Instance,
			    H245_REQ_TERMINAL_LIST,
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
#endif
			status = H245_ERROR_OK;
			break;

		case cnclMltpntMdCmmnd_chosen:
			// We're required to support receipt of this command, but I have no
			// idea what we're supposed to do with it
			status = H245_ERROR_OK;
			break;

		case videoFreezePicture_chosen:
		case videoFastUpdatePicture_chosen:
		case videoFastUpdateGOB_chosen:
		case MCd_tp_vdTmprlSptlTrdOff_chosen:
		case videoSendSyncEveryGOB_chosen:
		case videoFastUpdateMB_chosen:
		case vdSndSyncEvryGOBCncl_chosen:
			if (FindChannelInConference(pMiscellaneousCommand->logicalChannelNumber,
										TRUE,	// local channel number
										TX_CHANNEL | PROXY_CHANNEL,
										CC_INVALID_HANDLE,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == TX_CHANNEL) {
				H245MiscellaneousCommandCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousCommandCallbackParams.hChannel = hChannel;
				wChoice = pMiscellaneousCommand->type.choice;
				if ((wChoice == videoFreezePicture_chosen) ||
					(wChoice == videoFastUpdatePicture_chosen) ||
					(wChoice == videoFastUpdateGOB_chosen) ||
					(wChoice == videoFastUpdateMB_chosen))
					H245MiscellaneousCommandCallbackParams.bH323ActionRequired = TRUE;
				else
					H245MiscellaneousCommandCallbackParams.bH323ActionRequired = FALSE;
				H245MiscellaneousCommandCallbackParams.pMiscellaneousCommand =
					pMiscellaneousCommand;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_COMMAND_INDICATION,
											 CC_OK,
											 &H245MiscellaneousCommandCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;

				if (ValidateChannel(hChannel) == CC_OK)
					UnlockChannel(pChannel);
				if (ValidateCall(hCall) == CC_OK)
					UnlockCall(pCall);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				return H245_ERROR_OK;
			} else {
				// Proxy channel; forward the request to the transmitter
  				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				Pdu.choice = MSCMg_cmmnd_chosen;
				Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
				Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber =
					pChannel->wRemoteChannelNumber;
				Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand = *pMiscellaneousCommand;
				if (LockCall(pChannel->hCall, &pOldCall) == CC_OK) {
					H245SendPDU(pOldCall->H245Instance, &Pdu);
					UnlockCall(pOldCall);
				}
				UnlockChannel(pChannel);
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			// We should never reach here
			ASSERT(0);

		default:
			// Unrecognized miscellaneous command
			// Pass it up to the client
			H245MiscellaneousCommandCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245MiscellaneousCommandCallbackParams.hChannel = CC_INVALID_HANDLE;
			H245MiscellaneousCommandCallbackParams.bH323ActionRequired = FALSE;
			H245MiscellaneousCommandCallbackParams.pMiscellaneousCommand =
				pMiscellaneousCommand;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_MISCELLANEOUS_COMMAND_INDICATION,
												  CC_OK,
												  &H245MiscellaneousCommandCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return status;

	// We should never reach this point
	ASSERT(0);
}



HRESULT _IndMCLocation(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
PCALL						pEnqueuedCall;
CC_HCALL					hEnqueuedCall;
HRESULT						status;
CC_HCONFERENCE				hConference;

	if (pH245ConfIndData->u.Indication.u.IndMcLocation.type != H245_IP_UNICAST)
		return H245_ERROR_OK;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;

	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	UnlockCall(pCall);

	hConference = pConference->hConference;

	if (pConference->tsMultipointController != TS_FALSE) {
		// We don't expect to receive an MCLocationIndication until master/slave
		// has completed, at which time tsMultipointController will change from
		// TS_UNKNOWN to either TS_TRUE or TS_FALSE.
		UnlockConference(pConference);
		return H245_ERROR_NOSUP;
	}

	if (pConference->pMultipointControllerAddr == NULL) {
		pConference->pMultipointControllerAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if (pConference->pMultipointControllerAddr == NULL) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
	}
	pConference->pMultipointControllerAddr->nAddrType = CC_IP_BINARY;
	pConference->pMultipointControllerAddr->bMulticast = FALSE;
	pConference->pMultipointControllerAddr->Addr.IP_Binary.wPort =
		pH245ConfIndData->u.Indication.u.IndMcLocation.u.ip.tsapIdentifier;
	H245IPNetworkToHost(&pConference->pMultipointControllerAddr->Addr.IP_Binary.dwAddr,
						pH245ConfIndData->u.Indication.u.IndMcLocation.u.ip.network);

	// place all calls enqueued on this conference object
	for ( ; ; ) {
		// Start up all enqueued calls, if any exist
		status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
		if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hEnqueuedCall, &pEnqueuedCall);
		if (status == CC_OK) {
			// Place Call to MC
			pEnqueuedCall->CallState = PLACED;
			pEnqueuedCall->CallType = THIRD_PARTY_INVITOR;
			if (pEnqueuedCall->pQ931DestinationAddr == NULL)
				pEnqueuedCall->pQ931DestinationAddr = pEnqueuedCall->pQ931PeerConnectAddr;
			if (pEnqueuedCall->pQ931PeerConnectAddr == NULL)
				pEnqueuedCall->pQ931PeerConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pEnqueuedCall->pQ931PeerConnectAddr == NULL) {
				MarkCallForDeletion(pEnqueuedCall);
				ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	            if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		            ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	            else
		            ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				ConnectCallbackParams.bMultipointConference = TRUE;
				ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
				ConnectCallbackParams.pAlternateAddress = NULL;
				ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_NO_MEMORY,
									 &ConnectCallbackParams);

				if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					FreeCall(pEnqueuedCall);
				if (ValidateConference(hConference) != CC_OK)
					return H245_ERROR_OK;
			}
			pEnqueuedCall->pQ931PeerConnectAddr = pConference->pMultipointControllerAddr;

			status = PlaceCall(pEnqueuedCall, pConference);
			UnlockCall(pEnqueuedCall);
		}
	}

	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndConferenceRequest(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pPeerCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
H245_TERMINAL_LABEL_T		*H245TerminalLabelList;
H245_TERMINAL_LABEL_T		H245TerminalLabel;
WORD						wNumTerminalLabels;
CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS	H245ConferenceRequestCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferReq.RequestType) {
		case H245_REQ_ENTER_H243_TERMINAL_ID:
			switch (pConference->LocalParticipantInfo.TerminalIDState) {
				case TERMINAL_ID_INVALID:
					UnlockCall(pCall);
					EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
								   hCall);
					pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_REQUESTED;
					InvokeUserConferenceCallback(pConference,
									 CC_TERMINAL_ID_REQUEST_INDICATION,
									 CC_OK,
									 NULL);
					if (ValidateConference(hConference) == CC_OK)
						UnlockConference(pConference);
					return H245_ERROR_OK;

				case TERMINAL_ID_REQUESTED:
					UnlockCall(pCall);
					EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
								   hCall);
					UnlockConference(pConference);
					return H245_ERROR_OK;

				case TERMINAL_ID_VALID:
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_TERMINAL_ID,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
										   NULL,					// terminal list
										   0);						// terminal list count
					UnlockCall(pCall);
					UnlockConference(pConference);
					return H245_ERROR_OK;

				default:
					ASSERT(0);
			}

		case H245_REQ_TERMINAL_LIST:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				status = EnumerateTerminalLabelsInConference(&wNumTerminalLabels,
													      &H245TerminalLabelList,
														  pConference);
				if (status == CC_OK)
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_TERMINAL_LIST,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
										   H245TerminalLabelList,		// terminal list
										   wNumTerminalLabels);			// terminal list count
				if (H245TerminalLabelList != NULL)
					MemFree(H245TerminalLabelList);
				status = H245_ERROR_OK;
			} else
				status = H245_ERROR_NOSUP;
			break;

		case H245_REQ_TERMINAL_ID:
			if (pConference->tsMultipointController != TS_TRUE) {
				status = H245_ERROR_NOSUP;
				break;
			}

			if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber !=
				pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber) {
				// This terminal ID wasn't allocated by this MC, so return without a response
				status = H245_ERROR_OK;
				break;
			}

			// First check to see whether the requested terminal ID is ours
			if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber ==
				 pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber) {
			    if (pConference->LocalEndpointAttached != ATTACHED) {
					status = H245_ERROR_OK;
					break;
				}

  				switch (pConference->LocalParticipantInfo.TerminalIDState) {
					case TERMINAL_ID_INVALID:
						UnlockCall(pCall);
						EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
									   hCall);
						pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_REQUESTED;
						InvokeUserConferenceCallback(pConference,
										 CC_TERMINAL_ID_REQUEST_INDICATION,
										 CC_OK,
										 NULL);
						if (ValidateConference(hConference) == CC_OK)
							UnlockConference(pConference);
						return H245_ERROR_OK;

					case TERMINAL_ID_REQUESTED:
						UnlockCall(pCall);
						EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
									   hCall);
						UnlockConference(pConference);
						return H245_ERROR_OK;

					case TERMINAL_ID_VALID:
						H245ConferenceResponse(pCall->H245Instance,
											   H245_RSP_MC_TERMINAL_ID,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
											   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
											   NULL,					// terminal list
											   0);						// terminal list count
						UnlockCall(pCall);
						UnlockConference(pConference);
						return H245_ERROR_OK;

					default:
						ASSERT(0);
				}
			}

			H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber;
			H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber;

			FindPeerParticipantInfo(H245TerminalLabel,
									pConference,
									ESTABLISHED_CALL,
									&pPeerCall);
			if (pPeerCall == NULL) {
				// We don't know about the existance of this terminal ID, so return without a response
				status = H245_ERROR_OK;
				break;
			}

			if (pPeerCall->pPeerParticipantInfo == NULL) {
				UnlockCall(pPeerCall);
				status = H245_ERROR_OK;
				break;
			}

			switch (pPeerCall->pPeerParticipantInfo->TerminalIDState) {
				case TERMINAL_ID_INVALID:
					EnqueueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
								   hCall);
					pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
  					H245ConferenceRequest(pPeerCall->H245Instance,
										  H245_REQ_ENTER_H243_TERMINAL_ID,
										  pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
										  pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
					break;

				case TERMINAL_ID_REQUESTED:
					EnqueueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
								   hCall);
					break;

				case TERMINAL_ID_VALID:
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_MC_TERMINAL_ID,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength,
										   NULL,			// terminal list
										   0);				// terminal list count
					break;

				default:
					ASSERT(0);
					break;
			}
			UnlockCall(pPeerCall);
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceRequestCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceRequestCallbackParams.RequestType =
				pH245ConfIndData->u.Indication.u.IndConferReq.RequestType;
			H245ConferenceRequestCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber;
			H245ConferenceRequestCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_REQUEST_INDICATION,
												  CC_OK,
												  &H245ConferenceRequestCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			break;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndConferenceResponse(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pPeerCall;
CC_HCALL						hEnqueuedCall;
PCALL							pEnqueuedCall;
CC_HCALL						hVirtualCall;
CC_HCALL						hPeerCall;
PCALL							pVirtualCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
HRESULT							status;
WORD							i;
PPARTICIPANTINFO				pPeerParticipantInfo;
H245_TERMINAL_LABEL_T			TerminalLabel;
CC_PEER_ADD_CALLBACK_PARAMS		PeerAddCallbackParams;
CC_PEER_UPDATE_CALLBACK_PARAMS	PeerUpdateCallbackParams;
CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS	H245ConferenceResponseCallbackParams;
CC_OCTETSTRING					OctetString;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferRsp.ResponseType) {
		case H245_RSP_TERMINAL_LIST:
			if (pConference->tsMultipointController == TS_FALSE) {
				for (i = 0; i < pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount; i++) {
					if ((pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber ==
						 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber) &&
						(pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber ==
						 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber))
						// This terminal number refers to us
						continue;
					FindPeerParticipantInfo(pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i],
											pConference,
											VIRTUAL_CALL,
											&pPeerCall);
					if (pPeerCall != NULL) {
						// We already know this peer's terminal label, and we
						// eithet know its terminal ID or we have a pending request
						// to obtain it
						UnlockCall(pPeerCall);
						continue;
					}

					// We don't know about this peer.
					// Create a virtual call object for it, and issue a request
					// for its terminal ID
					status = AllocAndLockCall(&hVirtualCall,
											  pConference->hConference,
											  CC_INVALID_HANDLE,	// hQ931Call
											  CC_INVALID_HANDLE,	// hQ931CallInvitor,
											  NULL,					// pLocalAliasNames,
											  NULL,					// pPeerAliasNames,
											  NULL,					// pPeerExtraAliasNames
											  NULL,					// pPeerExtension
											  NULL,					// pLocalNonStandardData,
											  NULL,					// pPeerNonStandardData,
											  NULL,					// pszLocalDisplay,
											  NULL,					// pszPeerDisplay,
											  NULL,					// pPeerVendorInfo,
											  NULL,					// pQ931LocalConnectAddr,
											  NULL,					// pQ931PeerConnectAddr,
											  NULL,					// pQ931DestinationAddr,
											  NULL,                 // pSourceCallSignalAddress
											  VIRTUAL,				// CallType,
											  FALSE,				// bCallerIsMC,
											  0,					// dwUserToken,
											  CALL_COMPLETE,		// InitialCallState,
											  NULL,                 // no CallIdentifier
											  &pConference->ConferenceID,
											  &pVirtualCall);
					if (status == CC_OK) {
						status = AllocatePeerParticipantInfo(NULL,
														     &pPeerParticipantInfo);
						if (status == CC_OK) {
							pVirtualCall->pPeerParticipantInfo =
								pPeerParticipantInfo;
							pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber =
								(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber;
							pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber =
								(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber;
							AddVirtualCallToConference(pVirtualCall,
													   pConference);
							// Send RequestTerminalID
							H245ConferenceRequest(pCall->H245Instance,
										          H245_REQ_TERMINAL_ID,
										          (BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber,
												  (BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber);
							pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;

							// Generate PEER_ADD callback
							PeerAddCallbackParams.hCall = hVirtualCall;
							PeerAddCallbackParams.TerminalLabel =
								pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
							PeerAddCallbackParams.pPeerTerminalID = NULL;
							InvokeUserConferenceCallback(pConference,
												 CC_PEER_ADD_INDICATION,
												 CC_OK,
												 &PeerAddCallbackParams);
							if (ValidateCall(hVirtualCall) == CC_OK)
								UnlockCall(pVirtualCall);
						} else
							FreeCall(pVirtualCall);
					}
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_RSP_MC_TERMINAL_ID:
			if (pConference->tsMultipointController == TS_FALSE) {
				TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
				TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
				FindPeerParticipantInfo(TerminalLabel,
										pConference,
										VIRTUAL_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					hPeerCall = pPeerCall->hCall;
					if (pPeerCall->pPeerParticipantInfo->TerminalIDState != TERMINAL_ID_VALID) {
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString =
							(BYTE *)MemAlloc(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						if (pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString == NULL) {
							UnlockCall(pPeerCall);
							status = H245_ERROR_OK;
							break;
						}
						memcpy(pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength =
							pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
						pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_VALID;
						
						PeerUpdateCallbackParams.hCall = hPeerCall;
						PeerUpdateCallbackParams.TerminalLabel =
							pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerUpdateCallbackParams.pPeerTerminalID = &pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
						InvokeUserConferenceCallback(pConference,
													 CC_PEER_UPDATE_INDICATION,
													 CC_OK,
													 &PeerUpdateCallbackParams);
					}
					if (ValidateCall(hPeerCall) == CC_OK)
						UnlockCall(pPeerCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_RSP_TERMINAL_ID:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
				TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
				FindPeerParticipantInfo(TerminalLabel,
										pConference,
										ESTABLISHED_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					hPeerCall = pPeerCall->hCall;
					if (pPeerCall->pPeerParticipantInfo->TerminalIDState != TERMINAL_ID_VALID) {
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString =
							(BYTE *)MemAlloc(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						if (pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString == NULL) {
							UnlockCall(pPeerCall);
							status = H245_ERROR_OK;
							break;
						}
						memcpy(pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength =
							pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
						pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_VALID;
						
						// Dequeue and respond to each enqueued request for this terminal ID
						while (DequeueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
											  &hEnqueuedCall) == CC_OK) {
							if (LockCall(hEnqueuedCall, &pEnqueuedCall) == CC_OK) {
								H245ConferenceResponse(pEnqueuedCall->H245Instance,
													   H245_RSP_MC_TERMINAL_ID,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
													   (BYTE)pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength,
													   NULL,			// terminal list
													   0);				// terminal list count

								UnlockCall(pEnqueuedCall);
							}
						}

						// Generate a CC_PEER_UPDATE_INDICATION callback
						PeerUpdateCallbackParams.hCall = hPeerCall;
						PeerUpdateCallbackParams.TerminalLabel =
							pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerUpdateCallbackParams.pPeerTerminalID = &pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
						InvokeUserConferenceCallback(pConference,
													 CC_PEER_UPDATE_INDICATION,
													 CC_OK,
													 &PeerUpdateCallbackParams);
					}
					if (ValidateCall(hPeerCall) == CC_OK)
						UnlockCall(pPeerCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceResponseCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceResponseCallbackParams.ResponseType =
				pH245ConfIndData->u.Indication.u.IndConferRsp.ResponseType;
			H245ConferenceResponseCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
			H245ConferenceResponseCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
			if ((pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString == NULL) ||
				(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength == 0)) {
				H245ConferenceResponseCallbackParams.pOctetString = NULL;
			} else {
				OctetString.pOctetString =
					pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString;
				OctetString.wOctetStringLength =
					pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
				H245ConferenceResponseCallbackParams.pOctetString = &OctetString;
			}
			if (pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount == 0) {
				H245ConferenceResponseCallbackParams.pTerminalList = NULL;
				H245ConferenceResponseCallbackParams.wTerminalListCount = 0;
				status = CC_OK;
			} else {
				H245ConferenceResponseCallbackParams.pTerminalList =
					(CC_TERMINAL_LABEL *)MemAlloc(sizeof(CC_TERMINAL_LABEL) *
						pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount);
				if (H245ConferenceResponseCallbackParams.pTerminalList == NULL) {
					H245ConferenceResponseCallbackParams.wTerminalListCount = 0;
					status = CC_NO_MEMORY;
				} else {
					for (i = 0; i < pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount; i++) {
						H245ConferenceResponseCallbackParams.pTerminalList[i].bMCUNumber =
							(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber;
						H245ConferenceResponseCallbackParams.pTerminalList[i].bMCUNumber =
							(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber;
					}
					H245ConferenceResponseCallbackParams.wTerminalListCount =
						pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount;
					status = CC_OK;
				}
			}
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_RESPONSE_INDICATION,
												  status,
												  &H245ConferenceResponseCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (H245ConferenceResponseCallbackParams.pTerminalList != NULL)
				MemFree(H245ConferenceResponseCallbackParams.pTerminalList);
			break;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}




HRESULT _IndConferenceCommand(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pOldCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
WORD							i;
WORD							wNumCalls;
PCC_HCALL						CallList;
WORD							wNumChannels;
PCC_HCHANNEL					ChannelList;
PCHANNEL						pChannel;
CC_HCHANNEL						hChannel;
CALLSTATE						CallState;
HQ931CALL						hQ931Call;
H245_INST_T						H245Instance;
HRESULT							status = CC_OK;
CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS	H245ConferenceCommandCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType) {
		case H245_CMD_DROP_CONFERENCE:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				UnlockCall(pCall);
				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ALL_CALLS);
				for (i = 0; i < wNumCalls; i++) {
					if (LockCall(CallList[i], &pCall) == CC_OK) {
						hQ931Call = pCall->hQ931Call;
						H245Instance = pCall->H245Instance;
						CallState = pCall->CallState;
						FreeCall(pCall);
						switch (CallState) {
							case ENQUEUED:
								break;

							case PLACED:
							case RINGING:
								Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
								break;

							default:
								H245ShutDown(H245Instance);
								Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
								break;
						}
					}
				}
				if (CallList != NULL)
					MemFree(CallList);

				EnumerateChannelsInConference(&wNumChannels,
											  &ChannelList,
											  pConference,
											  ALL_CHANNELS);
				for (i = 0; i < wNumChannels; i++) {
					if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
						FreeChannel(pChannel);
				}
				if (ChannelList != NULL)
					MemFree(ChannelList);
						
				InvokeUserConferenceCallback(
									 pConference,
			                         CC_CONFERENCE_TERMINATION_INDICATION,
									 CC_OK,
									 NULL);
				if (ValidateConference(hConference) == CC_OK) {
					if (pConference->bDeferredDelete)
						FreeConference(pConference);
					else {
						ReInitializeConference(pConference);
						UnlockConference(pConference);
					}
				}
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		case brdcstMyLgclChnnl_chosen:
		case cnclBrdcstMyLgclChnnl_chosen:
			if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndConferCmd.Channel,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			
			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							H245ConferenceCommand(pOldCall->H245Instance,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType,
												  pChannel->wLocalChannelNumber,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber);
							UnlockCall(pOldCall);
						}
					}
				}
				MemFree(CallList);
			}

			if (pChannel->tsAccepted == TS_TRUE) {
				H245ConferenceCommandCallbackParams.hCall = hCall;
				H245ConferenceCommandCallbackParams.hChannel = hChannel;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245ConferenceCommandCallbackParams.CommandType =
					pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType;
				H245ConferenceCommandCallbackParams.TerminalLabel.bMCUNumber =
					pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber;
				H245ConferenceCommandCallbackParams.TerminalLabel.bTerminalNumber =
					pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber;
				status = InvokeUserConferenceCallback(pConference,
													  CC_H245_CONFERENCE_COMMAND_INDICATION,
													  CC_OK,
													  &H245ConferenceCommandCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;
			} else
				status = H245_ERROR_OK;

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;

		default:
			// Unrecognized conference command
			// Pass it up to the client
			H245ConferenceCommandCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceCommandCallbackParams.CommandType =
				pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType;
			H245ConferenceCommandCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber;
			H245ConferenceCommandCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber;
			H245ConferenceCommandCallbackParams.hChannel = CC_INVALID_HANDLE;
			
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_COMMAND_INDICATION,
												  CC_OK,
												  &H245ConferenceCommandCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndConference(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pPeerCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
H245_TERMINAL_LABEL_T			H245TerminalLabel;
PPARTICIPANTINFO				pPeerParticipantInfo;
HRESULT							status;
CC_HCALL						hVirtualCall;
PCALL							pVirtualCall;
CC_PEER_ADD_CALLBACK_PARAMS		PeerAddCallbackParams;
CC_PEER_DROP_CALLBACK_PARAMS	PeerDropCallbackParams;
CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS	H245ConferenceIndicationCallbackParams;


	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConfer.IndicationType) {
		case H245_IND_TERMINAL_NUMBER_ASSIGN:
			if (pConference->tsMultipointController == TS_FALSE) {
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber =
					pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber =
					pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;

                hConference = pConference->hConference;
                // Generate a CC_TERMINAL_NUMBER_ASSIGN callback
				InvokeUserConferenceCallback(pConference,
											 CC_TERMINAL_NUMBER_INDICATION,
											 CC_OK,
											 &pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel);

				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				UnlockCall(pCall);
				
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		case H245_IND_TERMINAL_JOINED:
			if (pConference->tsMultipointController == TS_FALSE) {
				if ((pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber ==
					 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber) &&
					(pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber ==
					 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber)) {
					// This message refers to us
					status = H245_ERROR_OK;
					break;
				}

				H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
				FindPeerParticipantInfo(H245TerminalLabel,
										pConference,
										VIRTUAL_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					// We already know this peer's terminal label, and we
					// eithet know its terminal ID or we have a pending request
					// to obtain it
					UnlockCall(pPeerCall);
					status = H245_ERROR_OK;
					break;
				}

				// We don't know about this peer.
				// Create a virtual call object for it, and issue a request
				// for its terminal ID
				status = AllocAndLockCall(&hVirtualCall,
										  pConference->hConference,
										  CC_INVALID_HANDLE,	// hQ931Call
										  CC_INVALID_HANDLE,	// hQ931CallInvitor,
										  NULL,					// pLocalAliasNames,
										  NULL,					// pPeerAliasNames,
										  NULL,					// pPeerExtraAliasNames
										  NULL,					// pPeerExtension
										  NULL,					// pLocalNonStandardData,
										  NULL,					// pPeerNonStandardData,
										  NULL,					// pszLocalDisplay,
										  NULL,					// pszPeerDisplay,
										  NULL,					// pPeerVendorInfo,
										  NULL,					// pQ931LocalConnectAddr,
										  NULL,					// pQ931PeerConnectAddr,
										  NULL,					// pQ931DestinationAddr,
										  NULL,                 // pSourceCallSignalAddress
										  VIRTUAL,				// CallType,
										  FALSE,				// bCallerIsMC,
										  0,					// dwUserToken,
										  CALL_COMPLETE,		// InitialCallState,
										  NULL,                 // no CallIdentifier
										  &pConference->ConferenceID,
										  &pVirtualCall);
				if (status == CC_OK) {
					status = AllocatePeerParticipantInfo(NULL,
														 &pPeerParticipantInfo);
					if (status == CC_OK) {
						pVirtualCall->pPeerParticipantInfo =
							pPeerParticipantInfo;
						pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber =
							(BYTE)H245TerminalLabel.mcuNumber;
						pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber =
							(BYTE)H245TerminalLabel.terminalNumber;
						AddVirtualCallToConference(pVirtualCall,
												   pConference);
						// Send RequestTerminalID
						H245ConferenceRequest(pCall->H245Instance,
										      H245_REQ_TERMINAL_ID,
										      (BYTE)H245TerminalLabel.mcuNumber,
											  (BYTE)H245TerminalLabel.terminalNumber);
						pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;

						// Generate PEER_ADD callback
						PeerAddCallbackParams.hCall = hVirtualCall;
						PeerAddCallbackParams.TerminalLabel =
							pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerAddCallbackParams.pPeerTerminalID = NULL;
						InvokeUserConferenceCallback(pConference,
											 CC_PEER_ADD_INDICATION,
											 CC_OK,
											 &PeerAddCallbackParams);
						if (ValidateCall(hVirtualCall) == CC_OK)
	 						UnlockCall(pVirtualCall);
						if (ValidateConference(hConference) == CC_OK)
							UnlockConference(pConference);
						UnlockCall(pCall);
						return H245_ERROR_OK;
					} else
						FreeCall(pVirtualCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_IND_TERMINAL_LEFT:
			if (pConference->tsMultipointController == TS_FALSE) {
				H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
				
				status = FindPeerParticipantInfo(H245TerminalLabel,
												 pConference,
												 VIRTUAL_CALL,
												 &pVirtualCall);
				if (status == CC_OK) {
					ASSERT(pVirtualCall != NULL);
					ASSERT(pVirtualCall->pPeerParticipantInfo != NULL);
					// Save the virtual call handle; we'll need to validate the virtual
					// call object after returning from the conference callback
					hVirtualCall = pVirtualCall->hCall;
					PeerDropCallbackParams.hCall = hVirtualCall;
					PeerDropCallbackParams.TerminalLabel = pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
					if (pVirtualCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
						PeerDropCallbackParams.pPeerTerminalID = &pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
					else
						PeerDropCallbackParams.pPeerTerminalID = NULL;
				} else {
					// Set pVirtualCall to NULL to indicate that we don't have
					// a virtual call object that needs to be free'd up later
					pVirtualCall = NULL;
					PeerDropCallbackParams.hCall = CC_INVALID_HANDLE;
					PeerDropCallbackParams.TerminalLabel.bMCUNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
					PeerDropCallbackParams.TerminalLabel.bTerminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
					PeerDropCallbackParams.pPeerTerminalID = NULL;
				}

				hConference = pConference->hConference;

				// Generate a CC_PEER_DROP_INDICATION callback
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_DROP_INDICATION,
											 CC_OK,
											 &PeerDropCallbackParams);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				// Check to see if we have a virtual call object that needs to be free'd up
				if (pVirtualCall != NULL)
					if (ValidateCall(hVirtualCall) == CC_OK)
						FreeCall(pVirtualCall);
				UnlockCall(pCall);
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceIndicationCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceIndicationCallbackParams.IndicationType =
				pH245ConfIndData->u.Indication.u.IndConfer.IndicationType;
			H245ConferenceIndicationCallbackParams.bSBENumber =
				pH245ConfIndData->u.Indication.u.IndConfer.bySbeNumber;
			H245ConferenceIndicationCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
			H245ConferenceIndicationCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_INDICATION_INDICATION,
												  CC_OK,
												  &H245ConferenceIndicationCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			break;
	}
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndCommunicationModeCommand(
									H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
CC_HCONFERENCE					hConference;
PCONFERENCE						pConference;
CC_MULTIPOINT_CALLBACK_PARAMS	MultipointCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	if (pConference->tsMultipointController == TS_TRUE) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

	// Destroy the old session table
	FreeConferenceSessionTable(pConference);

	H245CommunicationTableToSessionTable(
									pH245ConfIndData->u.Indication.u.IndCommRsp.pTable,
									pH245ConfIndData->u.Indication.u.IndCommRsp.byTableCount,
									&pConference->pSessionTable);
	
	pConference->bSessionTableInternallyConstructed = TRUE;

	// Generate MULTIPOINT callback
	MultipointCallbackParams.pTerminalInfo = &pConference->LocalParticipantInfo.ParticipantInfo;
	MultipointCallbackParams.pSessionTable = pConference->pSessionTable;
	InvokeUserConferenceCallback(pConference,
								 CC_MULTIPOINT_INDICATION,
								 CC_OK,
								 &MultipointCallbackParams);

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndVendorIdentification(	H245_CONF_IND_T			*pH245ConfIndData,
									VendorIdentification	*pVendorIdentification)
{
CC_HCALL						hCall;
PCALL							pCall;
CC_HCONFERENCE					hConference;
PCONFERENCE						pConference;
CC_NONSTANDARDDATA				NonStandardData;
CC_OCTETSTRING					ProductNumber;
CC_OCTETSTRING					VersionNumber;
CC_VENDOR_ID_CALLBACK_PARAMS	VendorIDCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	VendorIDCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		VendorIDCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		VendorIDCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	} else
		VendorIDCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;

	if (pVendorIdentification->vendor.choice == h221NonStandard_chosen) {
		NonStandardData.sData.pOctetString = NULL;
		NonStandardData.sData.wOctetStringLength = 0;
		NonStandardData.bCountryCode = (BYTE)pVendorIdentification->vendor.u.h221NonStandard.t35CountryCode;
		NonStandardData.bExtension = (BYTE)pVendorIdentification->vendor.u.h221NonStandard.t35Extension;
		NonStandardData.wManufacturerCode = pVendorIdentification->vendor.u.h221NonStandard.manufacturerCode;
		VendorIDCallbackParams.pNonStandardData = &NonStandardData;
	} else
		VendorIDCallbackParams.pNonStandardData = NULL;

	if (pVendorIdentification->bit_mask & productNumber_present) {
		ProductNumber.pOctetString =
			pVendorIdentification->productNumber.value;
		ProductNumber.wOctetStringLength = (WORD)
			pVendorIdentification->productNumber.length;
		VendorIDCallbackParams.pProductNumber = &ProductNumber;
	} else
		VendorIDCallbackParams.pProductNumber = NULL;
	if (pVendorIdentification->bit_mask & versionNumber_present) {
		VersionNumber.pOctetString =
			pVendorIdentification->versionNumber.value;
		VersionNumber.wOctetStringLength = (WORD)
			pVendorIdentification->versionNumber.length;
		VendorIDCallbackParams.pVersionNumber = &VersionNumber;
	} else
		VendorIDCallbackParams.pVersionNumber = NULL;

	InvokeUserConferenceCallback(pConference,
								 CC_VENDOR_ID_INDICATION,
								 CC_OK,
								 &VendorIDCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndH2250MaximumSkew(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCC_HCALL		CallList;
WORD			wNumCalls;
WORD			i;
PCALL			pCall;
PCALL			pOldCall;
CC_HCHANNEL		hChannel1;
PCHANNEL		pChannel1;
CC_HCHANNEL		hChannel2;
PCHANNEL		pChannel2;
CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS	MaximumAudioVideoSkewCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber1,
		                        FALSE,	// remote channel number
								RX_CHANNEL | PROXY_CHANNEL,
								hCall,
		                        &hChannel1,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel1, &pChannel1) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if (pChannel1->bChannelType == RX_CHANNEL) {
		UnlockChannel(pChannel1);
		if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2,
		                        FALSE,	// remote channel number
								RX_CHANNEL,
								hCall,
		                        &hChannel2,
								pConference) != CC_OK) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (LockChannel(hChannel2, &pChannel2) != CC_OK) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (pChannel2->bChannelType != RX_CHANNEL) {
			UnlockChannel(pChannel2);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		UnlockChannel(pChannel2);

		MaximumAudioVideoSkewCallbackParams.hChannel1 = hChannel1;
		MaximumAudioVideoSkewCallbackParams.hChannel2 = hChannel2;
		MaximumAudioVideoSkewCallbackParams.wMaximumSkew =
			pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew;
		InvokeUserConferenceCallback(pConference,
									 CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION,
									 CC_OK,
									 &MaximumAudioVideoSkewCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel1->bChannelType == PROXY_CHANNEL
		if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2,
									FALSE,	// remote channel number
									PROXY_CHANNEL,
									hCall,
									&hChannel2,
									pConference) != CC_OK) {
			UnlockChannel(pChannel1);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (LockChannel(hChannel2, &pChannel2) != CC_OK) {
			UnlockChannel(pChannel1);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (pChannel1->hCall != pChannel2->hCall) {
			UnlockChannel(pChannel1);
			UnlockChannel(pChannel2);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}

		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pOldCall) == CC_OK) {
 					H245H2250MaximumSkewIndication(pOldCall->H245Instance,
											pChannel1->wLocalChannelNumber,
											pChannel2->wLocalChannelNumber,
											pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew);
					UnlockCall(pCall);
				}
			}
		}

		if (CallList != NULL)
			MemFree(CallList);

		if ((pChannel1->tsAccepted == TS_TRUE) && (pChannel2->tsAccepted == TS_TRUE)) {
 			MaximumAudioVideoSkewCallbackParams.hChannel1 = hChannel1;
			MaximumAudioVideoSkewCallbackParams.hChannel2 = hChannel2;
			MaximumAudioVideoSkewCallbackParams.wMaximumSkew =
				pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew;
			InvokeUserConferenceCallback(pConference,
										 CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION,
										 CC_OK,
										 &MaximumAudioVideoSkewCallbackParams);
		}

		if (ValidateChannel(hChannel1) == CC_OK)
			UnlockChannel(pChannel1);
		if (ValidateChannel(hChannel2) == CC_OK)
			UnlockChannel(pChannel2);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}



HRESULT _IndUserInput(				H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_OK;
}



HRESULT _IndSendTerminalCapabilitySet(
									H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
PCONFERENCE		pConference;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	SendTermCaps(pCall, pConference);
	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndModeRequest(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_CALLBACK_PARAMS	RequestModeCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

    EnqueueRequest(&pConference->pEnqueuedRequestModeCalls, hCall);

	RequestModeCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		RequestModeCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	RequestModeCallbackParams.pRequestedModes =
		pH245ConfIndData->u.Indication.u.IndMrse.pRequestedModes;

	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_INDICATION,
								 CC_OK,
								 &RequestModeCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfUnimplemented(			H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_NOSUP;
}



HRESULT _ConfBiDirectionalOpen(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL			hCall;
CC_HCHANNEL			hChannel;
CC_HCONFERENCE		hConference;
PCHANNEL			pChannel;
PCONFERENCE			pConference;
BOOL				bAccept;
HRESULT				status;
CC_ADDR				T120Addr;
CC_OCTETSTRING		ExternalReference;
CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS	T120ChannelOpenCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (hCall == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	if (pChannel->bChannelType != TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		pChannel->wNumOutstandingRequests = 0;
		bAccept = TRUE;
	} else {
		(pChannel->wNumOutstandingRequests)--;
		bAccept = FALSE;
	}

	T120ChannelOpenCallbackParams.hChannel = hChannel;
	T120ChannelOpenCallbackParams.hCall = hCall;
	T120ChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;
	T120ChannelOpenCallbackParams.dwRejectReason = 0;

	if (bAccept) {
		status = CC_OK;
		if (pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack) {
			if ((pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.choice == localAreaAddress_chosen) &&
				(pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
				(pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.choice == UnicastAddress_iPAddress_chosen)) {
				T120Addr.nAddrType = CC_IP_BINARY;
				T120Addr.bMulticast = FALSE;
				T120Addr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier;
				H245IPNetworkToHost(&T120Addr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value);
				T120ChannelOpenCallbackParams.pAddr = &T120Addr;
			} else {
 				T120ChannelOpenCallbackParams.pAddr = NULL;
			}
			T120ChannelOpenCallbackParams.bAssociateConference =
				pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->associateConference;		
			if (pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->bit_mask & externalReference_present) {
				ExternalReference.wOctetStringLength = (WORD)
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->externalReference.length;
				ExternalReference.pOctetString =
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->externalReference.value;
				T120ChannelOpenCallbackParams.pExternalReference = &ExternalReference;
			} else
				T120ChannelOpenCallbackParams.pExternalReference = NULL;
		} else {
 			T120ChannelOpenCallbackParams.pAddr = NULL;
			T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
			T120ChannelOpenCallbackParams.pExternalReference = NULL;
		}
	} else { // bAccept == FALSE
		if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
			status = CC_PEER_REJECT;
		else
			status = pH245ConfIndData->u.Confirm.Error;
	 		
		T120ChannelOpenCallbackParams.pAddr = NULL;
		T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
		T120ChannelOpenCallbackParams.pExternalReference = NULL;
		T120ChannelOpenCallbackParams.dwRejectReason =
			pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej;
	}

	InvokeUserConferenceCallback(pConference,
								 CC_T120_CHANNEL_OPEN_INDICATION,
								 status,
								 &T120ChannelOpenCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		if (bAccept)
			UnlockChannel(pChannel);
		else
			FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _ConfOpenT120(	H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL			hCall;
CC_HCHANNEL			hChannel;
CC_HCONFERENCE		hConference;
PCHANNEL			pChannel;
PCONFERENCE			pConference;
HRESULT				status;
CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS	T120ChannelOpenCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (hCall == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	if (pChannel->bChannelType != TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		// We expect to get a ConfOpenNeedRsp callback for this case;
		// Since we're not sure how we got here, just bail out
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	T120ChannelOpenCallbackParams.hChannel = hChannel;
	T120ChannelOpenCallbackParams.hCall = hCall;
	T120ChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;

	if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
		status = CC_PEER_REJECT;
	else
		status = pH245ConfIndData->u.Confirm.Error;
	 		
	T120ChannelOpenCallbackParams.pAddr = NULL;
	T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
	T120ChannelOpenCallbackParams.pExternalReference = NULL;
	T120ChannelOpenCallbackParams.dwRejectReason =
		pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej;

	InvokeUserConferenceCallback(pConference,
								 CC_T120_CHANNEL_OPEN_INDICATION,
								 status,
								 &T120ChannelOpenCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _ConfOpen(					H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT								status;
CC_ADDR								PeerRTPAddr;
PCC_ADDR							pPeerRTPAddr;
CC_ADDR								PeerRTCPAddr;
PCC_ADDR							pPeerRTCPAddr;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS	TxChannelOpenCallbackParams;
PCALL								pCall;
BOOL								bAccept;
H245_MUX_T							H245MuxTable;
WORD								i;
#ifdef    GATEKEEPER
unsigned                            uBandwidth;
WORD								wNumCalls;
PCC_HCALL							CallList;
#endif // GATEKEEPER

	// a channel was opened

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	if (pChannel->bChannelType == TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return _ConfOpenT120(pH245ConfIndData);
	}

	hConference = pConference->hConference;

	if (pChannel->wNumOutstandingRequests == 0) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		pChannel->wNumOutstandingRequests = 0;
		bAccept = TRUE;
	} else {
		(pChannel->wNumOutstandingRequests)--;
		bAccept = FALSE;
#ifdef    GATEKEEPER
        if(GKIExists())
        {
    		uBandwidth = pChannel->dwChannelBitRate / 100;
    	    if (uBandwidth != 0 && pChannel->bChannelType != TXRX_CHANNEL)
    	    {
    	        EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
    		    for (i = 0; i < wNumCalls; ++i)
    		    {
    			    if (LockCall(CallList[i], &pCall) == CC_OK)
    			    {
    				    if (pCall->GkiCall.uBandwidthUsed >= uBandwidth)
    				    {
    					    if (GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel) == CC_OK)
    					    {
    						    UnlockCall(pCall);
    						    break;
    					    }
    				    }
    				    UnlockCall(pCall);
    			    }
    		    } // for
    	        if (CallList != NULL)
    	            MemFree(CallList);
    	    }
	    }
#endif // GATEKEEPER

	}
	
	if (pChannel->wNumOutstandingRequests == 0) {

		if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux == NULL) {
			pPeerRTPAddr = NULL;
			pPeerRTCPAddr = NULL;
		} else {
			ASSERT(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->Kind == H245_H2250ACK);
			if ((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannelPresent) &&
				((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_MULTICAST) ||
				(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_UNICAST))) {
				
				pPeerRTPAddr = &PeerRTPAddr;
				PeerRTPAddr.nAddrType = CC_IP_BINARY;
				if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_MULTICAST)
					PeerRTPAddr.bMulticast = TRUE;
				else
					PeerRTPAddr.bMulticast = FALSE;
				H245IPNetworkToHost(&PeerRTPAddr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.u.ip.network);
				PeerRTPAddr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.u.ip.tsapIdentifier;
			} else
				pPeerRTPAddr = NULL;

			if ((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannelPresent) &&
				((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_MULTICAST) ||
				(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_UNICAST))) {
				
				pPeerRTCPAddr = &PeerRTCPAddr;
				PeerRTCPAddr.nAddrType = CC_IP_BINARY;
				if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_MULTICAST)
					PeerRTCPAddr.bMulticast = TRUE;
				else
					PeerRTCPAddr.bMulticast = FALSE;
				H245IPNetworkToHost(&PeerRTCPAddr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.u.ip.network);
				PeerRTCPAddr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier;
			} else
				pPeerRTCPAddr = NULL;
		}

		if ((pPeerRTPAddr == NULL) || (pPeerRTCPAddr == NULL)) {
			if (pConference->pSessionTable != NULL) {
				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
						pChannel->bSessionID) {
						if (pPeerRTPAddr == NULL)
							pPeerRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						if (pPeerRTCPAddr == NULL)
							pPeerRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
						break;
					}
				}
			}
		}

		if ((pChannel->pPeerRTPAddr == NULL) && (pPeerRTPAddr != NULL))
			CopyAddr(&pChannel->pPeerRTPAddr, pPeerRTPAddr);
		if ((pChannel->pPeerRTCPAddr == NULL) && (pPeerRTCPAddr != NULL))
			CopyAddr(&pChannel->pPeerRTCPAddr, pPeerRTCPAddr);

		if (pChannel->bChannelType == PROXY_CHANNEL) {
			if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
	
				if (bAccept) {
					H245MuxTable.Kind = H245_H2250ACK;
					H245MuxTable.u.H2250ACK.nonStandardList = NULL;

					if (pPeerRTPAddr != NULL) {
						if (pPeerRTPAddr->bMulticast)
							H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
						else
							H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
						H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
							pPeerRTPAddr->Addr.IP_Binary.wPort;
						HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
											pPeerRTPAddr->Addr.IP_Binary.dwAddr);
						H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
					} else
						H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

					if (pPeerRTCPAddr != NULL) {
						if (pPeerRTCPAddr->bMulticast)
							H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
						else
							H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
						H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
							pPeerRTCPAddr->Addr.IP_Binary.wPort;
						HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
											pPeerRTCPAddr->Addr.IP_Binary.dwAddr);
						H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
					} else
						H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

					H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
					H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
					H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
					
					status = H245OpenChannelAccept(pCall->H245Instance,
												   0,					// dwTransId
												   pChannel->wRemoteChannelNumber, // Rx channel
												   &H245MuxTable,
												   0,						// Tx channel
												   NULL,					// Tx mux
												   H245_INVALID_PORT_NUMBER,// Port
												   NULL);
				} else { // bAccept == FALSE
					status = H245OpenChannelReject(pCall->H245Instance,
												   pChannel->wRemoteChannelNumber,  // Rx channel
												   (unsigned short)pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej);	// rejection reason
				}
				UnlockCall(pCall);
			}
		}

		TxChannelOpenCallbackParams.hChannel = hChannel;
		TxChannelOpenCallbackParams.pPeerRTPAddr = pPeerRTPAddr;
		TxChannelOpenCallbackParams.pPeerRTCPAddr = pPeerRTCPAddr;
		TxChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;

		if (bAccept) {
			status = CC_OK;
			TxChannelOpenCallbackParams.dwRejectReason = H245_ACC;
		} else { // bAccept = FALSE
			if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
				status = CC_PEER_REJECT;
			else
				status = pH245ConfIndData->u.Confirm.Error;
			TxChannelOpenCallbackParams.dwRejectReason =
				pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej;
		}

		if ((pChannel->bCallbackInvoked == FALSE) &&
		    ((pChannel->bChannelType == TX_CHANNEL) ||
			 ((pChannel->bChannelType == TXRX_CHANNEL) &&
			  (pChannel->bLocallyOpened == TRUE)))) {
			pChannel->bCallbackInvoked = TRUE;

			InvokeUserConferenceCallback(pConference,
										 CC_TX_CHANNEL_OPEN_INDICATION,
										 status,
										 &TxChannelOpenCallbackParams);
		}

		if (ValidateChannel(hChannel) == CC_OK)
			if (bAccept)
				UnlockChannel(pChannel);
			else
				FreeChannel(pChannel);
	} else
		UnlockChannel(pChannel);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfClose(					H245_CONF_IND_T			*pH245ConfIndData)
{

CC_HCALL							hCall;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
PCALL								pCall;
H245_ACC_REJ_T						AccRej;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

    if (pH245ConfIndData->u.Confirm.Error != H245_ERROR_OK)
    {
        // TBD - Report error to Call Control client
        // but wait! CC_CloseChannel() is a synchronous API!  Until/unless that
        // changes, the buck stops here.

        if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
			TRUE,	// local channel number
			TX_CHANNEL | PROXY_CHANNEL,
			hCall,
			&hChannel,
			pConference) != CC_OK)
	    {
    		UnlockConference(pConference);
	        return H245_ERROR_OK;
    	}
   		if (LockChannel(hChannel, &pChannel) != CC_OK)
   		{
    		UnlockConference(pConference);
    		return H245_ERROR_OK;
        }
        // NOTE STOPGAP MEASURE : short term intentional "leak" of channel number.
        // The channel number is actually a bit in a per-conference bitmap, so there
        // is no real memory leak.

        // This case is rare. The most likely error that leads here is a timeout.

        // Calling FreeChannel() will normally recycle the logical channel
        // number, and a new channel could reuse this number very quickly. If the error
        // is a timeout, chances are that a late CloseLogicalChannelAck is on its
        // way up the wire. We don't want that late CloseLogicalChannelAck to be
        // associated with a completely new unrelated channel.

        // set channel number to zero so that FreeChannel() does not recycle the number
        pChannel->wLocalChannelNumber = 0;

        FreeChannel(pChannel);
        UnlockConference(pConference);

    }
    else
    {
        if(pH245ConfIndData->u.Confirm.u.ConfClose.AccRej == H245_ACC)
        {
            if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
				TRUE,	// local channel number
    			TX_CHANNEL | PROXY_CHANNEL,
				hCall,
				&hChannel,
				pConference) != CC_OK)
		    {
        		UnlockConference(pConference);
		        return H245_ERROR_OK;
        	}
       		if (LockChannel(hChannel, &pChannel) != CC_OK)
       		{
        		UnlockConference(pConference);
        		return H245_ERROR_OK;
	        }
            FreeChannel(pChannel);
            UnlockConference(pConference);
        }
        else
        {
            // At the time the ASSERT(0) was added here, the path that leads here
            // always set pH245ConfIndData->u.Confirm.u.ConfClose.AccRej = H245_ACC
            // at the same point it set ConfInd.u.Confirm.Error = H245_ERROR_OK;
            // if that is ever changed, this also needs to change.
            // see ..\h245\src\api_up.c, function H245FsmConfirm(), case  H245_CONF_CLOSE:
            ASSERT(0);
        }

    }
	return H245_ERROR_OK;
}



HRESULT _ConfRequestClose(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
PCALL								pCall;
H245_ACC_REJ_T						AccRej;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

    if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
	    AccRej = pH245ConfIndData->u.Confirm.u.ConfReqClose.AccRej;
    else
        AccRej = H245_REJ;

	// Note: the only time we need to take any real action is when the channel
	// is a proxy channel, and the local endpoint is not the one which requested
	// the channel closure; in this case, we simply forward the closure response
	// on to the endpoint which initiated the request.
	// If the channel is an RX or TXRX channel, the channel object was deleted
	// when our client requested the channel closure, so there's no real work to
	// be done.
	// If the channel is a proxy channel which our client requested be closed,
	// the channel object will remain around until closed by the TX side, but we
	// don't need (nor do we have a mechanism) to inform our client of receipt
	// of this channel closure response.
	
	if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
								FALSE,	// remote channel number
								PROXY_CHANNEL,
								hCall,
								&hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	// Set hCall to the peer which initiated the close channel request
	hCall = pH245ConfIndData->u.Confirm.dwTransId;
	if (hCall == CC_INVALID_HANDLE) {
		// The local endpoint was the one who requested the channel closure,
		// so there's no one to forwards this response onto. We don't provide
		// a callback for informing our client of receipt of this response,
		// so we can simply clean up and return
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	// Forward this response onto the endpoint which requested the channel closure
	if (LockCall(hCall, &pCall) == CC_OK) {
		H245CloseChannelReqResp(pCall->H245Instance,
								AccRej,
								pChannel->wLocalChannelNumber);
		UnlockCall(pCall);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



#if 0

HRESULT _ConfShutdown(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL				hCall;
PCALL					pCall;
CC_HCONFERENCE			hConference;
PCONFERENCE				pConference;
HRESULT					status;
HQ931CALL				hQ931Call;
H245_INST_T				H245Instance;

#if 1
// Sync 2 - specific code

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	if (pConference->tsMultipointController == TS_TRUE) {
		// XXX -- invoke user callback with "peer drop indication"
	} else {
		H245Instance = pCall->H245Instance;
		hQ931Call = pCall->hQ931Call;
		FreeCall(pCall);

		if (H245Instance != H245_INVALID_ID)
			status = H245ShutDown(H245Instance);
		else
			status = H245_ERROR_OK;

		if (status == H245_ERROR_OK) {
			status = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (status == CS_BAD_PARAM)
				status = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

		InvokeUserConferenceCallback(pConference,
			                         CC_CONFERENCE_TERMINATION_INDICATION,
									 status,
									 NULL);

		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return H245_ERROR_OK;
	}
#else
// Probably sync 3 code
HHANGUP						hHangup;
PHANGUP						pHangup;
CC_HANGUP_CALLBACK_PARAMS	HangupCallbackParams;

	hHangup = pH245ConfIndData->u.Confirm.dwTransId;
	if (hHangup == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockHangup(hHangup, &pHangup) != CC_OK)
		return H245_ERROR_OK;

	pHangup->wNumCalls--;
	if (pHangup->wNumCalls == 0) {
		hConference = pHangup->hConference;
		if (LockConference(hConference, &pConference) != CC_OK) {
			UnlockHangup(pHangup);
			return H245_ERROR_OK;
		}
		HangupCallbackParams.dwUserToken = pHangup->dwUserToken;
		InvokeUserConferenceCallback(pConference->ConferenceCallback,
			                         CC_HANGUP_INDICATION,
									 CC_OK,
									 hConference,
									 pConference->dwConferenceToken,
									 &HangupCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateHangup(hHangup) == CC_OK)
			FreeHangup(pHangup);
		return H245_ERROR_OK;
	} else
		UnlockHangup(pHangup);
	return H245_ERROR_OK;
#endif // Sync 3 code
}

#endif



HRESULT _ConfInitMstslv(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CC_HCALL					hEnqueuedCall;
PCALL						pEnqueuedCall;
CC_HCONFERENCE				hConference;
HRESULT						status;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	ASSERT(pCall->MasterSlaveState != MASTER_SLAVE_COMPLETE);

	switch (pH245ConfIndData->u.Confirm.u.ConfMstSlv) {
        case H245_MASTER:
		    pConference->tsMaster = TS_TRUE;
		    if (pConference->tsMultipointController == TS_UNKNOWN) {
			    ASSERT(pConference->bMultipointCapable == TRUE);
			    pConference->tsMultipointController = TS_TRUE;

			    // place all calls enqueued on this conference object
			    for ( ; ; ) {
				    // Start up all enqueued calls, if any exist
				    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
				    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
					    break;

				    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
				    if (status == CC_OK) {
					    pEnqueuedCall->CallState = PLACED;

					    status = PlaceCall(pEnqueuedCall, pConference);
					    UnlockCall(pEnqueuedCall);
				    }
			    }
		    }
            break;

        case H245_SLAVE:
		    ASSERT(pConference->tsMaster != TS_TRUE);
		    ASSERT(pConference->tsMultipointController != TS_TRUE);
		    pConference->tsMaster = TS_FALSE;
		    pConference->tsMultipointController = TS_FALSE;

		    // XXX -- we may eventually want to re-enqueue these requests
		    // and set an expiration timer
		    hConference = pConference->hConference;
				
		    for ( ; ; ) {
			    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
			    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
				    break;

			    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
			    if (status == CC_OK) {
				    MarkCallForDeletion(pEnqueuedCall);
				    ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				    ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				    ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				    ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				    ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				    ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				    ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	                if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	                else
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				    ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				    ConnectCallbackParams.bMultipointConference = TRUE;
				    ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				    ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
					ConnectCallbackParams.pAlternateAddress = NULL;
				    ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				    InvokeUserConferenceCallback(pConference,
									    CC_CONNECT_INDICATION,
									    CC_NOT_MULTIPOINT_CAPABLE,
									    &ConnectCallbackParams);
				    if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					    FreeCall(pEnqueuedCall);
				    if (ValidateConference(hConference) != CC_OK) {
					    if (ValidateCall(hCall) == CC_OK)
						    UnlockCall(pCall);
					    return H245_ERROR_OK;
				    }
			    }
		    }
            break;

        default: // H245_INDETERMINATE
			UnlockConference(pConference);
			if (++pCall->wMasterSlaveRetry < MASTER_SLAVE_RETRY_MAX) {
				H245InitMasterSlave(pCall->H245Instance, pCall->H245Instance);
			    UnlockCall(pCall);
			} else {
			    UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
			}
			return H245_ERROR_OK;
	} // switch

	pCall->MasterSlaveState = MASTER_SLAVE_COMPLETE;

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfSendTermCap(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL		hCall;
PCALL			pCall;
HRESULT			status;
PCONFERENCE		pConference;

	// A TerminalCapabilitySet message was successfully sent from this endpoint

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

    if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK &&
        pH245ConfIndData->u.Confirm.u.ConfSndTcap.AccRej == H245_ACC) {
	    pCall->OutgoingTermCapState = TERMCAP_COMPLETE;
	    if ((pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	        (pCall->CallState == TERMCAP) &&
		    (pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		    // Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		    _ProcessConnectionComplete(pConference, pCall);
		    return H245_ERROR_OK;
	    }
    } else if (pCall->CallState == TERMCAP) {
        // Report error to Call Control client
		UnlockConference(pConference);
		UnlockCall(pCall);
		ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
	    return H245_ERROR_OK;
    }

	UnlockConference(pConference);
	UnlockCall(pCall);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestMode(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	switch (pH245ConfIndData->u.Confirm.u.ConfMrse) {
		case wllTrnsmtMstPrfrrdMd_chosen:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_WILL_TRANSMIT_PREFERRED_MODE;
			break;
		case wllTrnsmtLssPrfrrdMd_chosen:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_WILL_TRANSMIT_LESS_PREFERRED_MODE;
			break;
		default:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
	}
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestModeReject(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	switch (pH245ConfIndData->u.Confirm.u.ConfMrseReject) {
		case H245_REJ_UNAVAILABLE:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_MODE_UNAVAILABLE;
			break;
		case H245_REJ_MULTIPOINT:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_MULTIPOINT_CONSTRAINT;
			break;
		case H245_REJ_DENIED:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
		default:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
	}
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestModeExpired(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRoundTrip(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
HRESULT								status;
CC_PING_RESPONSE_CALLBACK_PARAMS	PingCallbackParams;	

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	PingCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PingCallbackParams.TerminalLabel.bMCUNumber = 255;
		PingCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		PingCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	PingCallbackParams.bResponse = TRUE;
	InvokeUserConferenceCallback(pConference,
								 CC_PING_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &PingCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRoundTripExpired(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
HRESULT								status;
CC_PING_RESPONSE_CALLBACK_PARAMS	PingCallbackParams;	

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	PingCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PingCallbackParams.TerminalLabel.bMCUNumber = 255;
		PingCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		PingCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	PingCallbackParams.bResponse = FALSE;
	InvokeUserConferenceCallback(pConference,
								 CC_PING_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &PingCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT H245Callback(				H245_CONF_IND_T			*pH245ConfIndData,
									void					*pMisc)
{
HRESULT	status = H245_ERROR_OK;

	EnterCallControl();

	if (CallControlState != OPERATIONAL_STATE)
		HResultLeaveCallControl(H245_ERROR_OK);

	if (pH245ConfIndData == NULL)
		HResultLeaveCallControl(H245_ERROR_OK);

	if (pH245ConfIndData->Kind == H245_CONF) {
		switch (pH245ConfIndData->u.Confirm.Confirm) {
			
			case H245_CONF_INIT_MSTSLV:
				status = _ConfInitMstslv(pH245ConfIndData);
				break;

			case H245_CONF_SEND_TERMCAP:
				status = _ConfSendTermCap(pH245ConfIndData);
				break;

			case H245_CONF_OPEN:
				status = _ConfOpen(pH245ConfIndData);
				break;

			case H245_CONF_NEEDRSP_OPEN:
				status = _ConfBiDirectionalOpen(pH245ConfIndData);
				break;

			case H245_CONF_CLOSE:
				status = _ConfClose(pH245ConfIndData);
				break;

			case H245_CONF_REQ_CLOSE:
				status = _ConfRequestClose(pH245ConfIndData);
				break;

//			case H245_CONF_MUXTBL_SND:      not valid for H.323 MuliplexEntrySend
//			case H245_CONF_RMESE:           not valid for H.323 RequestMultiplexEntry
//			case H245_CONF_RMESE_REJECT:    not valid for H.323 RequestMultiplexEntryReject
//			case H245_CONF_RMESE_EXPIRED:   not valid for H.323

			case H245_CONF_MRSE:
				status = _ConfRequestMode(pH245ConfIndData);
				break;

			case H245_CONF_MRSE_REJECT:
				status = _ConfRequestModeReject(pH245ConfIndData);
				break;

			case H245_CONF_MRSE_EXPIRED:
				status = _ConfRequestModeExpired(pH245ConfIndData);
				break;

			case H245_CONF_RTDSE:
				status = _ConfRoundTrip(pH245ConfIndData);
				break;

			case H245_CONF_RTDSE_EXPIRED:
				status = _ConfRoundTripExpired(pH245ConfIndData);
				break;

			default:
				status = _ConfUnimplemented(pH245ConfIndData);
				break;
		}
	} else if (pH245ConfIndData->Kind == H245_IND) {
		switch (pH245ConfIndData->u.Indication.Indicator) {
			
 			case H245_IND_MSTSLV:
				status = _IndMstslv(pH245ConfIndData);
				break;

			case H245_IND_CAP:
				status = _IndCapability(pH245ConfIndData);
				break;

			case H245_IND_CESE_RELEASE:
                // Remote has abandoned TerminalCapabilitySet
                // No longer need to send TerminalCapabilitySetAck
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

			case H245_IND_OPEN:
				status = _IndOpen(pH245ConfIndData);
				break;

			case H245_IND_OPEN_CONF:
                // Bi-directionl channel open complete
				status = _IndOpenConf(pH245ConfIndData);
				break;

			case H245_IND_CLOSE:
				status = _IndClose(pH245ConfIndData);
				break;

			case H245_IND_REQ_CLOSE:
				status = _IndRequestClose(pH245ConfIndData);
				break;

			case H245_IND_CLCSE_RELEASE:
                // Remote has abandoned RequestChannelClose
                // No longer need to send RequestChannelCloseAck and CloseLogicalChannel
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

//			case H245_IND_MUX_TBL:          not valid in H.323 MuliplexEntrySend
//			case H245_IND_MTSE_RELEASE      not valid in H.323 MuliplexEntrySendRelease
//			case H245_IND_RMESE             not valid in H.323 RequestMuliplexEntry
//			case H245_IND_RMESE_RELEASE     not valid in H.323 RequestMuliplexEntryRelease

			case H245_IND_MRSE:
				status = _IndModeRequest(pH245ConfIndData);
				break;

			case H245_IND_MRSE_RELEASE:
                // Remote has abandoned RequestMode
                // No longer need to send RequestModeAck or RequestModeReject
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

//			case H245_IND_MLSE:             We don't support looping back data

			case H245_IND_MLSE_RELEASE:
                // Required to accept this message
                break;

			case H245_IND_NONSTANDARD_REQUEST:
			case H245_IND_NONSTANDARD_RESPONSE:
			case H245_IND_NONSTANDARD_COMMAND:
			case H245_IND_NONSTANDARD:
				 status = _IndNonStandard(pH245ConfIndData);
				break;

			case H245_IND_MISC_COMMAND:
				status = _IndMiscellaneousCommand(pH245ConfIndData, pMisc);
				break;

			case H245_IND_MISC:
				status = _IndMiscellaneous(pH245ConfIndData, pMisc);
				break;
				
			case H245_IND_COMM_MODE_REQUEST:
				status = _IndUnimplemented(pH245ConfIndData); // TBD
				break;

//			case H245_IND_COMM_MODE_RESPONSE:   We never send request!

			case H245_IND_COMM_MODE_COMMAND:
				status = _IndCommunicationModeCommand(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_REQUEST:
				status = _IndConferenceRequest(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_RESPONSE:
				status = _IndConferenceResponse(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_COMMAND:
				status = _IndConferenceCommand(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE:
				status = _IndConference(pH245ConfIndData);
				break;
	
			case H245_IND_SEND_TERMCAP:
				status = _IndSendTerminalCapabilitySet(pH245ConfIndData);
				break;

//			case H245_IND_ENCRYPTION:       Not valid in H.323

			case H245_IND_FLOW_CONTROL:
				status = _IndFlowControl(pH245ConfIndData);
				break;

			case H245_IND_ENDSESSION:
				status = _IndEndSession(pH245ConfIndData);
				break;

			case H245_IND_FUNCTION_NOT_UNDERSTOOD:
				// We don't do anything with this but we still want to
                // return H245_ERROR_OK so H.245 does not sent
                // FunctionNotSupported back to remote peer!
				break;

			case H245_IND_JITTER:
                // It is ok to ignore this; no response is expected
                break;

//			case H245_IND_H223_SKEW:        Not valid in H.323
//			case H245_IND_NEW_ATM_VC:       Not valid in H.323

			case H245_IND_USERINPUT:
				status = _IndUserInput(pH245ConfIndData);
				break;

			case H245_IND_H2250_MAX_SKEW:
				status = _IndH2250MaximumSkew(pH245ConfIndData);
				break;

			case H245_IND_MC_LOCATION:
				status = _IndMCLocation(pH245ConfIndData);
				break;

			case H245_IND_VENDOR_ID:
				status = _IndVendorIdentification(pH245ConfIndData, pMisc);
				break;

			case H245_IND_FUNCTION_NOT_SUPPORTED:
				// We don't do anything with this but we still want to
                // return H245_ERROR_OK so H.245 does not sent
                // FunctionNotSupported back to remote peer!
				break;

//			case H245_IND_H223_RECONFIG:        Not valid in H.323
//			case H245_IND_H223_RECONFIG_ACK:    Not valid in H.323
//			case H245_IND_H223_RECONFIG_REJECT: Not valid in H.323
			default:
				status = _IndUnimplemented(pH245ConfIndData);
				break;
		}
	}
	HResultLeaveCallControl(status);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245plog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// AUTHOR       Stacy Bell
//
// DESCRIPTION
//              This file contains protocol logging definitions needed by H245 and
//              the H245 PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the H245 protocol as the one to be logged.  In the 
// H245 code, it is used only in the InteropLoad() call.  
// For example:  H245Logger = InteropLoad( H245LOG_PROTOCOL );
//
#define H245LOG_PROTOCOL "H245_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// H245 to the logging via user data.  Bit 1 represents whether the PDU
// was sent or received.
//

#define H245LOG_SENT_PDU                1UL
#define H245LOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245recv.c ===
/******************************************************************************
 *
 *  File:  h245recv.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245recv.c  $
 *  $Revision:   1.13  $
 *  $Modtime:   06 Feb 1997 18:17:22  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\h245recv.c_v  $
 *
 * Fixed warnings.
 *
 *    Rev 1.11   01 Nov 1996 15:24:56   EHOWARDX
 *
 * Added check for link not disconnected before re-posting receive buffer
 * to link layer to eliminate annoying error message from link layer.
 *
 *    Rev 1.10   22 Jul 1996 17:33:42   EHOWARDX
 * Updated to latest Interop API.
 *
 *    Rev 1.9   01 Jul 1996 16:14:32   EHOWARDX
 * locks
 * Added FunctionNotSupported if ossDecode fails.
 *
 *    Rev 1.8   10 Jun 1996 16:53:46   EHOWARDX
 * Removed special handling of EndSession since shutdown moved to InstanceUnlo
 *
 *    Rev 1.7   05 Jun 1996 17:14:28   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 *
 *    Rev 1.6   04 Jun 1996 18:18:16   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 *
 *    Rev 1.5   30 May 1996 23:39:10   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.4   28 May 1996 14:25:08   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.3   21 May 1996 13:40:46   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.2   17 May 1996 16:44:22   EHOWARDX
 * Changed to use LINK_RECV_CLOSED to signal link layer close.
 *
 *    Rev 1.1   17 May 1996 16:20:32   EHOWARDX
 * Added code to change API state if zero-length buffer received
 * signalling link layer closed.
 *
 *    Rev 1.0   09 May 1996 21:06:24   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.8.1.5   09 May 1996 19:33:58   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.17   29 Apr 1996 16:05:12   EHOWARDX
 * Added special case handling of EndSessionCommand to ReceiveComplete().
 *
 *    Rev 1.16   27 Apr 1996 21:13:14   EHOWARDX
 * Hope we finally got ossDecode() failure handling right...
 *
 *    Rev 1.15   27 Apr 1996 13:08:54   EHOWARDX
 * Also need to terminate while loop if ossDecode fails!
 *
 *    Rev 1.8.1.4   27 Apr 1996 11:25:36   EHOWARDX
 * Changed to not call FsmIncoming if ossDecode fails...
 *
 *
 *    Rev 1.8.1.3   25 Apr 1996 21:26:46   EHOWARDX
 * Changed to use pInstance->p_ossWorld instead of bAsnInitialized.
 *
 *    Rev 1.8.1.2   23 Apr 1996 14:44:30   EHOWARDX
 * Updated.
 *
 *    Rev 1.8.1.1   15 Apr 1996 15:12:00   EHOWARDX
 * Updated.
 *
 *    Rev 1.8.1.0   26 Mar 1996 19:15:24   EHOWARDX
 *
 * Commented out hTraceFile for H.323
 *
 *    Rev 1.8   21 Mar 1996 17:21:36   dabrown1
 *
 * - put in test1/2 trace fdwrite
 *
 *    Rev 1.7   13 Mar 1996 11:31:56   DABROWN1
 *
 * Enable logging for ring0
 *
 *    Rev 1.6   06 Mar 1996 13:13:04   DABROWN1
 *
 * flush receive buffer functionality
 *
 *    Rev 1.5   01 Mar 1996 17:25:54   DABROWN1
 *
 * moved oss 'world' context to h245instance
 * changed oss delete from ossFreeBuf to ossFreePDU
 *
 *    Rev 1.4   23 Feb 1996 13:56:04   DABROWN1
 *
 * added H245TRACE / ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 12:09:56   EHOWARDX
 * Eliminated unused local variables.
 *
 *    Rev 1.2   21 Feb 1996 08:25:08   DABROWN1
 *
 * Provide multiple buffers receiving > 1 message (ie., link ACKs).
 *
 *    Rev 1.1   13 Feb 1996 14:46:06   DABROWN1
 *
 * changed asnexp.h (no longer there) to fsmexp.h
 *
 *    Rev 1.0   09 Feb 1996 17:36:20   cjutzi
 * Initial revision.
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"



/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef  _IA_SPOX_
# define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
extern  LPInteropLogger H245Logger;
#endif  // (PCS_COMPLIANCE)

#ifdef  _IA_SPOX_
# undef _DLL
#endif //_IA_SPOX_



/**************************************************************************
** Function    : h245ReceiveComplete
** Description : Receive Completion Callback routine from link layer
***************************************************************************/

HRESULT
H245FunctionNotSupported(struct InstanceStruct *pInstance, unsigned short wChoice, unsigned char *pBuf, unsigned uLength)
{
    MltmdSystmCntrlMssg Pdu = {0};

    Pdu.choice = indication_chosen;
    Pdu.u.indication.choice = IndicationMessage_functionNotSupported_chosen;
    Pdu.u.indication.u.functionNotSupported.cause.choice = wChoice;
    if (pBuf != NULL && uLength != 0)
    {
        Pdu.u.indication.u.functionNotSupported.bit_mask = returnedFunction_present;
        Pdu.u.indication.u.functionNotSupported.returnedFunction.length = (WORD)uLength;
        Pdu.u.indication.u.functionNotSupported.returnedFunction.value  = pBuf;
    }
    else
    {
        Pdu.u.indication.u.functionNotSupported.bit_mask = 0;
    }
    return sendPDU(pInstance, &Pdu);
} // H245FunctionNotSupported()

void h245ReceiveComplete(DWORD_PTR h245Inst,
                         HRESULT dwMessage,
                         PBYTE   pbDataBuf,
                         DWORD   dwLength)
{
    struct InstanceStruct *pInstance;
    int                  pduNum = MltmdSystmCntrlMssg_PDU;
    ASN1_BUF             Asn1Buf;
    MltmdSystmCntrlMssg *pPdu;
    int                 nRet;

    // Validate the instance handle
    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
        H245TRACE(h245Inst, 1, "h245ReceiveComplete: Instance not found");
        return;
    }

    // ONLY submit buffers to the decoder if it's for data received,
    // skip for flushes
    switch (dwMessage) {
    case LINK_RECV_CLOSED:
        H245TRACE(h245Inst, 3, "h245ReceiveComplete: Link Layer closed");
        pInstance->API.SystemState = APIST_Disconnected;
        InstanceUnlock(pInstance);
        return;

    case LINK_RECV_DATA:

        if (pInstance->pWorld == NULL) {
            H245TRACE(h245Inst, 1, "h245ReceiveComplete: ASN.1 Decoder not initialized");
            InstanceUnlock(pInstance);
            return;
        }


        switch (pInstance->Configuration) {
        case H245_CONF_H324:
            Asn1Buf.value  = &pbDataBuf[2];
            Asn1Buf.length = dwLength;
            break;

        default:
            Asn1Buf.value  = pbDataBuf;
            Asn1Buf.length = dwLength;
        } // switch

        // Loop around as long as the length field is positive.
        // ASN.1 decoder will update the length for each PDU it decodes until
        // a 0 length is achieved.
        while (Asn1Buf.length > 0)
        {
            int savePduLength = Asn1Buf.length;
            PBYTE savePdu = Asn1Buf.value;
            pPdu = NULL;

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
            if (H245Logger)
                InteropOutput(H245Logger,
                              (BYTE FAR *)Asn1Buf.value,
                              (int)Asn1Buf.length,
                              H245LOG_RECEIVED_PDU);
#endif  // (PCS_COMPLIANCE)

            nRet = H245_Decode(pInstance->pWorld,
                            (void **)&pPdu,
                            pduNum,
                            &Asn1Buf);

            if (ASN1_SUCCEEDED(nRet))
            {
                // Decode succeeded

                H245TRACE(h245Inst, 3, "H.245 Msg decode successful");

                // Pass on data to finite state machine
                FsmIncoming(pInstance, pPdu);
            }
            else
            {
                // Decode failed
                H245FunctionNotSupported(pInstance, syntaxError_chosen, savePdu, savePduLength);
                Asn1Buf.length = 0;          // Terminate loop!
            }

            if (pPdu != NULL)
            {
                // Free the memory used by the ASN.1 library
                if (freePDU(pInstance->pWorld, pduNum, pPdu, H245ASN_Module))
                {
                H245TRACE(h245Inst, 1, "SR: FREE FAILURE");
                }
            }
        } // while (Asn1Buf.length > 0)

        if (pInstance->API.SystemState != APIST_Disconnected)
        {
            // Repost the buffer to the data link layer
            pInstance->SendReceive.hLinkReceiveReq(pInstance->SendReceive.hLinkLayerInstance,
                                                   pbDataBuf,
                                                   pInstance->SendReceive.dwPDUSize);
        }
        break; // case LINK_RECV_DATA

    case LINK_RECV_ABORT:
        // Receive buffer flush in process
        ASSERT(pbDataBuf != NULL);
        H245TRACE(h245Inst, 3, "SR: RX Flush Buffer");
        break;

    case LINK_FLUSH_COMPLETE:
        // Receive buffer flush done
        ASSERT(pbDataBuf == NULL);
        H245TRACE(h245Inst, 3, "SR: RX Flush Complete");
        pInstance->SendReceive.dwFlushMap &= ~DATALINK_RECEIVE;
        break;

    default:
        H245TRACE(h245Inst, 1, "SR: RX COMPLETE Error %d", dwMessage);
        break;
    } // switch
    InstanceUnlock(pInstance);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245sys.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245sys.c  $
 *  $Revision:   1.8  $
 *  $Modtime:   Mar 04 1997 17:38:08  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245sys.c_v  $
 *
 *    Rev 1.8   Mar 04 1997 17:51:56   tomitowx
 * process detach fix
 *
 *    Rev 1.7   24 Jan 1997 19:40:48   SBELL1
 * upgraded to oss 4.2
 *
 *    Rev 1.6   21 Jun 1996 18:53:22   unknown
 * Changed InstUnlock() to fix shutdown re-entrancy bug.
 *
 *    Rev 1.5   10 Jun 1996 16:59:34   EHOWARDX
 * Moved init/shutdown of submodules to CreateInstance/InstanceUnlock.
 *
 *    Rev 1.3   04 Jun 1996 13:57:02   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   28 May 1996 14:25:38   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   16 May 1996 13:51:26   EHOWARDX
 * Fixed minor timer/lock count interaction bugs.
 *
 *    Rev 1.0   09 May 1996 21:06:28   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.25   09 May 1996 19:39:04   EHOWARDX
 * Changed includes.
 *
 *    Rev 1.24   29 Apr 1996 12:56:58   EHOWARDX
 * Made timers more accurate & made them use fewer resources.
 * Note: This is windows-specific.
 *
 *    Rev 1.18.1.2   15 Apr 1996 15:12:34   EHOWARDX
 * Kludge to not call H245DeInitTimer() when last timer is stopped.
 * This will have to be revisited later.
 *
 *    Rev 1.18.1.1   02 Apr 1996 22:06:22   EHOWARDX
 * No change.
 *
 *    Rev 1.18.1.0   27 Mar 1996 16:44:18   EHOWARDX
 * Changed timer code; decided it would work better if H245InitTimer()
 * actually got called.
 *
 *    Rev 1.18   26 Mar 1996 09:46:08   cjutzi
 *
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 *
 *    Rev 1.17   25 Mar 1996 18:30:14   helgebax
 * - removed H245ASSERT .
 * .
 *
 *
 *    Rev 1.16   25 Mar 1996 18:10:48   cjutzi
 *
 * - well .. I broke the build.. had to put back what I did..
 *
 *
 *    Rev 1.15   25 Mar 1996 17:50:02   cjutzi
 *
 * - removed critical section.. back step
 *
 *    Rev 1.14   25 Mar 1996 17:20:34   cjutzi
 *
 * - added Remesh's EnterCritical section definitions.. to use
 *   oil layer.
 *
 *    Rev 1.13   18 Mar 1996 12:44:40   cjutzi
 *
 * - put NULL as callback at shutdown
 *
 *    Rev 1.12   18 Mar 1996 12:41:32   cjutzi
 * - added timer code for multiple timers queue..
 *
 *    Rev 1.11   12 Mar 1996 15:48:46   cjutzi
 *
 * - added InstanceTbl Lock
 *
 *    Rev 1.10   07 Mar 1996 22:47:34   dabrown1
 *
 * Modifications required for ring0/ring3 compatibilty
 *
 *    Rev 1.9   02 Mar 1996 22:14:52   DABROWN1
 *
 * removed h245_bzero and h245_bcopy (use memset and memcpy instead)
 *
 *    Rev 1.8   26 Feb 1996 17:10:56   cjutzi
 *
 * - removed h245sys.h
 *
 *    Rev 1.7   26 Feb 1996 12:42:26   cjutzi
 *
 * - added bcopy
 *
 *    Rev 1.6   21 Feb 1996 16:23:38   DABROWN1
 *
 * removed h245_ASN1free
 * modified malloc and free to save buffer size internally
 *
 *    Rev 1.5   13 Feb 1996 14:54:12   DABROWN1
 *
 * removed trace/debug files to new debug directory
 *
 *    Rev 1.4   09 Feb 1996 15:45:08   cjutzi
 * - added h245trace
 * - added h245Assert
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

/**************************************************************************
 *
 * Instance Table/Instance Lock implementation
 *
 **************************************************************************/

CRITICAL_SECTION        InstanceCreateLock     = {0};
CRITICAL_SECTION        InstanceLocks[MAXINST] = {0};
struct InstanceStruct * InstanceTable[MAXINST] = {0};

struct InstanceStruct *InstanceCreate(DWORD dwPhysId, H245_CONFIG_T Configuration)
{
  register struct InstanceStruct *pInstance;
  register unsigned int           uIndex;
  unsigned int                    uFirst = (dwPhysId - 1) % MAXINST;
  HRESULT                         lError;

  // Allocate new instance
  pInstance = (struct InstanceStruct *)MemAlloc(sizeof(*pInstance));
  if (pInstance == NULL)
  {
    H245TRACE(dwPhysId,1,"InstanceCreate -> Instance malloc failed");
    return NULL;
  }

  // Make sure no one is trying to simultaneously add same physical Id
  // (I know this is a stretch...)
  EnterCriticalSection(&InstanceCreateLock);

  // Check if instance corresponding to dwPhysId already exists
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for unused instances
    if (InstanceTable[uIndex])
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] && InstanceTable[uIndex]->dwPhysId == dwPhysId)
      {
        LeaveCriticalSection(&InstanceLocks[uIndex]);
        LeaveCriticalSection(&InstanceCreateLock);
        MemFree(pInstance);
        H245TRACE(dwPhysId,1,"InstanceCreate -> Physical Id already in use");
        return NULL;
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  // Find empty slot for new instance
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for used instances
    if (InstanceTable[uIndex] == NULL)
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] == NULL)
      {
        // Initialize new instance
        // Once the new instance is added to the instance table,
        // we can relinquish the CreateInstanceLock
        InstanceTable[uIndex] = pInstance;
        LeaveCriticalSection(&InstanceCreateLock);
        memset(pInstance, 0, sizeof(*pInstance));
        pInstance->dwPhysId  = dwPhysId;
        pInstance->dwInst    = uIndex + 1;
        pInstance->LockCount = 1;

        /* API Subsystem Initialization */
        pInstance->Configuration = Configuration;
        lError = api_init(pInstance);
        if (lError != H245_ERROR_OK)
        {
          InstanceTable[uIndex] = NULL;
          LeaveCriticalSection(&InstanceLocks[uIndex]);
          MemFree(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> api_init failed");
          return NULL;
        }

        /* Send Receive Subsystem Initialization */
        lError = sendRcvInit(pInstance);
        if (lError != H245_ERROR_OK)
        {
          api_deinit(pInstance);
          InstanceTable[uIndex] = NULL;
          LeaveCriticalSection(&InstanceLocks[uIndex]);
          MemFree(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> sendRcvInit failed");
          return NULL;
        }

        /* State Machine Subsystem Initialization */
        lError = Fsm_init(pInstance);
        if (lError != H245_ERROR_OK)
        {
          sendRcvShutdown(pInstance);
          api_deinit(pInstance);
          InstanceTable[uIndex] = NULL;
          LeaveCriticalSection(&InstanceLocks[uIndex]);
          MemFree(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> Fsm_init failed");
          return NULL;
        }

        H245TRACE(pInstance->dwInst,9,"InstanceCreate: ++LockCount=%d", pInstance->LockCount);
        return pInstance;                 // Return locked instance
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  LeaveCriticalSection(&InstanceCreateLock);
  MemFree(pInstance);
  H245TRACE(dwPhysId,1,"InstanceCreate -> Too many instances");
  return NULL;
} // InstanceCreate()

struct InstanceStruct *InstanceLock(register H245_INST_T dwInst)
{
  if (--dwInst >= MAXINST)
  {
    H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
    return NULL;
  }

  if (!InstanceTable[dwInst])
  {
      H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
      return NULL;
  }
  // Lock instance, then see if it still exists
  EnterCriticalSection(&InstanceLocks[dwInst]);
  if (InstanceTable[dwInst])
  {
    InstanceTable[dwInst]->LockCount++;
    H245TRACE(dwInst+1,9,"InstanceLock: ++LockCount=%d", InstanceTable[dwInst]->LockCount);
    return InstanceTable[dwInst];      // Return locked instance
  }
  LeaveCriticalSection(&InstanceLocks[dwInst]);
  H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
  return NULL;
} // InstanceLock()

int InstanceUnlock(struct InstanceStruct *pInstance)
{
  register H245_INST_T dwInst = pInstance->dwInst - 1;
  if (dwInst >= MAXINST || InstanceTable[dwInst] != pInstance)
  {
    H245TRACE(pInstance->dwInst,1,"InstanceUnlock -> Invalid instance");
    return -1;
  }
  if (pInstance->fDelete && pInstance->LockCount == 1)
  {
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: deleting instance");
    pInstance->fDelete = FALSE; // InstanceUnlock will be re-entered from H245WS callback!
    Fsm_shutdown(pInstance);
    sendRcvShutdown(pInstance);
    api_deinit(pInstance);
    InstanceTable[dwInst] = NULL;
    LeaveCriticalSection(&InstanceLocks[dwInst]);
    while (pInstance->pTimerList)
    {
      register TimerList_T *pTimer = pInstance->pTimerList;
      pInstance->pTimerList = pTimer->pNext;
      H245TRACE(pInstance->dwInst,1,"InstanceUnlock: deleting timer");
      MemFree(pTimer);
    }
    MemFree(pInstance);
  }
  else
  {
    pInstance->LockCount--;
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: --LockCount=%d", pInstance->LockCount);
    LeaveCriticalSection(&InstanceLocks[dwInst]);
  }
  return 0;
} // InstanceUnlock()

int InstanceDelete(struct InstanceStruct *pInstance)
{
  H245TRACE(pInstance->dwInst,9,"InstanceDelete");
  pInstance->fDelete = TRUE;
  return InstanceUnlock(pInstance);
} // InstanceDelete()



int InstanceUnlock_ProcessDetach(struct InstanceStruct *pInstance, BOOL fProcessDetach)
{
  register H245_INST_T dwInst = pInstance->dwInst - 1;
  if (dwInst >= MAXINST || InstanceTable[dwInst] != pInstance)
  {
    H245TRACE(pInstance->dwInst,1,"InstanceUnlock -> Invalid instance");
    return -1;
  }
  if (pInstance->fDelete && pInstance->LockCount == 1)
  {
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: deleting instance");
    pInstance->fDelete = FALSE; // InstanceUnlock will be re-entered from H245WS callback!

    Fsm_shutdown(pInstance);
    //sendRcvShutdown(pInstance);
    sendRcvShutdown_ProcessDetach(pInstance,fProcessDetach);

    api_deinit(pInstance);
    InstanceTable[dwInst] = NULL;
    LeaveCriticalSection(&InstanceLocks[dwInst]);
    while (pInstance->pTimerList)
    {
      register TimerList_T *pTimer = pInstance->pTimerList;
      pInstance->pTimerList = pTimer->pNext;
      H245TRACE(pInstance->dwInst,1,"InstanceUnlock: deleting timer");
      MemFree(pTimer);
    }
    MemFree(pInstance);
  }
  else
  {
    pInstance->LockCount--;
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: --LockCount=%d", pInstance->LockCount);
    LeaveCriticalSection(&InstanceLocks[dwInst]);
  }
  return 0;
} // InstanceUnlock_ProcessDetach()




/*****************************************************************************
 *
 * TYPE:  TIMER STUFF
 *
 *****************************************************************************/

CRITICAL_SECTION        TimerLock = {0};
static int              TimerInited = 0;
#ifndef _IA_SPOX_
static UINT_PTR         H245TimerId;
#endif

/*****************************************************************************
 *
 * TYPE:  Global System
 *
 * PROCEDURE:   H245TimerTick - ticks every 1000ms
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
void H245TimerTick (void)
{
  DWORD                           dwTickCount = GetTickCount();
  unsigned int                    uIndex;
  register struct InstanceStruct *pInstance;
  register TimerList_T           *pTimer;

  H245TRACE(0,9,"H245TimerTick <-");

  if (0 != TimerInited)
  {
    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      // Avoid entering critical section for unused instances
      if (InstanceTable[uIndex])
      {
        pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          while (pInstance->pTimerList && (pInstance->pTimerList->dwAlarm - dwTickCount) >= 0x80000000)
          {
            pTimer = pInstance->pTimerList;
            pInstance->pTimerList = pTimer->pNext;
            EnterCriticalSection(&TimerLock);
            if (--TimerInited == 0)
            {
#ifdef _IA_SPOX_
              H223_RegisterTimerCallBack((H223TIMERCB)NULL);
#else
              KillTimer (NULL, H245TimerId);
#endif
            }
            LeaveCriticalSection(&TimerLock);
            if (pTimer->pfnCallBack)
            {
              // TBD - what if pContext is no longer valid?
              (pTimer->pfnCallBack)(pInstance, (DWORD_PTR)pTimer, pTimer->pContext);
            }
            MemFree (pTimer);
          } // while
          InstanceUnlock(pInstance);
        } // if
      } // if
    } // for
  }
  H245TRACE(0,9,"H245TimerTick ->");
} // TimerTick()

/*****************************************************************************
 *
 * TYPE:  Global System
 *
 * PROCEDURE:   H245TimerProc - FOR WINDOWS Ring 3 only
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
#ifndef _IA_SPOX_
void CALLBACK  H245TimerProc(HWND  hwHwnd,
                             UINT  uiMessg,
                             UINT_PTR idTimer,
                             DWORD dwTime)
{
  if (idTimer == H245TimerId)
    H245TimerTick ();
}
#endif

/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245StartTimer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
DWORD_PTR H245StartTimer (struct InstanceStruct *   pInstance,
                      void                  *   pContext,
                      H245TIMERCALLBACK         pfnCallBack,
                      DWORD                     dwTicks)
{
  TimerList_T   *pNew;
  TimerList_T   *pLook;
  TimerList_T   *pList;

  if (!pfnCallBack)
  {
    H245TRACE(pInstance->dwInst,1,"H245StartTimer: pfnCallBack == NULL");
    return 0;
  }

  pNew = (TimerList_T *)MemAlloc(sizeof(TimerList_T));
  if (pNew == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StartTimer: memory allocation failed");
    return 0;
  }

  pNew->pNext       = NULL;
  pNew->pContext    = pContext;
  pNew->pfnCallBack = pfnCallBack;
  pNew->dwAlarm     = GetTickCount() + dwTicks;

  EnterCriticalSection(&TimerLock);
  if (++TimerInited == 1)
  {
#ifdef _IA_SPOX_
    H223_RegisterTimerCallBack((H223TIMERCB)H245TimerTick);
#else
    H245TimerId = SetTimer ((HWND)NULL, (UINT)0, (UINT)1000, H245TimerProc);
#endif
  }
  LeaveCriticalSection(&TimerLock);

  /* as you traverse the list.. subtract the delta off the new one */
  /* and link it in.. this list is a list of delta's off the time  */
  /* out that is linked in front of it.. so subtract as you go     */
  for (pList = NULL, pLook = pInstance->pTimerList;
       pLook && (pLook->dwAlarm - pNew->dwAlarm) >= 0x80000000;
       pList = pLook, pLook = pLook->pNext);

  /* link it in the list */
  pNew->pNext = pLook;
  if (pList)
  {
    // Insert new timer after pList and before pLook
    pList->pNext = pNew;
  }
  else
  {
    // Insert new timer at front of list
    pInstance->pTimerList = pNew;
  }
  return (DWORD_PTR)pNew;
}


/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245StopTimer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
DWORD H245StopTimer(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId)
{
  TimerList_T   *pTimer = (TimerList_T *)dwTimerId;
  TimerList_T   *pLook;
  TimerList_T   *pList;

  ASSERT(TimerInited != 0);

  EnterCriticalSection(&TimerLock);
  if (--TimerInited == 0)
  {
#ifdef _IA_SPOX_
    H223_RegisterTimerCallBack((H223TIMERCB)NULL);
#else
    KillTimer (NULL, H245TimerId);
#endif
  }
  LeaveCriticalSection(&TimerLock);

  if (pInstance->pTimerList == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StopTimer: timer list NULL");
    return TRUE;
  }

  if (pTimer == pInstance->pTimerList)
  {
    pInstance->pTimerList = pTimer->pNext;
    MemFree (pTimer);
    return FALSE;
  }

  pList = pInstance->pTimerList;
  pLook = pList->pNext;
  while (pLook && pLook != pTimer)
  {
     pList = pLook;
     pLook = pLook->pNext;
  }

  /* if the timer exists.. */
  if (pLook == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StopTimer: pTimer not in timer list");
    return TRUE;
  }

  pList->pNext = pTimer->pNext;
  MemFree (pTimer);
  return FALSE;
}

#ifdef _IA_SPOX_
PUBLIC RESULT InitializeCriticalSection(CRITICAL_SECTION * phLock)

{
  return OIL_CreateLock(phLock);
}

PUBLIC RESULT EnterCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_AcquireLock(*phLock);
}

PUBLIC RESULT LeaveCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_ReleaseLock(*phLock);
}

PUBLIC RESULT DeleteCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_DeleteLock(*phLock);
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245send.c ===
/******************************************************************************
 *
 *  File:  h245send.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245send.c  $
 *  $Revision:   1.8  $
 *  $Modtime:   22 Jul 1996 17:24:18  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245send.c_v  $
 *
 *    Rev 1.8   22 Jul 1996 17:33:28   EHOWARDX
 * Updated to latest Interop API.
 *
 *    Rev 1.7   05 Jun 1996 17:14:30   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 *
 *    Rev 1.6   04 Jun 1996 18:18:18   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 *
 *    Rev 1.5   30 May 1996 23:39:12   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.4   28 May 1996 14:25:18   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.3   21 May 1996 13:40:48   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.2   20 May 1996 14:35:14   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.1   17 May 1996 16:19:46   EHOWARDX
 * Changed sendPDU to return an error if link layer send fails.
 * (Probably should define a new error code for this...)
 *
 *    Rev 1.0   09 May 1996 21:06:26   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.11.1.4   09 May 1996 19:34:46   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.11.1.3   25 Apr 1996 21:27:14   EHOWARDX
 * Changed to use pInstance->p_ossWorld instead of bAsnInitialized.
 *
 *    Rev 1.11.1.2   23 Apr 1996 14:44:34   EHOWARDX
 * Updated.
 *
 *    Rev 1.11.1.1   15 Apr 1996 15:12:04   EHOWARDX
 * Updated.
 *
 *    Rev 1.11.1.0   26 Mar 1996 19:14:46   EHOWARDX
 *
 * Commented out hTraceFile for H.323
 *
 *    Rev 1.11   21 Mar 1996 17:20:40   dabrown1
 * - put in test1/2 trace fdwrite
 * .
 *
 * .
 *
 *
 *
 *
 *    Rev 1.10   13 Mar 1996 11:31:14   DABROWN1
 *
 * Enable logging for ring0
 *
 *    Rev 1.9   11 Mar 1996 15:32:06   DABROWN1
 *
 * Defined/Undefined _DLL for _IA_SPOX_ environment
 *
 *    Rev 1.8   06 Mar 1996 13:11:44   DABROWN1
 *
 * enable flush buffers
 *
 *    Rev 1.7   02 Mar 1996 22:10:26   DABROWN1
 * updated to new MemFree
 *
 *    Rev 1.6   01 Mar 1996 17:25:14   DABROWN1
 *
 * moved oss 'world' context to h245instance
 * delete buffer returned in sendcomplete instead of what was held in context
 *
 *    Rev 1.5   28 Feb 1996 14:52:18   DABROWN1
 * Put oss errors in range of SR (10000)
 *
 *    Rev 1.4   23 Feb 1996 13:56:30   DABROWN1
 *
 * added H245TRACE / ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 16:52:52   DABROWN1
 *
 * correct pointer passed to SRP for transmits
 *
 *    Rev 1.2   21 Feb 1996 10:50:42   EHOWARDX
 * Got rid of unreferenced local variable.
 *
 *    Rev 1.1   21 Feb 1996 08:24:20   DABROWN1
 * allocate/deallocate send buffers per message.  Enable sendComplete functiot
 *
 *    Rev 1.0   09 Feb 1996 17:37:42   cjutzi
 * Initial revision.
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"


/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef   _IA_SPOX_
#define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
extern  LPInteropLogger H245Logger;
#endif  // (PCS_COMPLIANCE)

#ifdef   _IA_SPOX_
#undef  _DLL
#endif //_IA_SPOX_



/**************************************************************************
**  Function    : sendPDU
**  Description : Convert struct to ASN.1 PDU and forward to datalink layer
***************************************************************************/
HRESULT sendPDU(struct InstanceStruct  *pInstance,
                MltmdSystmCntrlMssg    *lp245MsgStruct)
{
    HRESULT         lError;
    ASN1_BUF        Asn1Buf;
    PBYTE           pEncoded_pdu;
    int             nRet;

    // Set up the oss struct for passing a pre-allocated buffer
    switch (pInstance->Configuration) {
    case H245_CONF_H324:
        // Allocate a buffer to transmit
        pEncoded_pdu = MemAlloc(pInstance->SendReceive.dwPDUSize);
        if (pEncoded_pdu == NULL) {
            H245TRACE(pInstance->dwInst, 1, "H245Send: No memory");
            return H245_ERROR_NOMEM;
        }
        Asn1Buf.value  = &pEncoded_pdu[2];
        Asn1Buf.length = pInstance->SendReceive.dwPDUSize - 4;
        break;

    case H245_CONF_H323:
        // Allocate a buffer to transmit
        pEncoded_pdu = MemAlloc(pInstance->SendReceive.dwPDUSize);
        if (pEncoded_pdu == NULL) {
            H245TRACE(pInstance->dwInst, 1, "H245Send: No memory");
            return H245_ERROR_NOMEM;
        }
        Asn1Buf.value  = pEncoded_pdu;
        Asn1Buf.length = pInstance->SendReceive.dwPDUSize;
        break;

    default:
        H245TRACE(pInstance->dwInst,
                  1,
                  "SR: Unknown Configuration %d",
                  pInstance->Configuration);
        return H245_ERROR_SUBSYS;
    }

    nRet = H245_Encode(pInstance->pWorld,
                       (void *)lp245MsgStruct,
                       MltmdSystmCntrlMssg_PDU,
                       &Asn1Buf);

    if (ASN1_SUCCEEDED(nRet))
    {
        H245TRACE(pInstance->dwInst, 3, "H245: Msg Encode Successful");

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
        if (H245Logger)
            InteropOutput(H245Logger,
                          (BYTE FAR*)(pEncoded_pdu),
                          (int)Asn1Buf.length,
                          H245LOG_SENT_PDU);
#endif  // (PCS_COMPLIANCE)

        lError = pInstance->SendReceive.hLinkSendReq(pInstance->SendReceive.hLinkLayerInstance,
                                                     pEncoded_pdu,
                                                     Asn1Buf.length);
    }
    else
    {
        MemFree(pEncoded_pdu);
        lError = H245_ERROR_ASN1;
    }

    return lError;
}


/**************************************************************************
**  Function    : h245SendComplete
**  Description : Send Completion Callback routine from link layer
***************************************************************************/

void h245SendComplete(   DWORD_PTR   h245Inst,
                         HRESULT dwMessage,
                         PBYTE   pbDataBuf,
                         DWORD   dwLength)
{
    struct InstanceStruct *pInstance;

    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
        H245TRACE(h245Inst, 1, "SR: h245SendComplete - invalid instance");
        return;
    }

    // Return the buffer
    if (pbDataBuf) {
        MemFree(pbDataBuf);
    }

    switch (dwMessage) {
    case LINK_SEND_COMPLETE:
        if (pInstance->SendReceive.dwFlushMap & SHUTDOWN_PENDING) {
            H245TRACE(h245Inst, 10, "SR: Shutdown Complete");
        }
        break;
    case LINK_SEND_ABORT:
        H245TRACE(h245Inst, 10, "SR: TX Abort Buffer");
        break;
    case LINK_FLUSH_COMPLETE:
        // If we are in the process of abort, then the next and
        // last mesage out will be the endSession
        H245TRACE(h245Inst, 10, "SR: TX Flush Complete");

        // Indicate Transmit buffer flush is complete
        pInstance->SendReceive.dwFlushMap ^= DATALINK_TRANSMIT;

        // If all requested queues have been flushed, call the
        //  appropriate callback routing
        switch (pInstance->SendReceive.dwFlushMap & SHUTDOWN_MASK) {
        case 0:
            // TBD: Who is interested in callback if not in connection
            //  with shutdown?
            break;
        case SHUTDOWN_PENDING:
            // Flush buffers completed, and shutdown in progress
            //  notify the API
            H245TRACE(h245Inst, 20, "SR: SHUTDOWN CALLBACK");
            break;
        default:
            // Still waiting for buffers to be flushed. No action now
            break;
        }  // switch (pInstance->SendReceive.dwFlushMap & SHUTDOWN_MASK) {
        break;
    default:
        H245TRACE(h245Inst, 10, "SR: SendComplete");
        break;
    }
    InstanceUnlock(pInstance);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245ws.h ===
/***************************************************************************
 *
 * File: h245ws.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245ws.h  $
 * $Revision:   1.19  $
 * $Modtime:   31 Jan 1997 15:56:32  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\h245ws.h_v  $
 *
 *    Rev 1.19   31 Jan 1997 16:23:34   SBELL1
 * Got rid of unused next pointer and put in definition of SocketTOPhysicalID
 *
 *    Rev 1.18   13 Dec 1996 12:13:06   SBELL1
 * moved ifdef _cplusplus to after includes
 *
 *    Rev 1.17   11 Dec 1996 13:45:36   SBELL1
 * Changed table/locks to use tstable.h stuff.
 *
 *    Rev 1.16   21 Jun 1996 18:51:44   unknown
 * Fixed yet another shutdown bug - linkLayerShutdown re-entrancy check.
 *
 *    Rev 1.14   17 May 1996 16:49:36   EHOWARDX
 * Shutdown fix.
 *
 *    Rev 1.13   16 May 1996 13:09:50   EHOWARDX
 * Made reporting of IP Addres and port consistent between linkLayerListen
 * and LinkLayerConnect.
 *
 *    Rev 1.12   09 May 1996 18:33:06   EHOWARDX
 *
 * Changes to build with new LINKAPI.H.
 *
 *    Rev 1.11   Apr 29 1996 14:02:28   plantz
 * Delete unused or private functions.
 *
 *    Rev 1.10   Apr 29 1996 12:15:38   plantz
 * Remove unused members of HWSINST structure.
 *
 *    Rev 1.9   Apr 24 1996 20:46:58   plantz
 * Changed ListenCallback to ConnectCallback in HWSINST structure.
 *
 *    Rev 1.8   Apr 24 1996 16:24:14   plantz
 * Change to use winsock 1 and not use overlapped I/O.
 *
 *    Rev 1.7   01 Apr 1996 14:20:38   unknown
 * Shutdown redesign.
 *
 *    Rev 1.6   27 Mar 1996 13:01:28   EHOWARDX
 * Added dwThreadId to H245WS instance structure.
 *
 *    Rev 1.5   19 Mar 1996 20:21:46   EHOWARDX
 * Redesigned shutdown.
 *
 *    Rev 1.3   18 Mar 1996 19:07:10   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 *
 *    Rev 1.2   14 Mar 1996 17:01:50   EHOWARDX
 *
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 *
 *    Rev 1.1   09 Mar 1996 21:12:58   EHOWARDX
 * Fixes as result of testing.
 *
 *    Rev 1.0   08 Mar 1996 20:17:56   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef H245WS_H
#define H245WS_H

#ifndef STRICT
#define STRICT
#endif



#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus

/*
 * Constants
 */

#define SUCCESS         0
#define TPKT_VERSION    3
#define TPKT_HEADER_SIZE 4

// Indexes of permanent events in Events[]
#define EVENT_SOCKET    0
#define EVENT_RECV      1
#define EVENT_SEND      2
#define EVENT_FIRST     3



// Values for byLevel
#define HWS_CRITICAL    0x01
#define HWS_ERROR       0x02
#define HWS_WARNING     0x04
#define HWS_NOTIFY      0x08
#define HWS_TRACE       0x10
#define HWS_TEMP        0x20

#if defined(_DEBUG)
 void HwsTrace (DWORD dwInst, BYTE byLevel, LPSTR pszFormat, ...);
 #define HWSASSERT ASSERT
 #define HWSTRACE0(dwH245Instance,byLevel,a) HwsTrace(dwH245Instance,byLevel,a)
 #define HWSTRACE1(dwH245Instance,byLevel,a,b) HwsTrace(dwH245Instance,byLevel,a,b)
 #define HWSTRACE2(dwH245Instance,byLevel,a,b,c) HwsTrace(dwH245Instance,byLevel,a,b,c)
 #define HWSTRACE3(dwH245Instance,byLevel,a,b,c,d) HwsTrace(dwH245Instance,byLevel,a,b,c,d)
 #define HWSTRACE4(dwH245Instance,byLevel,a,b,c,d,e) HwsTrace(dwH245Instance,byLevel,a,b,c,d,e)
 #define HWSTRACE5(dwH245Instance,byLevel,a,b,c,d,e,f) HwsTrace(dwH245Instance,byLevel,a,b,c,d,e,f)
#else   // (_DEBUG)
 #define HWSASSERT(exp)
 #define HWSTRACE0(dwH245Instance,byLevel,a)
 #define HWSTRACE1(dwH245Instance,byLevel,a,b)
 #define HWSTRACE2(dwH245Instance,byLevel,a,b,c)
 #define HWSTRACE3(dwH245Instance,byLevel,a,b,c,d)
 #define HWSTRACE4(dwH245Instance,byLevel,a,b,c,d,e)
 #define HWSTRACE5(dwH245Instance,byLevel,a,b,c,d,e,f)
#endif  // (_DEBUG)


// This structure is used for overlapped sends and receives
typedef struct _IO_REQUEST
{
   struct _HWSINST * req_pHws;         // Pointer back to socket data
   BYTE              req_TpktHeader[TPKT_HEADER_SIZE];
   int               req_header_bytes_done;
   BYTE            * req_client_data;
   int               req_client_length;
   int               req_client_bytes_done;
   DWORD             req_dwMagic;      // Request type (send or receive)
#define RECV_REQUEST_MAGIC 0x91827364
#define SEND_REQUEST_MAGIC 0x19283746
} REQUEST, *PREQUEST;



typedef struct _HWSINST
{
   UINT              hws_uState;
#define HWS_START          0
#define HWS_LISTENING      1  /* Waiting for FD_ACCEPT                     */
#define HWS_CONNECTING     2  /* Waiting for FD_CONNECT                    */
#define HWS_CONNECTED      3  /* Data transfer state                       */
#define HWS_CLOSING        4  /* Waiting for FD_CLOSE                      */
#define HWS_CLOSED         5  /* Waiting for linkLayerShutdown()           */
#define HWS_SHUTDOWN       6  /* linkLayerShutdown() called from callback  */

   DWORD             hws_dwPhysicalId;
   DWORD_PTR         hws_dwH245Instance;
   H245CONNECTCALLBACK hws_h245ConnectCallback;
   H245SRCALLBACK    hws_h245RecvCallback;
   H245SRCALLBACK    hws_h245SendCallback;
   SOCKET            hws_Socket;
   SOCKADDR_IN       hws_SockAddr;
   UINT              hws_uSockAddrLen;

   // points to a queue used to hold send buffers
   PQUEUE            hws_pSendQueue;

   // points to a queue used to hold receive buffers
   PQUEUE            hws_pRecvQueue;

   // The maximum message size we can send on this socket.
   // This value is either an integer or the manifest constant NO_MAX_MSG_SIZE.
   UINT              hws_uMaxMsgSize;
   BOOL              hws_bCloseFlag;

#if defined(_DEBUG)
   DWORD             hws_dwMagic;      // Request type (send or receive)
#define HWSINST_MAGIC   0x12345678
#endif  // (_DEBUG)

} HWSINST, *PHWSINST;


typedef struct _SOCKET_TO_INSTANCE
{
	SOCKET socket;
	DWORD dwPhysicalId;
	struct _SOCKET_TO_INSTANCE *next;
} SOCKET_TO_INSTANCE, *PSOCKET_TO_INSTANCE;

#define SOCK_TO_PHYSID_TABLE_SIZE		251

////////////////////////////////////////////////////////////////////////////
//
// Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE_TRACE
LPCTSTR
#else
const char *
#endif
SocketErrorText(void);

//PHWSINST FindPhysicalId(DWORD dwPhysicalId);
void NotifyRead        (PHWSINST pHws);
void NotifyWrite       (PHWSINST pHws);
void ProcessQueuedRecvs(PHWSINST pHws);
void ProcessQueuedSends(PHWSINST pHws);
void SocketCloseEvent  (PHWSINST pHws);
DWORD SocketToPhysicalId (SOCKET socket);
BOOL CreateSocketToPhysicalIdMapping(SOCKET socket, DWORD dwPhysicalId);
BOOL RemoveSocketToPhysicalIdMapping(SOCKET socket);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)


#endif  // H245WS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245wstx.cpp ===
/***************************************************************************
 *
 * File: h245wstx.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245wstx.cpp  $
 * $Revision:   2.4  $
 * $Modtime:   30 Jan 1997 17:15:58  $
 * $Log:   S:/STURGEON/SRC/H245WS/VCS/h245wstx.cpv  $
 * 
 *    Rev 2.4   30 Jan 1997 17:18:02   EHOWARDX
 * Fixed bug in trace message - need to do trace before
 * calling shutdown() sent shutdown clears error retrieved
 * by WSAGetLastError().
 * 
 *    Rev 2.3   14 Jan 1997 15:49:00   EHOWARDX
 * Changed TryRecv() and TrySend() to check for WSAECONNRESET and
 * WSAECONNABORT return from recv() and send() and act accordingly.
 * 
 *    Rev 2.2   19 Dec 1996 18:55:12   SBELL1
 * took out tag comments
 * 
 *    Rev 2.1   Dec 13 1996 17:33:24   plantz
 * moved #ifdef _cplusplus to after include files
// 
//    Rev 1.1   13 Dec 1996 12:12:02   SBELL1
// moved #ifdef _cplusplus to after include files
// 
//    Rev 1.0   11 Dec 1996 13:41:54   SBELL1
// Initial revision.
 * 
 *    Rev 1.16   May 28 1996 18:14:40   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.15   17 May 1996 16:49:34   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.14   09 May 1996 18:33:20   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.13   29 Apr 1996 16:53:28   EHOWARDX
 * 
 * Added trace statement.
 * 
 *    Rev 1.12   Apr 29 1996 14:04:38   plantz
 * Call NotifyWrite instead of ProcessQueuedSends.
 * 
 *    Rev 1.11   Apr 29 1996 12:15:04   plantz
 * Change tpkt header to include header size in packet length.
 * Assert that message length does not exceed INT_MAX.
 * .
 * 
 *    Rev 1.10   27 Apr 1996 14:46:24   EHOWARDX
 * Parenthesized TrySend() return.
 * 
 *    Rev 1.9   Apr 24 1996 16:41:30   plantz
 * Merge 1.5.1.0 with 1.8 (changes for winsock 1).
 * 
 *    Rev 1.5.1.0   Apr 24 1996 16:22:22   plantz
 * Change to not use overlapped I/O (for winsock 1).
 * 
 *    Rev 1.5   01 Apr 1996 14:20:44   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.4   19 Mar 1996 20:18:20   EHOWARDX
 * 
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:08:32   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:02:02   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:30   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:20:06   unknown
 * Initial revision.
 *
 ***************************************************************************/

#define LINKDLL_EXPORT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include "precomp.h"

#include <limits.h>
//#include <winsock.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "tstable.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


// If we are using not using the Unicode version of the IRS display utility, then
// redefine the __TEXT macro to do nothing.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

extern TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table

static void SetupTPKTHeader(BYTE *tpkt_header, DWORD length);

/*++

Description:
   Attempt to send

Arguments:
   pHws              - Pointer to context for "connection"
   pReq              - Pointer to I/O request structure

Return Value:
   SUCCESS                       - Successfully started send.
   LINK_SEND_ERROR_WOULD_BLOCK   - 
   LINK_SEND_ERROR_CLOSED        - The socket was gracefully closed.
   LINK_SEND_ERROR_ERROR         - Error receiving data.

--*/

static HRESULT
TrySend(IN PHWSINST pHws, IN const char *data, IN int length, IN OUT int *total_bytes_sent)
{
   int requested_length = length - *total_bytes_sent;
   int send_result = send(pHws->hws_Socket, data+*total_bytes_sent, requested_length, 0);

   if (send_result == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         return LINK_SEND_WOULD_BLOCK;

      case WSAECONNABORTED:
      case WSAECONNRESET:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TrySend: send() returned %s"),
                   SocketErrorText());
         if (pHws->hws_uState == HWS_CONNECTED)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                      __TEXT("TrySend: calling shutdown"));
            if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
            {
               HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                        __TEXT("TrySend: shutdown() returned %s"),
                        SocketErrorText());
            }
            pHws->hws_uState = HWS_CLOSING;
         }
         return MAKE_WINSOCK_ERROR(err);

      default:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TrySend: send() returned %s"),
                   SocketErrorText());
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   }

   HWSTRACE1(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("TrySend: send returned %d"), send_result);
   *total_bytes_sent += send_result;
   return (send_result == requested_length) ? NOERROR : LINK_SEND_WOULD_BLOCK;
}


static HRESULT
SendStart(IN PHWSINST pHws, IN PREQUEST pReq)
{
   HRESULT nResult = NOERROR;

   // Sanity checks
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pReq != NULL);
   HWSASSERT(pReq->req_dwMagic == SEND_REQUEST_MAGIC);
   HWSASSERT(pReq->req_pHws == pHws);

   // Send the header first; if that succeeds send the client data
   if (pReq->req_header_bytes_done < TPKT_HEADER_SIZE)
   {
       nResult = TrySend(pHws,
                         (const char *)pReq->req_TpktHeader,
                         TPKT_HEADER_SIZE,
                         &pReq->req_header_bytes_done);
   }

   if (nResult == NOERROR)
   {
       nResult = TrySend(pHws,
                         (const char *)pReq->req_client_data,
                         pReq->req_client_length,
                         &pReq->req_client_bytes_done);
   }

   return nResult;
} // SendStart()


void
ProcessQueuedSends(IN PHWSINST pHws)
{
   register PREQUEST    pReq;
   register DWORD       dwPhysicalId = pHws->hws_dwPhysicalId;

   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pHws->hws_uState <= HWS_CONNECTED);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("ProcessQueuedSends"));

   while ((pReq = (PREQUEST)QRemove(pHws->hws_pSendQueue)) != NULL)
   {
      switch (SendStart(pHws, pReq))
      {
      case NOERROR:
         // Call Send callback
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_COMPLETE,
                                    pReq->req_client_data,
                                    pReq->req_client_bytes_done);

         // Free the I/O request structure
         MemFree(pReq);

         // Check to see if callback deallocated our instance or state changed
		   if(gpInstanceTable->Lock(dwPhysicalId) == NULL)
			   return;
		   gpInstanceTable->Unlock(dwPhysicalId);
		   if(pHws->hws_uState > HWS_CONNECTED)
		      return;

         break;

      default:
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("ProcessQueuedSends: SendStart() failed"));

         // Fall-through to next case is intentional

      case LINK_SEND_WOULD_BLOCK:
         // The send would have blocked; we need to requeue the I/O request
         // and wait for a FD_WRITE network event.
         // If any part of the data was sent, the bytes_done field has been updated.
         if (QInsertAtHead(pHws->hws_pSendQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedSends: QInsertAtHead() failed"));
         }
         return;

      } // switch
   } // while
} // ProcessQueuedSends()



/**************************************************************************
** Function    : datalinkSendRequest
** Description : Fills header/tail of buffer and posts buffer to H.223
***************************************************************************/
LINKDLL HRESULT datalinkSendRequest( DWORD    dwPhysicalId,
                                   PBYTE    pbyDataBuf,
                                   DWORD    dwLength)
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkSendRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);
   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkSendRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkSendRequest: state = %d"), pHws->hws_uState);
	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   // Allocate request structure
   pReq = (PREQUEST) MemAlloc(sizeof(*pReq));
   if (pReq == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("datalinkSendRequest: could not allocate request buffer"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_MEM_FAILURE;
   }

   // The current implementation requires that the size of each message
   // fit in a signed int (because that is what Winsock supports in a
   // single send). If it is necessary to send larger messages,
   // TrySend must be changed to limit the size in each send call, and
   // loop until all the data is sent. This ASSERT could then be removed.
   HWSASSERT(dwLength <= INT_MAX);

   pReq->req_pHws             = pHws;
   pReq->req_client_data      = pbyDataBuf;
   pReq->req_client_length    = (int)dwLength;
   pReq->req_client_bytes_done= 0;
   pReq->req_dwMagic          = SEND_REQUEST_MAGIC;

   // Format TPKT header
   SetupTPKTHeader(pReq->req_TpktHeader, dwLength);
   pReq->req_header_bytes_done = 0;

   if (QInsert(pHws->hws_pSendQueue, pReq) == FALSE)
   {
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                __TEXT("datalinkSendRequest: QInsert() failed"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_SEND_NOBUFF;
   }

   if (pHws->hws_uState == HWS_CONNECTED)
       NotifyWrite(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkSendRequest: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // datalinkSendRequest

static void SetupTPKTHeader(BYTE *tpkt_header, DWORD length)
{
    length += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    HWSASSERT(length < (1L << 16));

    tpkt_header[0] = TPKT_VERSION;
    tpkt_header[1] = 0;
    tpkt_header[2] = (BYTE)(length >> 8);
    tpkt_header[3] = (BYTE)length;
}


#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245wsrx.cpp ===
/***************************************************************************
 *
 * File: h245wsrx.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245wsrx.cpp  $
 * $Revision:   2.4  $
 * $Modtime:   30 Jan 1997 17:15:58  $
 * $Log:   S:/STURGEON/SRC/H245WS/VCS/h245wsrx.cpv  $
 * 
 *    Rev 2.4   30 Jan 1997 17:17:16   EHOWARDX
 * Fixed bug in trace message - need to do trace before
 * calling shutdown() sent shutdown clears error retrieved
 * by WSAGetLastError().
 * 
 *    Rev 2.3   14 Jan 1997 15:48:04   EHOWARDX
 * Changed TryRecv() and TrySend() to check for WSAECONNRESET and
 * WSAECONNABORT return from recv() and send() and act accordingly.
 * 
 *    Rev 2.2   19 Dec 1996 18:54:54   SBELL1
 * took out tag comments
 * 
 *    Rev 2.1   Dec 13 1996 17:31:00   plantz
 * moved #ifdef _cplusplus to after include files
// 
//    Rev 1.1   13 Dec 1996 12:11:34   SBELL1
// moved #ifdef _cplusplus to after include files
// 
//    Rev 1.0   11 Dec 1996 13:41:52   SBELL1
// Initial revision.
 * 
 *    Rev 1.19   08 Jul 1996 19:27:44   unknown
 * Second experiment to try to fix Q.931 shutdown problem.
 * 
 *    Rev 1.18   01 Jul 1996 16:45:12   EHOWARDX
 * 
 * Moved Call to SocketCloseEvent from TryRecv() to ProcessQueuedRecvs().
 * TryRecv() now returns LINK_RECV_CLOSED to trigger ProcessQueuedRecvs()
 * to call SocketCloseEvent().
 * 
 *    Rev 1.17   May 28 1996 18:14:36   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.16   17 May 1996 16:49:32   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.15   09 May 1996 18:33:16   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.14   29 Apr 1996 16:53:16   EHOWARDX
 * 
 * Added trace statement.
 * 
 *    Rev 1.13   Apr 29 1996 14:04:20   plantz
 * Call NotifyRead instead of ProcessQueuedRecvs.
 * 
 *    Rev 1.12   Apr 29 1996 12:14:06   plantz
 * Change tpkt header to include header size in packet length.
 * Assert that message length does not exceed INT_MAX.
 * .
 * 
 *    Rev 1.11   27 Apr 1996 14:07:32   EHOWARDX
 * Parenthesized return from TryRecv().
 * 
 *    Rev 1.10   Apr 25 1996 21:15:12   plantz
 * Check state of connection before attemting to call recv.
 * 
 *    Rev 1.9   Apr 24 1996 16:39:34   plantz
 * Merge 1.5.1.0 with 1.8 (changes for winsock 1)
 * 
 *    Rev 1.5.1.0   Apr 24 1996 16:23:00   plantz
 * Change to not use overlapped I/O (for winsock 1).
 * 
 *    Rev 1.5   01 Apr 1996 14:20:12   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.4   19 Mar 1996 20:18:16   EHOWARDX
 * 
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:08:32   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:01:58   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:02   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:20:18   unknown
 * Initial revision.
 *
 ***************************************************************************/

#define LINKDLL_EXPORT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment


#include "precomp.h"

#include <limits.h>
//#include <winsock.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "tstable.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


// If we are not using the Unicode version of the ISR display utility, then redefine
// the __TEXT macro to do nothing.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

extern TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table

#define GetTpktLength(pReq) (((pReq)->req_TpktHeader[2] << 8) + (pReq)->req_TpktHeader[3])


/*++

Description:
   Start a receive

Arguments:
   pHws              - Pointer to context for "connection"
   pReq              - Pointer to I/O request structure

Return Value:
   SUCCESS                       - Successfully started receive.
   LINK_RECV_ERROR_WOULD_BLOCK   - 
   Winsock error

--*/

static HRESULT
TryRecv(IN PHWSINST pHws, IN char *data, IN int length, IN OUT int *total_bytes_done)
{
   int requested_length = length - *total_bytes_done;
   int recv_result = recv(pHws->hws_Socket, data+*total_bytes_done, requested_length, 0);

   if (recv_result == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         return LINK_RECV_WOULD_BLOCK;

      case WSAECONNABORTED:
      case WSAECONNRESET:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TryRecv: recv() returned %s"),
                   SocketErrorText());
         if (pHws->hws_uState == HWS_CONNECTED)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                      __TEXT("TryRecv: calling shutdown"));
            if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
            {
               HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                        __TEXT("TryRecv: shutdown() returned %s"),
                        SocketErrorText());
            }
            pHws->hws_uState = HWS_CLOSING;
         }
         return MAKE_WINSOCK_ERROR(err);

      default:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TryRecv: recv() returned %s"),
                   SocketErrorText());
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   }

   HWSTRACE1(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("TryRecv: recv returned %d"), recv_result);
   if (recv_result == 0)
   {
      return LINK_RECV_CLOSED;
   }

   *total_bytes_done += recv_result;
   return (recv_result == requested_length) ? NOERROR : LINK_RECV_WOULD_BLOCK;
}


static HRESULT
RecvStart(IN PHWSINST pHws, IN PREQUEST pReq)
{
   HRESULT nResult = NOERROR;

   // Sanity checks
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pReq != NULL);
   HWSASSERT(pReq->req_dwMagic == RECV_REQUEST_MAGIC);
   HWSASSERT(pReq->req_pHws == pHws);

   // Get the header first; if that succeeds get the client data
   if (pReq->req_header_bytes_done < TPKT_HEADER_SIZE)
   {
       nResult = TryRecv(pHws,
                         (char *)pReq->req_TpktHeader,
                         TPKT_HEADER_SIZE,
                         &pReq->req_header_bytes_done);
   }

   if (nResult == NOERROR)
   {
       long int tpkt_length = GetTpktLength(pReq) - TPKT_HEADER_SIZE;
       if (pReq->req_TpktHeader[0] != TPKT_VERSION || tpkt_length <= 0)
       {
          // Invalid header version
          HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                    __TEXT("RecvComplete: bad header version; available data discarded"));
          // Should this be reported to the client??

          // Read and discard all available data
          // The client's buffer is used as a temporary buffer.
          while (recv(pHws->hws_Socket, (char *)pReq->req_client_data, pReq->req_client_length, 0) > 0)
              ;

          // Mark the header for this request as unread; it
          // will be read again when additional data is received.
          pReq->req_header_bytes_done = 0;
          nResult = LINK_RECV_ERROR;
       }
       else if (tpkt_length > pReq->req_client_length)
       {
          // Packet too large
          int request_length;
          int result;

          HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                    __TEXT("RecvComplete: packet too large; packet discarded"));
          // Should this be reported to the client??

          // Read and discard the packet
          // The client's buffer is used as a temporary buffer.
          do {
              request_length = pReq->req_client_length;
              if (request_length > tpkt_length)
                  request_length = tpkt_length;
              result = recv(pHws->hws_Socket, (char *)pReq->req_client_data, request_length, 0);
          } while (result > 0 && (tpkt_length -= result) > 0);

          if (result == SOCKET_ERROR && WSAGetLastError() == WSAEWOULDBLOCK)
          {
              //TODO: packet too large handling
              // Adjust the header so that the rest of this packet will be read, but
              // flag it so that it is known to be an error and will not be returned
              // to the client.
          }
          else
          {
              // Mark the header for this request as unread; it
              // will be read again for the next packet received.
              pReq->req_header_bytes_done = 0;
          }

          nResult = LINK_RECV_ERROR;
       }
       else
       {
           // Normal case
           // The current implementation of TryRecv requires that the requested
           // size fit in a signed int (because that is what Winsock supports
           // in a single recv). This is guaranteed at this point regardless
           // of the originator of the packets, because we don't allow a buffer
           // to be posted that is larger than that (see ASSERT below). If the
           // packet were larger than the buffer, it would have been caught above.
           // If TryRecv is changed to remove the restriction on buffer size and
           // accept a parameter of type long int, this ASSERT may be removed.
           HWSASSERT(tpkt_length <= INT_MAX);
           nResult = TryRecv(pHws,
                             (char *)pReq->req_client_data,
                             (int)tpkt_length,
                             &pReq->req_client_bytes_done);
       }
   }

   return nResult;
} // RecvStart()


void
ProcessQueuedRecvs(IN PHWSINST pHws)
{
   register PREQUEST    pReq;
   register DWORD       dwPhysicalId = pHws->hws_dwPhysicalId;

   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pHws->hws_uState <= HWS_CLOSING);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("ProcessQueuedRecvs"));

   while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
   {
      switch (RecvStart(pHws, pReq))
      {
      case NOERROR:
         // Call Recv callback
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_DATA,
                                    pReq->req_client_data,
                                    pReq->req_client_bytes_done);

         // Free the I/O request structure
         MemFree(pReq);

         // Check to see if callback deallocated our instance or state changed

         // Check to see if callback deallocated our instance - this can be done
  	      // by attempting a lock - which will now fail if the entry has been marked
	      // for deletion.  Thus, if the lock succeeds, then just unlock it (since we 
	      // already have a lock on it in a higher level function).

		   if(gpInstanceTable->Lock(dwPhysicalId) == NULL)
			   return;
		   gpInstanceTable->Unlock(dwPhysicalId);
		   if(pHws->hws_uState > HWS_CONNECTED)
		      return;

         break;

      default:
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("ProcessQueuedRecvs: RecvStart() failed"));

         // Fall-through to next case is intentional

      case LINK_RECV_WOULD_BLOCK:
         // The receive would have blocked; we need to requeue the I/O request
         // and wait for a FD_READ network event.
         // If any part of the data was received, the bytes_done field has been updated.
         if (QInsertAtHead(pHws->hws_pRecvQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedRecvs: QInsertAtHead() failed"));
         }
         return;

      case LINK_RECV_CLOSED:
         if (QInsertAtHead(pHws->hws_pRecvQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedRecvs: QInsertAtHead() failed"));
         }
         SocketCloseEvent(pHws);
         return;

      } // switch
   } // while
} // ProcessQueuedRecvs()






/**************************************************************************
** Function    : datalinkReceiveRequest
** Description : Fills header/tail of buffer and posts buffer to H.223
***************************************************************************/
LINKDLL HRESULT datalinkReceiveRequest( DWORD    dwPhysicalId,
                                        PBYTE    pbyDataBuf,
                                        DWORD    dwLength)
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkReceiveRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);

   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkReceiveRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkReceiveRequest: state = %d"), pHws->hws_uState);
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   // Allocate request structure
   pReq = (PREQUEST) MemAlloc(sizeof(*pReq));
   if (pReq == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("datalinkReceiveRequest: could not allocate request buffer"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_MEM_FAILURE;
   }

   // The current implementation requires that the size of each message
   // fit in a signed int (because that is what Winsock supports in a
   // single recv). If it is necessary to receive larger messages,
   // TryRecv and RecvStart must be changed to limit the size in each
   // recv call, and loop until all the data is received.
   // This ASSERT could then be removed.
   HWSASSERT(dwLength <= INT_MAX);

   pReq->req_pHws             = pHws;
   pReq->req_header_bytes_done= 0;
   pReq->req_client_data      = pbyDataBuf;
   pReq->req_client_length    = (int)dwLength;
   pReq->req_client_bytes_done= 0;
   pReq->req_dwMagic          = RECV_REQUEST_MAGIC;

   if (QInsert(pHws->hws_pRecvQueue, pReq) == FALSE)
   {
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                __TEXT("datalinkReceiveRequest: QInsert() failed"));
	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_RECV_NOBUFF;
   }

   if (pHws->hws_uState == HWS_CONNECTED)
       NotifyRead(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkReceiveRequest: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // datalinkReceiveRequest()



#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245_sr.c ===
/******************************************************************************
 *
 *  File:  h245_sr.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245_sr.c  $
 *  $Revision:   1.10  $
 *  $Modtime:   Mar 04 1997 17:30:56  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245_sr.c_v  $
 *
 *    Rev 1.11   Jun 25 1998 00:00:00 mikev@microsoft.com
 * STRIPPED PLUGIN LINK LAYER AND COMBINED THE SEPARATE DLLs
 * 
 *    Rev 1.10   Mar 04 1997 17:51:22   tomitowx
 * process detach fix
 * 
 *    Rev 1.9   11 Dec 1996 13:55:20   SBELL1
 * Changed linkLayerInit parameters
 * 
 *    Rev 1.8   14 Oct 1996 14:05:52   EHOWARDX
 * 
 * Used cast to get rid of warning.
 * 
 *    Rev 1.7   14 Oct 1996 14:01:30   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.6   23 Jul 1996 08:57:08   EHOWARDX
 * 
 * Moved H245 interop logger init/deinit from H245_SR.C (per-instance)
 * to H245MAIN.C (per-DLL). With multiple instances and a global variable,
 * per-instance init/deinit is fundamentally brain-dead.
 * 
 *    Rev 1.5   22 Jul 1996 17:33:44   EHOWARDX
 * Updated to latest Interop API.
 * 
 *    Rev 1.4   05 Jun 1996 17:13:50   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 * 
 *    Rev 1.3   04 Jun 1996 18:17:32   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 * 
 *    Rev 1.2   29 May 1996 15:20:20   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:32   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:28   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17.1.6   09 May 1996 19:34:40   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 * 
 *    Rev 1.17.1.5   29 Apr 1996 19:42:42   EHOWARDX
 * Commented out linkLayerFlushAll() call and synchronized with Rev 1.30.
 * 
 *    Rev 1.26   29 Apr 1996 12:53:16   EHOWARDX
 * Commented out receive thread/receive queue code.
 * 
 *    Rev 1.17.1.4   25 Apr 1996 21:27:04   EHOWARDX
 * Changed to use h245Instance->p_ossWorld instead of bAsnInitialized.
 * 
 *    Rev 1.17.1.3   23 Apr 1996 14:44:22   EHOWARDX
 * Updated.
 *
 *    Rev 1.17.1.2   15 Apr 1996 15:11:54   EHOWARDX
 * Updated.
 *
 *    Rev 1.17.1.1   26 Mar 1996 19:13:50   EHOWARDX
 *
 * Commented out hTraceFile.
 *
 *    Rev 1.17.1.0   26 Mar 1996 13:11:22   EHOWARDX
 * Branced and added H245_CONF_H323 to sendRecvInit
 *
 *    Rev 1.17   19 Mar 1996 18:09:04   helgebax
 * removed old timer code
 *
 *    Rev 1.16   13 Mar 1996 11:30:44   DABROWN1
 *
 * Enable logging for ring 0
 *
 *    Rev 1.15   11 Mar 1996 15:39:18   DABROWN1
 *
 * modifications required for ring0/ring3 compatiblity
 *
 *    Rev 1.13   06 Mar 1996 13:12:24   DABROWN1
 *
 * flush link layer buffers at shutdown
 *
 *    Rev 1.12   02 Mar 1996 22:11:10   DABROWN1
 *
 * changed h245_bzero to memset
 *
 *    Rev 1.11   01 Mar 1996 17:24:46   DABROWN1
 *
 * moved oss 'world' context to h245instance
 *
 *    Rev 1.10   28 Feb 1996 18:45:00   EHOWARDX
 *
 * Added H245TimerStart and H245TimerStop to linkLayerInit call.
 *
 *    Rev 1.9   28 Feb 1996 15:43:52   EHOWARDX
 *
 * Removed sample code.
 * Added code to free up all events on timer queue before deallocating.
 *
 *    Rev 1.8   27 Feb 1996 13:35:10   DABROWN1
 *
 * added h245instance in datalink initialization routine
 *
 *    Rev 1.7   26 Feb 1996 18:59:34   EHOWARDX
 *
 * Added H245TimerStart and H245TimerStop functions.
 * Also added sample timer function, which should be removed later.
 *
 *    Rev 1.6   23 Feb 1996 22:17:26   EHOWARDX
 *
 * Fixed check at start of sendRecvShutdown.
 * It's an error if dwInst is greater than or equal to MAXINST, not less than!
 *
 *    Rev 1.5   23 Feb 1996 21:59:28   EHOWARDX
 *
 * winspox changes.
 *
 *    Rev 1.4   23 Feb 1996 13:55:30   DABROWN1
 *
 * added h245TRACE ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 15:12:36   EHOWARDX
 *
 * Forgot to replace H245ReceiveComplete with H245ReceivePost.
 *
 *    Rev 1.2   20 Feb 1996 19:14:20   EHOWARDX
 * Added in mailbox changes.
 *
 *    Rev 1.1   21 Feb 1996 08:26:28   DABROWN1
 *
 * create and free multiple receive buffers.
 * Make size of buffer dependent on protocol in use
 *
 *    Rev 1.0   09 Feb 1996 17:34:24   cjutzi
 * Initial revision.
 *
 *****************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245com.h"
#include "sr_api.h"
#include "linkapi.h"


#if defined(USE_RECEIVE_QUEUE)
DWORD
ReceiveThread(VOID *lpThreadParameter)
{
    struct InstanceStruct *pInstance = (struct InstanceStruct *)lpThreadParameter;
	RXMSG				RxMsg;
    Uns                 uTimeout;

    Bool                bPendResult;


	SETTASK("H245RCVTASK0");

	if (pInstance == NULL) {
		H245PANIC();
		return SR_INVALID_CONTEXT;
	}

	// Loop until thread is ready to terminate
    pInstance->SendReceive.bReceiveThread = TRUE;
	for ( ; ; )
	{
        uTimeout = SYS_FOREVER;
		// Wait for an event (or a queued callback function) to wake us up.
		// This is an alertable wait state (fAlertable == TRUE)
        pInstance->SendReceive.bReceiveThread = FALSE;
        H245TRACE(pInstance->dwInst, 2, "ReceiveThread, uTimeout = %d", uTimeout);
		RESETTASK();

		bPendResult = MBX_pend(pInstance->SendReceive.pMailbox, &RxMsg, uTimeout);

		SETTASK("H245RCVTASK");
        H245TRACE(pInstance->pInstance->dwInst, 2, "ReceiveThread, bPendResult = %d", bPendResult);
        pInstance->SendReceive.bReceiveThread = TRUE;

		switch (RxMsg.dwMessage) {
		case EXIT_RECEIVE_THREAD:
			// Thread exiting....signal app

			TRACE("H245: Receive Thread Exiting");
			SEM_post(pInstance->SendReceive.hReceiveSemphore);
			RESETTASK();
			return 0;
			break;

		default:
			// Ignore timer message, which should have dwLength == 0
			if (RxMsg.dwLength)
			{
				h245ReceiveComplete(RxMsg.h245Inst,
									RxMsg.dwMessage,
									RxMsg.pbDataBuf,
									RxMsg.dwLength);
			}
			else 
			{

TRACE1("H245SEND: SendTask %d", RxMsg.dwMessage);

				h245SendComplete(RxMsg.h245Inst,
									RxMsg.dwMessage,
									RxMsg.pbDataBuf,
									RxMsg.dwLength);
			}
			break;
		} // switch

	} // for
	return 0;
} // ReceiveThread()


static void
h245ReceivePost(DWORD	h245Inst,
				DWORD	dwMessage,
				PBYTE	pbDataBuf,
				DWORD	dwLength)
{
    register struct InstanceStruct *pInstance;
	RXMSG					        RxMsg;

	// Validate the instance handle
    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
		H245TRACE(h245Inst, 1, "h245ReceivePost h245Inst Invalid");
		H245PANIC();
		return;
	}

	RxMsg.h245Inst    = h245Inst;
	RxMsg.dwMessage   = dwMessage;
	RxMsg.pbDataBuf   = pbDataBuf;
	RxMsg.dwLength    = dwLength;

	if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
		H245TRACE(h245Inst, 1, "SR: MBX POST FAIL");
		H245PANIC();
	}
    InstanceUnlock(pInstance);
} // h245ReceivePost()
#endif  // (USE_RECEIVE_QUEUE)

HRESULT
initializeLinkDllEntry
(
	struct InstanceStruct * pInstance,
	LPCTSTR		            szDLLFile
)
{


#if(0)
	if (!(pInstance->SendReceive.hLinkModule = LoadLibrary(szDLLFile))) {
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerInit = (PFxnlinkLayerInit)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKINITIALIZE)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkShutdown = (PFxnlinkLayerShutdown)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKSHUTDOWN)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkGetInstance = (PFxnlinkLayerGetInstance)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKGETINSTANCE)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkReceiveReq = (PFxndatalinkReceiveRequest)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKRECEIVEREQUEST)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkSendReq = (PFxndatalinkSendRequest)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKSENDREQUEST)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerFlushChannel = (PFxnlinkLayerFlushChannel)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKFLUSHCHANNEL)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerFlushAll = (PFxnlinkLayerFlushAll)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKFLUSHALL)))		{
		return H245_ERROR_FATAL;
	}
#else
    pInstance->SendReceive.hLinkLayerInit = linkLayerInit;
    pInstance->SendReceive.hLinkShutdown = linkLayerShutdown;
    pInstance->SendReceive.hLinkGetInstance = linkLayerGetInstance;
    pInstance->SendReceive.hLinkReceiveReq = datalinkReceiveRequest;
    pInstance->SendReceive.hLinkSendReq = datalinkSendRequest;
    pInstance->SendReceive.hLinkLayerFlushChannel = linkLayerFlushChannel;
    pInstance->SendReceive.hLinkLayerFlushAll = linkLayerFlushAll;
#endif //if(0)
	H245TRACE(pInstance->dwInst,
			  3,
			  "SR: %s Loaded", szDLLFile);

	return (0);
}


#if defined(_DEBUG) && defined(H324)
void
srInitializeLogging
(
	struct InstanceStruct *pInstance,
	BOOL	bTracingEnabled
)
{
	FILE				*hTraceFile;
	char				initTraceFile[20] = "c:\\tmp\\h2450.000";
	BOOL				bSearch = TRUE;		// search for filename

	if (pInstance == NULL) {
		H245TRACE(h245Inst, 1, "SR:Enable Log Instance Error");
		H245PANIC();
		return;
	}

	// eventually will be from registry
	pInstance->SendReceive.bLoggingEnabled = bTracingEnabled;
	
	if (pInstance->SendReceive.bLoggingEnabled) {
		// Init the logger file for Ring0/SPOX implementations.  Loop until
		//	we get the next available revision
		memcpy(pInstance->SendReceive.fTraceFile,
			   initTraceFile,
			   20);
		pInstance->SendReceive.fTraceFile[11] = ((unsigned char)pInstance->dwInst & 0xF) + 0x30;

		do {
			hTraceFile = fopen(pInstance->SendReceive.fTraceFile, "r");
			if ((hTraceFile == NULL) || ((int)hTraceFile == -1)) {
				bSearch = FALSE;
			}
			else {
				// able to open the file. close it and try the next one
				fclose(hTraceFile);

				// get the next revision number
				if (pInstance->SendReceive.fTraceFile[15] == '9') {
					pInstance->SendReceive.fTraceFile[15] = '0';
					if (pInstance->SendReceive.fTraceFile[14] == '9') {
						pInstance->SendReceive.fTraceFile[14] = '0';
						pInstance->SendReceive.fTraceFile[13]++;
					}
					else {
						pInstance->SendReceive.fTraceFile[14]++;
					}
				}
				else {
					pInstance->SendReceive.fTraceFile[15]++;
				}
			}
		}while (bSearch);

		hTraceFile = fopen(pInstance->SendReceive.fTraceFile, "wb");
		if ((hTraceFile == NULL) || ((int)hTraceFile == -1)) {
			pInstance->SendReceive.bLoggingEnabled = FALSE;
			H245TRACE(h245Inst,
					  1,
					  "SR: Trace File CREATE ERROR");
		}
		else {
		// Close the file.  Will be opened immediately before writing
		//	and closed immediately thereafter
			pInstance->SendReceive.bLoggingEnabled = TRUE;
			fclose(hTraceFile);
		}
		
	}
}
#endif  // (_DEBUG)

HRESULT
sendRcvShutdown
(
	struct InstanceStruct *pInstance
)
{
#if defined(USE_RECEIVE_QUEUE)
	RXMSG			RxMsg;
#endif  // (USE_RECEIVE_QUEUE)
	int				i;

	if (pInstance == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Shutdown Instance Error");
		return H245_ERROR_INVALID_INST;
	}

	if (pInstance->pWorld) {

		// Shutdown the ASN.1 libraries
		terminateASN1(pInstance->pWorld);

		// Free the ASN.1 global structure
		MemFree(        pInstance->pWorld);
        pInstance->pWorld = NULL;
	}



	// Shutdown link layer
#if(0)	
	if (pInstance->SendReceive.hLinkModule) {
		// First get all buffers back that may still be lurking
//		if (pInstance->SendReceive.hLinkLayerFlushAll) {
//			pInstance->SendReceive.hLinkLayerFlushAll(pInstance->SendReceive.hLinkLayerInstance);
//		}
		if (pInstance->SendReceive.hLinkShutdown) {
			pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
		}

        FreeLibrary(pInstance->SendReceive.hLinkModule);

		pInstance->SendReceive.hLinkModule = NULL;
	}
#else
	pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
#endif // if(0)
	// return buffers from data link layer
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		if (pInstance->SendReceive.lpRxBuffer[i]) {
			MemFree(        pInstance->SendReceive.lpRxBuffer[i]);
			pInstance->SendReceive.lpRxBuffer[i] = NULL;
		}
	}
#if defined(USE_RECEIVE_QUEUE)
	// Terminate receive thread
	if (pInstance->SendReceive.pTaskReceive && pInstance->SendReceive.pMailbox) {

TRACE("H245: Task/Mbox Present");
		// First post a message to have it exit
		RxMsg.h245Inst    = (DWORD)pInstance;
		RxMsg.dwMessage   = EXIT_RECEIVE_THREAD;
		RxMsg.pbDataBuf   = NULL;
		RxMsg.dwLength    = 0;
#ifdef   _IA_SPOX_
		if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
		if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
			H245TRACE(h245Inst, 1, "SR: Shutdown MBX POST FAIL");
			H245PANIC();
		}

		// Wait on semaphore for receive task to exit
#ifdef _IA_SPOX_
		RIL_WaitForSemaphore(pInstance->SendReceive.hReceiveSemphore, OIL_WAITFOREVER);
#else
		SEM_pend(pInstance->SendReceive.hReceiveSemphore, SYS_FOREVER);
#endif //_IA_SPOX_
		TRACE("H245: ReceiveTask Semaphore");
		
#ifdef _IA_SPOX_
		RIL_DeleteTask(pInstance->SendReceive.pTaskReceive);
#else
		TSK_delete(pInstance->SendReceive.pTaskReceive);
#endif //_IA_SPOX_
		pInstance->SendReceive.pTaskReceive = NULL;

#ifdef   _IA_SPOX_
		RIL_DeleteSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
		SEM_delete(pInstance->SendReceive.hReceiveSemphore);
#endif //_IA_SPOX_
		pInstance->SendReceive.hReceiveSemphore = NULL;

TRACE("H245: Semaphore Delete");
    }

    // Deallocate mailbox
    if (pInstance->SendReceive.pMailbox) {
#ifdef   _IA_SPOX_
	RIL_DeleteMailbox(pInstance->SendReceive.pMailbox);
#else
	MBX_delete(pInstance->SendReceive.pMailbox);
#endif //_IA_SPOX_
        pInstance->SendReceive.pMailbox = NULL;
    }
#endif  // (USE_RECEIVE_QUEUE)

    H245TRACE(pInstance->dwInst, 3, "SR: Shutdown Complete");
    return H245_ERROR_OK;
} // sendRcvShutdown()


HRESULT
sendRcvShutdown_ProcessDetach(	struct InstanceStruct *pInstance, BOOL fProcessDetach)
{
#if defined(USE_RECEIVE_QUEUE)
	RXMSG			RxMsg;
#endif  // (USE_RECEIVE_QUEUE)
	int				i;

	if (pInstance == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Shutdown Instance Error");
		return H245_ERROR_INVALID_INST;
	}

	if (pInstance->pWorld) {

		// Shutdown the ASN.1 libraries
		terminateASN1(pInstance->pWorld);

		// Free the ASN.1 global structure
		MemFree(        pInstance->pWorld);
        pInstance->pWorld = NULL;
	}



	// Shutdown link layer
	if (pInstance->SendReceive.hLinkModule) {
		// First get all buffers back that may still be lurking
//		if (pInstance->SendReceive.hLinkLayerFlushAll) {
//			pInstance->SendReceive.hLinkLayerFlushAll(pInstance->SendReceive.hLinkLayerInstance);
//		}
		//tomitowoju@intel.com
		if(!fProcessDetach)
		{
            H245TRACE(0, 0, "***** fProcessDetach = FALSE");

			if (pInstance->SendReceive.hLinkShutdown) {
				pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
			}
		}
		//tomitowoju@intel.com

        FreeLibrary(pInstance->SendReceive.hLinkModule);

		pInstance->SendReceive.hLinkModule = NULL;
	}

	// return buffers from data link layer
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		if (pInstance->SendReceive.lpRxBuffer[i]) {
			MemFree(        pInstance->SendReceive.lpRxBuffer[i]);
			pInstance->SendReceive.lpRxBuffer[i] = NULL;
		}
	}
#if defined(USE_RECEIVE_QUEUE)
	// Terminate receive thread
	if (pInstance->SendReceive.pTaskReceive && pInstance->SendReceive.pMailbox) {

TRACE("H245: Task/Mbox Present");
		// First post a message to have it exit
		RxMsg.h245Inst    = (DWORD)pInstance;
		RxMsg.dwMessage   = EXIT_RECEIVE_THREAD;
		RxMsg.pbDataBuf   = NULL;
		RxMsg.dwLength    = 0;
#ifdef   _IA_SPOX_
		if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
		if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
			H245TRACE(h245Inst, 1, "SR: Shutdown MBX POST FAIL");
			H245PANIC();
		}

		// Wait on semaphore for receive task to exit
#ifdef _IA_SPOX_
		RIL_WaitForSemaphore(pInstance->SendReceive.hReceiveSemphore, OIL_WAITFOREVER);
#else
		SEM_pend(pInstance->SendReceive.hReceiveSemphore, SYS_FOREVER);
#endif //_IA_SPOX_
		TRACE("H245: ReceiveTask Semaphore");
		
#ifdef _IA_SPOX_
		RIL_DeleteTask(pInstance->SendReceive.pTaskReceive);
#else
		TSK_delete(pInstance->SendReceive.pTaskReceive);
#endif //_IA_SPOX_
		pInstance->SendReceive.pTaskReceive = NULL;

#ifdef   _IA_SPOX_
		RIL_DeleteSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
		SEM_delete(pInstance->SendReceive.hReceiveSemphore);
#endif //_IA_SPOX_
		pInstance->SendReceive.hReceiveSemphore = NULL;

TRACE("H245: Semaphore Delete");
    }

    // Deallocate mailbox
    if (pInstance->SendReceive.pMailbox) {
#ifdef   _IA_SPOX_
	RIL_DeleteMailbox(pInstance->SendReceive.pMailbox);
#else
	MBX_delete(pInstance->SendReceive.pMailbox);
#endif //_IA_SPOX_
        pInstance->SendReceive.pMailbox = NULL;
    }
#endif  // (USE_RECEIVE_QUEUE)

    H245TRACE(pInstance->dwInst, 3, "SR: Shutdown Complete");
    return H245_ERROR_OK;
} // sendRcvShutdown_ProcessDetach()




HRESULT
sendRcvInit
(
	struct InstanceStruct *pInstance
)
{

	int 				rc;
	LPTSTR				szDLLFile;
	int					i;
   
    //MULTITHREAD
    DWORD dwTmpPhysID = INVALID_PHYS_ID; 

	// Overall oss ASN.1 initialization routine.  First allocate
	//	resources for its global structure, then initialize the
	//	subsystem.
	pInstance->pWorld = (ASN1_CODER_INFO *)MemAlloc(sizeof(ASN1_CODER_INFO));
	if (pInstance->pWorld == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - No Memory");
		return H245_ERROR_NOMEM;
	}

	if (initializeASN1(pInstance->pWorld) != 0) {
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - ASN.1 Encoder/Decoder initialization failed");

		// Free the ASN.1 global structure
		MemFree(pInstance->pWorld);
        pInstance->pWorld = NULL;
		return H245_ERROR_ASN1;
	}


	// Initialization proceeding well.  Wake up the
	//	data link layers, if necessary, based on the
	//	underlying protocol.
	switch (pInstance->Configuration) {
#if(0)	
	case H245_CONF_H324:
		// Get the DLL
		szDLLFile = (LPTSTR)SRPDLLFILE;

		// Initialize default size of PDU for SRP
		pInstance->SendReceive.dwPDUSize = LL_PDU_SIZE + 4;
		pInstance->SendReceive.dwNumRXBuffers = NUM_SRP_LL_RCV_BUFFERS;
		break;
#endif
	case H245_CONF_H323:
		// Get the DLL
		szDLLFile = (LPTSTR)H245WSDLLFILE;

		// Initialize default size of PDU
		pInstance->SendReceive.dwPDUSize = LL_PDU_SIZE;
		pInstance->SendReceive.dwNumRXBuffers = MAX_LL_BUFFERS;
		break;

	default:
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - Invalid configuration %d", pInstance->Configuration);
		return H245_ERROR_SUBSYS;
	}


	//	Load and Initialize Datalink layer
	if ((rc = initializeLinkDllEntry(pInstance, szDLLFile)) != 0) {
		H245TRACE(pInstance->dwInst, 1, "SR: Link Open Lib Fail %d", rc);
		return rc;
	}

        //MULTITHREAD
        //use dwTmpPhysID so PhysID doesn't change.
        //PhysID is different var for H245 than H245ws.
        //Use hLinkLayerInstance for H245ws PhysID.
	rc = pInstance->SendReceive.hLinkLayerInit(&dwTmpPhysID,
					   pInstance->dwInst,
#if defined(USE_RECEIVE_QUEUE)
					   h245ReceivePost,
					   h245SendPost);
#else   // (USE_RECEIVE_QUEUE)
					   h245ReceiveComplete,
					   h245SendComplete);
#endif  // (USE_RECEIVE_QUEUE)

	if (FAILED(rc)) {
		H245TRACE(pInstance->dwInst, 1, "SR: Link Init Fail");
		return rc;
	}
	// Get the Link layer's instance handle
	pInstance->SendReceive.hLinkLayerInstance = pInstance->SendReceive.hLinkGetInstance(dwTmpPhysID);

#if defined(USE_RECEIVE_QUEUE)
	// Allocate semaphore for task deletion procedures
#ifdef  _IA_SPOX_
    RIL_CreateSemaphore(0, &(pInstance->SendReceive.hReceiveSemphore));
#else
	pInstance->SendReceive.hReceiveSemphore = SEM_create(0, NULL);
#endif //_IA_SPOX_
	if (pInstance->SendReceive.hReceiveSemphore == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Semaphore creation failed");
		return SR_CREATE_SEM_FAIL;
	}

	// Allocate mailbox
#ifdef   _IA_SPOX_
	RIL_CreateMailbox(pInstance->dwInst,
					  ID_H245,
					  16,
					  OIL_LOCAL,
					  &(pInstance->SendReceive.pMailbox));
#else 
	pInstance->SendReceive.pMailbox = MBX_create(sizeof(RXMSG), 16, NULL);
#endif   _IA_SPOX_
	if (pInstance->SendReceive.pMailbox == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Mailbox creation failed");
		return SR_CREATE_MBX_FAIL;
	}

#if defined(_DEBUG) && defined(H324)
	// Turn logging on/off
	srInitializeLogging(pInstance, H245_TRACE_ENABLED);
#endif  // (_DEBUG)

#ifdef _IA_SPOX_
	// Initialize the task and
	// Start the receive thread
    srTaskAttr.idwPriority = OIL_MINPRI;
    srTaskAttr.pStack    = NULL;
    srTaskAttr.dwStackSize = 8192;
	srTaskAttr.pEnviron = NULL;
    srTaskAttr.szName = "H245ReceiveThread";
    srTaskAttr.bExitFlag = TRUE;

	RIL_CreateTask((PFxn)ReceiveThread,
				   &srTaskAttr,
				   srContext,
				   &pInstance->SendReceive.pTaskReceive);
#else
	// Initialize the task and
	// Start the receive thread
    srTaskAttr.priority = TSK_MINPRI;
    srTaskAttr.stack    = NULL;
    srTaskAttr.stacksize = 8192;
    srTaskAttr.stackseg = 0;
//	srTaskAttr.environ = NULL;
    srTaskAttr.name = " ";
    srTaskAttr.exitflag = FALSE;
//    srTaskAttr.debug = TSK_DBG_NO;

	pInstance->SendReceive.pTaskReceive = TSK_create((Fxn)ReceiveThread,
                                          &srTaskAttr,
                                          srContext);
#endif //_IA_SPOX_
	if (pInstance->SendReceive.pTaskReceive == NULL)
	{
		H245TRACE(pInstance->dwInst, 1, "SR: Thread Create FAIL");		H245PANIC();
		return SR_THREAD_CREATE_ERROR;
	}





#endif  // (USE_RECEIVE_QUEUE)

	// post buffers to link layer for receive
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		pInstance->SendReceive.lpRxBuffer[i] = MemAlloc(pInstance->SendReceive.dwPDUSize);
		if (pInstance->SendReceive.lpRxBuffer[i] == NULL) {
		    H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - No Memory");
			return H245_ERROR_NOMEM;
		}
		rc = pInstance->SendReceive.hLinkReceiveReq(pInstance->SendReceive.hLinkLayerInstance,
									   (PBYTE)pInstance->SendReceive.lpRxBuffer[i],
									   pInstance->SendReceive.dwPDUSize);
        if (rc != 0) {
		    H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - Receive Buffer Post returned %d", rc);
		    return rc;
        }
	}

	H245TRACE(pInstance->dwInst,  3, "SR: INIT Complete");

	return H245_ERROR_OK;
} // sendRcvInit()


HRESULT
sendRcvFlushPDUs
(
	struct InstanceStruct *pInstance,
	DWORD	 dwDirection,
	BOOL	 bShutdown
)
{
    pInstance->SendReceive.dwFlushMap = dwDirection;
    if (bShutdown) {
     	pInstance->SendReceive.dwFlushMap |= SHUTDOWN_PENDING;
    }

    // Flush the requested queue(s)
    return(pInstance->SendReceive.hLinkLayerFlushChannel(pInstance->SendReceive.hLinkLayerInstance,
                                                         dwDirection));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hangman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Hangman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.16  $
 *	$Date:   22 Jan 1997 14:55:52  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "hangman.h"


static BOOL		bHangupInited = FALSE;

static struct {
	PHANGUP				pHead;
	LOCK				Lock;
} HangupTable;

static struct {
	HHANGUP				hHangup;
	LOCK				Lock;
} HangupHandle;


HRESULT InitHangupManager()
{
	ASSERT(bHangupInited == FALSE);

	HangupTable.pHead = NULL;
	InitializeLock(&HangupTable.Lock);

	HangupHandle.hHangup = CC_INVALID_HANDLE + 1;
	InitializeLock(&HangupHandle.Lock);

	bHangupInited = TRUE;
	return CC_OK;
}



HRESULT DeInitHangupManager()
{
PHANGUP		pHangup;
PHANGUP		pNextHangup;

	if (bHangupInited == FALSE)
		return CC_OK;

	pHangup = HangupTable.pHead;
	while (pHangup != NULL) {
		AcquireLock(&pHangup->Lock);
		pNextHangup = pHangup->pNextInTable;
		FreeHangup(pHangup);
		pHangup = pNextHangup;
	}

	DeleteLock(&HangupHandle.Lock);
	DeleteLock(&HangupTable.Lock);
	bHangupInited = FALSE;
	return CC_OK;
}



HRESULT _AddHangupToTable(			PHANGUP					pHangup)
{
	ASSERT(pHangup != NULL);
	ASSERT(pHangup->hHangup != CC_INVALID_HANDLE);
	ASSERT(pHangup->bInTable == FALSE);

	AcquireLock(&HangupTable.Lock);

	pHangup->pNextInTable = HangupTable.pHead;
	pHangup->pPrevInTable = NULL;
	if (HangupTable.pHead != NULL)
		HangupTable.pHead->pPrevInTable = pHangup;
	HangupTable.pHead = pHangup;

	pHangup->bInTable = TRUE;

	RelinquishLock(&HangupTable.Lock);
	return CC_OK;
}



HRESULT _RemoveHangupFromTable(		PHANGUP					pHangup)
{
HHANGUP		hHangup;
BOOL		bTimedOut;

	ASSERT(pHangup != NULL);
	ASSERT(pHangup->bInTable == TRUE);

	// Caller must have a lock on the hangup object;
	// in order to avoid deadlock, we must:
	//   1. unlock the hangup object,
	//   2. lock the HangupTable,
	//   3. locate the hangup object in the HangupTable (note that
	//      after step 2, the hangup object may be deleted from the
	//      HangupTable by another thread),
	//   4. lock the hangup object (someone else may have the lock)
	//   5. remove the hangup object from the HangupTable,
	//   6. unlock the HangupTable
	//
	// The caller can now safely unlock and destroy the hangup object,
	// since no other thread will be able to find the object (its been
	// removed from the HangupTable), and therefore no other thread will
	// be able to lock it.

	// Save the hangup handle; its the only way to look up
	// the hangup object in the HangupTable. Note that we
	// can't use pHangup to find the hangup object, since
	// pHangup may be free'd up, and another hangup object
	// allocated at the same address
	hHangup = pHangup->hHangup;

	// step 1
	RelinquishLock(&pHangup->Lock);

step2:
	// step 2
	AcquireLock(&HangupTable.Lock);

	// step 3
	pHangup = HangupTable.pHead;
	while ((pHangup != NULL) && (pHangup->hHangup != hHangup))
		pHangup = pHangup->pNextInTable;

	if (pHangup != NULL) {
		// step 4
		AcquireTimedLock(&pHangup->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&HangupTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pHangup->pPrevInTable == NULL)
			HangupTable.pHead = pHangup->pNextInTable;
		else
			pHangup->pPrevInTable->pNextInTable = pHangup->pNextInTable;

		if (pHangup->pNextInTable != NULL)
			pHangup->pNextInTable->pPrevInTable = pHangup->pPrevInTable;

		pHangup->pNextInTable = NULL;
		pHangup->pPrevInTable = NULL;
		pHangup->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&HangupTable.Lock);

	if (pHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeHangupHandle(			PHHANGUP				phHangup)
{
	AcquireLock(&HangupHandle.Lock);
	*phHangup = HangupHandle.hHangup++;
	RelinquishLock(&HangupHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockHangup(			PHHANGUP				phHangup,
									CC_HCONFERENCE			hConference,
									DWORD_PTR				dwUserToken,
									PPHANGUP				ppHangup)
{
HRESULT		status;
	
	ASSERT(bHangupInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phHangup != NULL);
	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppHangup != NULL);

	// set phHangup now, in case we encounter an error
	*phHangup = CC_INVALID_HANDLE;

	*ppHangup = (PHANGUP)MemAlloc(sizeof(HANGUP));
	if (*ppHangup == NULL)
		return CC_NO_MEMORY;

	(*ppHangup)->bInTable = FALSE;
	status = _MakeHangupHandle(&(*ppHangup)->hHangup);
	if (status != CC_OK) {
		MemFree(*ppHangup);
		return status;
	}
	
	(*ppHangup)->hConference = hConference;
	(*ppHangup)->wNumCalls = 0;
	(*ppHangup)->dwUserToken = dwUserToken;
	(*ppHangup)->pNextInTable = NULL;
	(*ppHangup)->pPrevInTable = NULL;

	InitializeLock(&(*ppHangup)->Lock);
	AcquireLock(&(*ppHangup)->Lock);

	*phHangup = (*ppHangup)->hHangup;

	// add the Hangup to the Hangup table
	status = _AddHangupToTable(*ppHangup);
	if (status != CC_OK)
		FreeHangup(*ppHangup);
	
	return status;
}



// Caller must have a lock on the Hangup object
HRESULT FreeHangup(					PHANGUP				pHangup)
{
HHANGUP		hHangup;

	ASSERT(pHangup != NULL);

	// caller must have a lock on the Hangup object,
	// so there's no need to re-lock it
	
	hHangup = pHangup->hHangup;

	if (pHangup->bInTable == TRUE)
		if (_RemoveHangupFromTable(pHangup) == CC_BAD_PARAM)
			// the Hangup object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	// Since the hangup object has been removed from the HangupTable,
	// no other thread will be able to find the hangup object and obtain
	// a lock, so its safe to unlock the hangup object and delete it here
	RelinquishLock(&pHangup->Lock);
	DeleteLock(&pHangup->Lock);
	MemFree(pHangup);
	return CC_OK;
}



HRESULT LockHangup(					HHANGUP					hHangup,
									PPHANGUP				ppHangup)
{
BOOL	bTimedOut;

	ASSERT(hHangup != CC_INVALID_HANDLE);
	ASSERT(ppHangup != NULL);

step1:
	AcquireLock(&HangupTable.Lock);

	*ppHangup = HangupTable.pHead;
	while ((*ppHangup != NULL) && ((*ppHangup)->hHangup != hHangup))
		*ppHangup = (*ppHangup)->pNextInTable;

	if (*ppHangup != NULL) {
		AcquireTimedLock(&(*ppHangup)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&HangupTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&HangupTable.Lock);

	if (*ppHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateHangup(				HHANGUP					hHangup)
{
PHANGUP	pHangup;

	ASSERT(hHangup != CC_INVALID_HANDLE);

	AcquireLock(&HangupTable.Lock);

	pHangup = HangupTable.pHead;
	while ((pHangup != NULL) && (pHangup->hHangup != hHangup))
		pHangup = pHangup->pNextInTable;

	RelinquishLock(&HangupTable.Lock);

	if (pHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockHangup(				PHANGUP					pHangup)
{
	ASSERT(pHangup != NULL);

	RelinquishLock(&pHangup->Lock);
	return CC_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245ws.cpp ===
/***************************************************************************
 *
 * File: h245ws.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 *
 * $Workfile:   h245ws.cpp  $
 * $Revision:   2.11  $
 * $Modtime:   31 Jan 1997 19:22:28  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\h245ws.cpv  $
 * 
 *    Rev 2.11   31 Jan 1997 20:24:34   SBELL1
 * Relinquished CallControl Stack lock before DefWindowProc
 * 
 *    Rev 2.10   31 Jan 1997 14:54:12   EHOWARDX
 * Added CCLOCK support.
 *
 *    Rev 2.9   20 Jan 1997 20:42:34   SBELL1
 * Fixed GPF when shutting down.
 * 
 *    Rev 2.8   07 Jan 1997 11:51:48   EHOWARDX
 * 
 * Fixed "assignment within conditional expression" warning
 * in GetLinkLayerInstance().
 * 
 *    Rev 2.7   03 Jan 1997 13:15:18   EHOWARDX
 * Attempt at workaround for #1718 linkLayerListen() returns WSAENOBUFS.
 * 
 *    Rev 2.6   23 Dec 1996 15:30:16   EHOWARDX
 * 
 * Set window to zero after call to destroy window -- Uninitialize seems
 * to be called more than once.
 * 
 *    Rev 2.5   20 Dec 1996 17:49:10   SBELL1
 * changed to blocking mode before closesocket in SocketClose. 
 * This makes the linger work.
 * 
 *    Rev 2.4   19 Dec 1996 19:03:18   SBELL1
 * Moved Initialize to linkLayerInit
 * Set linger option on accept socket
 * reversed "new" change 
 * 
 *    Rev 2.3   Dec 13 1996 17:12:36   plantz
 * fixed string for UNICODE.
// 
//    Rev 1.3   13 Dec 1996 14:32:10   SBELL1
// fixed string for UNICODE.
// 
//    Rev 1.1   12 Dec 1996 17:59:02   SBELL1
// Fixed bug in lingering on Q.931 Listen socket.
// 
//    Rev 1.0   11 Dec 1996 13:41:14   SBELL1
// Initial revision.
 * 
 *    Rev 1.46   18 Oct 1996 16:46:12   EHOWARDX
 * 
 * Changed GetIpAddress to take wide char cAddr field.
 * 
 *    Rev 1.45   Oct 01 1996 14:29:56   EHOWARDX
 * Moved Initialize() and Unitialize() calls to DllMain().
 * 
 *    Rev 1.44   26 Sep 1996 18:52:10   EHOWARDX
 * 
 * Moved some initialization around to prevent possible ASSERTion failure
 * in SocketClose().
 * 
 *    Rev 1.43   15 Aug 1996 13:59:00   rodellx
 * 
 * Added additional address validation for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 * 
 *    Rev 1.42   Aug 07 1996 14:38:00   mandrews
 * Set bMulticast field of CC_ADDR structures correctly.
 * 
 *    Rev 1.41   24 Jul 1996 11:53:02   EHOWARDX
 * Changed ADDR to CC_ADDR, IP_XXX to CC_IP_XXX.
 * Fixed bug in SocketCloseEvent - needed to revalidate pHws after callback.
 * 
 *    Rev 1.40   08 Jul 1996 19:27:18   unknown
 * Second experiment to try to fix Q.931 shutdown problem.
 * 
 *    Rev 1.39   02 Jul 1996 16:23:02   EHOWARDX
 * Backed out experimental change.
 * 
 *    Rev 1.37   28 Jun 1996 18:06:50   unknown
 * Added breaks to GetPort.
 * 
 *    Rev 1.36   27 Jun 1996 14:06:06   EHOWARDX
 * Byte-swapped port number for debug trace in linkLayerListen & linkLayerConn
 * 
 *    Rev 1.35   21 Jun 1996 18:52:14   unknown
 * Fixed yet another shutdown bug - linkLayerShutdown re-entrancy check.
 * 
 *    Rev 1.34   18 Jun 1996 16:56:20   EHOWARDX
 * Added check to see if callback deallocated our instance to SocketConnect().
 * 
 *    Rev 1.33   17 Jun 1996 13:23:48   EHOWARDX
 * Workaround for PostQuitMessage() bug.
 * 
 *    Rev 1.32   12 Jun 1996 11:43:26   EHOWARDX
 * Changed linkLayerConnect errors from HWS_CRITICAL to HWS_WARNING.
 * 
 *    Rev 1.31   May 28 1996 18:14:00   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.30   May 28 1996 10:38:08   plantz
 * Change sprintf to wsprintf.
 * 
 *    Rev 1.29   17 May 1996 16:49:24   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.28   16 May 1996 13:09:18   EHOWARDX
 * Made reporting of IP Addres and port consistent between linkLayerListen
 * and LinkLayerConnect.
 * 
 *    Rev 1.27   14 May 1996 11:31:50   EHOWARDX
 * Fixed bug with doing another connect on instance that failed previous
 * connect. Instance now returns LINK_INVALID_STATE, and must be closed
 * and reopened.
 * 
 *    Rev 1.26   09 May 1996 18:33:22   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.25   Apr 29 1996 19:06:48   plantz
 * Reenable code to try to send all messages when shutting down.
 * 
 *    Rev 1.24   Apr 29 1996 14:02:58   plantz
 * Add NotifyRead and NotifyWrite functions.
 * Delete unused function FindH245Instance.
 * .
 * 
 *    Rev 1.23   Apr 25 1996 21:16:26   plantz
 * Add connect callback parameter to linkLayerAccept.
 * Pass message type to connect callback.
 * 
 *    Rev 1.22   Apr 24 1996 20:49:30   plantz
 * Listen on address passed to linkLayerListen; use INADDR_ANY if it is 0.
 * Return the result of getsockname after listening.
 * Add a callback parameter to linkLayerConnect. Call it when FD_CONNECT event
 * occurs and after calling accept, passing error code and local and peer
 * addresses.
 * 
 *    Rev 1.21   Apr 24 1996 16:55:20   plantz
 * Merge 1.15.1.0 with 1.20 (winsock 1 changes)
 * 
 *    Rev 1.20   19 Apr 1996 18:28:50   EHOWARDX
 * Changed Send and receive flush to call send and receive callback with
 * LINK_FLUSH_COMPLETE message to more accurately emulate behavior
 * of H245SRP.DLL.
 * 
 *    Rev 1.19   19 Apr 1996 10:34:26   EHOWARDX
 * Updated to latest LINKAPI.H - WINAPI keywork eliminated.
 * 
 *    Rev 1.18   12 Apr 1996 19:17:02   unknown
 * Removed annoying trace message.
 * 
 *    Rev 1.17   11 Apr 1996 14:53:22   EHOWARDX
 * Changed to include INCOMMON.H instead of CALLCONT.H.
 * 
 *    Rev 1.16   04 Apr 1996 12:35:04   EHOWARDX
 * Valiantly trying to track never-ending changes to Link Layer API
 * (Thanks Dan! Changing linkLayerGetInstId to linkLayerGetInstance() --
 * what a stroke of genius!)
 * 
 *    Rev 1.15.1.0   Apr 24 1996 16:23:02   plantz
 * Change to use winsock 1.
 * 
 *    Rev 1.15   03 Apr 1996 16:35:46   EHOWARDX
 * CLOSED state no longer implies that we have a thread;
 * replaced ASSERT with if statement.
 * 
 *    Rev 1.14   03 Apr 1996 14:52:24   EHOWARDX
 * Fixed yet another shutdown problem.
 * 
 *    Rev 1.13   02 Apr 1996 18:28:50   EHOWARDX
 * Added ProcessQueuedRecvs() to SocketAccept().
 * 
 *    Rev 1.12   01 Apr 1996 16:25:46   EHOWARDX
 * Experiment with calling ProcessRecvQueue on FD_WRITE event.
 * 
 *    Rev 1.11   01 Apr 1996 14:20:40   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.10   29 Mar 1996 11:12:56   EHOWARDX
 * Added line to SocketClose to set state to HWS_CLOSED.
 * 
 *    Rev 1.9   27 Mar 1996 13:00:30   EHOWARDX
 * Added dwThreadId to H245WS instance structure.
 * Reversed shutdown loop to check state first BEFORE checking send queue.
 * 
 *    Rev 1.8   22 Mar 1996 10:54:20   unknown
 * 
 * Minor change in trace text.
 * 
 *    Rev 1.7   20 Mar 1996 14:11:20   unknown
 * Added Sleep(0) to bind retry loop.
 * 
 *    Rev 1.6   19 Mar 1996 20:21:56   EHOWARDX
 * Redesigned shutdown.
 * 
 *    Rev 1.4   18 Mar 1996 19:08:28   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.3   14 Mar 1996 17:01:46   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.2   09 Mar 1996 21:12:26   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.1   08 Mar 1996 20:24:24   unknown
 * This is the real version of the main h245ws.dll code.
 * Version 1.0 was a stub version created by Mike Andrews.
 *
 ***************************************************************************/

#define LINKDLL_EXPORT
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment
#pragma warning ( disable : 4115 4201 4214 4514 )

#include "precomp.h"

//#include <winsock.h>
#include "queue.h"
#include "linkapi.h"
#include "incommon.h"
#include "h245ws.h"
#include "tstable.h"
#ifdef FORCE_SERIALIZE_CALL_CONTROL
#include "cclock.h"
#endif

#include "q931.h"
#include "hcall.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// REVIEW: Should we use the newer definition from winsock2.h ?
#undef FD_ALL_EVENTS
#define FD_ALL_EVENTS (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE)
#define WINSOCK_EVENT_MSG (WM_USER+1)

static HRESULT SocketOpen(PHWSINST pHws, BOOL bSetLinger = TRUE);
void Uninitialize();

/*
 * Static variables
 */
static BOOL bInitialized = FALSE;
static HWND        window   = 0;
TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table
static CRITICAL_SECTION SocketToHWSInstanceMapLock;
static SOCKET_TO_INSTANCE *pSocketToHWSInstanceMap = NULL;

// If we are not using the Unicode enabled tracing, then undefine the __TEXT macro.
// Do not place anything that should be a Unicode constant string between this #undef
// and the corresponding redefinition of the macro

#if defined(_DEBUG)
#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x

static const char * StateMap[] =

#else

static const LPTSTR StateMap[] =

#endif
{
   __TEXT("HWS_START"),         // 0  Initial state
   __TEXT("HWS_LISTENING"),     // 1  Waiting for FD_ACCEPT
   __TEXT("HWS_CONNECTING"),    // 2  Waiting for FD_CONNECT
   __TEXT("HWS_CONNECTED"),     // 3  Data transfer state
   __TEXT("HWS_CLOSING"),       // 4  Waiting for FD_CLOSE
   __TEXT("HWS_CLOSED"),        // 5  Waiting for linkLayerShutdown()
   __TEXT("HWS_SHUTDOWN"),      // 6  linkLayerShutdown() called from callback
};


static const ERROR_MAP ErrorMap[] =
{
   0,                     __TEXT("OK"),
   WSAEINTR,              __TEXT("WSAEINTR - Interrupted function call"),
   WSAEBADF,              __TEXT("WSAEBADF"),
   WSAEACCES,             __TEXT("WSAEACCES - Permission denied"),
   WSAEFAULT,             __TEXT("WSAEFAULT - Bad address"),
   WSAEINVAL,             __TEXT("WSAEINVAL - Invalid argument"),
   WSAEMFILE,             __TEXT("WSAEMFILE - Too many open files"),
   WSAEWOULDBLOCK,        __TEXT("WSAEWOULDBLOCK - Resource temporarily unavailable"),
   WSAEINPROGRESS,        __TEXT("WSAEINPROGRESS - Operation now in progress"),
   WSAEALREADY,           __TEXT("WSAEALREADY - Operation already in progress"),
   WSAENOTSOCK,           __TEXT("WSAENOTSOCK - Socket operation on non-socket"),
   WSAEDESTADDRREQ,       __TEXT("WSAEDESTADDRREQ - Destination address required"),
   WSAEMSGSIZE,           __TEXT("WSAEMSGSIZE - Message too long"),
   WSAEPROTOTYPE,         __TEXT("WSAEPROTOTYPE - Protocol wrong type for socket"),
   WSAENOPROTOOPT,        __TEXT("WSAENOPROTOOPT - Bad protocol option"),
   WSAEPROTONOSUPPORT,    __TEXT("WSAEPROTONOSUPPORT - Protocol not supported"),
   WSAESOCKTNOSUPPORT,    __TEXT("WSAESOCKTNOSUPPORT - Socket type not supported"),
   WSAEOPNOTSUPP,         __TEXT("WSAEOPNOTSUPP - Operation not supported"),
   WSAEPFNOSUPPORT,       __TEXT("WSAEPFNOSUPPORT - Protocol family not supported"),
   WSAEAFNOSUPPORT,       __TEXT("WSAEAFNOSUPPORT - Address family not supported by protocol family"),
   WSAEADDRINUSE,         __TEXT("WSAEADDRINUSE - Address already in use"),
   WSAEADDRNOTAVAIL,      __TEXT("WSAEADDRNOTAVAIL - Cannot assign requested address"),
   WSAENETDOWN,           __TEXT("WSAENETDOWN - Network is down"),
   WSAENETUNREACH,        __TEXT("WSAENETUNREACH - Network is unreachable"),
   WSAENETRESET,          __TEXT("WSAENETRESET - Network dropped connection on reset"),
   WSAECONNABORTED,       __TEXT("WSAECONNABORTED - Software caused connection abort"),
   WSAECONNRESET,         __TEXT("WSAECONNRESET - Connection reset by peer"),
   WSAENOBUFS,            __TEXT("WSAENOBUFS - No buffer space available"),
   WSAEISCONN,            __TEXT("WSAEISCONN - Socket is already connected"),
   WSAENOTCONN,           __TEXT("WSAENOTCONN - Socket is not connected"),
   WSAESHUTDOWN,          __TEXT("WSAESHUTDOWN - Cannot send after socket shutdown"),
   WSAETOOMANYREFS,       __TEXT("WSAETOOMANYREFS"),
   WSAETIMEDOUT,          __TEXT("WSAETIMEDOUT - Connection timed out"),
   WSAECONNREFUSED,       __TEXT("WSAECONNREFUSED - Connection refused"),
   WSAELOOP,              __TEXT("WSAELOOP"),
   WSAENAMETOOLONG,       __TEXT("WSAENAMETOOLONG"),
   WSAEHOSTDOWN,          __TEXT("WSAEHOSTDOWN - Host is down"),
   WSAEHOSTUNREACH,       __TEXT("WSAEHOSTUNREACH - No route to host"),
   WSAENOTEMPTY,          __TEXT("WSAENOTEMPTY"),
   WSAEPROCLIM,           __TEXT("WSAEPROCLIM - Too many processes"),
   WSAEUSERS,             __TEXT("WSAEUSERS"),
   WSAEDQUOT,             __TEXT("WSAEDQUOT"),
   WSAESTALE,             __TEXT("WSAESTALE"),
   WSAEREMOTE,            __TEXT("WSAEREMOTE"),
   WSASYSNOTREADY,        __TEXT("WSASYSNOTREADY - Network subsystem is unavailable"),
   WSAVERNOTSUPPORTED,    __TEXT("WSAVERNOTSUPPORTED - WINSOCK.DLL version out of range"),
   WSANOTINITIALISED,     __TEXT("WSANOTINITIALISED - Successful WSAStartup() not yet performed"),
   WSAEDISCON,            __TEXT("WSAEDISCON - Graceful shutdown in progress"),
   WSAHOST_NOT_FOUND,     __TEXT("WSAHOST_NOT_FOUND - Host not found"),
   WSATRY_AGAIN,          __TEXT("WSATRY_AGAIN - Non-authoritative host not found"),
   WSANO_RECOVERY,        __TEXT("WSANO_RECOVERY - This is a non-recoverable error"),
   WSANO_DATA,            __TEXT("WSANO_DATA - Valid name, no data record of requested type"),
//   WSA_INVALID_HANDLE,    __TEXT("WSA_INVALID_HANDLE - Specified event object handle is invalid"),
//   WSA_INVALID_PARAMETER, __TEXT("WSA_INVALID_PARAMETER - One or more parameters are invalid"),
//   WSA_IO_PENDING,        __TEXT("WSA_IO_PENDING - Overlapped operations will complete later"),
//   WSA_IO_INCOMPLETE,     __TEXT("WSA_IO_INCOMPLETE - Overlapped I/O event object not in signaled state"),
//   WSA_NOT_ENOUGH_MEMORY, __TEXT("WSA_NOT_ENOUGH_MEMORY - Insufficient memory available"),
//   WSA_OPERATION_ABORTED, __TEXT("WSA_OPERATION_ABORTED - Overlapped operation aborted"),
};



//
// Function Definitions
//

#include <string.h>

#ifdef UNICODE_TRACE
static const LPTSTR
#else
static const char *
#endif
SocketStateText(UINT uState)
{
#ifdef UNICODE_TRACE
   static TCHAR      szSocketStateText[80];
#else
   static char       szSocketStateText[80];
#endif

   if (uState <= HWS_SHUTDOWN)
      return StateMap[uState];
   wsprintf(szSocketStateText, __TEXT("Unknown state %d"), uState);
   return szSocketStateText;
} // SocketStateText()



#ifdef UNICODE_TRACE
static LPCTSTR
#else
static const char *
#endif
SocketErrorText1(int nErrorCode)
{
   register int      nIndex = sizeof(ErrorMap) / sizeof(ErrorMap[0]);
#ifdef UNICODE_TRACE
   static TCHAR      szSocketErrorText[80];
#else
   static char       szSocketErrorText[80];
#endif


   while (nIndex > 0)
   {
      if (ErrorMap[--nIndex].nErrorCode == nErrorCode)
      {
         return ErrorMap[nIndex].pszErrorText;
      }
   }
   wsprintf(szSocketErrorText, __TEXT("Unknown error 0x%x"), nErrorCode);
   return szSocketErrorText;
} // SocketErrorText1()

#ifdef UNICODE_TRACE
LPCTSTR
#else
const char *
#endif
SocketErrorText(void)
{
   return SocketErrorText1(WSAGetLastError());
} // SocketErrorText()

#endif  // (_DEBUG)


/***************************************************************************
 *
 * Local routines
 *
 ***************************************************************************/

static DWORD
HashSocket(SOCKET socket)
{
	return(DWORD)((socket >> 2) % SOCK_TO_PHYSID_TABLE_SIZE);
}



DWORD
SocketToPhysicalId(SOCKET socket)
{
	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	if(pSocketToHWSInstanceMap == NULL)
		return(INVALID_PHYS_ID);

	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	while(pEntry != NULL) 
	{
		if(pEntry->socket == socket)
		{
			LeaveCriticalSection(&SocketToHWSInstanceMapLock);
			return(pEntry->dwPhysicalId);
		} else
		{
			pEntry = pEntry->next;
		}
	}

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(INVALID_PHYS_ID);

} // SocketToPhysicalId()

BOOL
CreateSocketToPhysicalIdMapping(SOCKET socket, DWORD dwPhysicalId)
{
	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	
	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	PSOCKET_TO_INSTANCE pNewEntry;
	if (pEntry->socket == INVALID_SOCKET) 
	{
		pNewEntry = pEntry; 
	} else
	{
		pNewEntry = new SOCKET_TO_INSTANCE;
		if (pNewEntry == NULL) 
		{
			LeaveCriticalSection(&SocketToHWSInstanceMapLock);
			return(FALSE);
		}
		pNewEntry->next = pEntry->next;
		pEntry->next = pNewEntry;
	}

	pNewEntry->socket = socket;
	pNewEntry->dwPhysicalId = dwPhysicalId;

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(TRUE);
}

BOOL
RemoveSocketToPhysicalIdMapping(SOCKET socket)
{

	if (socket == INVALID_SOCKET)
		return(FALSE);

	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	BOOL bFound = FALSE;

	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	if (pEntry->socket == socket) 
	{
		pEntry->socket = INVALID_SOCKET;
		bFound = TRUE;
	} else
	{
		PSOCKET_TO_INSTANCE pNextEntry;
		pNextEntry = pEntry->next;
		while (bFound == FALSE && pNextEntry != NULL)
		{
			if(pNextEntry->socket == socket)
			{
				pEntry->next = pNextEntry->next;
				delete pNextEntry;
				bFound = TRUE;
			} else
			{
				pEntry     = pNextEntry;
				pNextEntry = pNextEntry->next;
			}
		}
	}

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(bFound);
}

static unsigned short GetPort (CC_ADDR *pAddr)
{
   unsigned short int port = 0;
   switch (pAddr->nAddrType)
   {
   case CC_IP_DOMAIN_NAME:
      port = pAddr->Addr.IP_DomainName.wPort;
      break;

   case CC_IP_DOT:
      port = pAddr->Addr.IP_Dot.wPort;
      break;

   case CC_IP_BINARY:
      port = pAddr->Addr.IP_Binary.wPort;
      break;

   } // switch

   return htons(port);
} // GetPort()


static unsigned long GetIPAddress (CC_ADDR *pAddr)
{
   struct hostent *     pHostEnt;
   char                 szAddr[256];

   switch (pAddr->nAddrType)
   {
   case CC_IP_DOMAIN_NAME:
      WideCharToMultiByte(CP_ACP,           // code page
                          0,                // dwFlags
                          pAddr->Addr.IP_DomainName.cAddr,
                          -1,               // Unicode string length (bytes)
                          szAddr,           // ASCII string
                          sizeof(szAddr),   // max ASCII string length
                          NULL,             // default character
                          NULL);            // default character used
      pHostEnt = gethostbyname(szAddr);
      if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
         return 0;
      return *((unsigned long *)pHostEnt->h_addr_list[0]);

   case CC_IP_DOT:
      WideCharToMultiByte(CP_ACP,           // code page
                          0,                // dwFlags
                          pAddr->Addr.IP_Dot.cAddr,
                          -1,               // Unicode string length (bytes)
                          szAddr,           // ASCII string
                          sizeof(szAddr),   // max ASCII string length
                          NULL,             // default character
                          NULL);            // default character used
      return inet_addr(szAddr);

   case CC_IP_BINARY:
       return pAddr->Addr.IP_Binary.dwAddr == 0 ? INADDR_ANY : htonl(pAddr->Addr.IP_Binary.dwAddr);
   } // switch
   return 0;
} // GetIPAddress()


static HRESULT GetLocalAddr(PHWSINST pHws, CC_ADDR *pAddr)
{
    SOCKADDR_IN sockaddr;
    int len = sizeof(sockaddr);

    if (getsockname(pHws->hws_Socket,
                    (struct sockaddr *)&sockaddr,
                    &len) == SOCKET_ERROR)
    {
        return MAKE_WINSOCK_ERROR(WSAGetLastError());
    }

    pAddr->nAddrType = CC_IP_BINARY;
	pAddr->bMulticast = FALSE;
    pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
    pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

    return NOERROR;
}

static HRESULT GetPeerAddr(PHWSINST pHws, CC_ADDR *pAddr)
{
    SOCKADDR_IN sockaddr;
    int len = sizeof(sockaddr);

    if (getpeername(pHws->hws_Socket,
                    (struct sockaddr *)&sockaddr,
                    &len) == SOCKET_ERROR)
    {
        return MAKE_WINSOCK_ERROR(WSAGetLastError());
    }

    pAddr->nAddrType = CC_IP_BINARY;
	pAddr->bMulticast = FALSE;
    pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
    pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

    return NOERROR;
}


static void
SocketFlushRecv(PHWSINST pHws)
{
   register PREQUEST    pReq;

   if (pHws->hws_pRecvQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
      {
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
   }
   pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                              LINK_FLUSH_COMPLETE,
                              NULL,
                              0);
} // SocketFlushRecv()



static void
SocketFlushSend(PHWSINST pHws)
{
   register PREQUEST    pReq;

   if (pHws->hws_pSendQueue)
   {
      while ((pReq = (PREQUEST)  QRemove(pHws->hws_pSendQueue)) != NULL)
      {
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
   }
   pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                              LINK_FLUSH_COMPLETE,
                              NULL,
                              0);
} // SocketFlushSend()



void
SocketCloseEvent(PHWSINST pHws)
{
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketCloseEvent"));
   if (pHws->hws_uState == HWS_CONNECTED)
   {
      register DWORD dwPhysicalId = pHws->hws_dwPhysicalId;
      pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,LINK_RECV_CLOSED,0,0);

      // Check to see if callback deallocated our instance or state changed

      if(gpInstanceTable->Validate(dwPhysicalId) == FALSE)
        return;

      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
				__TEXT("SocketCloseEvent: calling shutdown"));
      if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("HandleNetworkEvent: shutdown() returned %s"),
                  SocketErrorText());
      }
   }
   pHws->hws_uState = HWS_CLOSED;
} // SocketCloseEvent()



/*
 * DESCRIPTION
 *    Deallocate all allocated objects except for task handle
 */

static void
SocketClose(PHWSINST pHws)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketClose"));

   pHws->hws_uState = HWS_CLOSED;

   RemoveSocketToPhysicalIdMapping(pHws->hws_Socket);

   // Close the socket
   if (pHws->hws_Socket != INVALID_SOCKET)
   {
      // To make the linger work, turn off WSAAsyncSelect to turn off 
      // non-blocking via ioctlsocket, to close the socket.
      unsigned long blocking = 0;
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                __TEXT("SocketClose: calling closesocket"));
         
      WSAAsyncSelect(pHws->hws_Socket,
                     window, WINSOCK_EVENT_MSG,
                     0);
      ioctlsocket(pHws->hws_Socket, FIONBIO,&blocking);
      if (closesocket(pHws->hws_Socket) == SOCKET_ERROR)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("SocketClose: closesocket() returned %s"),
                   SocketErrorText());
      }
      pHws->hws_Socket = INVALID_SOCKET;
   }

} // SocketClose()



static HRESULT
SocketOpen(PHWSINST pHws, BOOL bSetLinger)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketOpen"));

   // Create a socket
   pHws->hws_Socket = socket(AF_INET, SOCK_STREAM, 0);
   if (pHws->hws_Socket == INVALID_SOCKET)
   {
      // WSASocket() failed
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("SocketOpen: socket() returned %s"),
                SocketErrorText1(err));
      SocketClose(pHws);
      return MAKE_WINSOCK_ERROR(err);
   }

   /*
   ** Request notification messages for all events on this socket.
   ** Note that this call automatically puts the socket into non-blocking
   ** mode, as if we had called WSAIoctl with the FIONBIO flag.
   **/
   if (WSAAsyncSelect(pHws->hws_Socket,
                      window, WINSOCK_EVENT_MSG,
                      FD_ALL_EVENTS) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketOpen: WSAASyncSelect() returned %s"),
                  SocketErrorText1(err));
      SocketClose(pHws);
      return MAKE_WINSOCK_ERROR(err);
   }

   if(bSetLinger == TRUE)
   {
		// Set a linger structure for the socket so that closesocket will block for a period of time (until all
		// data is sent or the timeout value) before actually killing the connection.
		// This change is being made in order to get rid of the PeekMessage() loops in linklayerShutdown().
		struct linger sockLinger;
		sockLinger.l_onoff = 1;				// yes we want to linger (wait for FIN ACK after sending data and FIN)
		sockLinger.l_linger = 1;			// linger for up to 1 second

	 
		if(setsockopt (pHws->hws_Socket,
								SOL_SOCKET,
								SO_LINGER,
								(const char*) &sockLinger,
								sizeof(sockLinger)) == SOCKET_ERROR)
		{
            int err = WSAGetLastError();
            HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketOpen: setsockopt returned %s"),
                  SocketErrorText1(err));
            SocketClose(pHws);
            return MAKE_WINSOCK_ERROR(err);
		}

	 }

   // add an entry in the socket to instance map
	if(CreateSocketToPhysicalIdMapping(pHws->hws_Socket, pHws->hws_dwPhysicalId) != TRUE)
	{
		HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
			__TEXT("SocketOpen: CreateSocketToPhysicalIdMapping() failed"));
		SocketClose(pHws);
		return(LINK_MEM_FAILURE);
	}

   return NOERROR;
} // SocketOpen()



static HRESULT
SocketBind(PHWSINST pHws, CC_ADDR *pAddr)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pAddr != NULL);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketBind"));

   // Get a local address to bind the socket to
   pHws->hws_SockAddr.sin_family           = AF_INET;
   pHws->hws_SockAddr.sin_port             = GetPort(pAddr);
   pHws->hws_SockAddr.sin_addr.S_un.S_addr = GetIPAddress(pAddr);
   if ((pAddr->nAddrType == CC_IP_DOMAIN_NAME) &&
           (pHws->hws_SockAddr.sin_addr.S_un.S_addr == 0))
   {
       return LINK_UNKNOWN_ADDR;
   }

   // Bind the socket
   while (bind(pHws->hws_Socket,                            // s
               (const struct sockaddr *)&pHws->hws_SockAddr, // name
               sizeof(pHws->hws_SockAddr)) == SOCKET_ERROR)      // namelen
   {
      // bind() failed
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("SocketBind: bind() returned %s"),
                SocketErrorText1(err));
      if (err != WSAENOBUFS)
      {
         return MAKE_WINSOCK_ERROR(err);
      }
      Sleep(0);
   }

   return NOERROR;
} // SocketBind()

static void
SocketConnect(PHWSINST pHws, int error)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketConnect"));

   if (error == 0)
   {
       pHws->hws_uState = HWS_CONNECTED;

       if (pHws->hws_h245ConnectCallback)
       {
            CC_ADDR   LocalAddr;
            CC_ADDR   PeerAddr;
            PCC_ADDR  pLocalAddr = &LocalAddr;
            PCC_ADDR  pPeerAddr  = &PeerAddr;
            DWORD     dwPhysicalId = pHws->hws_dwPhysicalId;
            HRESULT     hr;

            hr = GetLocalAddr(pHws, pLocalAddr);
            if (FAILED(hr))
            {
                WARNING_OUT(("SocketConnect - failed to get local address w/ error 0x%08x", hr));
                pLocalAddr = NULL;
            }
            else
            {
                hr = GetPeerAddr(pHws, pPeerAddr);
                if (FAILED(hr))
                {
                    WARNING_OUT(("SocketConnect - failed to get remote address w/ error 0x%08x", hr));
                    pPeerAddr = NULL;
                }
                else
                {
                    // All is OK
                    hr = LINK_CONNECT_COMPLETE;
                }
            }

            pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                hr, pLocalAddr, pPeerAddr);

            // Check to see if callback deallocated our instance - this can be done
		    // by attempting a lock - which will now fail if the entry has been marked
		    // for deletion.  Thus, if the lock succeeds, then just unlock it (since we 
		    // already have a lock on it).

		    if (gpInstanceTable->Validate(dwPhysicalId) == FALSE)
			    return;
       }

       NotifyWrite(pHws);
       NotifyRead(pHws);
   }
   else
   {
      if (pHws->hws_h245ConnectCallback)
      {
         pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                       MAKE_WINSOCK_ERROR(error), NULL, NULL);
      }
   }
} // SocketConnect()

static HRESULT
SocketAccept(PHWSINST pHwsListen, PHWSINST pHwsAccept)
{
   SOCKET listen_socket = pHwsListen->hws_Socket;
   struct linger sockLinger;
   sockLinger.l_onoff = 1;	// yes we want to linger (wait for FIN ACK after sending data and FIN)
   sockLinger.l_linger = 1;	// linger for up to 1 second

   // Accept the connection.
   pHwsAccept->hws_uSockAddrLen = sizeof(pHwsAccept->hws_SockAddr);
   pHwsAccept->hws_Socket = accept(pHwsListen->hws_Socket,
                       (struct sockaddr *)&pHwsAccept->hws_SockAddr,
                       (int *)&pHwsAccept->hws_uSockAddrLen);

   if (pHwsAccept->hws_Socket == INVALID_SOCKET)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHwsAccept->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerAccept: accept() returned %s"),
                SocketErrorText1(err));
      SocketConnect(pHwsAccept, err);
      return MAKE_WINSOCK_ERROR(err);
   }

   if (pHwsListen == pHwsAccept)
   {
      HWSTRACE0(pHwsListen->hws_dwPhysicalId, HWS_TRACE,
                __TEXT("SocketClose: calling closesocket"));
      closesocket(listen_socket);
      RemoveSocketToPhysicalIdMapping(listen_socket);
   }

   
   // Set a linger structure for the socket so that closesocket will block for a period of time (until all
   // data is sent or the timeout value) before actually killing the connection.
   // This change is being made in order to get rid of the PeekMessage() loops in linklayerShutdown().
   if(setsockopt (pHwsAccept->hws_Socket,
                  SOL_SOCKET,
	     		  SO_LINGER,
                  (const char*) &sockLinger,
                  sizeof(sockLinger)) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHwsAccept->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketAccept: setsockopt returned %s"),
                  SocketErrorText1(err));
      SocketClose(pHwsAccept);
      return MAKE_WINSOCK_ERROR(err);
   }
   

   // add the new socket to the socket to phys id map
   CreateSocketToPhysicalIdMapping(pHwsAccept->hws_Socket, pHwsAccept->hws_dwPhysicalId);

   SocketConnect(pHwsAccept, 0);
   return NOERROR;
} // SocketAccept()



/*++

Description:

   Handles network events that may occur on a connected socket.
   The events handled by this function are FD_ACCEPT, FD_CLOSE, FD_READ, and
   FD_WRITE.

Arguments:

   pHws - pointer to data for the connection on which the event happened.
   event - event that occurred
   error - error code accompanying the event

Return Value:

   SUCCESS - The network event was successfully handled.

   LINK_FATAL_ERROR - Some kind of error occurred while handling the
   event, and the connection should be closed.

   LINK_RECV_CLOSED - The connection has been gracefully closed.

--*/

static void
HandleNetworkEvent(PHWSINST pHws, int event, int error)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("HandleNetworkEvent"));

   if (error == WSAENETDOWN)
   {
       HWSTRACE0(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                 __TEXT("HandleSocketEvent: Connection error"));
       pHws->hws_uState = HWS_CLOSED;
       return;
   }

   switch (event)
   {
   case FD_READ:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_READ %s"),
                SocketErrorText1(error));
      if (error == 0 && pHws->hws_uState <= HWS_CLOSING)
      {
         ProcessQueuedRecvs(pHws);
      }
      break;

   case FD_WRITE:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_WRITE %s"),
                SocketErrorText1(error));
      if (error == 0 && pHws->hws_uState <= HWS_CONNECTED)
      {
         ProcessQueuedSends(pHws);
      }
      break;

   case FD_OOB:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_OOB %s"),
                SocketErrorText1(error));
      break;


   case FD_ACCEPT:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_ACCEPT %s"),
                SocketErrorText1(error));
      if (pHws->hws_h245ConnectCallback != NULL)
      {
         if (error == 0)
         {
             pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                           LINK_CONNECT_REQUEST, NULL, NULL);
         }
         else
         {
             pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                           MAKE_WINSOCK_ERROR(error), NULL, NULL);
         }
      }
      else if (error == 0)
      {
         // If the client did not specify a callback, accept the call using the same physical
         // Id as the listen. This will result in the listen socket being closed.
         SocketAccept(pHws, pHws);
      }
      break;

   case FD_CONNECT:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_CONNECT %s"),
                SocketErrorText1(error));
      SocketConnect(pHws, error);
      break;

   case FD_CLOSE:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_CLOSE %s"),
                SocketErrorText1(error));
      SocketCloseEvent(pHws);
      break;
   }
} // HandleNetworkEvent()


LRESULT APIENTRY WndProc(
        HWND hWnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,              /* additional information          */
        LPARAM lParam)              /* additional information          */
{
   PHWSINST pHws;
   DWORD dwPhysicalId;

#ifdef FORCE_SERIALIZE_CALL_CONTROL
	 CCLOCK_AcquireLock();
#endif 

   switch (message)
   {
   case WINSOCK_EVENT_MSG:
		if (((dwPhysicalId=SocketToPhysicalId((SOCKET)wParam)) == INVALID_PHYS_ID) ||
				((pHws=gpInstanceTable->Lock(dwPhysicalId)) == NULL))

      {
         HWSTRACE1(0, HWS_WARNING,
                   __TEXT("WndProc: Winsock event on unknown socket 0x%x"),
                   wParam);
         break;
      }

      HandleNetworkEvent(pHws, WSAGETSELECTEVENT(lParam), WSAGETSELECTERROR(lParam));
	  gpInstanceTable->Unlock(dwPhysicalId);

      break;

   default:
   		{
   		#ifdef FORCE_SERIALIZE_CALL_CONTROL
	        CCLOCK_RelinquishLock();
		#endif 
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
   }
   
   #ifdef FORCE_SERIALIZE_CALL_CONTROL
           CCLOCK_RelinquishLock();
   #endif 
   
   return (0);
}

void NotifyRead(PHWSINST pHws)
{
   PostMessage(window, WINSOCK_EVENT_MSG, (WPARAM)pHws->hws_Socket, (LPARAM)MAKELONG(FD_READ, 0));
}

void NotifyWrite(PHWSINST pHws)
{
   PostMessage(window, WINSOCK_EVENT_MSG, (WPARAM)pHws->hws_Socket, (LPARAM)MAKELONG(FD_WRITE, 0));
}

/*++

Description:

   Calls WSAStartup, makes sure we have a good version of WinSock

Arguments:

   None.

Return Value:
   0                 WinSock DLL successfully started up.
   LINK_FATAL_ERROR  Error starting up WinSock DLL.

--*/


static const TCHAR CLASS_NAME[] = __TEXT("H245WSWndClass");

int     WinsockInitError = -1;
HRESULT InitializeStatus = LINK_INVALID_STATE;

LINKDLL VOID H245WSShutdown()
{
	Uninitialize();
}

void Initialize()
{
   WORD wVersion = MAKEWORD(1, 1);
   WSADATA  WsaData;      // receives data from WSAStartup
   WNDCLASS wndclass = { 0, WndProc, 0, 0, 0, 0, 0, 0, NULL, CLASS_NAME };
   DWORD    dwIndex;

   // Caveat: We can't use WSAGetLastError() for WSAStartup failure!
   if ((WinsockInitError = WSAStartup(wVersion, &WsaData)) != 0)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: WSAStartup() failed"));
      InitializeStatus = MAKE_WINSOCK_ERROR(WinsockInitError);
      return;
   }

   if (LOBYTE(WsaData.wVersion) != 1 ||
       HIBYTE(WsaData.wVersion) != 1)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: Winsock version mismatch"));
      InitializeStatus = MAKE_WINSOCK_ERROR(WSAVERNOTSUPPORTED);
      return;
   }

   // Create window to receive Winsock messages
   if (RegisterClass(&wndclass) == 0
       || (window = CreateWindow(CLASS_NAME, __TEXT(""), WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, 0, NULL)) == 0)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: error creating window"));
      InitializeStatus = HRESULT_FROM_WIN32(GetLastError());
      return;
   }

    //
    // LAURABU
    // BOGUS BUGBUG
    // 
    // This table code was never stressed by the people who wrote it.  It
    // totally falls apart when it completely fills up
    //      * Allocating the last item doesn't work
    //      * Freeing the last item doesn't work
    //      * Resizing larger doesn't work
    //
    // Since it doesn't take a lot of memory, a decent solution is to just
    // allocate it maximum+1 sized, and leave the last item free.
    //
   gpInstanceTable = new TSTable <HWSINST> (257);

   if(gpInstanceTable == NULL || gpInstanceTable->IsInitialized() == FALSE)
   {
	  InitializeStatus = LINK_MEM_FAILURE;
      return;
   }
      
   pSocketToHWSInstanceMap = new SOCKET_TO_INSTANCE[SOCK_TO_PHYSID_TABLE_SIZE];
   if(pSocketToHWSInstanceMap == NULL)
   {
	  InitializeStatus = LINK_MEM_FAILURE;
      return;
   }
   InitializeCriticalSection(&SocketToHWSInstanceMapLock);

   memset(pSocketToHWSInstanceMap, 0, sizeof(SOCKET_TO_INSTANCE) * SOCK_TO_PHYSID_TABLE_SIZE);
	
   // Init the sockets to a bad value

   for (dwIndex = 0; dwIndex < SOCK_TO_PHYSID_TABLE_SIZE; dwIndex++)
   {
      pSocketToHWSInstanceMap[dwIndex].socket = INVALID_SOCKET;
   }

   InitializeStatus = NOERROR;
   bInitialized = TRUE;
}

void Uninitialize()
{
   if(bInitialized)
   {
	   if (WinsockInitError == 0)
	   {
	      if (window)
	      {
	         DestroyWindow(window);
	         window = 0;
	         UnregisterClass(CLASS_NAME, 0);

	         if (gpInstanceTable)
	         {
	            delete gpInstanceTable;

	            if (InitializeStatus == NOERROR)
	            {
	               EnterCriticalSection(&SocketToHWSInstanceMapLock);
	               delete pSocketToHWSInstanceMap;
	               LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	               DeleteCriticalSection(&SocketToHWSInstanceMapLock);
	            }
	         }
	      }
	      WSACleanup();
	   }
	   bInitialized = FALSE;
   }
 }


/***************************************************************************
 *
 * External entry points
 *
 ***************************************************************************/
//MULTITHREAD => dwH245Instance is now an OUTPUT param not an INPUT param.
LINKDLL HRESULT linkLayerInit (DWORD          *dwPhysicalId,
                              DWORD_PTR          dwH245Instance,
                              H245SRCALLBACK cbReceiveComplete,
                              H245SRCALLBACK cbTransmitComplete)
{
   register PHWSINST    pHws;
   *dwPhysicalId = INVALID_PHYS_ID; // Just in case...

   // Put Initialize back in here so we know everything we need is up and
   // running.
   if (InitializeStatus == LINK_INVALID_STATE)
      Initialize();
  
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   pHws = (PHWSINST)MemAlloc(sizeof(*pHws));
   if (pHws == NULL)
   {
      // couldn't allocate our context. Return
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate context"));
      return LINK_MEM_FAILURE;
   }
   memset(pHws, 0, sizeof(*pHws));
   pHws->hws_Socket           = INVALID_SOCKET;
#if defined(_DEBUG)
   pHws->hws_dwMagic = HWSINST_MAGIC;
#endif  // (_DEBUG)

   // Create and initialize the Receive queue
   pHws->hws_pRecvQueue = QCreate();
   if (pHws->hws_pRecvQueue == NULL)
   {
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate Receive queue"));
      MemFree(pHws);
      return LINK_MEM_FAILURE;
   }

   // Create and initialize the Send queue
   pHws->hws_pSendQueue = QCreate();
   if (pHws->hws_pSendQueue == NULL)
   {
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate Send queue"));
      QFree(pHws->hws_pRecvQueue);
      MemFree(pHws);
      return LINK_MEM_FAILURE;
   }

   // Save intance identifiers and callback pointers
   pHws->hws_uState           = HWS_START;
   pHws->hws_dwH245Instance   = dwH245Instance;
   pHws->hws_h245RecvCallback = cbReceiveComplete;
   pHws->hws_h245SendCallback = cbTransmitComplete;

   // Open Channel 0 for the Forward and Reverse Directions
   // TBD

   // Add instance to instance list

   if(!gpInstanceTable->CreateAndLock(pHws, &pHws->hws_dwPhysicalId))
   {
      Q931HangupPendingCalls(NULL);

      if(!gpInstanceTable->CreateAndLock(pHws, &pHws->hws_dwPhysicalId))
      {
         HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not add to instance table"));
         QFree(pHws->hws_pSendQueue);
         QFree(pHws->hws_pRecvQueue);
         MemFree(pHws);
         return LINK_INSTANCE_TABLE_FULL;
      }
   }
   
   *dwPhysicalId = pHws->hws_dwPhysicalId;

   gpInstanceTable->Unlock(pHws->hws_dwPhysicalId);

   HWSTRACE2(*dwPhysicalId, HWS_TRACE,
             __TEXT("linkLayerInit(%d, %d) succeeded"), dwPhysicalId, dwH245Instance);

   return NOERROR;
} // linkLayerInit()



LINKDLL HRESULT linkLayerShutdown(DWORD dwPhysicalId)
{
   register PHWSINST    pHws;
   UINT                 uRetryCount;
   register PREQUEST    pReq;

   if (InitializeStatus != NOERROR)
      return InitializeStatus;
	
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerShutdown: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   // mark this instance as deleted so we don't process anymore messages for it - 
   // note: the FALSE indicates to the TSTable class to NOT do the deletion of memory
   // once the last unlock has completed (which is at the end of this function)
   gpInstanceTable->Delete(dwPhysicalId, FALSE);

   RemoveSocketToPhysicalIdMapping(pHws->hws_Socket);

   switch (pHws->hws_uState)
   {
   case HWS_START:
   case HWS_LISTENING:
   case HWS_CONNECTING:
      break;

   case HWS_CONNECTED:
      // Try to send all messages waiting on send queue
      HWSASSERT(pHws->hws_pSendQueue != NULL);
      ProcessQueuedSends(pHws);
      uRetryCount = 0;
      while (  pHws->hws_uState == HWS_CONNECTED &&
               IsQEmpty(pHws->hws_pSendQueue) == FALSE &&
               ++uRetryCount <= 5)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                   __TEXT("linkLayerShutdown: Waiting for send %d"), uRetryCount);
         ProcessQueuedSends(pHws);
         Sleep(100);
      }

      if (pHws->hws_uState == HWS_CONNECTED)
      {
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                   __TEXT("linkLayerShutdown: calling shutdown"));
         if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
         {
            HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                     __TEXT("linkLayerShutdown: shutdown() returned %s"),
                     SocketErrorText());
         }
         pHws->hws_uState = HWS_CLOSING;
      }

   case HWS_CLOSING:
      break;

   case HWS_CLOSED:
      break;

   default:
      HWSASSERT(FALSE);
   } // switch

   // Deallocate instance objects

   SocketClose(pHws);


   // Deallocate Receive queue
   if (pHws->hws_pRecvQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
      {
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
      QFree(pHws->hws_pRecvQueue);
      pHws->hws_pRecvQueue = NULL;
   }

   // Deallocate Send queue
   if (pHws->hws_pSendQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pSendQueue)) != NULL)
      {
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
      QFree(pHws->hws_pSendQueue);
      pHws->hws_pSendQueue = NULL;
   }

   gpInstanceTable->Unlock(dwPhysicalId);

   MemFree(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerShutdown: succeeded"));
   return NOERROR;
} // linkLayerShutdown



/***************************************************************************
 *
 *  NAME
 *      linkLayerGetInstance - return instance id corresponding to physical id
 *
 *  SYNOPSIS
 *      LINKDLL DWORD linkLayerGetInstance(DWORD dwPhysicalId);
 *
 * DESCRIPTION
 *      Returns the Instance identifier corresponding to dwPhysId.
 *
 *  PARAMETERS
 *      dwPhysicalId    Physical identifier to search for
 *
 *  RETURN VALUE
 //MULTITHREAD
 *      INVALID_PHYS_ID    (-1)No instance corresponding to dwPhysicalId found
 *      n>0             Instance Id corresponding to dwPhysicalId
 *
 ***************************************************************************/

LINKDLL DWORD linkLayerGetInstance(DWORD dwPhysicalId)
{
   if (InitializeStatus == NOERROR &&
       dwPhysicalId != INVALID_PHYS_ID &&
       gpInstanceTable->Lock(dwPhysicalId) != NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerGetInstance: succeeded"));
      gpInstanceTable->Unlock(dwPhysicalId); 
      return dwPhysicalId;
   }

   HWSTRACE0(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerGetInstance: failed"));
   return INVALID_PHYS_ID;                           // return failure
} // linkLayerGetInstance()



/***************************************************************************
 *
 * NAME
 *    linkLayerFlushChannel - flush transmit and/or receive channels
 *
 * DESCRIPTION
 *    This is a dummy function required only for compatibility with the SRP API.
 *
 * RETURN VALUE
 *    0           Function succeeded.
 *    n!=0        Link error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/

LINKDLL HRESULT linkLayerFlushChannel(DWORD dwPhysicalId, DWORD dwDirectionMask)
{
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   PHWSINST pHws;
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerFlushChannel: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   switch (dwDirectionMask & (DATALINK_RECEIVE | DATALINK_TRANSMIT))
   {
   case DATALINK_TRANSMIT | DATALINK_RECEIVE:
      // Flush both receive and transmit
      // Caveat: H.245 expects us to flush receive first!
      SocketFlushRecv(pHws);

      // Fall through to next case

   case DATALINK_TRANSMIT:
      // Flush transmit
      // SockFlushSend() just removes the entries from the queue - it doesn't send them.
      // So instead, call ProcessQueuedSends() to actually empty the send queue.
      //      SocketFlushSend(pHws);	
			ProcessQueuedSends(pHws);
      break;

   case DATALINK_RECEIVE:
      // Flush receive
      SocketFlushRecv(pHws);
      break;

   } // switch

 	gpInstanceTable->Unlock(dwPhysicalId);

   HWSTRACE2(dwPhysicalId, HWS_TRACE,
             __TEXT("linkLayerFlushChannel(%d, 0x%X) succeeded"),
             dwPhysicalId, dwDirectionMask);
   return NOERROR;
} // linkLayerFlushChannel()



/***************************************************************************
 *
 * NAME
 *    linkLayerFlushAll - flush transmit and receive channels
 *
 * DESCRIPTION
 *    This is a dummy function required only for compatibility with the SRP API.
 *
 * RETURN VALUE
 *    0           Function succeeded.
 *    n!=0        Link error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/

LINKDLL HRESULT linkLayerFlushAll(DWORD dwPhysicalId)
{

   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   PHWSINST pHws;
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerFlushAll: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   // Flush both receive and transmit
   // Caveat: H.245 expects us to flush receive first!
   SocketFlushRecv(pHws);
   SocketFlushSend(pHws);

   gpInstanceTable->Unlock(dwPhysicalId);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerFlushAll succeeded"));
   return NOERROR;
} // linkLayerFlushAll()



/*++

Description:

   Initiates a call to a remote node.
   1) Create a socket.
   2) Set the socket up for windows message notification of FD_CONNECT events.
   3) Attempt a connection

Arguments:
   pHws  - Pointer to context data from connection.

Return Value:
   SUCCESS  - A connection attempt was successfully initiated.
   LINK_FATAL_ERROR  - Error occurred while attempting to initiate a connection.

--*/

LINKDLL HRESULT linkLayerConnect(DWORD dwPhysicalId, CC_ADDR *pAddr, H245CONNECTCALLBACK callback)
{
   register PHWSINST    pHws;
   CC_ADDR              Addr;
   HRESULT              hr;

   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   HWSTRACE5(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerConnect: connecting to %d.%d.%d.%d/%d"),
             GetIPAddress(pAddr) & 0xFF,
             (GetIPAddress(pAddr) >>  8) & 0xFF,
             (GetIPAddress(pAddr) >> 16) & 0xFF,
             GetIPAddress(pAddr) >> 24,
             ntohs(GetPort(pAddr)));

   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerConnect: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState != HWS_START)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerConnect: State = %s"),
                SocketStateText(pHws->hws_uState));
   	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   pHws->hws_h245ConnectCallback = callback;

   // Create a socket, bind to a local address and initiate a connection.
   if ((hr = SocketOpen(pHws)) != NOERROR)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerConnect: SocketOpen() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(dwPhysicalId);
      return hr;
   }

   Addr.nAddrType = CC_IP_BINARY;
   Addr.bMulticast = FALSE;
   Addr.Addr.IP_Binary.wPort = 0;
   Addr.Addr.IP_Binary.dwAddr = 0;
   if ((hr = SocketBind(pHws, &Addr)) != NOERROR)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
	      __TEXT("linkLayerConnect: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(dwPhysicalId);
      return hr;
   }

   // Reminder: WinSock requires that we pass a struct sockaddr *
   // to connect; however, the service provider is free to
   // interpret the pointer as an arbitrary chunk of data of size
   // uSockAddrLen.
   pHws->hws_SockAddr.sin_port             = GetPort(pAddr);
   pHws->hws_SockAddr.sin_addr.S_un.S_addr = GetIPAddress(pAddr);
   if (connect(pHws->hws_Socket,                                   // s
            (const struct sockaddr *)&pHws->hws_SockAddr,   // name
            sizeof(pHws->hws_SockAddr)) == SOCKET_ERROR)   // namelen
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         break;

      default:
         HWSTRACE1(dwPhysicalId, HWS_WARNING,
                   __TEXT("linkLayerConnect: WSAConnect() returned %s"),
                   SocketErrorText1(err));
         SocketClose(pHws);
         pHws->hws_uState = HWS_START;
         gpInstanceTable->Unlock(dwPhysicalId);
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   } // if
   else
   {
      HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("connect() succeeded"));
      SocketConnect(pHws, 0);
      gpInstanceTable->Unlock(dwPhysicalId);
      return NOERROR;
   } // else

   pHws->hws_uState = HWS_CONNECTING;
   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerConnect: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // linkLayerConnect()



/***************************************************************************
 *
 * NAME
 *    linkLayerListen - start listen on connection
 *
 * DESCRIPTION
 *    This function creates a socket,
 *    binds to a local address, and listens on the created socket.
 *    The address being listened to is returned in the structure
 *    pointed to by pAddr.
 *
 * PARAMETERS
 *    dwPhysicalId      Link layer identifier returned by linkLayerGetInstance().
 *    pAddr             Pointer to address structure (defined in CALLCONT.H.)
 *
 * RETURN VALUE
 *    0                 Function succeeded.
 *    n!=0              Error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/
//MULTITHREAD => dwPhysicalID was INPUT now it's OUTPUT
LINKDLL HRESULT linkLayerListen (DWORD *dwPhysicalId, DWORD_PTR dwH245Instance, CC_ADDR *pAddr, H245CONNECTCALLBACK callback)
{
   HRESULT hr;
   register PHWSINST    pHws;

   if (InitializeStatus == LINK_INVALID_STATE)
      Initialize();
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   if ((*dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(*dwPhysicalId))))
   {
      if ((hr = linkLayerInit(dwPhysicalId, dwH245Instance, NULL, NULL)) != NOERROR)
         return hr;

      pHws = gpInstanceTable->Lock(*dwPhysicalId);
      HWSASSERT(pHws != NULL);
   }
   else
   {
      HWSASSERT(pHws->hws_dwH245Instance == dwH245Instance);
   }

   if (pHws->hws_uState != HWS_START)
   {
      HWSTRACE1(*dwPhysicalId, HWS_ERROR, __TEXT("linkLayerListen: State = %s"),
                SocketStateText(pHws->hws_uState));
      gpInstanceTable->Unlock(*dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   pHws->hws_h245ConnectCallback = callback;

   if ((hr = SocketOpen(pHws, FALSE)) != NOERROR)
   {
      HWSTRACE0(*dwPhysicalId, HWS_WARNING, __TEXT("linkLayerListen: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   if ((hr = SocketBind(pHws, pAddr)) != NOERROR)
   {
      HWSTRACE0(*dwPhysicalId, HWS_WARNING, __TEXT("linkLayerListen: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   // Listen for incoming connection requests on the socket.
   int nBacklog = SOMAXCONN;
   while (listen(pHws->hws_Socket, nBacklog) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(*dwPhysicalId,
                HWS_WARNING,
                __TEXT("linkLayerListen: listen() returned %s"),
                SocketErrorText1(err));
      if (nBacklog == SOMAXCONN)
         nBacklog = 10;
      if (err != WSAENOBUFS || --nBacklog == 0)
      {
         SocketClose(pHws);
         pHws->hws_uState = HWS_START;
         gpInstanceTable->Unlock(*dwPhysicalId);
         return MAKE_WINSOCK_ERROR(err);
      }     
      Sleep(0);
   }

   if ((hr = GetLocalAddr(pHws, pAddr)) != NOERROR)
   {
      // getsockname() failed
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerListen: getsockname() returned %s"),
                SocketErrorText());
      SocketClose(pHws);
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   HWSTRACE5(*dwPhysicalId, HWS_TRACE, __TEXT("linkLayerListen: listening on %d.%d.%d.%d/%d"),
             GetIPAddress(pAddr) & 0xFF,
             (GetIPAddress(pAddr) >>  8) & 0xFF,
             (GetIPAddress(pAddr) >> 16) & 0xFF,
             GetIPAddress(pAddr) >> 24,
             ntohs(GetPort(pAddr)));

   pHws->hws_uState = HWS_LISTENING;
   HWSTRACE0(*dwPhysicalId, HWS_TRACE, __TEXT("linkLayerListen: succeeded"));
   gpInstanceTable->Unlock(*dwPhysicalId);
   return NOERROR;
} // linkLayerListen()


LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback)
{
    PHWSINST pHwsListen;
    PHWSINST pHwsAccept;

    HRESULT rc;
    if (InitializeStatus != NOERROR)
       return InitializeStatus;

	HWSTRACE0(dwPhysicalIdAccept, HWS_TRACE, __TEXT("linkLayerAccept"));
    if ((dwPhysicalIdListen == INVALID_PHYS_ID) ||
       (!(pHwsListen = gpInstanceTable->Lock(dwPhysicalIdListen))))
    {
       HWSTRACE0(dwPhysicalIdListen, HWS_ERROR, __TEXT("linkLayerAccept: dwPhysicalIdListen not found"));
       return LINK_INVALID_INSTANCE;
    }

    pHwsAccept = gpInstanceTable->Lock(dwPhysicalIdAccept);
    if (pHwsAccept == NULL)
    {
       HWSTRACE0(dwPhysicalIdAccept, HWS_ERROR, __TEXT("linkLayerAccept: dwPhysicalIdAccept not found"));
		 gpInstanceTable->Unlock(dwPhysicalIdListen);
       return LINK_INVALID_INSTANCE;
    }

    HWSASSERT(pHwsListen->hws_uState == HWS_LISTENING);
    HWSASSERT(pHwsAccept == pHwsListen || pHwsAccept->hws_uState == HWS_START);

    pHwsAccept->hws_h245ConnectCallback = callback;

    rc = SocketAccept(pHwsListen, pHwsAccept);
	gpInstanceTable->Unlock(dwPhysicalIdListen);
    gpInstanceTable->Unlock(dwPhysicalIdAccept);
    return rc;
}

/***************************************************************************
 *
 * NAME
 *    linkLayerReject   - reject an incomming connection request
 *
 * DESCRIPTION
 *    This function accepts an incomming connection
 *    request then immediatly closes the new socket. 
 *
 * PARAMETERS
 *    dwPhysicalId      Link layer identifier of the listening socket
 *
 * RETURN VALUE
 *    0                 Function succeeded.
 *    n!=0              Error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/
LINKDLL HRESULT
linkLayerReject(DWORD dwPhysicalIdListen)
{
    HRESULT     hr          = NOERROR;
    PHWSINST    pHwsListen  = NULL;
    SOCKET      sockReject  = INVALID_SOCKET;
    SOCKADDR_IN sockAddr;
    INT         sockAddrLen = sizeof(sockAddr);

    // Lock the table to get the socket handle
    pHwsListen = gpInstanceTable->Lock(dwPhysicalIdListen);
    if(NULL != pHwsListen)
    {
        // Accept incoming conenction then immediately close it
        sockReject = accept(pHwsListen->hws_Socket, (SOCKADDR *)&sockAddr, &sockAddrLen);
        if(INVALID_SOCKET != sockReject)
        {
            closesocket(sockReject);
        }
        else
        {
            hr = MAKE_WINSOCK_ERROR(WSAGetLastError());
        }
    }
    else
    {
        hr =  LINK_INVALID_INSTANCE;
    }

    // Unlock the instance table
    gpInstanceTable->Unlock(dwPhysicalIdListen);

    return hr;       
}

// Here is the corresponding redefinition of the __TEXT macro

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) L##x
#endif


#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hangman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/hangman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.4  $
 *	$Date:   Aug 12 1996 09:40:22  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitHangupManager();

HRESULT DeInitHangupManager();

HRESULT AllocAndLockHangup(			PHHANGUP				phHangup,
									CC_HCONFERENCE			hConference,
									DWORD_PTR				dwUserToken,
									PPHANGUP				ppHangup);

HRESULT FreeHangup(					PHANGUP					pHangup);

HRESULT LockHangup(					HHANGUP					hHangup,
									PPHANGUP				ppHangup);

HRESULT ValidateHangup(				HHANGUP					hHangup);

HRESULT UnlockHangup(				PHANGUP					pHangup);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\interop.cpp ===
#include "precomp.h"


#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#include "interop.h"
#include <stdio.h>
#include "cpls.h"

static int g_nRefCount = 0;

LPInteropLogger INTEROP_EXPORT InteropLoad(CPLProtocol Protocol)
{

	LPInteropLogger Logger = (LPInteropLogger) GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, sizeof(InteropLogger));
	if (!(Logger))
		return NULL;
    UINT oldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);

	(Logger)->hInst = LoadLibrary(DLLName);

    SetErrorMode(oldMode);

    if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
    {
	  g_nRefCount++;

      (Logger)->CPLInitialize = (CPLInitialize_t)GetProcAddress((Logger)->hInst, "CPLInitialize");
      (Logger)->CPLUninitialize = (CPLUninitialize_t)GetProcAddress((Logger)->hInst, "CPLUninitialize");
      (Logger)->CPLOpen = (CPLOpen_t)GetProcAddress((Logger)->hInst, "CPLOpen");
      (Logger)->CPLClose = (CPLClose_t)GetProcAddress((Logger)->hInst, "CPLClose");
      (Logger)->CPLOutput = (CPLOutput_t)GetProcAddress((Logger)->hInst, "CPLOutput");
	  Logger->g_ProtocolLogID = Logger->CPLInitialize(Protocol);
	  Logger->g_ComplianceProtocolLogger = Logger->CPLOpen(Logger->g_ProtocolLogID,
													NULL,
													CPLS_CREATE | CPLS_APPEND);
	}
    else
    {
		GlobalFree((Logger));
		(Logger) = NULL;
    }

    return Logger;
}

void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger)
{
	if ((Logger))
	{
		if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
		{
			Logger->CPLClose(Logger->g_ComplianceProtocolLogger);
			Logger->CPLUninitialize(Logger->g_ProtocolLogID);
			if (--g_nRefCount <= 0)
				FreeLibrary((Logger)->hInst);
		}
		GlobalFree((Logger));
		(Logger) = NULL;
	}
}

void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf,
							int length, unsigned long userData)
{
	if (!Logger)
		return;
	Logger->CPLOutput(Logger->g_ComplianceProtocolLogger, buf, length,userData);

}

#endif // #if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hlisten.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/HLISTEN.C_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.15  $
 *	$Date:   08 Jan 1997 14:10:34  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 4514 )

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include "q931.h"
#include "hlisten.h"
#include "utils.h"

static BOOL bListenListCreated = FALSE;

static struct
{
    P_LISTEN_OBJECT     pHead;
	CRITICAL_SECTION	Lock;
} ListenList;

static struct
{
    HQ931LISTEN           hQ931Listen;
	CRITICAL_SECTION	Lock;
} ListenHandleSource;


//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
_ListenObjectListAdd(
    P_LISTEN_OBJECT  pListenObject)
{
    if ((pListenObject == NULL) || (pListenObject->bInList == TRUE))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
	EnterCriticalSection(&ListenList.Lock);

	pListenObject->pNextInList = ListenList.pHead;
	pListenObject->pPrevInList = NULL;
	if (ListenList.pHead != NULL)
    {
		ListenList.pHead->pPrevInList = pListenObject;
    }
	ListenList.pHead = pListenObject;

	pListenObject->bInList = TRUE;
	LeaveCriticalSection(&ListenList.Lock);

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
_ListenObjectListRemove(
    P_LISTEN_OBJECT  pListenObject)
{
    HQ931LISTEN hQ931Listen;

    if ((pListenObject == NULL) || (pListenObject->bInList == FALSE))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
    // caller must have a lock on the listen object;
    // in order to avoid deadlock, we must:
    //   1. unlock the listen object,
    //   2. lock the ListenList,
    //   3. locate the listen object in the ListenList (note that
    //      after step 2, the listen object may be deleted from the
    //      ListenList by another thread),
    //   4. lock the listen object (someone else may have the lock)
    //   5. remove the listen object from the ListenList,
    //   6. unlock the ListenList
    //
    // the caller can now safely unlock and destroy the listen object,
    // since no other thread will be able to find the object (its been
    // removed from the ListenList), and therefore no other thread will
    // be able to lock it.

    // Save the listen handle; its the only way to look up
    // the listen object in the ListenList. Note that we
    // can't use pListenObject to find the listen object, because
    // the pointer will no longer be usable after step 1.
    hQ931Listen = pListenObject->hQ931Listen;

    // step 1
    LeaveCriticalSection(&pListenObject->Lock);

    // step 2
    EnterCriticalSection(&ListenList.Lock);

    // step 3
    pListenObject = ListenList.pHead;
    while ((pListenObject != NULL) && (pListenObject->hQ931Listen != hQ931Listen))
    {
        pListenObject = pListenObject->pNextInList;
    }

    if (pListenObject != NULL)
    {
        // step 4
        EnterCriticalSection(&pListenObject->Lock);

        // step 5
        if (pListenObject->pPrevInList == NULL)
        {
            ListenList.pHead = pListenObject->pNextInList;
        }
        else
        {
            pListenObject->pPrevInList->pNextInList = pListenObject->pNextInList;
        }

        if (pListenObject->pNextInList != NULL)
        {
            pListenObject->pNextInList->pPrevInList = pListenObject->pPrevInList;
        }

        pListenObject->bInList = FALSE;
    }

    // step 6
    LeaveCriticalSection(&ListenList.Lock);

    if (pListenObject == NULL)
    {
        return CS_BAD_PARAM;
    }
    return CS_OK;
}


//====================================================================================
//====================================================================================
CS_STATUS
_ListenHandleNew(
    PHQ931LISTEN phQ931Listen)
{
	EnterCriticalSection(&(ListenHandleSource.Lock));
	*phQ931Listen = ListenHandleSource.hQ931Listen++;
	LeaveCriticalSection(&(ListenHandleSource.Lock));
	return CS_OK;
}



//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
#if 0

BOOL
ListenListAddrSearch(
	WORD wListenPort)          // UDP or TCP port (host byte order)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    BOOL found = FALSE;

    EnterCriticalSection(&ListenList.Lock);

    pListenObject = ListenList.pHead;

    while ((pListenObject != NULL) && (pListenObject->ListenSocketAddr.sin_port != wListenPort))
    {
        pListenObject = pListenObject->pNextInList;
    }
    if (pListenObject != NULL)
    {
        found = TRUE;
    }

    LeaveCriticalSection(&ListenList.Lock);

    return found;
}
#endif

//====================================================================================
//====================================================================================
CS_STATUS
ListenListCreate()
{
    if (bListenListCreated == TRUE)
    {
    	ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    // list creation is not protected against multiple threads because it is only
    // called when a process is started, not when a thread is started.
	ListenList.pHead = NULL;
	InitializeCriticalSection(&(ListenList.Lock));

	ListenHandleSource.hQ931Listen = 1;
	InitializeCriticalSection(&(ListenHandleSource.Lock));

	bListenListCreated = TRUE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenListDestroy()
{
    P_LISTEN_OBJECT  pListenObject;
    HQ931LISTEN hCurrent;

	if (bListenListCreated == FALSE)
    {
    	ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

    for ( ; ; )
    {
        // first, get the top-most listen handle in the list (safely)
        EnterCriticalSection(&(ListenList.Lock));
        pListenObject = ListenList.pHead;
        if (pListenObject == NULL)
        {
            LeaveCriticalSection(&(ListenList.Lock));
            break;
        }
        EnterCriticalSection(&pListenObject->Lock);
        hCurrent = pListenObject->hQ931Listen;
        LeaveCriticalSection(&(pListenObject->Lock));
        LeaveCriticalSection(&(ListenList.Lock));

        // try to cancel the listen object.
        Q931CancelListen(hCurrent);

        // destroy the listen object. (if the object is still around for some reason)
        if (ListenObjectLock(hCurrent, &pListenObject) == CS_OK)
        {
            ListenObjectDestroy(pListenObject);
        }
    }

	DeleteCriticalSection(&(ListenList.Lock));
	DeleteCriticalSection(&(ListenHandleSource.Lock));

	bListenListCreated = FALSE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectCreate(
    PHQ931LISTEN        phQ931Listen,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ListenCallback)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS status = CS_OK;

    // make sure the listen list has been created.	
    if (bListenListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

	// validate all parameters for bogus values.
    if ((phQ931Listen == NULL) || (ListenCallback == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    // set phQ931Listen now, in case we encounter an error later.
    *phQ931Listen = 0;

    pListenObject = (P_LISTEN_OBJECT)MemAlloc(sizeof(LISTEN_OBJECT));
    if (pListenObject == NULL)
    {
        return CS_NO_MEMORY;
    }

    pListenObject->bInList = FALSE;

    if (_ListenHandleNew(&(pListenObject->hQ931Listen)) != CS_OK)
    {
        MemFree(pListenObject);
        return CS_INTERNAL_ERROR;
    }

    pListenObject->dwUserToken = dwUserToken;
    pListenObject->ListenCallback = ListenCallback;

	Q931MakePhysicalID(&pListenObject->dwPhysicalId);
    InitializeCriticalSection(&pListenObject->Lock);
    *phQ931Listen = pListenObject->hQ931Listen;

    // add the listen object to the listen list.
    status = _ListenObjectListAdd(pListenObject);
    if (status != CS_OK)
    {
        ListenObjectDestroy(pListenObject);
    }
    return status;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectDestroy(
    P_LISTEN_OBJECT  pListenObject)
{
    if (pListenObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
	// caller must have a lock on the listen object,
	// so there's no need to re-lock it
	
	if (pListenObject->bInList == TRUE)
    {
		if (_ListenObjectListRemove(pListenObject) == CS_BAD_PARAM)
        {
			// the listen object was deleted by another thread,
			// so just return CS_OK
			return CS_OK;
        }
    }

	// since the listen object has been removed from the ListenList,
	// no other thread will be able to find the listen object and obtain
	// a lock, so its safe to unlock the listen object and delete it here.
	LeaveCriticalSection(&(pListenObject->Lock));
	DeleteCriticalSection(&(pListenObject->Lock));
	MemFree(pListenObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectLock(
    HQ931LISTEN         hQ931Listen,
    PP_LISTEN_OBJECT    ppListenObject)
{
	if ((hQ931Listen == 0) || (ppListenObject == NULL))
    {
    	ASSERT(FALSE);
		return CS_BAD_PARAM;
    }

	EnterCriticalSection(&(ListenList.Lock));

	*ppListenObject = ListenList.pHead;
	while ((*ppListenObject != NULL) && ((*ppListenObject)->hQ931Listen != hQ931Listen))
    {
		*ppListenObject = (*ppListenObject)->pNextInList;
    }

	if (*ppListenObject != NULL)
    {
		EnterCriticalSection(&((*ppListenObject)->Lock));
    }

	LeaveCriticalSection(&(ListenList.Lock));

    if (*ppListenObject == NULL)
    {
        // the handle was not found in the list, so this is treated as a bad parm.
        return CS_BAD_PARAM;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectUnlock(
    P_LISTEN_OBJECT  pListenObject)
{
    if (pListenObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    LeaveCriticalSection(&pListenObject->Lock);
    return CS_OK;
}

#ifdef __cplusplus
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\interop.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __INTEROP_H
#define __INTEROP_H

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif

#else   // ! (defined(_DEBUG) || defined(PCS_COMPLIANCE))
#define InteropLoad()
#define InteropUnload()
#define InteropOutput()

#endif  // (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hcall.cpp ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hcall.cpv  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   2.7  $
 *	$Date:   28 Jan 1997 11:17:52  $
 *	$Author:   jdashevx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4100 4115 4201 4214 4514 4702 4710 )

#include "precomp.h"

#include <string.h>
#include <time.h>

#include "h225asn.h"

#include "isrg.h"

#include "common.h"
#include "q931.h"

#include "hcall.h"
#include "utils.h"

#include "tstable.h"

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif

// variable needed to support ISR debug facility.
#if defined(_DEBUG)
extern WORD ghISRInst;
#endif

static BOOL bCallListCreated = FALSE;

// Pointer to our global table.  Note that this table replaces the previous
// linked-list implementation.

TSTable<CALL_OBJECT>* gpCallObjectTable = NULL;

// Our call back function for enumerating the table when we want to tear down
// all existing calls

DWORD Q931HangUpAllCalls(P_CALL_OBJECT pCallObject, LPVOID context);

// Our call back function for determining if a timer has expired

DWORD Q931CheckForTimeout(P_CALL_OBJECT pCallObject, LPVOID context);

// Our call back function for determining if a timer has expired

DWORD Q931CallObjectFind(P_CALL_OBJECT pCallObject, LPVOID context);


static struct
{
    WORD                wCRV;              // Call Reference Value (0..7FFF).
    CRITICAL_SECTION    Lock;
} CRVSource;

static struct
{
    BOOL bBusy;
    DWORD dwTimerCount;
    DWORD dwTicks301;
    DWORD dwTicks303;
    UINT_PTR uTimerId;
    CRITICAL_SECTION Lock;
} Q931GlobalTimer = {0};



typedef struct
{
		BOOL bFound;
		WORD wCRV;
		PCC_ADDR pPeerAddr;
		HQ931CALL hQ931Call;
} Q931CALLOBJKEY, *PQ931CALLOBJKEY;


//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
Q931CRVNew(
    WORD *pwCRV)
{
    EnterCriticalSection(&(CRVSource.Lock));
    CRVSource.wCRV = (WORD)((CRVSource.wCRV + 1) & 0x7fff);
    if (CRVSource.wCRV == 0)
    {
        CRVSource.wCRV = 1;
    }
    *pwCRV = CRVSource.wCRV;
    LeaveCriticalSection(&(CRVSource.Lock));
    return CS_OK;
}

//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
CallListCreate()
{
    if (bCallListCreated == TRUE)
    {
        ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    // list creation is not protected against multiple threads because it is only
    // called when a process is started, not when a thread is started.

    //
    // LAURABU
    // BOGUS BUGBUG
    // 
    // This table code was never stressed by the people who wrote it.  It
    // totally falls apart when it completely fills up
    //      * Allocating the last item doesn't work
    //      * Freeing the last item doesn't work
    //      * Resizing larger doesn't work
    //
    // Since it doesn't take a lot of memory, a decent solution is to just
    // allocate it maximum+1 sized, and leave the last item free.
    //
		gpCallObjectTable = new TSTable <CALL_OBJECT> (257);

		if (gpCallObjectTable == NULL || gpCallObjectTable->IsInitialized() == FALSE)
		{
			return CS_NO_MEMORY;
		}

    CRVSource.wCRV = (WORD) (time(NULL) & 0x7fff);
    InitializeCriticalSection(&(CRVSource.Lock));

    Q931GlobalTimer.dwTicks301 = Q931_TICKS_301;
    Q931GlobalTimer.dwTicks303 = Q931_TICKS_303;
    InitializeCriticalSection(&(Q931GlobalTimer.Lock));

    bCallListCreated = TRUE;

    return CS_OK;
}


//====================================================================================
// this routine assumes all of the events and sockets belonging to each object
// are already destroyed.  It just makes sure memory is cleaned up.
//====================================================================================
CS_STATUS
CallListDestroy()
{
    if (bCallListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

		// For all entries, hang up the calls

		gpCallObjectTable->EnumerateEntries(Q931HangUpAllCalls,
																				NULL);

		// Get rid of the call object table

		delete gpCallObjectTable;
		gpCallObjectTable = NULL;

    DeleteCriticalSection(&(Q931GlobalTimer.Lock));
    DeleteCriticalSection(&(CRVSource.Lock));

    bCallListCreated = FALSE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
void
CallObjectFree(P_CALL_OBJECT pCallObject)
{
    if (pCallObject->NonStandardData.sData.pOctetString != NULL)
    {
        MemFree(pCallObject->NonStandardData.sData.pOctetString);
        pCallObject->NonStandardData.sData.pOctetString = NULL;
    }
    if (pCallObject->VendorInfoPresent)
    {
        if (pCallObject->VendorInfo.pProductNumber != NULL)
        {
            MemFree(pCallObject->VendorInfo.pProductNumber);
        }
        if (pCallObject->VendorInfo.pVersionNumber != NULL)
        {
            MemFree(pCallObject->VendorInfo.pVersionNumber);
        }
    }

    Q931FreeAliasNames(pCallObject->pCallerAliasList);
    pCallObject->pCallerAliasList = NULL;
    Q931FreeAliasNames(pCallObject->pCalleeAliasList);
    pCallObject->pCalleeAliasList = NULL;
    Q931FreeAliasNames(pCallObject->pExtraAliasList);
    pCallObject->pExtraAliasList = NULL;
    Q931FreeAliasItem(pCallObject->pExtensionAliasItem);
    pCallObject->pExtensionAliasItem = NULL;
    MemFree(pCallObject);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectCreate(
    PHQ931CALL          phQ931Call,
    DWORD_PTR           dwListenToken,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ConnectCallback,
    BOOL                fIsCaller,
    CC_ADDR             *pLocalAddr,         // Local address on which channel is connected
    CC_ADDR             *pPeerConnectAddr,   // Address to which channel is connected
    CC_ADDR             *pPeerCallAddr,      // Address of opposite call end-point.
    CC_ADDR             *pSourceAddr,        // Address of this call end-point.
    CC_CONFERENCEID     *pConferenceID,
    WORD                wGoal,
    WORD                wCallType,
    BOOL                bCallerIsMC,
    char                *pszDisplay,
    char                *pszCalledPartyNumber,
    PCC_ALIASNAMES      pCallerAliasList,
    PCC_ALIASNAMES      pCalleeAliasList,
    PCC_ALIASNAMES      pExtraAliasList,
    PCC_ALIASITEM       pExtensionAliasItem,
    PCC_ENDPOINTTYPE    pEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData,    // questionable!
    WORD                wCRV,
    LPGUID				pCallIdentifier)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS status = CS_OK;
    CS_STATUS CopyStatus = CS_OK;
    DWORD dwIndex = 0;
    int rc = 0;

    // make sure the call list has been created.
    if (bCallListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

    // validate all parameters for bogus values.
    if ((phQ931Call == NULL) || (ConnectCallback == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    // set phQ931Call now, in case we encounter an error later.
    *phQ931Call = 0;

    pCallObject = (P_CALL_OBJECT)MemAlloc(sizeof(CALL_OBJECT));
    if (pCallObject == NULL)
    {
        return CS_NO_MEMORY;
    }
    memset(pCallObject, 0, sizeof(CALL_OBJECT));


    // create and init an oss world struct for each call object.  This is
		// necessary to work in MT environments.
    rc = Q931_InitWorld(&pCallObject->World);
    if (rc != ASN1_SUCCESS)
    {
#if defined(_DEBUG)
        ISRERROR(ghISRInst, "Q931_InitCoder() returned: %d ", rc);
#endif
        return CS_SUBSYSTEM_FAILURE;
    }

    pCallObject->LocalAddr.bMulticast = FALSE;
    pCallObject->PeerConnectAddr.bMulticast = FALSE;
    pCallObject->PeerCallAddr.bMulticast = FALSE;
    pCallObject->SourceAddr.bMulticast = FALSE;

	if(pCallIdentifier)
	{
		memcpy(&pCallObject->CallIdentifier, pCallIdentifier, sizeof(GUID));
	}
    if (wCRV == 0)
    {
        if (Q931CRVNew(&pCallObject->wCRV) != CS_OK)
        {
            CallObjectFree(pCallObject);
            return CS_INTERNAL_ERROR;
        }
    }
    else
    {
        pCallObject->wCRV = wCRV;
    }

    pCallObject->szDisplay[0] = '\0';
    if (pszDisplay)
    {
        strcpy(pCallObject->szDisplay, pszDisplay);
    }

    pCallObject->szCalledPartyNumber[0] = '\0';
    if (pszCalledPartyNumber)
    {
        strcpy(pCallObject->szCalledPartyNumber, pszCalledPartyNumber);
    }

    pCallObject->dwListenToken = dwListenToken;
    pCallObject->dwUserToken = dwUserToken;
    pCallObject->Callback = ConnectCallback;
    pCallObject->bCallState = CALLSTATE_NULL;
    pCallObject->fIsCaller = fIsCaller;

    if (pLocalAddr)
    {
        pCallObject->LocalAddr = *pLocalAddr;
    }
    if (pPeerConnectAddr)
    {
        pCallObject->PeerConnectAddr = *pPeerConnectAddr;
    }
    if (pPeerCallAddr)
    {
        pCallObject->PeerCallAddr = *pPeerCallAddr;
        pCallObject->PeerCallAddrPresent = TRUE;
    }
    else
    {
        pCallObject->PeerCallAddrPresent = FALSE;
    }

    if (pSourceAddr)
    {
        pCallObject->SourceAddr = *pSourceAddr;
        pCallObject->SourceAddrPresent = TRUE;
    }
    else
    {
        pCallObject->SourceAddrPresent = FALSE;
    }

    if (pConferenceID == NULL)
    {
        memset(&(pCallObject->ConferenceID), 0, sizeof(CC_CONFERENCEID));
    }
    else
    {
        int length = min(sizeof(pConferenceID->buffer),
            sizeof(pCallObject->ConferenceID.buffer));
        memcpy(pCallObject->ConferenceID.buffer,
            pConferenceID->buffer, length);
    }

    pCallObject->wGoal = wGoal;
    pCallObject->bCallerIsMC = bCallerIsMC;
    pCallObject->wCallType = wCallType;

    if (pNonStandardData != NULL)
    {
        pCallObject->NonStandardData = *pNonStandardData;
        if (pNonStandardData->sData.wOctetStringLength > 0)
        {
            pCallObject->NonStandardData.sData.pOctetString =
                (BYTE *) MemAlloc(pNonStandardData->sData.wOctetStringLength);
            if (pCallObject->NonStandardData.sData.pOctetString == NULL)
            {
                CallObjectFree(pCallObject);
                return CS_NO_MEMORY;
            }
            memcpy(pCallObject->NonStandardData.sData.pOctetString,
                pNonStandardData->sData.pOctetString,
                pNonStandardData->sData.wOctetStringLength);
        }
        pCallObject->NonStandardDataPresent = TRUE;
    }
    else
    {
        pCallObject->NonStandardDataPresent = FALSE;
    }

    CopyStatus = Q931CopyAliasNames(&(pCallObject->pCallerAliasList),
        pCallerAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasNames(&(pCallObject->pCalleeAliasList),
        pCalleeAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasNames(&(pCallObject->pExtraAliasList),
        pExtraAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasItem(&(pCallObject->pExtensionAliasItem),
        pExtensionAliasItem);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }

    pCallObject->bResolved = FALSE;
    pCallObject->VendorInfoPresent = FALSE;
    pCallObject->bIsTerminal = TRUE;
    pCallObject->bIsGateway = FALSE;
    if (pEndpointType != NULL)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo != NULL)
        {
            pCallObject->VendorInfoPresent = TRUE;
            pCallObject->VendorInfo = *(pVendorInfo);

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                memcpy(pCallObject->bufVendorProduct,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
                pCallObject->VendorInfo.pProductNumber = (CC_OCTETSTRING*) MemAlloc(sizeof(CC_OCTETSTRING));
                if (pCallObject->VendorInfo.pProductNumber == NULL)
                {
                    CallObjectFree(pCallObject);
                    return CS_NO_MEMORY;
                }
                pCallObject->VendorInfo.pProductNumber->pOctetString =
                    pCallObject->bufVendorProduct;
                pCallObject->VendorInfo.pProductNumber->wOctetStringLength =
                    pVendorInfo->pProductNumber->wOctetStringLength;
            }
            else
            {
                pCallObject->VendorInfo.pProductNumber = NULL;
            }

            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                memcpy(pCallObject->bufVendorVersion,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
                pCallObject->VendorInfo.pVersionNumber = (CC_OCTETSTRING*) MemAlloc(sizeof(CC_OCTETSTRING));
                if (pCallObject->VendorInfo.pVersionNumber == NULL)
                {
                    CallObjectFree(pCallObject);
                    return CS_NO_MEMORY;
                }
                pCallObject->VendorInfo.pVersionNumber->pOctetString =
                    pCallObject->bufVendorVersion;
                pCallObject->VendorInfo.pVersionNumber->wOctetStringLength =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
            }
            else
            {
                pCallObject->VendorInfo.pVersionNumber = NULL;
            }

        }
        pCallObject->bIsTerminal = pEndpointType->bIsTerminal;
        pCallObject->bIsGateway = pEndpointType->bIsGateway;
    }

	Q931MakePhysicalID(&pCallObject->dwPhysicalId);
				
		// Insert the object into the table...if that doesn't work, blow away the object.

		if (gpCallObjectTable->CreateAndLock(pCallObject,
																				 &dwIndex) == FALSE)
		{
			CallObjectFree(pCallObject);
			return CS_INTERNAL_ERROR;
		}

		// Save the index as the handle (this makes it easier to find the object later).

    *phQ931Call = pCallObject->hQ931Call = (HQ931CALL) dwIndex;
             #if defined(_DEBUG)
		ISRTRACE(ghISRInst, "CallObjectCreate() -returned-> 0x%.8x", dwIndex);
             #endif
		// Unlock the entry

		gpCallObjectTable->Unlock(dwIndex);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectDestroy(
    P_CALL_OBJECT  pCallObject)
{
    if (pCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

             #if defined (_DEBUG)
		ISRTRACE(ghISRInst, "CallObjectDestroy(0x%.8x)", (DWORD)pCallObject->hQ931Call);
             #endif

		
		Q931_TermWorld(&pCallObject->World);

		// Since the caller must already have a lock on the object, remove the entry from
		// the table.  We won't let the table delete the object as we want to clean up.

		if (gpCallObjectTable->Delete((DWORD) pCallObject->hQ931Call) == FALSE)
		{
			return CS_OK;
		}

    Q931StopTimer(pCallObject, Q931_TIMER_301);
    Q931StopTimer(pCallObject, Q931_TIMER_303);

		// Unlock the object

		gpCallObjectTable->Unlock((DWORD) pCallObject->hQ931Call);

		// Free up the call object

    CallObjectFree(pCallObject);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectLock(
    HQ931CALL         hQ931Call,
    PP_CALL_OBJECT    ppCallObject)
{
    if (ppCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

	// Attempt to lock the entry.  If that fails, we'll return CS_BAD_PARAM under
	// the assumption that the entry is invalid.

	*ppCallObject = gpCallObjectTable->Lock((DWORD) hQ931Call);

	return (*ppCallObject == NULL ? CS_BAD_PARAM : CS_OK);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectUnlock(
    P_CALL_OBJECT  pCallObject)
{
    if (pCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

		// Unlock the entry

		if (gpCallObjectTable->Unlock((DWORD) pCallObject->hQ931Call) == FALSE)
		{
                   #if defined(_DEBUG)
			ISRERROR(ghISRInst, "gpCallObjectTable->Unlock(0x%.8x) FAILED!!!!", (DWORD)pCallObject->hQ931Call);
                   #endif
			return CS_BAD_PARAM;
		}

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectValidate(
    HQ931CALL hQ931Call)
{
	if (gpCallObjectTable->Validate((DWORD) hQ931Call) == TRUE)
	{
		return CS_OK;
	}

	return CS_BAD_PARAM;
}

//====================================================================================
//====================================================================================
BOOL
CallObjectFind(
    HQ931CALL *phQ931Call,
    WORD wCRV,
    PCC_ADDR pPeerAddr)
{
		Q931CALLOBJKEY Q931CallObjKey;
		Q931CallObjKey.wCRV = wCRV;
		Q931CallObjKey.pPeerAddr = pPeerAddr;
		Q931CallObjKey.bFound = FALSE;
		
		gpCallObjectTable->EnumerateEntries(Q931CallObjectFind,
																				(LPVOID) &Q931CallObjKey);
	
		if(Q931CallObjKey.bFound == TRUE)
		{
        *phQ931Call = Q931CallObjKey.hQ931Call;
        return TRUE;
    }
    return FALSE;
}

//====================================================================================
//====================================================================================
CS_STATUS CallObjectMarkForDelete(HQ931CALL hQ931Call)
{
	// User must have the object already locked to call this.

	// Mark the object as deleted but don't let the table delete the object's
	// memory.

	return (gpCallObjectTable->Delete((DWORD) hQ931Call) == FALSE ? CS_BAD_PARAM : CS_OK);
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//====================================================================================
// This routine will be called every 1000 ms if any call object
// has caused the Q931GlobalTimer to be created.
//====================================================================================
VOID CALLBACK
Q931TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    DWORD dwTickCount = GetTickCount();

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (Q931GlobalTimer.bBusy)
    {
        LeaveCriticalSection(&(Q931GlobalTimer.Lock));
        return;
    }
    Q931GlobalTimer.bBusy = TRUE;

		// Check all of the entries for timeout

		gpCallObjectTable->EnumerateEntries(Q931CheckForTimeout,
																				(LPVOID) &dwTickCount);

    Q931GlobalTimer.bBusy = FALSE;
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));
}

//====================================================================================
//====================================================================================
HRESULT
Q931StartTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId)
{
    if (pCallObject == NULL)
    {
        return CS_BAD_PARAM;
    }

    switch (wTimerId)
    {
        case Q931_TIMER_301:
            if (pCallObject->dwTimerAlarm301)
            {
                // timer is already set for this call object...
                return CS_INTERNAL_ERROR;
            }
            EnterCriticalSection(&(Q931GlobalTimer.Lock));
            pCallObject->dwTimerAlarm301 = GetTickCount() + Q931GlobalTimer.dwTicks301;
            LeaveCriticalSection(&(Q931GlobalTimer.Lock));
            break;
        case Q931_TIMER_303:
            if (pCallObject->dwTimerAlarm303)
            {
                // timer is already set for this call object...
                return CS_INTERNAL_ERROR;
            }
            EnterCriticalSection(&(Q931GlobalTimer.Lock));
            pCallObject->dwTimerAlarm303 = GetTickCount() + Q931GlobalTimer.dwTicks303;
            LeaveCriticalSection(&(Q931GlobalTimer.Lock));
            break;
        default:
            return CS_BAD_PARAM;
            break;
    }

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (!Q931GlobalTimer.dwTimerCount)
    {
        Q931GlobalTimer.uTimerId = SetTimer(NULL, 0, 1000, (TIMERPROC)Q931TimerProc);
    }
    Q931GlobalTimer.dwTimerCount++;
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));

    return CS_OK;
}

//====================================================================================
//====================================================================================
HRESULT
Q931StopTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId)
{
    if (pCallObject == NULL)
    {
        return CS_BAD_PARAM;
    }
    switch (wTimerId)
    {
        case Q931_TIMER_301:
            if (!pCallObject->dwTimerAlarm301)
            {
                return CS_OK;
            }
            pCallObject->dwTimerAlarm301 = 0;
            break;
        case Q931_TIMER_303:
            if (!pCallObject->dwTimerAlarm303)
            {
                return CS_OK;
            }
            pCallObject->dwTimerAlarm303 = 0;
            break;
        default:
            return CS_BAD_PARAM;
            break;
    }

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (Q931GlobalTimer.dwTimerCount > 0)
    {
        Q931GlobalTimer.dwTimerCount--;
        if (!Q931GlobalTimer.dwTimerCount)
        {
            KillTimer(NULL, Q931GlobalTimer.uTimerId);
            Q931GlobalTimer.uTimerId = 0;
        }
    }
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SetAlertingTimeout(DWORD dwDuration)
{
    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (dwDuration)
    {
        Q931GlobalTimer.dwTicks303 = dwDuration;
    }
    else
    {
        Q931GlobalTimer.dwTicks303 = Q931_TICKS_303;
    }
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));
    return CS_OK;
}

//====================================================================================
//====================================================================================
DWORD Q931HangUpAllCalls(P_CALL_OBJECT pCallObject, LPVOID context)
{
	HQ931CALL hQ931Call = pCallObject->hQ931Call;

	// Try to hangup the call object.

	Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);

	// Try to lock the object.  If that succeeds, then we want to force the object to
	// be deleted.  We should never have to do this as the hang up is supposed to
	// take care of that for us.

	if (gpCallObjectTable->Lock(hQ931Call) != NULL)
	{
		CallObjectDestroy(pCallObject);
	}

	return CALLBACK_DELETE_ENTRY;
}

//====================================================================================
//====================================================================================
DWORD
Q931CallObjectFind(P_CALL_OBJECT pCallObject, LPVOID context)
{
	PQ931CALLOBJKEY pQ931CallObjKey = (PQ931CALLOBJKEY) context;
	PCC_ADDR pPeerAddr = pQ931CallObjKey->pPeerAddr;
	WORD wCRV = pQ931CallObjKey->wCRV;

	if (!pCallObject->bResolved)
	{
		return(CALLBACK_CONTINUE);
	}
	
	if ((pCallObject->wCRV & (~0x8000)) == (wCRV & (~0x8000)))
	{
		if (!pPeerAddr)
		{
			pQ931CallObjKey->bFound = TRUE;
			pQ931CallObjKey->hQ931Call = pCallObject->hQ931Call;
			return(CALLBACK_ABORT);
		}
		else if ((pCallObject->PeerConnectAddr.nAddrType == CC_IP_BINARY) &&
				(pPeerAddr->nAddrType == CC_IP_BINARY) &&
				(pCallObject->PeerConnectAddr.Addr.IP_Binary.dwAddr == pPeerAddr->Addr.IP_Binary.dwAddr))
		{
			pQ931CallObjKey->bFound = TRUE;
			pQ931CallObjKey->hQ931Call = pCallObject->hQ931Call;
			return(CALLBACK_ABORT);
		}
	}
	return(CALLBACK_CONTINUE);
}


//====================================================================================
//====================================================================================

DWORD Q931CheckForTimeout(P_CALL_OBJECT pCallObject, LPVOID context)
{
	DWORD dwTickCount = *((LPDWORD) context);

	// Determine if a timer has expired for the entry

	if (pCallObject->dwTimerAlarm301 &&
			(pCallObject->dwTimerAlarm301 <= dwTickCount))
	{
		Q931StopTimer(pCallObject, Q931_TIMER_301);
		Q931StopTimer(pCallObject, Q931_TIMER_303);

		if (pCallObject->dwTimerAlarm303 &&
				(pCallObject->dwTimerAlarm303 < pCallObject->dwTimerAlarm301) &&
				(pCallObject->dwTimerAlarm303 <= dwTickCount))
		{
			CallBackT303(pCallObject);
		}
		else
		{
			CallBackT301(pCallObject);
		}
	}
	else if (pCallObject->dwTimerAlarm303 &&
					 (pCallObject->dwTimerAlarm303 <= dwTickCount))
	{
		Q931StopTimer(pCallObject, Q931_TIMER_301);
		Q931StopTimer(pCallObject, Q931_TIMER_303);
		CallBackT303(pCallObject);
	}

	return CALLBACK_CONTINUE;
}

/***************************************************************************
 *
 * NAME
 *    HangupPendingCalls - Hangs up incoming calls from specified destination
 *                        
 * DESCRIPTION
 *    This function will hang up all calls in waiting 
 *    from the specified destination to prevent DOS attacks
 *    that would fill up the call object table.
 *
 * PARAMETERS
 *    pCallObject       Current enumerated call object
 *    context           Callback parameter representing source IP address
 *
 * RETURN VALUE
 *    CALLBACK_ABORT    Stop enumerating calls
 *    CALLBACK_CONTINUE Continue enumerating calls
 *
 ***************************************************************************/
DWORD Q931HangupPendingCallsCallback(P_CALL_OBJECT pCallObject, LPVOID context)
{
    ASSERT(NULL != pCallObject);

    // Only hang up incoming calls
    if(FALSE == pCallObject->fIsCaller)
    {
        if(CALLSTATE_INITIATED == pCallObject->bCallState)
        {
            Q931Hangup(pCallObject->hQ931Call, CC_REJECT_SECURITY_DENIED);
        }
    }

    return CALLBACK_CONTINUE;
}

HRESULT Q931HangupPendingCalls(LPVOID context)
{
    gpCallObjectTable->EnumerateEntries(Q931HangupPendingCallsCallback, context);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hlisten.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hlisten.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.8  $
 *	$Date:   22 Jul 1996 19:00:20  $
 *	$Author:   rodellx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Listen Object Methods
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef HLISTEN_H
#define HLISTEN_H

#ifdef __cplusplus
extern "C" {
#endif

#define LISTEN_SHUTDOWN_EVENT 0
#define LISTEN_ACCEPT_EVENT 1

typedef struct LISTEN_OBJECT_tag
{
    HQ931LISTEN         hQ931Listen;
    DWORD_PTR           dwUserToken;
    Q931_CALLBACK       ListenCallback;
    DWORD               dwPhysicalId;

    BOOL                bInList;
    struct LISTEN_OBJECT_tag *pNextInList;
    struct LISTEN_OBJECT_tag *pPrevInList;
    CRITICAL_SECTION    Lock;
} LISTEN_OBJECT, *P_LISTEN_OBJECT, **PP_LISTEN_OBJECT;

BOOL ListenListAddrSearch(
    WORD             wListenPort);

CS_STATUS ListenListCreate();

CS_STATUS ListenListDestroy();

CS_STATUS ListenObjectCreate(
    PHQ931LISTEN        phQ931Listen,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ListenCallback);

CS_STATUS ListenObjectDestroy(
    P_LISTEN_OBJECT     pListenObject);

CS_STATUS ListenObjectLock(
    HQ931LISTEN         hQ931Listen,
    PP_LISTEN_OBJECT    ppListenObject);

CS_STATUS ListenObjectUnlock(
    P_LISTEN_OBJECT     pListenObject);

#ifdef __cplusplus
}
#endif

#endif HLISTEN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hcall.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hcall.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.27  $
 *	$Date:   08 Jan 1997 18:04:32  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Call Object Methods
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef HCALL_H
#define HCALL_H

#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

// Call Object states                     // OUT          // IN
#define CALLSTATE_NULL              0x00  // relcomp*     // relcomp*
#define CALLSTATE_INITIATED         0x01  // setup*       //
#define CALLSTATE_OUTGOING          0x03  //              // proceeding*
#define CALLSTATE_DELIVERED         0x04  //              // alerting*
#define CALLSTATE_PRESENT           0x06  //              // setup*
#define CALLSTATE_RECEIVED          0x07  // alerting*    //
#define CALLSTATE_CONNECT_REQUEST   0x08  //              //
#define CALLSTATE_INCOMING          0x09  // proceeding-  //
#define CALLSTATE_ACTIVE            0x0A  // connect*     // connect*

// Call Timer limits
#define Q931_TIMER_301             301
#define Q931_TICKS_301             180000L        // 3 minutes
#define Q931_TIMER_303             303
#define Q931_TICKS_303             4000L          // 4 seconds

typedef struct CALL_OBJECT_tag
{
    HQ931CALL           hQ931Call;
    WORD                wCRV;              // Call Reference Value (0..7FFF).
    DWORD_PTR           dwListenToken;
    DWORD_PTR           dwUserToken;
    Q931_CALLBACK       Callback;
    BYTE                bCallState;
    BOOL                fIsCaller;
    DWORD               dwPhysicalId;
    BOOL                bResolved;         // re-connect phase is over.
    BOOL                bConnected;        // has a live channel.

    CC_ADDR             LocalAddr;         // Local address on which channel is connected
    CC_ADDR             PeerConnectAddr;   // Address to which channel is connected

    CC_ADDR             PeerCallAddr;      // Address of opposite call end-point.
    BOOL                PeerCallAddrPresent;  // Address is present.

    CC_ADDR             SourceAddr;        // Address of this end-point.
    BOOL                SourceAddrPresent; // Address is present.

    CC_CONFERENCEID     ConferenceID;
    WORD                wGoal;
    BOOL                bCallerIsMC;
    WORD                wCallType;

    BOOL                NonStandardDataPresent;
    CC_NONSTANDARDDATA  NonStandardData;

    char                szDisplay[CC_MAX_DISPLAY_LENGTH];
                                           // length = 0 means not present.
    char                szCalledPartyNumber[CC_MAX_PARTY_NUMBER_LEN];
                                           // length = 0 means not present.

    PCC_ALIASNAMES      pCallerAliasList;
    PCC_ALIASNAMES      pCalleeAliasList;
    PCC_ALIASNAMES      pExtraAliasList;

    PCC_ALIASITEM       pExtensionAliasItem;

    // these are part of EndpointType...
    BOOL                VendorInfoPresent;
    CC_VENDORINFO       VendorInfo;
    BYTE                bufVendorProduct[CC_MAX_PRODUCT_LENGTH];
    BYTE                bufVendorVersion[CC_MAX_VERSION_LENGTH];
    BOOL                bIsTerminal;
    BOOL                bIsGateway;

    ASN1_CODER_INFO     World;

    DWORD               dwTimerAlarm301;
    DWORD               dwTimerAlarm303;
    GUID                CallIdentifier;
} CALL_OBJECT, *P_CALL_OBJECT, **PP_CALL_OBJECT;

CS_STATUS CallListCreate();

CS_STATUS CallListDestroy();

CS_STATUS CallObjectCreate(
    PHQ931CALL          phQ931Call,
    DWORD_PTR           dwListenToken,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ConnectCallback,
    BOOL                fIsCaller,
    CC_ADDR             *pLocalAddr,         // Local address on which channel is connected
    CC_ADDR             *pPeerConnectAddr,   // Address to which channel is connected
    CC_ADDR             *pPeerCallAddr,      // Address of opposite call end-point.
    CC_ADDR             *pSourceAddr,        // Address of this call end-point.
    CC_CONFERENCEID     *pConferenceID,
    WORD                wGoal,
    WORD                wCallType,
    BOOL                bCallerIsMC,
    char *              pszDisplay,
    char *              pszCalledPartyNumber,
    PCC_ALIASNAMES      pCallerAliasList,
    PCC_ALIASNAMES      pCalleeAliasList,
    PCC_ALIASNAMES      pExtraAliasList,
    PCC_ALIASITEM       pExtensionAliasItem,
    PCC_ENDPOINTTYPE    pEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData,
    WORD                wCRV,
    LPGUID              pCallIdentifier);

CS_STATUS CallObjectDestroy(
    P_CALL_OBJECT  pCallObject);

CS_STATUS CallObjectLock(
    HQ931CALL         hQ931Call,
    PP_CALL_OBJECT    ppCallObject);

CS_STATUS CallObjectUnlock(
    P_CALL_OBJECT     pCallObject);

CS_STATUS CallObjectValidate(
    HQ931CALL hQ931Call);

BOOL CallObjectFind(
    HQ931CALL *phQ931Call,
    WORD wCRV,
    PCC_ADDR pPeerAddr);

CS_STATUS CallObjectMarkForDelete(
    HQ931CALL hQ931Call);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CallBackT301(P_CALL_OBJECT pCallObject);
void CallBackT303(P_CALL_OBJECT pCallObject);
void CALLBACK Q931TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
HRESULT Q931StartTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId);
HRESULT Q931StopTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId);
HRESULT Q931HangupPendingCalls(LPVOID context);

#ifdef __cplusplus
}
#endif

#endif HCALL_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\hwsdebug.c ===
/***************************************************************************
 *
 * File: hwsdebug.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   hwsdebug.c  $
 * $Revision:   1.13  $
 * $Modtime:   13 Dec 1996 11:44:24  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\hwsdebug.c_v  $
 * 
 *    Rev 1.13   13 Dec 1996 12:12:50   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.12   11 Dec 1996 13:41:56   SBELL1
 * Put in UNICODE tracing stuff.
 * 
 *    Rev 1.11   01 Oct 1996 14:49:22   EHOWARDX
 * Revision 1.9 copied to tip.
 * 
 *    Rev 1.9   May 28 1996 10:40:14   plantz
 * Change vsprintf to wvsprintf.
 * 
 *    Rev 1.8   29 Apr 1996 17:13:16   unknown
 * Fine-tuning instance-specific name.
 * 
 *    Rev 1.7   29 Apr 1996 13:04:56   EHOWARDX
 * 
 * Added timestamp and instance-specific short name.
 * 
 *    Rev 1.6   Apr 24 1996 16:20:56   plantz
 * Removed include winsock2.h and incommon.h
 * 
 *    Rev 1.4.1.0   Apr 24 1996 16:19:54   plantz
 * Removed include winsock2.h and callcont.h
 * 
 *    Rev 1.4   01 Apr 1996 14:20:34   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.3   22 Mar 1996 16:04:18   EHOWARDX
 * Added #if defined(_DEBUG) around whole file.
 * 
 *    Rev 1.2   22 Mar 1996 15:25:28   EHOWARDX
 * Changed to use ISR_HookDbgStr instead of OutputDebugString.
 * 
 *    Rev 1.1   14 Mar 1996 17:01:00   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.0   08 Mar 1996 20:22:14   unknown
 * Initial revision.
 *
 ***************************************************************************/

#if defined(_DEBUG)

#ifndef STRICT
#define STRICT
#endif	// not defined STRICT
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#pragma warning ( disable : 4115 4201 4214 4514 )
#include "precomp.h"

#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "isrg.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


/*****************************************************************************
 *
 * TYPE:       Global System
 *
 * PROCEDURE:  HwsTrace
 *
 * DESCRIPTION:
 *    Trace function for HWS
 *
 * INPUT:
 *    dwInst         Instance identifier for trace message
 *    dwLevel        Trace level as defined below
 *    pszFormat      sprintf string format with 1-N parameters
 *
 * Trace Level (byLevel) Definitions:
 *    HWS_CRITICAL   Progammer errors that should never happen
 *    HWS_ERROR	   Errors that need to be fixed
 *    HWS_WARNING	   The user could have problems if not corrected
 *    HWS_NOTIFY	   Status, events, settings...
 *    HWS_TRACE	   Trace info that will not overrun the system
 *    HWS_TEMP		   Trace info that may be reproduced in heavy loops
 *
 * RETURN VALUE:
 *    None
 *
 *****************************************************************************/

void HwsTrace (DWORD dwInst, 
               BYTE byLevel, 
#ifdef UNICODE_TRACE
				LPTSTR pszFormat,
#else
				LPSTR pszFormat,
#endif               
                ...)
{
#ifdef UNICODE_TRACE
   TCHAR                szBuffer[128];
   static TCHAR         szName[] = __TEXT("H245WS-1");
#else
   char                 szBuffer[128];
   static char          szName[] = "H245WS-1";
#endif
   va_list              pParams;
   static WORD          wIsrInst = 0xFFFF;

   ASSERT(pszFormat != NULL);

   switch (byLevel)
   {
   case HWS_CRITICAL:
   case HWS_ERROR:
   case HWS_WARNING:
   case HWS_NOTIFY:
   case HWS_TRACE:
   case HWS_TEMP:
      break;

   default:
      byLevel = HWS_CRITICAL;
   } // switch

   if (wIsrInst == 0xFFFF)
   {
	   UINT        hMod;
	   ptISRModule	pMod;

	   for (hMod = 0; hMod < kMaxModules; ++hMod)
	   {
		   pMod = ISR_GetModule(hMod);
		   if (pMod)
         {
		      if (memcmp(szName, pMod->zSName, sizeof(szName)) == 0)
		      {
               szName[7] += 1;
            }
		   }
      }
      ISR_RegisterModule(&wIsrInst, szName, szName);
   }

#ifdef UNICODE_TRACE
   wsprintf(szBuffer, __TEXT("%9d:"), GetTickCount());
#else
   wsprintf(szBuffer, "%9d:", GetTickCount());
#endif
   va_start(pParams, pszFormat);
   wvsprintf(&szBuffer[10], pszFormat, pParams);
   ISR_HookDbgStr((UINT)dwInst, wIsrInst, byLevel, szBuffer, 0);
} // HwsTrace()



#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // (_DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\listman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/listman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   10 Dec 1996 11:26:46  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitListenManager();

HRESULT DeInitListenManager();

HRESULT AllocAndLockListen(			PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									HQ931LISTEN				hQ931Listen,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD_PTR				dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback,
									PPLISTEN				ppListen);

HRESULT FreeListen(					PLISTEN					pListen);

HRESULT LockListen(					CC_HLISTEN				hListen,
									PPLISTEN				ppListen);

HRESULT ValidateListen(				CC_HLISTEN				hListen);

HRESULT UnlockListen(				PLISTEN					pListen);

HRESULT GetLastListenAddress(		PCC_ADDR				pListenAddr);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\listman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Listman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.22  $
 *	$Date:   22 Jan 1997 14:55:52  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "listman.h"


static BOOL		bListenInited = FALSE;

static struct {
	PLISTEN				pHead;
	LOCK				Lock;
} ListenTable;

static struct {
	CC_HLISTEN			hListen;
	LOCK				Lock;
} ListenHandle;


HRESULT InitListenManager()
{
	ASSERT(bListenInited == FALSE);

	ListenTable.pHead = NULL;
	InitializeLock(&ListenTable.Lock);

	ListenHandle.hListen = CC_INVALID_HANDLE + 1;
	InitializeLock(&ListenHandle.Lock);

	bListenInited = TRUE;
	return CC_OK;
}



HRESULT DeInitListenManager()
{
PLISTEN		pListen;
PLISTEN		pNextListen;

	if (bListenInited == FALSE)
		return CC_OK;

	pListen = ListenTable.pHead;
	while (pListen != NULL) {
		AcquireLock(&pListen->Lock);
		pNextListen = pListen->pNextInTable;
		FreeListen(pListen);
		pListen = pNextListen;
	}

	DeleteLock(&ListenHandle.Lock);
	DeleteLock(&ListenTable.Lock);
	bListenInited = FALSE;
	return CC_OK;
}



HRESULT _AddListenToTable(			PLISTEN					pListen)
{
	ASSERT(pListen != NULL);
	ASSERT(pListen->hListen != CC_INVALID_HANDLE);
	ASSERT(pListen->bInTable == FALSE);

	AcquireLock(&ListenTable.Lock);

	pListen->pNextInTable = ListenTable.pHead;
	pListen->pPrevInTable = NULL;
	if (ListenTable.pHead != NULL)
		ListenTable.pHead->pPrevInTable = pListen;
	ListenTable.pHead = pListen;

	pListen->bInTable = TRUE;

	RelinquishLock(&ListenTable.Lock);
	return CC_OK;
}



HRESULT _RemoveListenFromTable(		PLISTEN					pListen)
{
CC_HLISTEN		hListen;
BOOL			bTimedOut;

	ASSERT(pListen != NULL);
	ASSERT(pListen->bInTable == TRUE);

	// Caller must have a lock on the listen object;
	// in order to avoid deadlock, we must:
	//   1. unlock the listen object,
	//   2. lock the ListenTable,
	//   3. locate the listen object in the ListenTable (note that
	//      after step 2, the listen object may be deleted from the
	//      ListenTable by another thread),
	//   4. lock the listen object (someone else may have the lock)
	//   5. remove the listen object from the ListenTable,
	//   6. unlock the ListenTable
	//
	// The caller can now safely unlock and destroy the listen object,
	// since no other thread will be able to find the object (its been
	// removed from the ListenTable), and therefore no other thread will
	// be able to lock it.

	// Save the listen handle; its the only way to look up
	// the listen object in the ListenTable. Note that we
	// can't use pListen to find the listen object, since
	// pListen may be free'd up, and another listen object
	// allocated at the same address
	hListen = pListen->hListen;

	// step 1
	RelinquishLock(&pListen->Lock);

step2:
	// step 2
	AcquireLock(&ListenTable.Lock);

	// step 3
	pListen = ListenTable.pHead;
	while ((pListen != NULL) && (pListen->hListen != hListen))
		pListen = pListen->pNextInTable;

	if (pListen != NULL) {
		// step 4
		AcquireTimedLock(&pListen->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ListenTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pListen->pPrevInTable == NULL)
			ListenTable.pHead = pListen->pNextInTable;
		else
			pListen->pPrevInTable->pNextInTable = pListen->pNextInTable;

		if (pListen->pNextInTable != NULL)
			pListen->pNextInTable->pPrevInTable = pListen->pPrevInTable;

		pListen->pNextInTable = NULL;
		pListen->pPrevInTable = NULL;
		pListen->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ListenTable.Lock);

	if (pListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeListenHandle(			PCC_HLISTEN				phListen)
{
	AcquireLock(&ListenHandle.Lock);
	*phListen = ListenHandle.hListen++;
	RelinquishLock(&ListenHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockListen(			PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									HQ931LISTEN				hQ931Listen,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD_PTR				dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback,
									PPLISTEN				ppListen)
{
HRESULT		status;
	
	ASSERT(bListenInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phListen != NULL);
	ASSERT(pListenAddr != NULL);
	ASSERT(ListenCallback != NULL);
	ASSERT(ppListen != NULL);

	// set phListen now, in case we encounter an error
	*phListen = CC_INVALID_HANDLE;

	*ppListen = (PLISTEN)MemAlloc(sizeof(LISTEN));
	if (*ppListen == NULL)
		return CC_NO_MEMORY;

	(*ppListen)->bInTable = FALSE;
	status = _MakeListenHandle(&(*ppListen)->hListen);
	if (status != CC_OK) {
		MemFree(*ppListen);
		return status;
	}
	
	// make a local copy of the ListenAddr
	(*ppListen)->ListenAddr = *pListenAddr;
	(*ppListen)->hQ931Listen = hQ931Listen;
	(*ppListen)->dwListenToken = dwListenToken;
	(*ppListen)->pLocalAliasNames = NULL;
	(*ppListen)->ListenCallback = ListenCallback;
	(*ppListen)->pNextInTable = NULL;
	(*ppListen)->pPrevInTable = NULL;
	(*ppListen)->pLocalAliasNames = NULL;

	InitializeLock(&(*ppListen)->Lock);
	AcquireLock(&(*ppListen)->Lock);

	*phListen = (*ppListen)->hListen;

	// make a local copy of the local alias names
	status = Q931CopyAliasNames(&(*ppListen)->pLocalAliasNames, pLocalAliasNames);
	if (status != CS_OK) {
		FreeListen(*ppListen);
		*phListen = CC_INVALID_HANDLE;
		return status;
	}

	// add the Listen to the Listen table
	status = _AddListenToTable(*ppListen);
	if (status != CC_OK)
		FreeListen(*ppListen);
	
	return status;
}



// Caller must have a lock on the Listen object
HRESULT FreeListen(					PLISTEN				pListen)
{
CC_HLISTEN		hListen;

	ASSERT(pListen != NULL);

	// caller must have a lock on the Listen object,
	// so there's no need to re-lock it

	hListen = pListen->hListen;

	if (pListen->bInTable == TRUE)
		if (_RemoveListenFromTable(pListen) == CC_BAD_PARAM)
			// the Listen object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pListen->pLocalAliasNames != NULL)
		Q931FreeAliasNames(pListen->pLocalAliasNames);
	
	// Since the listen object has been removed from the ListenTable,
	// no other thread will be able to find the listen object and obtain
	// a lock, so its safe to unlock the listen object and delete it here
	RelinquishLock(&pListen->Lock);
	DeleteLock(&pListen->Lock);
	MemFree(pListen);
	return CC_OK;
}



HRESULT LockListen(					CC_HLISTEN				hListen,
									PPLISTEN				ppListen)
{
BOOL	bTimedOut;

	ASSERT(hListen != CC_INVALID_HANDLE);
	ASSERT(ppListen != NULL);

step1:
	AcquireLock(&ListenTable.Lock);

	*ppListen = ListenTable.pHead;
	while ((*ppListen != NULL) && ((*ppListen)->hListen != hListen))
		*ppListen = (*ppListen)->pNextInTable;

	if (*ppListen != NULL) {
		AcquireTimedLock(&(*ppListen)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ListenTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ListenTable.Lock);

	if (*ppListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateListen(				CC_HLISTEN				hListen)
{
PLISTEN	pListen;

	ASSERT(hListen != CC_INVALID_HANDLE);

	AcquireLock(&ListenTable.Lock);

	pListen = ListenTable.pHead;
	while ((pListen != NULL) && (pListen->hListen != hListen))
		pListen = pListen->pNextInTable;

	RelinquishLock(&ListenTable.Lock);

	if (pListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockListen(				PLISTEN					pListen)
{
	ASSERT(pListen != NULL);

	RelinquishLock(&pListen->Lock);
	return CC_OK;
}



HRESULT GetLastListenAddress(		PCC_ADDR				pListenAddr)
{
HRESULT	status;
PLISTEN	pListen;
PLISTEN	pLastListen;

	ASSERT(pListenAddr != NULL);

	AcquireLock(&ListenTable.Lock);

	pListen = ListenTable.pHead;
	pLastListen = pListen;
	while (pListen != NULL) {
		if (pLastListen->hListen < pListen->hListen)
			pLastListen = pListen;
		pListen = pListen->pNextInTable;
	}

	if (pLastListen == NULL)
		status = CC_BAD_PARAM;
	else {
		status = CC_OK;
		*pListenAddr = pLastListen->ListenAddr;
	}	

	RelinquishLock(&ListenTable.Lock);
	return status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\linkapi.h ===
/***************************************************************************
 *
 * File: linkapi.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   linkapi.h  $
 * $Revision:   1.17  $
 * $Modtime:   11 Dec 1996 13:57:14  $
 * $Log:   S:\sturgeon\src\include\vcs\linkapi.h_v  $
 *
 *    Rev 1.17   11 Dec 1996 14:10:48   SBELL1
 * changed parameters to linkLayerInit/Listen
 *
 *    Rev 1.16.1.0   11 Dec 1996 13:57:14   SBELL1
 * CHanged parameters to linkLayerInit and Listen.
 *
 *    Rev 1.16   14 Oct 1996 14:00:20   EHOWARDX
 *
 * Unicode changes.
 *
 *    Rev 1.15   15 Aug 1996 14:00:08   rodellx
 *
 * Added additional address validation error case for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 *
 *    Rev 1.14   11 Jul 1996 18:42:10   rodellx
 *
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 *
 *    Rev 1.13   10 Jul 1996 21:36:26   rodellx
 *
 * Changed error code base to required value defined by apierror.h.
 *
 *    Rev 1.12   May 28 1996 18:09:08   plantz
 * Change all error and message codes to use HRESULT. Deleted unused codes.
 *
 *    Rev 1.11   09 May 1996 18:28:36   EHOWARDX
 * Eliminated unnessary formal parameters.
 *
 *    Rev 1.4   25 Apr 1996 21:43:50   helgebax
 * Copied Philip's changes from sturgeon\src\include.
 *
 *    Rev 1.10   Apr 25 1996 21:07:16   plantz
 * Add messages for connect callback.
 * Add connect callback parameter to link layer accept.
 *
 *    Rev 1.9   Apr 25 1996 15:36:50   plantz
 * Remove #include incommon.h and dependencies on types defined in incommon
 * (use pointers to incomplete structure types instead).
 *
 *    Rev 1.8   Apr 24 1996 20:54:08   plantz
 * Change name of H245LISTENCALLBACK to H245CONNECTCALLBACK and add additional
 * parameters. Add it as an parameter to linkLayerConnect as well as
 * linkLayerListen.
 *
 *    Rev 1.7   Apr 24 1996 17:00:04   plantz
 * Merge 1.3.1.0 with 1.6 (changes to support Q931).
 *
 *    Rev 1.6   19 Apr 1996 10:35:36   EHOWARDX
 * Encorporate Dan's latest SRPAPI.H changes.
 *
 *    Rev 1.3.1.0   Apr 23 1996 13:45:26   plantz
 * Changes to support Q.931.
 *
 *****************************************************************************/

#ifndef LINKAPI_H
#define LINKAPI_H

#include "apierror.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// declare exported functions
#if(0)  // it's all in one DLL
#if defined(LINKDLL_EXPORT)
#define LINKDLL __declspec (dllexport)
#else   // (LINKDLL_EXPORT)
#define LINKDLL __declspec (dllimport)
#endif  // (LINKDLL_EXPORT)
#define SRPDLL LINKDLL
#else
#define LINKDLL cdecl
#endif

////////////////////////////////////////////////////////////////////////////
//
// Link Layer defaults
//
////////////////////////////////////////////////////////////////////////////

#define INVALID_PHYS_ID			(DWORD) 0xffffffff


////////////////////////////////////////////////////////////////////////////
//
// Link Layer Error defines
//
////////////////////////////////////////////////////////////////////////////

#define LINK_ERROR_BASE        ERROR_LOCAL_BASE_ID
#define LINK_SEND_ERROR_BASE   LINK_ERROR_BASE + 0x100
#define LINK_SEND_COMP_BASE    LINK_ERROR_BASE + 0x200
#define LINK_RCV_ERROR_BASE    LINK_ERROR_BASE + 0x300
#define LINK_RCV_COMP_BASE     LINK_ERROR_BASE + 0x400
#define LINK_UTIL_ERROR_BASE   LINK_ERROR_BASE + 0x500
#define LINK_UTIL_COMP_BASE    LINK_ERROR_BASE + 0x600
#define LINK_FATAL_ERROR       LINK_ERROR_BASE + 0x700
#define LINK_CONN_ERROR_BASE   LINK_ERROR_BASE + 0x800
#define LINK_CONN_COMP_BASE    LINK_ERROR_BASE + 0x900

////////////////////////////////////////////////////////////////////////////
//
// CallBack Prototype for Channel CallBack
//
////////////////////////////////////////////////////////////////////////////

typedef void (*H245SRCALLBACK)
(
    DWORD_PTR   dwH245Instance,
    HRESULT     dwMessage,
    PBYTE       pbyDataBuf,
    DWORD       dwLength
);

// Link Send Callback error codes
#define LINK_SEND_COMPLETE     MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 0)
#define LINK_SEND_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 5) // Tx aborted the SDU (not implemented)
#define LINK_SEND_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+20)
#define LINK_SEND_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+22)
#define LINK_SEND_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+23)

// Link Receive Callback error codes
#define LINK_RECV_DATA         MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 6) // DATA.INDICATION from H.223 (Should not be zero)
#define LINK_RECV_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 7) // Tx aborted the SDU (not implemented)
#define LINK_RECV_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+10) // from AL2 - _CRC error
#define LINK_RECV_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+20)
#define LINK_RECV_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+22)

typedef void (*H245CONNECTCALLBACK)
(
   DWORD_PTR   dwH245Instance,
   HRESULT     dwMessage,
   struct _ADDR *LocalAddr,
   struct _ADDR *PeerAddr
);

#define LINK_CONNECT_REQUEST   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+1)
#define LINK_CONNECT_COMPLETE  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+2)

////////////////////////////////////////////////////////////////////////////
//
// Link Layer Function Prototypes
//
////////////////////////////////////////////////////////////////////////////
LINKDLL VOID H245WSShutdown();

/**************************************************************************
**	Function 	: linkLayerInit
**	Description : This function will initialize the datalink subsystem.
**				  This in turn will make appropriate calls to initialize
**				  the software and hardware subsystems below this layer.
**				  linkLayernit() has to be called before any other service or
**				  System control functions are used.
****************************************************************************/
LINKDLL HRESULT
linkLayerInit
(
    DWORD*           pdwPhysicalId,
    DWORD_PTR       dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

typedef
HRESULT
(*PFxnlinkLayerInit)
(
    DWORD*           pdwPhysicalId,
    DWORD_PTR       dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

///////////////////////////////////////////////////////////////
///
///	SRP Initialization defines
///
///////////////////////////////////////////////////////////////

#define LINK_INVALID_INSTANCE    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+1)
#define LINK_DUPLICATE_INSTANCE  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+2)
#define LINK_MEM_FAILURE         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, ERROR_OUTOFMEMORY)
#define LINK_INVALID_STATE       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+6)
#define LINK_INSTANCE_TABLE_FULL MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+7)



/**************************************************************************
**	Function 	: linkLayerShutdown
**	Description : This releases all the memory the link layer used for a particular
**				  instance. For using any of the linklayer services in that
**				  instance again, a linkLayerInit has to be called.
**				  This function will shutdown the linklayer session pointed
**				  by the dwPhysicalID.
***************************************************************************/
LINKDLL HRESULT
linkLayerShutdown
(DWORD dwPhysicalId);



typedef
 HRESULT
(*PFxnlinkLayerShutdown)
(DWORD dwPhysicalId);



///////////////////////////////////////////////////////////////
///
///	SRP Termination defines
///
///////////////////////////////////////////////////////////////

/**************************************************************************
**	Function 	: linkLayerGetInstance
**	Description : Returns the link layer instance corresponding to a physical ID
***************************************************************************/
LINKDLL DWORD
linkLayerGetInstance
(DWORD dwPhysicalId);



typedef
DWORD
(*PFxnlinkLayerGetInstance)
(DWORD dwPhysicalId);



/**************************************************************************
**	Function 	: datalinkReceiveRequest
**	Description : Posts one receive message buffer to the link layer subsystem.
**				  This buffer will be filled in by the incoming message for
** 				  the specified channel. H223_DATA_INDICATION will be sendto
**				  the client on receiving a complete PDU. Error messages may also be
**				  reported.
***************************************************************************/
LINKDLL HRESULT
datalinkReceiveRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT
(*PFxndatalinkReceiveRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Receive Request return codes

#define LINK_RECV_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_ERROR_BASE+ 2) // No room for buffering


/**************************************************************************
**	Function 	: datalinkSendRequest
**	Description : Hands over the message to be sent to the link layer subsystem.
***************************************************************************/
LINKDLL HRESULT
datalinkSendRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT
(*PFxndatalinkSendRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Send Request return codes

#define LINK_SEND_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_ERROR_BASE+2)


/**************************************************************************
**	Function 	: linkLayerFlushChannel
**	Description : All the posted transmit and/or receive buffers are released.
**					The bitmasks DATALINK_RECEIVE and DATALINK_RECEIVE can
**					be OR'd together to perform both functions in the same call
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushChannel
(DWORD dwPhysicalId, DWORD dwDirectionMask);




typedef
HRESULT
(*PFxnlinkLayerFlushChannel)
(DWORD dwPhysicalId, DWORD dwDirectionMask);




// Bits for dwDirectionMask
#define DATALINK_RECEIVE      0x01  // Flush buffer in receive direction
#define DATALINK_TRANSMIT     0x02  // Flush buffer in Transmit direction
#define DATALINK_TX_ACTIVES   0x04  // Flush buffers actively being transmitted
#define SHUTDOWN_PENDING      0x08  // Shutdown is in progress
#define FLUSH_SYNCH           0x10  // 0: Asynch call, 1: Synchronous call
#define DATALINK_TRANSMIT_ALL (DATALINK_TRANSMIT | DATALINK_TX_ACTIVES)
#define SHUTDOWN_MASK         (DATALINK_RECEIVE | DATALINK_TRANSMIT | SHUTDOWN_PENDING)


// linkLayerFlushChannel Callback

#define LINK_FLUSH_COMPLETE   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_UTIL_COMP_BASE+1)


/**************************************************************************
**	Function 	: linkLayerFlushAll
**	Description : All the posted transmit and/or receive buffers are released.
**					Same as LinkLayerFlushChannel except:
**					1) Synchronous Call
**					2) Transmit Buffers in progress are flushed
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushAll
(DWORD	dwPhysicalId);



typedef
HRESULT
(*PFxnlinkLayerFlushAll)
(DWORD	dwPhysicalId);



// linkLayerFlushChannel RETURN CODES same as for linkLayerFlushChannel

#define LINK_UNKNOWN_ADDR      MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, LINK_UTIL_ERROR_BASE + 1)

LINKDLL HRESULT
linkLayerConnect(DWORD dwPhysicalId, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerListen(DWORD* dwPhysicalId, DWORD_PTR dwH245Instance, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerReject(DWORD dwPhysicalIdListen);


#define LL_PDU_SIZE             2048



/**************************************************************************
**
**  Dynamic DLL Function Calls
**
**************************************************************************/
#ifdef UNICODE
#define SRPDLLFILE          L"h245srp.dll"
#define H245WSDLLFILE       L"h245ws.dll"
#else
#define SRPDLLFILE          "h245srp.dll"
#define H245WSDLLFILE       "h245ws.dll"
#endif

#define LINKINITIALIZE      __TEXT("linkLayerInit")
#define LINKSHUTDOWN        __TEXT("linkLayerShutdown")
#define LINKGETINSTANCE     __TEXT("linkLayerGetInstance")
#define LINKRECEIVEREQUEST  __TEXT("datalinkReceiveRequest")
#define LINKSENDREQUEST     __TEXT("datalinkSendRequest")
#define LINKFLUSHCHANNEL    __TEXT("linkLayerFlushChannel")
#define LINKFLUSHALL        __TEXT("linkLayerFlushAll")

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // LINKAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\mstrslv.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mstrslv.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   mstrslv.c  $
 * $Revision:   1.12  $
 * $Modtime:   12 Dec 1996 14:37:12  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/mstrslv.c_v  $
 *
 *    Rev 1.12   12 Dec 1996 15:52:50   EHOWARDX
 * Master Slave Determination kludge.
 *
 *    Rev 1.11   11 Dec 1996 16:50:50   EHOWARDX
 * Went back to original Master/Slave determination algorithm.
 *
 *    Rev 1.10   09 Dec 1996 13:34:48   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.9   26 Nov 1996 17:06:02   EHOWARDX
 * Reversed order of subtraction for DetermineMasterSlave.
 *
 *    Rev 1.8   08 Aug 1996 16:03:40   EHOWARDX
 *
 * Fixed master slave determinate bug (hopefully the last one!)
 *
 *    Rev 1.7   19 Jul 1996 12:12:44   EHOWARDX
 *
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 *
 *    Rev 1.6   01 Jul 1996 23:35:48   EHOWARDX
 * MSDetAckIncoming bug - was sending indication instead of confirm.
 *
 *    Rev 1.5   01 Jul 1996 23:14:20   EHOWARDX
 * Fixed bug in MSDetOutgoing -- state change was ifdefed out.
 *
 *    Rev 1.4   07 Jun 1996 16:00:26   EHOWARDX
 * Fixed bug with pOut not getting freed in msDetOutgoing.
 *
 *    Rev 1.3   07 Jun 1996 15:40:20   EHOWARDX
 * Fixed bug in msDetRejOutgoing; pOut was not freed if N100 count exceeded.
 *
 *    Rev 1.2   04 Jun 1996 13:57:54   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:16   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:32   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.11.1.4   09 May 1996 19:48:48   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.11.1.3   25 Apr 1996 17:00:22   EHOWARDX
 * Minor fixes.
 *
 *    Rev 1.11.1.2   15 Apr 1996 10:45:46   EHOWARDX
 * Update.
 *
 *    Rev 1.11.1.1   10 Apr 1996 21:15:46   EHOWARDX
 * Check-in for safety in middle of re-design.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mstrslv.h"
#include "pdu.x"



// Master Slave Determination states

#define MSIDLE                      0
#define MSOutgoingAwaiting          1
#define MSIncomingAwaiting          2

#define MAX_RAND                  0x00FFFFFF


extern unsigned int uN100;
extern unsigned int uT106;



/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T106ExpiryF - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T106ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T106Expiry);
} // T106ExpiryF()



#define GetTerminal(pObject)  (pObject)->pInstance->StateMachine.sv_TT
#define GetStatus(pObject)    (pObject)->pInstance->StateMachine.sv_STATUS
#define SetStatus(pObject, Status) (pObject)->pInstance->StateMachine.sv_STATUS = (Status)
#define GetRandomNumber(pObject) (pObject)->u.msdse.sv_SDNUM
#define SetRandomNumber(pObject, uRandom) (pObject)->u.msdse.sv_SDNUM = (uRandom)
#define GetCount(pObject) (pObject)->u.msdse.sv_NCOUNT
#define SetCount(pObject, uCount) (pObject)->u.msdse.sv_NCOUNT = (uCount)



/*
 *  NAME
 *      DetermineStatus - determines whether the terminal is a master or a slave or neither
 *
 *
 *  PARAMETERS
 *   INPUT   pdu        pointer to a PDU structure
 *
 *  RETURN VALUE
 *   terminal status
 */

static MS_Status_t DetermineStatus(Object_t *pObject, PDU_t *pPdu)
{
    unsigned int uTemp;
    unsigned char sv_TT = GetTerminal(pObject);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.terminalType < sv_TT)
        return pObject->pInstance->StateMachine.sv_STATUS = MASTER;
    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.terminalType > sv_TT)
        return pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
    uTemp = (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.statusDeterminationNumber - GetRandomNumber(pObject)) & 0xFFFFFF;
    if (uTemp > 0x800000)
        return pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
    if (uTemp < 0x800000 && uTemp != 0)
        return pObject->pInstance->StateMachine.sv_STATUS = MASTER;
    return pObject->pInstance->StateMachine.sv_STATUS = INDETERMINATE;
}



/***********************************************************************
 *
 * FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      detRequestIdle - request Master/Slave Determination from API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT detRequestIdle(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIDLE);

    SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
    SetCount(pObject, 1);               // Initialize retry counter
    SetStatus(pObject, INDETERMINATE);
    H245TRACE(  pObject->dwInst, 2,
                "detRequestIdle: TerminalType=%d StatusDeterminationNumber=%d",
                GetTerminal(pObject), GetRandomNumber(pObject));

    /* Send a Master/Slave determination PDU */
    H245TRACE(pObject->dwInst, 2, "Master/Slave Determination to Send/Rec module");
    pdu_req_mstslv (pPdu, GetTerminal(pObject), GetRandomNumber(pObject));
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T106 */
    pObject->State = MSOutgoingAwaiting;
    FsmStartTimer(pObject, T106ExpiryF, uT106);

    return lError;
} // detRequestIdle()

/*
 *  NAME
 *      msDetIdle - received Master/Slave Determination PDU in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetIdle(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIDLE);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        DetermineStatus(pObject, pPdu);
        return H245_ERROR_NOMEM;
    }

    SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
    switch (DetermineStatus(pObject, pPdu))
    {
    case MASTER:
        /* Build MasterSlave Determination Ack */
        H245TRACE(pObject->dwInst, 2, "msDetIdle: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case SLAVE:
        /* Build MasterSlave Determination Ack */
        H245TRACE(pObject->dwInst, 2, "msDetIdle: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        /* Send a masterSlaveDet Reject */
        pdu_rsp_mstslv_rej(pOut);
        lError = sendPDU(pObject->pInstance, pOut);
        MemFree(pOut);
        return lError;
    } // switch

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    pObject->State = MSIncomingAwaiting;

#if defined(SDL_COMPLIANT)
    /* Send DETERMINE indication to client - unnecessary */
    H245FsmIndication(pPdu, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    /* set timer T106 */
    FsmStartTimer(pObject, T106ExpiryF, uT106);
    return lError;
}



/*
 *  NAME
 *      msDetAckOutgoing - received Master/Slave Determination Ack pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */
HRESULT msDetAckOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer */
    FsmStopTimer(pObject);

    /* Decision is opposite of MasterSlaveDeterminationAck.decision */
    switch(pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice)
    {
    case master_chosen:
        pObject->pInstance->StateMachine.sv_STATUS = MASTER;
        H245TRACE(pObject->dwInst, 2, "msDetAckOutgoing: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case slave_chosen:
        pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
        H245TRACE(pObject->dwInst, 2, "msDetAckOutgoing: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        H245TRACE(pObject->dwInst, 1, "msDetAckOutgoing: Invalid Master Slave Determination Ack received");
        return H245_ERROR_PARAM;
    }

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send DETERMINE confirm to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      msDetOutgoing- received Master/Slave Determination pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);

	if (pObject->pInstance->bMasterSlaveKludge == 0)
	{
		// Ignore this message
		return NOERROR;
	}

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer T106 */
    FsmStopTimer(pObject);

    switch (DetermineStatus(pObject, pPdu))
    {
    case MASTER:
        H245TRACE(pObject->dwInst, 2, "msDetOutgoing: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case SLAVE:
        H245TRACE(pObject->dwInst, 2, "msDetOutgoing: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        if (GetCount(pObject) >= uN100)
        {
            MemFree(pOut);

            /* Send ERROR.indication(F) to client */
            H245TRACE(pObject->dwInst, 2, "msDetOutgoing: Counter expired; Session Failed");
            H245FsmConfirm(NULL,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

            /* Send REJECT.indication to client - unnecessary */

            pObject->State = MSIDLE;
            lError = 0;
        }
        else
        {
            /* generate a new random number */
            H245TRACE(pObject->dwInst, 2, "Resending MasterSlaveDetermination");
            SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
            SetCount(pObject, GetCount(pObject) + 1);

            /* Send MasterSlave Determination PDU to remote */
            pdu_req_mstslv (pOut, GetTerminal(pObject), GetRandomNumber(pObject));
            lError = sendPDU(pObject->pInstance, pOut);
            MemFree(pOut);

            /* set timer T106 */
            pObject->State = MSOutgoingAwaiting;
            FsmStartTimer(pObject, T106ExpiryF, uT106);
        }
        return lError;
    } // switch

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    pObject->State = MSIncomingAwaiting;

#if defined(SDL_COMPLIANT)
    /* Send DETERMINE indication to client */
    H245FsmIndication(pPdu, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    /* set timer T106 */
    FsmStartTimer(pObject, T106ExpiryF, uT106);

    return lError;
}



/*
 *  NAME
 *      msDetRejOutgoing- received Master/Slave Determination Reject pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */


HRESULT msDetRejOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer T106 */
    FsmStopTimer(pObject);

    if (GetCount(pObject) >= uN100)
    {
        MemFree(pOut);

        H245TRACE(pObject->dwInst, 2, "msDetRejOutgoing: Counter expired; Session Failed");
        pObject->State = MSIDLE;

        /* Send ERROR.indication(f) to client */
        H245FsmConfirm(pPdu,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
        /* Send REJECT.indication to client - not necessary */
        H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

        lError = 0;
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "msDetRejOutgoint: Re-sending a MasterSlaveDetermination");

        /* generate a new random number */
        SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
        SetCount(pObject, GetCount(pObject) + 1);

        /* Send MasterSlave Determination PDU to remote */
        pdu_req_mstslv (pOut, GetTerminal(pObject), GetRandomNumber(pObject));
        lError = sendPDU(pObject->pInstance,pOut);
        MemFree(pOut);

        /* set timer T106 */
        FsmStartTimer(pObject, T106ExpiryF, uT106);
    }

    return lError;
}



/*
 *  NAME
 *      msDetReleaseOutgoing- received Master/Slave Determination release pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetReleaseOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetReleaseOutgoing: Master/Slave Determination Release received; session failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(B) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      t106ExpiryOutgoing- timer expired for an outgoing M/S determination pdu
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t106ExpiryOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);
    ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2, "t106ExpiryOutgoing: Timer expired before receiving Ack; session failed");

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* Send MasterSlave Determination Release to remote */
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = mstrSlvDtrmntnRls_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send ERROR.indication(A) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(NULL,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return lError;
}

/*
*  NAME
*      msDetAckIncoming- received Master/Slave Determination Ack pdu in incoming state
*
*
*  PARAMETERS
*   INPUT   pObject        pointer to a State Entity
*
*  RETURN VALUE
*       error return codes defined in h245com.h
*/

HRESULT msDetAckIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);

    /* reset timer T106 */
    FsmStopTimer(pObject);

    switch (GetStatus(pObject))
    {
    case  master_chosen:
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
        {
            H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Terminal is a MASTER");

            /* Send DETERMINE.confirm to client */
            pObject->State = MSIDLE;
            H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
            return 0;
        }
        break;

    case slave_chosen:
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == slave_chosen)
        {
            H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Terminal is a SLAVE");

            /* Send DETERMINE.confirm to client */
            pObject->State = MSIDLE;
            H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
            return 0;
        }
        break;

    default:
        H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Invalid MasterSlave Determination Ack received");
        return H245_ERROR_PARAM;
    } // switch

    H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: bad decision in MasterSlave Determination Ack; Session failed");

    /* Send ERROR.indication(E) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, SESSION_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

return 0;
}



/*
 *  NAME
 *      msDetIncoming- received Master/Slave Determination pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetIncoming: received MasterSlave Determination in INCOMING state; Session failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(C) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      msDetRejIncoming- received Master/Slave Determination Reject pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetRejIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetRejIncoming: received MasterSlave Reject: Session Failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(D) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      msDetReleaseIncoming- received Master/Slave Determination Release pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetReleaseIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetReleaseIncoming: received MasterSlave Release; Session Failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(B) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      t106ExpiryIncoming - timer expired while waiting for second Ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t106ExpiryIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2, "t106ExpiryIncoming: timer expired waiting for Ack; Session failed");

    /* Send ERROR.indication(A) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\mlse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mlse.c                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MLSE.C  $
 * $Revision:   1.4  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/MLSE.C_v  $
 *
 *    Rev 1.4   09 Dec 1996 13:34:46   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.3   04 Jun 1996 13:57:24   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:14   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   28 May 1996 14:25:42   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:30   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:26   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:46:58   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/
#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mlse.h"



// Out-going/In-coming MLSE states
#define MLSE_NOT_LOOPED             0   // NOT LOOPED
#define MLSE_WAIT                   1   // AWAITING RESPONSE
#define MLSE_LOOPED                 1   // LOOPED


extern unsigned int uT102;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T102ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T102ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T102Expiry);
} // T102ExpiryF()



static void BuildMaintenanceLoopOffCommand(PDU_t *pPdu)
{
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = mntnncLpOffCmmnd_chosen;
} // BuildMaintenanceLoopOffCommand()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MLSE0_LOOP_requestF - LOOP.request from API in NOT LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE0_LOOP_requestF             (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_NOT_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE0_LOOP_request:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    // Send Maintenance Loop Request PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T102
    pObject->State = MLSE_WAIT;
    FsmStartTimer(pObject, T102ExpiryF, uT102);

    return lError;
} // MLSE0_LOOP_request



/*
 *  NAME
 *      MLSE1_MaintenanceLoopAckF - MaintenanceLoopAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopAckF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopAck:%d", pObject->Key);

    // Reset timer T102
    FsmStopTimer(pObject);

    // Send LOOP.confirm to client
    pObject->State = MLSE_LOOPED;
    H245FsmConfirm(pPdu, H245_CONF_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopAck



/*
 *  NAME
 *      MLSE1_MaintenanceLoopRejF - MaintenanceLoopReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopRej:%d", pObject->Key);

    // Reset timer T102
    FsmStopTimer(pObject);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmConfirm(pPdu, H245_CONF_MLSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopRej



/*
 *  NAME
 *      MLSE1_OUT_RELEASE_requestF - RELEASE.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_OUT_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pObject->State = MLSE_NOT_LOOPED;
    BuildMaintenanceLoopOffCommand(pPdu);
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_OUT_RELEASE_request



/*
 *  NAME
 *      MLSE1_T102ExpiryF - timer T102 Expiry in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_T102ExpiryF               (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MLSE1_T102Expiry:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MLSE1_T102ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildMaintenanceLoopOffCommand(pOut);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send RELEASE.indication to client
    //   SOURCE := MLSE
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmConfirm(NULL, H245_CONF_MLSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // MLSE1_T102Expiry

/*
 *  NAME
 *      MLSE2_MaintenanceLoopRejF - MaintenanceLoopReject in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopRej:%d", pObject->Key);

    pObject->State = MLSE_NOT_LOOPED;

#if defined(SDL_COMPLIANT)
    // Send ERROR.indication(B) to client
    // TBD
#endif

    // Send RELEASE.indication to client
    //   SOURCE := MLSE
    H245FsmConfirm(pPdu, H245_CONF_MLSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopRej



/*
 *  NAME
 *      MLSE2_OUT_RELEASE_requestF - RELEASE.request from API in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE2_OUT_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pObject->State = MLSE_NOT_LOOPED;
    BuildMaintenanceLoopOffCommand(pPdu);
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE2_OUT_RELEASE_request



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MLSE0_MaintenanceLoopRequestF - MaintenanceLoopRequest received in NOT LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE0_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_NOT_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE0_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    // Send LOOP.indication to client
    pObject->State = MLSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE0_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE1_MaintenanceLoopRequestF - MaintenanceLoopRequest received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

#if defined(SDL_COMPLIANT)
    // Send RELEASE.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send LOOP.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE1_MaintenanceLoopReleaseF - MaintenanceLoopOffCommand received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopOffCommand:%d", pObject->Key);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopOffCommand



/*
 *  NAME
 *      MLSE1_LOOP_responseF - LOOP.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_LOOP_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_LOOP_response:%d", pObject->Key);

    // Send MaintenanceLoopAck PDU to remote peer
    pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice = pObject->u.mlse.wLoopType;
    switch (pObject->u.mlse.wLoopType)
    {
    case systemLoop_chosen:
        break;
    case mediaLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop          = (WORD)pObject->Key;
        break;
    case logicalChannelLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.logicalChannelLoop = (WORD)pObject->Key;
        break;
    default:
        H245TRACE(pObject->dwInst, 1, "Invalid loop type %d", pObject->u.mlse.wLoopType);
    } // switch
    pObject->State = MLSE_LOOPED;
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_LOOP_response



/*
 *  NAME
 *      MLSE1_IN_RELEASE_requestF - RELEASE.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_IN_RELEASE_requestF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_IN_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopReject PDU to remote peer
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice = pObject->u.mlse.wLoopType;
    switch (pObject->u.mlse.wLoopType)
    {
    case systemLoop_chosen:
        break;
    case mediaLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop          = (WORD)pObject->Key;
        break;
    case logicalChannelLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.logicalChannelLoop = (WORD)pObject->Key;
        break;
    default:
        H245TRACE(pObject->dwInst, 1, "Invalid loop type %d", pObject->u.mlse.wLoopType);
    } // switch
    pObject->State = MLSE_NOT_LOOPED;
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_IN_RELEASE_request



/*
 *  NAME
 *      MLSE2_MaintenanceLoopRequestF - MaintenanceLoopRequest received in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    pObject->State = MLSE_WAIT;

#if defined(SDL_COMPLIANT)
    // Send RELEASE.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send LOOP.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE2_MaintenanceLoopReleaseF - MaintenanceLoopOffCommand received in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopOffCommand:%d", pObject->Key);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopOffCommand

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\mrse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mrse.h                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MRSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MRSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:24   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:52   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:44:02   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:11:14   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mode (MRSE_OUT) state functions
HRESULT MRSE0_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeAckF           (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeRejF           (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_T109ExpiryF               (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mode (MRSE_OUT) state functions
HRESULT MRSE0_RequestModeF              (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeF              (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeReleaseF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_TRANSFER_responseF        (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_REJECT_requestF           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\mrse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mrse.c                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   mrse.c  $
 * $Revision:   1.5  $
 * $Modtime:   13 Feb 1997 19:25:48  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/mrse.c_v  $
 *
 *    Rev 1.5   13 Feb 1997 19:31:20   MANDREWS
 * Fixed bug in generation of request mode ack and request mode reject;
 * the sequence number was not being copied into the pdu.
 *
 *    Rev 1.4   09 Dec 1996 13:34:46   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.3   04 Jun 1996 14:01:06   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:16   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   28 May 1996 14:25:44   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:32   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:08   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:44:52   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mrse.h"



// Out-going/In-coming MRSE states
#define MRSE_IDLE                   0   // IDLE
#define MRSE_WAIT                   1   // AWAITING_RESPONSE



extern unsigned int uT109;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T109ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T109ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T109Expiry);
} // T109ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MRSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE0_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MRSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byMrseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber =
        pObject->pInstance->StateMachine.byMrseOutSequence;

    // Send Request Mode PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T109
    pObject->State = MRSE_WAIT;
    FsmStartTimer(pObject, T109ExpiryF, uT109);

    return lError;
} // MRSE0_TRANSFER_request



/*
 *  NAME
 *      MRSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T109
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byMrseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber =
        pObject->pInstance->StateMachine.byMrseOutSequence;

    // Send Request Mode PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T109
    FsmStartTimer(pObject, T109ExpiryF, uT109);

    return lError;
} // MRSE1_TRANSFER_request



/*
 *  NAME
 *      MRSE1_RequestModeAckF - RequestModeAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeAckF     (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestModeAck:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.requestModeAck.sequenceNumber ==
        pObject->pInstance->StateMachine.byMrseOutSequence)
    {
        // Reset timer T109
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = MRSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MRSE1_RequestModeAck



/*
 *  NAME
 *      MRSE1_RequestModeRejF - RequestModeReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeRejF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE0_RequestModeRej:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.requestModeReject.sequenceNumber ==
        pObject->pInstance->StateMachine.byMrseOutSequence)
    {
        // Reset timer T109
        FsmStopTimer(pObject);

        // Send REJECT.indication to H.245 user
        // CAUSE = RequestModeReject.cause
        pObject->State = MRSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MRSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MRSE1_RequestModeRej



/*
 *  NAME
 *      MRSE1_T109ExpiryF - timer T109 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_T109ExpiryF                (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MRSE1_T109Expiry:%d", pObject->Key);

    // Send RequestModeRelease PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MRSE1_T109ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = requestModeRelease_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = MRSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_MRSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // MRSE1_T109Expiry

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MRSE0_RequestModeF - RequestMode received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE0_RequestModeF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MRSE0_RequestMode:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber;

    // Send TRANSFER.indication to H.245 user
    pObject->State = MRSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE0_RequestMode



/*
 *  NAME
 *      MRSE1_RequestModeF - RequestMode received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestMode:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber;

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MRSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send TRANSFER.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE1_RequestMode



/*
 *  NAME
 *      MRSE1_RequestModeReleaseF - RequestModeRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeReleaseF (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestModeRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    // SOURCE:=PROTOCOL
    pObject->State = MRSE_IDLE;
    H245FsmIndication(pPdu, H245_IND_MRSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE1_RequestModeRelease



/*
 *  NAME
 *      MRSE1_TRANSFER_responseF - TRANSFER.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_TRANSFER_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_TRANSFER_response:%d", pObject->Key);

    // Send RequestModeAck PDU to remote peer
    pObject->State = MRSE_IDLE;
	pPdu->u.MSCMg_rspns.u.requestModeAck.sequenceNumber = pObject->byInSequence;
    return sendPDU(pObject->pInstance, pPdu);
} // MRSE1_TRANSFER_response



/*
 *  NAME
 *      MRSE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_REJECT_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_REJECT_request:%d", pObject->Key);

    // Send RequestModeReject PDU to remote
    pObject->State = MRSE_IDLE;
	pPdu->u.MSCMg_rspns.u.requestModeReject.sequenceNumber = pObject->byInSequence;
    return sendPDU(pObject->pInstance, pPdu);
} // MRSE1_REJECT_request

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\muxentry.c ===
/***********************************************************************
 *                                                                     *
 * Filename: muxentry.c                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MUXENTRY.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/MUXENTRY.C_v  $
 *
 *    Rev 1.5   09 Dec 1996 13:34:50   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.4   19 Jul 1996 12:12:46   EHOWARDX
 *
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 *
 *    Rev 1.3   14 Jun 1996 18:58:30   EHOWARDX
 * Geneva Update.
 *
 *    Rev 1.2   04 Jun 1996 13:57:06   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:18   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:34   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.14.1.3   09 May 1996 19:48:36   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.14.1.2   15 Apr 1996 10:46:00   EHOWARDX
 * Update.
 *
 *    Rev 1.14.1.1   10 Apr 1996 21:15:00   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.14.1.0   05 Apr 1996 20:52:56   EHOWARDX
 * Branched.
 *
 *    Rev 1.14   02 Apr 1996 12:01:58   helgebax
 * documented code
 *
 *    Rev 1.13   28 Mar 1996 11:20:52   helgebax
 * removed mux release, fixed return values
 *
 *    Rev 1.12   19 Mar 1996 18:09:46   helgebax
 *
 * removed include file: h245time.h
 *
 *    Rev 1.11   19 Mar 1996 17:31:36   helgebax
 *
 * added new timers
 *
 *    Rev 1.10   13 Mar 1996 11:49:14   helgebax
 * s can also access already deleted objects
 *
 *    Rev 1.9   13 Mar 1996 08:58:46   helgebax
 * No change.
 *
 *    Rev 1.8   11 Mar 1996 14:31:32   helgebax
 * removed prototype def for release function (moved to pdu.x)
 *
 *    Rev 1.7   07 Mar 1996 13:23:12   helgebax
 * changed pObject->pdu_struct to NULL in timerExpiry function because the
 * pdu pointer has been deleted
 *
 *    Rev 1.6   01 Mar 1996 13:22:46   unknown
 *
 * Changed to used pdu_id to save muxentry number so when timeout occurs
 * we can send the correct muxentry number in the MultiplexEntrySendRelease.
 *
 *    Rev 1.5   01 Mar 1996 11:47:56   unknown
 * Since nSequence was removed from header, I have commented out
 * all references to it in the code. Also, state ASSERTs have been
 * changed to reflect the fact that state changes occur BEFORE
 * calling the state function, rather than AFTER.
 *
 *    Rev 1.4   29 Feb 1996 20:57:20   helgebax
 * No change.
 *
 *    Rev 1.3   29 Feb 1996 18:19:46   EHOWARDX
 * Made changes requested by Hani.
 *
 *    Rev 1.2   28 Feb 1996 15:47:04   EHOWARDX
 *
 * First pass MTSE implementation complete.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "muxentry.h"



// Out-going/In-coming MTSE states
#define MTSE_IDLE                   0   // IDLE
#define MTSE_WAIT                   1   // AWAITING_RESPONSE



extern unsigned int uT104;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T104ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T104Expiry);
} // T104ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MTSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE0_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT                       lError;
    unsigned int                  uIndex;
    MultiplexEntryDescriptorLink  pLink;

    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MTSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byMtseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber =
        pObject->pInstance->StateMachine.byMtseOutSequence;

    // Save information for release
    uIndex = 0;
    pLink = pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors;
    while (pLink)
    {
      pObject->u.mtse.multiplexTableEntryNumber.value[uIndex++] =
        pLink->value.multiplexTableEntryNumber;
      pLink = pLink->next;
    }
    pObject->u.mtse.multiplexTableEntryNumber.count = (unsigned short)uIndex;

    // Send MultiplexEntrySend PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T104
    pObject->State = MTSE_WAIT;
    FsmStartTimer(pObject, T104ExpiryF, uT104);

    return lError;
} // MTSE0_TRANSFER_request



/*
 *  NAME
 *      MTSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT                       lError;
    unsigned int                  uIndex;
    MultiplexEntryDescriptorLink  pLink;

    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T104
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byMtseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber =
        pObject->pInstance->StateMachine.byMtseOutSequence;

    // Save information for release
    uIndex = 0;
    pLink = pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors;
    while (pLink)
    {
      pObject->u.mtse.multiplexTableEntryNumber.value[uIndex++] =
        pLink->value.multiplexTableEntryNumber;
      pLink = pLink->next;
    }
    pObject->u.mtse.multiplexTableEntryNumber.count = (unsigned short)uIndex;

    // Send MultiplexEntrySend PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T104
    FsmStartTimer(pObject, T104ExpiryF, uT104);

    return lError;
} // MTSE1_TRANSFER_request



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendAckF - MultiplexEntrySendAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendAckF     (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySendAck:%d", pObject->Key);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber ==
        pObject->pInstance->StateMachine.byMtseOutSequence)
    {
        // Reset timer T104
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = MTSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MTSE1_MultiplexEntrySendAck



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendRejF - MultiplexEntrySendReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendRejF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE0_MultiplexEntrySendRej:%d", pObject->Key);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber ==
        pObject->pInstance->StateMachine.byMtseOutSequence)
    {
        // Reset timer T104
        FsmStopTimer(pObject);

        // Send REJECT.indication to H.245 user
        // CAUSE = MultiplexEntrySendReject.cause
        pObject->State = MTSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, REJECT);
    }

    return 0;
} // MTSE1_MultiplexEntrySendRej



/*
 *  NAME
 *      MTSE1_T104ExpiryF - timer T104 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_T104ExpiryF                (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MTSE1_T104Expiry:%d", pObject->Key);

    // Send MultiplexEntrySendRelease PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MTSE1_T104ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = mltplxEntrySndRls_chosen;
    pOut->u.indication.u.mltplxEntrySndRls = pObject->u.mtse;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send REJECT.indication to H.245 user
    // SOURCE = PROTOCOL
    pObject->State = MTSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
} // MTSE1_T104Expiry

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MTSE0_MultiplexEntrySendF - MultiplexEntrySend received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE0_MultiplexEntrySendF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MTSE0_MultiplexEntrySend:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber;

    // Send TRANSFER.indication to H.245 user
    pObject->State = MTSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MUX_TBL, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE0_MultiplexEntrySend



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendF - MultiplexEntrySend received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySend:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber;

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MTSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send TRANSFER.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MUX_TBL, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE1_MultiplexEntrySend



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendReleaseF - MultiplexEntrySendRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendReleaseF (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySendRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    // SOURCE:=PROTOCOL
    pObject->State = MTSE_IDLE;
    H245FsmIndication(pPdu, H245_IND_MTSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE1_MultiplexEntrySendRelease



/*
 *  NAME
 *      MTSE1_TRANSFER_responseF - TRANSFER.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_TRANSFER_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_TRANSFER_response:%d", pObject->Key);

    // Send MultiplexEntrySendAck PDU to remote peer
    pObject->State = MTSE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // MTSE1_TRANSFER_response



/*
 *  NAME
 *      MTSE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_REJECT_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_REJECT_request:%d", pObject->Key);

    // Send MultiplexEntrySendReject PDU to remote
    pObject->State = MTSE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // MTSE1_REJECT_request

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\mlse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mlse.h                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MLSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MLSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:40:58   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:22   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:52   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.2   15 Apr 1996 10:43:08   EHOWARDX
 * Update.
 * 
 *    Rev 1.1   11 Apr 1996 13:21:10   EHOWARDX
 * Deleted unused function.
 * 
 *    Rev 1.0   10 Apr 1996 21:08:30   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mode (MLSE_OUT) state functions
HRESULT MLSE0_LOOP_requestF             (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopAckF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_T102ExpiryF               (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mode (MLSE_IN) state functions
HRESULT MLSE0_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_LOOP_responseF            (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_IN_RELEASE_requestF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\mstrslv.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mstrslv.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MSTRSLV.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MSTRSLV.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:24   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:54   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.4.1.2   15 Apr 1996 10:43:40   EHOWARDX
 * Update.
 * 
 *    Rev 1.4.1.1   10 Apr 1996 21:08:34   EHOWARDX
 * Deleted No-op functions and moved state definitions to .C file.
 * 
 *    Rev 1.4.1.0   05 Apr 1996 12:14:32   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Master Slave Determination state functions
HRESULT detRequestIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetIdle                       (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetAckOutgoing                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetOutgoing                   (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetRejOutgoing                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetReleaseOutgoing            (Object_t *pObject, PDU_t *pPdu);
HRESULT t106ExpiryOutgoing              (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetAckIncoming                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetIncoming                   (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetRejIncoming                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetReleaseIncoming            (Object_t *pObject, PDU_t *pPdu);
HRESULT t106ExpiryIncoming              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\openu.c ===
/***********************************************************************
 *                                                                     *
 * Filename: openu.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENU.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/OPENU.C_v  $
 *
 *    Rev 1.5   09 Dec 1996 13:36:50   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.4   19 Jul 1996 12:12:02   EHOWARDX
 *
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 *
 *    Rev 1.3   04 Jun 1996 13:56:52   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:20   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   28 May 1996 14:25:24   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:36   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.13.1.2   09 May 1996 19:48:32   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.13.1.1   15 Apr 1996 10:45:26   EHOWARDX
 * Update.
 *
 *    Rev 1.13.1.0   10 Apr 1996 21:14:06   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openu.h"
#include "pdu.x"



// Open Uni-directional Logical Channel Out-going states
#define OpenOutUReleased                 0
#define OpenOutUAwaitingEstablishment    1
#define OpenOutUEstablished              2
#define OpenOutUAwaitingRelease          3



// Open Uni-directional Logical Channel In-coming states
#define OpenInUReleased                  0
#define OpenInUAwaitingEstablishment     1
#define OpenInUEstablished               2



extern unsigned int uT103;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T103ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103Expiry);
} // T103ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      establishReleased - request for open unidirectional channel from API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT establishReleased(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUReleased);
    H245TRACE(pObject->dwInst, 2, "Sending open logical channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingEstablishment;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openAckAwaitingE - received open unidirectional channel Ack in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openAckAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm (SOURCE:=USER) to client */
    pObject->State = OpenOutUEstablished;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openRejAwaitingE - received open unidirectional channel reject in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_OPEN with REJECT to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      releaseAwaitingE - close unidirectional channel in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Close message to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingRelease;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      t103AwaitingE - handle timer T103 expiry
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t103AwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_OPEN with a timer expiry to API; Channel=%d",
              pObject->Key);

    pOut =  MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t103AwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel (source:=lcse) to remote peer */
    pdu_req_close_logical_channel(pOut, (WORD)pObject->Key, 1);
    lError = sendPDU(pObject->pInstance,pOut);
    MemFree(pOut);

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

    return lError;
}



/*
 *  NAME
 *      releaseEstablished - send close channel while in the Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseEstablished(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2, "Send a Close Logical Channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingRelease;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openRejEstablished - received open unidirectional channel reject in Establish state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_OPEN with error B then with REJECT to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenOutUReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(B) to client - not necessary */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_B_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeAckEstablished - received close unidirectional channel Ack in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAckEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_OPEN with error C then with REJECT to API->channel:%d", pObject->Key);

    pObject->State = OpenOutUReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(C) to client - not necessary */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_C_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeAckAwaitingR - received CloseAck/OpenReject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.confirm to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openRejAwaitingR - received open unidirectional channel Reject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    return closeAckAwaitingR(pObject, pPdu);
}



/*
 *  NAME
 *      t103AwaitingR - handle timer expiry for close channel
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t103AwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State  == OpenOutUAwaitingRelease);
    ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with timer expiry to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(NULL, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.confirm to client - not necessary */
    H245FsmConfirm(NULL, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}

/*
 *  NAME
 *      establishAwaitingR - open unidirectional channel request from API in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT establishAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingRelease);
    H245TRACE(pObject->dwInst, 2, "send a (re) Open Channel to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingEstablishment;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

HRESULT openReleased(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUReleased);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* Send ESTABLISH.indication to client */
    pObject->State = OpenInUAwaitingEstablishment;
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeReleased - received close unidirectional channel in Idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeReleased(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUReleased);
    ASSERT(pObject->Key == pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber);
    H245TRACE(pObject->dwInst, 2, "Close Channel received while in Released state; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2, "Send Close Ack; Channel=%d",
              pObject->Key);

    pOut =  MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeReleased: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
}

/*
 *  NAME
 *      responseAwaiting - response to an open in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT responseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenAck to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Ack to remote peer */
    pObject->State = OpenInUEstablished;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      releaseAwaiting - response to open with open reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenReject to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Reject to remote peer */
    pObject->State = OpenInUReleased;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      closeAwaiting - received close unidirectional channel in Awaiting  state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeAwaiting: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInUReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openAwaiting - received an overriding open unidirectional channel while Awaiting establishment
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE, then H245_IND_OPEN to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenInUReleased;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication( NULL, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeEstablished - received close unidirectional channel in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeEstablished(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeEstablished: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to clietn */
    pObject->State = OpenInUReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openEstablished - received overriding open unidirectional channel in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE followed by H245_IND_OPEN to API; Channel=%d",
              pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client - not necessary */
    H245FsmIndication( NULL, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication( pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\openb.c ===
/***********************************************************************
 *                                                                     *
 * Filename: openb.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   openb.c  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 18:05:30  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\openb.c_v $
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openb.h"
#include "pdu.x"



// Open Bi-directional Logical Channel Out-going states
#define OpenOutBReleased                 0
#define OpenOutBAwaitingEstablishment    1
#define OpenOutBEstablished              2
#define OpenOutBAwaitingRelease          3

// Open Bi-directional Logical Channel In-coming states
#define OpenInBReleased                  0
#define OpenInBAwaitingEstablishment     1
#define OpenInBAwaitingConfirmation      2
#define OpenInBEstablished               3



extern unsigned int uT103;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103OutExpiryF - Callback function called by the timer.
 *      T103InExpiryF  - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   obj        pointer to a FSM object
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T103OutExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103OutExpiry);
} // T103OutExpiryF()

int T103InExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103InExpiry);
} // T103InExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      establishReqBReleased - API request to open bidirectional channel in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishReqBReleased(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBReleased);
    H245TRACE(pObject->dwInst, 2,
              "Sending open Bidirectional channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingEstablishment;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openChannelAckBAwaitingE - received open bidirectional channel Ack in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelAckBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm to client */
    pObject->State = OpenOutBEstablished;
    H245FsmConfirm(pPdu,H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, FSM_OK);

    /* Send Open Logical Channel Confirm to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 1,
                  "openChannelAckBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_ind_open_logical_channel_conf(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);
    return lError;
}



/*
 *  NAME
 *      openChannelRejBAwaitingE - received open bidirectional channel reject in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with REJECT to API; Channel=%d",
              pObject->Key);

    /* reset  timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.indication to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      releaseReqBOutAwaitingE - API request to close bidirectional channel in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBOutAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Close (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingRelease;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      t103ExpiryBAwaitingE - handle timeout for  outstanding  open bidirectional pdu
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t103ExpiryBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_NEEDRSP_OPEN  with a timer expiry to API->Channel=%d", pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(NULL, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

    /* Send Close Logical Channel (source:=lcse) to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 1,
                  "t103ExpiryBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_req_close_logical_channel(pOut, (WORD)pObject->Key, 1);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}

/*
 *  NAME
 *      releaseReqBEstablished - API request to close channel in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Bidirectional Channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingRelease;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openChannelRejBEstablished - received open reject in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_NEEDRSP_OPEN with error B then with REJECT to API->Channel=%d", pObject->Key);

    pObject->State = OpenOutBReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(B) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_B_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=B-LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeChannelAckBEstablished - received close ack in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelAckBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with error C then with REJECT to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenOutBReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(C) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_C_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeChannelAckAwaitingR - received close ack in Awaiting Release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.confirm to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(pPdu, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openChannelRejBAwaitingR - received open reject in awaiting release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    return closeChannelAckAwaitingR(pObject, pPdu);
}



/*
 *  NAME
 *      t103ExpiryBAwaitingR - handle timer expiry in awaiting release
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t103ExpiryBAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingRelease);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with timer expiry to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(NULL, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.confirm to client */
#endif

    return 0;
}

/*
 *  NAME
 *      establishReqAwaitingR - API open request in awaiting release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishReqAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "Send a (re) Open Bidirectional Channel to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingEstablishment;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      openChannelBReleased - open channel received in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBReleased(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBReleased);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* Send ESTABLISH.indication to client */
    pObject->State = OpenInBAwaitingEstablishment;
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);
    return 0;
}



/*
 *  NAME
 *      closeChannelBReleased - close channel received in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBReleased (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBReleased);
    ASSERT(pObject->Key == pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber);
    H245TRACE(pObject->dwInst, 2,
              "Close Channel (Bidirectional) received while in Released state; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Ack (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBReleased: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
}

/*
 *  NAME
 *      establishResBAwaitingE - response to an open request    with an ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishResBAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenAck (Bidirectional) to ASN module; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Ack to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenInBAwaitingConfirmation;
    FsmStartTimer(pObject, T103InExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      releaseReqBInAwaitingE - response to an open request with a reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBInAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Send OpenReject (Bidirectional) to SR module; Channel=%d", pObject->Key);

    /* Send Open Logical Channel Reject to remote peer */
    pObject->State = OpenInBReleased;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      closeChannelBAwaitingE - received close channel in Awaiting establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBAwaitingE - overriding open request
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openChannelConfirmBAwaitingE - received open confirm while awaiting establishment
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelConfirmBAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN_CONF with error F to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(F) to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_OPEN_CONF, pObject->pInstance, 0, ERROR_E_INAPPROPRIATE);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "openChannelConfirmBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=B-LCSE) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}



/*
 *  NAME
 *      t103ExpiryBAwaitingC - timer expired waiting for open confirm
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t103ExpiryBAwaitingC(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "Timer T103 expired while waiting for OpenConfirm for OpenAck");

    /* Send ERROR.indication(G) to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(NULL, H245_IND_OPEN_CONF, pObject->pInstance, pObject->dwTransId, ERROR_F_TIMEOUT);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t103ExpiryBAwaitingC: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}

/*
 *  NAME
 *      openChannelConfirmBAwaitingC - received open confirm while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelConfirmBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN_CONF with no errors; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm to client */
    pObject->State = OpenInBEstablished;
    H245FsmIndication(pPdu, H245_IND_OPEN_CONF, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeChannelBAwaitingC - received close channel while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Ack (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBAwaitingC: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBAwaitingC - received open channel while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    pObject->State = OpenInBAwaitingEstablishment;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeChannelBEstablished - received close channel while in established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error up to API; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBEstablished: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBEstablished - received open channel while in established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBEstablished);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

    pObject->State = OpenInBAwaitingEstablishment;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client*/
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\pduparse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: pduparse.c                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   PDUPARSE.C  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/PDUPARSE.C_v  $
 * 
 *    Rev 1.6   09 Dec 1996 13:36:56   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.5   29 Jul 1996 16:58:08   EHOWARDX
 * 
 * Missed some Geneva update PDU types.
 * 
 *    Rev 1.4   05 Jun 1996 17:15:02   EHOWARDX
 * MaintenanceLoop fix.
 * 
 *    Rev 1.3   04 Jun 1996 13:58:06   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   29 May 1996 15:20:24   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:26   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:40   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.8.1.4   09 May 1996 19:48:40   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.8.1.3   25 Apr 1996 17:00:16   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.8.1.2   15 Apr 1996 10:48:00   EHOWARDX
 * Update.
 *
 *    Rev 1.8.1.1   10 Apr 1996 21:15:54   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.8.1.0   05 Apr 1996 20:53:06   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"

/*
 *  NAME
 *      PduParseIncoming - parse an inbound PDU and determine Entity, Event, etc.
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM Instance structure
 *      INPUT   pPdu        Pointer to an incoming PDU structure
 *      OUTPUT  pEntity     Pointer to variable to return PDU state entity in
 *      OUTPUT  pEvent      Pointer to variable to return PDU event in
 *      OUTPUT  pKey        Pointer to variable to return lookup key in
 *      OUTPUT  pbCreate    Pointer to variable to return create flag in
 *
 *  RETURN VALUE
 *      SUCCESS or FAIL
 */


HRESULT
PduParseIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu,
                 Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate)
{
    ASSERT(pInstance != NULL);
    ASSERT(pPdu      != NULL);
    ASSERT(pEntity   != NULL);
    ASSERT(pEvent    != NULL);
    ASSERT(pKey      != NULL);
    ASSERT(pbCreate  != NULL);

    // Set default value for key
    *pKey = 0;

    switch (pPdu->choice)
    {

    ////////////////////////////////////////////////////////////////////
    //
    // REQUEST
    //
    ////////////////////////////////////////////////////////////////////
    case MltmdSystmCntrlMssg_rqst_chosen:
        *pbCreate = TRUE;
        switch (pPdu->u.MltmdSystmCntrlMssg_rqst.choice)
        {
        case RqstMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardRequestPDU;
            break;

        case masterSlaveDetermination_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetPDU;
            break;

        case terminalCapabilitySet_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = TermCapSetPDU;
            break;

        case openLogicalChannel_chosen:
            if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = OpenBChPDU;
            }
            else
            {
                *pEntity    = LCSE_IN;
                *pEvent     = OpenUChPDU;
            }
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;
            break;

        case closeLogicalChannel_chosen:
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = CloseBChPDU;
            }
            else
            {
               *pEntity     = LCSE_IN;
               *pEvent      = CloseUChPDU;
            }
            break;

        case requestChannelClose_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = ReqChClosePDU;
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySend_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MultiplexEntrySendPDU;
            break;

        case requestMultiplexEntry_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RequestMultiplexEntryPDU;
            break;

        case requestMode_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = RequestModePDU;
            break;

        case roundTripDelayRequest_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayRequestPDU;
            break;

        case maintenanceLoopRequest_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MaintenanceLoopRequestPDU;
            switch (pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case communicationModeRequest_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeRequestPDU;
            break;

        case conferenceRequest_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceRequestPDU;
            break;
#if(0) // this is not part of H.245 version 3
        case h223AnnxARcnfgrtn_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigPDU;
            break;
#endif // if (0)
        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Request %d",
                      pPdu->u.MltmdSystmCntrlMssg_rqst.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // RESPONSE
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_rspns_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_rspns.choice)
        {
        case RspnsMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardResponsePDU;
            break;

        case mstrSlvDtrmntnAck_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetAckPDU;
            break;

        case mstrSlvDtrmntnRjct_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetRejectPDU;
            break;

        case terminalCapabilitySetAck_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TermCapSetAckPDU;
            break;

        case trmnlCpbltyStRjct_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TermCapSetRejectPDU;
            break;

        case openLogicalChannelAck_chosen:
            if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = OpenBChAckPDU;
            }
            else
            {
                *pEntity    = LCSE_OUT;
                *pEvent     = OpenUChAckPDU;
            }
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.forwardLogicalChannelNumber;
            break;

        case openLogicalChannelReject_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = OpenBChRejectPDU;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = OpenUChRejectPDU;
            }
            break;

        case closeLogicalChannelAck_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.closeLogicalChannelAck.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = CloseBChAckPDU;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = CloseUChAckPDU;
            }
            break;

        case requestChannelCloseAck_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqChCloseAckPDU;
            *pKey = pPdu->u.MSCMg_rspns.u.requestChannelCloseAck.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRjct_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqChCloseRejectPDU;
            *pKey = pPdu->u.MSCMg_rspns.u.rqstChnnlClsRjct.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySendAck_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MultiplexEntrySendAckPDU;
            break;

        case multiplexEntrySendReject_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MultiplexEntrySendRejectPDU;
            break;

        case requestMultiplexEntryAck_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RequestMultiplexEntryAckPDU;
            break;

        case rqstMltplxEntryRjct_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RequestMultiplexEntryRejectPDU;
            break;

        case requestModeAck_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = RequestModeAckPDU;
            break;

        case requestModeReject_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = RequestModeRejectPDU;
            break;

        case roundTripDelayResponse_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayResponsePDU;
            break;

        case maintenanceLoopAck_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MaintenanceLoopAckPDU;
            switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case maintenanceLoopReject_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MaintenanceLoopRejectPDU;
            switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case cmmnctnMdRspns_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeResponsePDU;
            break;

        case conferenceResponse_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceResponsePDU;
            break;
#if(0) // this is not part of H.245 version 3
        case h223AnnxARcnfgrtnAck_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigAckPDU;
            break;

        case h223AnnxARcnfgrtnRjct_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigRejectPDU;
            break;
#endif // if(0)
        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Response %d",
                      pPdu->u.MSCMg_rspns.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // COMMAND
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_cmmnd_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_cmmnd.choice)
        {
        case CmmndMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardCommandPDU;
            break;

        case mntnncLpOffCmmnd_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MaintenanceLoopOffCommandPDU;
            break;

        case sndTrmnlCpbltySt_chosen:
            *pEntity    = STATELESS;
            *pEvent     = SendTerminalCapabilitySetPDU;
            *pbCreate   = TRUE;
            break;

        case encryptionCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = EncryptionCommandPDU;
            break;

        case flowControlCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FlowControlCommandPDU;
            break;

        case endSessionCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = EndSessionCommandPDU;
            break;

        case miscellaneousCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MiscellaneousCommandPDU;
            break;

        case communicationModeCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeCommandPDU;
            break;

        case conferenceCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceCommandPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Command %d",
                      pPdu->u.MSCMg_cmmnd.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // INDICATION
    //
    ////////////////////////////////////////////////////////////////////
    case indication_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.indication.choice)
        {
        case IndctnMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardIndicationPDU;
            break;

        case functionNotUnderstood_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FunctionNotUnderstoodPDU;
            break;

        case mstrSlvDtrmntnRls_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetReleasePDU;
            break;

        case trmnlCpbltyStRls_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = TermCapSetReleasePDU;
            break;

        case opnLgclChnnlCnfrm_chosen:
            *pEntity    = BLCSE_IN;
            *pEvent     = OpenBChConfirmPDU;
            *pKey = pPdu->u.indication.u.opnLgclChnnlCnfrm.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRls_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = ReqChCloseReleasePDU;
            *pKey = pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber;
            break;

        case mltplxEntrySndRls_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MultiplexEntrySendReleasePDU;
            break;

        case rqstMltplxEntryRls_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RequestMultiplexEntryReleasePDU;
            break;

        case requestModeRelease_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = RequestModeReleasePDU;
            break;

        case miscellaneousIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MiscellaneousIndicationPDU;
            break;

        case jitterIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = JitterIndicationPDU;
            break;

        case h223SkewIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223SkewIndicationPDU;
            break;

        case newATMVCIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NewATMVCIndicationPDU;
            break;

        case userInput_chosen:
            *pEntity    = STATELESS;
            *pEvent     = UserInputIndicationPDU;
            break;

        case h2250MxmmSkwIndctn_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H2250MaximumSkewIndicationPDU;
            break;

        case mcLocationIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MCLocationIndicationPDU;
            break;

        case conferenceIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceIndicationPDU;
            break;

        case vendorIdentification_chosen:
            *pEntity    = STATELESS;
            *pEvent     = VendorIdentificationPDU;
            break;

        case IndicationMessage_functionNotSupported_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FunctionNotSupportedPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Indication %d",
                      pPdu->u.indication.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    default:
        H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Message Type %d",
                  pPdu->choice);
        return H245_ERROR_PARAM;
    } // switch

    return H245_ERROR_OK;
} // PduParseIncoming()



/*
 *  NAME
 *      PduParseOutgoing - parse an outbound PDU and determine Entity, Event, etc.
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM Instance structure
 *      INPUT   pPdu        Pointer to an incoming PDU structure
 *      OUTPUT  pEntity     Pointer to variable to return PDU state entity in
 *      OUTPUT  pEvent      Pointer to variable to return PDU event in
 *      OUTPUT  pKey        Pointer to variable to return lookup key in
 *      OUTPUT  pbCreate    Pointer to variable to return create flag in
 *
 *  RETURN VALUE
 *      SUCCESS or FAIL
 */

HRESULT
PduParseOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu,
                 Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate)
{
    ASSERT(pInstance != NULL);
    ASSERT(pPdu      != NULL);
    ASSERT(pEntity   != NULL);
    ASSERT(pEvent    != NULL);
    ASSERT(pKey      != NULL);
    ASSERT(pbCreate  != NULL);

    // Set default value for key
    *pKey = 0;

    switch (pPdu->choice)
    {

    ////////////////////////////////////////////////////////////////////
    //
    // REQUEST
    //
    ////////////////////////////////////////////////////////////////////
    case MltmdSystmCntrlMssg_rqst_chosen:
        *pbCreate = TRUE;
        switch (pPdu->u.MltmdSystmCntrlMssg_rqst.choice)
        {
        case RqstMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case masterSlaveDetermination_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetReq;
            break;

        case terminalCapabilitySet_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TransferCapRequest;
            break;

        case openLogicalChannel_chosen:
            if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = ReqBEstablish;
            }
            else
            {
                *pEntity    = LCSE_OUT;
                *pEvent     = ReqUEstablish;
            }
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;
            break;

        case closeLogicalChannel_chosen:
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = ReqClsBLCSE;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = ReqURelease;
            }
            break;

        case requestChannelClose_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqClose;
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySend_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MTSE_TRANSFER_request;
            break;

        case requestMultiplexEntry_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RMESE_SEND_request;
            break;

        case requestMode_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = MRSE_TRANSFER_request;
            break;

        case roundTripDelayRequest_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RTDSE_TRANSFER_request;
            break;

        case maintenanceLoopRequest_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MLSE_LOOP_request;
            switch (pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case communicationModeRequest_chosen:
        case conferenceRequest_chosen:
        // case h223AnnxARcnfgrtn_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Request %d",
                      pPdu->u.MltmdSystmCntrlMssg_rqst.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // RESPONSE
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_rspns_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_rspns.choice)
        {
        case RspnsMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

#if 0
        // Master Slave Determination Ack is generated by State Machine only
        case mstrSlvDtrmntnAck_chosen:
            *pEntity    = MSDSE;
            break;

        // Master Slave Determination Reject is generated by State Machine only
        case mstrSlvDtrmntnRjct_chosen:
            *pEntity    = MSDSE;
            break;
#endif

        case terminalCapabilitySetAck_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = CESE_TRANSFER_response;
            break;

        case trmnlCpbltyStRjct_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = CESE_REJECT_request;
            break;

        case openLogicalChannelAck_chosen:
            if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = ResponseBEstablish;
            }
            else
            {
                *pEntity    = LCSE_IN;
                *pEvent     = ResponseUEstablish;
            }
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.forwardLogicalChannelNumber;
            break;

        case openLogicalChannelReject_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = OpenRejectBLCSE;
            }
            else
            {
               *pEntity     = LCSE_IN;
               *pEvent      = EstablishUReject;
            }
            break;

#if 0
        // Close Logical Channel Ack is generated by State Machine only
        case closeLogicalChannelAck_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.closeLogicalChannelAck.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
            }
            else
            {
               *pEntity     = LCSE_IN;
            }
            break;
#endif

        case requestChannelCloseAck_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = CLCSE_CLOSE_response;
            *pKey = pPdu->u.MSCMg_rspns.u.requestChannelCloseAck.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRjct_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = CLCSE_REJECT_request;
            *pKey = pPdu->u.MSCMg_rspns.u.rqstChnnlClsRjct.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySendAck_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MTSE_TRANSFER_response;
            break;

        case multiplexEntrySendReject_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MTSE_REJECT_request;
            break;

        case requestMultiplexEntryAck_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RMESE_SEND_response;
            break;

        case rqstMltplxEntryRjct_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RMESE_REJECT_request;
            break;

        case requestModeAck_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = MRSE_TRANSFER_response;
            break;

        case requestModeReject_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = MRSE_REJECT_request;
            break;

#if 0
        // Round Trip Delay Response sent by State Machine only
        case roundTripDelayResponse_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayResponse;
            break;
#endif

        case maintenanceLoopAck_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MLSE_LOOP_response;
            // Caveat: Channel number must be zero if system loop!
            *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
            break;

        case maintenanceLoopReject_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MLSE_IN_RELEASE_request;
            // Caveat: Channel number must be zero if system loop!
            *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
            break;

        case cmmnctnMdRspns_chosen:
        case conferenceResponse_chosen:
//        case h223AnnxARcnfgrtnAck_chosen:
//        case h223AnnxARcnfgrtnRjct_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Response %d",
                      pPdu->u.MSCMg_rspns.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // COMMAND
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_cmmnd_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_cmmnd.choice)
        {
        case CmmndMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case mntnncLpOffCmmnd_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MLSE_OUT_RELEASE_request;
            break;

        case sndTrmnlCpbltySt_chosen:
        case encryptionCommand_chosen:
        case flowControlCommand_chosen:
        case endSessionCommand_chosen:
        case miscellaneousCommand_chosen:
        case communicationModeCommand_chosen:
        case conferenceCommand_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Command %d",
                      pPdu->u.MSCMg_cmmnd.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // INDICATION
    //
    ////////////////////////////////////////////////////////////////////
    case indication_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.indication.choice)
        {
        case IndctnMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case functionNotUnderstood_chosen:
            *pEntity    = STATELESS;
            break;

#if 0
        // Master Slave Determination Release is sent by State Machine Only
        case mstrSlvDtrmntnRls_chosen:
            *pEntity    = MSDSE;
            break;

       // Terminal Capability Set Release is sent by State Machine Only
        case trmnlCpbltyStRls_chosen:
            *pEntity    = CESE_OUT
            break;
#endif

        case opnLgclChnnlCnfrm_chosen:
            *pEntity    = BLCSE_OUT;
            *pEvent     = RspConfirmBLCSE;
            *pKey = pPdu->u.indication.u.opnLgclChnnlCnfrm.forwardLogicalChannelNumber;
            break;

#if 0
        // Request Channel Close Release is sent by State Machine Only
        case rqstChnnlClsRls_chosen:
            *pEntity    = CLCSE_OUT;
            *pKey = pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber;
            break;

        // Multiplex Entry Send Release is sent by State Machine Only
        case mltplxEntrySndRls_chosen:
            *pEntity    = MTSE_OUT;
            break;

        // Request Multiplex Entry Release is sent by State Machine Only
        case rqstMltplxEntryRls_chosen:
            *pEntity    = RMESE_OUT;
            break;

        // Request Mode Release is sent by State Machine Only
        case requestModeRelease_chosen:
            *pEntity    = MRSE_OUT;
            break;
#endif

        case miscellaneousIndication_chosen:
        case jitterIndication_chosen:
        case h223SkewIndication_chosen:
        case newATMVCIndication_chosen:
        case userInput_chosen:
        case h2250MxmmSkwIndctn_chosen:
        case mcLocationIndication_chosen:
        case conferenceIndication_chosen:
        case vendorIdentification_chosen:
        case IndicationMessage_functionNotSupported_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Indication %d",
                      pPdu->u.indication.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    default:
        H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Message Type %d",
                  pPdu->choice);
        return H245_ERROR_PARAM;
    } // switch

    return H245_ERROR_OK;
} // PduParseOutgoing()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\pdu.c ===
/***************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 *  $Workfile:   pdu.c  $
 *  $Revision:   1.13  $
 *  $Modtime:   27 Jan 1997 12:33:26  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/pdu.c_v  $
 *
 *    Rev 1.13   27 Jan 1997 12:40:28   MANDREWS
 *
 * Fixed warnings.
 *
 *    Rev 1.12   28 Aug 1996 11:37:26   EHOWARDX
 * const changes.
 *
 *    Rev 1.11   19 Aug 1996 15:38:36   EHOWARDX
 * Initialized lResult to H245_ERROR_OK in SetupCommModeEntry().
 *
 *    Rev 1.10   15 Aug 1996 15:20:34   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 *
 *    Rev 1.9   08 Aug 1996 16:01:56   EHOWARDX
 *
 * Change pdu_rsp_mstslv_ack to take either master_chosen or slave_chosen
 * as second parameter.
 *
 *    Rev 1.8   19 Jul 1996 12:14:30   EHOWARDX
 * Eliminated pdu_cmd_misc.
 *
 *    Rev 1.7   09 Jul 1996 17:10:26   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 *
 *    Rev 1.6   14 Jun 1996 18:58:32   EHOWARDX
 * Geneva Update.
 *
 *    Rev 1.5   10 Jun 1996 16:52:24   EHOWARDX
 * Eliminated #include "h245init.x"
 *
 *    Rev 1.4   30 May 1996 23:39:22   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.3   29 May 1996 15:20:22   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.2   28 May 1996 14:25:20   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   13 May 1996 23:16:40   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.0   09 May 1996 21:06:38   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.27   09 May 1996 19:32:46   EHOWARDX
 * Added support for new H.245 fields (e.g. SeparateStack).
 *
 *    Rev 1.26   01 May 1996 19:28:24   EHOWARDX
 * Changed H2250_xxx defines from H2250 address type to H245_xxx defines.
 *
 *    Rev 1.25   27 Apr 1996 21:10:42   EHOWARDX
 * Cleaned up multiplex ack parameter handling.
 *
 *    Rev 1.23.1.5   25 Apr 1996 17:54:34   EHOWARDX
 * Changed wTxPort to dwTxPort in pdu_req_open_logical_channel().
 *
 *    Rev 1.23.1.4   24 Apr 1996 20:51:24   EHOWARDX
 * Added new OpenLogicalChannelAck support.
 *
 *    Rev 1.23.1.3   16 Apr 1996 20:10:58   EHOWARDX
 * Added support for H2250LogicalParameters to OpenLogicalChannel.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:14:20   EHOWARDX
 * Updated Open Logical Channel to match current ASN.1 syntax structure.
 *
 *    Rev 1.23.1.1   02 Apr 1996 22:35:04   EHOWARDX
 * Needed to initialize setupType.choice in H245OpenChannel.
 * (This field is probably soon to be obsolete, but right now
 * the PDU encode rejects it if it is not initialized.
 *
 *    Rev 1.23.1.0   28 Mar 1996 20:17:18   EHOWARDX
 *
 * Changes for new ASN syntax additions.
 *
 *    Rev 1.22   13 Mar 1996 10:12:00   cjutzi
 *
 * - was not puting sequence number in mux_acc or mux_rej
 *
 *    Rev 1.21   12 Mar 1996 15:50:22   cjutzi
 *
 * added EndSession
 *
 *    Rev 1.20   11 Mar 1996 14:04:32   cjutzi
 * - added ind_multiplex_entry_send_release.. back in.. and to the header..
 *
 *    Rev 1.19   08 Mar 1996 14:01:04   cjutzi
 *
 * - added Multiplex Entry stuff
 *
 *    Rev 1.18   06 Mar 1996 08:43:32   cjutzi
 * - fixed constraints on sub element lists, and nesting depth for
 *   mux table pdu build..
 *
 *    Rev 1.17   05 Mar 1996 19:40:04   EHOWARDX
 * Put pdu_ind_multiplex_entry_send_release() and
 * pdu_ind_request_multiplex_entry_release() functions back in after
 * Curt was so kind as to delete them for us.
 *
 *    Rev 1.16   05 Mar 1996 17:33:12   cjutzi
 *
 * - fixed, and imlemented down muxt table entries,
 * - removed bzero/bcopy and fixed free api call
 *
 *    Rev 1.15   02 Mar 1996 22:14:18   DABROWN1
 *
 *    Rev 1.14   28 Feb 1996 19:06:34   unknown
 * Oops! Gotta watch those global replaces... (Changed H245ASSERT
 * back to ASSERT)
 *
 *    Rev 1.13   28 Feb 1996 18:29:34   EHOWARDX
 * Changed ASSERT() to ASSERT().
 *
 *    Rev 1.12   28 Feb 1996 16:08:36   EHOWARDX
 *
 * Changed pTable to WORD pointer.
 *
 *    Rev 1.11   28 Feb 1996 14:01:42   EHOWARDX
 *
 * Added MultiplexEntry functions:
 *   pdu_req_multiplex_entry_send
 *   pdu_rsp_multiplex_entry_send_ack
 *   pdu_rsp_multiplex_entry_send_reject
 *   pdu_ind_multiplex_entry_send_release
 *   pdu_ind_request_multiplex_entry_release
 *
 *    Rev 1.10   26 Feb 1996 17:25:14   cjutzi
 *
 * - implemented MISCCMD command for PDU's
 *
 *    Rev 1.9   26 Feb 1996 09:24:30   cjutzi
 * - removed req_termcqap_set (bit_mask) setup.. moved to main line
 *   code.. rather than the pdu build..
 *
 *    Rev 1.8   22 Feb 1996 12:43:16   unknown
 * Fixed bitmask Open Ack problem
 *
 *    Rev 1.7   21 Feb 1996 14:17:36   unknown
 * No change.
 *
 *    Rev 1.6   15 Feb 1996 10:55:16   cjutzi
 *
 * - fixed open pdu problem bit-mask
 * - changed interface for MUX_T
 *
 *    Rev 1.5   13 Feb 1996 14:39:48   DABROWN1
 * Removed SPOX dependent include files from mainline
 *
 *    Rev 1.4   13 Feb 1996 13:27:04   cjutzi
 * - fixed a problem w/ open channel
 *
 *    Rev 1.3   09 Feb 1996 15:49:48   cjutzi
 *
 * - added dollar log to header.
 * - changed bitmask on open.. hadn't set forward open parameters to present..
 *
 ***************************************************************************/
#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245asn1.h"                   /* must be included before H245api.h */
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "api_util.x"	                /* for free_mux_desc_list */
#include "pdu.x"



HRESULT
SetupUnicastAddress (UnicastAddress                  *pOut,
                     const H245_TRANSPORT_ADDRESS_T  *pIn)
{
  switch (pIn->type)
  {
  case H245_IP_UNICAST:
    pOut->choice = UnicastAddress_iPAddress_chosen;
    pOut->u.UnicastAddress_iPAddress.network.length = 4;
    memcpy(pOut->u.UnicastAddress_iPAddress.network.value, pIn->u.ip.network, 4);
    pOut->u.UnicastAddress_iPAddress.tsapIdentifier = pIn->u.ip.tsapIdentifier;
    break;

  case H245_IP6_UNICAST:
    pOut->choice = UncstAddrss_iP6Address_chosen;
    pOut->u.UncstAddrss_iP6Address.network.length = 16;
    memcpy(pOut->u.UncstAddrss_iP6Address.network.value, pIn->u.ip6.network, 16);
    pOut->u.UncstAddrss_iP6Address.tsapIdentifier = pIn->u.ip6.tsapIdentifier;
    break;

  case H245_IPSSR_UNICAST:
    pOut->choice = iPSourceRouteAddress_chosen;
    pOut->u.iPSourceRouteAddress.routing.choice = strict_chosen;
    pOut->u.iPSourceRouteAddress.network.length = 4;
    memcpy(pOut->u.iPSourceRouteAddress.network.value, pIn->u.ipSourceRoute.network, 4);
    pOut->u.iPSourceRouteAddress.tsapIdentifier = pIn->u.ipSourceRoute.tsapIdentifier;
    // TBD - handle route
    return H245_ERROR_NOTIMP;
    break;

  case H245_IPLSR_UNICAST:
    pOut->choice = iPSourceRouteAddress_chosen;
    pOut->u.iPSourceRouteAddress.routing.choice = loose_chosen;
    pOut->u.iPSourceRouteAddress.network.length = 4;
    memcpy(pOut->u.iPSourceRouteAddress.network.value, pIn->u.ipSourceRoute.network, 4);
    pOut->u.iPSourceRouteAddress.tsapIdentifier = pIn->u.ipSourceRoute.tsapIdentifier;
    // TBD - handle route
    return H245_ERROR_NOTIMP;
    break;

  case H245_IPX_UNICAST:
    pOut->choice = iPXAddress_chosen;
    pOut->u.iPXAddress.node.length = 6;
    memcpy(pOut->u.iPXAddress.node.value, pIn->u.ipx.node, 6);
    pOut->u.iPXAddress.netnum.length = 4;
    memcpy(pOut->u.iPXAddress.netnum.value, pIn->u.ipx.netnum, 4);
    pOut->u.iPXAddress.tsapIdentifier.length = 2;
    memcpy(pOut->u.iPXAddress.tsapIdentifier.value, pIn->u.ipx.tsapIdentifier, 2);
    break;

  case H245_NETBIOS_UNICAST:
    pOut->choice = netBios_chosen;
    pOut->u.netBios.length = 16;
    memcpy(pOut->u.netBios.value, pIn->u.netBios, 16);
    break;

  default:
	  H245TRACE(0,1,"API:SetupUnicastAddress: invalid address type %d", pIn->type);
    return H245_ERROR_PARAM;
  } // switch

  return H245_ERROR_OK;
} // SetupUnicastAddress()



HRESULT
SetupMulticastAddress (MulticastAddress                *pOut,
                       const H245_TRANSPORT_ADDRESS_T  *pIn)
{
  switch (pIn->type)
  {
  case H245_IP_MULTICAST:
    pOut->choice = MltcstAddrss_iPAddress_chosen;
    pOut->u.MltcstAddrss_iPAddress.network.length = 4;
    memcpy(pOut->u.MltcstAddrss_iPAddress.network.value, pIn->u.ip.network, 4);
    pOut->u.MltcstAddrss_iPAddress.tsapIdentifier = pIn->u.ip.tsapIdentifier;
    break;

  case H245_IP6_MULTICAST:
    pOut->choice = MltcstAddrss_iP6Address_chosen;
    pOut->u.MltcstAddrss_iP6Address.network.length = 16;
    memcpy(pOut->u.MltcstAddrss_iP6Address.network.value, pIn->u.ip6.network, 16);
    pOut->u.MltcstAddrss_iP6Address.tsapIdentifier = pIn->u.ip6.tsapIdentifier;
    break;

  default:
    H245TRACE(0,1,"API:SetupMulticastAddress: invalid address type %d", pIn->type);
    return H245_ERROR_PARAM;
  } // switch

  return H245_ERROR_OK;
} // SetupMulticastAddress()



HRESULT
SetupTransportAddress ( H245TransportAddress               *pOut,
                        const H245_TRANSPORT_ADDRESS_T *pIn)
{
  if (pIn->type & 1)
  {
    pOut->choice = unicastAddress_chosen;
    return SetupUnicastAddress(&pOut->u.unicastAddress, pIn);
  }
  else
  {
    pOut->choice = multicastAddress_chosen;
    return SetupMulticastAddress(&pOut->u.multicastAddress, pIn);
  }
} // SetupTransportAddress()



HRESULT
SetupCommModeEntry    ( CommunicationModeTableEntry        *pOut,
                        const H245_COMM_MODE_ENTRY_T       *pIn)
{
  HRESULT   lResult = H245_ERROR_OK;

  memset(pOut, 0, sizeof(*pOut));
  if (pIn->pNonStandard != NULL)
  {
    pOut->CMTEy_nnStndrd = pIn->pNonStandard;
    pOut->bit_mask |= CMTEy_nnStndrd_present;
  }

  pOut->sessionID = pIn->sessionID;

  if (pIn->associatedSessionIDPresent)
  {
    pOut->CMTEy_assctdSssnID = pIn->associatedSessionID;
    pOut->bit_mask |= CMTEy_assctdSssnID_present;
  }

  if (pIn->terminalLabelPresent)
  {
    pOut->terminalLabel = pIn->terminalLabel;
    pOut->bit_mask |= CommunicationModeTableEntry_terminalLabel_present;
  }

  pOut->sessionDescription.value  = pIn->pSessionDescription;
  pOut->sessionDescription.length = pIn->wSessionDescriptionLength;

  switch (pIn->dataType.ClientType)
  {
  case H245_CLIENT_VID_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_NONSTD");
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_videoData.u.VdCpblty_nonStandard,
                                       &pIn->dataType.Cap.H245Vid_NONSTD);
    pOut->dataType.u.dataType_videoData.choice = VdCpblty_nonStandard_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H261:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H261");
    pOut->dataType.u.dataType_videoData.u.h261VideoCapability = pIn->dataType.Cap.H245Vid_H261;
    pOut->dataType.u.dataType_videoData.choice = h261VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H262:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H262");
    pOut->dataType.u.dataType_videoData.u.h262VideoCapability = pIn->dataType.Cap.H245Vid_H262;
    pOut->dataType.u.dataType_videoData.choice = h262VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H263:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H263");
    pOut->dataType.u.dataType_videoData.u.h263VideoCapability = pIn->dataType.Cap.H245Vid_H263;
    pOut->dataType.u.dataType_videoData.choice = h263VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_IS11172:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_IS11172");
    pOut->dataType.u.dataType_videoData.u.is11172VideoCapability = pIn->dataType.Cap.H245Vid_IS11172;
    pOut->dataType.u.dataType_videoData.choice = is11172VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;

  case H245_CLIENT_AUD_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_NONSTD");
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_audioData.u.AdCpblty_nonStandard,
                                      &pIn->dataType.Cap.H245Aud_NONSTD);
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_nonStandard_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;



    break;
  case H245_CLIENT_AUD_G711_ALAW64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ALAW64");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Alaw64k = pIn->dataType.Cap.H245Aud_G711_ALAW64;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Alaw64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ALAW56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ALAW56");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Alaw56k = pIn->dataType.Cap.H245Aud_G711_ALAW56;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Alaw56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ULAW64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ULAW64");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Ulaw64k = pIn->dataType.Cap.H245Aud_G711_ULAW64;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Ulaw64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ULAW56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ULAW56");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Ulaw56k = pIn->dataType.Cap.H245Aud_G711_ULAW56;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Ulaw56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_64");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_64k = pIn->dataType.Cap.H245Aud_G722_64;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_56");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_56k = pIn->dataType.Cap.H245Aud_G722_56;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_48:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_48");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_48k = pIn->dataType.Cap.H245Aud_G722_48;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_48k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G723:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G723");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g7231 = pIn->dataType.Cap.H245Aud_G723;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g7231_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G728:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G728");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g728 = pIn->dataType.Cap.H245Aud_G728;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g728_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G729:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G729");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g729 = pIn->dataType.Cap.H245Aud_G729;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g729_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_GDSVD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_GDSVD");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g729AnnexA = pIn->dataType.Cap.H245Aud_GDSVD;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g729AnnexA_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_IS11172:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_IS11172");
    pOut->dataType.u.dataType_audioData.u.is11172AudioCapability = pIn->dataType.Cap.H245Aud_IS11172;
    pOut->dataType.u.dataType_audioData.choice = is11172AudioCapability_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_IS13818:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_IS13818");
    pOut->dataType.u.dataType_audioData.u.is13818AudioCapability = pIn->dataType.Cap.H245Aud_IS13818;
    pOut->dataType.u.dataType_audioData.choice = is13818AudioCapability_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;

  case H245_CLIENT_DAT_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_NONSTD");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_NONSTD;
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_nnStndrd,
                                            &pIn->dataType.Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd);
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_nnStndrd_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T120:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T120");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T120;
    if (pIn->dataType.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t120_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_DSMCC:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_DSMCC");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_DSMCC;
    if (pIn->dataType.Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_dsm_cc_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_USERDATA:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_USERDATA");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_USERDATA;
    if (pIn->dataType.Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd,
                                            &pIn->dataType.Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_usrDt_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T84:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T84");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T84;
    if (pIn->dataType.Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd,
                                                  &pIn->dataType.Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t84_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T434:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T434");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T434;
    if (pIn->dataType.Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_T434.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t434_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_H224:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_H224");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_H224;
    if (pIn->dataType.Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_H224.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_h224_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_NLPID:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_NLPID");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_NLPID;
    if (pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
    }
    if (lResult == H245_ERROR_OK && pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length != 0)
    {
      pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value =
        MemAlloc(pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
      if (pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value)
      {
        memcpy(pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value,
                pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.value,
                pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
      }
      else
        lResult = H245_ERROR_NOMEM;
    }
    else
      pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value = NULL;

    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_nlpd_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_DSVD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_DSVD");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_DSMCC;
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_dsvdCntrl_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_H222:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_H222");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_H222;
    if (pIn->dataType.Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd,
                                         &pIn->dataType.Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_an_h222DtPrttnng_chosen ;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  default:
    H245TRACE(0,20,"SetupCommModeEntry: default");
    lResult = H245_ERROR_NOSUP;
  } /* switch */
  if (lResult)
    return lResult;

  if (pIn->mediaChannelPresent)
  {
    lResult = SetupTransportAddress(&pOut->CMTEy_mdChnnl, &pIn->mediaChannel);
    if (lResult)
      return lResult;
    pOut->bit_mask |= CMTEy_mdChnnl_present;
  }

  if (pIn->mediaGuaranteedPresent)
  {
    pOut->CMTEy_mdGrntdDlvry = pIn->mediaGuaranteed;
    pOut->bit_mask |= CMTEy_mdGrntdDlvry_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    lResult = SetupTransportAddress(&pOut->CMTEy_mdCntrlChnnl, &pIn->mediaControlChannel);
    if (lResult)
      return lResult;
    pOut->bit_mask |= CMTEy_mdCntrlChnnl_present;
  }

  if (pIn->mediaControlGuaranteedPresent)
  {
    pOut->CMTEy_mdCntrlGrntdDlvry = pIn->mediaControlGuaranteed;
    pOut->bit_mask |= CMTEy_mdCntrlGrntdDlvry_present;
  }

  return H245_ERROR_OK;
} // SetupCommModeEntry()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   setup_H223_mux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
static HRESULT
setup_H222_mux (H222LogicalChannelParameters         *pOut,
                const H245_H222_LOGICAL_PARAM_T      *pIn)
{
  /* See load_H222_param() for inverse function */
  pOut->bit_mask     = 0;
  pOut->resourceID   = pIn->resourceID;
  pOut->subChannelID = pIn->subChannelID;
  if (pIn->pcr_pidPresent)
  {
    pOut->bit_mask |= pcr_pid_present;
    pOut->pcr_pid = pIn->pcr_pid;
  }
  if (pIn->programDescriptors.length && pIn->programDescriptors.value)
  {
    pOut->bit_mask |= programDescriptors_present;
    pOut->programDescriptors.length = (WORD)pIn->programDescriptors.length;
    pOut->programDescriptors.value  = pIn->programDescriptors.value;
  }
  if (pIn->streamDescriptors.length && pIn->streamDescriptors.value)
  {
    pOut->bit_mask |= streamDescriptors_present;
    pOut->streamDescriptors.length = (WORD)pIn->streamDescriptors.length;
    pOut->streamDescriptors.value  = pIn->streamDescriptors.value;
  }
  return H245_ERROR_OK;
} // setup_H222_mux

static HRESULT
setup_H223_mux (H223LogicalChannelParameters         *pOut,
		            const H245_H223_LOGICAL_PARAM_T      *pIn)
{
  /* See load_H223_param() for inverse function */
  switch (pIn->AlType)
  {
  case H245_H223_AL_NONSTD:
    pOut->adaptationLayerType.u.H223LCPs_aLTp_nnStndrd = pIn->H223_NONSTD;
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_nnStndrd_chosen;
    break;

  case H245_H223_AL_AL1FRAMED:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al1Frmd_chosen;
    break;

  case H245_H223_AL_AL1NOTFRAMED:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al1NtFrmd_chosen;
    break;

  case H245_H223_AL_AL2NOSEQ:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_a2WSNs_1_chosen;
    break;

  case H245_H223_AL_AL2SEQ:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_a2WSNs_2_chosen;
    break;

  case H245_H223_AL_AL3:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al3_chosen;
    pOut->adaptationLayerType.u.H223LCPs_aLTp_al3.controlFieldOctets = pIn->CtlFldOctet;
    pOut->adaptationLayerType.u.H223LCPs_aLTp_al3.sendBufferSize = pIn->SndBufSize;
    break;

  default:
	 H245TRACE(0,1,"API:setup_H223_mux: invalid AlType %d", pIn->AlType);
    return H245_ERROR_PARAM;
  } /* switch */

  /* segmentation flag */
  pOut->segmentableFlag = pIn->SegmentFlag;

  return H245_ERROR_OK;
} // setup_H223_mux

static HRESULT
setup_VGMUX_mux(V76LogicalChannelParameters        *pOut,
                const H245_VGMUX_LOGICAL_PARAM_T   *pIn)
{
  /* See load_VGMUX_param() for inverse function */
  pOut->hdlcParameters.crcLength.choice       = (unsigned short)pIn->crcLength;
  pOut->hdlcParameters.n401                   = pIn->n401;
  pOut->hdlcParameters.loopbackTestProcedure  = pIn->loopbackTestProcedure;
  pOut->suspendResume.choice                  = (unsigned short)pIn->suspendResume;
  pOut->uIH                                   = pIn->uIH;
  pOut->mode.choice                           = (unsigned short)pIn->mode;
  switch (pIn->mode)
  {
  case H245_V76_ERM:
    pOut->mode.u.eRM.windowSize               = pIn->windowSize;
    pOut->mode.u.eRM.recovery.choice          = (unsigned short)pIn->recovery;
    break;

  } // switch
  pOut->v75Parameters.audioHeaderPresent = pIn->audioHeaderPresent;
  return H245_ERROR_OK;
} // setup_VGMUX_mux

static HRESULT
setup_H2250_mux(H2250LogicalChannelParameters  *pOut,
                const H245_H2250_LOGICAL_PARAM_T     *pIn)
{
  /* See load_H2250_param() for inverse function */
  HRESULT                lError = H245_ERROR_OK;

  pOut->bit_mask = 0;

  if (pIn->nonStandardList)
  {
    pOut->H2250LCPs_nnStndrd = pIn->nonStandardList;
    pOut->bit_mask |= H2250LCPs_nnStndrd_present;
  }

  pOut->sessionID = pIn->sessionID;

  if (pIn->associatedSessionIDPresent)
  {
    pOut->H2250LCPs_assctdSssnID = pIn->associatedSessionID;
    pOut->bit_mask |= H2250LCPs_assctdSssnID_present;
  }

  if (pIn->mediaChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCPs_mdChnnl,
                                     &pIn->mediaChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCPs_mdChnnl_present;
      }
    }
  }

  if (pIn->mediaGuaranteedPresent)
  {
    pOut->H2250LCPs_mdGrntdDlvry = pIn->mediaGuaranteed;
    pOut->bit_mask |= H2250LCPs_mdGrntdDlvry_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCPs_mdCntrlChnnl,
                                     &pIn->mediaControlChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCPs_mdCntrlChnnl_present;
      }
    }
  }

  if (pIn->mediaControlGuaranteedPresent)
  {
    pOut->H2250LCPs_mCGDy = pIn->mediaControlGuaranteed;
    pOut->bit_mask |= H2250LCPs_mCGDy_present;
  }

  if (pIn->silenceSuppressionPresent)
  {
    pOut->silenceSuppression = pIn->silenceSuppression;
    pOut->bit_mask |= silenceSuppression_present;
  }

  if (pIn->destinationPresent)
  {
    pOut->destination = pIn->destination;
    pOut->bit_mask |= H2250LogicalChannelParameters_destination_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    pOut->bit_mask |= H2250LCPs_mdCntrlChnnl_present;
    lError = SetupTransportAddress(&pOut->H2250LCPs_mdCntrlChnnl,
                                     &pIn->mediaControlChannel);
  }

  if (pIn->dynamicRTPPayloadTypePresent)
  {
    pOut->H2250LCPs_dRTPPTp = pIn->dynamicRTPPayloadType;
    pOut->bit_mask |= H2250LCPs_dRTPPTp_present;
  }

  if (pIn->h261aVideoPacketization)
  {
    pOut->mediaPacketization.choice = h261aVideoPacketization_chosen;
    pOut->bit_mask |= mediaPacketization_present;
  }

  return lError;
} // setup_H2250_mux

static HRESULT
setup_H2250ACK_mux(H2250LgclChnnlAckPrmtrs             *pOut,
                   const H245_H2250ACK_LOGICAL_PARAM_T *pIn)
{
  /* See load_H2250ACK_param() for inverse function */
  HRESULT                lError = H245_ERROR_OK;

  pOut->bit_mask = 0;

  if (pIn->nonStandardList)
  {
    pOut->H2250LCAPs_nnStndrd = pIn->nonStandardList;
    pOut->bit_mask |= H2250LCAPs_nnStndrd_present;
  }

  if (pIn->sessionIDPresent)
  {
    pOut->sessionID = pIn->sessionID;
    pOut->bit_mask |= sessionID_present;
  }

  if (pIn->mediaChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCAPs_mdChnnl,
                                     &pIn->mediaChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCAPs_mdChnnl_present;
      }
    }
  }

  if (pIn->mediaControlChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCAPs_mdCntrlChnnl,
                                       &pIn->mediaControlChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCAPs_mdCntrlChnnl_present;
      }
    }
  }

  if (pIn->dynamicRTPPayloadTypePresent)
  {
    pOut->H2250LCAPs_dRTPPTp = pIn->dynamicRTPPayloadType;
    pOut->bit_mask |= H2250LCAPs_dRTPPTp_present;
  }

  return lError;
} // setup_H2250ACK_mux



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_open_channel (  PDU_T *         pPdu,
                        WORD            wTxChannel,
                        DWORD           dwTxPort,
                        const H245_TOTCAP_T * pTxMode,
                        const H245_MUX_T    * pTxMux,
                        const H245_TOTCAP_T * pRxMode,
                        const H245_MUX_T    * pRxMux,
                        const H245_ACCESS_T * pSeparateStack)
{
  RequestMessage               *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  struct OpenLogicalChannel    *pPdu_olc = &p_req->u.openLogicalChannel;
  HRESULT                       lError;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = openLogicalChannel_chosen;

  ASSERT(pTxMode);
  ASSERT(pTxMux);

  /* Initialize bit masks to 0 */
  /* --> bit_mask no reverse parameters, no reverse mux table parameters */
  pPdu_olc->bit_mask = 0;
  /* no port number present */
  pPdu_olc->forwardLogicalChannelParameters.bit_mask = 0;
  /* no reverse mulitiplex parameters present    */
  pPdu_olc->OLCl_rLCPs.bit_mask = 0;

  /************************************************************/
  /* SETUP THE CHANNEL INFORMATION (NOT MUX STUFF : SEE BELOW */
  /************************************************************/

  /*************************/
  /* FORWARD CHANNEL STUFF */
  /*************************/

  /* --> forwardLogicalChannelNumber */
  pPdu_olc->forwardLogicalChannelNumber = wTxChannel;

  /* --> forwardLogicalChannelParameters                */
  /*    -->forwardLogicalChannelParameters.bit_mask     */
  /*    -->forwardLogicalChannelParameters.fLCPs_prtNmbr*/

  /*    -->forwardLogicalChannelParameters.dataType     */


  /* if port present .. make it so.. (beam me up scotty) */
  if (dwTxPort != H245_INVALID_PORT_NUMBER)
  {
    pPdu_olc->forwardLogicalChannelParameters.bit_mask |= fLCPs_prtNmbr_present;
    pPdu_olc->forwardLogicalChannelParameters.fLCPs_prtNmbr = (WORD)dwTxPort;
  }

  /* select the data type */
  switch (pTxMode->DataType)
    {
    case H245_DATA_NONSTD:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_nonStandard_chosen;
      break;
    case H245_DATA_NULL:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = nullData_chosen;
      break;
    case H245_DATA_VIDEO:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_videoData_chosen;
      break;
    case H245_DATA_AUDIO:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_audioData_chosen;
      break;
    case H245_DATA_DATA:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_data_chosen;
      break;
    case H245_DATA_ENCRYPT_D:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = encryptionData_chosen;
      return H245_ERROR_NOTIMP;     // TBD
      break;
    default:
	   H245TRACE(0,1,"API:pdu_req_open_channel: invalid TX DataType %d", pTxMode->DataType);
      return H245_ERROR_PARAM;
    } /* switch */

  /* in the DataType.. load the capability */
  lError = load_cap((struct Capability *)&pPdu_olc->forwardLogicalChannelParameters.dataType, pTxMode);
  if (lError != H245_ERROR_OK)
    {
      return lError;
    }

  /********************************/
  /* FORWARD MUX H223 PARAM STUFF */
  /********************************/

  /* set forward parameters choices */
  /*    -->forwardLogicalChannelParameters.multiplexParameters.choice                   */
  /*    -->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs     */
  switch (pTxMux->Kind)
  {
  case H245_H222:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h222LCPs_chosen;
    lError = setup_H222_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs,
                             &pTxMux->u.H222);
    break;

  case H245_H223:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h223LCPs_chosen;
    lError = setup_H223_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h223LCPs,
                             &pTxMux->u.H223);
    break;

  case H245_VGMUX:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_v76LCPs_chosen;
    lError = setup_VGMUX_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_v76LCPs,
                              &pTxMux->u.VGMUX);
    break;

  case H245_H2250:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h2250LCPs_chosen;
    lError = setup_H2250_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h2250LCPs,
                              &pTxMux->u.H2250);
    // TBD - Add Network Access Parameters support
    break;

  default:
    H245TRACE(0,1,"API:pdu_req_open_channel: invalid TX Mux Kind %d", pTxMux->Kind);
    lError = H245_ERROR_PARAM;
  } /* switch */
  if (lError != H245_ERROR_OK)
    return lError;

  /*************************/
  /* REVERSE CHANNEL STUFF */
  /*************************/

  if (pRxMode)
    {
      /* --> bit_mask reverse parameters exist !!!! party..down garth..  */
      pPdu_olc->bit_mask |= OLCl_rLCPs_present;
      /*        -->OLCl_rLCPs.dataType  */

      /* select the data type */
      switch (pRxMode->DataType)
        {
        case H245_DATA_NONSTD:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_nonStandard_chosen;
          break;
        case H245_DATA_NULL:
          pPdu_olc->OLCl_rLCPs.dataType.choice = nullData_chosen;
          break;
        case H245_DATA_VIDEO:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_videoData_chosen;
          break;
        case H245_DATA_AUDIO:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_audioData_chosen;
          break;
        case H245_DATA_DATA:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_data_chosen;
          break;
        case H245_DATA_ENCRYPT_D:
          pPdu_olc->OLCl_rLCPs.dataType.choice = encryptionData_chosen;
          return H245_ERROR_NOTIMP;     // TBD
          break;
        default:
	       H245TRACE(0,1,"API:pdu_req_open_channel: invalid RX DataType %d", pRxMode->DataType);
          return H245_ERROR_PARAM;
        } /* switch */

      /* in the DataType.. load the capability */
      lError = load_cap((struct Capability *)&pPdu_olc->OLCl_rLCPs.dataType, pRxMode);
      if (lError != H245_ERROR_OK)
        {
          return lError;
        }

      /********************************/
      /* REVERSE MUX H223 PARAM STUFF */
      /********************************/

      if (pRxMux)
        {
              /* set reverse parameters choices         */
              /*        -->OLCl_rLCPs.dataType          */
              /*        -->OLCl_rLCPs.bit_mask  */
              /* set them to be present.. and it was so */

          switch (pRxMux->Kind)
            {
            case H245_H223:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_h223LCPs_chosen;
              lError = setup_H223_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h223LCPs,
                                        &pRxMux->u.H223);
              break;

            case H245_VGMUX:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_v76LCPs_chosen;
              lError = setup_VGMUX_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_v76LCPs,
                                         &pRxMux->u.VGMUX);
              break;

            case H245_H2250:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_h2250LCPs_chosen;
              lError = setup_H2250_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h2250LCPs,
                                         &pRxMux->u.H2250);
              break;

            default:
              H245TRACE(0,1,"API:pdu_req_open_channel: invalid RX Mux Kind %d", pRxMux->Kind);
              lError = H245_ERROR_PARAM;
            } /* switch */
            if (lError != H245_ERROR_OK)
              return lError;

            pPdu_olc->OLCl_rLCPs.bit_mask |= OLCl_rLCPs_mltplxPrmtrs_present; /* reverse multiplex parameters present */

        } /* if pRxMux */
    } /* if pRxMode */

  if (pSeparateStack)
  {
    pPdu_olc->bit_mask |= OpnLgclChnnl_sprtStck_present;
    pPdu_olc->OpnLgclChnnl_sprtStck = *pSeparateStack;
  }

  return H245_ERROR_OK;
}


//
// Frees PDU and contents used for pdu_req_open_channel()
//
void free_pdu_req_open_channel
(
    PDU_T * pPdu,
    const H245_TOTCAP_T * pTxMode,
    const H245_TOTCAP_T * pRxMode
)
{
    RequestMessage *            p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
    struct OpenLogicalChannel * pPdu_olc = &p_req->u.openLogicalChannel;

    if (pRxMode)
    {
        free_cap((struct Capability *)&pPdu_olc->OLCl_rLCPs.dataType, pRxMode);
    }

    free_cap((struct Capability *)&pPdu_olc->forwardLogicalChannelParameters.dataType, pTxMode);

    // Free PDU pointer
    MemFree(pPdu);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_open_logical_channel_ack (  PDU_T *               pPdu,
				                            WORD                  wRxChannel,
                                    const H245_MUX_T *    pRxMux,
				                            WORD                  wTxChannel,
				                            const H245_MUX_T *    pTxMux, // for H.222/H.225.0 only
                                    DWORD                 dwTxPort,
                                    const H245_ACCESS_T * pSeparateStack)
{
  OpenLogicalChannelAck  *pAck = &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck;
  HRESULT                 lError;

  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = openLogicalChannelAck_chosen;

  pAck->bit_mask = 0;                   // Initialize bit mask

  pAck->forwardLogicalChannelNumber = wRxChannel;

  if (wTxChannel != 0)
  {
    pAck->bit_mask |= OLCAk_rLCPs_present;

    pAck->OLCAk_rLCPs.bit_mask = 0;     // Initialize bit mask
    pAck->OLCAk_rLCPs.reverseLogicalChannelNumber = wTxChannel;
    if (dwTxPort != H245_INVALID_PORT_NUMBER)
    {
      pAck->OLCAk_rLCPs.bit_mask |= rLCPs_prtNmbr_present;
      pAck->OLCAk_rLCPs.rLCPs_prtNmbr = (WORD)dwTxPort;
    }

    if (pTxMux)
    {
      pAck->OLCAk_rLCPs.bit_mask |= OLCAk_rLCPs_mPs_present;
      lError = H245_ERROR_PARAM;
      switch (pTxMux->Kind)
      {
      case H245_H222:
        pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice = rLCPs_mPs_h222LCPs_chosen;
        lError = setup_H222_mux(&pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.rLCPs_mPs_h222LCPs,
                                  &pTxMux->u.H222);
        break;

      case H245_H2250:
        pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice = mPs_h2250LgclChnnlPrmtrs_chosen;
        lError = setup_H2250_mux(&pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.mPs_h2250LgclChnnlPrmtrs,
                                      &pTxMux->u.H2250);
        break;

      } // switch
      if (lError != H245_ERROR_OK)
        return lError;
    } // if
  } // if

  if (pSeparateStack)
  {
    pAck->bit_mask |= OLCAk_sprtStck_present;
    pAck->OLCAk_sprtStck = *pSeparateStack;
  }

  if (pRxMux)
  {
    pAck->bit_mask |= frwrdMltplxAckPrmtrs_present;
    lError = H245_ERROR_PARAM;
    switch (pRxMux->Kind)
    {
    case H245_H2250ACK:
      pAck->frwrdMltplxAckPrmtrs.choice = h2250LgclChnnlAckPrmtrs_chosen;
      lError = setup_H2250ACK_mux(&pAck->frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs,
                                    &pRxMux->u.H2250ACK);
      break;

    } // switch
    if (lError != H245_ERROR_PARAM)
      return lError;
  }

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_open_logical_channel_rej (  PDU_T *         pPdu,
				                            WORD            wRxChannel,
				                            WORD            wCause)
{
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = openLogicalChannelReject_chosen;
  pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber = wRxChannel;
  pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice = wCause;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_ind_open_logical_channel_conf ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  IndicationMessage     *p_ind = &pPdu->u.indication;
  OpenLogicalChannelConfirm *pPdu_olcc = &(p_ind->u.opnLgclChnnlCnfrm);
  p_ind->choice = opnLgclChnnlCnfrm_chosen;

  pPdu->choice = indication_chosen;
  pPdu_olcc->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_request_close_channel(PDU_T *pPdu,
			                        WORD                 wChannel)
{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  RequestChannelClose   *pPdu_rcc = &(p_req->u.requestChannelClose);

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = requestChannelClose_chosen;
  pPdu_rcc->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_close_logical_channel (PDU_T *pPdu,
			                         WORD                wChannel,
			                         DWORD               user_lcse) /* 0=user */
							                                                /* 1=lcse */

{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  CloseLogicalChannel   *pPdu_cc = &(p_req->u.closeLogicalChannel);
  p_req->choice = closeLogicalChannel_chosen;

  pPdu_cc->bit_mask = CloseLogicalChannel_reason_present;
  pPdu_cc->reason.choice = CloseLogicalChannel_reason_reopen_chosen;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_cc->forwardLogicalChannelNumber = wChannel;
  if (user_lcse)
    pPdu_cc->source.choice = lcse_chosen;
  else
    pPdu_cc->source.choice = user_chosen;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_close_logical_channel_ack ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  ResponseMessage       *p_rsp = &pPdu->u.MSCMg_rspns;
  CloseLogicalChannelAck        *pPdu_clca = &(p_rsp->u.closeLogicalChannelAck);

  p_rsp->choice = closeLogicalChannelAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_clca->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_request_channel_close_ack ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  ResponseMessage       *p_rsp = &pPdu->u.MSCMg_rspns;
  RequestChannelCloseAck *pPdu_rcca = &(p_rsp->u.requestChannelCloseAck);
  p_rsp->choice = requestChannelCloseAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_rcca->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_request_channel_close_rej ( PDU_T *pPdu,
				                            WORD                 wChannel,
				                            H245_ACC_REJ_T       acc_rej)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  RequestChannelCloseReject     *pPdu_rccr = &(p_rsp->u.rqstChnnlClsRjct);

  p_rsp->choice = rqstChnnlClsRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_rccr->forwardLogicalChannelNumber = wChannel;
  pPdu_rccr->cause.choice = (WORD)acc_rej;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_mstslv (        PDU_T *                 pPdu,
		                    BYTE                    byTerminalType,
		                    unsigned int            number)
{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  MasterSlaveDetermination      *pPdu_msd = &(p_req->u.masterSlaveDetermination);
  p_req->choice = masterSlaveDetermination_chosen;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_msd->terminalType = byTerminalType;
  pPdu_msd->statusDeterminationNumber = number;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mstslv_rej (PDU_T *pPdu)
{
  ResponseMessage                       *p_rsp = &pPdu->u.MSCMg_rspns;
  MasterSlaveDeterminationReject        *pPdu_msdr = &(p_rsp->u.mstrSlvDtrmntnRjct);

  p_rsp->choice = mstrSlvDtrmntnRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_msdr->cause.choice = identicalNumbers_chosen;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mstslv_ack (    PDU_T *                 pPdu,
                        unsigned short          mst_slv)
{
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = mstrSlvDtrmntnAck_chosen;
  pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice = mst_slv;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_termcap_set (PDU_T *pPdu,
		               WORD                 wSequenceNumber)
{
  RequestMessage *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  TerminalCapabilitySet *pPdu_tcs = &(p_req->u.terminalCapabilitySet);
  p_req->choice = terminalCapabilitySet_chosen;
				
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_tcs->sequenceNumber = (SequenceNumber)wSequenceNumber;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_termcap_set_ack(PDU_T *pPdu,
			                  WORD                 wSequenceNumber)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  TerminalCapabilitySetAck      *pPdu_tcsa = &(p_rsp->u.terminalCapabilitySetAck);

  p_rsp->choice = terminalCapabilitySetAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_tcsa->sequenceNumber = (SequenceNumber)wSequenceNumber;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_termcap_set_rej(PDU_T *pPdu,
			               WORD                 wSequenceNumber,
			               H245_ACC_REJ_T       reason,
			               WORD                 highest_processed)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  TerminalCapabilitySetReject   *pPdu_tcsr = &(p_rsp->u.trmnlCpbltyStRjct);

  p_rsp->choice = trmnlCpbltyStRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_tcsr->sequenceNumber = (SequenceNumber)wSequenceNumber;

  switch (reason)
    {
    case H245_REJ_UNDEF_TBL_ENTRY:
      pPdu_tcsr->cause.choice =  undefinedTableEntryUsed_chosen;
      break;
    case H245_REJ_DIS_CAP_EXCEED:
      pPdu_tcsr->cause.choice = dscrptrCpctyExcdd_chosen;
      break;
    case H245_REJ_TBLENTRY_CAP_EXCEED:
      pPdu_tcsr->cause.choice = tblEntryCpctyExcdd_chosen;

      if (!highest_processed)
	pPdu_tcsr->cause.u.tblEntryCpctyExcdd.choice = noneProcessed_chosen;
      else
	{
	  pPdu_tcsr->cause.u.tblEntryCpctyExcdd.choice = hghstEntryNmbrPrcssd_chosen;
	  pPdu_tcsr->cause.u.tblEntryCpctyExcdd.u.hghstEntryNmbrPrcssd = highest_processed;
	}
      break;
    case H245_REJ:
    default:
      pPdu_tcsr->cause.choice = TCSRt_cs_unspcfd_chosen;
      break;
    }
  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_ind_misc (PDU_T       *pPdu)
{
  IndicationMessage     *p_ind = &pPdu->u.indication;
  MiscellaneousIndication       *p_pdu_misc = &(p_ind->u.miscellaneousIndication);
  p_ind->choice = miscellaneousIndication_chosen;

  pPdu->choice = indication_chosen;
  /* (TBC) */
  return H245_ERROR_NOTIMP;
}




/*****************************************************************************
 *
 * TYPE:        LOCAL
 *
 * PROCEDURE:   build_mux_entry_element - recursivly build mux element list
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
build_mux_entry_element(struct InstanceStruct    *pInstance,
       			         H245_MUX_ENTRY_ELEMENT_T *p_mux_el,
			               MultiplexElement         *p_ASN_mux_el,
			               DWORD			              element_depth)
{
  HRESULT       lError;
  DWORD		max_element_depth = 0;
  DWORD		max_element_width = 0;

  /* check for h223 MAX depth of recursion */
  if (pInstance->Configuration == H245_CONF_H324)
    {
      /* if h223 in basic mode */
      if (pInstance->API.PDU_LocalTermCap.
	    u.MltmdSystmCntrlMssg_rqst.
	      u.terminalCapabilitySet.multiplexCapability.
	        u.h223Capability.
		  h223MultiplexTableCapability.choice == h223MltplxTblCpblty_bsc_chosen)
	{
	  max_element_depth = 1;
	  max_element_width = 2;
	}
      else
      if (pInstance->API.PDU_LocalTermCap.
	    u.MltmdSystmCntrlMssg_rqst.
	      u.terminalCapabilitySet.multiplexCapability.
	        u.h223Capability.
		  h223MultiplexTableCapability.choice == h223MTCy_enhncd_chosen)
	{
	  max_element_depth =
	    pInstance->API.PDU_LocalTermCap.
	      u.MltmdSystmCntrlMssg_rqst.
		u.terminalCapabilitySet.multiplexCapability.
		  u.h223Capability.
		    h223MultiplexTableCapability.u.h223MTCy_enhncd.maximumNestingDepth;
	  max_element_width =
	    pInstance->API.PDU_LocalTermCap.
	      u.MltmdSystmCntrlMssg_rqst.
		u.terminalCapabilitySet.multiplexCapability.
		  u.h223Capability.
		    h223MultiplexTableCapability.u.h223MTCy_enhncd.maximumElementListSize;
	}
    }
  /* nested too deap */
  if (max_element_depth)
    if (element_depth > max_element_depth)
      {
	H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Maximum Depth %d",element_depth );
	return (H245_ERROR_MUXELEMENT_DEPTH);
      }

  ASSERT (p_mux_el);

  /* if logical channel number (termination of tree branch) */
  if (p_mux_el->Kind == H245_MUX_LOGICAL_CHANNEL)
    {
      p_ASN_mux_el->type.choice = typ_logicalChannelNumber_chosen;

      /* invalid channel number .. 0 is command channel */
      // 3/7/96 - cjutzi removed.. looks like they use it in the examples
      //
      //if (p_mux_el->u.wChannel == 0)
      //	{
      //	  H245TRACE(Inst,1,"API:build_mux_entry_element: << ERROR >> Channel 0 not allowed if format");
      //	  return H245_ERROR_INVALID_DATA_FORMAT;
      //	}

      p_ASN_mux_el->type.u.typ_logicalChannelNumber = (WORD)p_mux_el->u.Channel;
    }
  /* else it is a sub element list again.. */
  else
    {
      MultiplexElementLink 	        p_ASN_mux_link;
      H245_MUX_ENTRY_ELEMENT_T 	       *p_mux_el_look;

      /* allocate a new sub element list structure */

      p_ASN_mux_link = (MultiplexElementLink)MemAlloc(sizeof(*p_ASN_mux_link));
      if (p_ASN_mux_link == NULL)
	{
	  return H245_ERROR_NOMEM;
	}

      /* zero memory out */
      memset (p_ASN_mux_link, 0, sizeof (*p_ASN_mux_link));

      /* for every entry  entry present.. */
      for (p_ASN_mux_link->count = 0, p_mux_el_look = p_mux_el->u.pMuxTblEntryElem;
	   p_mux_el_look;
	   p_mux_el_look = p_mux_el_look->pNext, p_ASN_mux_link->count++)
	{
	  /* check.. for api mistakes.. ie.. pointer is really a channel # */
	
	  if ((DWORD_PTR)p_mux_el_look < (DWORD)128)
	    {
	      H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << WARNING >> Possible H245_MUX_LOGICAL_CHANNEL labeled as pointer.. <<CRASH>>");
	    }

	  if ((lError = build_mux_entry_element (pInstance,
						p_mux_el_look,
						&(p_ASN_mux_link->value[p_ASN_mux_link->count]),
						element_depth+1)) != H245_ERROR_OK)
	    {
	      MemFree (p_ASN_mux_link);
	      return lError;
	    }

	} /* for */

      /* must have at least 2 subelements in the list.. if not */
      /* there is an error in the construct.  */
      if (p_ASN_mux_link->count < 2)
	{
	  H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Element List < 2");
	  MemFree (p_ASN_mux_link);
	  return H245_ERROR_INVALID_DATA_FORMAT;
	}

      /* width too wide for MuxLayer*/
      if (max_element_width)
	if (p_ASN_mux_link->count > max_element_width)
	  {
	    H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Maximum Width %d",(p_ASN_mux_link->count));
	    MemFree (p_ASN_mux_link);
	    return H245_ERROR_MUXELEMENT_WIDTH;
	  }

      /* assign to the ASN1 struct for this element */
      p_ASN_mux_el->type.u.subElementList = p_ASN_mux_link;
      p_ASN_mux_el->type.choice = subElementList_chosen;
    }

  /* ok.. deal w/ ASN1 repeat count */
  if (!p_mux_el->RepeatCount)
    p_ASN_mux_el->repeatCount.choice = untilClosingFlag_chosen;
  else
    {
      p_ASN_mux_el->repeatCount.choice = repeatCount_finite_chosen;
      p_ASN_mux_el->repeatCount.u.repeatCount_finite = (WORD)p_mux_el->RepeatCount;
    }

  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_send_mux_table (  struct InstanceStruct * pInstance,
			  PDU_T                 * pPdu,
			  H245_MUX_TABLE_T      * p_mux_table,
			  WORD                    wSequenceNumber,
			  DWORD	                * p_mux_count)
{
  RequestMessage         	       *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  MultiplexEntrySend     	       *pPdu_mes = &(p_req->u.multiplexEntrySend);
  MultiplexEntryDescriptorLink	        p_ASN_med_link = NULL;
  MultiplexEntryDescriptorLink	        p_ASN_med_link_lst = NULL;
  //H245_MUX_ENTRY_DESC_T		*p_mux_desc;

  /* setup pdu choices */
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = multiplexEntrySend_chosen;

  pPdu_mes->sequenceNumber = (SequenceNumber)wSequenceNumber;
  pPdu_mes->multiplexEntryDescriptors = NULL;

  /* must have mux table structure */
  if (!p_mux_table)
    return H245_ERROR_PARAM;

  /* for each descriptor in the table.. */
  /* make sure there are only max of 15 */
  /* and that the numbers range 1-15	*/

  for (*p_mux_count = 0;
       p_mux_table && (*p_mux_count < 16);
       p_mux_table = p_mux_table->pNext,*p_mux_count = (*p_mux_count)+1)
    {
      /* allocate a new multiplex Entry Descriptor */
      p_ASN_med_link = (MultiplexEntryDescriptorLink)MemAlloc(sizeof(*p_ASN_med_link));
      if (p_ASN_med_link == NULL)
	{
	  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
	  return H245_ERROR_NOMEM;
	}

      /* zero out the structure */
      memset (p_ASN_med_link, 0, sizeof(*p_ASN_med_link));

      /* first multiplex entry descriptor ie. time through */
      /* assign to "->multiplexEntryDescriptors" 	   */
      if (!pPdu_mes->multiplexEntryDescriptors)
	pPdu_mes->multiplexEntryDescriptors = p_ASN_med_link;

      /* every other time.. link it in.. */
      else
	{
	  ASSERT (p_ASN_med_link_lst);
	  p_ASN_med_link_lst->next = p_ASN_med_link;
	}
      /* setup for next time thorugh */
      p_ASN_med_link_lst = p_ASN_med_link;

      /* set the entry number */
      if ((p_mux_table->MuxEntryId > 15) ||
	  (p_mux_table->MuxEntryId < 1))
	{
	  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
	  /* MemFree (p_ASN_med_link); -- will be freed in call abouve since it is already linked in */
	  return H245_ERROR_PARAM;
	}
      p_ASN_med_link->value.multiplexTableEntryNumber = (MultiplexTableEntryNumber)p_mux_table->MuxEntryId;

      /* if entry is present */
      if (p_mux_table->pMuxTblEntryElem)
	{
	  H245_MUX_ENTRY_ELEMENT_T *p_mux_el;
	  DWORD			    error;

	  /* setup so ASN knows entry is present */
	  p_ASN_med_link->value.bit_mask = elementList_present;

	  /* for every entry  entry present.. */
	  for (p_ASN_med_link->value.elementList.count = 0, p_mux_el = p_mux_table->pMuxTblEntryElem;
	       p_mux_el;
	       p_mux_el = p_mux_el->pNext, p_ASN_med_link->value.elementList.count++)
	    {
	      if ((error =
		   build_mux_entry_element (pInstance, p_mux_el,
		    &(p_ASN_med_link->value.elementList.value[p_ASN_med_link->value.elementList.count]),0)) != H245_ERROR_OK)
		{
		  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
		  return error;
		}
	    } /* for */

	} /* if */
      /* else.. not present */
      else
	p_ASN_med_link->value.bit_mask = 0;

    } /* for */

  /* you've got too many mux entries.. no more than 16 .. remember.. */
  if (*p_mux_count >= 16)
    {
      free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
      return H245_ERROR_INVALID_MUXTBLENTRY;
    }
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   pdu_rsp_mux_table_ack -
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 *		- Assume all mux id's are valid.
 *
 * RETURN:
 *		- H245_ERROR_OK if there are acks to send
 *		- H245_CANCELED if you shouldn't send the pdu.. (nothing to do)
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mux_table_ack ( PDU_T *pPdu,
		                  WORD		            wSequenceNumber,
		                  H245_ACC_REJ_MUX_T   acc_rej_mux,
		                  DWORD		            count)
{
  DWORD			 ii;
  WORD	 num_ack = 0;
  ResponseMessage	*p_rsp 	  = &(pPdu->u.MSCMg_rspns);
  MultiplexEntrySendAck *p_mux_ack = &(p_rsp->u.multiplexEntrySendAck);

  pPdu->choice = MSCMg_rspns_chosen;
  p_rsp->choice = multiplexEntrySendAck_chosen;
  p_mux_ack->sequenceNumber = (SequenceNumber)wSequenceNumber;

  for (ii = 0; ii < count; ii++)
    {
      if (acc_rej_mux[ii].AccRej == H245_ACC)
	{
	  p_mux_ack->multiplexTableEntryNumber.value[num_ack] =
	     (MultiplexTableEntryNumber)acc_rej_mux[ii].MuxEntryId;
	  num_ack++;
	}
    }

  p_mux_ack->multiplexTableEntryNumber.count = num_ack;

  if (num_ack)
    return H245_ERROR_OK;
  else
    return H245_ERROR_CANCELED;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   pdu_rsp_mux_table_rej -
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 *		- Assume all mux id's are valid.
 *
 * RETURN:
 *		- H245_ERROR_OK if there are rej to send
 *		- H245_CANCELED if you shouldn't send the pdu.. (nothing to do)
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mux_table_rej ( PDU_T *pPdu,
		                  WORD		            wSequenceNumber,
		                  H245_ACC_REJ_MUX_T   acc_rej_mux,
		                  DWORD		            count)
{
  DWORD			    ii;
  WORD	    num_rej = 0;
  ResponseMessage	   *p_rsp 	  = &(pPdu->u.MSCMg_rspns);
  MultiplexEntrySendReject *p_mux_rej = &(p_rsp->u.multiplexEntrySendReject);

  pPdu->choice = MSCMg_rspns_chosen;
  p_rsp->choice = multiplexEntrySendReject_chosen;

  p_mux_rej->sequenceNumber = (SequenceNumber)wSequenceNumber;

  for (ii = 0; ii < count; ii++)
    {
      if (acc_rej_mux[ii].AccRej != H245_ACC)
	{
	  p_mux_rej->rejectionDescriptions.value[num_rej].multiplexTableEntryNumber =
	    (MultiplexTableEntryNumber)acc_rej_mux[ii].MuxEntryId;

	  switch (acc_rej_mux[ii].AccRej)
	    {
	    case H245_REJ_MUX_COMPLICATED:
	      p_mux_rej->rejectionDescriptions.value[num_rej].cause.choice =
		descriptorTooComplex_chosen;
	      break;

	    case H245_REJ:
	    default:
	      p_mux_rej->rejectionDescriptions.value[num_rej].cause.choice =
		MERDs_cs_unspcfdCs_chosen;
	      break;
	    }
	
	  num_rej++;
	}
    }

  p_mux_rej->rejectionDescriptions.count = num_rej;

  if (num_rej)
    return H245_ERROR_OK;
  else
    return H245_ERROR_CANCELED;
}



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   pdu_cmd_end_session
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_cmd_end_session(PDU_T *         pPdu,
		                H245_ENDSESSION_T       		mode,
		                const H245_NONSTANDARD_PARAMETER_T *p_nonstd)
{
  CommandMessage     *p_cmd = &pPdu->u.MSCMg_cmmnd;
  EndSessionCommand  *p_pdu_endsess = &(p_cmd->u.endSessionCommand);
  p_cmd->choice = endSessionCommand_chosen;
  pPdu->choice = MSCMg_cmmnd_chosen;

  switch (mode)
    {
    case H245_ENDSESSION_DISCONNECT:
      p_pdu_endsess->choice = disconnect_chosen;
      break;
    case H245_ENDSESSION_NONSTD:
      p_pdu_endsess->choice = EndSssnCmmnd_nonStandard_chosen;
      ASSERT(p_nonstd);
      p_pdu_endsess->u.EndSssnCmmnd_nonStandard = *p_nonstd;
      break;
    case H245_ENDSESSION_TELEPHONY:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice =
        EndSessionCommand_gstnOptions_telephonyMode_chosen;
      break;
    case H245_ENDSESSION_V8BIS:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v8bis_chosen;
      break;
    case H245_ENDSESSION_V34DSVD:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice =  v34DSVD_chosen;
      break;
    case H245_ENDSESSION_V34DUPFAX:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v34DuplexFAX_chosen;
      break;
    case H245_ENDSESSION_V34H324:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v34H324_chosen;
      break;
    default:
      return H245_ERROR_NOSUP;
    }
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_ind_usrinpt ( PDU_T *pPdu,
                  const H245_NONSTANDARD_PARAMETER_T *pNonStd,
                  const char *string)
{
  IndicationMessage    *p_ind     = &pPdu->u.indication;
  UserInputIndication  *p_pdu_usr = &p_ind->u.userInput;
  pPdu->choice = indication_chosen;
  p_ind->choice = userInput_chosen;

  /* Must be either one or the other */
  if (pNonStd && string)
    return H245_ERROR_PARAM;

  if (pNonStd)
  {
    p_pdu_usr->choice = UsrInptIndctn_nnStndrd_chosen;
    p_pdu_usr->u.UsrInptIndctn_nnStndrd = *pNonStd;
  }
  else if (string)
  {
    p_pdu_usr->choice = alphanumeric_chosen;
    p_pdu_usr->u.alphanumeric = (char *)string;
  }
  else
    return H245_ERROR_PARAM;

  return H245_ERROR_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\muxentry.h ===
/***********************************************************************
 *                                                                     *
 * Filename: muxentry.h                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MUXENTRY.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MUXENTRY.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:54   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.3.1.2   15 Apr 1996 10:44:00   EHOWARDX
 * Update.
 * 
 *    Rev 1.3.1.1   10 Apr 1996 21:07:32   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.3.1.0   05 Apr 1996 11:48:12   EHOWARDX
 * Branched.
 *
 *    Rev 1.3   29 Feb 1996 20:42:40   helgebax
 * No change.
 *
 *    Rev 1.2   28 Feb 1996 15:54:28   EHOWARDX
 * Completed first pass MTSE implementation.
 *                                                                     *
 ***********************************************************************/

// Out-going Multiplex Table (MTSE_OUT) state functions
HRESULT MTSE0_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendAckF    (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendRejF    (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_T104ExpiryF               (Object_t *pObject, PDU_t *pPdu);

// In-coming Multiplex Table (MTSE_OUT) state functions
HRESULT MTSE0_MultiplexEntrySendF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendReleaseF(Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_TRANSFER_responseF        (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_REJECT_requestF           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\openb.h ===
/***********************************************************************
 *                                                                     *
 * Filename: openb.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENB.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/OPENB.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:42:52   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.4.1.3   09 May 1996 19:42:38   EHOWARDX
 * 
 * Removed gratuitious outgoing waiting for confirm state that was
 * not in the ITI SDLs.
 * 
 *    Rev 1.4.1.2   15 Apr 1996 10:44:10   EHOWARDX
 * Update.
 * 
 *    Rev 1.4.1.1   10 Apr 1996 21:07:14   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.4.1.0   05 Apr 1996 12:14:20   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Open Bi-directional Logical Channel Out-going state functions
HRESULT establishReqBReleased           (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelAckBAwaitingE        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBAwaitingE        (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBOutAwaitingE         (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingE            (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBEstablished          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBEstablished      (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelAckBEstablished     (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelAckAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingR            (Object_t *pObject, PDU_t *pPdu);
HRESULT establishReqAwaitingR           (Object_t *pObject, PDU_t *pPdu);

// Open Bi-directional Logical Channel In-coming state functions
HRESULT openChannelBReleased            (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBReleased           (Object_t *pObject, PDU_t *pPdu);
HRESULT establishResBAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBInAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBAwaitingE           (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelConfirmBAwaitingE    (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingC            (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelConfirmBAwaitingC    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBAwaitingC          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBAwaitingC           (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBEstablished        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBEstablished         (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\openu.h ===
/***********************************************************************
 *                                                                     *
 * Filename: openu.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENU.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/OPENU.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:28   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   15 Apr 1996 10:43:56   EHOWARDX
 * Update.
 * 
 *    Rev 1.6.1.1   10 Apr 1996 21:06:40   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.6.1.0   05 Apr 1996 12:14:26   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Open Uni-directional Logical Channel Out-going state functions
HRESULT establishReleased               (Object_t *pObject, PDU_t *pPdu);
HRESULT openAckAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT t103AwaitingE                   (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseEstablished              (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejEstablished              (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAckEstablished             (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAckAwaitingR               (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejAwaitingR                (Object_t *pObject, PDU_t *pPdu);
HRESULT t103AwaitingR                   (Object_t *pObject, PDU_t *pPdu);
HRESULT establishAwaitingR              (Object_t *pObject, PDU_t *pPdu);

// Open Uni-directional Logical Channel In-coming state functions
HRESULT openReleased                    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeReleased                   (Object_t *pObject, PDU_t *pPdu);
HRESULT responseAwaiting                (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseAwaiting                 (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAwaiting                   (Object_t *pObject, PDU_t *pPdu);
HRESULT openAwaiting                    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeEstablished                (Object_t *pObject, PDU_t *pPdu);
HRESULT openEstablished                 (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\port32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  
//   This source is supplied under the terms of a licence agreement or
//   non-disclosure statement with Intel Corporation and may not be copied
//   nor disclosed except in accordance with the terms of that agreement.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PORT32.H
// Stuff to make porting from Win3.1 to Win32 a little less hellish.
//////////////////////////////////////////////////////////////////////////////
#ifndef PORT32_H
#define PORT32_H


//////////////////////////////////////////////////////////////////////////////
// some convenient, explicit types
//////////////////////////////////////////////////////////////////////////////
typedef short INTEGER_16;
typedef int INTEGER_32;
typedef unsigned short UINTEGER_16;
typedef unsigned int UINTEGER_32;
typedef short BOOLEAN_16;

#ifndef _BASETSD_H_
typedef short INT16;
typedef int INT32;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
#endif

typedef short BOOL16;
	
//////////////////////////////////////////////////////////////////////////////
// macros to make old keywords go away
//////////////////////////////////////////////////////////////////////////////
#define __pascal
#define _pascal
#define _far
#define __far
#define _export
#define __export
#define _huge
#define huge
#define __huge
#define  __segment
#define _HFAR_
#define _loadds
#define __loadds

//////////////////////////////////////////////////////////////////////////////
// other macros that may or may not be handy
//////////////////////////////////////////////////////////////////////////////
#define WRITE OF_WRITE

#define OFFSETOF(lp)        (int) (lp)
#define SELECTOROF

#define GLOBALHANDLE(lp)      GlobalHandle(lp)
#define GLOBALHANDLEFUNC(lp)  GlobalHandle(lp)
#define LOCALHANDLE(lp)       LocalHandle(lp)
#define LOCALHANDLEFUNC(lp)   LocalHandle(lp)


#define _AfxGetPtrFromFarPtr(p)   ((void*)(p))
#define GETWINDOWHINSTANCE(hWnd)  GetWindowLong(hWnd ,GWL_HINSTANCE)
#define GETWINDOWHPARENT(hWnd)    GetWindowLong(hWnd, GWL_HWNDPARENT)
#define GETWINDOWID(hWnd)         GetWindowLong(hWnd, GWL_ID)

#define SETCLASSCURSOR(hWnd,NewVal)  SetClassLong(hWnd ,GCL_HCURSOR,NewVal)

//////////////////////////////////////////////////////////////////////////////
// Name of shared mutex for serializing access to 16-bit data stack
//////////////////////////////////////////////////////////////////////////////
#define STR_DATASTACKMUX "_mux_DataStack"

#endif // PORT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\precomp.h ===
#include <windows.h>
#include <windowsx.h>
#include <winsock2.h>
#include <winreg.h>
#include <oprahcom.h>

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/q931.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.122  $
 *	$Date:   04 Mar 1997 20:59:26  $
 *	$Author:   MANDREWS  $
 *
 *	BCL's revision info:
 *	Revision:   1.99
 *	Date:   19 Nov 1996 14:54:02
 *	Author:   rodellx
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/
// [ ] Add facility ie to FACILITY MSG.
// [ ] Read Q931 Appendix D.

#pragma warning ( disable : 4057 4100 4115 4201 4214 4514 )

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include <stdio.h>

#include <rpc.h>

#include "apierror.h"
#include "isrg.h"
#include "incommon.h"
#include "linkapi.h"

#include "common.h"
#include "q931.h"
#include "utils.h"
#include "hlisten.h"
#include "hcall.h"
#include "q931pdu.h"

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
#include "interop.h"
#include "q931plog.h"
LPInteropLogger Q931Logger;
#endif

#define RECEIVE_BUFFER_SIZE 0x2000
#define HANGUP_TIMEOUT              1000        // 1 second
#define CANCEL_LISTEN_TIMEOUT       5000        // 5 seconds

// variable needed to support ISR debug facility.
#if (ISRDEBUGINFO >= 1)
WORD ghISRInst = 0;
#endif

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif

#define _Unicode(x) L ## x
#define Unicode(x) _Unicode(x)

// global data used by WinSock.
static BOOL bQ931Initialized = FALSE;

static Q931_RECEIVE_PDU_CALLBACK gReceivePDUHookProc = NULL;

static struct
{
    DWORD TempID;
    CC_CONFERENCEID ConferenceID;
    CRITICAL_SECTION Lock;
} ConferenceIDSource;


extern VOID Q931PduInit();

//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
void _FreeSetupASN(Q931_SETUP_ASN *pSetupASN)
{
	ASSERT(pSetupASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pSetupASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pSetupASN->NonStandardData.sData.pOctetString);
		pSetupASN->NonStandardData.sData.pOctetString = NULL;
	}
	if (pSetupASN->VendorInfo.pProductNumber)
	{
		MemFree(pSetupASN->VendorInfo.pProductNumber);
		pSetupASN->VendorInfo.pProductNumber = NULL;
	}
	if (pSetupASN->VendorInfo.pVersionNumber)
	{
		MemFree(pSetupASN->VendorInfo.pVersionNumber);
		pSetupASN->VendorInfo.pVersionNumber = NULL;
	}
	Q931FreeAliasNames(pSetupASN->pCallerAliasList);
	pSetupASN->pCallerAliasList = NULL;
	Q931FreeAliasNames(pSetupASN->pCalleeAliasList);
	pSetupASN->pCalleeAliasList = NULL;
	Q931FreeAliasNames(pSetupASN->pExtraAliasList);
	pSetupASN->pExtraAliasList = NULL;
	Q931FreeAliasItem(pSetupASN->pExtensionAliasItem);
	pSetupASN->pExtensionAliasItem = NULL;
}


void _FreeReleaseCompleteASN(Q931_RELEASE_COMPLETE_ASN *pReleaseCompleteASN)
{
	ASSERT(pReleaseCompleteASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pReleaseCompleteASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pReleaseCompleteASN->NonStandardData.sData.pOctetString);
		pReleaseCompleteASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeFacilityASN(Q931_FACILITY_ASN *pFacilityASN)
{
	ASSERT(pFacilityASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pFacilityASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pFacilityASN->NonStandardData.sData.pOctetString);
		pFacilityASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeProceedingASN(Q931_CALL_PROCEEDING_ASN *pProceedingASN)
{
	ASSERT(pProceedingASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pProceedingASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pProceedingASN->NonStandardData.sData.pOctetString);
		pProceedingASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeAlertingASN(Q931_ALERTING_ASN *pAlertingASN)
{
	ASSERT(pAlertingASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pAlertingASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pAlertingASN->NonStandardData.sData.pOctetString);
		pAlertingASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeConnectASN(Q931_CONNECT_ASN *pConnectASN)
{
	ASSERT(pConnectASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pConnectASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pConnectASN->NonStandardData.sData.pOctetString);
		pConnectASN->NonStandardData.sData.pOctetString = NULL;
	}
	if (pConnectASN->VendorInfo.pProductNumber)
    {
        MemFree(pConnectASN->VendorInfo.pProductNumber);
        pConnectASN->VendorInfo.pProductNumber = NULL;
    }
    if (pConnectASN->VendorInfo.pVersionNumber)
    {
        MemFree(pConnectASN->VendorInfo.pVersionNumber);
        pConnectASN->VendorInfo.pVersionNumber = NULL;
    }
}


void
_ConferenceIDNew(
    CC_CONFERENCEID *pConferenceID)
{
    UUID id;
    int iresult;

    EnterCriticalSection(&(ConferenceIDSource.Lock));

    memset(ConferenceIDSource.ConferenceID.buffer, 0,
        sizeof(ConferenceIDSource.ConferenceID.buffer));
    iresult = UuidCreate(&id);

    if ((iresult == RPC_S_OK) || (iresult ==RPC_S_UUID_LOCAL_ONLY))
    {
        memcpy(ConferenceIDSource.ConferenceID.buffer, &id,
            min(sizeof(ConferenceIDSource.ConferenceID.buffer), sizeof(UUID)));
    }
    else
        ASSERT(0);

    memcpy(pConferenceID->buffer, ConferenceIDSource.ConferenceID.buffer,
        sizeof(pConferenceID->buffer));

    LeaveCriticalSection(&(ConferenceIDSource.Lock));
    return;
}

//====================================================================================
// This function is used internally whenever a function needs to send a PDU.
// Note that before a datalinkSendRequest() is done, the call object is unlocked
// and then subsequently locked after returning.  This is necessary to prevent deadlock
// in MT apps.  Further, it is the responsibility of calling functions to revalidate
// the call object before using it.
//====================================================================================
CS_STATUS
Q931SendMessage(
    P_CALL_OBJECT       pCallObject,
    BYTE*               CodedPtrPDU,
    DWORD               CodedLengthPDU,
    BOOL                bOkToUnlock)
{
    HQ931CALL           hQ931Call;
    DWORD               dwPhysicalId;
    HRESULT             result;

    ASSERT(pCallObject != NULL);
    ASSERT(CodedPtrPDU != NULL);
    ASSERT(CodedLengthPDU != 0);

    hQ931Call    = pCallObject->hQ931Call;
    dwPhysicalId = pCallObject->dwPhysicalId;

    // send the message.
    if (pCallObject->bConnected)
    {
        // Unlock the call object before we call down to Link Layer (if caller said it was ok)
        if(bOkToUnlock)
            CallObjectUnlock(pCallObject);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
        InteropOutput(Q931Logger, (BYTE FAR*)CodedPtrPDU, CodedLengthPDU, Q931LOG_SENT_PDU);
#endif

        result = datalinkSendRequest(dwPhysicalId, CodedPtrPDU, CodedLengthPDU);

        // Now attempt to lock the object again.  Note: higher level funcs must
        // be sure to call CallObjectValidate before assuming they have a valid lock
        if (bOkToUnlock && ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL)))
        {
            ISRERROR(ghISRInst, "CallObjectLock() returned error (object not found).", 0L);
        }

        // Note: if we can't get the lock, perhaps we should pass back a specific return code
        // that higher layers can check for??? For now, they should call CallObjectValidate()
        // before assuming the call object is still good.
        if (FAILED(result))
        {
            ISRERROR(ghISRInst, "datalinkSendRequest() failed", 0L);
            MemFree(CodedPtrPDU);
        }
        return result;
    }

    ISRWARNING(ghISRInst, "Q931SendMessage: message not sent because bConnected is FALSE", 0L);
    MemFree(CodedPtrPDU);
    return CS_OK;
}


//====================================================================================
//====================================================================================
CS_STATUS
Q931RingingInternal(P_CALL_OBJECT pCallObject, WORD wCRV)
{
    CC_ENDPOINTTYPE EndpointType;
    DWORD CodedLengthASN;
    BYTE *CodedPtrASN;
    BINARY_STRING UserUserData;
    DWORD CodedLengthPDU;
    BYTE *CodedPtrPDU;
    HRESULT result = CS_OK;
    int nError = 0;
	HQ931CALL hQ931Call = pCallObject->hQ931Call;

    if (pCallObject->VendorInfoPresent)
        EndpointType.pVendorInfo = &pCallObject->VendorInfo;
    else
        EndpointType.pVendorInfo = NULL;
    EndpointType.bIsTerminal = pCallObject->bIsTerminal;
    EndpointType.bIsGateway = pCallObject->bIsGateway;

    result = Q931AlertingEncodeASN(
        NULL, /* pNonStandardData */
        NULL, /* h245Addr */
        &EndpointType,
        &pCallObject->World,
        &CodedPtrASN,
        &CodedLengthASN,
        &pCallObject->CallIdentifier);

    if (result != CS_OK || CodedLengthASN == 0 || CodedPtrASN == NULL)
    {
        ISRERROR(ghISRInst, "Q931AlertingEncodeASN() failed, nothing to send.", 0L);
        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }
        return (result != CS_OK) ? result : CS_INTERNAL_ERROR;
    }

    UserUserData.length = (WORD)CodedLengthASN;
    UserUserData.ptr = CodedPtrASN;

    result = Q931AlertingEncodePDU(wCRV, &UserUserData, &CodedPtrPDU,
        &CodedLengthPDU);

    if (CodedPtrASN != NULL)
    {
        Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
    }

    if ((result != CS_OK) || (CodedLengthPDU == 0) ||
            (CodedPtrPDU == NULL))
    {
        ISRERROR(ghISRInst, "Q931AlertingEncodePDU() failed, nothing to send.", 0L);
        if (CodedPtrPDU != NULL)
        {
            MemFree(CodedPtrPDU);
        }
        if (result != CS_OK)
        {
            return result;
        }
        return CS_INTERNAL_ERROR;
    }
    else
    {
        result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
        if(CallObjectValidate(hQ931Call) != CS_OK)
            return(CS_INTERNAL_ERROR);

    }
    return result;
}


//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallSetup(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_SETUP_ASN *pSetupASN)
{
    DWORD		result;
	HQ931CALL	hQ931Call;
	HRESULT		Status;

    // if the callstate is anything other than null, ignore...
//    if (pCallObject->bCallState != CALLSTATE_NULL)
//    {
//        return CS_OK;
//    }

	hQ931Call = pCallObject->hQ931Call;

    if (pMessage->CallReference & 0x8000)
    {
        // the message came from the callee, so this should be ignored???
    }
    pMessage->CallReference &= ~(0x8000);    // strip off the high bit.
    pCallObject->wCRV = pMessage->CallReference;

    pCallObject->wGoal = pSetupASN->wGoal;
    pCallObject->bCallerIsMC = pSetupASN->bCallerIsMC;
    pCallObject->wCallType = pSetupASN->wCallType;
    pCallObject->ConferenceID = pSetupASN->ConferenceID;
    pCallObject->CallIdentifier = pSetupASN->CallIdentifier;

    pCallObject->bCallState = CALLSTATE_PRESENT;

    {
        CSS_CALL_INCOMING EventData;
        WCHAR szUnicodeDisplay[CC_MAX_DISPLAY_LENGTH + 1];
        WCHAR szUnicodeCalledPartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];

        EventData.wGoal = pCallObject->wGoal;
        EventData.wCallType = pCallObject->wCallType;
        EventData.bCallerIsMC = pCallObject->bCallerIsMC;
        EventData.ConferenceID = pCallObject->ConferenceID;

        EventData.pSourceAddr = NULL;
        if (pSetupASN->SourceAddrPresent)
        {
            EventData.pSourceAddr = &(pSetupASN->SourceAddr);
        }

        EventData.pCallerAddr = NULL;
        if (pSetupASN->CallerAddrPresent)
        {
            EventData.pCallerAddr = &(pSetupASN->CallerAddr);
        }

        EventData.pCalleeDestAddr = NULL;
        if (pSetupASN->CalleeDestAddrPresent)
        {
            EventData.pCalleeDestAddr = &(pSetupASN->CalleeDestAddr);
        }

        EventData.pLocalAddr = NULL;
        if (pSetupASN->CalleeAddrPresent)
        {
            EventData.pLocalAddr = &(pSetupASN->CalleeAddr);
        }

        if (!(pSetupASN->NonStandardDataPresent) ||
                (pSetupASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pSetupASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pSetupASN->NonStandardData);
        }

        EventData.pCallerAliasList = pSetupASN->pCallerAliasList;
        EventData.pCalleeAliasList = pSetupASN->pCalleeAliasList;
        EventData.pExtraAliasList = pSetupASN->pExtraAliasList;
        EventData.pExtensionAliasItem = pSetupASN->pExtensionAliasItem;
        EventData.CallIdentifier = pSetupASN->CallIdentifier;

        EventData.pszDisplay = NULL;
        if (pMessage->Display.Present && pMessage->Display.Contents)
        {
            MultiByteToWideChar(CP_ACP, 0, (const char *)pMessage->Display.Contents, -1,
                szUnicodeDisplay, sizeof(szUnicodeDisplay) / sizeof(szUnicodeDisplay[0]));
            EventData.pszDisplay = szUnicodeDisplay;
        }

        EventData.pszCalledPartyNumber = NULL;
        if (pMessage->CalledPartyNumber.Present && pMessage->CalledPartyNumber.PartyNumberLength)
        {
            MultiByteToWideChar(CP_ACP, 0, (const char *)pMessage->CalledPartyNumber.PartyNumbers, -1,
                szUnicodeCalledPartyNumber, sizeof(szUnicodeCalledPartyNumber) / sizeof(szUnicodeCalledPartyNumber[0]));
            EventData.pszCalledPartyNumber = szUnicodeCalledPartyNumber;
        }

        EventData.pSourceEndpointType = &(pSetupASN->EndpointType);

        EventData.wCallReference = pMessage->CallReference;

        result = pCallObject->Callback((BYTE)Q931_CALL_INCOMING,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

	Status = CallObjectValidate(hQ931Call);
	if (Status != CS_OK)
		return Status;

    if (result == 0)
    {
        WORD wCRV = (WORD)(pMessage->CallReference | 0x8000);
        HRESULT Status;

        Status = Q931RingingInternal(pCallObject, wCRV);
        if (Status != CS_OK)
        {
            return Status;
        }
        pCallObject->bCallState = CALLSTATE_RECEIVED;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS Status;
    WORD wCRV;

    if (bQ931Initialized == FALSE)
    {
    	ASSERT(FALSE);
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Entering Q931Ringing()...", 0L);

    // need parameter checking...
    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error (object not found).", 0L);
        return CS_BAD_PARAM;
    }

    if (pwCRV != NULL)
    {
        wCRV = *pwCRV;
    }
    else
    {
        wCRV = pCallObject->wCRV;
    }

    Status = Q931RingingInternal(pCallObject, wCRV);
    if (Status != CS_OK)
    {
        return Status;
    }

    pCallObject->bCallState = CALLSTATE_RECEIVED;
    Status = CallObjectUnlock(pCallObject);

    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallProceeding(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_CALL_PROCEEDING_ASN *pProceedingASN)
{
    pCallObject->bCallState = CALLSTATE_OUTGOING;

    Q931StopTimer(pCallObject, Q931_TIMER_303);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallAlerting(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_ALERTING_ASN *pAlertingASN)
{
    DWORD result;

    pCallObject->bCallState = CALLSTATE_DELIVERED;

    if (pAlertingASN != NULL)
    {
        // we could pass h245addr, userinfo, and conferenceid
        // if desired later...
        // (this would be passed in the pAlertingASN field)
    }

    Q931StopTimer(pCallObject, Q931_TIMER_303);
    Q931StartTimer(pCallObject, Q931_TIMER_301);

    result = pCallObject->Callback((BYTE)Q931_CALL_RINGING,
        pCallObject->hQ931Call, pCallObject->dwListenToken,
        pCallObject->dwUserToken, NULL);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallConnect(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_CONNECT_ASN *pConnectASN)
{
    DWORD result;

    if ((pMessage->CallReference & 0x8000) == 0)
    {
        // the message came from the caller, so this should be ignored???
    }
    pMessage->CallReference &= ~(0x8000);    // strip off the high bit.

    pCallObject->ConferenceID = pConnectASN->ConferenceID;

    pCallObject->bCallState = CALLSTATE_ACTIVE;

    {
        CSS_CALL_ACCEPTED EventData;
        WCHAR szUnicodeDisplay[CC_MAX_DISPLAY_LENGTH + 1];

        // populate the event data struct.

        EventData.ConferenceID = pCallObject->ConferenceID;

        if (pCallObject->PeerCallAddrPresent)
        {
            EventData.pCalleeAddr = &(pCallObject->PeerCallAddr);
        }
        else
        {
            EventData.pCalleeAddr = NULL;
        }
        EventData.pLocalAddr = &(pCallObject->LocalAddr);

        EventData.pH245Addr = NULL;
        if (pConnectASN->h245AddrPresent)
        {
            EventData.pH245Addr = &(pConnectASN->h245Addr);
        }

        if (!(pConnectASN->NonStandardDataPresent) ||
                (pConnectASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pConnectASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pConnectASN->NonStandardData);
        }

        EventData.pszDisplay = NULL;
        if (pMessage->Display.Present && pMessage->Display.Contents)
        {
            MultiByteToWideChar(CP_ACP, 0, (const char *)pMessage->Display.Contents, -1,
                szUnicodeDisplay, sizeof(szUnicodeDisplay) / sizeof(szUnicodeDisplay[0]));
            EventData.pszDisplay = szUnicodeDisplay;
        }

        EventData.pDestinationEndpointType = &(pConnectASN->EndpointType);

        EventData.wCallReference = pMessage->CallReference;

        Q931StopTimer(pCallObject, Q931_TIMER_303);
        Q931StopTimer(pCallObject, Q931_TIMER_301);

        result = pCallObject->Callback((BYTE)Q931_CALL_ACCEPTED,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallReleaseComplete(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_RELEASE_COMPLETE_ASN *pReleaseCompleteASN)
{
    DWORD result;
    BYTE bCause = 0;

    if (pMessage && pMessage->Cause.Present &&
            (pMessage->Cause.Length >= 3))
    {
        bCause = (BYTE)(pMessage->Cause.Contents[2] & (~CAUSE_EXT_BIT));
    }

    Q931StopTimer(pCallObject, Q931_TIMER_303);
    Q931StopTimer(pCallObject, Q931_TIMER_301);

    // if this is the callee, or the call has been connected already,
    // then this message should be treated as hangup (not reject).
    if (!(pCallObject->fIsCaller) ||
            (pCallObject->bCallState == CALLSTATE_ACTIVE) ||
            (bCause == CAUSE_VALUE_NORMAL_CLEAR))
    {
        CSS_CALL_REMOTE_HANGUP EventData;

        EventData.bReason = CC_REJECT_NORMAL_CALL_CLEARING;
        pCallObject->bCallState = CALLSTATE_NULL;

        result = pCallObject->Callback((BYTE)Q931_CALL_REMOTE_HANGUP,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }
    else
    {
        CSS_CALL_REJECTED EventData;

        pCallObject->bCallState = CALLSTATE_NULL;

        // populate the event data struct.
        switch (bCause)
        {
            case CAUSE_VALUE_NORMAL_CLEAR:
                EventData.bRejectReason = CC_REJECT_NORMAL_CALL_CLEARING;
                break;
            case CAUSE_VALUE_USER_BUSY:
                EventData.bRejectReason = CC_REJECT_USER_BUSY;
                break;
            case CAUSE_VALUE_SECURITY_DENIED:
                EventData.bRejectReason = CC_REJECT_SECURITY_DENIED;
                break;
            case CAUSE_VALUE_NO_ANSWER:
                EventData.bRejectReason = CC_REJECT_NO_ANSWER;
                break;
            case CAUSE_VALUE_NOT_IMPLEMENTED:
                EventData.bRejectReason = CC_REJECT_NOT_IMPLEMENTED;
                break;
            case CAUSE_VALUE_INVALID_CRV:
                EventData.bRejectReason = CC_REJECT_INVALID_IE_CONTENTS;
                break;
            case CAUSE_VALUE_IE_MISSING:
                EventData.bRejectReason = CC_REJECT_MANDATORY_IE_MISSING;
                break;
            case CAUSE_VALUE_IE_CONTENTS:
                EventData.bRejectReason = CC_REJECT_INVALID_IE_CONTENTS;
                break;
            case CAUSE_VALUE_TIMER_EXPIRED:
                EventData.bRejectReason = CC_REJECT_TIMER_EXPIRED;
                break;
            default:
                EventData.bRejectReason = pReleaseCompleteASN->bReason;
                break;
        }

        EventData.ConferenceID = pCallObject->ConferenceID;

        EventData.pAlternateAddr = NULL;

        if (!(pReleaseCompleteASN->NonStandardDataPresent) ||
                (pReleaseCompleteASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pReleaseCompleteASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pReleaseCompleteASN->NonStandardData);
        }

        result = pCallObject->Callback((BYTE)Q931_CALL_REJECTED,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallFacility(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_FACILITY_ASN *pFacilityASN)
{
    DWORD result;

    // if this is the callee, or the call has been connected already,
    // then this message should be treated as hangup (not reject).
    if (!(pCallObject->fIsCaller) ||
            (pCallObject->bCallState == CALLSTATE_ACTIVE))
    {
        CSS_CALL_REMOTE_HANGUP EventData;

        EventData.bReason = pFacilityASN->bReason;
        pCallObject->bCallState = CALLSTATE_NULL;

        result = pCallObject->Callback((BYTE)Q931_CALL_REMOTE_HANGUP,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }
    else
    {
        CSS_CALL_REJECTED EventData;

        pCallObject->bCallState = CALLSTATE_NULL;

        // populate the event data struct.
        EventData.bRejectReason = pFacilityASN->bReason;

        EventData.ConferenceID = pFacilityASN->ConferenceIDPresent ?
            pFacilityASN->ConferenceID : pCallObject->ConferenceID;

        EventData.pAlternateAddr = &(pFacilityASN->AlternativeAddr);

        if (!(pFacilityASN->NonStandardDataPresent) ||
                (pFacilityASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pFacilityASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pFacilityASN->NonStandardData);
        }

        result = pCallObject->Callback((BYTE)Q931_CALL_REJECTED,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendReleaseCompleteMessage(
    P_CALL_OBJECT pCallObject,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData)
{
    CS_STATUS result = CS_OK;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;

    // since this call is going away, mark the call object for deletion so any other
    // threads attempting to use this object will fail to get a lock on it.
    CallObjectMarkForDelete(hQ931Call);

    if((bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER) ||
            (bRejectReason == CC_REJECT_CALL_FORWARDED) ||
            (bRejectReason == CC_REJECT_ROUTE_TO_MC))
    {
        // send the FACILITY message to the peer to reject the call.
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;
        CC_ADDR AltAddr;

        MakeBinaryADDR(pAlternateAddr, &AltAddr);

        ResultASN = Q931FacilityEncodeASN(pNonStandardData,
            (pAlternateAddr ? &AltAddr : NULL),
            bRejectReason, pConferenceID, NULL, &pCallObject->World,
            &CodedPtrASN, &CodedLengthASN, &pCallObject->CallIdentifier);
        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            ISRERROR(ghISRInst, "Q931FacilityEncodeASN() failed, nothing to send.", 0L);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            result = CS_INTERNAL_ERROR;
        }
        else
        {
            DWORD CodedLengthPDU;
            BYTE *CodedPtrPDU;
            BINARY_STRING UserUserData;
            HRESULT ResultEncode = CS_OK;
            WORD wCRV;
            if (pCallObject->fIsCaller)
            {
                wCRV = (WORD)(pCallObject->wCRV & 0x7FFF);
            }
            else
            {
                wCRV = (WORD)(pCallObject->wCRV | 0x8000);
            }

            UserUserData.length = (WORD)CodedLengthASN;
            UserUserData.ptr = CodedPtrASN;

            ResultEncode = Q931FacilityEncodePDU(wCRV,
                &UserUserData, &CodedPtrPDU, &CodedLengthPDU);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                    (CodedPtrPDU == NULL))
            {
                ISRERROR(ghISRInst, "Q931FacilityEncodePDU() failed, nothing to send.", 0L);
                if (CodedPtrPDU != NULL)
                {
                    MemFree(CodedPtrPDU);
                }
                result = CS_INTERNAL_ERROR;
            }
            else
            {
                result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, FALSE);
            }
        }
    }
    else
    {
        // send the RELEASE COMPLETE message to the peer to reject call.
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;
        BYTE bReasonUU = bRejectReason;
        BYTE *pbReasonUU = &bReasonUU;

        switch (bReasonUU)
        {
            case CC_REJECT_NO_BANDWIDTH:            //noBandwidth_chosen
            case CC_REJECT_GATEKEEPER_RESOURCES:    // gatekeeperResources_chosen
            case CC_REJECT_UNREACHABLE_DESTINATION: // unreachableDestination_chosen
            case CC_REJECT_DESTINATION_REJECTION:   // destinationRejection_chosen
            case CC_REJECT_INVALID_REVISION:        // ReleaseCompleteReason_invalidRevision_chosen
            case CC_REJECT_NO_PERMISSION:           // noPermission_chosen
            case CC_REJECT_UNREACHABLE_GATEKEEPER:  // unreachableGatekeeper_chosen
            case CC_REJECT_GATEWAY_RESOURCES:       // gatewayResources_chosen
            case CC_REJECT_BAD_FORMAT_ADDRESS:      // badFormatAddress_chosen
            case CC_REJECT_ADAPTIVE_BUSY:           // adaptiveBusy_chosen
            case CC_REJECT_IN_CONF:                 // inConf_chosen
            case CC_REJECT_UNDEFINED_REASON:        // ReleaseCompleteReason_undefinedReason_chosen
            case CC_REJECT_INTERNAL_ERROR:          // will be mapped to ReleaseCompleteReason_undefinedReason_chosen
            case CC_REJECT_NORMAL_CALL_CLEARING:    // will be mapped to ReleaseCompleteReason_undefinedReason_chosen
            case CC_REJECT_USER_BUSY:               // will be mapped to inConf_chosen
            case CC_REJECT_CALL_DEFLECTION:         // facilityCallDeflection_chosen
            case CC_REJECT_SECURITY_DENIED:         // securityDenied_chosen

               break;
            default:
                pbReasonUU = NULL;
                break;
        }

        ResultASN = Q931ReleaseCompleteEncodeASN(pNonStandardData,
            pConferenceID, pbReasonUU, &pCallObject->World,
            &CodedPtrASN, &CodedLengthASN, &pCallObject->CallIdentifier);
        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            ISRERROR(ghISRInst, "Q931ReleaseCompleteEncodeASN() failed, nothing to send.", 0L);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            result = CS_INTERNAL_ERROR;
        }
        else
        {
            DWORD CodedLengthPDU;
            BYTE *CodedPtrPDU;
            BINARY_STRING UserUserData;
            HRESULT ResultEncode = CS_OK;
            BYTE bCause = 0;
            BYTE *pbCause = &bCause;
            WORD wCRV;

            if (pCallObject->fIsCaller)
            {
                wCRV = (WORD)(pCallObject->wCRV & 0x7FFF);
            }
            else
            {
                wCRV = (WORD)(pCallObject->wCRV | 0x8000);
            }

            UserUserData.length = (WORD)CodedLengthASN;
            UserUserData.ptr = CodedPtrASN;

            switch (bRejectReason)
            {
                case CC_REJECT_NORMAL_CALL_CLEARING:
                    bCause = CAUSE_VALUE_NORMAL_CLEAR;
                    break;
                case CC_REJECT_USER_BUSY:
                    bCause = CAUSE_VALUE_USER_BUSY;
                    break;
                case CC_REJECT_SECURITY_DENIED:
                    bCause = CAUSE_VALUE_SECURITY_DENIED;
                    break;
                case CC_REJECT_NO_ANSWER:
                    bCause = CAUSE_VALUE_NO_ANSWER;
                    break;
                case CC_REJECT_NOT_IMPLEMENTED:
                    bCause = CAUSE_VALUE_NOT_IMPLEMENTED;
                    break;
                case CC_REJECT_MANDATORY_IE_MISSING:
                    bCause = CAUSE_VALUE_IE_MISSING;
                    break;
                case CC_REJECT_INVALID_IE_CONTENTS:
                    bCause = CAUSE_VALUE_IE_CONTENTS;
                    break;
                case CC_REJECT_TIMER_EXPIRED:
                    bCause = CAUSE_VALUE_TIMER_EXPIRED;
                    break;
                default:
                    pbCause = NULL;
                    break;
            }

            ResultEncode = Q931ReleaseCompleteEncodePDU(wCRV,
                pbCause, &UserUserData,
                &CodedPtrPDU, &CodedLengthPDU);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                    (CodedPtrPDU == NULL))
            {
                ISRERROR(ghISRInst, "Q931ReleaseCompleteEncodePDU() failed, nothing to send.", 0L);
                if (CodedPtrPDU != NULL)
                {
                    MemFree(CodedPtrPDU);
                }
                result = CS_INTERNAL_ERROR;
            }
            else
            {
                result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, FALSE);
            }
        }
    }

    pCallObject->bCallState = CALLSTATE_NULL;

    if (result != CS_OK)
    {
        return result;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendStatusMessage(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    BYTE bCause)
{
    CS_STATUS result = CS_OK;

    DWORD CodedLengthPDU;
    BYTE *CodedPtrPDU;
    HRESULT EncodePDU = CS_OK;
	int nError = 0;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;
    WORD wCRV;
    if (pCallObject->fIsCaller)
    {
        wCRV = (WORD)(pCallObject->wCRV & 0x7FFF);
    }
	else
	{
        wCRV = (WORD)(pCallObject->wCRV | 0x8000);
	}

    EncodePDU = Q931StatusEncodePDU(wCRV, NULL, bCause,
        pCallObject->bCallState, &CodedPtrPDU, &CodedLengthPDU);
    if ((EncodePDU != CS_OK) || (CodedLengthPDU == 0) ||
            (CodedPtrPDU == NULL))
    {
        ISRERROR(ghISRInst, "Q931StatusEncodePDU() failed, nothing to send.", 0L);
        if (CodedPtrPDU != NULL)
        {
            MemFree(CodedPtrPDU);
        }
        result = CS_INTERNAL_ERROR;
    }
    else
    {
        result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
        if(CallObjectValidate(hQ931Call) != CS_OK)
            return(CS_INTERNAL_ERROR);
    }
    return(result);
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData)
{
    CS_STATUS result = CS_OK;

    DWORD CodedLengthASN;
    BYTE *CodedPtrASN;
    HRESULT ResultASN = CS_OK;
    DWORD dwPhysicalId = INVALID_PHYS_ID;
    P_CALL_OBJECT pCallObject = NULL;


    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error", 0L);
        return CS_SUBSYSTEM_FAILURE;
    }
    dwPhysicalId = pCallObject->dwPhysicalId;

    // first build the ASN portion of the message (user to user part)
    ResultASN = Q931ProceedingEncodeASN(
        pNonStandardData,
        NULL,                          // No H245 address.
        pDestinationEndpointType,      // EndpointType information.
		&pCallObject->World,
        &CodedPtrASN,
        &CodedLengthASN,
        &pCallObject->CallIdentifier);

    if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
            (CodedPtrASN == NULL))
    {
        ISRERROR(ghISRInst, "Q931ProceedingEncodeASN() failed, nothing to send.", 0L);

        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }
        result = CS_INTERNAL_ERROR;
    }
    else
    {
        // now build the rest of the message
        DWORD CodedLengthPDU;
        BYTE *CodedPtrPDU;
        BINARY_STRING UserUserData;
        HRESULT ResultEncode = CS_OK;
        WORD wCRV = (WORD)(wCallReference | 0x8000);

        UserUserData.length = (WORD)CodedLengthASN;
        UserUserData.ptr = CodedPtrASN;

        ResultEncode = Q931ProceedingEncodePDU(wCRV,
            &UserUserData, &CodedPtrPDU, &CodedLengthPDU);
        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }
        if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                (CodedPtrPDU == NULL))
        {
            ISRERROR(ghISRInst, "Q931ProceedingEncodePDU() failed, nothing to send.", 0L);
            if (CodedPtrPDU != NULL)
            {
                MemFree(CodedPtrPDU);
            }
            result = CS_INTERNAL_ERROR;
        }
        else
        {
            result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);

						if (CallObjectValidate(hQ931Call) != CS_OK)
							return(CS_INTERNAL_ERROR);
        }
    }
    CallObjectUnlock(pCallObject);
    return(result);
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendPDU(HQ931CALL hQ931Call, BYTE* CodedPtrPDU, DWORD CodedLengthPDU)
{
    CS_STATUS result = CS_OK;
    HRESULT TempResult;
    P_CALL_OBJECT pCallObject = NULL;

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) ||
            (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error", 0L);
        return CS_SUBSYSTEM_FAILURE;
    }


    TempResult = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);

    if (CallObjectValidate(hQ931Call) != CS_OK)
        return(CS_INTERNAL_ERROR);

    if(FAILED(TempResult))
    {
        CSS_CALL_FAILED EventData;
        EventData.error = TempResult;
        if ((pCallObject->bCallState == CALLSTATE_ACTIVE) &&
                (pCallObject->bResolved))
        {
            pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, NULL);
        }
        else
        {
            pCallObject->Callback(Q931_CALL_FAILED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
        }

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
           DWORD dwId = pCallObject->dwPhysicalId;
           if ((pCallObject->bCallState != CALLSTATE_ACTIVE) ||
                   (!pCallObject->bResolved))
           {
               CallObjectDestroy(pCallObject);
               pCallObject = NULL;
           }
           linkLayerShutdown(dwId);
           if (pCallObject)
           {
               pCallObject->bConnected = FALSE;
           }
        }
        return TempResult;
    }
	CallObjectUnlock(pCallObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallStatusEnquiry(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage)
{
    CS_STATUS SendStatus;

    SendStatus = Q931SendStatusMessage(pCallObject, pMessage,
        CAUSE_VALUE_ENQUIRY_RESPONSE);

    return SendStatus;
}

//====================================================================================
//====================================================================================
void
Q931SendComplete(DWORD_PTR instance, HRESULT msg, PBYTE buf, DWORD length)
{
    HQ931CALL hQ931Call = (HQ931CALL)instance;
    P_CALL_OBJECT pCallObject = NULL;

    ISRTRACE(ghISRInst, "Entering Q931SendComplete()...", 0L);

    if (buf != NULL)
    {
        MemFree(buf);
    }

    if (FAILED(msg))
    {
        // shut down link layer; report failure to client
        CSS_CALL_FAILED EventData;

        ISRERROR(ghISRInst, "error in datalinkSendRequest()", 0L);

        if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
        {
            ISRERROR(ghISRInst, "CallObjectLock() returned error", 0L);
            return;
        }

        EventData.error = msg;
        if ((pCallObject->bCallState == CALLSTATE_ACTIVE) &&
                (pCallObject->bResolved))
        {
            pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, NULL);
        }
        else
        {
            pCallObject->Callback(Q931_CALL_FAILED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
        }

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             if ((pCallObject->bCallState != CALLSTATE_ACTIVE) ||
                     (!pCallObject->bResolved))
             {
                 CallObjectDestroy(pCallObject);
                 pCallObject = NULL;
             }
             linkLayerShutdown(dwId);
             if (pCallObject)
             {
                 pCallObject->bConnected = FALSE;
             }
        }
        return;
    }
    return;
}

//====================================================================================
//====================================================================================
static DWORD
PostReceiveBuffer(DWORD dwPhysicalId, BYTE *buf)
{
    if (buf == NULL)
    {
        buf = MemAlloc(RECEIVE_BUFFER_SIZE);
    }
    return datalinkReceiveRequest(dwPhysicalId, buf, RECEIVE_BUFFER_SIZE);
}

//====================================================================================
//====================================================================================
void
OnReceiveCallback(DWORD_PTR instance, HRESULT message, Q931MESSAGE *pMessage, BYTE *buf, DWORD nbytes)
{
    HQ931CALL hQ931Call = (HQ931CALL)instance;
    P_CALL_OBJECT pCallObject = NULL;
    DWORD dwPhysicalId;

    ISRTRACE(ghISRInst, "Entering ReceiveCallback()...", 0L);

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        if (buf)
        {
            MemFree(buf);
        }
        ISRTRACE(ghISRInst, "Call Object no longer available:", (DWORD)hQ931Call);
        return;
    }

    if (message == LINK_RECV_DATA)
    {
        HRESULT Result = CS_OK;

        if ((buf == NULL) || (nbytes == 0))
        {
            ISRERROR(ghISRInst, "Empty buffer received as data.", 0L);
            CallObjectUnlock(pCallObject);
            return;
        }

        // This block is the Q931 call re-connect implementation:
        // if the object related to the incoming message is not yet resolved...
        if (pCallObject->bResolved == FALSE)
        {
            // try to resolve the object.
            HQ931CALL hFoundCallObject;
            P_CALL_OBJECT pFoundCallObject = NULL;

            // If found another object with matching CRV/Addr...
            if (CallObjectFind(&hFoundCallObject, pCallObject->wCRV,
                    &(pCallObject->PeerConnectAddr)) &&
                    ((CallObjectLock(hFoundCallObject, &pFoundCallObject) == CS_OK) &&
                    (pFoundCallObject != NULL)))
            {
                // friendly channel close of the pFoundCallObject.
                Q931SendReleaseCompleteMessage(pFoundCallObject,
                    CC_REJECT_UNDEFINED_REASON, &(pFoundCallObject->ConferenceID), NULL, NULL);

                // unlock the call object before calling shutdown
                CallObjectUnlock(pFoundCallObject);

                linkLayerShutdown(pFoundCallObject->dwPhysicalId);

                if((CallObjectLock(hFoundCallObject, &pFoundCallObject) != CS_OK) ||
                  (pFoundCallObject == NULL))
                  return;

                // assign the new dwPhysicalId to found object.
                pFoundCallObject->dwPhysicalId = pCallObject->dwPhysicalId;

                // new object should be destroyed.
                CallObjectDestroy(pCallObject);
                pCallObject = pFoundCallObject;
            }
            else
            {
                // The call is a newly established call, so resolve it now.
                pCallObject->bResolved = TRUE;
            }
        }

        Result = Q931ParseMessage((BYTE *)buf, nbytes, pMessage);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
        InteropOutput(Q931Logger, buf, nbytes, Q931LOG_RECEIVED_PDU);
#endif

        if (Result != CS_OK)
        {
            Result = Q931SendStatusMessage(pCallObject, pMessage,
                CAUSE_VALUE_INVALID_MSG);

            ISRERROR(ghISRInst, "Q931ParseMessage(): failed.", 0L);

            if(CallObjectValidate(hQ931Call) != CS_OK)
            {
			        if (buf)
			        {
			            MemFree(buf);
			        }
              return;
            }

            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectUnlock(pCallObject);
            PostReceiveBuffer(dwPhysicalId, buf);
            return;
        }

        if (pMessage->Shift.Present)
        {
            ISRERROR(ghISRInst, "Shift present in message:  dropped.", 0L);
            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectUnlock(pCallObject);
            PostReceiveBuffer(dwPhysicalId, buf);
            return;
        }

        // If a hooking procedure has been installed,
        // give it first shot at acting on the received PDU.
        // If it returns TRUE, then processing is finished.
        if (gReceivePDUHookProc)
        {
            BOOL bHookProcessedMessage;

            bHookProcessedMessage = gReceivePDUHookProc(pMessage,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken);

            if (bHookProcessedMessage)
            {
                if (CallObjectValidate(hQ931Call) == CS_OK)
                {
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                }
                return;
            }
        }

        // Message now contains the values of the Q931 PDU elements...
        switch (pMessage->MessageType)
        {
        case SETUPMESSAGETYPE:
            {
                Q931_SETUP_ASN SetupASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Message is missing ASN.1 UserUser data...", 0L);
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                ISRTRACE(ghISRInst, "ReceiveCallback(): received Setup message...", 0L);
                Result = Q931SetupParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &SetupASN);
                if (Result == CS_OPTION_NOT_IMPLEMENTED)
                {
                    //... maybe callback callcont in later drop.

                    // initiate a disconnect sequence from the caller side.
                    if (Q931SendReleaseCompleteMessage(pCallObject,
                            CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) != CS_OK)
                    {
                        // nothing to do if this fails.
                    }

                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectDestroy(pCallObject);
                    linkLayerShutdown(dwPhysicalId);
                    if (buf)
                    {
                        MemFree(buf);
                        buf = NULL;
                    }
                    return;
                }
                if (Result != CS_OK)
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Unable to parse ASN.1 data.", 0L);
                    break;
                }

                // The "CallerAddr is not passed in the PDU, so the
                // only valuable addr to use is the connection addr
                // passed from the link layer and saved into the call
                // object at connect-time.
                SetupASN.CallerAddrPresent = TRUE;
                SetupASN.CallerAddr = pCallObject->PeerConnectAddr;

                // The "CalleeAddr" which is passed in the PDU is ignored
                // by the ASN parser, and supplied by the link layer
                // instead and saved into the call object at connect-time.
                // here, this address is used as the callee addr.
                SetupASN.CalleeAddrPresent = TRUE;
                SetupASN.CalleeAddr = pCallObject->LocalAddr;

                Result = Q931OnCallSetup(pCallObject, pMessage, &SetupASN);

				_FreeSetupASN(&SetupASN);
	        }
            break;
        case RELEASECOMPLMESSAGETYPE:
            {
                Q931_RELEASE_COMPLETE_ASN ReleaseCompleteASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Message is missing ASN.1 UserUser data...", 0L);
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                ISRTRACE(ghISRInst, "ReceiveCallback(): received ReleaseComplete message...", 0L);
                Result = Q931ReleaseCompleteParseASN(&pCallObject->World,
										pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &ReleaseCompleteASN);
                if (Result != CS_OK)
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Unable to parse ASN.1 data.", 0L);
                    break;
                }
                Result = Q931OnCallReleaseComplete(pCallObject, pMessage, &ReleaseCompleteASN);
                if (CallObjectValidate(hQ931Call) == CS_OK)
                {
                     dwPhysicalId = pCallObject->dwPhysicalId;
                     CallObjectDestroy(pCallObject);
                     linkLayerShutdown(dwPhysicalId);
                }
                MemFree(buf);
				_FreeReleaseCompleteASN(&ReleaseCompleteASN);
                return;
            }
            break;
        case FACILITYMESSAGETYPE:
            {
                Q931_FACILITY_ASN FacilityASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Message is missing ASN.1 UserUser data...", 0L);
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                ISRTRACE(ghISRInst, "ReceiveCallback(): received Facility message...", 0L);
                Result = Q931FacilityParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &FacilityASN);
                if (Result != CS_OK)
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Unable to parse ASN.1 data.", 0L);
                    break;
                }

                // initiate a disconnect sequence from the caller side.
                Q931SendReleaseCompleteMessage(pCallObject,
                        CC_REJECT_CALL_DEFLECTION, NULL, NULL, NULL);

                Result = Q931OnCallFacility(pCallObject, pMessage, &FacilityASN);
               	_FreeFacilityASN(&FacilityASN);
                dwPhysicalId = pCallObject->dwPhysicalId;
                CallObjectDestroy(pCallObject);
                linkLayerShutdown(dwPhysicalId);
                MemFree(buf);
                return;
            }
            break;
        case CONNECTMESSAGETYPE:
            {
                Q931_CONNECT_ASN ConnectASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Message is missing ASN.1 UserUser data...", 0L);
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                ISRTRACE(ghISRInst, "ReceiveCallback(): received Connect message...", 0L);
                Result = Q931ConnectParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &ConnectASN);
                if (Result != CS_OK)
                {
                    ISRERROR(ghISRInst, "ReceiveCallback(): Unable to parse ASN.1 data.", 0L);
                    break;
                }
                Result = Q931OnCallConnect(pCallObject, pMessage, &ConnectASN);
				_FreeConnectASN(&ConnectASN);
            }
            break;
        case PROCEEDINGMESSAGETYPE:
            {
                Q931_CALL_PROCEEDING_ASN ProceedingASN;

                ISRTRACE(ghISRInst, "ReceiveCallback(): received Proceeding message...", 0L);
                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Result = Q931OnCallProceeding(pCallObject, pMessage, NULL);
                }
                else
                {
                    Result = Q931ProceedingParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                        pMessage->UserToUser.UserInformationLength, &ProceedingASN);
                    if (Result != CS_OK)
                    {
                        ISRERROR(ghISRInst, "ReceiveCallback(): Unable to parse ASN.1 data.", 0L);
                        break;
                    }
                    Result = Q931OnCallProceeding(pCallObject, pMessage, &ProceedingASN);
					_FreeProceedingASN(&ProceedingASN);
                }
            }
            break;
        case ALERTINGMESSAGETYPE:
            {
                Q931_ALERTING_ASN AlertingASN;

                ISRTRACE(ghISRInst, "ReceiveCallback(): received Alerting message...", 0L);
                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Result = Q931OnCallAlerting(pCallObject, pMessage, NULL);
                }
                else
                {
                    Result = Q931AlertingParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                        pMessage->UserToUser.UserInformationLength, &AlertingASN);
                    if (Result != CS_OK)
                    {
                        ISRERROR(ghISRInst, "ReceiveCallback(): Unable to parse ASN.1 data.", 0L);
                        break;
                    }
                    Result = Q931OnCallAlerting(pCallObject, pMessage, &AlertingASN);
					_FreeAlertingASN(&AlertingASN);
                }
            }
            break;
        case RELEASEMESSAGETYPE:
        case STATUSMESSAGETYPE:
            ISRWARNING(ghISRInst, "ReceiveCallback(): message not yet supported.", 0L);
            break;
        case STATUSENQUIRYMESSAGETYPE:
            ISRWARNING(ghISRInst, "ReceiveCallback(): message not yet supported.", 0L);
            Result = Q931OnCallStatusEnquiry(pCallObject, pMessage);
            break;
        default:
            ISRERROR(ghISRInst, "ReceiveCallback(): unknown message received.", 0L);
            break;
        }

        // re-validate the call object:
        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectUnlock(pCallObject);
            PostReceiveBuffer(dwPhysicalId, buf);
            if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
              return;
        }
        else
        {
            if (buf)
            {
                MemFree(buf);
            }
            return;
        }

        if (Result == CS_INCOMPATIBLE_VERSION)
        {
            // initiate a disconnect sequence from the caller side.
            Q931SendReleaseCompleteMessage(pCallObject,
                    CC_REJECT_INVALID_REVISION, NULL, NULL, NULL);

            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectDestroy(pCallObject);
            linkLayerShutdown(dwPhysicalId);
            return;
        }

        if (Result == CS_MANDATORY_IE_MISSING)
        {
            Q931SendStatusMessage(pCallObject, pMessage,
                CAUSE_VALUE_IE_MISSING);
        }
        else if (Result == CS_BAD_IE_CONTENT)
        {
            Q931SendStatusMessage(pCallObject, pMessage,
                CAUSE_VALUE_IE_CONTENTS);
        }

    }
    else if (message == LINK_RECV_CLOSED)
    {
        // Socket closed
        if (buf)
        {
            MemFree(buf);
        }
        pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED, pCallObject->hQ931Call,
            pCallObject->dwListenToken,
            pCallObject->dwUserToken, NULL);

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
             dwPhysicalId = pCallObject->dwPhysicalId;
             pCallObject->bConnected = FALSE;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwPhysicalId);
        }
        return;
    }
    else if (buf)
    {
        // unknown condition?
        MemFree(buf);
    }

    if (CallObjectValidate(hQ931Call) == CS_OK)
    {
        CallObjectUnlock(pCallObject);
    }

    return;
}

//====================================================================================
//====================================================================================
void
Q931ReceiveCallback(DWORD_PTR instance, HRESULT message, BYTE *buf, DWORD nbytes)
{
    Q931MESSAGE *pMessage = NULL;
    if (message == LINK_RECV_DATA)
    {
        pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
        if (pMessage == NULL)
        {
            ISRERROR(ghISRInst, "Not enough memory to process Q931 message.", 0L);
            // something more should be done here to indicate SERIOUS error...
            return;
        }
    }
    OnReceiveCallback(instance, message, pMessage, buf, nbytes);
    if (pMessage)
    {
        MemFree(pMessage);
    }
    return;
}

//====================================================================================
//====================================================================================
void
Q931ConnectCallback(DWORD_PTR dwInstance, HRESULT dwMessage,
        CC_ADDR *pLocalAddr, CC_ADDR *pPeerAddr)
{
    HQ931CALL hQ931Call = (HQ931CALL)dwInstance;
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult;
    DWORD dwPhysicalId;

    ISRTRACE(ghISRInst, "Entering Q931ConnectCallback()...", 0L);

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error", 0L);
        return;
    }

    pCallObject->bConnected = TRUE;

    if (FAILED(dwMessage))
    {
        // shut down link layer; report failure to client
        CSS_CALL_FAILED EventData;

        ISRERROR(ghISRInst, "error in connect", 0L);

        EventData.error = dwMessage;
        pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
            pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
        return;
    }

    if (dwMessage != LINK_CONNECT_COMPLETE)
    {
        ISRERROR(ghISRInst, "unexpected connect callback", 0L);
        CallObjectUnlock(pCallObject);
        return;
    }

    if (pCallObject->bCallState == CALLSTATE_NULL)
    {
        pCallObject->bCallState = CALLSTATE_INITIATED;
    }

    ASSERT(pLocalAddr);
    pCallObject->LocalAddr = *pLocalAddr;

    ASSERT(pPeerAddr);
    pCallObject->PeerConnectAddr = *pPeerAddr;

    // if the user specified a binary source address with address = 0,
    // fill in the address with the local address and send.
    if ((pCallObject->SourceAddrPresent) &&
            (pCallObject->SourceAddr.nAddrType == CC_IP_BINARY) &&
            (!pCallObject->SourceAddr.Addr.IP_Binary.dwAddr))
    {
        pCallObject->SourceAddr = *pLocalAddr;
    }

    if ((pCallObject->fIsCaller) &&
            (pCallObject->bCallState == CALLSTATE_INITIATED))
    {
        // send the SETUP message to the peer.
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;

        DWORD CodedLengthPDU;
        BYTE *CodedPtrPDU;
        HRESULT ResultPDU = CS_OK;

        int nError = 0;
        BOOL ResultSend = FALSE;
        BINARY_STRING UserUserData;
        PCC_VENDORINFO pVendorInfo = NULL;
        CC_NONSTANDARDDATA *pNonStandardData = NULL;
		DWORD dwId;

        if (pCallObject->VendorInfoPresent)
        {
            pVendorInfo = &(pCallObject->VendorInfo);
        }

        if (pCallObject->NonStandardDataPresent)
        {
            pNonStandardData = &(pCallObject->NonStandardData);
        }

        // if there is a special callee alias list, load the calledparty#.
        if (pCallObject->szCalledPartyNumber[0] == 0 &&
            pCallObject->pCalleeAliasList != NULL &&
            pCallObject->pCalleeAliasList->wCount == 1 &&
            pCallObject->pCalleeAliasList->pItems[0].wType == CC_ALIAS_H323_PHONE &&
            pCallObject->pCalleeAliasList->pItems[0].wDataLength > 0 &&
            pCallObject->pCalleeAliasList->pItems[0].pData != NULL)
        {
            PCC_ALIASITEM pItem = &pCallObject->pCalleeAliasList->pItems[0];
            WCHAR szWidePartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];

            memset(szWidePartyNumber, 0 , CC_MAX_PARTY_NUMBER_LEN + 1);

            if (pItem->wPrefixLength > 0 && pItem->pPrefix != NULL)
            {
                ASSERT((pItem->wPrefixLength + pItem->wDataLength +1) <= (sizeof(szWidePartyNumber)/sizeof(szWidePartyNumber[0])));
                memcpy(&szWidePartyNumber[0],
                       pItem->pPrefix,
                       (pItem->wPrefixLength) * sizeof(WCHAR));
                memcpy(&szWidePartyNumber[pItem->wPrefixLength],
                       pItem->pData,
                       pItem->wDataLength * sizeof(WCHAR));
            }
            else
            {
                ASSERT((pItem->wDataLength +1) <= (sizeof(szWidePartyNumber)/sizeof(szWidePartyNumber[0])));
                memcpy(szWidePartyNumber,
                       pCallObject->pCalleeAliasList->pItems[0].pData,
                       pItem->wDataLength * sizeof(WCHAR));
            }
            WideCharToMultiByte(CP_ACP, 0, szWidePartyNumber,
                pItem->wPrefixLength + pItem->wDataLength * sizeof(WCHAR),
                pCallObject->szCalledPartyNumber,
                sizeof(pCallObject->szCalledPartyNumber), NULL, NULL);
        }

        // may wish to pass alias parms later instead of NULL, NULL.
        ResultASN = Q931SetupEncodeASN(pNonStandardData,
            pCallObject->SourceAddrPresent ? &(pCallObject->SourceAddr) : NULL,
            pCallObject->PeerCallAddrPresent ? &(pCallObject->PeerCallAddr) : NULL,  // callee
            pCallObject->wGoal,
            pCallObject->wCallType,
            pCallObject->bCallerIsMC,
            &(pCallObject->ConferenceID),
            pCallObject->pCallerAliasList,
            pCallObject->pCalleeAliasList,
            pCallObject->pExtraAliasList,
            pCallObject->pExtensionAliasItem,
            pVendorInfo,
            pCallObject->bIsTerminal,
            pCallObject->bIsGateway,
						&pCallObject->World,
            &CodedPtrASN,
            &CodedLengthASN,
            &pCallObject->CallIdentifier);

        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            CSS_CALL_FAILED EventData;
            ISRERROR(ghISRInst, "Q931SetupEncodeASN() failed, nothing to send.", 0L);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            EventData.error = CS_INTERNAL_ERROR;
            dwId = pCallObject->dwPhysicalId;
            pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
                pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
            linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
                 CallObjectDestroy(pCallObject);
            return;
        }

        UserUserData.length = (WORD)CodedLengthASN;
        UserUserData.ptr = CodedPtrASN;

        ResultPDU = Q931SetupEncodePDU(pCallObject->wCRV,
            pCallObject->szDisplay, pCallObject->szCalledPartyNumber,
            &UserUserData, &CodedPtrPDU, &CodedLengthPDU);

        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }

        if ((ResultPDU != CS_OK) || (CodedLengthPDU == 0) ||
                (CodedPtrPDU == NULL))
        {
            CSS_CALL_FAILED EventData;
            ISRERROR(ghISRInst, "Q931SetupEncodePDU() failed, nothing to send.", 0L);
            if (CodedPtrPDU != NULL)
            {
                MemFree(CodedPtrPDU);
            }
            EventData.error = CS_INTERNAL_ERROR;
            dwId = pCallObject->dwPhysicalId;
            pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
                pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
            linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
                 CallObjectDestroy(pCallObject);
            return;
        }

        if (pCallObject->NonStandardDataPresent)
        {
            if (pCallObject->NonStandardData.sData.pOctetString != NULL)
            {
                MemFree(pCallObject->NonStandardData.sData.pOctetString);
                pCallObject->NonStandardData.sData.pOctetString = NULL;
            }
            pCallObject->NonStandardDataPresent = FALSE;
        }
        Q931FreeAliasNames(pCallObject->pCallerAliasList);
        pCallObject->pCallerAliasList = NULL;
        Q931FreeAliasNames(pCallObject->pCalleeAliasList);
        pCallObject->pCalleeAliasList = NULL;
        Q931FreeAliasNames(pCallObject->pExtraAliasList);
        pCallObject->pExtraAliasList = NULL;
        Q931FreeAliasItem(pCallObject->pExtensionAliasItem);
        pCallObject->pExtensionAliasItem = NULL;

        TempResult=Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
        if (CallObjectValidate(hQ931Call) != CS_OK)
          return;

        if(FAILED(TempResult))
        {
            CSS_CALL_FAILED EventData;

            EventData.error = TempResult;
			dwId = pCallObject->dwPhysicalId;
            pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
                pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
            linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
                 CallObjectDestroy(pCallObject);
            return;
        }

        Q931StartTimer(pCallObject, Q931_TIMER_303);
    }
    dwPhysicalId = pCallObject->dwPhysicalId;
    CallObjectUnlock(pCallObject);
    PostReceiveBuffer(dwPhysicalId, NULL);
}

//====================================================================================
//====================================================================================
void
Q931ListenCallback(DWORD_PTR dwInstance, HRESULT dwMessage,
        CC_ADDR *LocalAddr, CC_ADDR *PeerAddr)
{
    HQ931LISTEN hListenObject = (HQ931LISTEN)dwInstance;
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS CreateObjectResult;
    HQ931CALL hQ931Call;
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult;
	DWORD dwPhysicalId;

    ISRTRACE(ghISRInst, "Q931ListenCallback.", 0L);

    if (dwMessage != LINK_CONNECT_REQUEST)
    {
        ISRERROR(ghISRInst, "unexpected callback received on listen socket", 0L);
        return;
    }

    if (FAILED(dwMessage))
    {
        ISRERROR(ghISRInst, "error on listen socket", 0L);
        return;
    }

    if ((ListenObjectLock(hListenObject, &pListenObject) != CS_OK) || (pListenObject == NULL))
    {
        ISRERROR(ghISRInst, "ListenObjectLock() returned error", 0L);
        return;
    }

    // create call object with all known attributes of this call.
    // a handle of the call object is returned in phQ931Call.
    CreateObjectResult = CallObjectCreate(&hQ931Call,
        pListenObject->dwUserToken,
        CC_INVALID_HANDLE,
        pListenObject->ListenCallback,
        FALSE,                  // I am NOT the caller.
        LocalAddr,              // Local address on which channel is connected
        PeerAddr,               // Address to which channel is connected
        NULL,                   // Address of opposite call end-point.
        NULL,                   // no source addr
        NULL,                   // no conference id yet.
        CSG_NONE,               // no goal yet.
        CC_CALLTYPE_UNKNOWN,    // no call type yet.
        FALSE,                  // caller is assumed to not be the MC.
        NULL,                   // no display yet.
        NULL,                   // no called party number yet.
        NULL,                   // no caller aliases yet.
        NULL,                   // no callee aliases yet.
        NULL,                   // no extra aliases yet.
        NULL,                   // no extension aliases.
        NULL,                   // no EndpointType info yet.
        NULL,
		0,                      // no CRV yet.
		NULL);					// no h225 CallIdentifier yet.
    if (CreateObjectResult != CS_OK)
    {
        ISRERROR(ghISRInst, "CallObjectCreate() failed.", 0L);
        ListenObjectUnlock(pListenObject);
        return;
    }

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error", 0L);
        ListenObjectUnlock(pListenObject);
        return;
    }

    TempResult = linkLayerInit(&pCallObject->dwPhysicalId, hQ931Call,
        Q931ReceiveCallback, Q931SendComplete);
    if (FAILED(TempResult))
    {
        ISRERROR(ghISRInst, "linkLayerInit() failed", 0);
        linkLayerReject(pListenObject->dwPhysicalId);
        CallObjectDestroy(pCallObject);
        ListenObjectUnlock(pListenObject);
        return;
    }

//    pCallObject->bCallState = CALLSTATE_NULL;

    // unlock CallObject before calling down into h245ws in order to prevent deadlock - which
    // is probably unlikely with linkLayerAccept(), but just to be safe and consistent...
    // not sure if we need to worry about unlocking the listen object???

    dwPhysicalId = pCallObject->dwPhysicalId;
    CallObjectUnlock(pCallObject);

    TempResult = linkLayerAccept(pListenObject->dwPhysicalId,
        dwPhysicalId, Q931ConnectCallback);

    if (FAILED(TempResult))
    {
	      if((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
   	    {
	           ListenObjectUnlock(pListenObject);
	           return;
  	    }
        ISRERROR(ghISRInst, "linkLayerAccept() failed", 0);
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
        ListenObjectUnlock(pListenObject);
        return;
    }

    ListenObjectUnlock(pListenObject);
}

//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================

CS_STATUS
H225Init()
{
     CS_STATUS result;

    if (H225_InitModule() != ASN1_SUCCESS)
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }



     return CS_OK;
}


CS_STATUS
H225DeInit()
{
    CS_STATUS result;
    result = H225_TermModule();
    if (result != CS_OK)
    {
        return CS_SUBSYSTEM_FAILURE;
    }
    return CS_OK;
}

CS_STATUS
Q931Init()
{
    CS_STATUS result;

    if (bQ931Initialized == TRUE)
    {
    	ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    bQ931Initialized = TRUE;

    // Register Call Setup for debug output
    ISRREGISTERMODULE(&ghISRInst, "Q931", "Q931 Call Setup");

    // Initialize the current conference ID to 0's, which is intentionally
    // assigned to an invalid conference ID.  Must create one for it
    // to be valid.
    memset(&(ConferenceIDSource), 0, sizeof(ConferenceIDSource));
    InitializeCriticalSection(&(ConferenceIDSource.Lock));

    if ((result = ListenListCreate()) != CS_OK)
    {
        return result;
    }
    if ((result = CallListCreate()) != CS_OK)
    {
        ListenListDestroy();
        return result;
    }

    // init protocol ID structures
    Q931PduInit();

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
    Q931Logger = InteropLoad(Q931LOG_PROTOCOL);
#endif

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931DeInit()
{
    CS_STATUS result1;
    CS_STATUS result2;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
// This causes a protection exception, so don't do it for now.  DAC 12/9/96
//    InteropUnload(Q931Logger);
#endif

    result1 = ListenListDestroy();

    result2 = CallListDestroy();

    DeleteCriticalSection(&(ConferenceIDSource.Lock));

    bQ931Initialized = FALSE;

    if (result1 != CS_OK)
    {
        return result1;
    }
    return result2;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931Listen(
    PHQ931LISTEN        phQ931Listen,
    PCC_ADDR            pListenAddr,
    DWORD_PTR           dwListenToken,
    Q931_CALLBACK       ListenCallback)
{
    CS_STATUS CreateObjectResult;
    P_LISTEN_OBJECT pListenObject = NULL;
    HRESULT TempResult;

    // make sure q931 is initialized with an initialize flag.
    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    // make sure parms are validated.
    if ((phQ931Listen == NULL) || (ListenCallback == NULL) || (pListenAddr == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    SetDefaultPort(pListenAddr);

    // create listen object with all known attributes of this listen session.
    // a handle of the listen object is returned in phQ931Listen.

    CreateObjectResult = ListenObjectCreate(phQ931Listen, dwListenToken, ListenCallback);
    if (CreateObjectResult != CS_OK)
    {
        return CS_SUBSYSTEM_FAILURE;
    }

    if (ListenObjectLock(*phQ931Listen, &pListenObject) != CS_OK)
    {
        return CS_BAD_PARAM;
    }

    TempResult = linkLayerListen(&pListenObject->dwPhysicalId, *phQ931Listen,
        pListenAddr, Q931ListenCallback);
    ListenObjectUnlock(pListenObject);
    if (FAILED(TempResult))
    {
        ISRTRACE(ghISRInst, "Q931Listen() linkLayerListen failed.", 0L);
        return TempResult;
    }

    ISRTRACE(ghISRInst, "Q931Listen() completed successfully.", 0L);
    return CS_OK;
}

//====================================================================================
// In the old code, this blocked until thread and socket were finished
// closing...
//====================================================================================
CS_STATUS
Q931CancelListen(
    HQ931LISTEN         hQ931Listen)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS Status;

    // make sure q931 is initialized with an initialize flag.
    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Q931CancelListen() finding listen object...", 0L);

    // lock the listen object, get the event to wait for, and unlock the listen object.
    if (ListenObjectLock(hQ931Listen, &pListenObject) != CS_OK)
    {
        return CS_BAD_PARAM;
    }

    {
        DWORD dwId = pListenObject->dwPhysicalId;
        linkLayerShutdown(dwId);
        // destroy the object.  dont need to unlock it since entire object will be destroyed.
        ISRTRACE(ghISRInst, "Q931CancelListen(): destroying listen object...", 0L);
        Status = ListenObjectDestroy(pListenObject);
    }

    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD_PTR dwUserToken,
    Q931_CALLBACK ConnectCallback,
    WORD wCRV,
    LPGUID pCallIdentifier)
{
    CS_STATUS CreateObjectResult;
    P_CALL_OBJECT pCallObject = NULL;
    CC_ADDR PeerCallAddr;
    CC_ADDR PeerConnectAddr;
    CC_ADDR SourceAddr;
    HRESULT TempResult;
    char szAsciiDisplay[CC_MAX_DISPLAY_LENGTH + 1];
    char szAsciiPartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];
    DWORD dwPhysicalId;

    // make sure q931 is initialized with an initialize flag.
    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    // make sure parms are validated.
    if ((phQ931Call == NULL) || (ConnectCallback == NULL) ||
            ((pControlAddr == NULL) && (pDestinationAddr == NULL)) ||
            (pSourceEndpointType == NULL))
    {
        return CS_BAD_PARAM;
    }

    {
        CS_STATUS TempStatus;

        TempStatus = Q931ValidateAddr(pControlAddr);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAddr(pDestinationAddr);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAddr(pSourceAddr);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }

        TempStatus = Q931ValidateVendorInfo(pSourceEndpointType->pVendorInfo);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateDisplay(pszDisplay);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidatePartyNumber(pszCalledPartyNumber);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }

        szAsciiDisplay[0] = '\0';
        if (pszDisplay && WideCharToMultiByte(CP_ACP, 0, pszDisplay, -1, szAsciiDisplay,
                sizeof(szAsciiDisplay), NULL, NULL) == 0)
        {
            return CS_BAD_PARAM;
        }
        szAsciiPartyNumber[0] = '\0';
        if (pszCalledPartyNumber && WideCharToMultiByte(CP_ACP, 0, pszCalledPartyNumber, -1, szAsciiPartyNumber,
                sizeof(szAsciiPartyNumber), NULL, NULL) == 0)
        {
            return CS_BAD_PARAM;
        }
        TempStatus = Q931ValidateNonStandardData(pNonStandardData);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasNames(pCallerAliasList);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasNames(pCalleeAliasList);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasNames(pExtraAliasList);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasItem(pExtensionAliasItem);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
    }

    // get the correct callee and control address to use for the call.
    if (pDestinationAddr)
    {
        if (!MakeBinaryADDR(pDestinationAddr, &PeerCallAddr))
        {
            return CS_BAD_PARAM;
        }
        SetDefaultPort(&PeerCallAddr);
    }

    if (pControlAddr)
    {
        if (!MakeBinaryADDR(pControlAddr, &PeerConnectAddr))
        {
            return CS_BAD_PARAM;
        }
        SetDefaultPort(&PeerConnectAddr);
    }
    else
    {
        PeerConnectAddr = PeerCallAddr;
    }

    // get the correct callee and control address to use for the call.
    if (pSourceAddr)
    {
        if (!MakeBinaryADDR(pSourceAddr, &SourceAddr))
        {
            return CS_BAD_PARAM;
        }
        SetDefaultPort(&SourceAddr);
    }

	if (wGoal == CSG_CREATE)
        {
            // caller is asking to start a new conference.
            if (((DWORD *)pConferenceID->buffer)[0] == 0 &&
                ((DWORD *)pConferenceID->buffer)[1] == 0 &&
                ((DWORD *)pConferenceID->buffer)[2] == 0 &&
                ((DWORD *)pConferenceID->buffer)[3] == 0)
            {
                _ConferenceIDNew(pConferenceID);
            }
        }

    // create call object with all known attributes of this call.
    // a handle of the call object is returned in phQ931Call.
    CreateObjectResult = CallObjectCreate(phQ931Call,
        CC_INVALID_HANDLE,
        dwUserToken,
        ConnectCallback,
        TRUE,                  // I am the caller.
        NULL,                  // no local address yet.
        &PeerConnectAddr,
        pDestinationAddr ? &PeerCallAddr : NULL,
        pSourceAddr ? &SourceAddr : NULL,
        pConferenceID,
        wGoal,
        wCallType,
        bCallerIsMC,
        pszDisplay ? szAsciiDisplay : NULL,
        pszCalledPartyNumber ? szAsciiPartyNumber : NULL,
        pCallerAliasList,
        pCalleeAliasList,
        pExtraAliasList,
        pExtensionAliasItem,
        pSourceEndpointType,
        pNonStandardData,
        wCRV,
        pCallIdentifier);

    if (CreateObjectResult != CS_OK)
    {
        return CS_SUBSYSTEM_FAILURE;
    }

    if ((CallObjectLock(*phQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error", 0L);
        return CS_SUBSYSTEM_FAILURE;
    }

    TempResult = linkLayerInit(&pCallObject->dwPhysicalId, *phQ931Call,
        Q931ReceiveCallback, Q931SendComplete);
    if (FAILED(TempResult))
    {
        ISRERROR(ghISRInst, "linkLayerInit() failed", 0);
        CallObjectDestroy(pCallObject);
        *phQ931Call = 0;
        return TempResult;
    }

    // unlock CallObject before calling down into h245ws in order to prevent deadlock - which
    // is probably unlikely with linkLayerConnect(), but just to be safe and consistent...
    dwPhysicalId = pCallObject->dwPhysicalId;
    CallObjectUnlock(pCallObject);
    TempResult = linkLayerConnect(dwPhysicalId, &PeerConnectAddr,
            Q931ConnectCallback);
    if((CallObjectLock(*phQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        *phQ931Call = 0;
        return(CS_INTERNAL_ERROR);
    }

    if (FAILED(TempResult))
    {
        ISRERROR(ghISRInst, "linkLayerConnect() failed", 0);
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
        *phQ931Call = 0;
        return TempResult;
    }

//    pCallObject->bCallState = CALLSTATE_NULL;

    CallObjectUnlock(pCallObject);

    ISRTRACE(ghISRInst, "Q931PlaceCall() completed successfully.", 0L);
    return CS_OK;
}

//====================================================================================
// In the old code, this blocked until thread and socket were finished
// closing...
//====================================================================================
CS_STATUS
Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS Status;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Entering Q931Hangup()...", 0L);

    // need parameter checking...
    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRTRACE(ghISRInst, "Call Object no longer available:", (DWORD)hQ931Call);
        return CS_BAD_PARAM;
    }

    {

        CS_STATUS SendStatus = CS_OK;
        if (pCallObject->bCallState != CALLSTATE_NULL)
        {
            // send the RELEASE COMPLETE message to the peer to hang-up.
            SendStatus = Q931SendReleaseCompleteMessage(pCallObject,
                bReason, &(pCallObject->ConferenceID), NULL, NULL);
        }

        {
             DWORD dwId = pCallObject->dwPhysicalId;
             Status = CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }

        if (FAILED(SendStatus))
        {
            return SendStatus;
        }
    }

    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931AcceptCall(
    HQ931CALL           hQ931Call,
    LPWSTR              pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE    pDestinationEndpointType,
    PCC_ADDR            pH245Addr,
    DWORD_PTR           dwUserToken)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS result = CS_OK;
    char szAsciiDisplay[CC_MAX_DISPLAY_LENGTH + 1];

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Entering Q931AcceptCall()...", 0L);

    if ((pDestinationEndpointType == NULL) ||
            (pDestinationEndpointType->pVendorInfo == NULL))
    {
        return CS_BAD_PARAM;
    }

    {
        CS_STATUS TempStatus;

        TempStatus = Q931ValidateVendorInfo(pDestinationEndpointType->pVendorInfo);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateDisplay(pszDisplay);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        szAsciiDisplay[0] = '\0';
        if (pszDisplay && WideCharToMultiByte(CP_ACP, 0, pszDisplay, -1, szAsciiDisplay,
                sizeof(szAsciiDisplay), NULL, NULL) == 0)
        {
            return CS_BAD_PARAM;
        }
        TempStatus = Q931ValidateNonStandardData(pNonStandardData);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
    }

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error (Socket not found).", 0L);
        return CS_INTERNAL_ERROR;
    }

    if (pCallObject->fIsCaller)
    {
        ISRERROR(ghISRInst, "Caller attempted to accept call.", 0L);

        CallObjectUnlock(pCallObject);
        return CS_OUT_OF_SEQUENCE;
    }

    // label with the user supplied UserToken for this call object.
    pCallObject->dwUserToken = dwUserToken;

    // send the CONNECT message to peer to accept call.
    {
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;
        CC_ADDR h245Addr;

        if (pH245Addr != NULL)
        {
            MakeBinaryADDR(pH245Addr, &h245Addr);
        }

        ResultASN = Q931ConnectEncodeASN(pNonStandardData,
            &(pCallObject->ConferenceID),
            (pH245Addr ? &h245Addr : NULL),
            pDestinationEndpointType,
						&pCallObject->World,
            &CodedPtrASN,
            &CodedLengthASN,
            &pCallObject->CallIdentifier);
        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            ISRERROR(ghISRInst, "Q931ConnectEncodeASN() failed, nothing to send.", 0L);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            CallObjectUnlock(pCallObject);
            return CS_SUBSYSTEM_FAILURE;
        }
        else
        {
            DWORD CodedLengthPDU;
            BYTE *CodedPtrPDU;
            BINARY_STRING UserUserData;
            HRESULT ResultEncode = CS_OK;
            HRESULT TempResult;
            WORD wCRV = (WORD)(pCallObject->wCRV | 0x8000);

            UserUserData.length = (WORD)CodedLengthASN;
            UserUserData.ptr = CodedPtrASN;

            ResultEncode = Q931ConnectEncodePDU(wCRV,
                szAsciiDisplay, &UserUserData, &CodedPtrPDU, &CodedLengthPDU);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                    (CodedPtrPDU == NULL))
            {
                ISRERROR(ghISRInst, "Q931ConnectEncodePDU() failed, nothing to send.", 0L);
                if (CodedPtrPDU != NULL)
                {
                    MemFree(CodedPtrPDU);
                }
                CallObjectUnlock(pCallObject);
                return CS_SUBSYSTEM_FAILURE;
            }

            TempResult = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
            if (CallObjectValidate(hQ931Call) != CS_OK)
              return CS_INTERNAL_ERROR;


            if (FAILED(TempResult))
            {
                ISRERROR(ghISRInst, "datalinkSendRequest() failed", 0);
                if (CodedPtrPDU != NULL)
                {
                    MemFree(CodedPtrPDU);
                }
                // when the connect notification fails...what should we do anyway????
                CallObjectUnlock(pCallObject);
                return TempResult;
            }
        }
    }

    pCallObject->bCallState = CALLSTATE_ACTIVE;

    CallObjectUnlock(pCallObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS result = CS_OK;
    CS_STATUS Status = CS_OK;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Entering Q931RejectCall()...", 0L);

    {
        CS_STATUS TempStatus;

        TempStatus = Q931ValidateNonStandardData(pNonStandardData);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
    }

    // if reason is alternate addr, but there is no alternate addr -->err
    if (((bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER) ||
            (bRejectReason == CC_REJECT_CALL_FORWARDED) ||
            (bRejectReason == CC_REJECT_ROUTE_TO_MC)) &&
            (pAlternateAddr == NULL))
    {
        return CS_BAD_PARAM;
    }

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error (Socket not found).", 0L);
        return CS_INTERNAL_ERROR;
    }

    if (pCallObject->fIsCaller)
    {
        ISRERROR(ghISRInst, "Caller attempted to reject call.", 0L);

        CallObjectUnlock(pCallObject);
        return CS_OUT_OF_SEQUENCE;
    }

    result = Q931SendReleaseCompleteMessage(pCallObject,
        bRejectReason, pConferenceID, pAlternateAddr, pNonStandardData);

    {
        DWORD dwId = pCallObject->dwPhysicalId;
        Status = CallObjectDestroy(pCallObject);
        linkLayerShutdown(dwId);
    }

    if (result != CS_OK)
    {
        return result;
    }


    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ReOpenConnection(
    HQ931CALL hQ931Call)
{
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult = CS_OK;
    CC_ADDR PeerConnectAddr;
    DWORD dwPhysicalId;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Entering Q931ReOpenConnection()...", 0L);

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRERROR(ghISRInst, "CallObjectLock() returned error.", 0L);
        return CS_INTERNAL_ERROR;
    }

    if (pCallObject->bConnected)
    {
        return CS_OUT_OF_SEQUENCE;
    }

    Q931MakePhysicalID(&pCallObject->dwPhysicalId);
    TempResult = linkLayerInit(&pCallObject->dwPhysicalId, hQ931Call,
        Q931ReceiveCallback, Q931SendComplete);
    if (FAILED(TempResult))
    {
        ISRERROR(ghISRInst, "linkLayerInit() failed on re-connect.", 0);
        CallObjectUnlock(pCallObject);
        return TempResult;
    }

    // unlock CallObject before calling down into h245ws in order to prevent deadlock - which
    // is probably unlikely with linkLayerConnect, but just to be safe and consistent...

    // copy stuff we need out of call object before we unlock it
    dwPhysicalId = pCallObject->dwPhysicalId;
    PeerConnectAddr = pCallObject->PeerConnectAddr;

    CallObjectUnlock(pCallObject);

    TempResult = linkLayerConnect(dwPhysicalId,
            &PeerConnectAddr, Q931ConnectCallback);

    if((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        return(CS_INTERNAL_ERROR);
    }

    if (FAILED(TempResult))
    {
        ISRERROR(ghISRInst, "linkLayerConnect() failed on re-connect.", 0);
        linkLayerShutdown(pCallObject->dwPhysicalId);
        CallObjectUnlock(pCallObject);
        return TempResult;
    }

    CallObjectUnlock(pCallObject);

    ISRTRACE(ghISRInst, "Q931ReOpenConnection() completed successfully.", 0L);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931GetVersion(
    WORD wLength,
    LPWSTR pszVersion)
{
WCHAR	pszQ931Version[255];

    // parameter validation.
    if ((wLength == 0) || (pszVersion == NULL))
    {
        return CS_BAD_PARAM;
    }

    wcscpy(pszQ931Version, L"Call Setup ");
    wcscat(pszQ931Version, Unicode(__DATE__));
    wcscat(pszQ931Version, L" ");
    wcscat(pszQ931Version, Unicode(__TIME__));

    if (wcslen(pszQ931Version) >= wLength)
    {
		memcpy(pszVersion, pszQ931Version, (wLength-1)*sizeof(WCHAR));
        pszQ931Version[wLength-1] = L'\0';
        return CS_BAD_SIZE;
    }

	wcscpy(pszVersion, pszQ931Version);
    return CS_OK;
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//====================================================================================
// Timer 301 has expired for this object...
//====================================================================================
void
CallBackT301(P_CALL_OBJECT pCallObject)
{
    CSS_CALL_FAILED EventData;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;

    EventData.error = CS_RINGING_TIMER_EXPIRED;
    pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
        pCallObject->dwListenToken,
        pCallObject->dwUserToken, &EventData);

    if (CallObjectValidate(hQ931Call) == CS_OK)
    {
        if (Q931SendReleaseCompleteMessage(pCallObject,
            CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) == CS_OK)
        {
            // nothing to do...
        }

        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
    }
    return;
}

//====================================================================================
// Timer 303 has expired for this object...
//====================================================================================
void
CallBackT303(P_CALL_OBJECT pCallObject)
{
    CSS_CALL_FAILED EventData;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;

    EventData.error = CS_SETUP_TIMER_EXPIRED;
    pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
        pCallObject->dwListenToken,
        pCallObject->dwUserToken, &EventData);

    if (CallObjectValidate(hQ931Call) == CS_OK)
    {
        if (Q931SendReleaseCompleteMessage(pCallObject,
            CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) == CS_OK)
        {
            // nothing to do...
        }

        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
    }
    return;
}

//====================================================================================
//====================================================================================
void
Q931SetReceivePDUHook(Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback)
{
    gReceivePDUHookProc = Q931ReceivePDUCallback;
    return;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FlushSendQueue(
    HQ931CALL hQ931Call)
{
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult = CS_OK;
    DWORD dwPhysicalId;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    ISRTRACE(ghISRInst, "Entering Q931FlushSendQueue()...", 0L);

    // need parameter checking...
    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        ISRTRACE(ghISRInst, "Call Object no longer available:", (DWORD)hQ931Call);
        return CS_INTERNAL_ERROR;
    }

    dwPhysicalId = pCallObject->dwPhysicalId;

    CallObjectUnlock(pCallObject);

    TempResult = linkLayerFlushChannel(dwPhysicalId, DATALINK_TRANSMIT);
    if (FAILED(TempResult))
    {
        ISRERROR(ghISRInst, "datalinkSendRequest() failed", 0L);
    }

    return(TempResult);
}

#ifdef __cplusplus
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\protocol.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/protocol.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.3  $
 *	$Date:   Apr 25 1996 21:21:48  $
 *	$Author:   plantz  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Line Protocol Definitions.
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef PROTOCOL_H
#define PROTOCOL_H

#ifdef __cplusplus
extern "C" {
#endif


#define TYPE_Q931_SETUP                 1
#define TYPE_Q931_CONNECT               2
#define TYPE_Q931_RELEASE_COMPLETE      3
#define TYPE_Q931_ALERTING              4
// and more later....


#define Q931_PROTOCOL ((WORD)0x1)

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
} MSG_Q931, *PMSG_Q931;

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    ADDR            CallerAddr;     // needed because call may be made from gatekeeper.
    ADDR            CalleeAddr;     // needed because call may be made to gatekeeper.
    WORD            wConferenceID;
    WORD            wGoal;
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_SETUP, *PMSG_Q931_SETUP;

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    WORD            wConferenceID;
    ADDR            H245Addr;       // address returned by callee.
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_CONNECT, *PMSG_Q931_CONNECT;


typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    WORD            wConferenceID;  //   I think this should be passed from the user...
	BYTE            bReason;        // defined above.
    ADDR            AlternateAddr;  // alternative address to use.
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_RELEASE_COMPLETE, *PMSG_Q931_RELEASE_COMPLETE;


typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
} MSG_Q931_ALERTING, *PMSG_Q931_ALERTING;


#ifdef __cplusplus
}
#endif

#endif PROTOCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\postrecv.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:/STURGEON/SRC/GKI/VCS/postrecv.cpv  $
*																		*
*	$Revision:   1.8  $
*	$Date:   13 Feb 1997 15:05:20  $
*																		*
*	$Author:   unknown  $
*																		*
*   $Log:   S:/STURGEON/SRC/GKI/VCS/postrecv.cpv  $
// 
//    Rev 1.8   13 Feb 1997 15:05:20   unknown
// Moved CGatekeeper::Unlock to end of PostRecv thread to avoid shutdown err
// 
//    Rev 1.7   12 Feb 1997 01:12:08   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.6   24 Jan 1997 18:36:24   CHULME
// Reverted to rev 1.4
// 
//    Rev 1.4   17 Jan 1997 09:02:32   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.3   10 Jan 1997 16:15:54   CHULME
// Removed MFC dependency
// 
//    Rev 1.2   22 Nov 1996 15:21:24   CHULME
// Added VCS log to the header
*************************************************************************/

// postrecv.cpp : Provides the secondary thread implementation
//
#include "precomp.h"

#include "gkicom.h"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void 
PostReceive(void *pv)
{
	// ABSTRACT:  This function is invoked in a separate thread to
	//            post a receive on the associated socket.  When a datagram
	//            arrives, this function will decode it and send it
	//            to the PDUHandler.  If the PDUHandler doesn't instruct
	//            this thread to exit (with a non-zero return code), this
	//            function will post another receive.
	// AUTHOR:    Colin Hulme

	char			szBuffer[512];
	int				nRet;
	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRasMessage;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "PostReceive(pv)\n", 0);
	ASSERT(g_pCoder);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return;	
		
	while ((hResult == GKI_OK) && g_pReg && H225ASN_Module)
	{
		g_pReg->LockSocket();			
		nRet = g_pReg->m_pSocket->Receive(szBuffer, 512);
		g_pReg->UnlockSocket();

		g_pGatekeeper->Lock();
		if ((g_pReg == 0) || (H225ASN_Module == NULL))
		{
			SPIDER_TRACE(SP_THREAD, "PostReceive thread exiting\n", 0);
			g_pGatekeeper->Unlock();
			return;
		}		

		if (nRet != SOCKET_ERROR)
		{
			if (fGKIEcho && (pEchoBuff != 0))
			{
				if (nEchoLen != nRet)
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer len != Sent buffer len ***\n", 0);
				}
				if (memcmp(szBuffer, pEchoBuff, nEchoLen) == 0)
				{
					SPIDER_TRACE(SP_DEBUG, "Received buffer = Sent buffer\n", 0);
				}
				else
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer != Sent buffer ***\n", 0);
				}
				SPIDER_TRACE(SP_NEWDEL, "del pEchoBuff = %X\n", pEchoBuff);
				delete pEchoBuff;
				pEchoBuff = 0;
			}
			else	// Process incoming PDU
			{
				// Setup Asn1Buf for decoder and decode PDU
				Asn1Buf.length = nRet;	// number of bytes received
				Asn1Buf.value = (unsigned char *)szBuffer;
				dwErrorCode = g_pCoder->Decode(&Asn1Buf, &pRasMessage);

				if (dwErrorCode)
				{
					SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_DECODER_ERROR)\n", 0);
					PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, GKI_DECODER_ERROR);
				}

				else
				{
#ifdef _DEBUG
					if (dwGKIDLLFlags & SP_DUMPMEM)
						DumpMem(pRasMessage, sizeof(RasMessage));
#endif
					hResult = g_pReg->PDUHandler(pRasMessage);

					// Notify client app if an error code was received
					if (hResult & HR_SEVERITY_MASK)
					{
						SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
						PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
																hResult);
					}
				}

				// Free the encoder memory
				g_pCoder->Free(pRasMessage);
			}
		}
		//======================================================================================
		else
		{
			// WSAEINTR - returned when socket closed
			//            get out cleanly
			if (g_pReg->m_pSocket->GetLastError() == WSAEINTR)
				hResult = GKI_REDISCOVER;

			else
			{
				hResult = GKI_WINSOCK2_ERROR(g_pReg->m_pSocket->GetLastError());
				SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
				PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
				hResult = GKI_EXIT_THREAD;
			}
		}

		// Release access to the registration object
		g_pGatekeeper->Unlock();
	}

	// Lock access to the registration object
	g_pGatekeeper->Lock();
	if (g_pReg == 0)
	{
		SPIDER_TRACE(SP_THREAD, "PostReceive thread exiting\n", 0);
		g_pGatekeeper->Unlock();
		return;
	}
	if (hResult != GKI_REDISCOVER)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
	}
	else
		g_pReg->SetRcvThread(0);

	SPIDER_TRACE(SP_THREAD, "PostReceive thread exiting\n", 0);
	g_pGatekeeper->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931asn1.h ===
#ifndef _Q931_ASN1_H_
#define _Q931_ASN1_H_

#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif


// H310Caps, H320Caps, H321Caps, H322Caps, H323Caps, H324Caps, VoiceCaps, T120OnlyCaps, McuInfo, TerminalInfo, GatekeeperInfo
#define GtkprInf_nnStndrdDt_present     H310Caps_nonStandardData_present
#define GtkprInf_nnStndrdDt             nonStandardData

// GatewayInfo
#define GtwyInf_nonStandardData_present GatewayInfo_nonStandardData_present
#define GtwyInf_nonStandardData         nonStandardData

// EndpointType
#define EndpntTyp_nnStndrdDt_present    EndpointType_nonStandardData_present
#define EndpntTyp_nnStndrdDt            nonStandardData


// CallProceeding_UUIE, Alerting_UUIE
#define CPg_UUIE_h245Addrss_present     CallProceeding_UUIE_h245Address_present
#define CPg_UUIE_h245Addrss             h245Address

// Connect_UUIE
#define Cnnct_UUIE_h245Address_present  Connect_UUIE_h245Address_present
#define Cnnct_UUIE_h245Address          h245Address

// ReleaseCompleteReason
#define RlsCmpltRsn_undfndRsn_chosen    ReleaseCompleteReason_undefinedReason_chosen

// FacilityReason
#define FcltyRsn_undefinedReason_chosen FacilityReason_undefinedReason_chosen

// H323_UU_PDU
#define H323_UU_PDU_nnStndrdDt_present  H323_UU_PDU_nonStandardData_present
#define H323_UU_PDU_nnStndrdDt          nonStandardData


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _Q931_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.49  $
 *	$Date:   08 Jan 1997 18:02:54  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef Q931_H
#define Q931_H


#include "incommon.h"
#include "q931pdu.h"
#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

//====================================================================================
// Q931-specific codes
//====================================================================================

// Status codes
#define CS_OK                               NOERROR
#define CS_BAD_PARAM                        MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x1)
#define CS_DUPLICATE_LISTEN                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x2)
#define CS_INTERNAL_ERROR                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x3)
#define CS_BAD_SIZE                         MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x4)
#define CS_NO_MEMORY                        MAKE_Q931_ERROR(ERROR_OUTOFMEMORY)
#define CS_NOT_IMPLEMENTED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x6)
#define CS_NOT_INITIALIZED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x7)
#define CS_DUPLICATE_INITIALIZE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x8)
#define CS_SUBSYSTEM_FAILURE                MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x9)
#define CS_OUT_OF_SEQUENCE                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xA)
#define CS_PEER_UNREACHABLE                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xB)
#define CS_SETUP_TIMER_EXPIRED              MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xC)
#define CS_RINGING_TIMER_EXPIRED            MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xD)
#define CS_INCOMPATIBLE_VERSION             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xE)

// parsing error cases
#define CS_OPTION_NOT_IMPLEMENTED           MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xF)
#define CS_ENDOFINPUT                       MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x10)
#define CS_INVALID_FIELD                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x11)
#define CS_NO_FIELD_DATA                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x12)
#define CS_INVALID_PROTOCOL                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x13)
#define CS_INVALID_MESSAGE_TYPE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x14)
#define CS_MANDATORY_IE_MISSING             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x15)
#define CS_BAD_IE_CONTENT                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x16)

// Event codes
#define Q931_CALL_INCOMING                  1
#define Q931_CALL_REMOTE_HANGUP             2
#define Q931_CALL_REJECTED                  3
#define Q931_CALL_ACCEPTED                  4
#define Q931_CALL_RINGING                   5
#define Q931_CALL_FAILED                    6
#define Q931_CALL_CONNECTION_CLOSED         7

// Goal codes
#define CSG_NONE                            0
#define CSG_JOIN                            1
#define CSG_CREATE                          2
#define CSG_INVITE                          3

#define CC_MAX_PARTY_NUMBER_LEN             254

//====================================================================================
// Q931-specific types
//====================================================================================

typedef HRESULT CS_STATUS;
typedef DWORD_PTR HQ931LISTEN, *PHQ931LISTEN;
typedef DWORD_PTR HQ931CALL, *PHQ931CALL;


//====================================================================================
// Callback definitions.
//====================================================================================

typedef DWORD (*Q931_CALLBACK) (BYTE bEvent, HQ931CALL hQ931Call,
    HQ931LISTEN hListenToken, DWORD_PTR dwUserToken, void *pEventData);

typedef BOOL (*Q931_RECEIVE_PDU_CALLBACK) (Q931MESSAGE *pMessage,
    HQ931CALL hQ931Call, DWORD_PTR dwListenToken, DWORD_PTR dwUserToken);

//====================================================================================
// definitions of structures passed to callbacks as parameters.
//====================================================================================

// CSS_CALL_INCOMING callback parameter type
typedef struct
{
    WORD wCallReference;
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;
    LPWSTR pszCalledPartyNumber;
    PCC_ADDR pSourceAddr;
    PCC_ADDR pCallerAddr;
    PCC_ADDR pCalleeDestAddr;
    PCC_ADDR pLocalAddr;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pSourceEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
    GUID CallIdentifier;
} CSS_CALL_INCOMING, *PCSS_CALL_INCOMING;

// CSS_CALL_REMOTE_HANGUP callback parameter type
typedef struct
{
    BYTE bReason;
} CSS_CALL_REMOTE_HANGUP, *PCSS_CALL_REMOTE_HANGUP;


// CSS_CALL_REJECTED callback parameter type
typedef struct
{
    BYTE bRejectReason;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pAlternateAddr;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_REJECTED, *PCSS_CALL_REJECTED;

// CSS_CALL_ACCEPTED callback parameter type
typedef struct
{
    WORD wCallReference;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pCalleeAddr;
    PCC_ADDR pLocalAddr;
    PCC_ADDR pH245Addr;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pDestinationEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_ACCEPTED, *PCSS_CALL_ACCEPTED;

// Q931_CALL_RINGING callback event will have pEventData set to NULL

// CSS_CALL_FAILED callback paremeter type
typedef struct
{
    HRESULT error;
} CSS_CALL_FAILED, *PCSS_CALL_FAILED;

//====================================================================================
// function declarations.
//====================================================================================

CS_STATUS H225Init();
CS_STATUS H225DeInit();

CS_STATUS Q931Init();
CS_STATUS Q931DeInit();

CS_STATUS Q931Listen(
    PHQ931LISTEN phQ931Listen,
    PCC_ADDR pListenAddr,
    DWORD_PTR dwListenToken,
    Q931_CALLBACK ListenCallback);

CS_STATUS Q931CancelListen(
    HQ931LISTEN hQ931Listen);

CS_STATUS Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD_PTR dwUserToken,
    Q931_CALLBACK ConnectCallback,
    WORD wCRV,
    LPGUID pCallIdentifier);

CS_STATUS Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason);

CS_STATUS Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV);

CS_STATUS Q931AcceptCall(
    HQ931CALL hQ931Call,
    LPWSTR pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_ADDR pH245Addr,
    DWORD_PTR dwUserToken);

CS_STATUS Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931ReOpenConnection(
    HQ931CALL hQ931Call);

CS_STATUS Q931GetVersion(
    WORD wLength,          // character count, not byte count.
    LPWSTR pszVersion);

CS_STATUS Q931SetAlertingTimeout(
    DWORD dwDuration);

void Q931SetReceivePDUHook(
    Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback);

CS_STATUS Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931SendPDU(
    HQ931CALL hQ931Call,
    BYTE* CodedPtrPDU,
    DWORD CodedLengthPDU);

CS_STATUS Q931FlushSendQueue(
    HQ931CALL hQ931Call);

// utility routines
CS_STATUS Q931ValidateAddr(PCC_ADDR pAddr);
CS_STATUS Q931ValidatePartyNumber(LPWSTR pszPartyNumber);

CS_STATUS Q931ValidateAliasItem(PCC_ALIASITEM pSource);
CS_STATUS Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource);
CS_STATUS Q931FreeAliasItem(PCC_ALIASITEM pSource);

CS_STATUS Q931ValidateAliasNames(PCC_ALIASNAMES pSource);
CS_STATUS Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
CS_STATUS Q931FreeAliasNames(PCC_ALIASNAMES pSource);

CS_STATUS Q931ValidateDisplay(LPWSTR pszDisplay);
CS_STATUS Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource);
CS_STATUS Q931FreeDisplay(LPWSTR pszDisplay);

CS_STATUS Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo);
CS_STATUS Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource);
CS_STATUS Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo);

CS_STATUS Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);
CS_STATUS Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource);
CS_STATUS Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);

#ifdef __cplusplus
}
#endif

#endif Q931_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931man.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/q931man.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.138  $
 *	$Date:   04 Mar 1997 09:43:22  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "h245man.h"
#include "linkapi.h"
#include "ccutils.h"


extern CALL_CONTROL_STATE	CallControlState;
extern THREADCOUNT			ThreadCount;
extern CC_CONFERENCEID		InvalidConferenceID;


HRESULT InitQ931Manager()
{
	return CC_OK;
}



HRESULT DeInitQ931Manager()
{
	return CC_OK;
}



DWORD _GenerateListenCallback(		PLISTEN					pListen,
									HQ931CALL				hQ931Call,
									PCSS_CALL_INCOMING		pCallIncomingData)
{
HRESULT						status;
CC_HLISTEN					hListen;
CC_LISTEN_CALLBACK_PARAMS	ListenCallbackParams;
PCALL						pCall;
CC_HCALL					hCall;

	ASSERT(pListen != NULL);
	ASSERT(pCallIncomingData != NULL);

	hListen = pListen->hListen;

	status = AllocAndLockCall(
		&hCall,							// pointer to call handle
		CC_INVALID_HANDLE,				// conference handle
		hQ931Call,						// Q931 call handle
		CC_INVALID_HANDLE,				// Q931 call handle for third party invitor
		pCallIncomingData->pCalleeAliasList,
		pCallIncomingData->pCallerAliasList,
		NULL,							// pPeerExtraAliasNames
		NULL,							// pPeerExtension
		NULL,							// local non-standard data
		pCallIncomingData->pNonStandardData,	// remote non-standard data
		NULL,							// local display value
		pCallIncomingData->pszDisplay,	// remote display value
		pCallIncomingData->pSourceEndpointType->pVendorInfo,// remote vendor info
		pCallIncomingData->pLocalAddr,	// local address
		pCallIncomingData->pCallerAddr,	// connect address
		NULL,							// destination address
		pCallIncomingData->pSourceAddr, // source call signal address
		CALLEE,							// call direction
		pCallIncomingData->bCallerIsMC,
		0,								// user token; user will specify in AcceptRejectCall
		INCOMING,						// initial call state
		&pCallIncomingData->CallIdentifier, // H225 CallIdentifier
		&pCallIncomingData->ConferenceID,	// conference ID
		&pCall);						// pointer to call object

	if (status != CC_OK) {
		UnlockListen(pListen);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}	

	// Map from Q.931 goals to Call Control goals
	switch (pCallIncomingData->wGoal) {
		case CSG_JOIN:
			ListenCallbackParams.wGoal = CC_GOAL_JOIN;
			break;
		case CSG_CREATE:
			ListenCallbackParams.wGoal = CC_GOAL_CREATE;
			break;
		case CSG_INVITE:
			ListenCallbackParams.wGoal = CC_GOAL_INVITE;
			break;
	}

	ListenCallbackParams.hCall = hCall;
	ListenCallbackParams.pCallerAliasNames = pCallIncomingData->pCallerAliasList;
	ListenCallbackParams.pCalleeAliasNames = pCallIncomingData->pCalleeAliasList;
	ListenCallbackParams.pNonStandardData = pCallIncomingData->pNonStandardData;
	ListenCallbackParams.pszDisplay = pCallIncomingData->pszDisplay;
	ListenCallbackParams.pVendorInfo = pCallIncomingData->pSourceEndpointType->pVendorInfo;
	ListenCallbackParams.ConferenceID = pCallIncomingData->ConferenceID;
	ListenCallbackParams.pCallerAddr = pCallIncomingData->pCallerAddr;
	ListenCallbackParams.pCalleeAddr = pCallIncomingData->pLocalAddr;
	ListenCallbackParams.dwListenToken = pListen->dwListenToken;

	UnlockCall(pCall);

	// Invoke the user callback -- the listen object is locked during the callback,
	// but the associated call object is unlocked (to prevent deadlock if
	// CC_AcceptCall() or CC_RejectCall() is called during the callback from a
	// different thread, and the callback thread blocks pending completion of
	// CC_AcceptCall() or CC_RejectCall())
	InvokeUserListenCallback(pListen,
							 CC_OK,
							 &ListenCallbackParams);

	// Need to validate the listen handle; the associated object may have been
	// deleted during the user callback by this thread
	if (ValidateListen(hListen) == CC_OK)
		UnlockListen(pListen);

	status = LockCall(hCall, &pCall);
	if ((status == CC_OK) && (pCall->CallState == INCOMING)) {
		UnlockCall(pCall);
		return 0;	// cause a ringing condition to occur
	} else {
		// call object has been deleted, or exists in a non-incoming state
		if (status == CC_OK)
			// call object exists in a non-incoming state; AcceptRejectCall
			// may have been invoked from the user callback
			UnlockCall(pCall);
//                return 1;       // don't cause a ringing condition to occur
	}
			
//        // We should never reach this point
//        ASSERT(0);
	return 1;
}



DWORD _Q931CallIncoming(			HQ931CALL				hQ931Call,
									CC_HLISTEN				hListen,
									PCSS_CALL_INCOMING		pCallIncomingData)
{
HRESULT						status;
PLISTEN						pListen;
PCONFERENCE					pConference;
PCALL						pCall;
CC_HCALL					hCall;

	ASSERT(hListen != CC_INVALID_HANDLE);
	ASSERT(pCallIncomingData != NULL);
	ASSERT(!EqualConferenceIDs(&pCallIncomingData->ConferenceID, &InvalidConferenceID));

	if ((pCallIncomingData->wGoal != CSG_CREATE) &&
		(pCallIncomingData->wGoal != CSG_JOIN) &&
		(pCallIncomingData->wGoal != CSG_INVITE)) {
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}

	status = LockListen(hListen, &pListen);
	if (status != CC_OK) {
		// the listen was presumably cancelled by the user,
		// but we haven't informed Call Setup yet
		Q931RejectCall(hQ931Call,				// Q931 call handle
			           CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}

	// Look for wConferenceID in conference list
	status = LockConferenceID(&pCallIncomingData->ConferenceID, &pConference);
	if (status == CC_OK) {
		// We found a matching conference ID
		if ((pConference->bDeferredDelete) &&
			((pConference->bAutoAccept == FALSE) ||
			 ((pConference->tsMultipointController == TS_TRUE) &&
			 (pCallIncomingData->bCallerIsMC == TRUE)))) {
			UnlockListen(pListen);
			UnlockConference(pConference);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &pCallIncomingData->ConferenceID,
						   NULL,					// alternate address
						   NULL);					// non-standard data
			return 1;
		} else {
			if (pConference->tsMultipointController == TS_TRUE) {
				if ((pCallIncomingData->pCalleeDestAddr == NULL) ||
					((pCallIncomingData->pCalleeDestAddr != NULL) &&
					 (EqualAddrs(pCallIncomingData->pLocalAddr,
					             pCallIncomingData->pCalleeDestAddr)))) {
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_JOIN:
							if ((pConference->bDeferredDelete) &&
								(pConference->bAutoAccept == TRUE)) {
								// Auto accept
								status = AllocAndLockCall(
									&hCall,							// pointer to call handle
									pConference->hConference,		// conference handle
									hQ931Call,						// Q931 call handle
									CC_INVALID_HANDLE,				// Q931 call handle for third party invitor
									pCallIncomingData->pCalleeAliasList,
									pCallIncomingData->pCallerAliasList,
									NULL,							// pPeerExtraAliasNames
									NULL,							// pPeerExtension
									NULL,							// local non-standard data
									pCallIncomingData->pNonStandardData,	// remote non-standard data
									NULL,							// local display value
									pCallIncomingData->pszDisplay,	// remote display value
									pCallIncomingData->pSourceEndpointType->pVendorInfo,// remote vendor info
									pCallIncomingData->pLocalAddr,	// local address
									pCallIncomingData->pCallerAddr,	// connect address
									NULL,							// destination address
									pCallIncomingData->pSourceAddr, // source call signal address
									CALLEE,							// call type
									pCallIncomingData->bCallerIsMC,
									0,								// user token; user will specify in AcceptRejectCall
									INCOMING,						// initial call state
									&pCallIncomingData->CallIdentifier,  // h225 CallIdentifier
									&pCallIncomingData->ConferenceID,	// conference ID
									&pCall);						// pointer to call object

								if (status != CC_OK) {
									UnlockListen(pListen);
									UnlockConference(pConference);
									Q931RejectCall(hQ931Call,				// Q931 call handle
												   CC_REJECT_UNDEFINED_REASON,	// reject reason
												   &pCallIncomingData->ConferenceID,
												   NULL,					// alternate address
												   NULL);					// non-standard data
									return 1;
								}
								
								AcceptCall(pCall, pConference);
								return 1;	// Don't send back a RINGING indication
							} else {
								UnlockConference(pConference);
								return _GenerateListenCallback(pListen,
															   hQ931Call,
															   pCallIncomingData);
							}
						case CSG_INVITE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_IN_CONF,		// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
					} // switch (wGoal)
				} else { // connect addr != destination addr
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
						case CSG_JOIN:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_INVITE:
							// 3rd party invite
							if (pCallIncomingData->bCallerIsMC == TRUE) {
								UnlockListen(pListen);
								UnlockConference(pConference);
								Q931RejectCall(hQ931Call,				// Q931 call handle
											   CC_REJECT_UNDEFINED_REASON,	// reject reason
											   &pCallIncomingData->ConferenceID,
											   NULL,					// alternate address
											   NULL);					// non-standard data
								return 1;
							}
							status = AllocAndLockCall(
								&hCall,							// pointer to call handle
								pConference->hConference,		// conference handle
								CC_INVALID_HANDLE,				// Q931 call handle
								hQ931Call,						// Q931 call handle for third party invitor
								pCallIncomingData->pCallerAliasList, // local alias names
								pCallIncomingData->pCalleeAliasList, // remote alias names
								NULL,							// pPeerExtraAliasNames
								NULL,							// pPeerExtension
								pCallIncomingData->pNonStandardData, // local non-standard data
								NULL,							// remote non-standard data
								pCallIncomingData->pszDisplay,	// local display value
								NULL,							// remote display value
								NULL,							// remote vendor info
								NULL,							// local address
								pCallIncomingData->pCalleeDestAddr,	// connect address
								pCallIncomingData->pCalleeDestAddr,	// destination address
								pCallIncomingData->pSourceAddr, // source call signal address
								THIRD_PARTY_INTERMEDIARY,			// call type
								TRUE,							// caller (this endpoint) is MC
								0,								// user token; user will specify in AcceptRejectCall
								PLACED,							// initial call state
								&pCallIncomingData->CallIdentifier,  // h225 CallIdentifier
								&pCallIncomingData->ConferenceID,	// conference ID
								&pCall);						// pointer to call object

							if (status != CC_OK) {
								UnlockListen(pListen);
								UnlockConference(pConference);
								Q931RejectCall(hQ931Call,				// Q931 call handle
											   CC_REJECT_UNDEFINED_REASON,	// reject reason
											   &pCallIncomingData->ConferenceID,
											   NULL,					// alternate address
											   NULL);					// non-standard data
								return 1;
							}
							PlaceCall(pCall, pConference);
							UnlockCall(pCall);
							UnlockConference(pConference);
							return 1;	// Don't send back a RINGING indication
					} // switch (wGoal)
				}
			} else { // pConference->tsMultipointController != TS_TRUE
				if ((pCallIncomingData->pCalleeDestAddr == NULL) ||
					((pCallIncomingData->pCalleeDestAddr != NULL) &&
					 (EqualAddrs(pCallIncomingData->pLocalAddr,
					             pCallIncomingData->pCalleeDestAddr)))) {
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_JOIN:
						case CSG_INVITE:
							UnlockConference(pConference);
							return _GenerateListenCallback(pListen,
														   hQ931Call,
														   pCallIncomingData);
					} // switch (wGoal)
				} else { // connect addr != destination addr
					UnlockListen(pListen);
					UnlockConference(pConference);
					Q931RejectCall(hQ931Call,				// Q931 call handle
								   CC_REJECT_UNDEFINED_REASON,	// reject reason
								   &pCallIncomingData->ConferenceID,
								   NULL,					// alternate address
								   NULL);					// non-standard data
					return 1;
				} // connect addr != destination addr
			} // pConference->tsMultipointController != TS_TRUE
		} // Matching conference ID
	} else if (status == CC_BAD_PARAM) {
		// This is OK; it simply means that we did not find a matching conference ID
		if (((pCallIncomingData->pCalleeDestAddr != NULL) &&
			(EqualAddrs(pCallIncomingData->pLocalAddr,
					    pCallIncomingData->pCalleeDestAddr))) ||
		    (pCallIncomingData->pCalleeDestAddr == NULL)) {
				return _GenerateListenCallback(pListen,
											   hQ931Call,
											   pCallIncomingData);
		} else { // connect addr != destination addr
			UnlockListen(pListen);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &pCallIncomingData->ConferenceID,
						   NULL,					// alternate address
						   NULL);					// non-standard data
			return 1;
		}
	} else { // fatal error in LockConference
		UnlockListen(pListen);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;	
	}
	
	// We should never reach this point
	ASSERT(0);
	return 1;
}



DWORD _Q931CallRemoteHangup(		HQ931CALL				hQ931Call,
									CC_HLISTEN				hListen,
									CC_HCALL				hCall)
{
CC_LISTEN_CALLBACK_PARAMS	ListenCallbackParams;
PCALL						pCall;
PLISTEN						pListen;

	if (hCall == CC_INVALID_HANDLE) {
		// Either we've already informed the user of the hangup,
		// or the user has not yet accepted or rejected the incoming
		// call request
		ASSERT(hListen != CC_INVALID_HANDLE);

		if (LockQ931Call(hCall, hQ931Call, &pCall) != CC_OK)
			return 0;

		hCall = pCall->hCall;

		if (pCall->hConference != CC_INVALID_HANDLE) {
			UnlockCall(pCall);
			// XXX -- need bHangupReason
			ProcessRemoteHangup(hCall, hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			return 0;
		}

		if (LockListen(hListen, &pListen) != CC_OK) {
			FreeCall(pCall);
			return 0;
		}

		MarkCallForDeletion(pCall);

		ListenCallbackParams.hCall = pCall->hCall;
		ListenCallbackParams.pCallerAliasNames = pCall->pPeerAliasNames;
		ListenCallbackParams.pCalleeAliasNames = pCall->pLocalAliasNames;
		ListenCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
		ListenCallbackParams.pszDisplay = pCall->pszPeerDisplay;
		ListenCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
		ListenCallbackParams.wGoal = CC_GOAL_CREATE;	// igonred in this callback
		ListenCallbackParams.ConferenceID = pCall->ConferenceID;
		ListenCallbackParams.pCallerAddr = pCall->pQ931PeerConnectAddr;
		ListenCallbackParams.pCalleeAddr = pCall->pQ931LocalConnectAddr;
		ListenCallbackParams.dwListenToken = pListen->dwListenToken;

		InvokeUserListenCallback(pListen,
		                         CC_PEER_CANCEL,
								 &ListenCallbackParams);

		// Need to validate the listen and call handles; the associated objects may
		// have been deleted during the user callback by this thread
		if (ValidateListen(hListen) == CC_OK)
			UnlockListen(pListen);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
	} else
		// XXX -- need bHangupReason
		ProcessRemoteHangup(hCall, hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);

	return 0;
}



DWORD _Q931CallRejected(			HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_REJECTED		pCallRejectedData)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
HQ931CALL					hQ931CallInvitor;
CC_ENDPOINTTYPE				SourceEndpointType;
CALLTYPE					CallType;
CC_CONFERENCEID				ConferenceID;
CC_ADDR						SourceAddr;
WORD						wNumCalls;
WORD                        wQ931Goal;
WORD                        wQ931CallType;

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	ConferenceID = pCall->ConferenceID;

	if ((pCall->hQ931Call != hQ931Call) ||
		((pCall->CallState != PLACED) && (pCall->CallState != RINGING))) {
		// The peer must be in a bad state; we don't expect to receive this message now
		UnlockCall(pCall);
		return 0;
	}

	if (CallType == THIRD_PARTY_INTERMEDIARY) {
		hQ931CallInvitor = pCall->hQ931CallInvitor;
		FreeCall(pCall);
		if (hQ931CallInvitor != CC_INVALID_HANDLE)
			Q931RejectCall(hQ931CallInvitor,
						   pCallRejectedData->bRejectReason,
						   &ConferenceID,
						   NULL,	// alternate address
						   NULL);	// non-standard data
		return 0;
	}

	if (pCall->hConference == CC_INVALID_HANDLE) {
		// Call is not attached to a conference
		FreeCall(pCall);
		return 0;
	}

	UnlockCall(pCall);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	ConnectCallbackParams.pNonStandardData = pCallRejectedData->pNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = NULL;
	ConnectCallbackParams.bRejectReason = pCallRejectedData->bRejectReason;
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;	
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;

	if (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC)
    {
		ConnectCallbackParams.bMultipointConference = TRUE;
        wQ931Goal = CSG_JOIN;
        wQ931CallType = CC_CALLTYPE_N_N;
    }
	else
    {
        // Goal and CallType need to be changed for multipoint support.
		ConnectCallbackParams.bMultipointConference = FALSE;
        wQ931Goal = CSG_CREATE;
        wQ931CallType = CC_CALLTYPE_PT_PT;
    }
	ConnectCallbackParams.pConferenceID = &pCallRejectedData->ConferenceID;
	if (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC)
		ConnectCallbackParams.pMCAddress = pCallRejectedData->pAlternateAddr;
	else
		ConnectCallbackParams.pMCAddress = NULL;
	ConnectCallbackParams.pAlternateAddress = pCallRejectedData->pAlternateAddr;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	if (((pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC) ||
		 (pCallRejectedData->bRejectReason == CC_REJECT_CALL_FORWARDED) ||
		 (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER)) &&
		(EqualConferenceIDs(&pCallRejectedData->ConferenceID, &pCall->ConferenceID)) &&
		(pCallRejectedData->pAlternateAddr != NULL)) {
		// XXX - In order to be H.323 compliant here, we need to re-permission this call
		// through the gatekeeper because:
		// 1. The rerouted call may be going to another gatekeeper zone.
		// 2. The alternate address may be NULL, and we may have to resolve the
		//    alternate alias name list through the gatekeeper
		SourceEndpointType.pVendorInfo = pConference->pVendorInfo;
		SourceEndpointType.bIsTerminal = TRUE;
		SourceEndpointType.bIsGateway = FALSE;

		// Cause our local Q.931 connect address to be placed in the
		// Q.931 setup-UUIE sourceAddress field
		SourceAddr.nAddrType = CC_IP_BINARY;
		SourceAddr.bMulticast = FALSE;
		SourceAddr.Addr.IP_Binary.dwAddr = 0;
		SourceAddr.Addr.IP_Binary.wPort = 0;

		status = Q931PlaceCall(&pCall->hQ931Call,			// Q931 call handle
			                   pCall->pszLocalDisplay,
			                   pCall->pLocalAliasNames,
							   pCall->pPeerAliasNames,
                               pCall->pPeerExtraAliasNames,	// pExtraAliasList
                               pCall->pPeerExtension,		// pExtensionAliasItem
			                   pCall->pLocalNonStandardData,// non-standard data
							   &SourceEndpointType,
                               NULL,						// pszCalledPartyNumber
							   pCallRejectedData->pAlternateAddr, // connect address
							   pCall->pQ931DestinationAddr,	// destination address
							   NULL,						// source address
							   FALSE,						// bIsMC
							   &pCall->ConferenceID,		// conference ID
							   wQ931Goal,					// goal
							   wQ931CallType,				// call type
							   hCall,						// user token
							   (Q931_CALLBACK)Q931Callback,	// callback
#ifdef GATEKEEPER
                               pCall->GkiCall.usCRV,        // CRV
                               &pCall->CallIdentifier);     // H.225 CallIdentifier
#else
                               0,                           // CRV
                               &pCall->CallIdentifier);     // H.225 CallIdentifier
#endif GATEKEEPER
		if (status != CS_OK) {
			MarkCallForDeletion(pCall);
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

			if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
				FreeCall(pCall);

			if (ValidateConference(hConference) != CC_OK)
				return 0;

			for ( ; ; ) {
				// Start up an enqueued call, if one exists
				status = RemoveEnqueuedCallFromConference(pConference, &hCall);
				if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
					break;

				status = LockCall(hCall, &pCall);
				if (status == CC_OK) {
					pCall->CallState = PLACED;

					status = PlaceCall(pCall, pConference);
					UnlockCall(pCall);
					if (status == CC_OK)
						break;
				}
			}
			return 0;
		}
		UnlockCall(pCall);
		UnlockConference(pConference);
		return 0;
	}

	MarkCallForDeletion(pCall);

	if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
		((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_PEER_REJECT,
									 &ConnectCallbackParams);
	}
	
	if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
		FreeCall(pCall);

	// Need to validate conference handle; the associated object may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) != CC_OK)
		return 0;

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}
	
	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	return 0;
}



DWORD _Q931CallAccepted(			HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_ACCEPTED		pCallAcceptedData)
{
HRESULT						status;
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
BYTE						bTerminalType;
BOOL						bMultipointConference;
CALLTYPE					CallType;
HQ931CALL					hQ931CallInvitor;
H245_INST_T					H245Instance;
DWORD                       dwLinkLayerPhysicalId;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	hConference = pConference->hConference;
	hQ931Call = pCall->hQ931Call;
	hQ931CallInvitor = pCall->hQ931CallInvitor;

	ASSERT((pCall->hQ931Call == hQ931Call) || (pCall->hQ931CallInvitor == hQ931Call));

	if ((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		(pConference->ConferenceMode == MULTIPOINT_MODE))
		bMultipointConference = TRUE;
	else
		bMultipointConference = FALSE;

	// Initialize ConnectCallbackParams
	ConnectCallbackParams.pNonStandardData = pCallAcceptedData->pNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = pCallAcceptedData->pszDisplay;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;	// field ignored
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	ConnectCallbackParams.pPeerAddr = pCallAcceptedData->pCalleeAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = bMultipointConference;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	if (pCallAcceptedData->pCalleeAddr) {
		// Set pCall->pQ931DestinationAddr to the destination address that we got from Q931.
		// Note that we may not current have a destination address (if the client didn't
		// specify one), or we may currently have a destination address	in domain name format
		// which we need to change to binary format
		if (pCall->pQ931DestinationAddr == NULL)
			pCall->pQ931DestinationAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if (pCall->pQ931DestinationAddr != NULL)
			*pCall->pQ931DestinationAddr = *pCallAcceptedData->pCalleeAddr;
	}

	if ((!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) &&
		(!EqualConferenceIDs(&pConference->ConferenceID, &pCallAcceptedData->ConferenceID))) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_INTERNAL_ERROR,
											 &ConnectCallbackParams);
		}
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return 0;
	}

	pConference->ConferenceID = pCallAcceptedData->ConferenceID;
	pCall->ConferenceID = pCallAcceptedData->ConferenceID;
	// Copy the newly-supplied peer address into the call object.
	// This is preferable if the original peer address was in IP dot
	// or domain name format
	if (CallType != THIRD_PARTY_INVITOR) {
		if (pCallAcceptedData->pCalleeAddr != NULL) {
			if (pCall->pQ931DestinationAddr == NULL)
				pCall->pQ931DestinationAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pCall->pQ931DestinationAddr != NULL)
				*pCall->pQ931DestinationAddr = *pCallAcceptedData->pCalleeAddr;
		}
		
		if (pCallAcceptedData->pLocalAddr != NULL) {
			if (pCall->pQ931LocalConnectAddr == NULL)
				pCall->pQ931LocalConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pCall->pQ931LocalConnectAddr != NULL)
				*pCall->pQ931LocalConnectAddr = *pCallAcceptedData->pLocalAddr;
		}
	}

	ASSERT(pCall->pPeerNonStandardData == NULL);
	CopyNonStandardData(&pCall->pPeerNonStandardData,
		                pCallAcceptedData->pNonStandardData);

	ASSERT(pCall->pszPeerDisplay == NULL);
	CopyDisplay(&pCall->pszPeerDisplay,
		        pCallAcceptedData->pszDisplay);

	ASSERT(pCall->pPeerVendorInfo == NULL);
	CopyVendorInfo(&pCall->pPeerVendorInfo,
	               pCallAcceptedData->pDestinationEndpointType->pVendorInfo);

	if (CallType == THIRD_PARTY_INVITOR) {
		pCall->CallState = CALL_COMPLETE;
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
		MarkCallForDeletion(pCall);
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_OK,
									 &ConnectCallbackParams);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	pCall->CallState = TERMCAP;

	status = MakeH245PhysicalID(&pCall->dwH245PhysicalID);
	if (status != CC_OK) {
		
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 status,
											 &ConnectCallbackParams);
		}
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

    //MULTITHREAD
    //Use a tmp ID so we don't clobber the chosen H245Id.
    //   H245Id=>
    //   <= linkLayerId
    dwLinkLayerPhysicalId = INVALID_PHYS_ID;

	SetTerminalType(pConference->tsMultipointController, &bTerminalType);
	pCall->H245Instance = H245Init(H245_CONF_H323,
                                   pCall->dwH245PhysicalID,
                                   &dwLinkLayerPhysicalId,
								   hCall,
								   (H245_CONF_IND_CALLBACK_T)H245Callback,
								   bTerminalType);
	if (pCall->H245Instance == H245_INVALID_ID) {
		MarkCallForDeletion(pCall);
		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_INTERNAL_ERROR,
											 &ConnectCallbackParams);
		}
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	H245Instance = pCall->H245Instance;

	// XXX -- need to define connect callback routine
    // Send in the Id we got back from H245Init.
    status = linkLayerConnect(dwLinkLayerPhysicalId,
		                      pCallAcceptedData->pH245Addr,
							  NULL);
	if (status != NOERROR) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 status,
											 &ConnectCallbackParams);
		}
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	pCall->bLinkEstablished = TRUE;

	status = SendTermCaps(pCall, pConference);
	if (status != CC_OK) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_NO_MEMORY,
											 &ConnectCallbackParams);
		}
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}
	
	pCall->OutgoingTermCapState = AWAITING_ACK;

	if (pCall->MasterSlaveState == MASTER_SLAVE_NOT_STARTED) {
		status = H245InitMasterSlave(pCall->H245Instance,
			                         pCall->H245Instance);	// returned as dwTransId in the callback
		if (status != H245_ERROR_OK) {

			MarkCallForDeletion(pCall);

			if (CallType == THIRD_PARTY_INTERMEDIARY) {
				if (hQ931CallInvitor != CC_INVALID_HANDLE)
					Q931RejectCall(hQ931CallInvitor,
								   CC_REJECT_UNDEFINED_REASON,
								   &pCallAcceptedData->ConferenceID,
								   NULL,	// alternate address
								   pCallAcceptedData->pNonStandardData);
			} else {
				if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			        ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
					InvokeUserConferenceCallback(pConference,
												 CC_CONNECT_INDICATION,
												 status,
												 &ConnectCallbackParams);
			}
			H245ShutDown(H245Instance);
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
				FreeCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return 0;
		}
		pCall->MasterSlaveState = MASTER_SLAVE_IN_PROGRESS;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);
	return 0;
}



DWORD _Q931CallRinging(				HQ931CALL				hQ931Call,
									CC_HCALL				hCall)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
CC_RINGING_CALLBACK_PARAMS	RingingCallbackParams;
CC_CONFERENCEID				ConferenceID;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		Q931RejectCall(hQ931Call,				// Q931 call handle
		               CC_REJECT_UNDEFINED_REASON,	// reject reason
					   NULL,					// conference ID
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 0;
	}

	ConferenceID = pCall->ConferenceID;

	if ((pCall->hQ931Call != hQ931Call) || (pCall->CallState != PLACED)) {
		// The peer must be in a bad state; we don't expect to receive this message now
		UnlockCall(pCall);
		return 0;
	}

	pCall->CallState = RINGING;

	if (pCall->CallType == THIRD_PARTY_INTERMEDIARY) {
		// Send "ringing" indication to pCall->hQ931CallInvitor
		Q931Ringing(pCall->hQ931CallInvitor,
			        NULL);	// pCRV
		UnlockConference(pConference);
		UnlockCall(pCall);
		return 0;
	}

	RingingCallbackParams.pNonStandardData = NULL;
	RingingCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	InvokeUserConferenceCallback(pConference,
		                         CC_RINGING_INDICATION,
								 CC_OK,
								 &RingingCallbackParams);
	
	// Need to validate conference and call handles; the associated objects may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	return 0;
}



DWORD _Q931CallFailed(				HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_FAILED		pCallFailedData)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HQ931CALL					hQ931CallInvitor;
HRESULT						status;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CALLTYPE					CallType;
CC_CONFERENCEID				ConferenceID;
WORD						wNumCalls;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	ConferenceID = pCall->ConferenceID;

	if (pCall->hQ931Call != hQ931Call) {
		UnlockConference(pConference);
		UnlockCall(pCall);
		return 0;
	}

	if (CallType == THIRD_PARTY_INTERMEDIARY) {
		hQ931CallInvitor = pCall->hQ931CallInvitor;
		FreeCall(pCall);
		UnlockConference(pConference);
		if (hQ931CallInvitor != CC_INVALID_HANDLE)
			Q931RejectCall(hQ931CallInvitor,
						   CC_REJECT_UNREACHABLE_DESTINATION,
						   &ConferenceID,
						   NULL,	// alternate address
						   NULL);	// non-standard data
		return 0;
	}

	ConnectCallbackParams.pNonStandardData = NULL;
	ConnectCallbackParams.pszPeerDisplay = NULL;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNREACHABLE_DESTINATION;
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;	
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = FALSE;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = NULL;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	MarkCallForDeletion(pCall);

	if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
	    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 pCallFailedData->error,
									 &ConnectCallbackParams);
	}
	if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
		FreeCall(pCall);
	// Need to validate conference handle; the associated object may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) != CC_OK)
		return 0;

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	return 0;
}



DWORD _Q931CallConnectionClosed(	HQ931CALL				hQ931Call,
									CC_HCALL				hCall)
{
	return 0;
}



DWORD Q931Callback(					BYTE					bEvent,
									HQ931CALL				hQ931Call,
									DWORD_PTR				dwListenToken,
									DWORD_PTR				dwUserToken,
									void *					pEventData)
{
DWORD	dwStatus;

	EnterCallControl();

	if (CallControlState != OPERATIONAL_STATE)
		DWLeaveCallControl(0);

	switch (bEvent) {
		case Q931_CALL_INCOMING:
			dwStatus = _Q931CallIncoming(hQ931Call, (CC_HLISTEN)dwListenToken,
				                         (PCSS_CALL_INCOMING)pEventData);
			break;

		case Q931_CALL_REMOTE_HANGUP:
			dwStatus = _Q931CallRemoteHangup(hQ931Call, (CC_HLISTEN)dwListenToken,
				                             (CC_HCALL)dwUserToken);
			break;

		case Q931_CALL_REJECTED:
			dwStatus =  _Q931CallRejected(hQ931Call, (CC_HCALL)dwUserToken,
				                          (PCSS_CALL_REJECTED)pEventData);
			break;

		case Q931_CALL_ACCEPTED:
			dwStatus =  _Q931CallAccepted(hQ931Call, (CC_HCALL)dwUserToken,
				                          (PCSS_CALL_ACCEPTED)pEventData);
			break;

		case Q931_CALL_RINGING:
			dwStatus =  _Q931CallRinging(hQ931Call, (CC_HCALL)dwUserToken);
			break;

		case Q931_CALL_FAILED:
			dwStatus = _Q931CallFailed(hQ931Call, (CC_HCALL)dwUserToken,
				                       (PCSS_CALL_FAILED)pEventData);
			break;

		case Q931_CALL_CONNECTION_CLOSED:
			dwStatus = _Q931CallConnectionClosed(hQ931Call, (CC_HCALL)dwUserToken);
			break;

		default:
			ASSERT(0);
			dwStatus = 0;
			break;
	}
	DWLeaveCallControl(dwStatus);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931man.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/q931man.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.14  $
 *	$Date:   Aug 12 1996 09:40:40  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitQ931Manager();

HRESULT DeInitQ931Manager();

DWORD Q931Callback(					BYTE					bEvent,
									HQ931CALL				hQ931Call,
									DWORD_PTR				dwListenToken,
									DWORD_PTR				dwUserToken,
									void *					pEventData);



								


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931pdu.h ===
/****************************************************************************
 *
 *  $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931pdu.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1996 Intel Corporation.
 *
 *  $Revision:   1.11  $
 *  $Date:   22 Jan 1997 17:21:04  $
 *  $Author:   MANDREWS  $
 *
 *  Abstract: Parser routines for Q931 PDUs
 *
 ***************************************************************************/
#ifndef Q931PAR_H
#define Q931PAR_H

#include <winerror.h>
#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

struct S_BUFFERDESCR
{
    DWORD Length;
    BYTE *BufferPtr;
};

typedef struct S_BUFFERDESCR BUFFERDESCR;
typedef struct S_BUFFERDESCR *PBUFFERDESCR;

// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_PROGRESS2       0x1F
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E
   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN Present;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN Present;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN Present;
    BYTE Length;
    BYTE Contents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The sending complete element is a single type 2
typedef struct S_SINGLESTRUCT2 SENDCOMPLIE;
typedef struct S_SINGLESTRUCT2 *PSENDCOMPLIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The repeat indicator element is a single type 1
typedef struct S_SINGLESTRUCT1 REPEATIE;
typedef struct S_SINGLESTRUCT1 *PREPEATIE;

// The segmented element is a variable 
typedef struct S_VARSTRUCT SEGMENTEDIE;
typedef struct S_VARSTRUCT *PSEGMENTEDIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The end to end transit delay element is a variable 
typedef struct S_VARSTRUCT ENDTOENDDELAYIE;
typedef struct S_VARSTRUCT *PENDTOENDDELAYIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The reverse charge indication element is a variable 
typedef struct S_VARSTRUCT REVERSECHARGEIE;
typedef struct S_VARSTRUCT *PREVERSECHARGEIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The transit network selection element is a variable 
typedef struct S_VARSTRUCT TRANSITNETIE;
typedef struct S_VARSTRUCT *PTRANSITNETIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209 ((PDTYPE)0x05)

struct S_VARSTRUCT_UU
{
    BOOLEAN Present;
    BYTE ProtocolDiscriminator;
    WORD UserInformationLength;
    BYTE UserInformation[0x1000];   // 4k bytes should be good for now...
};

// The user to user element is a variable 
typedef struct S_VARSTRUCT_UU USERUSERIE;
typedef struct S_VARSTRUCT_UU *PUSERUSERIE;

struct S_PARTY_NUMBER
{
    BOOLEAN Present;
    BYTE NumberType;
    BYTE NumberingPlan;
    BYTE PartyNumberLength;
    BYTE PartyNumbers[MAXVARFIELDLEN];
};

// The called party number element is a variable 
typedef struct S_PARTY_NUMBER CALLEDNUMBERIE;
typedef struct S_PARTY_NUMBER *PCALLEDNUMBERIE;

// Q932 defined message types
#define FACILITYMESSAGETYPE   0x62
#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE CallReference;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    SENDCOMPLIE SendingComplete;
    CONGESTIONIE CongestionLevel;
    REPEATIE RepeatIndicator;
    SEGMENTEDIE SegmentedMessage;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    ENDTOENDDELAYIE EndToEndTransitDelay;
    TRANSITDELAYIE TransitDelay;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CLOSEDUGIE ClosedUserGroup;
    REVERSECHARGEIE ReverseChargeIndication;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    TRANSITNETIE TransitNetworkSelection;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;
};

typedef struct S_MESSAGE Q931MESSAGE;
typedef struct S_MESSAGE *PQ931MESSAGE;

//-------------------------------------------------------------------
// Single routine for parsing Q931 messages
//-------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message);

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//==========================================================
// CAUSE FIELD DEFINITIONS
//==========================================================
#define CAUSE_EXT_BIT                0x80
#define CAUSE_CODING_CCITT           0x00
#define CAUSE_LOCATION_USER          0x00
#define CAUSE_RECOMMENDATION_Q931    0x00

#define CAUSE_VALUE_NORMAL_CLEAR     0x10
#define CAUSE_VALUE_USER_BUSY        0x11
#define CAUSE_VALUE_SECURITY_DENIED  0x12
#define CAUSE_VALUE_NO_ANSWER        0x13   // Callee does not answer
#define CAUSE_VALUE_REJECTED         0x15
#define CAUSE_VALUE_ENQUIRY_RESPONSE 0x1E
#define CAUSE_VALUE_NOT_IMPLEMENTED  0x4F
#define CAUSE_VALUE_INVALID_CRV      0x51
#define CAUSE_VALUE_INVALID_MSG      0x5F
#define CAUSE_VALUE_IE_MISSING       0x60
#define CAUSE_VALUE_IE_CONTENTS      0x64
#define CAUSE_VALUE_TIMER_EXPIRED    0x66

typedef struct _ERROR_MAP
{
    int nErrorCode;
#ifdef UNICODE_TRACE
    LPWSTR pszErrorText;
#else
    LPSTR pszErrorText;
#endif
} ERROR_MAP;

typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *ptr;
} BINARY_STRING;

typedef struct _Q931_SETUP_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    BOOL SourceAddrPresent;
    BOOL CallerAddrPresent;
    BOOL CalleeAddrPresent;
    BOOL CalleeDestAddrPresent;
    CC_ADDR SourceAddr;                // originating addr
    CC_ADDR CallerAddr;                // gk addr
    CC_ADDR CalleeAddr;                // local addr
    CC_ADDR CalleeDestAddr;            // target destination addr
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    GUID CallIdentifier;    // H.225 CallIdentifier
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_SETUP_ASN;

typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BYTE bReason;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_RELEASE_COMPLETE_ASN;

typedef struct _Q931_CONNECT_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BOOL h245AddrPresent;
    CC_ADDR h245Addr;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    GUID CallIdentifier;    // H.225 CallIdentifier

    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_CONNECT_ASN;

typedef struct _Q931_ALERTING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_ALERTING_ASN;

typedef struct _Q931_CALL_PROCEEDING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_CALL_PROCEEDING_ASN;

typedef struct _Q931_FACILITY_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR AlternativeAddr;
    PCC_ALIASNAMES pAlternativeAliasList;
    CC_CONFERENCEID ConferenceID;
    BOOL ConferenceIDPresent;
    BYTE bReason;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_FACILITY_ASN;


//-------------------------------------------------------------------
// Parsing Routines
//-------------------------------------------------------------------

HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData);

HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData);

HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData);

HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData);

HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData);

HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData);

//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------

// routines for the Setup Message:
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Release Complete Message:
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Connect Message:
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Alerting Message:
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Proceeding Message:
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf);

#ifdef __cplusplus
}
#endif

#endif Q931PAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931pdu.c ===
/****************************************************************************
 *
 *    $Archive:   S:/STURGEON/SRC/Q931/VCS/q931pdu.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *    Copyright (c) 1996 Intel Corporation.
 *
 *    $Revision:   1.67.1.0  $
 *    $Date:   17 Mar 1997 19:44:52  $
 *    $Author:   MANDREWS  $
 *
 *    Deliverable:
 *
 *    Abstract: Parser routines for Q931 PDUs
 *
 *    Notes:
 *
 ***************************************************************************/
#pragma comment (exestr, "$Workfile:   q931pdu.c  $ $Revision:   1.67.1.0  $")

// [ ]  Do another integration of own q931test area.
// [ ]  Alias values displayed in tracing routines.
// - - - -  -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// STANDARDS ISSUES
// - - - -  -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// [ ]  !!! EndpointType contains MC info, so Setup_UUIE doesnt need MC field !!!
// [ ]  !!! Need to decide how CallType is to be used !!!
// [ ]  !!! ALERTING message is missing the ConferenceID field !!!
// [ ]  !!! Place needed for Caller and Callee transport addr, or else explanation of how this information is available round-trip !!!
// [ ]  !!! FACILITY message is missing the protocolIdentifier field !!!

//------------------------------------------------------------------------------
// Note:  These parsing details have not yet been supported:
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// 1) variable octet fields having extending groups,
//    extending indications, or escape for extensions. (See 4.5.1)
// 2) codeset recognition and exclusion based on SHIFT (See 4.5.2)
// 3) correct ignoring of escapes for nationally specific message types.
// 4) The call reference value is 2 bytes long sizeof(WORD).
//    A call reference of 0 means, the message pertains to all
//    calls on the same data link.
//------------------------------------------------------------------------------

#pragma warning ( disable : 4100 4115 4201 4214 4514 )

#include "precomp.h"
#include <string.h>

#include "h225asn.h"
#include "q931asn1.h"

#include "common.h"
#include "q931.h"
#include "isrg.h"

#include "utils.h"
#include "q931pdu.h"

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif


//==========================================================
// CALLED PARTY FIELD DEFINITIONS
//==========================================================
// called party encoding bits...
#define CALLED_PARTY_EXT_BIT        0x80

// called party number type
#define CALLED_PARTY_TYPE_UNKNOWN   0x00
        // ...other types are not defined because they are not used...

// called party numbering plan
#define CALLED_PARTY_PLAN_E164      0x01
        // ...other plans are not defined because they are not used...
 


//==========================================================
// BEARER FIELD DEFINITIONS
//==========================================================
// bearer encoding bits...
#define BEAR_EXT_BIT                0x80

// bearer coding standards...
#define BEAR_CCITT                  0x00
        // ...others not needed...

// bearer information transfer capability...
#define BEAR_UNRESTRICTED_DIGITAL   0x08
        // ...others not needed...

// bearer transfer mode...
#define BEAR_PACKET_MODE            0x40
        // ...others not needed...

// bearer information transfer rate...
#define BEAR_NO_CIRCUIT_RATE        0x00
        // ...others not needed...

// bearer layer1 protocol...
#define BEAR_LAYER1_INDICATOR       0x20
#define BEAR_LAYER1_H221_H242       0x05
        // ...others not needed...

static struct ObjectID_ ProtocolId1;
static struct ObjectID_ ProtocolId2;
static struct ObjectID_ ProtocolId3;
static struct ObjectID_ ProtocolId4;
static struct ObjectID_ ProtocolId5;
static struct ObjectID_ ProtocolId6;

static struct GatewayInfo_protocol TempProtocol;

MESSAGEIDTYPE MessageSet[] =
{
    ALERTINGMESSAGETYPE,
    PROCEEDINGMESSAGETYPE,
    CONNECTMESSAGETYPE,
    CONNECTACKMESSAGETYPE,
    PROGRESSMESSAGETYPE,
    SETUPMESSAGETYPE,
    SETUPACKMESSAGETYPE,

    RESUMEMESSAGETYPE,
    RESUMEACKMESSAGETYPE,
    RESUMEREJMESSAGETYPE,
    SUSPENDMESSAGETYPE,
    SUSPENDACKMESSAGETYPE,
    SUSPENDREJMESSAGETYPE,
    USERINFOMESSAGETYPE,

    DISCONNECTMESSAGETYPE,
    RELEASEMESSAGETYPE,
    RELEASECOMPLMESSAGETYPE,
    RESTARTMESSAGETYPE,
    RESTARTACKMESSAGETYPE,

    SEGMENTMESSAGETYPE,
    CONGCTRLMESSAGETYPE,
    INFORMATIONMESSAGETYPE,
    NOTIFYMESSAGETYPE,
    STATUSMESSAGETYPE,
    STATUSENQUIRYMESSAGETYPE,

    FACILITYMESSAGETYPE
};


#define Q931_PROTOCOL_ID1           0
#define Q931_PROTOCOL_ID2           0
#define Q931_PROTOCOL_ID3           8
#define Q931_PROTOCOL_ID4           2250
#define Q931_PROTOCOL_ID5           0
//#define Q931_PROTOCOL_ID6           1
#define Q931_PROTOCOL_ID6           2       // H.225 version 2!

VOID Q931PduInit()
{
    ProtocolId1.value = Q931_PROTOCOL_ID1;
    ProtocolId1.next = &ProtocolId2;
    ProtocolId2.value = Q931_PROTOCOL_ID2;
    ProtocolId2.next = &ProtocolId3;
    ProtocolId3.value = Q931_PROTOCOL_ID3;
    ProtocolId3.next = &ProtocolId4;
    ProtocolId4.value = Q931_PROTOCOL_ID4;
    ProtocolId4.next = &ProtocolId5;
    ProtocolId5.value = Q931_PROTOCOL_ID5;
    ProtocolId5.next = &ProtocolId6;
    ProtocolId6.value = Q931_PROTOCOL_ID6;
    ProtocolId6.next = NULL;

    // gateway protocol supported.  For now, hard-coded to only 1:  H323.
    TempProtocol.next = NULL;
    TempProtocol.value.choice = h323_chosen;
}

//====================================================================================
//====================================================================================
static CS_STATUS
AliasToSeqof(struct Setup_UUIE_sourceAddress **ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource && (pSource->wCount))
    {
        struct Setup_UUIE_sourceAddress *ListHead = NULL;
        struct Setup_UUIE_sourceAddress *CurrentNode = NULL;
        LPWSTR pData = NULL;         // UNICODE STRING
        int SourceItem;
        WORD x;

        for (SourceItem = pSource->wCount - 1; SourceItem >= 0; SourceItem--)
        {
            BOOL Cleanup = FALSE;

            // first do the required memory allocations...
            CurrentNode = (struct Setup_UUIE_sourceAddress *)MemAlloc(sizeof(struct Setup_UUIE_sourceAddress));
            if (CurrentNode == NULL)
            {
                Cleanup = TRUE;
            }
            else
            {
                if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_ID)
                {
                    if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                        (pSource->pItems[SourceItem].pData != NULL))
                    {
                        pData = (LPWSTR)MemAlloc(pSource->pItems[SourceItem].wDataLength *
                            sizeof(WCHAR));
                        if (pData == NULL)
                        {
                            MemFree(CurrentNode);
                            Cleanup = TRUE;
                        }
                    }
                }
            }
            if (Cleanup)
            {
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            MemFree(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    MemFree(CurrentNode);
                }
                return CS_NO_MEMORY;
            }

            // then do the required memory copying.
            if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_ID)
            {
                CurrentNode->value.choice = h323_ID_chosen;
                if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                    (pSource->pItems[SourceItem].pData != NULL))
                {
                    CurrentNode->value.u.h323_ID.length =
                        pSource->pItems[SourceItem].wDataLength;
                    for (x = 0; x < pSource->pItems[SourceItem].wDataLength; x++)
                    {
                        pData[x] = pSource->pItems[SourceItem].pData[x];
                    }
                    CurrentNode->value.u.h323_ID.value = pData;
                }
                else
                {
                    CurrentNode->value.u.h323_ID.length = 0;
                    CurrentNode->value.u.h323_ID.value = NULL;
                }
            }
            else if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_PHONE)
            {
                CurrentNode->value.choice = e164_chosen;
                if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                    (pSource->pItems[SourceItem].pData != NULL))
                {
                    for (x = 0; x < pSource->pItems[SourceItem].wDataLength; x++)
                    {
                        CurrentNode->value.u.e164[x] = (BYTE)(pSource->pItems[SourceItem].pData[x]);
                    }
                    CurrentNode->value.u.e164[pSource->pItems[SourceItem].wDataLength] = '\0';
                }
                else
                {
                    CurrentNode->value.u.e164[0] = '\0';
                }
            }
            CurrentNode->next = ListHead;
            ListHead = CurrentNode;
        }
        *ppTarget = ListHead;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
AliasWithPrefixToSeqof(struct Setup_UUIE_sourceAddress **ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource && (pSource->wCount))
    {
        struct Setup_UUIE_sourceAddress *ListHead = NULL;
        struct Setup_UUIE_sourceAddress *CurrentNode = NULL;
        int SourceItem;

        for (SourceItem = pSource->wCount - 1; SourceItem >= 0; SourceItem--)
        {
			PCC_ALIASITEM pItem = &pSource->pItems[SourceItem];
			LPWSTR pData = NULL;        // UNICODE STRING
            BOOL Cleanup = FALSE;
            unsigned uPrefixLength;
            unsigned uDataLength;
            unsigned x;
            
            if (pItem->pPrefix != NULL &&
                pItem->wPrefixLength > 0)
            {
                uPrefixLength = (unsigned) pItem->wPrefixLength;
            }
            else
            {
                uPrefixLength = 0;
            }

            if (pItem->pData != NULL &&
                pItem->wDataLength > 0)
            {
                uDataLength = (unsigned) pItem->wDataLength;
            }
            else
            {
                uDataLength = 0;
            }

            // first do the required memory allocations...
            CurrentNode = (struct Setup_UUIE_sourceAddress *)MemAlloc(sizeof(struct Setup_UUIE_sourceAddress));
            if (CurrentNode == NULL)
            {
                Cleanup = TRUE;
            }
            else
            {
                if (pItem->wType == CC_ALIAS_H323_ID)
                {
#ifdef USE_PREFIX_FOR_H323_ID
                    if (uPrefixLength != 0 || uDataLength != 0)
                    {
                        pData = (LPWSTR)MemAlloc((uPrefixLength + uDataLength) * sizeof(WCHAR));
#else
                    if (uDataLength != 0)
                    {
                        pData = (LPWSTR)MemAlloc((uDataLength) * sizeof(WCHAR));
#endif
                        if (pData == NULL)
                        {
                            MemFree(CurrentNode);
                            Cleanup = TRUE;
                        }
                    }
                }
            }
            if (Cleanup)
            {
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            MemFree(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    MemFree(CurrentNode);
                }
                return CS_NO_MEMORY;
            }

            // then do the required memory copying.
            switch (pItem->wType)
            {
            case CC_ALIAS_H323_ID:
                CurrentNode->value.choice = h323_ID_chosen;
#ifdef USE_PREFIX_FOR_H323_ID
                if (uPrefixLength != 0 || uDataLength != 0)
                {
                    CurrentNode->value.u.h323_ID.length = (WORD)(uPrefixLength + uDataLength);
                    for (x = 0; x < uPrefixLength; ++x)
                    {
                        pData[x] = pItem->pPrefix[x];
                    }
                    for (x = 0; x < uDataLength; ++x)
                    {
                        pData[uPrefixLength + x] = pItem->pData[x];
                    }
#else
                if (uDataLength != 0)
                {
                    CurrentNode->value.u.h323_ID.length = (WORD)(uDataLength);
                    for (x = 0; x < uDataLength; ++x)
                    {
                        pData[x] = pItem->pData[x];
                    }
#endif
                    CurrentNode->value.u.h323_ID.value = pData;
                }
                else
                {
                    CurrentNode->value.u.h323_ID.length = 0;
                    CurrentNode->value.u.h323_ID.value  = NULL;
                }
                break;

            case CC_ALIAS_H323_PHONE:
                CurrentNode->value.choice = e164_chosen;
                for (x = 0; x < uPrefixLength; ++x)
                {
                    CurrentNode->value.u.e164[x] = (BYTE)(pItem->pPrefix[x]);
                }
                for (x = 0; x < uDataLength; ++x)
                {
                    CurrentNode->value.u.e164[uPrefixLength + x] = (BYTE)(pItem->pData[x]);
                }
                for (x = uDataLength + uPrefixLength; x < sizeof(CurrentNode->value.u.e164); ++x)
                {
                    CurrentNode->value.u.e164[x] = 0;
                }
                break;

            default:
                MemFree(CurrentNode);
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            MemFree(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    MemFree(CurrentNode);
                }
                return CS_BAD_PARAM;
            } // switch
            CurrentNode->next = ListHead;
            ListHead = CurrentNode;
        }
        *ppTarget = ListHead;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
SeqofToAlias(PCC_ALIASNAMES *ppTarget, struct Setup_UUIE_sourceAddress *pSource)
{
    struct Setup_UUIE_sourceAddress *ListHead = NULL;
    struct Setup_UUIE_sourceAddress *CurrentNode = NULL;
    WORD wCount;
    WORD x = 0;
    PCC_ALIASITEM p = NULL;
    CS_STATUS status = CS_OK;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }

    wCount = 0;
    for (CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next)
    {
        wCount++;
    }

    *ppTarget = (PCC_ALIASNAMES)MemAlloc(sizeof(CC_ALIASNAMES));
    if (*ppTarget == NULL)
    {
        return CS_NO_MEMORY;
    }

    (*ppTarget)->pItems = (PCC_ALIASITEM)MemAlloc(wCount * sizeof(CC_ALIASITEM));
    if ((*ppTarget)->pItems == NULL)
    {
        MemFree(*ppTarget);
        *ppTarget = NULL;
        return CS_NO_MEMORY;
    }

    p = (*ppTarget)->pItems;

    for (CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next)
    {
        WORD y;

	    p[x].wPrefixLength = 0;
        p[x].pPrefix = NULL;

        switch (CurrentNode->value.choice)
        {
        case h323_ID_chosen:
            p[x].wType = CC_ALIAS_H323_ID;
            if ((CurrentNode->value.u.h323_ID.length != 0) &&
                    (CurrentNode->value.u.h323_ID.value != NULL))
            {
                p[x].wDataLength = (WORD) CurrentNode->value.u.h323_ID.length;
                p[x].pData = (LPWSTR)MemAlloc(CurrentNode->value.u.h323_ID.length * sizeof(p[x].pData[0]));
                if (p[x].pData != NULL)
                {
                    for (y = 0; y < CurrentNode->value.u.h323_ID.length; y++)
                    {
                        p[x].pData[y] = (WCHAR)((CurrentNode->value.u.h323_ID.value)[y]);
                    }
					x++;
                }
                else
                {
                    status = CS_NO_MEMORY;
                }
            }
            break;


        case e164_chosen:
            p[x].wType = CC_ALIAS_H323_PHONE;
            p[x].wDataLength = (WORD)strlen(CurrentNode->value.u.e164);
            p[x].pData = (LPWSTR)MemAlloc((p[x].wDataLength+1) * sizeof(p[x].pData[0]));
            if (p[x].pData != NULL)
            {
                for (y = 0; y < p[x].wDataLength; y++)
                {
                    p[x].pData[y] = CurrentNode->value.u.e164[y];
                }
                p[x].pData[p[x].wDataLength] = 0;
				x++;
            }
            else
            {
                status = CS_NO_MEMORY;
            }
            break;

        default:
			// we don't currently handle other alias types
			break;
        } // switch

        if (status != CS_OK)
        {
            // Free everything that has been allocated so far...
            for (y = 0; y < x; y++)
            {
                MemFree(p[y].pData);
            }
            MemFree(p);
            MemFree(*ppTarget);
            *ppTarget = NULL;
            return status;
        }
    }
    (*ppTarget)->wCount = x;

    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
FreeSeqof(struct Setup_UUIE_sourceAddress *pSource)
{
    struct Setup_UUIE_sourceAddress *CurrentNode = NULL;

    for (CurrentNode = pSource; CurrentNode; CurrentNode = pSource)
    {
        pSource = CurrentNode->next;
        if (CurrentNode->value.choice == h323_ID_chosen)
        {
            if (CurrentNode->value.u.h323_ID.value)
            {
                MemFree(CurrentNode->value.u.h323_ID.value);
            }
        }
        MemFree(CurrentNode);
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931CopyAliasItemToAliasAddr(AliasAddress *pTarget, PCC_ALIASITEM pSource)
{
    AliasAddress *pNewAddress = NULL;
    WORD x;

    if (pTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        return CS_BAD_PARAM;
    }

    pNewAddress = pTarget;

    if (pSource->wType == CC_ALIAS_H323_ID)
    {
        pNewAddress->choice = h323_ID_chosen;
        if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
        {
            LPWSTR pData = NULL;         // UNICODE STRING
            pData = (LPWSTR)MemAlloc(pSource->wDataLength * sizeof(WCHAR));
            if (pData == NULL)
            {
                return CS_NO_MEMORY;
            }
            pNewAddress->u.h323_ID.length = pSource->wDataLength;
            for (x = 0; x < pSource->wDataLength; x++)
            {
                pData[x] = pSource->pData[x];
            }
            pNewAddress->u.h323_ID.value = pData;
        }
        else
        {
            pNewAddress->u.h323_ID.length = 0;
            pNewAddress->u.h323_ID.value = NULL;
        }
    }
    else if (pSource->wType == CC_ALIAS_H323_PHONE)
    {
        pNewAddress->choice = e164_chosen;
        if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
        {
            for (x = 0; x < pSource->wDataLength; x++)
            {
                pNewAddress->u.e164[x] = (BYTE)(pSource->pData[x]);
            }
            pNewAddress->u.e164[pSource->wDataLength] = '\0';
        }
        else
        {
            pNewAddress->u.e164[0] = '\0';
        }
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931AliasAddrToAliasItem(PCC_ALIASITEM *ppTarget, AliasAddress *pSource)
{
    PCC_ALIASITEM pNewItem = NULL;
    WORD y;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppTarget = NULL;
        return CS_OK;
    }

    pNewItem = (PCC_ALIASITEM)MemAlloc(sizeof(CC_ALIASITEM));
    if (pNewItem == NULL)
    {
        *ppTarget = NULL;
        return CS_NO_MEMORY;
    }
    memset(pNewItem, 0, sizeof(*pNewItem));

    switch (pSource->choice)
    {
    case h323_ID_chosen:
        pNewItem->wType = CC_ALIAS_H323_ID;
        if ((pSource->u.h323_ID.length != 0) &&
            (pSource->u.h323_ID.value  != NULL))
        {
            // convert the text from UNICODE to ascii.
            pNewItem->wDataLength = (WORD) pSource->u.h323_ID.length;
            pNewItem->pData = (LPWSTR)MemAlloc(pSource->u.h323_ID.length * sizeof(pNewItem->pData[0]));
            if (pNewItem->pData == NULL)
            {
                MemFree(pNewItem);
                return CS_NO_MEMORY;
            }
            for (y = 0; y < pSource->u.h323_ID.length; y++)
            {
                pNewItem->pData[y] = (WCHAR)((pSource->u.h323_ID.value)[y]);
            }
        }
        break;

    case e164_chosen:
        pNewItem->wType = CC_ALIAS_H323_PHONE;
        pNewItem->wDataLength = (WORD)strlen(pSource->u.e164);
        pNewItem->pData = (LPWSTR)MemAlloc((pNewItem->wDataLength + 1) * sizeof(pNewItem->pData[0]));
        if (pNewItem->pData == NULL)
        {
            MemFree(pNewItem);
            return CS_NO_MEMORY;
        }
        for (y = 0; y < pNewItem->wDataLength; y++)
        {
            pNewItem->pData[y] = pSource->u.e164[y];
        }
        pNewItem->pData[pNewItem->wDataLength] = 0;
        break;

    default:
        MemFree(pNewItem);
        *ppTarget = NULL;
        return CS_BAD_PARAM;
    } // switch

    *ppTarget = pNewItem;
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931ClearAliasAddr(AliasAddress *pSource)
{
    if (pSource)
    {
        if (pSource->choice == h323_ID_chosen)
        {
            if (pSource->u.h323_ID.value)
            {
                MemFree(pSource->u.h323_ID.value);
            }
        }
    }
    return CS_OK;
}





//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//     Value      Pointer to space for field value
//------------------------------------------------------------------------------
static HRESULT 
ParseSingleOctetType1(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *Value)
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low bits (0, 1, 2, 3) of the byte are the value
    *Value = (BYTE)(*BufferDescriptor->BufferPtr & TYPE1VALUEMASK);

    // higher bits (4, 5, 6) are the identifier.  bit 7 is always 1,
    // and is not returned as part of the id.
    *Ident = (BYTE)((*BufferDescriptor->BufferPtr & 0x70) >> 4);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
// This octet has no value, only an identifier.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer containing the
//                length and a pointer to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//------------------------------------------------------------------------------
static HRESULT
ParseSingleOctetType2(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident)
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the byte are the identifier
    *Ident = (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//
// Parameters :
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//     Length     Pointer to space for the length
//     Contents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
static HRESULT 
ParseVariableOctet(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *Length,
    BYTE *Contents)
{
    register int i;
    BYTE *Tempptr;

    // There has to be at least 2 bytes in order just to get 
    // the length and the identifier
    // able to parse the single octet value
    if (BufferDescriptor->Length < 2)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the first byte are the identifier
    *Ident= (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // The next byte is the length
    *Length = *BufferDescriptor->BufferPtr;
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    ASSERT(*Length <= MAXVARFIELDLEN);
    if (MAXVARFIELDLEN < *Length)
    {
        return CS_INVALID_FIELD;
    }
    
    if (BufferDescriptor->Length < *Length)
    {
        return CS_ENDOFINPUT;
    }

    Tempptr = Contents;
    for (i = 0; i < *Length; i++)
    {
        // Copy the bytes out of the rest of the buffer
        *Tempptr = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
        Tempptr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
ParseVariableASN(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *ProtocolDiscriminator,
    WORD *UserInformationLength,     // Length of the User Information.
    BYTE *UserInformation,           // Bytes of the User Information.
    WORD cbMaxUserInformation)
{
    register int i;
    BYTE *Tempptr;
    WORD ContentsLength;     // Length of the full UserUser contents.

    *UserInformationLength = 0;

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    if (BufferDescriptor->Length < 4)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the first byte are the identifier
    *Ident= (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // The next 2 bytes are the length
    ContentsLength = *(BufferDescriptor->BufferPtr);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;
    ContentsLength = (WORD)((ContentsLength << 8) + *BufferDescriptor->BufferPtr);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (BufferDescriptor->Length < ContentsLength)
    {
        return CS_ENDOFINPUT;
    }

    // The next byte is the protocol discriminator.
    *ProtocolDiscriminator = *BufferDescriptor->BufferPtr;
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (ContentsLength > 0)
    {
        *UserInformationLength = (WORD)(ContentsLength - 1);
    }

    ASSERT(*UserInformationLength <= cbMaxUserInformation);
    if(cbMaxUserInformation < *UserInformationLength)
    {
        return CS_INVALID_FIELD;
    }

    Tempptr = UserInformation;
    for (i = 0; i < *UserInformationLength; i++)
    {
        // Copy the bytes out of the rest of the buffer
        *Tempptr = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
        Tempptr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Get the identifier of the next field from the buffer and
// return it.  The buffer pointer is not incremented, To
// parse the field and extract its values, the above functions
// should be used.  See Q931 table 4-3 for the encodings of the 
// identifiers.
//
// Parameters:
//      BufferPtr        Pointer to the buffer space
//------------------------------------------------------------------------------
static BYTE
GetNextIdent(
    void *BufferPtr)
{
    FIELDIDENTTYPE Ident;

    // Extract the first byte from the buffer
    Ident= (*(FIELDIDENTTYPE *)BufferPtr);

    // This value can be returned as the identifier as long
    // as it is not a single Octet - Type 1 element.
    // Those items must have the value removed from them
    // before they can be returned.
    if ((Ident & 0x80) && ((Ident & TYPE1IDENTMASK) != 0xA0))
    {
        return (BYTE)(Ident & TYPE1IDENTMASK);
    }

    return Ident;
}

//------------------------------------------------------------------------------
// Parse and return a protocol discriminator. See Q931 section 4.2.
// The octet pointed to by **BufferPtr is the protocol Discriminator.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Discrim    Pointer to space for discriminator
//------------------------------------------------------------------------------
static HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR BufferDescriptor,
    PDTYPE *Discrim)
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < sizeof(PDTYPE))
    {
        return CS_ENDOFINPUT;
    }

    *Discrim = *(PDTYPE *)BufferDescriptor->BufferPtr;
    if (*Discrim != Q931PDVALUE)
    {
        return CS_INVALID_PROTOCOL;
    }

    BufferDescriptor->BufferPtr += sizeof(PDTYPE);
    BufferDescriptor->Length -= sizeof(PDTYPE);
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 call reference see 
// Q931 section 4.3.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Length     Pointer to space for the length
//     Contents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
static HRESULT
ParseCallReference(
    PBUFFERDESCR BufferDescriptor,
    CRTYPE *CallReference)
{
    register int i;
    BYTE Length;

    // There has to be at least enough bytes left in the 
    // string for the length byte
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low 4 bits of the first byte are the length.
    // the rest of the bits are zeroes.
    Length = (BYTE)(*BufferDescriptor->BufferPtr & 0x0f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < Length)
    {
        return CS_ENDOFINPUT;
    }

    *CallReference = 0;     // length can be 0, so initialize here first...
    for (i = 0; i < Length; i++)
    {
        if (i < sizeof(CRTYPE))
        {
            // Copy the bytes out of the rest of the buffer
            *CallReference = (WORD)((*CallReference << 8) +
                *BufferDescriptor->BufferPtr);
        }
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
    }

    // note:  the high order bit of the value represents callee relationship.

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a message type.  See Q931 section 4.4.
// The octet pointed to by **BufferPtr is the message type.
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
static HRESULT
ParseMessageType(
    PBUFFERDESCR BufferDescriptor,
    MESSAGEIDTYPE *MessageType)
{
    register int i;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < sizeof(MESSAGEIDTYPE))
    {
        return CS_ENDOFINPUT;
    }

    *MessageType = (BYTE)(*((MESSAGEIDTYPE *)BufferDescriptor->BufferPtr) & MESSAGETYPEMASK);
    for (i = 0; i < sizeof(MessageSet) / sizeof(MESSAGEIDTYPE); i++)
    {
        if (MessageSet[i] == *MessageType)
        {
            break;
        }
    }
    if (i >= sizeof(MessageSet) / sizeof(MESSAGEIDTYPE))
    {
        return CS_INVALID_MESSAGE_TYPE;
    }

    BufferDescriptor->BufferPtr += sizeof(MESSAGEIDTYPE);
    BufferDescriptor->Length -= sizeof(MESSAGEIDTYPE);
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional shift field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer containing the
//                  length and a pointer to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed shift message information.
//------------------------------------------------------------------------------
static HRESULT
ParseShift(
    PBUFFERDESCR BufferDescriptor,
    PSHIFTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SHIFTIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SHIFT)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }
    return CS_OK;
}


//------------------------------------------------------------------------------
// Parse an optional facility ie field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed facility
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseFacility(
    PBUFFERDESCR BufferDescriptor,
    PFACILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(FACILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_FACILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional more data field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed field information
//------------------------------------------------------------------------------
static HRESULT 
ParseMoreData(
    PBUFFERDESCR BufferDescriptor,
    PMOREDATAIE FieldStruct)
{
    BYTE Ident;

    memset(FieldStruct, 0, sizeof(MOREDATAIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_MORE)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType2(BufferDescriptor, &Ident);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional sending clomplete field.  Q931 section 4.4.
// The octet pointed to by **BufferPtr is the message type.
//
// Parameters:
//      BufferPtr    Pointer to a descriptor of the buffer
//                   containing the length and a pointer
//                   to the raw bytes of the input stream.
//      MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
static HRESULT
ParseSendingComplete(
    PBUFFERDESCR BufferDescriptor,
    PSENDCOMPLIE FieldStruct)
{
    BYTE Ident;

    memset(FieldStruct, 0, sizeof(SENDCOMPLIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SENDINGCOMPLETE)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType2(BufferDescriptor, &Ident);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional congestion level field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed congestion 
//                  level information.
//------------------------------------------------------------------------------
static HRESULT 
ParseCongestionLevel(
    PBUFFERDESCR BufferDescriptor,
    PCONGESTIONIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CONGESTIONIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CONGESTION)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional repeat indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed repeat
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRepeatIndicator(
    PBUFFERDESCR BufferDescriptor,
    PREPEATIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REPEATIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REPEAT)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional segmented message field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed segmented message
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseSegmented(
    PBUFFERDESCR BufferDescriptor,
    PSEGMENTEDIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SEGMENTEDIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SEGMENTED)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional bearer capability field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed bearer capability
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseBearerCapability(
    PBUFFERDESCR BufferDescriptor,
    PBEARERCAPIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(BEARERCAPIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_BEARERCAP)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional cause field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed cause
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCause(
    PBUFFERDESCR BufferDescriptor,
    PCAUSEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CAUSEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CAUSE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional call identity field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed call identity
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallIdentity(
    PBUFFERDESCR BufferDescriptor,
    PCALLIDENTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLIDENTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLIDENT)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional call state field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed call state
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallState(
    PBUFFERDESCR BufferDescriptor,
    PCALLSTATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLSTATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLSTATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional channel identification field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed channel identity
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseChannelIdentification(
    PBUFFERDESCR BufferDescriptor,
    PCHANIDENTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CHANIDENTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CHANNELIDENT)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional progress indication field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed progress
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseProgress(
    PBUFFERDESCR BufferDescriptor,
    PPROGRESSIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PROGRESSIE));
    FieldStruct->Present = FALSE;
    if ((GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PROGRESS) ||
	(GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PROGRESS2))
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional network specific facilities field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed network facitlities
//                  information.
//------------------------------------------------------------------------------
static HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR BufferDescriptor,
    PNETWORKIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(NETWORKIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_NETWORKSPEC)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional notification indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parse notification indicator
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR BufferDescriptor,
    PNOTIFICATIONINDIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(NOTIFICATIONINDIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_NOTIFICATION)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional display field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed display
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseDisplay(
    PBUFFERDESCR BufferDescriptor,
    PDISPLAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(DISPLAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_DISPLAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional date/time field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed date/time
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseDate(
    PBUFFERDESCR BufferDescriptor,
    PDATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(DATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_DATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional keypad field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed keypad
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseKeypad(
    PBUFFERDESCR BufferDescriptor,
    PKEYPADIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(KEYPADIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_KEYPAD)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional signal field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed signal
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseSignal(
    PBUFFERDESCR BufferDescriptor,
    PSIGNALIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SIGNALIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SIGNAL)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional information rate field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed information rate
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseInformationRate(
    PBUFFERDESCR BufferDescriptor,
    PINFORATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(INFORATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_INFORMATIONRATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional end to end transit delay field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed end to end
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseEndToEndDelay(
    PBUFFERDESCR BufferDescriptor,
    PENDTOENDDELAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(ENDTOENDDELAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_ENDTOENDDELAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional transit delay field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed transit delay
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseTransitDelay(
    PBUFFERDESCR BufferDescriptor,
    PTRANSITDELAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(TRANSITDELAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_TRANSITDELAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet layer binary params field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketLayerParams(
    PBUFFERDESCR BufferDescriptor,
    PPLBINARYPARAMSIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PLBINARYPARAMSIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PLBINARYPARAMS)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet layer window size field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketLayerWindowSize(
    PBUFFERDESCR BufferDescriptor,
    PPLWINDOWSIZEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PLWINDOWSIZEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PLWINDOWSIZE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet size field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parse packet size
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketSize(
    PBUFFERDESCR BufferDescriptor,
    PPACKETSIZEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PACKETSIZEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PACKETSIZE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional closed user group field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseClosedUserGroup(
    PBUFFERDESCR BufferDescriptor,
    PCLOSEDUGIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CLOSEDUGIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CLOSEDUG)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional reverse charge field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseReverseCharge(
    PBUFFERDESCR BufferDescriptor,
    PREVERSECHARGEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REVERSECHARGEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REVCHARGE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR BufferDescriptor,
    PCALLINGNUMBERIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLINGNUMBERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLINGNUMBER)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party subaddress field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR BufferDescriptor,
    PCALLINGSUBADDRIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLINGSUBADDRIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLINGSUBADDR)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCalledPartyNumber(
    PBUFFERDESCR BufferDescriptor, 
    PCALLEDNUMBERIE FieldStruct)
{
    memset(FieldStruct, 0, sizeof(PCALLEDNUMBERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLEDNUMBER)
    {
        register int i;
        BYTE RemainingLength = 0;
        BYTE *Tempptr;
    
        // Need 3 bytes for the ident (1), length (1),
        // and type + plan (1) fields.
        if (BufferDescriptor->Length < 3)
        {
            return CS_ENDOFINPUT;
        }

        // skip the ie identifier...    
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;

        // Get the length of the contents following the length field.
        RemainingLength = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;

        // make sure we have at least that much length left...    
        if (BufferDescriptor->Length < RemainingLength)
        {
            return CS_ENDOFINPUT;
        }

        // Get the type + plan fields.
        if (*(BufferDescriptor->BufferPtr) & 0x80)
        {
            FieldStruct->NumberType =
                (BYTE)(*BufferDescriptor->BufferPtr & 0xf0);
            FieldStruct->NumberingPlan =
                (BYTE)(*BufferDescriptor->BufferPtr & 0x0f);
            BufferDescriptor->BufferPtr++;
            BufferDescriptor->Length--;
            RemainingLength--;
        }

        FieldStruct->PartyNumberLength = RemainingLength;
        FieldStruct->Present = TRUE;

        Tempptr = FieldStruct->PartyNumbers;
        for (i = 0; i < RemainingLength; i++)
        {
            // Copy the bytes out of the rest of the buffer
            *Tempptr = *(BufferDescriptor->BufferPtr);
            BufferDescriptor->BufferPtr++;
            BufferDescriptor->Length--;
            Tempptr++;
        }
        *Tempptr = (BYTE)0;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party subaddress field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCalledPartySubaddress(
    PBUFFERDESCR BufferDescriptor,
    PCALLEDSUBADDRIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLEDSUBADDRIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLEDSUBADDR)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional redirecting number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRedirectingNumber(
    PBUFFERDESCR BufferDescriptor, 
    PREDIRECTINGIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REDIRECTINGIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REDIRECTING)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional transit network selection field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseTransitNetwork(
    PBUFFERDESCR BufferDescriptor, 
    PTRANSITNETIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(TRANSITNETIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_TRANSITNET)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional restart indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRestart(
    PBUFFERDESCR BufferDescriptor,
    PRESTARTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PRESTARTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_RESTART)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional lower layer compatibility field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR BufferDescriptor,
    PLLCOMPATIBILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(LLCOMPATIBILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_LLCOMPATIBILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional higher layer compatibility field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseHighLayerCompatibility(
    PBUFFERDESCR BufferDescriptor,
    PHLCOMPATIBILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(HLCOMPATIBILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_HLCOMPATIBILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional user to user field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseUserToUser(
    PBUFFERDESCR BufferDescriptor,
    PUSERUSERIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(USERUSERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_USERUSER)
    {
        HRESULT ParseResult;

        ParseResult = ParseVariableASN(BufferDescriptor, 
            &Ident, &(FieldStruct->ProtocolDiscriminator),
            &(FieldStruct->UserInformationLength),
            &(FieldStruct->UserInformation[0]),
            sizeof(FieldStruct->UserInformation));

        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->UserInformationLength > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse the next Q931 field in the given message
//
// Parameters:
//      BufferDescriptor  Pointer to buffer descriptor of a 
//                        the network packet of the 931 message
//      Message           Pointer to space for parsed information.
//------------------------------------------------------------------------------
static HRESULT
ParseQ931Field(
    PBUFFERDESCR BufferDescriptor,
    PQ931MESSAGE Message)
{
    FIELDIDENTTYPE Ident;

    Ident = GetNextIdent(BufferDescriptor->BufferPtr);
    switch (Ident)
    {
    case IDENT_SHIFT:
        return ParseShift(BufferDescriptor,
            &Message->Shift);
    case IDENT_FACILITY:
        return ParseFacility(BufferDescriptor,
            &Message->Facility);
    case IDENT_MORE:
        return ParseMoreData(BufferDescriptor,
            &Message->MoreData);
    case IDENT_SENDINGCOMPLETE:
        return ParseSendingComplete(BufferDescriptor,
            &Message->SendingComplete);
    case IDENT_CONGESTION:
        return ParseCongestionLevel(BufferDescriptor,
            &Message->CongestionLevel);
    case IDENT_REPEAT:
        return ParseRepeatIndicator(BufferDescriptor,
            &Message->RepeatIndicator);
    case IDENT_SEGMENTED:
        return ParseSegmented(BufferDescriptor,
            &Message->SegmentedMessage);
    case IDENT_BEARERCAP:
        return ParseBearerCapability(BufferDescriptor,
            &Message->BearerCapability);
    case IDENT_CAUSE:
        return ParseCause(BufferDescriptor,
            &Message->Cause);
    case IDENT_CALLIDENT:
        return ParseCallIdentity(BufferDescriptor,
            &Message->CallIdentity);
    case IDENT_CALLSTATE:
        return ParseCallState(BufferDescriptor,
            &Message->CallState);
    case IDENT_CHANNELIDENT:
        return ParseChannelIdentification(BufferDescriptor,
            &Message->ChannelIdentification);
    case IDENT_PROGRESS:
    case IDENT_PROGRESS2:
        return ParseProgress(BufferDescriptor,
            &Message->ProgressIndicator);
    case IDENT_NETWORKSPEC:
        return ParseNetworkSpec(BufferDescriptor,
            &Message->NetworkFacilities);
    case IDENT_NOTIFICATION:
        return ParseNotificationIndicator(BufferDescriptor,
            &Message->NotificationIndicator);
    case IDENT_DISPLAY:
        return ParseDisplay(BufferDescriptor,
            &Message->Display);
    case IDENT_DATE:
        return ParseDate(BufferDescriptor,
            &Message->Date);
    case IDENT_KEYPAD:
        return ParseKeypad(BufferDescriptor,
            &Message->Keypad);
    case IDENT_SIGNAL:
        return ParseSignal(BufferDescriptor,
            &Message->Signal);
    case IDENT_INFORMATIONRATE:
        return ParseInformationRate(BufferDescriptor,
            &Message->InformationRate);
    case IDENT_ENDTOENDDELAY:
        return ParseEndToEndDelay(BufferDescriptor,
            &Message->EndToEndTransitDelay);
    case IDENT_TRANSITDELAY:
        return ParseTransitDelay(BufferDescriptor,
            &Message->TransitDelay);
    case IDENT_PLBINARYPARAMS:
        return ParsePacketLayerParams(BufferDescriptor,
            &Message->PacketLayerBinaryParams);
    case IDENT_PLWINDOWSIZE:
        return ParsePacketLayerWindowSize(BufferDescriptor,
            &Message->PacketLayerWindowSize);
    case IDENT_PACKETSIZE:
        return ParsePacketSize(BufferDescriptor,
            &Message->PacketSize);
    case IDENT_CLOSEDUG:
        return ParseClosedUserGroup(BufferDescriptor,
            &Message->ClosedUserGroup);
    case IDENT_REVCHARGE:
        return ParseReverseCharge(BufferDescriptor,
            &Message->ReverseChargeIndication);
    case IDENT_CALLINGNUMBER:
        return ParseCallingPartyNumber(BufferDescriptor,
            &Message->CallingPartyNumber);
    case IDENT_CALLINGSUBADDR:
        return ParseCallingPartySubaddress(BufferDescriptor,
            &Message->CallingPartySubaddress);
    case IDENT_CALLEDNUMBER:
        return ParseCalledPartyNumber(BufferDescriptor,
            &Message->CalledPartyNumber);
    case IDENT_CALLEDSUBADDR:
        return ParseCalledPartySubaddress(BufferDescriptor,
            &Message->CalledPartySubaddress);
    case IDENT_REDIRECTING:
        return ParseRedirectingNumber(BufferDescriptor,
            &Message->RedirectingNumber);
    case IDENT_TRANSITNET:
        return ParseTransitNetwork(BufferDescriptor,
            &Message->TransitNetworkSelection);
    case IDENT_RESTART:
        return ParseRestart(BufferDescriptor,
            &Message->RestartIndicator);
    case IDENT_LLCOMPATIBILITY:
        return ParseLowLayerCompatibility(BufferDescriptor,
            &Message->LowLayerCompatibility);
    case IDENT_HLCOMPATIBILITY:
        return ParseHighLayerCompatibility(BufferDescriptor,
            &Message->HighLayerCompatibility);
    case IDENT_USERUSER:
        return ParseUserToUser(BufferDescriptor,
            &Message->UserToUser);
    default:
        return CS_INVALID_FIELD;
    }
}

//------------------------------------------------------------------------------
// Parse a generic Q931 message and place the fields of the buffer
// into the appropriate structure fields.
//
// Parameters:
//     BufferDescriptor  Pointer to buffer descriptor of an
//                       input packet containing the 931 message.
//     Message           Pointer to space for parsed output information.
//------------------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message)
{
    HRESULT Result;
    BUFFERDESCR BufferDescriptor;

    BufferDescriptor.Length = CodedBufferLength;
    BufferDescriptor.BufferPtr = CodedBufferPtr;

    memset(Message, 0, sizeof(Q931MESSAGE));

    if ((Result = ParseProtocolDiscriminator(&BufferDescriptor,
        &Message->ProtocolDiscriminator)) != CS_OK)
    {
        return Result;
    }

    if ((Result = ParseCallReference(&BufferDescriptor,
        &Message->CallReference)) != CS_OK)
    {
        return Result;
    }

    if ((Result = ParseMessageType(&BufferDescriptor,
        &Message->MessageType)) != CS_OK)
    {
        return Result;
    }

    while (BufferDescriptor.Length)
    {
        Result = ParseQ931Field(&BufferDescriptor, Message);
        if (Result != CS_OK)
        {
            return Result;
        }
    }
    return CS_OK;
}


//==============================================================================
//==============================================================================
//==============================================================================
// BELOW HERE ARE THE OUTPUT ROUTINES...
//==============================================================================
//==============================================================================
//==============================================================================


//------------------------------------------------------------------------------
// Write the protocol discriminator. See Q931 section 4.2.
//------------------------------------------------------------------------------
static HRESULT
WriteProtocolDiscriminator(
    PBUFFERDESCR BufferDescriptor)
{
    BufferDescriptor->Length += sizeof(PDTYPE);
    if (BufferDescriptor->BufferPtr)
    {
        *(PDTYPE *)BufferDescriptor->BufferPtr = Q931PDVALUE;
        BufferDescriptor->BufferPtr += sizeof(PDTYPE);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a variable length Q931 call reference.  See Q931 section 4.3.
//------------------------------------------------------------------------------
static HRESULT
WriteCallReference(
    PBUFFERDESCR BufferDescriptor,
    CRTYPE *CallReference)
{
    register int i;

    // space for the length byte
    BufferDescriptor->Length++;

    // the length byte
    if (BufferDescriptor->BufferPtr != NULL)
    {
        *BufferDescriptor->BufferPtr = (BYTE)sizeof(CRTYPE);
        BufferDescriptor->BufferPtr++;
    }

    for (i = 0; i < sizeof(CRTYPE); i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr =
                (BYTE)(((*CallReference) >> ((sizeof(CRTYPE) - 1 -i) * 8)) & 0xff);
            BufferDescriptor->BufferPtr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a Q931 message type.  See Q931 section 4.4.
//------------------------------------------------------------------------------
static HRESULT
WriteMessageType(
    PBUFFERDESCR BufferDescriptor,
    MESSAGEIDTYPE *MessageType)
{
    register int i;

    for (i = 0; i < sizeof(MessageSet) / sizeof(MESSAGEIDTYPE); i++)
    {
        if (MessageSet[i] == *MessageType)
        {
            break;
        }
    }
    if (i >= sizeof(MessageSet) / sizeof(MESSAGEIDTYPE))
    {
        return CS_INVALID_MESSAGE_TYPE;
    }

    BufferDescriptor->Length += sizeof(MESSAGEIDTYPE);
    if (BufferDescriptor->BufferPtr != NULL)
    {
        *(MESSAGEIDTYPE *)(BufferDescriptor->BufferPtr) =
            (BYTE)(*MessageType & MESSAGETYPEMASK);
        BufferDescriptor->BufferPtr += sizeof(MESSAGEIDTYPE);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a single octet encoded value, See Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteSingleOctetType1(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE Value)
{
    BufferDescriptor->Length++;
    if (BufferDescriptor->BufferPtr)
    {
        *BufferDescriptor->BufferPtr =
            (BYTE)(0x80 | Ident | (Value & TYPE1VALUEMASK));
        BufferDescriptor->BufferPtr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a single octet encoded value, See Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteSingleOctetType2(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident)
{
    BufferDescriptor->Length++;
    if (BufferDescriptor->BufferPtr)
    {
        *BufferDescriptor->BufferPtr = (BYTE)(0x80 | Ident);
        BufferDescriptor->BufferPtr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteVariableOctet(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE Length,
    BYTE *Contents)
{
    register int i;
    BYTE *Tempptr;

    if (Contents == NULL)
    {
        Length = 0;
    }

    // space for the length and the identifier bytes
    BufferDescriptor->Length += 2;

    // the id byte, then the length byte
    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of the first byte are the identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;
        *BufferDescriptor->BufferPtr = Length;
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = Contents;
    for (i = 0; i < Length; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
//Write out the Party number.
//------------------------------------------------------------------------------
static HRESULT 
WritePartyNumber(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE PartyNumberLength,
    BYTE *PartyNumbers)
{
    register int i;
    BYTE *Tempptr;

    if (PartyNumbers == NULL)
    {
        PartyNumberLength = 0;
    }

    // space for the ident (1), length (1), and type + plan (1) fields.
    BufferDescriptor->Length += 3;

    // write the fields out.
    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of byte 1 are the ie identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;

        // byte 2 is the ie contents length following the length field.
        *BufferDescriptor->BufferPtr = (BYTE)(PartyNumberLength + 1);
        BufferDescriptor->BufferPtr++;

        // byte 3 is the type and plan field.
        *BufferDescriptor->BufferPtr = (BYTE)(NumberType | NumberingPlan);
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = PartyNumbers;
    for (i = 0; i < PartyNumberLength; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteVariableASN(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    WORD UserInformationLength,
    BYTE *UserInformation)
{
    register int i;
    BYTE *Tempptr;
    WORD ContentsLength = (WORD)(UserInformationLength + 1);

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    BufferDescriptor->Length += 4;

    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of the first byte are the identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;

        // write the contents length bytes.
        *BufferDescriptor->BufferPtr = (BYTE)(ContentsLength >> 8);
        BufferDescriptor->BufferPtr++;
        *BufferDescriptor->BufferPtr = (BYTE)ContentsLength;
        BufferDescriptor->BufferPtr++;

        // write the protocol discriminator byte.
        *(BufferDescriptor->BufferPtr) = Q931_PROTOCOL_X209;
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = UserInformation;
    for (i = 0; i < UserInformationLength; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write the Q931 fields to the encoding buffer.
//
// Parameters:
//      BufferDescriptor  Pointer to buffer descriptor for
//                        the encoded output buffer.
//      Message           Pointer to space for parsed input information.
//------------------------------------------------------------------------------
static HRESULT
WriteQ931Fields(
    PBUFFERDESCR BufferDescriptor,
    PQ931MESSAGE Message)
{
    // write the required information elements...
    WriteProtocolDiscriminator(BufferDescriptor);
    WriteCallReference(BufferDescriptor,
        &Message->CallReference);
    WriteMessageType(BufferDescriptor,
        &Message->MessageType);

    // try to write all other information elements...
// don't write this message.
#if 0
    if (Message->Shift.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_SHIFT,
            Message->Shift.Value);
    }
#endif

    if (Message->Facility.Present)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_FACILITY,
            Message->Facility.Length,
            Message->Facility.Contents);
    }

    if (Message->MoreData.Present)
    {
        WriteSingleOctetType2(BufferDescriptor, IDENT_MORE);
    }
    if (Message->SendingComplete.Present)
    {
        WriteSingleOctetType2(BufferDescriptor, IDENT_SENDINGCOMPLETE);
    }
    if (Message->CongestionLevel.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_CONGESTION,
            Message->CongestionLevel.Value);
    }
    if (Message->RepeatIndicator.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_REPEAT,
            Message->RepeatIndicator.Value);
    }

    if (Message->SegmentedMessage.Present &&
            Message->SegmentedMessage.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_SEGMENTED,
            Message->SegmentedMessage.Length,
            Message->SegmentedMessage.Contents);
    }
    if (Message->BearerCapability.Present &&
            Message->BearerCapability.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_BEARERCAP,
            Message->BearerCapability.Length,
            Message->BearerCapability.Contents);
    }
    if (Message->Cause.Present &&
            Message->Cause.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CAUSE,
            Message->Cause.Length,
            Message->Cause.Contents);
    }
    if (Message->CallIdentity.Present &&
            Message->CallIdentity.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLIDENT,
            Message->CallIdentity.Length,
            Message->CallIdentity.Contents);
    }
    if (Message->CallState.Present &&
            Message->CallState.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLSTATE,
            Message->CallState.Length,
            Message->CallState.Contents);
    }
    if (Message->ChannelIdentification.Present &&
            Message->ChannelIdentification.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CHANNELIDENT,
            Message->ChannelIdentification.Length,
            Message->ChannelIdentification.Contents);
    }
    if (Message->ProgressIndicator.Present &&
            Message->ProgressIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PROGRESS,
            Message->ProgressIndicator.Length,
            Message->ProgressIndicator.Contents);
    }
    if (Message->NetworkFacilities.Present &&
            Message->NetworkFacilities.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_NETWORKSPEC,
            Message->NetworkFacilities.Length,
            Message->NetworkFacilities.Contents);
    }
    if (Message->NotificationIndicator.Present &&
            Message->NotificationIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_NOTIFICATION,
            Message->NotificationIndicator.Length,
            Message->NotificationIndicator.Contents);
    }
    if (Message->Display.Present &&
            Message->Display.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_DISPLAY,
            Message->Display.Length,
            Message->Display.Contents);
    }
    if (Message->Date.Present &&
            Message->Date.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_DATE,
            Message->Date.Length,
            Message->Date.Contents);
    }
    if (Message->Keypad.Present &&
            Message->Keypad.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_KEYPAD,
            Message->Keypad.Length,
            Message->Keypad.Contents);
    }
    if (Message->Signal.Present &&
            Message->Signal.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_SIGNAL,
            Message->Signal.Length,
            Message->Signal.Contents);
    }
    if (Message->InformationRate.Present &&
            Message->InformationRate.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_INFORMATIONRATE,
            Message->InformationRate.Length,
            Message->InformationRate.Contents);
    }
    if (Message->EndToEndTransitDelay.Present &&
            Message->EndToEndTransitDelay.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_ENDTOENDDELAY,
            Message->EndToEndTransitDelay.Length,
            Message->EndToEndTransitDelay.Contents);
    }
    if (Message->TransitDelay.Present &&
            Message->TransitDelay.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_TRANSITDELAY,
            Message->TransitDelay.Length,
            Message->TransitDelay.Contents);
    }
    if (Message->PacketLayerBinaryParams.Present &&
            Message->PacketLayerBinaryParams.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PLBINARYPARAMS,
            Message->PacketLayerBinaryParams.Length,
            Message->PacketLayerBinaryParams.Contents);
    }
    if (Message->PacketLayerWindowSize.Present &&
            Message->PacketLayerWindowSize.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PLWINDOWSIZE,
            Message->PacketLayerWindowSize.Length,
            Message->PacketLayerWindowSize.Contents);
    }
    if (Message->PacketSize.Present &&
            Message->PacketSize.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PACKETSIZE,
            Message->PacketSize.Length,
            Message->PacketSize.Contents);
    }
    if (Message->ClosedUserGroup.Present &&
            Message->ClosedUserGroup.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CLOSEDUG,
            Message->ClosedUserGroup.Length,
            Message->ClosedUserGroup.Contents);
    }
    if (Message->ReverseChargeIndication.Present &&
            Message->ReverseChargeIndication.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_REVCHARGE,
            Message->ReverseChargeIndication.Length,
            Message->ReverseChargeIndication.Contents);
    }
    if (Message->CallingPartyNumber.Present &&
            Message->CallingPartyNumber.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLINGNUMBER,
            Message->CallingPartyNumber.Length,
            Message->CallingPartyNumber.Contents);
    }
    if (Message->CallingPartySubaddress.Present &&
            Message->CallingPartySubaddress.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLINGSUBADDR,
            Message->CallingPartySubaddress.Length,
            Message->CallingPartySubaddress.Contents);
    }
    if (Message->CalledPartyNumber.Present)
    {
        WritePartyNumber(BufferDescriptor, IDENT_CALLEDNUMBER,
            Message->CalledPartyNumber.NumberType,
            Message->CalledPartyNumber.NumberingPlan,
            Message->CalledPartyNumber.PartyNumberLength,
            Message->CalledPartyNumber.PartyNumbers);
     }
    if (Message->CalledPartySubaddress.Present &&
            Message->CalledPartySubaddress.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLEDSUBADDR,
            Message->CalledPartySubaddress.Length,
            Message->CalledPartySubaddress.Contents);
    }
    if (Message->RedirectingNumber.Present &&
            Message->RedirectingNumber.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_REDIRECTING,
            Message->RedirectingNumber.Length,
            Message->RedirectingNumber.Contents);
    }
    if (Message->TransitNetworkSelection.Present &&
            Message->TransitNetworkSelection.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_TRANSITNET,
            Message->TransitNetworkSelection.Length,
            Message->TransitNetworkSelection.Contents);
    }
    if (Message->RestartIndicator.Present &&
            Message->RestartIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_RESTART,
            Message->RestartIndicator.Length,
            Message->RestartIndicator.Contents);
    }
    if (Message->LowLayerCompatibility.Present &&
            Message->LowLayerCompatibility.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_LLCOMPATIBILITY,
            Message->LowLayerCompatibility.Length,
            Message->LowLayerCompatibility.Contents);
    }
    if (Message->HighLayerCompatibility.Present &&
            Message->HighLayerCompatibility.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_HLCOMPATIBILITY,
            Message->HighLayerCompatibility.Length,
            Message->HighLayerCompatibility.Contents);
    }
    if (Message->UserToUser.Present &&
            Message->UserToUser.UserInformationLength)
    {
        WriteVariableASN(BufferDescriptor,
            IDENT_USERUSER,
            Message->UserToUser.UserInformationLength,
            Message->UserToUser.UserInformation);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse a generic Q931 message and place the fields of the 
// of the buffer into the appropriate field structure.
//
// Parameters:
//     BufferDescriptor  Pointer to buffer descriptor of a 
//                       the network packet of the 931 message
//     Message           Pointer to space for parsed information.
//------------------------------------------------------------------------------
HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    BUFFERDESCR BufferDescriptor;
    BYTE *OutBuffer = NULL;
    DWORD Pass1Length = 0;

    if ((CodedBufferPtr == NULL) || (CodedBufferLength == NULL))
    {
        return CS_BAD_PARAM;
    }

    BufferDescriptor.Length = 0;
    BufferDescriptor.BufferPtr = NULL;

    WriteQ931Fields(&BufferDescriptor, Message);
    if (BufferDescriptor.Length == 0)
    {
        return CS_NO_FIELD_DATA;
    }

    Pass1Length = BufferDescriptor.Length;

    OutBuffer = (BYTE *)MemAlloc(BufferDescriptor.Length + 1000);
    if (OutBuffer == NULL)
    {
        return CS_NO_MEMORY;
    }

    BufferDescriptor.Length = 0;
    BufferDescriptor.BufferPtr = OutBuffer;

    WriteQ931Fields(&BufferDescriptor, Message);

    if (Pass1Length != BufferDescriptor.Length)
    {
        // this is a serious error, since memory may have been overrun.
        return CS_BAD_PARAM;
    }

    *CodedBufferPtr = OutBuffer;
    *CodedBufferLength = BufferDescriptor.Length;

    return CS_OK;
}


//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = SETUPMESSAGETYPE;

    pMessage->BearerCapability.Present = TRUE;
    pMessage->BearerCapability.Length = 3;
    pMessage->BearerCapability.Contents[0] =
        (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    pMessage->BearerCapability.Contents[1] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_PACKET_MODE | BEAR_NO_CIRCUIT_RATE);
    pMessage->BearerCapability.Contents[2] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)(strlen(pszDisplay) + 1);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    if (pszCalledPartyNumber && *pszCalledPartyNumber)
    {
        WORD wLen = (WORD)strlen(pszCalledPartyNumber);
        pMessage->CalledPartyNumber.Present = TRUE;

        pMessage->CalledPartyNumber.NumberType =
            (BYTE)(CALLED_PARTY_EXT_BIT | CALLED_PARTY_TYPE_UNKNOWN);
        pMessage->CalledPartyNumber.NumberingPlan =
            (BYTE)(CALLED_PARTY_PLAN_E164);
        pMessage->CalledPartyNumber.PartyNumberLength = (BYTE)wLen;
        memcpy(pMessage->CalledPartyNumber.PartyNumbers,
            pszCalledPartyNumber, wLen);
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    if (pbCause)
    {
        switch (*pbCause)
        {
            case CAUSE_VALUE_NORMAL_CLEAR:
            case CAUSE_VALUE_USER_BUSY:
            case CAUSE_VALUE_SECURITY_DENIED:
            case CAUSE_VALUE_NO_ANSWER:
            case CAUSE_VALUE_REJECTED:
            case CAUSE_VALUE_NOT_IMPLEMENTED:
            case CAUSE_VALUE_INVALID_CRV:
            case CAUSE_VALUE_IE_MISSING:
            case CAUSE_VALUE_IE_CONTENTS:
            case CAUSE_VALUE_TIMER_EXPIRED:
                break;
            default:
                return CS_BAD_PARAM;
                break;
        }
    }

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = RELEASECOMPLMESSAGETYPE;

    if (pbCause)
    {
        pMessage->Cause.Present = TRUE;
        pMessage->Cause.Length = 3;
        pMessage->Cause.Contents[0] = (BYTE)(CAUSE_CODING_CCITT | CAUSE_LOCATION_USER);
        pMessage->Cause.Contents[1] = (BYTE)(CAUSE_RECOMMENDATION_Q931);
        pMessage->Cause.Contents[2] = (BYTE)(CAUSE_EXT_BIT | *pbCause);
    }
    else
    {
        pMessage->Cause.Present = FALSE;
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = CONNECTMESSAGETYPE;

    pMessage->BearerCapability.Present = TRUE;
    pMessage->BearerCapability.Length = 3;
    pMessage->BearerCapability.Contents[0] =
        (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    pMessage->BearerCapability.Contents[1] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_PACKET_MODE | BEAR_NO_CIRCUIT_RATE);
    pMessage->BearerCapability.Contents[2] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)strlen(pszDisplay);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = PROCEEDINGMESSAGETYPE;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = ALERTINGMESSAGETYPE;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = FACILITYMESSAGETYPE;

    // The facility ie is encoded as present, but empty...
    pMessage->Facility.Present = TRUE;
    pMessage->Facility.Length = 0;
    pMessage->Facility.Contents[0] = 0;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = STATUSMESSAGETYPE;

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)(strlen(pszDisplay) + 1);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    pMessage->Cause.Present = TRUE;
    pMessage->Cause.Length = 3;
    pMessage->Cause.Contents[0] = (BYTE)(CAUSE_CODING_CCITT | CAUSE_LOCATION_USER);
    pMessage->Cause.Contents[1] = (BYTE)(CAUSE_RECOMMENDATION_Q931);
    pMessage->Cause.Contents[2] = (BYTE)(CAUSE_EXT_BIT | bCause);

    pMessage->CallState.Present = TRUE;
    pMessage->CallState.Length = 1;
    pMessage->CallState.Contents[0] = (BYTE)(bCallState);

    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}
#if(0)
//========================================================================
//========================================================================
//========================================================================
// THIS IS THE ASN PART...
//========================================================================
//========================================================================
//========================================================================

static ERROR_MAP EncodeErrorMap[] =
{
    PDU_ENCODED, __TEXT("PDU successfully encoded"),
    MORE_BUF, __TEXT("User-provided output buffer too small"),
    PDU_RANGE, __TEXT("PDU specified out of range"),
    BAD_ARG, __TEXT("Bad pointer was passed"),
    BAD_VERSION, __TEXT("Versions of encoder and table do not match"),
    OUT_MEMORY, __TEXT("Memory-allocation error"),
    BAD_CHOICE, __TEXT("Unknown selector for a choice"),
    BAD_OBJID, __TEXT("Object identifier conflicts with x.208"),
    BAD_PTR, __TEXT("Unexpected NULL pointer in input buffer"),
    BAD_TIME, __TEXT("Bad value in time type"),
    MEM_ERROR, __TEXT("Memory violation signal trapped"),
    BAD_TABLE, __TEXT("Table was bad, but not NULL"),
    TOO_LONG, __TEXT("Type was longer than constraint"),
    CONSTRAINT_VIOLATED, __TEXT("Constraint violation error occured"),
    FATAL_ERROR, __TEXT("Serious internal error"),
    ACCESS_SERIALIZATION_ERROR, __TEXT("Thread access to global data failed"),
    NULL_TBL, __TEXT("NULL control table pointer"),
    NULL_FCN, __TEXT("Encoder called via a NULL pointer"),
    BAD_ENCRULES, __TEXT("Unknown encoding rules"),
    UNAVAIL_ENCRULES, __TEXT("Encoding rules requested are not implemented"),
    UNIMPLEMENTED, __TEXT("Type was not implemented yet"),
//    LOAD_ERR, __TEXT("Unable to load DLL"),
    CANT_OPEN_TRACE_FILE, __TEXT("Error when opening a trace file"),
    TRACE_FILE_ALREADY_OPEN, __TEXT("Trace file has been opened"),
    TABLE_MISMATCH, __TEXT("Control table mismatch"),
    0, NULL
};

static ERROR_MAP DecodeErrorMap[] =
{
    PDU_DECODED, __TEXT("PDU successfully decoded"),
    MORE_BUF, __TEXT("User-provided output buffer too small"),
    NEGATIVE_UINTEGER, __TEXT("The first unsigned bit of the encoding is 1"),
    PDU_RANGE, __TEXT("Pdu specified out of range"),
    MORE_INPUT, __TEXT("Unexpected end of input buffer"),
    DATA_ERROR, __TEXT("An error exists in the encoded data"),
    BAD_VERSION, __TEXT("Versions of encoder and table do not match"),
    OUT_MEMORY, __TEXT("Memory-allocation error"),
    PDU_MISMATCH, __TEXT("The PDU tag does not match data"),
    LIMITED, __TEXT("Size implementation limit exceeded"),
    CONSTRAINT_VIOLATED, __TEXT("Constraint violation error occured"),
    ACCESS_SERIALIZATION_ERROR, __TEXT("Thread access to global data failed"),
    NULL_TBL, __TEXT("NULL control table pointer"),
    NULL_FCN, __TEXT("Encoder called via a NULL pointer"),
    BAD_ENCRULES, __TEXT("Unknown encoding rules"),
    UNAVAIL_ENCRULES, __TEXT("Encoding rules requested are not implemented"),
    UNIMPLEMENTED, __TEXT("The type was not implemented yet"),
//    LOAD_ERR, __TEXT("Unable to load DLL"),
    CANT_OPEN_TRACE_FILE, __TEXT("Error when opening a trace file"),
    TRACE_FILE_ALREADY_OPEN, __TEXT("The trace file has been opened"),
    TABLE_MISMATCH, __TEXT("Control table mismatch"),
    0, NULL
};

#endif // if(0)

//====================================================================================
//====================================================================================
#ifdef UNICODE_TRACE
LPWSTR
#else
LPSTR
#endif
ErrorToTextASN(ERROR_MAP *Map, int nErrorCode)
{
    register int nIndex = 0;

    if (Map != NULL)
    {
        for (nIndex = 0; Map[nIndex].pszErrorText; nIndex++)
        {
            if (Map[nIndex].nErrorCode == nErrorCode)
            {
                return Map[nIndex].pszErrorText;
            }
        }
    }
    return __TEXT("Unknown ASN.1 Error");
}

#if 0
//------------------------------------------------------------------------
//------------------------------------------------------------------------
int
ASN1LinePrint(FILE *stream, const char *format, ...)
{
    va_list marker;
    char buf[300];
    int i;

    va_start(marker, format);
    i = wsprintf(buf, format, marker);
    va_end(marker);

    // TRACE the buf...
    ISRTRACE(ghISRInst, buf, 0L);

    return i;
}
#endif



#define USE_ASN1_ENCODING 5

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,                     // this data is not yet passed in the PDU...
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    // redundant! memset to zero ---> UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    // redundant ---> UserInfo.bit_mask &= (~user_data_present);

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = 
            H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = setup_chosen;
    UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask = 0;

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.protocolIdentifier = &ProtocolId1;

    if (pCallerAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.sourceAddress), pCallerAliasList);
        if (AliasResult != CS_OK)
        {
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (sourceAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~sourceAddress_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask = 0;

    if (pVendorInfo)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |= vendor_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask = 0;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;
        if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                pVendorInfo->pProductNumber->wOctetStringLength)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask |= productId_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.length =
                pVendorInfo->pProductNumber->wOctetStringLength;
            memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.value,
                pVendorInfo->pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->wOctetStringLength);
        }
        if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                pVendorInfo->pVersionNumber->wOctetStringLength)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask |= versionId_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.length =
                pVendorInfo->pVersionNumber->wOctetStringLength;
            memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.value,
                pVendorInfo->pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->wOctetStringLength);
        }
    }

    if (bIsTerminal)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |=
            terminal_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.terminal.bit_mask = 0;
    }

    if (bIsGateway)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |=
            gateway_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.gateway.bit_mask = protocol_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.gateway.protocol = &TempProtocol;
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.mc = (ASN1_BOOL)bCallerIsMC;
    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.undefinedNode = 0;

    if (pCalleeAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasWithPrefixToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.destinationAddress), pCalleeAliasList);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.
                h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (destinationAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~destinationAddress_present);
    }

    if (pExtraAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasWithPrefixToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.destExtraCallInfo), pExtraAliasList);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress = NULL;
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_destExtraCallInfo_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~Setup_UUIE_destExtraCallInfo_present);
    }

    if (pCalleeAddr)
    {
        DWORD a = pCalleeAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.port =
            pCalleeAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_destCallSignalAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~Setup_UUIE_destCallSignalAddress_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.activeMC = (ASN1_BOOL)bCallerIsMC;

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.length);
    }

    switch (wGoal)
	{
	case CSG_INVITE:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = invite_chosen;
		break;
    case CSG_JOIN:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = join_chosen;
		break;
	default:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = create_chosen;
	} // switch

	switch (wCallType)
	{
	case CC_CALLTYPE_1_N:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = oneToN_chosen;
		break;
	case CC_CALLTYPE_N_1:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = nToOne_chosen;
		break;
	case CC_CALLTYPE_N_N:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = nToN_chosen;
		break;
	default:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = pointToPoint_chosen;
	} // switch

    if (pCallerAddr)
    {
        DWORD a = pCallerAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.port =
            pCallerAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (sourceCallSignalAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~sourceCallSignalAddress_present);
    }

    if (pExtensionAliasItem)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = Q931CopyAliasItemToAliasAddr(&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.remoteExtensionAddress), pExtensionAliasItem);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo = NULL;
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress = NULL;
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_remoteExtensionAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~Setup_UUIE_remoteExtensionAddress_present);
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_callIdentifier_present);
        ASSERT(sizeof(GUID) 
            == sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.setup.
                callIdentifier.guid.value));
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.setup.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
            
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.
            callIdentifier.guid.length = sizeof(GUID);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    // Free the alias name structures from the UserInfo area.
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.sourceAddress);
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.destinationAddress);
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.destExtraCallInfo);
    Q931ClearAliasAddr(&(UserInfo.h323_uu_pdu.h323_message_body.u.setup.remoteExtensionAddress));

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }
    
    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf)
{
    ASN1_FreeEncoded(pWorld->pEncInfo, pEncodedBuf);
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID,          // not passed in PDU!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = releaseComplete_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.protocolIdentifier = &ProtocolId1;

    if (pbReason)
    {
        unsigned short choice = 0;

        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask |=
            (ReleaseComplete_UUIE_reason_present);
        switch (*pbReason)
        {
        case CC_REJECT_NO_BANDWIDTH:
            choice = noBandwidth_chosen;
            break;
        case CC_REJECT_GATEKEEPER_RESOURCES:
            choice = gatekeeperResources_chosen;
            break;
        case CC_REJECT_UNREACHABLE_DESTINATION:
            choice = unreachableDestination_chosen;
            break;
        case CC_REJECT_DESTINATION_REJECTION:
            choice = destinationRejection_chosen;
            break;
        case CC_REJECT_INVALID_REVISION:
            choice = ReleaseCompleteReason_invalidRevision_chosen;
            break;
        case CC_REJECT_NO_PERMISSION:
            choice = noPermission_chosen;
            break;
        case CC_REJECT_UNREACHABLE_GATEKEEPER:
            choice = unreachableGatekeeper_chosen;
            break;
        case CC_REJECT_GATEWAY_RESOURCES:
            choice = gatewayResources_chosen;
            break;
        case CC_REJECT_BAD_FORMAT_ADDRESS:
            choice = badFormatAddress_chosen;
            break;
        case CC_REJECT_ADAPTIVE_BUSY:
            choice = adaptiveBusy_chosen;
            break;
            
        case CC_REJECT_USER_BUSY:
        case CC_REJECT_IN_CONF:
            choice = inConf_chosen;
            break;
            
        case CC_REJECT_SECURITY_DENIED:
            choice = securityDenied_chosen;
            break;
            
        case CC_REJECT_CALL_DEFLECTION:
            choice = facilityCallDeflection_chosen;
            break;
        
        case CC_REJECT_NORMAL_CALL_CLEARING:// normal  = undefined reason
        case CC_REJECT_UNDEFINED_REASON:    // internal error = undefined reason
        case CC_REJECT_INTERNAL_ERROR:
            choice = RlsCmpltRsn_undfndRsn_chosen;
            break;
            
        default:
            return CS_BAD_PARAM;
            break;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice = choice;
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask |=
            (ReleaseComplete_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.
            callIdentifier.guid.length = sizeof(GUID);
    }
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier
    )
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = connect_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.protocolIdentifier = &ProtocolId1;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask |=
            (Cnnct_UUIE_h245Address_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask &=
            (~Cnnct_UUIE_h245Address_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask = 0;

    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |=
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |=
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.undefinedNode = 0;

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.length);
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask |=
            (Connect_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.connect.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.
            callIdentifier.guid.length = sizeof(GUID);
    }
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = alerting_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.protocolIdentifier = &ProtocolId1;

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask = 0;
    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask =
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask =
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.undefinedNode = 0;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask |=
            (CPg_UUIE_h245Addrss_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask &=
            (~CPg_UUIE_h245Addrss_present);
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask |=
            (Alerting_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.alerting.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.
            callIdentifier.guid.length = sizeof(GUID);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.protocolIdentifier = &ProtocolId1;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask |=
            (CPg_UUIE_h245Addrss_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &=
            (~CPg_UUIE_h245Addrss_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask = 0;
    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask =
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask =
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.undefinedNode = 0;

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask |=
            (CallProceeding_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.
            callIdentifier.guid.length = sizeof(GUID);
    }
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = facility_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.facility.protocolIdentifier = &ProtocolId1;

    if (AlternativeAddr != NULL)
    {
        DWORD a = AlternativeAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.port =
            AlternativeAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (alternativeAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~alternativeAddress_present);
    }

    if (pAlternativeAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.facility.alternativeAliasAddress), pAlternativeAliasList);
        if (AliasResult != CS_OK)
        {
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (alternativeAliasAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~alternativeAliasAddress_present);
    }

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.length);
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (Facility_UUIE_conferenceID_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~Facility_UUIE_conferenceID_present);
    }

    switch (bReason)
	{
	case CC_REJECT_ROUTE_TO_GATEKEEPER:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
		    = FacilityReason_routeCallToGatekeeper_chosen;
		break;
	case CC_REJECT_CALL_FORWARDED:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
		    = callForwarded_chosen;
		break;
	case CC_REJECT_ROUTE_TO_MC:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
		    = routeCallToMC_chosen;
		break;
	default:
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
            = RlsCmpltRsn_undfndRsn_chosen;
	} // switch

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (Facility_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.facility.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.
            callIdentifier.guid.length = sizeof(GUID);
    }
    
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    // Free the alias name structures from the UserInfo area.
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        facility.alternativeAliasAddress);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }
    
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL
Q931ValidPduVersion(struct ObjectID_ *id)
{
// not sure what version checking to put here
#if 0
    if ((id != NULL) && (id->value == 0) && (id->next != NULL) && (id->next->value <= 1))
    {
        return TRUE;
    }
    return FALSE;
#else
    return TRUE;
#endif
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Setup information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != setup_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // make sure that the conference id is formed correctly.
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.length >
            sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.value))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

#if 0
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice != create_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_OPTION_NOT_IMPLEMENTED;
    }
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callType.choice != pointToPoint_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_OPTION_NOT_IMPLEMENTED;
    }
#endif

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_SETUP_ASN));
    pParsedData->SourceAddr.bMulticast = FALSE;
    pParsedData->CallerAddr.bMulticast = FALSE;
    pParsedData->CalleeDestAddr.bMulticast = FALSE;
    pParsedData->CalleeAddr.bMulticast = FALSE;

    // no validation of sourceInfo needed.

    pParsedData->EndpointType.pVendorInfo = NULL;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (vendor_present))
    {
        pParsedData->EndpointType.pVendorInfo = &(pParsedData->VendorInfo);
        pParsedData->VendorInfo.bCountryCode =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35CountryCode;
        pParsedData->VendorInfo.bExtension =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35Extension;
        pParsedData->VendorInfo.wManufacturerCode =
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.manufacturerCode;
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask & (productId_present))
        {
            pParsedData->VendorInfo.pProductNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pProductNumber == NULL)
            {
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pProductNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.length,
                CC_MAX_PRODUCT_LENGTH - 1);
            memcpy(pParsedData->bufProductValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.value,
                pParsedData->VendorInfo.pProductNumber->wOctetStringLength);
            pParsedData->bufProductValue[pParsedData->VendorInfo.pProductNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pProductNumber->pOctetString = pParsedData->bufProductValue;
        }
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask & (versionId_present))
        {
            pParsedData->VendorInfo.pVersionNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pVersionNumber == NULL)
            {
                MemFree(pParsedData->VendorInfo.pProductNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pVersionNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.length,
                CC_MAX_VERSION_LENGTH - 1);
            memcpy(pParsedData->bufVersionValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.value,
                pParsedData->VendorInfo.pVersionNumber->wOctetStringLength);
            pParsedData->bufVersionValue[pParsedData->VendorInfo.pVersionNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pVersionNumber->pOctetString = pParsedData->bufVersionValue;
        }
    }

    pParsedData->EndpointType.bIsTerminal = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (terminal_present))
    {
        pParsedData->EndpointType.bIsTerminal = TRUE;
    }
    pParsedData->EndpointType.bIsGateway = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (gateway_present))
    {
        pParsedData->EndpointType.bIsGateway = TRUE;
    }

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            == H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

//RMO. ignore the h245 address.

    {
        CS_STATUS AliasResult = CS_OK;

        // parse the sourceAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pCallerAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
        if (AliasResult != CS_OK)
        {
  			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				MemFree(pParsedData->NonStandardData.sData.pOctetString);
			MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the destinationAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pCalleeAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
        if (AliasResult != CS_OK)
        {
            Q931FreeAliasNames(pParsedData->pCallerAliasList);
   			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				MemFree(pParsedData->NonStandardData.sData.pOctetString);
            pParsedData->pCallerAliasList = NULL;
            MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the destExtraCallInfo aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pExtraAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo);
        if (AliasResult != CS_OK)
        {
            Q931FreeAliasNames(pParsedData->pCalleeAliasList);
            Q931FreeAliasNames(pParsedData->pCallerAliasList);
  			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				MemFree(pParsedData->NonStandardData.sData.pOctetString);
            pParsedData->pCallerAliasList = NULL;
            MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the remoteExtensionAddress aliases here...
        if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
                Setup_UUIE_remoteExtensionAddress_present) != 0)
        {
            AliasResult = Q931AliasAddrToAliasItem(&(pParsedData->pExtensionAliasItem),
                &(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.remoteExtensionAddress));
            if (AliasResult != CS_OK)
            {
                Q931FreeAliasNames(pParsedData->pExtraAliasList);
                Q931FreeAliasNames(pParsedData->pCalleeAliasList);
                Q931FreeAliasNames(pParsedData->pCallerAliasList);
                pParsedData->pCallerAliasList = NULL;
  				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					MemFree(pParsedData->NonStandardData.sData.pOctetString);
                MemFree(pParsedData->VendorInfo.pProductNumber);
                MemFree(pParsedData->VendorInfo.pVersionNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
        }
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_destCallSignalAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->CalleeDestAddr.Addr.IP_Binary.dwAddr));
        pParsedData->CalleeDestAddr.nAddrType = CC_IP_BINARY;
        pParsedData->CalleeDestAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[3];
        pParsedData->CalleeDestAddrPresent = TRUE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            sourceCallSignalAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->SourceAddr.Addr.IP_Binary.dwAddr));
        pParsedData->SourceAddr.nAddrType = CC_IP_BINARY;
        pParsedData->SourceAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[3];
        pParsedData->SourceAddrPresent = TRUE;
    }

    pParsedData->bCallerIsMC = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.activeMC;

    memcpy(pParsedData->ConferenceID.buffer,
        pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.value,
        pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.length);

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callIdentifier.guid.length);
    }
    
#if(0)  // not yet implemented
    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_fastStart_present) != 0)
    {

    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_fastCap_present) != 0)
    {

    }
#endif

    switch (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice)
	{
	case invite_chosen:
		pParsedData->wGoal = CSG_INVITE;
		break;
	case join_chosen:
		pParsedData->wGoal = CSG_JOIN;
		break;
	default:
		pParsedData->wGoal = CSG_CREATE;
	} // switch

	switch (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callType.choice)
    {
	case oneToN_chosen:
        pParsedData->wCallType = CC_CALLTYPE_1_N;
		break;
	case nToOne_chosen:
        pParsedData->wCallType = CC_CALLTYPE_N_1;
		break;
	case nToN_chosen:
        pParsedData->wCallType = CC_CALLTYPE_N_N;
		break;
	default:
        pParsedData->wCallType = CC_CALLTYPE_PT_PT;
    } // switch

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Release Complete information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != releaseComplete_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_RELEASE_COMPLETE_ASN));

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            == H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask &
            ReleaseComplete_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.callIdentifier.guid.length);
    }
    
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask 
        & ReleaseComplete_UUIE_reason_present)
    {
        switch (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice)
		{
        case noBandwidth_chosen:
			pParsedData->bReason = CC_REJECT_NO_BANDWIDTH;
			break;
        case gatekeeperResources_chosen:
			pParsedData->bReason = CC_REJECT_GATEKEEPER_RESOURCES;
			break;
        case unreachableDestination_chosen:
			pParsedData->bReason = CC_REJECT_UNREACHABLE_DESTINATION;
			break;
        case destinationRejection_chosen:
			pParsedData->bReason = CC_REJECT_DESTINATION_REJECTION;
			break;
        case ReleaseCompleteReason_invalidRevision_chosen:
			pParsedData->bReason = CC_REJECT_INVALID_REVISION;
			break;
        case noPermission_chosen:
			pParsedData->bReason = CC_REJECT_NO_PERMISSION;
			break;
        case unreachableGatekeeper_chosen:
			pParsedData->bReason = CC_REJECT_UNREACHABLE_GATEKEEPER;
			break;
        case gatewayResources_chosen:
			pParsedData->bReason = CC_REJECT_GATEWAY_RESOURCES;
			break;
        case badFormatAddress_chosen:
			pParsedData->bReason = CC_REJECT_BAD_FORMAT_ADDRESS;
			break;
        case adaptiveBusy_chosen:
			pParsedData->bReason = CC_REJECT_ADAPTIVE_BUSY;
			break;
        case inConf_chosen:
			pParsedData->bReason = CC_REJECT_IN_CONF;
			break;
        case securityDenied_chosen:
			pParsedData->bReason = CC_REJECT_SECURITY_DENIED;
			break;
        case facilityCallDeflection_chosen:
			pParsedData->bReason = CC_REJECT_CALL_DEFLECTION;
			break;
		default:
            pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
		} // switch
    }
	else
	{
		pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
	}

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Connect information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != connect_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // make sure that the conference id is formed correctly.
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.length >
            sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.value))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_CONNECT_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength = (WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.connect.bit_mask &
            Cnnct_UUIE_h245Address_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[3];
        pParsedData->h245AddrPresent = TRUE;
    }
    else
    {
        pParsedData->h245AddrPresent = FALSE;
    }

    // no validation of destinationInfo needed.

    pParsedData->EndpointType.pVendorInfo = NULL;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (vendor_present))
    {
        pParsedData->EndpointType.pVendorInfo = &(pParsedData->VendorInfo);
        pParsedData->VendorInfo.bCountryCode =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35CountryCode;
        pParsedData->VendorInfo.bExtension =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35Extension;
        pParsedData->VendorInfo.wManufacturerCode =
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.manufacturerCode;

        if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask & (productId_present))
        {
            pParsedData->VendorInfo.pProductNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pProductNumber == NULL)
            {
				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					MemFree(pParsedData->NonStandardData.sData.pOctetString);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pProductNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.length,
                CC_MAX_PRODUCT_LENGTH - 1);
            memcpy(pParsedData->bufProductValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.value,
                pParsedData->VendorInfo.pProductNumber->wOctetStringLength);
            pParsedData->bufProductValue[pParsedData->VendorInfo.pProductNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pProductNumber->pOctetString = pParsedData->bufProductValue;
        }
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask & (versionId_present))
        {
            pParsedData->VendorInfo.pVersionNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pVersionNumber == NULL)
            {
				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					MemFree(pParsedData->NonStandardData.sData.pOctetString);
                MemFree(pParsedData->VendorInfo.pProductNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pVersionNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.length,
                CC_MAX_VERSION_LENGTH - 1);
            memcpy(pParsedData->bufVersionValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.value,
                pParsedData->VendorInfo.pVersionNumber->wOctetStringLength);
            pParsedData->bufVersionValue[pParsedData->VendorInfo.pVersionNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pVersionNumber->pOctetString = pParsedData->bufVersionValue;
        }

    }

    pParsedData->EndpointType.bIsTerminal = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (terminal_present))
    {
        pParsedData->EndpointType.bIsTerminal = TRUE;
    }
    pParsedData->EndpointType.bIsGateway = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (gateway_present))
    {
        pParsedData->EndpointType.bIsGateway = TRUE;
    }


    memcpy(pParsedData->ConferenceID.buffer,
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.value,
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.length);

     if ((pUserInfo->h323_uu_pdu.h323_message_body.u.connect.bit_mask &
            Connect_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.callIdentifier.guid.length);
    }

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Alerting information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != alerting_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_ALERTING_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.bit_mask &
            CPg_UUIE_h245Addrss_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.bit_mask &
            Alerting_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.callIdentifier.guid.length);
    }

//RMO. ignore the destinationInfo field.

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Call Proceeding information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != callProceeding_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_CALL_PROCEEDING_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
        pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
				pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &
            CPg_UUIE_h245Addrss_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &
            CallProceeding_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.callIdentifier.guid.length);
    }
//RMO. ignore the destinationInfo field.

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Facility information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != facility_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    {
        struct ObjectID_ *id;

        id = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.protocolIdentifier;
        if (!Q931ValidPduVersion(id))
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_INCOMPATIBLE_VERSION;
        }
    }

    // if there is a conference id, make sure that it is formed correctly.
    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            Facility_UUIE_conferenceID_present) != 0)
    {
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.length >
                sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.value))
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_BAD_PARAM;
        }
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_FACILITY_ASN));
    pParsedData->AlternativeAddr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            alternativeAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->AlternativeAddr.Addr.IP_Binary.dwAddr));
        pParsedData->AlternativeAddr.nAddrType = CC_IP_BINARY;
        pParsedData->AlternativeAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            alternativeAliasAddress_present) != 0)
    {
        CS_STATUS AliasResult = CS_OK;

        // parse the sourceAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pAlternativeAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAliasAddress);
        if (AliasResult != CS_OK)
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            Facility_UUIE_conferenceID_present) != 0)
    {
        memcpy(pParsedData->ConferenceID.buffer,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.length);
        pParsedData->ConferenceIDPresent = TRUE;
    }

	switch (pUserInfo->h323_uu_pdu.h323_message_body.u.facility.reason.choice)
    {
	case FacilityReason_routeCallToGatekeeper_chosen:
        pParsedData->bReason = CC_REJECT_ROUTE_TO_GATEKEEPER;
		break;
	case callForwarded_chosen:
        pParsedData->bReason = CC_REJECT_CALL_FORWARDED;
		break;
	case routeCallToMC_chosen:
        pParsedData->bReason = CC_REJECT_ROUTE_TO_MC;
		break;
	default:
        pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
	} // switch


    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            Facility_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.facility.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.callIdentifier.guid.length);
    }
    
    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

int H225_InitModule(void)
{
    H225ASN_Module_Startup();
    return (H225ASN_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int H225_TermModule(void)
{
    H225ASN_Module_Cleanup();
    return ASN1_SUCCESS;
}

int Q931_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,         // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H225ASN_Module,         // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        Q931_TermWorld(pWorld);
    }

    return rc;
}

int Q931_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize)
{
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        *pcbEncodedSize = pEncInfo->len;        // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        ASSERT(FALSE);
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
    return rc;
}

int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\q931plog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// AUTHOR    Tony Moy, Stacy Bell
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by Q931 and
//		the Q931 PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the Q931 protocol as the one to be logged.  In the 
// Q931 code, it is used only in the InteorpLoad() call.  
// For example:  Q931Logger = InteropLoad( Q931LOG_PROTOCOL );
//

#define Q931LOG_PROTOCOL "Q931_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// Q931 to the logging via user data.  Bit zero of the user data represents
// whether the PDU was sent or received.
//

#define Q931LOG_SENT_PDU        1UL
#define Q931LOG_RECEIVED_PDU    0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rmese.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rmese.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RMESE.C  $
 * $Revision:   1.3  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/RMESE.C_v  $
 *
 *    Rev 1.3   09 Dec 1996 13:37:00   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.2   04 Jun 1996 13:57:38   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:26   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:40   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:50   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:45:20   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rmese.h"



// Out-going/In-coming RMESE states
#define RMESE_IDLE                  0   // IDLE
#define RMESE_WAIT                  1   // AWAITING_RESPONSE



extern unsigned int uT107;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T107ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T107ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T107Expiry);
} // T107ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RMESE0_SEND_requestF - SEND.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE0_SEND_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RMESE0_SEND_request:%d", pObject->Key);

    // Save information for release
    pObject->u.rmese = pPdu->u.indication.u.rqstMltplxEntryRls;

    // Send RequestMultiplexEntry PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T107
    pObject->State = RMESE_WAIT;
    FsmStartTimer(pObject, T107ExpiryF, uT107);

    return lError;
} // RMESE0_SEND_request



/*
 *  NAME
 *      RMESE1_SEND_requestF - SEND.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_SEND_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_SEND_request:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Save information for release
    pObject->u.rmese = pPdu->u.indication.u.rqstMltplxEntryRls;

    // Send RequestMultiplexEntry PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T107
    FsmStartTimer(pObject, T107ExpiryF, uT107);

    return lError;
} // RMESE1_SEND_request



/*
 *  NAME
 *      RMESE1_RequestMuxEntryAckF - RequestMultiplexEntryAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryAckF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntryAck:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Send SEND.confirm to H.245 user
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(pPdu, H245_CONF_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryAck



/*
 *  NAME
 *      RMESE1_RequestMuxEntryRejF - RequestMultiplexEntryReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryRejF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE0_RequestMuxEntryRej:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Send REJECT.indication to H.245 user
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(pPdu, H245_CONF_RMESE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryRej



/*
 *  NAME
 *      RMESE1_T107ExpiryF - timer T107 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_T107ExpiryF              (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "RMESE1_T107Expiry:%d", pObject->Key);

    // Send RequestMultiplexEntryRelease PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RMESE1_T107ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = rqstMltplxEntryRls_chosen;
    pOut->u.indication.u.rqstMltplxEntryRls = pObject->u.rmese;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_RMESE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // RMESE1_T107Expiry

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RMESE0_RequestMuxEntryF - RequestMultiplexEntry received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE0_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RMESE0_RequestMuxEntry:%d", pObject->Key);

    // Send SEND.indication to H.245 user
    pObject->State = RMESE_WAIT;
    H245FsmIndication(pPdu, H245_IND_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE0_RequestMuxEntry



/*
 *  NAME
 *      RMESE1_RequestMuxEntryF - RequestMultiplexEntry received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntry:%d", pObject->Key);

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_RMESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send SEND.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntry



/*
 *  NAME
 *      RMESE1_RequestMuxEntryReleaseF - RequestMultiplexEntryRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryReleaseF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntryRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = RMESE_IDLE;
    H245FsmIndication(pPdu, H245_IND_RMESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryRelease



/*
 *  NAME
 *      RMESE1_SEND_responseF - SEND.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_SEND_responseF           (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_SEND_response:%d", pObject->Key);

    // Send RequestMultiplexEntryAck PDU to remote peer
    pObject->State = RMESE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // RMESE1_SEND_response



/*
 *  NAME
 *      RMESE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_REJECT_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_REJECT_request:%d", pObject->Key);

    // Send RequestMultiplexEntryReject PDU to remote
    pObject->State = RMESE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // RMESE1_REJECT_request

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\queue.h ===
/***********************************************************************
 *  INTEL Corporation Prorietary Information                           *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation.                          *
 ***********************************************************************/
/*-*-------------------------------------------------------------------------

   File Name:
      queue.h

   Summary:
      Queue management header file.

   Prerequisites:
      windows.h

   Hide:
   $Header:   S:\sturgeon\src\h245ws\vcs\queue.h_v   1.5   13 Dec 1996 12:13:58   SBELL1  $

-------------------------------------------------------------------------*-*/

#ifndef QUEUE_H
#define QUEUE_H

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

#define NORMAL          0
#define ABNORMAL        1

#define MAX_QUEUE_SIZE  10
#define Q_NULL          -1

typedef struct _QUEUE
{

    LPVOID              apObjects[MAX_QUEUE_SIZE];
    int                 nHead;
    int                 nTail;
    CRITICAL_SECTION    CriticalSection;

} QUEUE, *PQUEUE;


PQUEUE  QCreate         (void);
void    QFree           (PQUEUE pQueue);
BOOL    QInsert         (PQUEUE pQueue, LPVOID pObject);
BOOL    QInsertAtHead   (PQUEUE pQueue, LPVOID pObject);
LPVOID  QRemove         (PQUEUE pQueue);
BOOL    IsQEmpty        (PQUEUE pQueue);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  /* QUEUE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\queue.c ===
/***************************************************************************
 *
 * File: queue.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   queue.c  $
 * $Revision:   1.8  $
 * $Modtime:   13 Dec 1996 11:48:16  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\queue.c_v  $
 * 
 *    Rev 1.8   13 Dec 1996 12:13:12   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.7   May 28 1996 10:39:00   plantz
 * Change QFree to not free objects on the queue; instead it insists that
 * the queue be empty.
 * 
 *    Rev 1.6   21 May 1996 16:21:36   EHOWARDX
 * Added DeleteCriticalSection to QFree().
 * 
 *    Rev 1.5   Apr 24 1996 16:18:58   plantz
 * Removed include winsock2.h and incommon.h
 * 
 *    Rev 1.3.1.0   Apr 24 1996 16:16:42   plantz
 * Removed include winsock2.h and callcont.h
 * 
 *    Rev 1.3   01 Apr 1996 14:53:28   EHOWARDX
 * Changed pQUEUE to PQUEUE.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:34   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:22:38   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef STRICT
#define STRICT
#endif	// not defined STRICT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include "precomp.h"

#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)



/*-*-------------------------------------------------------------------------

   Function Name:
      QCreate

   Syntax:
      PQUEUE QCreate(void);

   Parameters:
      None.

   Summary:
      Allocates and initializes a new queue.

   Returns:
      NULL        - Allocation of memory for new queue failed.
      Otherwise   - Address of new queue created.

-------------------------------------------------------------------------*-*/

PQUEUE QCreate(void)
{
   register PQUEUE     pQueue;         /* pointer to the new queue         */

   /* Allocate a new queue */
   pQueue = (PQUEUE)MemAlloc(sizeof(QUEUE));
   if (pQueue != NULL)
   {
      /* Initialize the new queue */
      pQueue->nHead = pQueue->nTail = Q_NULL;
      InitializeCriticalSection(&pQueue->CriticalSection);
   }

   return pQueue;
} /* QCreate */



/*-*-------------------------------------------------------------------------

   Function Name:
      QFree

   Syntax:
      void QFree(PQUEUE pQueue);

   Parameters:
      pQueue      -pointer to the queue to free

   Summary:
      Deallocates a queue that was allocated by QCreate.

-------------------------------------------------------------------------*-*/

void QFree(PQUEUE pQueue)
{
   /* The queue must be empty before it is freed. */
   HWSASSERT(pQueue->nHead == Q_NULL);

   /* Free the queue. */
   DeleteCriticalSection(&pQueue->CriticalSection);
   MemFree(pQueue);
} /* QFree */



/*
 *  NAME
 *      QRemove - remove object from head of queue
 *
 *  ARGUMENTS
 *      pQueue      Pointer to queue
 *
 *  RETURN VALUE
 *      Pointer to object dequeued or NULL of queue empty
 */

/*-*-------------------------------------------------------------------------

   Function Name:
      QRemove

   Syntax:
      LPVOID QRemove(PQUEUE pQueue);

   Parameters:
      pQueue      - Pointer to queue.

   Summary:
      Removes and returns object from head of queue.

   Returns:
      NULL        - Queue was empty.
      Otherwise   - Address of object dequeued.

-------------------------------------------------------------------------*-*/

LPVOID QRemove(PQUEUE pQueue)
{
   register LPVOID     pObject;           /* pointer to the object to remove  */

   EnterCriticalSection(&pQueue->CriticalSection);

   if (pQueue->nHead == Q_NULL)
   {
      /* If the queue is empty, we will return NULL */
      pObject = NULL;
   }
   else
   {
      /* Get the pointer, NULL it in the apObjects array. */
      pObject = pQueue->apObjects[pQueue->nHead];
      pQueue->apObjects[pQueue->nHead] = NULL;

      /* Check to see if we've just emptied the queue; if so, set */
      /* the nHead and nTail indices to Q_NULL.  If not, set the nHead */
      /* index to the right value. */
      if (pQueue->nHead == pQueue->nTail)
      {
         pQueue->nHead = pQueue->nTail = Q_NULL;
      }
      else
      {
         pQueue->nHead = (pQueue->nHead + 1) % MAX_QUEUE_SIZE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return pObject;
} /* QRemove */



/*-*-------------------------------------------------------------------------

   Function Name:
      QInsert

   Syntax:
      BOOL QInsert(PQUEUE pQueue, LPVOID pObject);

   Parameters:
      pQueue      - Pointer to queue to insert object into.
      pObject     - Pointer to object to insert into queue.

   Summary:
      Inserts an object at tail of queue.

   Returns:
      TRUE        - Object successfully added to queue.
      FALSE       - Queue full; object could not be added.

-------------------------------------------------------------------------*-*/

BOOL QInsert(PQUEUE pQueue, LPVOID pObject)
{
   register int        iTemp;

   EnterCriticalSection(&pQueue->CriticalSection);

   /* If the queue is full, set the return value to FALSE and do */
   /* nothing; if not, update the indices appropriately and set the */
   /* return value to TRUE.  */
   if (pQueue->nHead == Q_NULL)
   {
      /* Queue is empty */
      pQueue->apObjects[0] = pObject;
      pQueue->nHead = pQueue->nTail = 0;
      iTemp = TRUE;
   }
   else
   {
      iTemp = (pQueue->nTail + 1) % MAX_QUEUE_SIZE;
      if (iTemp == pQueue->nHead)
      {
         /* Queue is full */
         iTemp = FALSE;
      }
      else
      {
         pQueue->apObjects[iTemp] = pObject;
         pQueue->nTail = iTemp;
         iTemp = TRUE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return (BOOL) iTemp;
}



/*-*-------------------------------------------------------------------------

   Function Name:
      QInsertAtHead

   Syntax:
      BOOL QInsertAtHead(PQUEUE pQueue, LPVOID pObject);

   Parameters:
      pQueue      - Pointer to queue to insert object into.
      pObject     - Pointer to object to insert into queue.

   Summary:
      Inserts an object at head of queue.

   Returns:
      TRUE        - Object successfully added to queue.
      FALSE       - Queue full; object could not be added.

-------------------------------------------------------------------------*-*/

BOOL QInsertAtHead(PQUEUE pQueue, LPVOID pObject)
{
   register int        iTemp;

   EnterCriticalSection(&pQueue->CriticalSection);

   if (pQueue->nHead == Q_NULL)
   {
      /* Queue is empty */
      pQueue->apObjects[0] = pObject;
      pQueue->nHead = pQueue->nTail = 0;
      iTemp = TRUE;
   }
   else
   {
      iTemp = (pQueue->nHead + (MAX_QUEUE_SIZE - 1)) % MAX_QUEUE_SIZE;
      if (iTemp == pQueue->nTail)
      {
         /* Queue is full */
         iTemp = FALSE;
      }
      else
      {
         pQueue->apObjects[iTemp] = pObject;
         pQueue->nHead = iTemp;
         iTemp = TRUE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return (BOOL) iTemp;
} /* QInsertAtHead */



/*-*-------------------------------------------------------------------------

   Function Name:
      IsQEmpty

   Syntax:
      BOOL IsQEmpty(PQUEUE pQueue);

   Parameters:
      pQueue      - Pointer to queue to check.

   Summary:
      Checks if a queue is empty.

   Returns:
      TRUE        - Queue is empty.
      FALSE       - Queue contains at least one object.

-------------------------------------------------------------------------*-*/

BOOL IsQEmpty(PQUEUE pQueue)
{
   return (pQueue->nHead == Q_NULL ? TRUE : FALSE);
} /* IsQEmpty */



#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rasplog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1994:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR	Steve Nesland, Sam Sakthivel
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by MBFT and
//		the MBFT PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the MBFT protocol as the one to be logged.  In the 
// MBFT code, it is used only in the CPLInitialize() call.  
// For example:  MBFTProtocolLogger = CPLInitialize( MBFT_PROTOCOL );
//
#define RASLOG_PROTOCOL "RAS_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// MBFT to the logging via user data.  Bit zero of the user data represents
// the ASN encoding type.  Bit 1 represents pdu type (Connect or Domain).
// Bit 2 represents whether the PDU was sent or received.
//

#define RASLOG_SENT_PDU                1UL
#define RASLOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\retry.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\retry.cpv  $
*																		*
*	$Revision:   1.11  $
*	$Date:   12 Feb 1997 01:10:26  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\retry.cpv  $
// 
//    Rev 1.11   12 Feb 1997 01:10:26   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.10   08 Feb 1997 13:05:10   CHULME
// Added debug message for thread termination
// 
//    Rev 1.9   08 Feb 1997 12:18:08   CHULME
// Added Check for semaphore signalling to exit the retry thread
// 
//    Rev 1.8   24 Jan 1997 18:29:44   CHULME
// Reverted to rev 1.6
// 
//    Rev 1.6   22 Jan 1997 20:45:38   EHOWARDX
// Work-around for race condition that may result in
// GKI_RegistrationRequest returning GKI_ALREADY_REG.
// 
//    Rev 1.5   17 Jan 1997 09:02:34   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:16:04   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 01:28:00   CHULME
// Fixed memory leak on GK_REG_BYPASS
// 
//    Rev 1.2   22 Nov 1996 15:21:12   CHULME
// Added VCS log to the header
*************************************************************************/

// retry.cpp : Provides a background retry thread
//
#include "precomp.h"

#include "gkicom.h"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if (0)
void 
Retry(void *pv)
{
	// ABSTRACT:  This function is invoked in a separate thread to
	//            periodically check for outstanding PDUs.  If a configurable 
	//            timeout period has expired, the PDU will be reissued.  If
	//            the maximum number of retries has been exhausted, this thread
	//            will clean-up the appropriate memory.
	// AUTHOR:    Colin Hulme

	DWORD			dwTime, dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;
	HANDLE			hRetrySemaphore;
	
	SPIDER_TRACE(SP_FUNC, "Retry(pv)\n", 0);
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return; 
		
	dwTime = g_pGatekeeper->GetRetryMS();

	g_pGatekeeper->Lock();
	while (hResult == GKI_OK)
	{
		hRetrySemaphore = g_pReg->m_hRetrySemaphore;
		g_pGatekeeper->Unlock();
		dwErrorCode = WaitForSingleObject(hRetrySemaphore, dwTime);
		if(dwErrorCode != WAIT_TIMEOUT)
		{
			SPIDER_TRACE(SP_THREAD, "Retry thread exiting\n", 0);
			return;		// Exit thread
		}

		g_pGatekeeper->Lock();
		if (g_pReg == 0)
		{
			SPIDER_TRACE(SP_THREAD, "Retry thread exiting\n", 0);
			g_pGatekeeper->Unlock();
			return;		// Exit thread
		}

		hResult = g_pReg->Retry();
	}

	SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
	delete g_pReg;
	g_pReg = 0;

	SPIDER_TRACE(SP_THREAD, "Retry thread exiting\n", 0);
	g_pGatekeeper->Unlock();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rmese.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rmese.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RMESE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RMESE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:30   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:43:28   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:07:58   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mux Entry (RMESE_OUT) state functions
HRESULT RMESE0_SEND_requestF            (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_SEND_requestF            (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryAckF      (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryRejF      (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_T107ExpiryF              (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mux Entry (RMESE_OUT) state functions
HRESULT RMESE0_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryReleaseF  (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_SEND_responseF           (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_REJECT_requestF          (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\sr_api.h ===
/******************************************************************************
 *
 *  File:  sr_api.h
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   sr_api.h  $
 *  $Revision:   1.5  $
 *  $Modtime:   Mar 04 1997 17:32:54  $
 *  $History$
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/sr_api.h_v  $
 *
 *    Rev 1.5   Mar 04 1997 17:52:48   tomitowx
 * process detach fix
 *
 *    Rev 1.4   19 Jul 1996 12:04:34   EHOWARDX
 *
 * Eliminated H245DLL #define (God only knows why Dan put it in this
 * file in the first place!)
 *
 *    Rev 1.3   05 Jun 1996 17:20:20   EHOWARDX
 * Changed initializeASN1 and terminateASN1 prototypes back to int.
 *
 *    Rev 1.2   05 Jun 1996 16:37:18   EHOWARDX
 * Further work in converting to HRESULT.
 *
 *    Rev 1.1   30 May 1996 23:38:34   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:05:00   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.8   09 May 1996 19:38:18   EHOWARDX
 * Redesigned locking logic and added new functionality.
 *
 *    Rev 1.7   15 Apr 1996 13:00:14   DABROWN1
 *
 * Added SR initialize trace logging call
 *
 *    Rev 1.6   12 Apr 1996 10:27:40   dabrown1
 *
 * removed WINAPI/windows references
 *  $Ident$
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

#ifndef _SR_API_H
#define _SR_API_H

#include "h245com.h"
#include "h245asn1.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

///////////////////////////////////////////////////////////////
///
/// TRACE Logging Defines
///
///////////////////////////////////////////////////////////////
#define H245_TRACE_ENABLED  TRUE


////////////////////////////////////////////////////////////////////
//
// Callback routines for Link Layer
//
////////////////////////////////////////////////////////////////////
void h245ReceiveComplete(DWORD_PTR h245Instance,
                         HRESULT  dwMessage,
                         PBYTE    pbDataBuf,
                         DWORD    dwLength);

void h245SendComplete   (DWORD_PTR h245Instance,
                         HRESULT  dwMessage,
                         PBYTE    pbDataBuf,
                         DWORD    dwLength);
HRESULT
sendRcvFlushPDUs
(
    struct InstanceStruct * pInstance,
    DWORD                   dwDirection,
    BOOL                    bShutdown
);

void
srInitializeLogging
(
    struct InstanceStruct * pInstance,
    BOOL                    bTracingEnabled
);

int     initializeASN1 (ASN1_CODER_INFO *);
int     terminateASN1  (ASN1_CODER_INFO *);
HRESULT sendRcvInit    (struct InstanceStruct * pInstance);
HRESULT sendRcvShutdown(struct InstanceStruct * pInstance);
HRESULT sendPDU        (struct InstanceStruct * pInstance, MltmdSystmCntrlMssg *pPdu);
HRESULT sendRcvShutdown_ProcessDetach(	struct InstanceStruct *pInstance, BOOL fProcessDetach);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _SRP_API_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rtdse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rtdse.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   rtdse.c  $
 * $Revision:   1.4  $
 * $Modtime:   Feb 28 1997 13:13:32  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/rtdse.c_v  $
 *
 *    Rev 1.4   Feb 28 1997 13:14:24   tomitowx
 * fixed Roundtripdelay timer problem.
 * that occurs when ping peer link is invalid/unvailable
 * due to an abnormal application/machine shutdown.
 *
 *    Rev 1.3   09 Dec 1996 13:37:04   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.2   04 Jun 1996 13:57:26   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:28   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:42   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:24   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:46:40   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rtdse.h"



// Out-going/In-coming RTDSE states
#define RTDSE_IDLE                  0   // IDLE
#define RTDSE_WAIT                  1   // AWAITING_RESPONSE



extern unsigned int uT105;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T105ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H.245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T105ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T105Expiry);
} // T105ExpiryF()



static void BuildRoundTripDelayResponse(PDU_t *pOut, BYTE bySequenceNumber)
{
    pOut->choice = MSCMg_rspns_chosen;
    pOut->u.MSCMg_rspns.choice = roundTripDelayResponse_chosen;
    pOut->u.MSCMg_rspns.u.roundTripDelayResponse.sequenceNumber = bySequenceNumber;
} // BuildRoundTripDelayResponse()



/***********************************************************************
 *
 * FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RTDSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE0_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RTDSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byRtdseSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber =
        pObject->pInstance->StateMachine.byRtdseSequence;

    // Send RoundTripDelayRequest PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

	
//tomitowoju@intel.com
	if(lError == H245_ERROR_OK)
	{
		// Set timer T105
		pObject->State = RTDSE_WAIT;
		FsmStartTimer(pObject, T105ExpiryF, uT105);

	}
//tomitowoju@intel.com
		// Set timer T105
//		pObject->State = RTDSE_WAIT;
//		FsmStartTimer(pObject, T105ExpiryF, uT105);
//tomitowoju@intel.com

    return lError;
} // RTDSE0_TRANSFER_request



/*
 *  NAME
 *      RTDSE0_RoundTripDelayRequestF - RoundTripDelayRequest received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE0_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RTDSE0_RoundTripDelayRequest:%d", pObject->Key);

    // Send RoundTripDelayResponse to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RTDSE0_RoundTripDelayRequestF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildRoundTripDelayResponse(pOut, (BYTE)pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
} // RTDSE0_RoundTripDelayRequest



/*
 *  NAME
 *      RTDSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T105
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byRtdseSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber =
        pObject->pInstance->StateMachine.byRtdseSequence;

    // Send RoundTripDelayRequest PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T105
    FsmStartTimer(pObject, T105ExpiryF, uT105);

    return lError;
} // RTDSE1_TRANSFER_request



/*
 *  NAME
 *      RTDSE1_RoundTripDelayRequestF - RoundTripDelayRequest received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_RoundTripDelayRequest:%d", pObject->Key);

    // Send RoundTripDelayResponse to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RTDSE1_RoundTripDelayRequestF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildRoundTripDelayResponse(pOut, (BYTE)pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
} // RTDSE1_RoundTripDelayRequest



/*
 *  NAME
 *      RTDSE1_RoundTripDelayResponseF - RoundTripDelayResponse in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_RoundTripDelayResponseF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_RoundTripDelayResponse:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.roundTripDelayResponse.sequenceNumber ==
        pObject->pInstance->StateMachine.byRtdseSequence)
    {
        // Reset timer T105
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = RTDSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_RTDSE, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // RTDSE1_RoundTripDelayResponse



/*
 *  NAME
 *      RTDSE1_T105ExpiryF - timer T105 Expiry in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_T105ExpiryF              (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_T105Expiry:%d", pObject->Key);

    // Send EXPIRY.notification to client
    pObject->State = RTDSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_RTDSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RTDSE1_T105Expiry

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rqstcls.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rqstcls.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RQSTCLS.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/RQSTCLS.C_v  $
 *
 *    Rev 1.5   09 Dec 1996 13:37:02   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.4   19 Jul 1996 12:15:40   EHOWARDX
 *
 * Changed to use event definitions from H245API.H.
 *
 *    Rev 1.3   04 Jun 1996 13:57:30   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:26   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   29 May 1996 15:20:26   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.0   09 May 1996 21:06:42   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.6.1.2   09 May 1996 19:48:46   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.6.1.1   15 Apr 1996 10:46:22   EHOWARDX
 * Update.
 *
 *    Rev 1.6.1.0   10 Apr 1996 21:12:42   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rqstcls.h"



// request close channels from receive side outgoing states
#define ReqCloseOutIDLE             0
#define ReqCloseOutAwaitingResponse 1

// request close channels on open side incoming states
#define ReqCloseInIDLE              0
#define ReqCloseInAwaitingResponse  1



extern unsigned int uT108;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T108ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T108ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T108Expiry);
} // T108ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      closeRequestIdle - request to close a remote channel by API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeRequestIdle (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutIDLE);
    H245TRACE(pObject->dwInst, 2,
              "Send RequestChannelClose to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T108 */
    pObject->State = ReqCloseOutAwaitingResponse;
    FsmStartTimer(pObject, T108ExpiryF, uT108);

    return lError;
}



/*
 *  NAME
 *      requestCloseAckAwaitingR - received request close Ack in awaiting release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE to API; Channel=%d",
              pObject->Key);

    /* reset timer T108 */
    FsmStopTimer(pObject);

    /* Send CLOSE.confirm to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(pPdu, H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      requestCloseRejAwaitingR - received request close reject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseRejAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE to API with REJECT; Channel=%d",
              pObject->Key);

    /* reset timer T108 */
    FsmStopTimer(pObject);

    /* Send REJECT.indication to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(pPdu,H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId,REJECT);

    return 0;
}



/*
 *  NAME
 *      t108ExpiryAwaitingR - handle timer expiry of an outstanding request close
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t108ExpiryAwaitingR (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE with Timer T108 Expiry to API; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Release to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t108ExpiryAwaitingR: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = rqstChnnlClsRls_chosen;
    pOut->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber = (WORD)pObject->Key;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send REJECT.indication (SOURCE:=PROTOCOL to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(NULL, H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
}

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      requestCloseIdle - received requestClose in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseIdle (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInIDLE);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_REQ_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* Send CLOSE.indication to client */
    pObject->State = ReqCloseInAwaitingResponse;
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeResponseAwaitingR - respond to a requestclose with an Ack (or Reject)
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeResponseAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "Request Close Response Ack to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Ack to remote peer */
    pObject->State = ReqCloseInIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



HRESULT rejectRequestAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Request Close Response Reject to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Reject to remote peer */
    pObject->State = ReqCloseInIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      requestCloseReleaseAwaitingR - received a release while awaiting the api to respond
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseReleaseAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_REQ_CLOSE with Reject to API; Channel=%d",
              pObject->Key);

    /* Send REJECT.indication to client */
    pObject->State = ReqCloseInIDLE;
    H245FsmIndication(pPdu, H245_IND_CLCSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      requestCloseAwaitingR - overriding requestClose pdu in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseAwaitingR (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "Overriding H245_IND_REQ_CLOSE with OK to API; Channel=%d",
              pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    /* Send CLOSE.indication to client */
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\termcap.c ===
/***********************************************************************
 *                                                                     *
 * Filename: termcap.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   TERMCAP.C  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\termcap.c_v $
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "termcap.h"
#include "pdu.x"



// Terminal Capability Exchange Out-going/In-coming states
#define CapIDLE                         0
#define CapAwaitingResponse             1



extern unsigned int uT101;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T101ExpiryF - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T101ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T101Expiry);
} // T101ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      requestCapIdle - received TRANSFER.request in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT requestCapIdle(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapIDLE);

    /* Increment sequence number */
    pObject->pInstance->StateMachine.byCeseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber =
        pObject->pInstance->StateMachine.byCeseOutSequence;
    H245TRACE(  pObject->dwInst, 2, "TerminalCapabilitySet to ASN; Sequence=%d",
                pObject->pInstance->StateMachine.byCeseOutSequence);

    /* Send Terminal Capability Set to remote */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T101 */
    pObject->State = CapAwaitingResponse;
    FsmStartTimer(pObject, T101ExpiryF, uT101);

    return lError;
}



/*
 *  NAME
 *      termCapAckAwaiting - received termCap Ack in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapAckAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapAwaitingResponse);

    /* reset timer T101 */
    FsmStopTimer(pObject);

    if (pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber ==
        pObject->pInstance->StateMachine.byCeseOutSequence)
    {
        H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with no error to API; Sequence=%d",
                  pObject->pInstance->StateMachine.byCeseOutSequence);
        pObject->State = CapIDLE;
        H245FsmConfirm(pPdu, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "termCapAckAwaiting: Sequence %d != %d",
                  pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber,
                  pObject->pInstance->StateMachine.byCeseOutSequence);
    }

    return 0;
}



/*
 *  NAME
 *      termCapRejAwaiting - received termCap Ack  in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapRejAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapAwaitingResponse);

    /* reset timer T101 */
    FsmStopTimer(pObject);

    if (pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber ==
        pObject->pInstance->StateMachine.byCeseOutSequence)
    {
        H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with Reject to API; Sequence=%d",
                  pObject->pInstance->StateMachine.byCeseOutSequence);
        pObject->State = CapIDLE;
        H245FsmConfirm(pPdu, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, REJECT);
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "termCapRejAwaiting: Sequence %d != %d",
                  pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber,
                  pObject->pInstance->StateMachine.byCeseOutSequence);
    }

    return 0;
}



/*
 *  NAME
 *      t101ExpiryAwaiting - handle timer expiry for an outstanding termcap
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t101ExpiryAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapAwaitingResponse);
    ASSERT(pPdu           == NULL);

    pOut = (PDU_t *) MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* Send Terminal Capability Set Release to remote */
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = trmnlCpbltyStRls_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send REJECT.indication (SOURCE=PROTOCOL) to client */
    H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with Timer Expiry to API; Sequence=%d",
              pObject->pInstance->StateMachine.byCeseOutSequence);
    pObject->State = CapIDLE;
    H245FsmConfirm(NULL, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
}

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      termCapSetIdle - received termcap set in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapSetIdle(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapIDLE);

    /* Save sequence number from PDU */
    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;
    H245TRACE(pObject->dwInst, 2, "H245_IND_CAP with no error to API; Sequence=%d",
              pObject->byInSequence);

    /* Send TRANSFER.indication to client */
    pObject->State = CapAwaitingResponse;
    H245FsmIndication(pPdu, H245_IND_CAP, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      responseCapAwaiting - respond to a termcap with ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT responseCapAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Send Term Cap Ack to ASN; Sequence=%d",
              pObject->byInSequence);

    pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber =
        pObject->byInSequence;

    /* Send Terminal Capability Set Ack to remote */
    pObject->State = CapIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      rejectCapAwaiting - respond to a termcap with reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT rejectCapAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Send Term Cap Reject to ASN; Sequence=%d",
              pObject->byInSequence);

    pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber =
        pObject->byInSequence;

    /* Send Terminal Capability Set Reject to remote */
    pObject->State = CapIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      termCapReleaseAwaiting - received termcap release in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapReleaseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "H245_IND_CAP with Reject to API; Sequence=%d",
              pObject->byInSequence);

    /* Send REJECT.indication (SOURCE = PROTOCOL) to client */
    pObject->State = CapIDLE;
    H245FsmIndication(pPdu, H245_IND_CESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      termCapSetAwaiting - received overriding termcap set in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapSetAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);

    /* Save sequence number from PDU */
    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;
    H245TRACE(  pObject->dwInst, 2, "termCapSetAwaiting: Sequence=%d",
                pObject->byInSequence);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_CAP, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    /* Send TRANSFER.indication to client */
    H245FsmIndication(pPdu, H245_IND_CAP, pObject->pInstance, 0, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rqstcls.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rqstcls.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RQSTCLS.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RQSTCLS.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:06   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:32   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:58   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.3.1.2   15 Apr 1996 10:43:52   EHOWARDX
 * Update.
 * 
 *    Rev 1.3.1.1   10 Apr 1996 21:07:22   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.3.1.0   05 Apr 1996 11:48:24   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Close Logical Channel state functions
HRESULT closeRequestIdle                (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseAckAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseRejAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT t108ExpiryAwaitingR             (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Close Logical Channel state functions
HRESULT requestCloseIdle                (Object_t *pObject, PDU_t *pPdu);
HRESULT closeResponseAwaitingR          (Object_t *pObject, PDU_t *pPdu);
HRESULT rejectRequestAwaitingR          (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseReleaseAwaitingR    (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseAwaitingR           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\rtdse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rtdse.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RTDSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RTDSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:06   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:32   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:58   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:43:46   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:09:14   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Round Trip Delay (RTDSE) state functions
HRESULT RTDSE0_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE0_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_RoundTripDelayResponseF  (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_T105ExpiryF              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\termcap.h ===
/***********************************************************************
 *                                                                     *
 * Filename: termcap.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   TERMCAP.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/TERMCAP.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:08   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:34   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:05:00   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   15 Apr 1996 10:43:50   EHOWARDX
 * Update.
 * 
 *    Rev 1.6.1.1   10 Apr 1996 21:07:26   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.6.1.0   05 Apr 1996 11:47:56   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Terminal Capability Exchange (CESE) Out-going state functions
HRESULT requestCapIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapAckAwaiting              (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapRejAwaiting              (Object_t *pObject, PDU_t *pPdu);
HRESULT t101ExpiryAwaiting              (Object_t *pObject, PDU_t *pPdu);

// Terminal Capability Exchange (CESE) Out-going state functions
HRESULT termCapSetIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT responseCapAwaiting             (Object_t *pObject, PDU_t *pPdu);
HRESULT rejectCapAwaiting               (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapReleaseAwaiting          (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapSetAwaiting              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\userman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/userman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   Aug 12 1996 09:40:44  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitUserManager();

HRESULT DeInitUserManager();

HRESULT InvokeUserListenCallback(	PLISTEN						pListen,
									HRESULT						status,
									PCC_LISTEN_CALLBACK_PARAMS	pListenCallbackParams);

HRESULT InvokeUserConferenceCallback(
									PCONFERENCE				pConference,
									BYTE					bIndication,
									HRESULT					status,
									void *					pConferenceCallbackParams);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\userman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Userman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.22  $
 *	$Date:   22 Jan 1997 14:55:54  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"



HRESULT InitUserManager()
{
	return CC_OK;
}



HRESULT DeInitUserManager()
{
	return CC_OK;
}



HRESULT InvokeUserListenCallback(	PLISTEN						pListen,
									HRESULT						status,
									PCC_LISTEN_CALLBACK_PARAMS	pListenCallbackParams)
{
	ASSERT(pListen != NULL);
	ASSERT(pListenCallbackParams != NULL);

	pListen->ListenCallback(status, pListenCallbackParams);

	return CC_OK;
}



HRESULT InvokeUserConferenceCallback(
									PCONFERENCE				pConference,
									BYTE					bIndication,
									HRESULT					status,
									void *					pConferenceCallbackParams)
{
HRESULT		ReturnStatus;

	ASSERT(pConference != NULL);
	// Note that ConferenceCallback and/or pConferenceCallbackParams may legitimately be NULL

	if ((pConference->ConferenceCallback != NULL) &&
		(pConference->LocalEndpointAttached != DETACHED)) {
		ReturnStatus = pConference->ConferenceCallback(bIndication,
													   status,
													   pConference->hConference,
													   pConference->dwConferenceToken,
													   pConferenceCallbackParams);
	} else {
		ReturnStatus = CC_OK;
	}
	return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\utils.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/utils.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.16  $
 *	$Date:   21 Jan 1997 16:09:10  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Call Setup Utilities
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef UTILS_H
#define UTILS_H

#ifdef __cplusplus
extern "C" {
#endif

void Q931MakePhysicalID(DWORD *);

#define UnicodeToAscii(src, dest, max)    WideCharToMultiByte(CP_ACP, 0, src, -1, dest, max, NULL, NULL)
#define AsciiToUnicode(src, dest, max)    MultiByteToWideChar(CP_ACP, 0, src, -1, dest, max)

WORD ADDRToInetPort(CC_ADDR *pAddr);
DWORD ADDRToInetAddr(CC_ADDR *pAddr);
void SetDefaultPort(CC_ADDR *pAddr);
BOOL MakeBinaryADDR(CC_ADDR *pInAddr, CC_ADDR *pOutAddr);
void GetDomainAddr(CC_ADDR *pAddr);

#ifdef __cplusplus
}
#endif

#endif UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\utils.c ===
/****************************************************************************
 *
 *	$Archive:   S:\sturgeon\src\q931\vcs\utils.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.33  $
 *	$Date:   23 Jan 1997 20:42:54  $
 *	$Author:   SBELL1  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 4514 )

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include "q931.h"
#include "isrg.h"
#include "utils.h"
#include "linkapi.h"

//====================================================================================
//===============/=====================================================================
void
Q931MakePhysicalID(DWORD *pdwPhysicalID)
{
   *pdwPhysicalID = INVALID_PHYS_ID;
}

//====================================================================================
//====================================================================================
WORD
ADDRToInetPort(CC_ADDR *pAddr)
{
    WORD HostPort = 0;
    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        HostPort = pAddr->Addr.IP_DomainName.wPort;
        break;
    case CC_IP_DOT:
        HostPort = pAddr->Addr.IP_Dot.wPort;
        break;
    case CC_IP_BINARY:
        HostPort = pAddr->Addr.IP_Binary.wPort;
        break;
    }
    return htons(HostPort);
}

//====================================================================================
//====================================================================================
DWORD
ADDRToInetAddr(CC_ADDR *pAddr)
{
    struct hostent *pHostEnt;

    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        {
            char buf[sizeof(pAddr->Addr.IP_DomainName.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pAddr->Addr.IP_DomainName.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            pHostEnt = gethostbyname(buf);
        }
        if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
        {
            return htonl(0L);
        }
        return *((DWORD *)pHostEnt->h_addr_list[0]);
    
    case CC_IP_DOT:
        {
            char buf[sizeof(pAddr->Addr.IP_Dot.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pAddr->Addr.IP_Dot.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            return inet_addr(buf);
        }
    case CC_IP_BINARY:
        return htonl(pAddr->Addr.IP_Binary.dwAddr);
    }
    return 0L;
}

//====================================================================================
// If Port 0 is passed in, use default listen port.
//====================================================================================
void
SetDefaultPort(CC_ADDR *pAddr)
{
    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        if (pAddr->Addr.IP_DomainName.wPort == 0)
        {
            pAddr->Addr.IP_DomainName.wPort = CC_H323_HOST_CALL;
        }
        return;
    case CC_IP_DOT:
        if (pAddr->Addr.IP_Dot.wPort == 0)
        {
            pAddr->Addr.IP_Dot.wPort = CC_H323_HOST_CALL;
        }
        return;
    case CC_IP_BINARY:
        if (pAddr->Addr.IP_Binary.wPort == 0)
        {
            pAddr->Addr.IP_Binary.wPort = CC_H323_HOST_CALL;
        }
        return;
    }
    return;
}

//====================================================================================
//====================================================================================
BOOL
MakeBinaryADDR(CC_ADDR *pInAddr, CC_ADDR *pOutAddr)
{
    if (pOutAddr == NULL)
    {
        return FALSE;
    }

    memset(pOutAddr, 0, sizeof(CC_ADDR));

    if (pInAddr == NULL)
    {
        return FALSE;
    }

    pOutAddr->nAddrType = CC_IP_BINARY;
    pOutAddr->bMulticast = pInAddr->bMulticast;

    switch (pInAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
    {
        struct hostent *pHostEnt;
        DWORD net_addr;
        {
            char buf[sizeof(pInAddr->Addr.IP_DomainName.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pInAddr->Addr.IP_DomainName.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            if (buf[0] == '\0')
            {
                return FALSE;
            }
            pHostEnt = gethostbyname(buf);
        }
        if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
        {
            return FALSE;
        }
        net_addr = *((DWORD *)pHostEnt->h_addr_list[0]);
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_DomainName.wPort;
        pOutAddr->Addr.IP_Binary.dwAddr = ntohl(net_addr);
    }
        break;
    case CC_IP_DOT:
        {
            char buf[sizeof(pInAddr->Addr.IP_Dot.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pInAddr->Addr.IP_Dot.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            if (buf[0] == '\0')
            {
                return FALSE;
            }
            pOutAddr->Addr.IP_Binary.dwAddr = ntohl(inet_addr(buf));
        }
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_Dot.wPort;
        break;
    default:
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_Binary.wPort;
        pOutAddr->Addr.IP_Binary.dwAddr = pInAddr->Addr.IP_Binary.dwAddr;
        break;
    }
    return TRUE;
}

//====================================================================================
//====================================================================================
void
GetDomainAddr(CC_ADDR *pAddr)
{
    WORD wTemp;
    char szHostName[80];

    if (gethostname(szHostName, sizeof(szHostName)) != SOCKET_ERROR)
    {
        wTemp = pAddr->Addr.IP_Binary.wPort;
        pAddr->nAddrType = CC_IP_DOMAIN_NAME;

        MultiByteToWideChar(CP_ACP, 0, szHostName, -1,
            pAddr->Addr.IP_DomainName.cAddr,
            sizeof(pAddr->Addr.IP_DomainName.cAddr) /
            sizeof(pAddr->Addr.IP_DomainName.cAddr[0]));

        pAddr->Addr.IP_DomainName.wPort = wTemp;
    }
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAddr(PCC_ADDR pAddr)
{
    if (pAddr == NULL)
    {
        return CS_OK;
    }
    if ((pAddr->nAddrType != CC_IP_DOMAIN_NAME) &&
            (pAddr->nAddrType != CC_IP_DOT) &&
            (pAddr->nAddrType != CC_IP_BINARY))
    {
        return CS_BAD_PARAM;
    }

    if (pAddr->nAddrType == CC_IP_DOT)
    {
        WCHAR *p = pAddr->Addr.IP_Dot.cAddr;

        while (*p)
        {
            if (wcschr((const WCHAR *)CC_ODOTTO_CHARS, *p) == NULL)
            {
                return CS_BAD_PARAM;
            }
            p++;
        }
    }

    if (pAddr->bMulticast == TRUE)
    {
        return CS_BAD_PARAM;
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAliasItem(PCC_ALIASITEM pSource)
{
    register unsigned int y;

    if (pSource)
    {
        if ((pSource->pData == NULL) || (pSource->wDataLength == 0))
        {
            return CS_BAD_PARAM;
        }
        if (pSource->pPrefix != NULL)
        {
            if (pSource->wPrefixLength == 0)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pSource->wPrefixLength != 0)
        {
            return CS_BAD_PARAM;
        }
        switch (pSource->wType)
        {
        case CC_ALIAS_H323_ID:
            if ((pSource->wDataLength + pSource->wPrefixLength) > CC_ALIAS_MAX_H323_ID)
            {
                return CS_BAD_PARAM;
            }
            break;

        case CC_ALIAS_H323_PHONE:
            if ((pSource->wDataLength + pSource->wPrefixLength +1) > CC_ALIAS_MAX_H323_PHONE)
            {
                return CS_BAD_PARAM;
            }
            for (y = 0; y < pSource->wDataLength; ++y)
            {
                if (wcschr((const WCHAR *)CC_ALIAS_H323_PHONE_CHARS, pSource->pData[y]) == NULL)
                {
                    return CS_BAD_PARAM;
                }
            }
            if (pSource->pPrefix != NULL)
            {
                for (y = 0; y < pSource->wPrefixLength; ++y)
                {
                    if (wcschr((const WCHAR *)CC_ALIAS_H323_PHONE_CHARS, pSource->pPrefix[y]) == NULL)
                    {
                        return CS_BAD_PARAM;
                    }
                }
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource)
{
    PCC_ALIASITEM pNewItem = NULL;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }

    pNewItem = (PCC_ALIASITEM)MemAlloc(sizeof(CC_ALIASITEM));
    if (pNewItem == NULL)
    {
        return CS_NO_MEMORY;
    }
    pNewItem->wType = pSource->wType;

  	if ((pSource->wPrefixLength != 0) && (pSource->pPrefix != NULL))
	{
        pNewItem->wPrefixLength = pSource->wPrefixLength;
        pNewItem->pPrefix = (LPWSTR)MemAlloc(pSource->wPrefixLength * sizeof(pNewItem->pPrefix[0]));
        if (pNewItem->pPrefix == NULL)
        {
            MemFree(pNewItem);
            return CS_NO_MEMORY;
        }
        memcpy(pNewItem->pPrefix, pSource->pPrefix, pSource->wPrefixLength * sizeof(WCHAR));
    }
    else
    {
        pNewItem->wPrefixLength = 0;
        pNewItem->pPrefix = NULL;
    }


    if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
    {
        pNewItem->wDataLength = pSource->wDataLength;
        pNewItem->pData = (LPWSTR)MemAlloc(pSource->wDataLength * sizeof(pNewItem->pData[0]));
        if (pNewItem->pData == NULL)
        {
            if (pNewItem->pPrefix)
            {
               MemFree(pNewItem->pPrefix);
            }
            MemFree(pNewItem);
            return CS_NO_MEMORY;
        }
        memcpy(pNewItem->pData, pSource->pData, pSource->wDataLength * sizeof(WCHAR));
    }
    else
    {
        pNewItem->wDataLength = 0;
        pNewItem->pData = NULL;
    }
    *ppTarget = pNewItem;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeAliasItem(PCC_ALIASITEM pSource)
{
    if (pSource)
    {
        if ((pSource->pPrefix) != NULL)
        {
            MemFree(pSource->pPrefix);
        }
        if ((pSource->pData) != NULL)
        {
            MemFree(pSource->pData);
        }
        MemFree(pSource);
    }
    return CS_OK;
}












//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAliasNames(PCC_ALIASNAMES pSource)
{
    CS_STATUS TempResult = CS_OK;
    WORD x;

    if (pSource)
    {
        for (x = 0; x < pSource->wCount; x++)
        {
            TempResult = Q931ValidateAliasItem(&(pSource->pItems[x]));
            if (TempResult != CS_OK)
            {
                return TempResult;
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource->wCount)
    {
        WORD x;
        *ppTarget = (PCC_ALIASNAMES)MemAlloc(sizeof(CC_ALIASNAMES));
        if (*ppTarget == NULL)
        {
            return CS_NO_MEMORY;
        }
        (*ppTarget)->pItems = (PCC_ALIASITEM)MemAlloc(pSource->wCount *
            sizeof(CC_ALIASITEM));
        if ((*ppTarget)->pItems == NULL)
        {
            MemFree(*ppTarget);
            *ppTarget = NULL;
            return CS_NO_MEMORY;
        }
        (*ppTarget)->wCount = pSource->wCount;
        {
            PCC_ALIASITEM p = (*ppTarget)->pItems;

            for (x = 0; x < pSource->wCount; x++)
            {
                p[x].wType = pSource->pItems[x].wType;

                if ((pSource->pItems[x].wPrefixLength != 0) &&
                        (pSource->pItems[x].pPrefix != NULL))
                {
                    p[x].wPrefixLength = pSource->pItems[x].wPrefixLength;
                    p[x].pPrefix = (LPWSTR)MemAlloc(pSource->pItems[x].wPrefixLength * sizeof(p[x].pPrefix[0]));
                    if (p[x].pPrefix == NULL)
                    {
                        // Free everything that has been allocated so far...
                        int y;
                        for (y = 0; y < x; y++)
                        {
                            if (p[y].pPrefix)
                            {
                                MemFree(p[y].pPrefix);
                            }
                            if (p[y].pData)
                            {
                                MemFree(p[y].pData);
                            }
                        }
                        MemFree(p);
                        MemFree(*ppTarget);
                        *ppTarget = NULL;
                        return CS_NO_MEMORY;
                    }
                    memcpy(p[x].pPrefix, pSource->pItems[x].pPrefix,
                        pSource->pItems[x].wPrefixLength * sizeof(WCHAR));
                }
                else
                {
                    p[x].wPrefixLength = 0;
                    p[x].pPrefix = NULL;
                }


                if ((pSource->pItems[x].wDataLength != 0) &&
                        (pSource->pItems[x].pData != NULL))
                {
                    p[x].wDataLength = pSource->pItems[x].wDataLength;
                    p[x].pData = (LPWSTR)MemAlloc(pSource->pItems[x].wDataLength * sizeof(p[x].pData[0]));
                    if (p[x].pData == NULL)
                    {
                        // Free everything that has been allocated so far...
                        int y;
                        if (p[x].pPrefix)
                        {
                            MemFree(p[x].pPrefix);
                        }
                        for (y = 0; y < x; y++)
                        {
                            if (p[y].pPrefix)
                            {
                                MemFree(p[y].pPrefix);
                            }
                            if (p[y].pData)
                            {
                                MemFree(p[y].pData);
                            }
                         }
                        MemFree(p);
                        MemFree(*ppTarget);
                        *ppTarget = NULL;
                        return CS_NO_MEMORY;
                    }
                    memcpy(p[x].pData, pSource->pItems[x].pData,
                        pSource->pItems[x].wDataLength * sizeof(WCHAR));
                }
                else
                {
                    p[x].wDataLength = 0;
                    p[x].pData = NULL;
                }
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeAliasNames(PCC_ALIASNAMES pSource)
{
    if (pSource && (pSource->wCount))
    {
        // Free everything that has been allocated so far...
        int x;
        for (x = 0; x < pSource->wCount; x++)
        {
            if ((pSource->pItems[x].pPrefix) != NULL)
            {
                MemFree(pSource->pItems[x].pPrefix);
            }
            if ((pSource->pItems[x].pData) != NULL)
            {
                MemFree(pSource->pItems[x].pData);
            }
        }
        if (pSource->pItems != NULL)
        {
            MemFree(pSource->pItems);
        }
        if (pSource != NULL)
        {
            MemFree(pSource);
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateDisplay(LPWSTR pszDisplay)
{
    if (pszDisplay == NULL)
    {
        return CS_OK;
    }
    if (wcslen(pszDisplay) > CC_MAX_DISPLAY_LENGTH)
    {
        return CS_BAD_PARAM;
    }
#if 0 // turn this on to validate display field against IA5 characters...
    while (*pszDisplay)
    {
        if (wcschr(CC_UNICODE_IA5_CHARS, *pszDisplay) == NULL)
        {
            return CS_BAD_PARAM;
        }
        pszDisplay++;
    }
#endif
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidatePartyNumber(LPWSTR pszPartyNumber)
{
    if (pszPartyNumber == NULL)
    {
        return CS_OK;
    }
    if (wcslen(pszPartyNumber) > CC_MAX_PARTY_NUMBER_LEN)
    {
        return CS_BAD_PARAM;
    }
#if 0 // turn this on to validate party number field against IA5 characters...
    while (*pszPartyNumber)
    {
        if (wcschr(CC_UNICODE_IA5_CHARS, *pszPartyNumber) == NULL)
        {
            return CS_BAD_PARAM;
        }
        pszPartyNumber++;
    }
#endif
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (LPWSTR)MemAlloc((wcslen(pSource) + 1) * sizeof(WCHAR));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    wcscpy(*ppDest, pSource);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeDisplay(LPWSTR pszDisplay)
{
    if (pszDisplay == NULL)
    {
        return CS_OK;
    }
    MemFree(pszDisplay);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo)
{
    if (pVendorInfo == NULL)
    {
        return CS_OK;
    }

    if (pVendorInfo->pProductNumber)
    {
        if (pVendorInfo->pProductNumber->wOctetStringLength)
        {
            if (pVendorInfo->pProductNumber->wOctetStringLength > CC_MAX_PRODUCT_LENGTH)
            {
                return CS_BAD_PARAM;
            }
            if (pVendorInfo->pProductNumber->pOctetString == NULL)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pVendorInfo->pProductNumber->pOctetString)
        {
            return CS_BAD_PARAM;
        }
    }

    if (pVendorInfo->pVersionNumber)
    {
        if (pVendorInfo->pVersionNumber->wOctetStringLength)
        {
            if (pVendorInfo->pVersionNumber->wOctetStringLength > CC_MAX_VERSION_LENGTH)
            {
                return CS_BAD_PARAM;
            }
            if (pVendorInfo->pVersionNumber->pOctetString == NULL)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pVendorInfo->pVersionNumber->pOctetString)
        {
            return CS_BAD_PARAM;
        }
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (PCC_VENDORINFO)MemAlloc(sizeof(CC_VENDORINFO));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    memset(*ppDest, 0, sizeof(CC_VENDORINFO));
    (*ppDest)->bCountryCode = pSource->bCountryCode;
    (*ppDest)->bExtension = pSource->bExtension;
    (*ppDest)->wManufacturerCode = pSource->wManufacturerCode;

    if ((pSource->pProductNumber == NULL) ||
            (pSource->pProductNumber->pOctetString == NULL) ||
            (pSource->pProductNumber->wOctetStringLength == 0))
    {
        (*ppDest)->pProductNumber = NULL;
    }
    else
    {
        (*ppDest)->pProductNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING));
        if ((*ppDest)->pProductNumber == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memset((*ppDest)->pProductNumber, 0, sizeof(CC_OCTETSTRING));
        (*ppDest)->pProductNumber->pOctetString =
            (BYTE *)MemAlloc(pSource->pProductNumber->wOctetStringLength);
        if ((*ppDest)->pProductNumber->pOctetString == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        (*ppDest)->pProductNumber->wOctetStringLength =
            pSource->pProductNumber->wOctetStringLength;
        memcpy((*ppDest)->pProductNumber->pOctetString,
            pSource->pProductNumber->pOctetString,
            pSource->pProductNumber->wOctetStringLength);
    }

    if ((pSource->pVersionNumber == NULL) ||
            (pSource->pVersionNumber->pOctetString == NULL) ||
            (pSource->pVersionNumber->wOctetStringLength == 0))
    {
        (*ppDest)->pVersionNumber = NULL;
    }
    else
    {
        (*ppDest)->pVersionNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING));
        if ((*ppDest)->pVersionNumber == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memset((*ppDest)->pVersionNumber, 0, sizeof(CC_OCTETSTRING));
        (*ppDest)->pVersionNumber->pOctetString =
            (BYTE *)MemAlloc(pSource->pVersionNumber->wOctetStringLength);
        if ((*ppDest)->pVersionNumber->pOctetString == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        (*ppDest)->pVersionNumber->wOctetStringLength =
            pSource->pVersionNumber->wOctetStringLength;
        memcpy((*ppDest)->pVersionNumber->pOctetString,
            pSource->pVersionNumber->pOctetString,
            pSource->pVersionNumber->wOctetStringLength);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo)
{
    if (pVendorInfo == NULL)
    {
        return CS_OK;
    }
    if (pVendorInfo->pProductNumber != NULL)
    {
        if (pVendorInfo->pProductNumber->pOctetString != NULL)
        {
            MemFree(pVendorInfo->pProductNumber->pOctetString);
        }
        MemFree(pVendorInfo->pProductNumber);
    }
    if (pVendorInfo->pVersionNumber != NULL)
    {
        if (pVendorInfo->pVersionNumber->pOctetString != NULL)
        {
            MemFree(pVendorInfo->pVersionNumber->pOctetString);
        }
        MemFree(pVendorInfo->pVersionNumber);
    }
    MemFree(pVendorInfo);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData)
{
    if (pNonStandardData)
    {
        if ((pNonStandardData->sData.pOctetString == NULL) ||
                (pNonStandardData->sData.wOctetStringLength == 0))
        {
            return CS_BAD_PARAM;
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (PCC_NONSTANDARDDATA)MemAlloc(sizeof(CC_NONSTANDARDDATA));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    (*ppDest)->bCountryCode = pSource->bCountryCode;
    (*ppDest)->bExtension = pSource->bExtension;
    (*ppDest)->wManufacturerCode = pSource->wManufacturerCode;
    (*ppDest)->sData.wOctetStringLength = pSource->sData.wOctetStringLength;
    if (pSource->sData.pOctetString == NULL)
    {
        (*ppDest)->sData.pOctetString = NULL;
    }
    else
    {
        (*ppDest)->sData.pOctetString = (void *)MemAlloc(pSource->sData.wOctetStringLength);
        if ((*ppDest)->sData.pOctetString == NULL)
        {
            MemFree(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memcpy((*ppDest)->sData.pOctetString, pSource->sData.pOctetString,
            pSource->sData.wOctetStringLength);
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData)
{
    if (pNonStandardData == NULL)
    {
        return CS_OK;
    }
    if (pNonStandardData->sData.pOctetString != NULL)
    {
        MemFree(pNonStandardData->sData.pOctetString);
    }
    MemFree(pNonStandardData);
    return CS_OK;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\tstable.h ===
/****************************************************************************
 *
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef __TSTABLE_H
#define __TSTABLE_H

typedef struct _LOCK_ENTRY
{
	HANDLE        hLock;
	int           iLockCount;
	BOOL          bCleanup,
								bDeleted;
	WORD          wNextFree,
								wUniqueID;

} LOCK_ENTRY, *PLOCK_ENTRY;


// definition of an invalid ID
#define TSTABLE_INVALID_ID				(DWORD) 0xFFFFFFFF

// return codes that the callback function used in conjunction with EnumerateEntries can return
const DWORD CALLBACK_CONTINUE                = 1;
const DWORD CALLBACK_ABORT                   = 2;
const DWORD CALLBACK_DELETE_ENTRY            = 3;
const DWORD CALLBACK_DELETE_ENTRY_AND_OBJECT = 4;



// used in call to Lock
#define TSTABLE_INVALID_UNIQUE_ID            (WORD) 0xFFFF
#define TSTABLE_INVALID_INDEX                (WORD) 0xFFFF

// This is a compare function that we aren't using right now.  It
// will be useful in the future if there is a reason to search
// the table

typedef INT (*ENTRY_COMPARE) (LPVOID ptr1, LPVOID ptr2);


template <class EntryData> class TSTable
{
typedef DWORD (*TABLE_CALLBACK) (EntryData* ptr, LPVOID context);

public:
	           TSTable         (WORD            _size);
	          ~TSTable         ();
	BOOL       Resize          (WORD            wNewSize);
	BOOL       CreateAndLock   (EntryData*      pEntryData,
															LPDWORD         lpdwID);
	BOOL       Validate        (DWORD_PTR       dwID);
	EntryData *Lock            (DWORD_PTR       dwID,
															DWORD           timeout = INFINITE);
	BOOL       Unlock          (DWORD_PTR       dwID);
	BOOL       Delete          (DWORD_PTR       dwID,
															BOOL            bCleanup = FALSE);
	EntryData *EnumerateEntries(TABLE_CALLBACK  callBackFunc,
															void*           context,
															BOOL            bUnlockTable = FALSE);
	
	BOOL       IsInitialized   () {return bInitialized;}
	WORD       GetSize         () {return wNumUsed;}

private:
	// data

	EntryData**       pDataTable;
	PLOCK_ENTRY       pLockTable;
	CRITICAL_SECTION  csTableLock;
	WORD              wSize,
					  wNumUsed,
					  wFirstFree,
				      wLastFree,
					  wUniqueID;
	BOOL              bInitialized;

	// private methods

	BOOL LockEntry   (WORD wIndex,
									 DWORD timeout = INFINITE);
	BOOL UnLockEntry(WORD wIndex);
	void LockTable  () { EnterCriticalSection(&csTableLock); };
	void UnLockTable() { LeaveCriticalSection(&csTableLock); };
	WORD GenerateUniqueID();
	DWORD MakeID(WORD wIndex, WORD wUniqueID)
		{
			DWORD theID = wUniqueID;
			theID = (theID << 16) & 0xFFFF0000;
			theID |= wIndex;
			return(theID);
		};
	void BreakID(DWORD_PTR theID, WORD* pwIndex, WORD* pwUID)
		{
			*pwIndex = (WORD) (theID & 0x0000FFFF);
			*pwUID   = (WORD) ((theID >> 16) & 0x0000FFFF);
		};

};

/*
 ** TSTable::TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\tstable.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::TSTable(WORD _size) :
														wSize(_size),
														wNumUsed((WORD) 0),
														wFirstFree((WORD) 0),
														wLastFree((WORD) (_size - 1)),
														wUniqueID((WORD) 0),
														bInitialized(TRUE),
														pDataTable(NULL),
														pLockTable(NULL)
{
	WORD wIndex;

	// Create the table lock

	InitializeCriticalSection(&csTableLock);

	// Lock the table

	LockTable();

	// Create the data table

	pDataTable = new EntryData*[wSize];
	
	if(pDataTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}

	// Init the pointers

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		pDataTable[wIndex] = NULL;
	}

	// Create the lock table

	pLockTable = new LOCK_ENTRY[wSize];

	if (pLockTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}

	// Initialize the lock table entries...each entry begins with
	// a NULL mutex handle, a zero lock count and it's next free is
	// the next successive entry.

	for (wIndex = 0; wIndex < wSize; wIndex++ )
	{
		pLockTable[wIndex].hLock      = NULL;
		pLockTable[wIndex].iLockCount = 0;
		pLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}

	// note: the wNextFree in the last table entry points to an invalid index, however,
	// this is OK since if the table ever fills, it is automatically resized making what
	// was an invalid index, the index into the first entry of newly added part of the
	// enlargened table.  Trust me...

	// Unlock the table

	UnLockTable();
}

/*
 ** TSTable::~TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::~TSTable()
{
	DWORD wIndex;

	// Lock the table

	LockTable();

	// Delete the data table

	if (pDataTable != NULL)
	{
		delete pDataTable;
	}

	// Delete the lock table

	if (pLockTable != NULL)
	{
		// Destroy the mutexes

		for (wIndex = 0; wIndex < wSize; wIndex++)
		{
			if (pLockTable[wIndex].hLock != NULL)
			{
				CloseHandle(pLockTable[wIndex].hLock);
			}
		}

		delete pLockTable;
	}

	// Unlock the table

	UnLockTable();

	// Destroy the table lock

	DeleteCriticalSection(&csTableLock);

	bInitialized = FALSE;
}

/*
 ** TSTable::CreateAndLock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::CreateAndLock(EntryData* pEntryData,
																			 LPDWORD    lpdwID)
{
	BOOL  bRetCode = FALSE;
	WORD wIndex;

	// If the pointer passed in is bad, then don't even try to do anything for them

	if (pEntryData == NULL || lpdwID == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// If the table is full, then resize it.

	if (wNumUsed >= wSize - 1)
	{
		goto EXIT;
	}

	// Get the first free entry

	wIndex = wFirstFree;

	// Create the mutex for the object

	if ((pLockTable[wIndex].hLock = CreateMutexA(NULL, FALSE, NULL)) == NULL)
	{
		goto EXIT;
	}

	// Lock the entry (no need checking the return code as the entire
	// table is locked) - since this is a new entry, that means that nobody
	// could have locked the entry already.

	LockEntry(wIndex, 0);

	// Copy pointer to the data table

	pDataTable[wIndex] = pEntryData;

	// Init the corresponding lock table entry

	pLockTable[wIndex].bDeleted   = FALSE;
	pLockTable[wIndex].iLockCount = 1;
	pLockTable[wIndex].wUniqueID = GenerateUniqueID();

	// Set the id for the caller

	*lpdwID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

	// Bump up the count of number used

	wNumUsed++;

	// Fix the next free index

	wFirstFree = pLockTable[wIndex].wNextFree;

	// Signal success

	bRetCode = TRUE;

EXIT:

	// Unlock the table

	UnLockTable();
	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::Lock(DWORD_PTR dwID,
																		DWORD timeout)
{
	EntryData* pEntryData = NULL;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, and the unique ID matches).

	if (pLockTable[wIndex].hLock    == NULL ||
			pLockTable[wIndex].bDeleted == TRUE ||
			pLockTable[wIndex].wUniqueID != wUID)
	{
		goto EXIT;
	}

	// If the timeout is INFINITE, then try to lock the entry using a more
	// "thread friendly" method.	 If a timeout is specified, then don't do
	// the spin lock since it could be implemented at a higher level.

	if(timeout == INFINITE)
	{
		// simulate infinity with a pseudo "spin lock"
		// This is more "thread friendly" in that it unlocks the table allowing some
		// other thread that is trying to unlock the same entry to be able to lock the
		// table.

		while(LockEntry(wIndex, 0) == FALSE)
		{
			UnLockTable();

			// give up the rest of this thread quantum, allowing others to run and potentially
			// unlock the entry

			Sleep(0);
			LockTable();

			// If the entry has been replaced, deleted or marked for deletion then
			// bag it (give up)

			if((pLockTable[wIndex].wUniqueID != wUID)  ||
				 (pLockTable[wIndex].hLock      == NULL)  ||
				 (pLockTable[wIndex].bDeleted   == TRUE))
			{
				goto EXIT;
			}
		}

		// we got the lock

		pEntryData = pDataTable[wIndex];
	}
	
	// Otherwise, do a normal lock

	else
	{	
		if (LockEntry(wIndex, timeout) == TRUE)
		{
			pEntryData = pDataTable[wIndex];
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return pEntryData;
}

/*
 ** TSTable::Unlock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Unlock(DWORD_PTR dwID)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);
	
	// Lock the table

	LockTable();

	// Verify the id is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the lock is actually valid and that the entry has not been
	// deleted

	if (pLockTable[wIndex].hLock == NULL)
	{
		goto EXIT;
	}

	// Make sure that that thread has the lock on the entry

	if ((bRetCode = LockEntry(wIndex, 0)) == TRUE)
	{
		// if this table entry is marked for delete and the lock count is less than 2
		// (since the thread could have called delete after unlocking the entry...although
		// this is a no-no) then clean up the table entry

		if (pLockTable[wIndex].bDeleted   == TRUE &&
				pLockTable[wIndex].iLockCount <= 2)
		{
			// If the caller specifed cleanup on delete, then get rid of memory

			if (pLockTable[wIndex].bCleanup == TRUE)
			{
				delete pDataTable[wIndex];
			}

			// Set the pointer to NULL

			pDataTable[wIndex] = NULL;

			// Decrement the count of used entries

			wNumUsed--;

			// Fix the entry so that it's next free index is what is currently
			// the next free pointed to by the current last free entry.
			// Then update the last free entry's next pointer, and finally,
			// update the last free index to this entry
			pLockTable[wIndex].wNextFree    = pLockTable[wLastFree].wNextFree;
			pLockTable[wLastFree].wNextFree = wIndex;
			wLastFree                       = wIndex;
		}

		// Do two unlocks on the entry ... one for the original lock and another for
		// the lock we obtained during the test

		UnLockEntry(wIndex);
		UnLockEntry(wIndex);

		// Since the entire table is locked, then we can get away with this.  If
		// the code is ever changed so that the entire table is not locked during
		// these operations, then this will cause a race condition.

		// If we got rid of the data, then close the handle to the mutex and
		// set the handle to NULL

		if (pDataTable[wIndex] == NULL)
		{
			CloseHandle(pLockTable[wIndex].hLock);
			pLockTable[wIndex].hLock = NULL;
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Delete
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Delete(DWORD_PTR dwID,
																BOOL  bCleanup)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);

	// Lock the table

	LockTable();

	// Verify that the ID is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is valid

	if (pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Try to lock the entry (ie check to see if we had the entry locked)

	if (LockEntry(wIndex, 0) == TRUE)
	{
		// mark it for deletion, set the cleanp flag and then unlock it

		pLockTable[wIndex].bDeleted = TRUE;
		pLockTable[wIndex].bCleanup = bCleanup;

		UnLockEntry(wIndex);

		// Note: this function does not call ::Unlock() on behalf of the user.
		// Thus, the entry is only marked as deleted at this point and can no
		// longer be locked by any threads (including the one that marked it for delete).
		// The thread that marked the entry as deleted must call ::Unlock() to actually
		// free up the entry.
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:  Validates that an object still exists.  Can be called
 *								regardless if caller has entry locked or not.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Validate(DWORD_PTR dwID)
{
	BOOL bRetCode = TRUE;
	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, the unique ID matches, and the data ptr is not null).

	if (pLockTable[wIndex].hLock    == NULL  ||
			pLockTable[wIndex].bDeleted == TRUE  ||
			pLockTable[wIndex].wUniqueID != wUID ||
			pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::EnumerateEntries
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::EnumerateEntries(TABLE_CALLBACK callbackFunc,
																								LPVOID         context,
																								BOOL           bUnlockTable)
{
	DWORD      dwAction;
	WORD       wIndex = wSize;
	EntryData* pEntryData = NULL;
	DWORD      dwEntryID;

	// Make sure they passed a good function

	if (callbackFunc == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// Run through the data table and pass the data to the callback function

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		// Verify that there is actually data in the entry and that the entry has not
		// been marked for deletion.

		if (pDataTable[wIndex]          == NULL ||
				pLockTable[wIndex].bDeleted == TRUE)
		{
			continue;
		}


		// Try to lock the entry...if we cannot, then we don't have the lock and
		// we will only report entries that we have locked (or are unlocked)

		if (LockEntry(wIndex, 0) == FALSE)
		{
			continue;
		}
		
		// build and remember the "full" entry ID so we can use it to unlock the entry
		dwEntryID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

		// Save the pointer to the object.

		pEntryData = pDataTable[wIndex];

		// note: only unlock the table during the callback if we are explicitly asked to (the
		// default is not to unlock the table).
		if(bUnlockTable == TRUE)
			UnLockTable();

		// Call their function
		dwAction = callbackFunc(pDataTable[wIndex], context);

		if(bUnlockTable == TRUE)
			LockTable();

		// If the action says to delete the entry, then do so...if we are also to delete
		// the object, pass in a TRUE.

		if (dwAction == CALLBACK_DELETE_ENTRY ||
				dwAction == CALLBACK_DELETE_ENTRY_AND_OBJECT)
		{
			Delete(dwEntryID, (dwAction == CALLBACK_DELETE_ENTRY ? FALSE : TRUE));
		}

		// If the action says abort, then break the loop...notice that means that
		// the entry is still locked

		else if (dwAction == CALLBACK_ABORT)
		{
			goto EXIT;
		}

		// Unlock the entry...notice we don't use UnLockEntry.  The reason is that
		// if the entry has been marked as deleted, then we need to have
		// it destroyed and UnLockEntry doesn't do that.

		Unlock(dwEntryID);
	}

EXIT:

	// Unlock the table

	UnLockTable();

	// Return NULL if we processed the entire table...if we were told to abort,
	// return a pointer to the entry we stopped on.

	return (wIndex == wSize ? NULL : pEntryData);
}

// helper functions - these assume table is locked and index is good

/*
 ** TSTable::LockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::LockEntry(WORD wIndex,
																	 DWORD timeout)
{
	BOOL  bRetCode = TRUE;
	DWORD dwRetCode;


	// Try to lock the entry.  If it succeeds, we'll bump up the lock count.  If
	// the wait ended because another thread abandoned the mutex, then set the count
	// to one.

	dwRetCode = WaitForSingleObject(pLockTable[wIndex].hLock, timeout);
	
	if (dwRetCode == WAIT_OBJECT_0)
	{
		pLockTable[wIndex].iLockCount++;
	}
	else if (dwRetCode == WAIT_ABANDONED)
	{
		pLockTable[wIndex].iLockCount = 1;
	}
	else
	{
		bRetCode = FALSE;
	}

	return bRetCode;
}

/*
 ** TSTable::UnLockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::UnLockEntry(WORD wIndex)
{
	BOOL bRetCode;

	// Release the mutex...if that succeeds, reduce the count

	if((bRetCode = ReleaseMutex(pLockTable[wIndex].hLock)) == TRUE)
	{
		pLockTable[wIndex].iLockCount--;
	}

	return bRetCode;
}


/*
 ** TSTable::GenerateUniqueID
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION: table should be locked before calling this function.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
WORD TSTable<EntryData>::GenerateUniqueID()
{
	// table must be locked
	if(++wUniqueID == TSTABLE_INVALID_UNIQUE_ID)
		wUniqueID++;
	return(wUniqueID);
}






#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech261\avi.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: avi.h,v $
 * Revision 1.1.2.4  1996/01/15  16:26:22  Hans_Graves
 * 	Added Wave stuff
 * 	[1996/01/15  15:43:39  Hans_Graves]
 *
 * Revision 1.1.2.3  1996/01/08  16:41:23  Hans_Graves
 * 	Renamed AVI header structures.
 * 	[1996/01/08  15:45:16  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/12/07  19:31:26  Hans_Graves
 * 	Creation under SLIB
 * 	[1995/12/07  18:29:05  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _AVI_H_
#define _AVI_H_

/************** AVI parsing definitions **************/
typedef unsigned short twocc_t;
typedef unsigned int fourcc_t;

#ifndef FOURCC
#define FOURCC( ch0, ch1, ch2, ch3 ) \
          ( (fourcc_t)(char)(ch3) | ( (fourcc_t)(char)(ch2) << 8 ) | \
          ( (fourcc_t)(char)(ch1) << 16 ) | ( (fourcc_t)(char)(ch0) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */

#ifndef TWOCC
#define TWOCC(ch0, ch1) ((twocc_t)(char)(ch1)|((twocc_t)(char)(ch0)<<8))
#endif

/* form types, list types, and chunk types */
#define AVI_AVI                 FOURCC('A', 'V', 'I', ' ')
#define AVI_AVIHEADERTYPE       FOURCC('h', 'd', 'r', 'l')
#define AVI_MAINHDR             FOURCC('a', 'v', 'i', 'h')
#define AVI_STREAMHEADERTYPE    FOURCC('s', 't', 'r', 'l')
#define AVI_STREAMHEADER        FOURCC('s', 't', 'r', 'h')
#define AVI_STREAMFORMAT        FOURCC('s', 't', 'r', 'f')
#define AVI_STREAMHANDLERDATA   FOURCC('s', 't', 'r', 'd')

#define AVI_MOVIETYPE           FOURCC('m', 'o', 'v', 'i')
#define AVI_RECORDTYPE          FOURCC('r', 'e', 'c', ' ')

#define AVI_NEWINDEX            FOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define AVI_VIDEOSTREAM         FOURCC('v', 'i', 'd', 's')
#define AVI_AUDIOSTREAM         FOURCC('a', 'u', 'd', 's')

/* Basic chunk types */
#define AVI_DIBbits           TWOCC('d', 'b')
#define AVI_DIBcompressed     TWOCC('d', 'c')
#define AVI_PALchange         TWOCC('p', 'c')
#define AVI_WAVEbytes         TWOCC('w', 'b')
#define AVI_Indeo             TWOCC('i', 'v')

/* Chunk id to use for extra chunks for padding. */
#define AVI_PADDING             FOURCC('J', 'U', 'N', 'K')

typedef struct
{
  dword dwMicroSecPerFrame;     /* frame display rate */
  dword dwMaxBytesPerSec;       /* max. transfer rate */
  dword dwPaddingGranularity;   /* pad to multiples of this */
                                /* size; normally 2K. */
  dword dwFlags;                /* the ever-present flags */
  dword dwTotalFrames;          /* # frames in file */
  dword dwInitialFrames;
  dword dwStreams;
  dword dwSuggestedBufferSize;

  dword dwWidth;
  dword dwHeight;

  dword dwReserved[4];
} AVI_MainHeader;

typedef struct {
    short left,top,right,bottom;
} DUMMYRECT;

typedef struct {
  fourcc_t  fccType;
  fourcc_t  fccHandler;
  dword     dwFlags;        /* Contains AVITF_* flags */
  dword     dwPriority;
  dword     dwInitialFrames;
  dword     dwScale;
  dword     dwRate; /* dwRate / dwScale == samples/second */
  dword     dwStart;
  dword     dwLength; /* In units above... */
  dword     dwSuggestedBufferSize;
  dword     dwQuality;
  dword     dwSampleSize;
  DUMMYRECT rcFrame;
} AVI_StreamHeader;

typedef struct
{
  dword ckid;
  dword dwFlags;
  dword dwChunkOffset;          /* Position of chunk */
  dword dwChunkLength;          /* Length of chunk */
} AVI_INDEXENTRY;

#define RIFF_WAVE               FOURCC('W', 'A', 'V', 'E')
#define RIFF_FORMAT             FOURCC('f', 'm', 't', ' ')
#define RIFF_DATA               FOURCC('d', 'a', 't', 'a')

typedef struct
{
  word  wFormatTag;
  word  nChannels;
  dword nSamplesPerSec;
  dword nAvgBytesPerSec;
  word  nBlockAlign;
  word  wBitsPerSample;
} WAVE_format;

#endif _AVI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech261\ac3.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: ac3.h,v $
 * Revision 1.1.2.3  1996/11/11  18:21:00  Hans_Graves
 * 	Added AC3_SYNC_WORD_REV define.
 * 	[1996/11/11  17:56:01  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/11/08  21:50:39  Hans_Graves
 * 	Swapped bytes in SYNC_WORD
 * 	[1996/11/08  21:16:07  Hans_Graves]
 * 
 * 	First time under SLIB.
 * 	[1996/11/08  16:23:53  Hans_Graves]
 * 
 * $EndLog$
 */
/*	File: usr_equ.h		$Revision: 1.1.2.3 $	*/

/****************************************************************************
;	Unpublished work.  Copyright 1993-1996 Dolby Laboratories, Inc.
;	All Rights Reserved.
;
;	File:	usr_equ.h
;		Common equates for AC-3 system
;
;	History:
;		8/2/93		Created
;***************************************************************************/

#ifndef _AC3_H_
#define _AC3_H_

/**** General system equates ****/

#define NBLOCKS      6   /* # of time blocks per frame */
#define NCHANS       6   /* max # of discrete channels */
#define N            256 /* # of samples per time block */
#define AC3_FRAME_SIZE (NBLOCKS*N) /* 6 * 256 = 1536 */

/**** Miscellaneous equates ****/

#define NOUTWORDS         (3840 / 2)  /* max # words per frame */
#define NINFOWDS          10          /* # words needed by frame info */

/* Note:  Because of mismatches between the way AC-3 word stream parsing works
**		and the way that it's done for MPEG, you need to be careful using these
**		definitions
*/

#define AC3_SYNC_WORD     0x0B77      /* Byte reversed AC-3 sync word */
#define AC3_SYNC_WORD_REV 0x770B      /* packed data stream sync word */
#define AC3_SYNC_WORD_LEN 16          /* sync word length */
#define PCMCHANSZ         256         /* decoder overlap-add channel size */
#define PCM16BIT          1           /* 16-bit PCM code for Dolby SIP */

#ifdef KCAPABLE
#define NKCAPABLEMODES  4 /* # defined karaoke capable modes */
#define NKCAPABLEVARS   6 /* # karaoke pan/mix parameters */
#endif

#endif /* _AC3_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech261\audio.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_audio.c,v $
 * Revision 1.1.6.14  1996/12/13  18:19:06  Hans_Graves
 * 	Added initialization of AudioPTimeBase.
 * 	[1996/12/13  18:07:26  Hans_Graves]
 *
 * Revision 1.1.6.13  1996/12/04  22:34:30  Hans_Graves
 * 	Make AC3 detection in audio streams more accurate.
 * 	[1996/12/04  22:19:21  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/11/18  23:07:34  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:36  Hans_Graves]
 *
 * R