 - The irp for this operation.

Return Value:

    TRUE if this operation should be pended, or FALSE otherwise.

--*/
{
    BOOLEAN returnValue = FALSE;
    ULONG operation
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
LatAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
        NOTE:  The only reason this parameter is passed in is to conserve         
        stack space.  In most cases, the caller to this function has already
        allocated a buffer to temporarily store the device name and there
        is no reason this function and the functions it calls can't share
        the same buffer.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT latencyDeviceObject;
    PDEVICE_OBJECT attachedToDevObj;
    PLATENCY_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  See if this is a file system we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if this is Microsoft's file system recognizer device (see if the name of the
    //  driver is the FS_REC driver).  If so skip it.  We don't need to 
    //  attach to file system recognizer devices since we can just wait for the
    //  real file system driver to load.  Therefore, if we can identify them, we won't
    //  attach to them.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
    LatGetObjectName( DeviceObject->DriverObject, Name );
    
    if (RtlCompareUnicodeString( Name, &fsrecName, TRUE ) == 0) {

        return STATUS_SUCCESS;
    }

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( Globals.DriverObject,
                             sizeof( LATENCY_DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &latencyDeviceObject );

    if (!NT_SUCCESS( status )) {

        LAT_DBG_PRINT0( DEBUG_ERROR,
                        "LATENCY (LatAttachToFileSystem): Could not create a Latency Filter device object to attach to the filesystem.\n" );
        return status;
    }

    //
    //  Do the attachment
    //

    attachedToDevObj = IoAttachDeviceToDeviceStack( latencyDeviceObject, DeviceObject );

    if (attachedToDevObj == NULL) {

        LAT_DBG_PRINT0( DEBUG_ERROR,
                        "LATENCY (LatAttachToFileSystem): Could not attach Latency Filter to the filesystem control device object.\n" );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializing our device extension
    //

    devExt = latencyDeviceObject->DeviceExtension;
    devExt->AttachedToDeviceObject = attachedToDevObj;

    //
    //  Propagate flags from Device Object we attached to
    //

    if ( FlagOn( attachedToDevObj->Flags, DO_BUFFERED_IO )) {

        SetFlag( latencyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( attachedToDevObj->Flags, DO_DIRECT_IO )) {

        SetFlag( latencyDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Since this is an attachment to a file system control device object
    //  we are not going to log anything, but properly initialize our
    //  extension.
    //

    LatResetDeviceExtension( devExt );
    devExt->Enabled= FALSE;
    devExt->IsVolumeDeviceObject = FALSE;

    RtlInitEmptyUnicodeString( &(devExt->DeviceNames),
                               devExt->DeviceNamesBuffer,
                               sizeof( devExt->DeviceNamesBuffer ) );
                               
    RtlInitEmptyUnicodeString( &(devExt->UserNames),
                               devExt->UserNamesBuffer,
                               sizeof( devExt->UserNamesBuffer ) );
                               
    ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    if (FlagOn( Globals.DebugLevel, DEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        LatCacheDeviceName( latencyDeviceObject );
        DbgPrint( "LATENCY (LatAttachToFileSystem): Attaching to file system   \"%.*S\" (%s)\n",
                  devExt->DeviceNames.Length / sizeof( WCHAR ),
                  devExt->DeviceNames.Buffer,
                  GET_DEVICE_TYPE_NAME(latencyDeviceObject->DeviceType) );
    }

    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = LatEnumerateFileSystemVolumes( DeviceObject, Name );

    if (!NT_SUCCESS( status )) {

        LAT_DBG_PRINT3( DEBUG_ERROR,
                        "LATENCY (LatAttachToFileSystem): Error attaching to existing volumes for \"%.*S\", status=%08x\n",
                        devExt->DeviceNames.Length / sizeof( WCHAR ),
                        devExt->DeviceNames.Buffer,
                        status );

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( latencyDeviceObject );

    ErrorCleanupDevice:
        IoDeleteDevice( latencyDeviceObject );

    return status;
}

VOID
LatDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PLATENCY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  We have to iterate through the device objects in the filter stack
    //  attached to DeviceObject.  If we are attached to this filesystem device
    //  object, We should be at the top of the stack, but there is no guarantee.
    //  If we are in the stack and not at the top, we can safely call IoDetachDevice
    //  at this time because the IO Manager will only really detach our device
    //  object from the stack at a safe time.
    //

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            LAT_DBG_PRINT3( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                            "LATENCY (LatDetachFromFileSystem): Detaching from file system \"%.*S\" (%s)\n",
                            devExt->DeviceNames.Length / sizeof( WCHAR ),
                            devExt->DeviceNames.Buffer,
                            GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType) );
                                
            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

NTSTATUS
LatEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT latencyDeviceObject;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList( FSDeviceObject->DriverObject,
                                          NULL,
                                          0,
                                          &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         LATENCY_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !LatIsAttachedToDevice( devList[i], NULL )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                LatGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the disk device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    status = IoGetDiskDeviceObject( devList[i], &diskDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoCreateDevice( Globals.DriverObject,
                                                 sizeof( LATENCY_DEVICE_EXTENSION ),
                                                 (PUNICODE_STRING) NULL,
                                                 devList[i]->DeviceType,
                                                 0,
                                                 FALSE,
                                                 &latencyDeviceObject );

                        if (NT_SUCCESS( status )) {

                            //
                            //  Attach to this device object
                            //

                            status = LatAttachToMountedDevice( devList[i], 
                                                               latencyDeviceObject,
                                                               diskDeviceObject );

                            //
                            //  This should succeed.
                            //

                            ASSERT( NT_SUCCESS( status ) );

                            //
                            //  Finished all initialization of the new device
                            //  object,  so clear the initializing flag now.
                            //

                            ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );
                            
                        } else {

                            LAT_DBG_PRINT0( DEBUG_ERROR,
                                            "LATENCY (LatEnumberateFileSystemVolumes): Cannot attach Latency device object to volume.\n" );
                        }
                        
                        //
                        //  Remove reference added by IoGetDiskDeviceObject.
                        //  We only need to hold this reference until we are
                        //  successfully attached to the current volume.  Once
                        //  we are successfully attached to devList[i], the
                        //  IO Manager will make sure that the underlying
                        //  diskDeviceObject will not go away until the file
                        //  system stack is torn down.
                        //

                        ObDereferenceObject( diskDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}

BOOLEAN
LatIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

    Note:  If AttachedDeviceObject is returned with a non-NULL value,
      there is a reference on the AttachedDeviceObject that must
      be cleared by the caller.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which Latency
        has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) {

            if (NULL != AttachedDeviceObject) {

                *AttachedDeviceObject = currentDevObj;
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}

NTSTATUS
LatAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT LatencyDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject
    )
/*++

Routine Description:

    This routine will attach the LatencyDeviceObject to the filter stack
    that DeviceObject is in.

    NOTE:  If there is an error in attaching, the caller is responsible
        for deleting the LatencyDeviceObject.
    
Arguments:

    DeviceObject - A device object in the stack to which we want to attach.

    LatencyDeviceObject - The latency device object that has been created
        to attach to this filter stack.

	DiskDeviceObject - The device object for the disk device of this
		stack.
        
Return Value:

    Returns STATUS_SUCCESS if the latency deviceObject could be attached,
    otherwise an appropriate error code is returned.
    
--*/
{
    PLATENCY_DEVICE_EXTENSION devext;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( IS_MY_DEVICE_OBJECT( LatencyDeviceObject ) );
    ASSERT( !LatIsAttachedToDevice ( DeviceObject, NULL ) );
    
    devext = LatencyDeviceObject->DeviceExtension;

    devext->AttachedToDeviceObject = IoAttachDeviceToDeviceStack( LatencyDeviceObject,
                                                                  DeviceObject );

    if (devext->AttachedToDeviceObject == NULL ) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        //  Do all common initializing of the device extension
        //

        //
        //  We just want to attach to the device, but not actually
        //  start adding latency.
        //
        
        devext->Enabled = FALSE;

        RtlInitEmptyUnicodeString( &(devext->DeviceNames), 
                                   devext->DeviceNamesBuffer, 
                                   sizeof( devext->DeviceNamesBuffer ) );
        RtlInitEmptyUnicodeString( &(devext->UserNames),
                                   devext->UserNamesBuffer,
                                   sizeof( devext->UserNamesBuffer ) );

        //
        //  Store off the DiskDeviceObject.  We shouldn't need it
        //  later since we have already successfully attached to the
        //  filter stack, but it may be helpful for debugging.
        //  
        
        devext->DiskDeviceObject = DiskDeviceObject;                         

        //
        //  Try to get the device name so that we can store it in the
        //  device extension.
        //

        LatCacheDeviceName( LatencyDeviceObject );

        LAT_DBG_PRINT2( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                        "LATENCY (LatAttachToMountedDevice): Attaching to volume     \"%.*S\"\n",
                        devext->DeviceNames.Length / sizeof( WCHAR ),
                        devext->DeviceNames.Buffer );

        //
        //  Set our deviceObject flags based on the 
        //  flags send in the next driver's device object.
        //
        
        if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

            SetFlag( LatencyDeviceObject->Flags, DO_BUFFERED_IO );
        }

        if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

            SetFlag( LatencyDeviceObject->Flags, DO_DIRECT_IO );
        }

        //
        //  Add this device to our attachment list
        //

        devext->IsVolumeDeviceObject = TRUE;

        ExAcquireFastMutex( &Globals.DeviceExtensionListLock );
        InsertTailList( &Globals.DeviceExtensionList, devext->NextLatencyDeviceLink );
        ExReleaseFastMutex( &Globals.DeviceExtensionListLock );
    }

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
LatGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

VOID
LatGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    DeviceObject = IoGetDeviceAttachmentBaseRef( DeviceObject );

    //
    //  Get the name of that object
    //

    LatGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}

VOID
LatCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
    ) 
/*++

Routine Description:

    This routines tries to set a name into the device extension of the given
    device object. 
    
    It will try and get the name from:
        - The device object
        - The disk device object if there is one

Arguments:

    DeviceObject - The object we want a name for

Return Value:

    None

--*/
{
    PLATENCY_DEVICE_EXTENSION devExt;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    devExt = DeviceObject->DeviceExtension;

    //
    //  Get the name of the given device object.
    //

    LatGetBaseDeviceObjectName( DeviceObject, &(devExt->DeviceNames) );

    //
    //  If we didn't get a name and there is a REAL device object, lookup
    //  that name.
    //

    if ((devExt->DeviceNames.Length <= 0) && (NULL != devExt->DiskDeviceObject)) {

        LatGetObjectName( devExt->DiskDeviceObject, &(devExt->DeviceNames) );
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Helper routine for turning on/off logging on demand      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
LatGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine
    
Arguments:

    DeviceName - Name of device for which we want the deviceObject.
    DeviceObject - Set to the DeviceObject for this device name if
        we can successfully retrieve it.

    Note:  If the DeviceObject is returned, it is returned with a
        reference that must be cleared by the caller once the caller
        is finished with it.

Return Value:

    STATUS_SUCCESS if the deviceObject was retrieved from the
    name, and an error code otherwise.
    
--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;
    PFILE_OBJECT volumeFileObject;
    HANDLE fileHandle;
    PDEVICE_OBJECT nextDeviceObject;

    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, L"\\DosDevices\\" );
    RtlAppendUnicodeStringToString( &volumeNameUnicodeString, DeviceName );

    InitializeObjectAttributes( &objectAttributes,
								&volumeNameUnicodeString,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if(!NT_SUCCESS( status )) {

        return status;
    }

	//
    // get a pointer to the volumes file object
	//

    status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( status )) {

        ZwClose( fileHandle );
        return status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    nextDeviceObject = IoGetRelatedDeviceObject( volumeFileObject );
    
    if (nextDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        return status;
    }

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    ASSERT( NULL != DeviceObject );

    ObReferenceObject( nextDeviceObject );
    
    *DeviceObject = nextDeviceObject;

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Start/stop logging routines                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
LatEnable (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR UserDeviceName
    )
/*++

Routine Description:

    This routine ensures that we are attached to the specified device
    then turns on logging for that device.
    
    Note:  Since all network drives through LAN Manager are represented by _
        one_ device object, we want to only attach to this device stack once
        and use only one device extension to represent all these drives.
        Since Latency does not do anything to filter I/O on the LAN Manager's
        device object to only log the I/O to the requested drive, the user
        will see all I/O to a network drive it he/she is attached to a
        network drive.

Arguments:

    DeviceObject - Device object for LATENCY driver

    UserDeviceName - Name of device for which logging should be started
    
Return Value:

    STATUS_SUCCESS if the logging has been successfully started, or
    an appropriate error code if the logging could not be started.
    
--*/
{
    UNICODE_STRING userDeviceName;
    NTSTATUS status;
    PLATENCY_DEVICE_EXTENSION devext;
    PDEVICE_OBJECT nextDeviceObject;
    PDEVICE_OBJECT latencyDeviceObject;
    PDEVICE_OBJECT diskDeviceObject;

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Check to see if we have previously attached to this device by
    //  opening this device name then looking through its list of attached
    //  devices.
    //

    RtlInitUnicodeString( &userDeviceName, UserDeviceName );

    status = LatGetDeviceObjectFromName( &userDeviceName, &nextDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }

    if (LatIsAttachedToDevice( nextDeviceObject, &latencyDeviceObject )) {

        //
        //  We are already attached, so just make sure that logging is turned on
        //  for this device.
        //

        ASSERT( NULL != latencyDeviceObject );

        devext = latencyDeviceObject->DeviceExtension;
        devext->Enabled = TRUE;

/* ISSUE-2000-09-21-mollybro 

    TODO: Straighten out this name issue.
*/

//        LatStoreUserName( devext, &userDeviceName );

        //
        //  Clear the reference that was returned from LatIsAttachedToDevice.
        //
        
        ObDereferenceObject( latencyDeviceObject );
        
    } else {

        //
        //  We are not already attached, so create a latency device object and
        //  attach it to this device object.
        //

        //
        //  Create a new device object so we can attach it in the filter stack
        //
        
        status = IoCreateDevice( Globals.DriverObject,
								 sizeof( LATENCY_DEVICE_EXTENSION ),
								 NULL,
								 nextDeviceObject->DeviceType,
								 0,
								 FALSE,
								 &latencyDeviceObject );

        if (!NT_SUCCESS( status )) {

            ObDereferenceObject( nextDeviceObject );
            return status;
        }

        //
        //  Get the disk device object associated with this
        //  file  system device object.  Only try to attach if we
        //  have a disk device object.  If the device does not
        //  have a disk device object, it is a control device object
        //  for a driver and we don't want to attach to those
        //  device objects.
        //

        status = IoGetDiskDeviceObject( nextDeviceObject, &diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            LAT_DBG_PRINT2( DEBUG_ERROR,
                            "LATENCY (LatEnable): No disk device object exist for \"%.*S\"; cannot log this volume.\n",
                            userDeviceName.Length / sizeof( WCHAR ),
                            userDeviceName.Buffer );
            IoDeleteDevice( latencyDeviceObject );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }
        
        //
        //  Call the routine to attach to a mounted device.
        //

        status = LatAttachToMountedDevice( nextDeviceObject,
                                           latencyDeviceObject,
                                           diskDeviceObject );

        //
        //  Clear the reference on diskDeviceObject that was
        //  added by IoGetDiskDeviceObject.
        //

        ObDereferenceObject( diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            LAT_DBG_PRINT2( DEBUG_ERROR,
                            "LATENCY (LatEnable): Could not attach to \"%.*S\"; logging not started.\n",
                            userDeviceName.Length / sizeof( WCHAR ),
                            userDeviceName.Buffer );
            IoDeleteDevice( latencyDeviceObject );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }

        //
        //  We successfully attached so do any more device extension 
        //  initialization we need.  Along this code path, we want to
        //  turn on logging and store our device name.
        // 

        devext = latencyDeviceObject->DeviceExtension;
        LatResetDeviceExtension( devext );
        devext->Enabled = TRUE;

        //
        //  We want to store the name that was used by the user-mode
        //  application to name this device.
        //

/* ISSUE-2000-09-21-mollybro 

    TODO: Fix user name thing.
*/

//        LatStoreUserName( devext, &userDeviceName );

        //
        //  We are done initializing this device object, so
        //  clear the DO_DEVICE_OBJECT_INITIALIZING flag.
        //

        ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );
    }

    ObDereferenceObject( nextDeviceObject );
    return STATUS_SUCCESS;
}

NTSTATUS
LatDisable (
    IN PWSTR DeviceName
    )
/*++

Routine Description:

    This routine stop logging the specified device.  Since you can not
    physically detach from devices, this routine simply sets a flag saying
    to not log the device anymore.

    Note:  Since all network drives are represented by _one_ device object,
        and, therefore, one device extension, if the user detaches from one
        network drive, it has the affect of detaching from _all_ network
        devices.

Arguments:

    DeviceName - The name of the device to stop logging.

Return Value:
    NT Status code

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT latencyDeviceObject;
    PLATENCY_DEVICE_EXTENSION devext;
    NTSTATUS status;
    
    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, DeviceName );

    status = LatGetDeviceObjectFromName( &volumeNameUnicodeString, &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  We could not get the deviceObject from this DeviceName, so
        //  return the error code.
        //
        
        return status;
    }

    //
    //  Find Latency's device object from the device stack to which
    //  deviceObject is attached.
    //

    if (LatIsAttachedToDevice( deviceObject, &latencyDeviceObject )) {

        //
        //  Latency is attached and Latency's deviceObject was returned.
        //

        ASSERT( NULL != latencyDeviceObject );

        devext = latencyDeviceObject->DeviceExtension;

        devext->Enabled = FALSE;

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }    

    ObDereferenceObject( deviceObject );
    ObDereferenceObject( latencyDeviceObject );

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Initialization routines for device extension         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
LatResetDeviceExtension (
    PLATENCY_DEVICE_EXTENSION DeviceExtension
)
{
    ULONG i;

    ASSERT( NULL != DeviceExtension );
    
    DeviceExtension->Enabled = FALSE;
    
    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
    
        DeviceExtension->Operations[i].PendOperation = FALSE;
        DeviceExtension->Operations[i].MillisecondDelay = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\sfilter\sfilter.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    sfilter.c

Abstract:

    This module contains the code that implements the general purpose sample
    file system filter driver.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.

// @@BEGIN_DDKSPLIT
Author:

    Darryl E. Havens (darrylh) 26-Jan-1995

// @@END_DDKSPLIT
Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

    Neal Christiansen (nealch) 28-Jun-2000
        Added support so the filter can be loaded at anytime and properly
        enumerate and attach to all existing volumes.  Also did some
        simplifications of operations because of changes in past versions
        of NT that were not propagated into SFILTER

    Neal Christiansen (nealch) 20-Nov-2000
        Added a DriverUnload routine so that the driver can be unloaded.

    Neal Christiansen (nealch) 04-Jan-2001
        Moved the code to display the filename out of SrCreate into a
        separate routine.  This is so the filename buffer will not be
        on the create stack as it calls down through the code.

    Neal Christiansen (nealch) 27-Mar-2002
        We have done several updates to the code.  The latest change is
        that we no longer support the opening of the control device
        object.

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.
// @@END_DDKSPLIT
--*/

#include "ntifs.h"
#include "ntdddisk.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

/////////////////////////////////////////////////////////////////////////////
//
//                   Macro and Structure Definitions
//
/////////////////////////////////////////////////////////////////////////////

//
//  VERSION NOTE:
//
//  The following useful macros are defined in NTIFS.H in Windows XP and later.
//  We will define them locally if we are building for the Windows 2000 
//  environment.
//

#if WINVER == 0x0500

//
//  These macros are used to test, set and clear flags respectively
//

#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif


#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))


#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

//
//  We want ASSERT defined as an expression, which was fixed after Windows 2000
//

#ifdef ASSERT
#undef ASSERT
#if DBG
#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)
#else
#define ASSERT( exp ) ((void) 0)
#endif
#endif        

#define ExFreePoolWithTag( a, b ) ExFreePool( (a) )

#endif /* WINVER == 0x0500 */

#ifndef Add2Ptr
#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))
#endif

//
//  Buffer size for local names on the stack
//

#define MAX_DEVNAME_LENGTH 64

//
//  Device extension definition for our driver.  Note that the same extension
//  is used for the following types of device objects:
//      - File system device object we attach to
//      - Mounted volume device objects we attach to
//

typedef struct _SFILTER_DEVICE_EXTENSION {

    //
    //  Pointer to the file system device object we are attached to
    //

    PDEVICE_OBJECT AttachedToDeviceObject;

    //
    //  Pointer to the real (disk) device object that is associated with
    //  the file system device object we are attached to
    //

    PDEVICE_OBJECT StorageStackDeviceObject;

    //
    //  Name for this device.  If attached to a Volume Device Object it is the
    //  name of the physical disk drive.  If attached to a Control Device
    //  Object it is the name of the Control Device Object.
    //

    UNICODE_STRING DeviceName;

    //
    //  Buffer used to hold the above unicode strings
    //

    WCHAR DeviceNameBuffer[MAX_DEVNAME_LENGTH];

} SFILTER_DEVICE_EXTENSION, *PSFILTER_DEVICE_EXTENSION;

//
//  This structure contains the information we need to pass to the completion
//  processing for FSCTRLs.
//

typedef struct _FSCTRL_COMPLETION_CONTEXT {

    //
    //  The workitem that will be initialized with our context and 
    //  worker routine if this completion processing needs to be completed
    //  in a worker thread.
    //
    
    WORK_QUEUE_ITEM WorkItem;

    //
    //  The device object to which this device is currently directed.
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    //  The IRP for this FSCTRL operation.
    //
    
    PIRP Irp;

    //
    //  For mount operations, the new device object that we have allocated
    //  and partially initialized that we will attach to the mounted volume
    //  if the mount is successful.
    //
    
    PDEVICE_OBJECT NewDeviceObject;
    
} FSCTRL_COMPLETION_CONTEXT, *PFSCTRL_COMPLETION_CONTEXT;
        

//
//  Macro to test if this is my device object
//

#define IS_MY_DEVICE_OBJECT(_devObj) \
    (((_devObj) != NULL) && \
     ((_devObj)->DriverObject == gSFilterDriverObject) && \
      ((_devObj)->DeviceExtension != NULL))

//
//  Macro to test if this is my control device object
//

#define IS_MY_CONTROL_DEVICE_OBJECT(_devObj) \
    (((_devObj) == gSFilterControlDeviceObject) ? \
            (ASSERT(((_devObj)->DriverObject == gSFilterDriverObject) && \
                    ((_devObj)->DeviceExtension == NULL)), TRUE) : \
            FALSE)

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
//  Macro to test if FAST_IO_DISPATCH handling routine is valid
//

#define VALID_FAST_IO_DISPATCH_HANDLER(_FastIoDispatchPtr, _FieldName) \
    (((_FastIoDispatchPtr) != NULL) && \
     (((_FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
            (FIELD_OFFSET(FAST_IO_DISPATCH, _FieldName) + sizeof(void *))) && \
     ((_FastIoDispatchPtr)->_FieldName != NULL))


#if WINVER >= 0x0501
//
//  MULTIVERSION NOTE:
//
//  If built in the Windows XP environment or later, we will dynamically import
//  the function pointers for routines that were not supported on Windows 2000
//  so that we can build a driver that will run, with modified logic, on 
//  Windows 2000 or later.
//
//  Below are the prototypes for the function pointers that we need to 
//  dynamically import because not all OS versions support these routines.
//

typedef
NTSTATUS
(*PSF_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS) (
    IN PDRIVER_OBJECT DriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    );

typedef
NTSTATUS
(*PSF_ENUMERATE_DEVICE_OBJECT_LIST) (
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT *DeviceObjectList,
    IN  ULONG DeviceObjectListSize,
    OUT PULONG ActualNumberDeviceObjects
    );

typedef
NTSTATUS
(*PSF_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE) (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

typedef    
PDEVICE_OBJECT
(*PSF_GET_LOWER_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  DeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSF_GET_DEVICE_ATTACHMENT_BASE_REF) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSF_GET_DISK_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSF_GET_ATTACHED_DEVICE_REFERENCE) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSF_GET_VERSION) (
    IN OUT PRTL_OSVERSIONINFOW VersionInformation
    );

typedef struct _SF_DYNAMIC_FUNCTION_POINTERS {

    //
    //  The following routines should all be available on Windows XP (5.1) and
    //  later.
    //

    PSF_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS RegisterFileSystemFilterCallbacks;
    PSF_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE AttachDeviceToDeviceStackSafe;
    PSF_ENUMERATE_DEVICE_OBJECT_LIST EnumerateDeviceObjectList;
    PSF_GET_LOWER_DEVICE_OBJECT GetLowerDeviceObject;
    PSF_GET_DEVICE_ATTACHMENT_BASE_REF GetDeviceAttachmentBaseRef;
    PSF_GET_DISK_DEVICE_OBJECT GetDiskDeviceObject;
    PSF_GET_ATTACHED_DEVICE_REFERENCE GetAttachedDeviceReference;
    PSF_GET_VERSION GetVersion;

} SF_DYNAMIC_FUNCTION_POINTERS, *PSF_DYNAMIC_FUNCTION_POINTERS;

SF_DYNAMIC_FUNCTION_POINTERS gSfDynamicFunctions = {0};

//
//  MULTIVERSION NOTE: For this version of the driver, we need to know the
//  current OS version while we are running to make decisions regarding what
//  logic to use when the logic cannot be the same for all platforms.  We
//  will look up the OS version in DriverEntry and store the values
//  in these global variables.
//

ULONG gSfOsMajorVersion = 0;
ULONG gSfOsMinorVersion = 0;

//
//  Here is what the major and minor versions should be for the various OS versions:
//
//  OS Name                                 MajorVersion    MinorVersion
//  ---------------------------------------------------------------------
//  Windows 2000                             5                 0
//  Windows XP                               5                 1
//  Windows .NET                             5                 2
//

#define IS_WINDOWS2000() \
    ((gSfOsMajorVersion == 5) && (gSfOsMinorVersion == 0))

#define IS_WINDOWSXP() \
    ((gSfOsMajorVersion == 5) && (gSfOsMinorVersion == 1))

#define IS_WINDOWSXP_OR_LATER() \
    (((gSfOsMajorVersion == 5) && (gSfOsMinorVersion >= 1)) || \
     (gSfOsMajorVersion > 5))

#define IS_WINDOWSDOTNET_OR_LATER() \
    (((gSfOsMajorVersion == 5) && (gSfOsMinorVersion >= 2)) || \
     (gSfOsMajorVersion > 5))

#endif


//
//  TAG identifying memory SFilter allocates
//

#define SFLT_POOL_TAG   'tlFS'

//
//  This structure and these routines are used to retrieve the name of a file
//  object.  To prevent allocating memory every time we get a name this
//  structure contains a small buffer (which should handle 90+% of all names).
//  If we do overflow this buffer we will allocate a buffer big enough
//  for the name.
//

typedef struct _GET_NAME_CONTROL {

    PCHAR allocatedBuffer;
    CHAR smallBuffer[256];
    
} GET_NAME_CONTROL, *PGET_NAME_CONTROL;


PUNICODE_STRING
SfGetFileName(
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS CreateStatus,
    IN OUT PGET_NAME_CONTROL NameControl
    );


VOID
SfGetFileNameCleanup(
    IN OUT PGET_NAME_CONTROL NameControl
    );


//
//  Macros for SFilter DbgPrint levels.
//

#define SF_LOG_PRINT( _dbgLevel, _string )                  \
    (FlagOn(SfDebug,(_dbgLevel)) ?                          \
        DbgPrint _string  :                                 \
        ((void)0))

//
//  Delay values for KeDelayExecutionThread()
//  (Values are negative to represent relative time)
//

#define DELAY_ONE_MICROSECOND   (-10)
#define DELAY_ONE_MILLISECOND   (DELAY_ONE_MICROSECOND*1000)
#define DELAY_ONE_SECOND        (DELAY_ONE_MILLISECOND*1000)


/////////////////////////////////////////////////////////////////////////////
//
//                      Global variables
//
/////////////////////////////////////////////////////////////////////////////

//
//  Holds pointer to the driver object for this driver
//

PDRIVER_OBJECT gSFilterDriverObject = NULL;

//
//  Holds pointer to the device object that represents this driver and is used
//  by external programs to access this driver.  This is also known as the
//  "control device object".
//

PDEVICE_OBJECT gSFilterControlDeviceObject = NULL;

//
//  This lock is used to synchronize our attaching to a given device object.
//  This lock fixes a race condition where we could accidently attach to the
//  same device object more then once.  This race condition only occurs if
//  a volume is being mounted at the same time as this filter is being loaded.
//  This problem will never occur if this filter is loaded at boot time before
//  any file systems are loaded.
//
//  This lock is used to atomically test if we are already attached to a given
//  device object and if not, do the attach.
//

FAST_MUTEX gSfilterAttachLock;

/////////////////////////////////////////////////////////////////////////////
//
//                      Debug Definitions
//
/////////////////////////////////////////////////////////////////////////////

//
//  DEBUG display flags
//

#define SFDEBUG_DISPLAY_ATTACHMENT_NAMES    0x00000001  //display names of device objects we attach to
#define SFDEBUG_DISPLAY_CREATE_NAMES        0x00000002  //get and display names during create
#define SFDEBUG_GET_CREATE_NAMES            0x00000004  //get name (don't display) during create
#define SFDEBUG_DO_CREATE_COMPLETION        0x00000008  //do create completion routine, don't get names
#define SFDEBUG_ATTACH_TO_FSRECOGNIZER      0x00000010  //do attach to FSRecognizer device objects
#define SFDEBUG_ATTACH_TO_SHADOW_COPIES     0x00000020  //do attach to ShadowCopy Volume device objects -- they are only around on Windows XP and later

ULONG SfDebug = 0;


//
//  Given a device type, return a valid name
//

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (sizeof(DeviceTypeNames) / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Known device type names
//

static const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};


/////////////////////////////////////////////////////////////////////////////
//
//                          Function Prototypes
//
/////////////////////////////////////////////////////////////////////////////

//
//  Define driver entry routine.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#if DBG && WINVER >= 0x0501
VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );
#endif

//
//  Define the local routines used by this driver module.  This includes a
//  a sample of how to filter a create file operation, and then invoke an I/O
//  completion routine when the file has successfully been created/opened.
//

#if WINVER >= 0x0501
VOID
SfLoadDynamicFunctions (
    );

VOID
SfGetCurrentVersion (
    );
#endif

NTSTATUS
SfPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfCreateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SfCleanupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SfFsControlMountVolumeCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    );

NTSTATUS
SfFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    );

NTSTATUS
SfFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SfFsControlLoadFileSystemCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    );

NTSTATUS
SfFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfFsControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
SfFastIoCheckIfPossible(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoQueryBasicInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoQueryStandardInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoLock(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoUnlockSingle(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoUnlockAll(
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoUnlockAllByKey(
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SfFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

BOOLEAN
SfFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


BOOLEAN
SfFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoQueryOpen(
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */
NTSTATUS
SfPreFsFilterPassThrough (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

VOID
SfPostFsFilterPassThrough (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );
#endif

VOID
SfFsNotification(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    );

NTSTATUS
SfAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

NTSTATUS
SfAttachToFileSystemDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DeviceName
    );

VOID
SfDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SfAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT SFilterDeviceObject
    );

VOID
SfCleanupMountedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501
NTSTATUS
SfEnumerateFileSystemVolumes(
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING FSName
    );
#endif

VOID
SfGetObjectName(
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );

VOID
SfGetBaseDeviceObjectName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING DeviceName
    );

BOOLEAN
SfIsAttachedToDevice(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    );

BOOLEAN
SfIsAttachedToDeviceW2K(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    );

BOOLEAN
SfIsAttachedToDeviceWXPAndLater(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    );

VOID
SfReadDriverParameters(
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SfIsShadowCopyVolume (
    IN PDEVICE_OBJECT StorageStackDeviceObject,
    OUT PBOOLEAN IsShadowCopy
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Assign text sections for each routine.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#if DBG && WINVER >= 0x0501
#pragma alloc_text(PAGE, DriverUnload)
#endif

#pragma alloc_text(PAGE, SfFsNotification)
#pragma alloc_text(PAGE, SfCreate)
#pragma alloc_text(PAGE, SfCleanupClose)
#pragma alloc_text(PAGE, SfFsControl)
#pragma alloc_text(PAGE, SfFsControlMountVolume)
#pragma alloc_text(PAGE, SfFsControlMountVolumeComplete)
#pragma alloc_text(PAGE, SfFsControlLoadFileSystem)
#pragma alloc_text(PAGE, SfFsControlLoadFileSystemComplete)
#pragma alloc_text(PAGE, SfFastIoCheckIfPossible)
#pragma alloc_text(PAGE, SfFastIoRead)
#pragma alloc_text(PAGE, SfFastIoWrite)
#pragma alloc_text(PAGE, SfFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, SfFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, SfFastIoLock)
#pragma alloc_text(PAGE, SfFastIoUnlockSingle)
#pragma alloc_text(PAGE, SfFastIoUnlockAll)
#pragma alloc_text(PAGE, SfFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, SfFastIoDeviceControl)
#pragma alloc_text(PAGE, SfFastIoDetachDevice)
#pragma alloc_text(PAGE, SfFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, SfFastIoMdlRead)
#pragma alloc_text(PAGE, SfFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, SfFastIoMdlWriteComplete)
#pragma alloc_text(PAGE, SfFastIoReadCompressed)
#pragma alloc_text(PAGE, SfFastIoWriteCompressed)
#pragma alloc_text(PAGE, SfFastIoQueryOpen)
#pragma alloc_text(PAGE, SfAttachDeviceToDeviceStack)
#pragma alloc_text(PAGE, SfAttachToFileSystemDevice)
#pragma alloc_text(PAGE, SfDetachFromFileSystemDevice)
#pragma alloc_text(PAGE, SfAttachToMountedDevice)
#pragma alloc_text(PAGE, SfIsAttachedToDevice)
#pragma alloc_text(PAGE, SfIsAttachedToDeviceW2K)
#pragma alloc_text(INIT, SfReadDriverParameters)
#pragma alloc_text(PAGE, SfIsShadowCopyVolume)

#if WINVER >= 0x0501
#pragma alloc_text(INIT, SfLoadDynamicFunctions)
#pragma alloc_text(INIT, SfGetCurrentVersion)
#pragma alloc_text(PAGE, SfEnumerateFileSystemVolumes)
#pragma alloc_text(PAGE, SfIsAttachedToDeviceWXPAndLater)
#endif

#endif


/////////////////////////////////////////////////////////////////////////////
//
//                      Functions
//
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SFILTER file system filter
    driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PFAST_IO_DISPATCH fastIoDispatch;
    UNICODE_STRING nameString;
    NTSTATUS status;
    ULONG i;

#if WINVER >= 0x0501
    //
    //  Try to load the dynamic functions that may be available for our use.
    //

    SfLoadDynamicFunctions();

    //
    //  Now get the current OS version that we will use to determine what logic
    //  paths to take when this driver is built to run on various OS version.
    //

    SfGetCurrentVersion();
#endif

    //
    //  Get Registry values
    //

    SfReadDriverParameters( RegistryPath );

    //
    //  Save our Driver Object, set our UNLOAD routine
    //

    gSFilterDriverObject = DriverObject;

#if DBG && WINVER >= 0x0501

    //
    //  MULTIVERSION NOTE:
    //
    //  We can only support unload for testing environments if we can enumerate
    //  the outstanding device objects that our driver has.
    //
    
    //
    //  Unload is useful for development purposes. It is not recommended for
    //  production versions
    //

    if (NULL != gSfDynamicFunctions.EnumerateDeviceObjectList) {
        
        gSFilterDriverObject->DriverUnload = DriverUnload;
    }
#endif

    //
    //  Setup other global variables
    //

    ExInitializeFastMutex( &gSfilterAttachLock );

    //
    //  Create the Control Device Object (CDO).  This object represents this 
    //  driver.  Note that it does not have a device extension.
    //

    RtlInitUnicodeString( &nameString, L"\\FileSystem\\Filters\\SFilter" );

    status = IoCreateDevice( DriverObject,
                             0,                      //has no device extension
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &gSFilterControlDeviceObject );

    if (status == STATUS_OBJECT_PATH_NOT_FOUND) {

        //
        //  This must be a version of the OS that doesn't have the Filters
        //  path in its namespace.  This was added in Windows XP.
        //
        //  We will try just putting our control device object in the \FileSystem
        //  portion of the object name space.
        //

        RtlInitUnicodeString( &nameString, L"\\FileSystem\\SFilterCDO" );

        status = IoCreateDevice( DriverObject,
                                 0,                      //has no device extension
                                 &nameString,
                                 FILE_DEVICE_DISK_FILE_SYSTEM,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &gSFilterControlDeviceObject );

        if (!NT_SUCCESS( status )) {
           
            KdPrint(( "SFilter!DriverEntry: Error creating control device object \"%wZ\", status=%08x\n", &nameString, status ));
            return status;
        }
        
    } else if (!NT_SUCCESS( status )) {

        KdPrint(( "SFilter!DriverEntry: Error creating control device object \"%wZ\", status=%08x\n", &nameString, status ));
        return status;
    }

    //
    //  Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = SfPassThrough;
    }

    //
    //  We will use SfCreate for all the create operations
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SfCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE] = SfCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] = SfCreate;
    
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SfFsControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SfCleanupClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SfCleanupClose;

    //
    //  Allocate fast I/O data structure and fill it in.
    //
    //  NOTE:  The following FastIo Routines are not supported:
    //      AcquireFileForNtCreateSection
    //      ReleaseFileForNtCreateSection
    //      AcquireForModWrite
    //      ReleaseForModWrite
    //      AcquireForCcFlush
    //      ReleaseForCcFlush
    //
    //  For historical reasons these FastIO's have never been sent to filters
    //  by the NT I/O system.  Instead, they are sent directly to the base 
    //  file system.  On Windows XP and later OS releases, you can use the new 
    //  system routine "FsRtlRegisterFileSystemFilterCallbacks" if you need to 
    //  intercept these callbacks (see below).
    //

    fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, sizeof( FAST_IO_DISPATCH ), SFLT_POOL_TAG );
    if (!fastIoDispatch) {

        IoDeleteDevice( gSFilterControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );

    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = SfFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = SfFastIoRead;
    fastIoDispatch->FastIoWrite = SfFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = SfFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = SfFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = SfFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = SfFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = SfFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = SfFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = SfFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = SfFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = SfFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = SfFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = SfFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = SfFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = SfFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = SfFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = SfFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = SfFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = SfFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = SfFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

//
//  VERSION NOTE:
//
//  There are 6 FastIO routines for which file system filters are bypassed as
//  the requests are passed directly to the base file system.  These 6 routines
//  are AcquireFileForNtCreateSection, ReleaseFileForNtCreateSection,
//  AcquireForModWrite, ReleaseForModWrite, AcquireForCcFlush, and 
//  ReleaseForCcFlush.
//
//  In Windows XP and later, the FsFilter callbacks were introduced to allow
//  filters to safely hook these operations.  See the IFS Kit documentation for
//  more details on how these new interfaces work.
//
//  MULTIVERSION NOTE:
//  
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test
//  for the presence of FsFilter callbacks registration API.  If we have it,
//  then we will register for those callbacks, otherwise, we will not.
//

#if WINVER >= 0x0501

    {
        FS_FILTER_CALLBACKS fsFilterCallbacks;

        if (NULL != gSfDynamicFunctions.RegisterFileSystemFilterCallbacks) {

            //
            //  Setup the callbacks for the operations we receive through
            //  the FsFilter interface.
            //
            //  NOTE:  You only need to register for those routines you really need
            //         to handle.  SFilter is registering for all routines simply to
            //         give an example of how it is done.
            //

            fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
            fsFilterCallbacks.PreAcquireForSectionSynchronization = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostAcquireForSectionSynchronization = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreReleaseForSectionSynchronization = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostReleaseForSectionSynchronization = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreAcquireForCcFlush = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostAcquireForCcFlush = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreReleaseForCcFlush = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostReleaseForCcFlush = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreAcquireForModifiedPageWriter = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostAcquireForModifiedPageWriter = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreReleaseForModifiedPageWriter = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostReleaseForModifiedPageWriter = SfPostFsFilterPassThrough;

            status = (gSfDynamicFunctions.RegisterFileSystemFilterCallbacks)( DriverObject, 
                                                                             &fsFilterCallbacks );

            if (!NT_SUCCESS( status )) {
                
                DriverObject->FastIoDispatch = NULL;
                ExFreePool( fastIoDispatch );
                IoDeleteDevice( gSFilterControlDeviceObject );
                return status;
            }
        }
    }
#endif

    //
    //  The registered callback routine "SfFsNotification" will be called
    //  whenever a new file systems is loaded or when any file system is
    //  unloaded.
    //
    //  VERSION NOTE:
    //
    //  On Windows XP and later this will also enumerate all existing file
    //  systems (except the RAW file systems).  On Windows 2000 this does not
    //  enumerate the file systems that were loaded before this filter was
    //  loaded.
    //

    status = IoRegisterFsRegistrationChange( DriverObject, SfFsNotification );
    if (!NT_SUCCESS( status )) {

        KdPrint(( "SFilter!DriverEntry: Error registering FS change notification, status=%08x\n", status ));

        DriverObject->FastIoDispatch = NULL;
        ExFreePool( fastIoDispatch );
        IoDeleteDevice( gSFilterControlDeviceObject );
        return status;
    }

    //
    //  Attempt to attach to the appropriate RAW file system device objects
    //  since they are not enumerated by IoRegisterFsRegistrationChange.
    //

    {
        PDEVICE_OBJECT rawDeviceObject;
        PFILE_OBJECT fileObject;

        //
        //  Attach to RawDisk device
        //

        RtlInitUnicodeString( &nameString, L"\\Device\\RawDisk" );

        status = IoGetDeviceObjectPointer(
                    &nameString,
                    FILE_READ_ATTRIBUTES,
                    &fileObject,
                    &rawDeviceObject );

        if (NT_SUCCESS( status )) {

            SfFsNotification( rawDeviceObject, TRUE );
            ObDereferenceObject( fileObject );
        }

        //
        //  Attach to the RawCdRom device
        //

        RtlInitUnicodeString( &nameString, L"\\Device\\RawCdRom" );

        status = IoGetDeviceObjectPointer(
                    &nameString,
                    FILE_READ_ATTRIBUTES,
                    &fileObject,
                    &rawDeviceObject );

        if (NT_SUCCESS( status )) {

            SfFsNotification( rawDeviceObject, TRUE );
            ObDereferenceObject( fileObject );
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( gSFilterControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}

#if DBG && WINVER >= 0x0501
VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can NOT be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gSFilterDriverObject);

    //
    //  Log we are unloading
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!DriverUnload:                        Unloading driver (%p)\n",
                   DriverObject) );

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, SfFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.  Note that this routine should always be
        //  defined since this routine is only compiled for Windows XP and
        //  later.
        //

        ASSERT( NULL != gSfDynamicFunctions.EnumerateDeviceObjectList );
        status = (gSfDynamicFunctions.EnumerateDeviceObjectList)(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a reference count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reasonable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed.  This can easily
        //           occur under stress situations and if a long lived IRP is
        //           pending (like oplocks and directory change notifications).
        //           The system will fault when this Irp actually completes.
        //           This is a sample of how to do this during testing.  This
        //           is not recommended for production code.
        //

        interval.QuadPart = (5 * DELAY_ONE_SECOND);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that references it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                SfCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gSFilterControlDeviceObject);
                gSFilterControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove reference counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the reference count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;
    ExFreePool( fastIoDispatch );
}
#endif

#if WINVER >= 0x0501
VOID
SfLoadDynamicFunctions (
    )
/*++

Routine Description:

    This routine tries to load the function pointers for the routines that
    are not supported on all versions of the OS.  These function pointers are
    then stored in the global structure SpyDynamicFunctions.

    This support allows for one driver to be built that will run on all 
    versions of the OS Windows 2000 and greater.  Note that on Windows 2000, 
    the functionality may be limited.
    
Arguments:

    None.
    
Return Value:

    None.

--*/
{
    UNICODE_STRING functionName;

    RtlZeroMemory( &gSfDynamicFunctions, sizeof( gSfDynamicFunctions ) );

    //
    //  For each routine that we would want to use, lookup its address in the
    //  kernel or hal.  If it is not present, that field in our global
    //  SpyDynamicFunctions structure will be set to NULL.
    //

    RtlInitUnicodeString( &functionName, L"FsRtlRegisterFileSystemFilterCallbacks" );
    gSfDynamicFunctions.RegisterFileSystemFilterCallbacks = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoAttachDeviceToDeviceStackSafe" );
    gSfDynamicFunctions.AttachDeviceToDeviceStackSafe = MmGetSystemRoutineAddress( &functionName );
    
    RtlInitUnicodeString( &functionName, L"IoEnumerateDeviceObjectList" );
    gSfDynamicFunctions.EnumerateDeviceObjectList = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetLowerDeviceObject" );
    gSfDynamicFunctions.GetLowerDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDeviceAttachmentBaseRef" );
    gSfDynamicFunctions.GetDeviceAttachmentBaseRef = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDiskDeviceObject" );
    gSfDynamicFunctions.GetDiskDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetAttachedDeviceReference" );
    gSfDynamicFunctions.GetAttachedDeviceReference = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"RtlGetVersion" );
    gSfDynamicFunctions.GetVersion = MmGetSystemRoutineAddress( &functionName );
    
}

VOID
SfGetCurrentVersion (
    )
/*++

Routine Description:

    This routine reads the current OS version using the correct routine based
    on what routine is available.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    if (NULL != gSfDynamicFunctions.GetVersion) {

        RTL_OSVERSIONINFOW versionInfo;
        NTSTATUS status;

        //
        //  VERSION NOTE: RtlGetVersion does a bit more than we need, but
        //  we are using it if it is available to show how to use it.  It
        //  is available on Windows XP and later.  RtlGetVersion and
        //  RtlVerifyVersionInfo (both documented in the IFS Kit docs) allow
        //  you to make correct choices when you need to change logic based
        //  on the current OS executing your code.
        //

        versionInfo.dwOSVersionInfoSize = sizeof( RTL_OSVERSIONINFOW );

        status = (gSfDynamicFunctions.GetVersion)( &versionInfo );

        ASSERT( NT_SUCCESS( status ) );

        gSfOsMajorVersion = versionInfo.dwMajorVersion;
        gSfOsMinorVersion = versionInfo.dwMinorVersion;
        
    } else {

        PsGetVersion( &gSfOsMajorVersion,
                      &gSfOsMinorVersion,
                      NULL,
                      NULL );
    }
}
#endif

VOID
SfFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )

/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.  Specifically we are looking
    for MOUNT requests so we can attach to newly mounted volumes.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/

{
    UNICODE_STRING name;
    WCHAR nameBuffer[MAX_DEVNAME_LENGTH];

    PAGED_CODE();

    //
    //  Init local name buffer
    //

    RtlInitEmptyUnicodeString( &name, nameBuffer, sizeof(nameBuffer) );

    SfGetObjectName( DeviceObject, &name );

    //
    //  Display the names of all the file system we are notified of
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFsNotification:                    %s   %p \"%wZ\" (%s)\n",
                   (FsActive) ? "Activating file system  " : "Deactivating file system",
                   DeviceObject,
                   &name,
                   GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType)) );

    //
    //  Handle attaching/detaching from the given file system.
    //

    if (FsActive) {

        SfAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        SfDetachFromFileSystemDevice( DeviceObject );
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//                  IRP Handling Routines
//
/////////////////////////////////////////////////////////////////////////////


NTSTATUS
SfPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to file system filter implementers:  
        This routine actually "passes" through the request by taking this
        driver out of the IRP stack.  If the driver would like to pass the
        I/O request through, but then also see the result, then rather than
        taking itself out of the loop it could keep itself in by copying the
        caller's parameters to the next stack location and then set its own
        completion routine.  

        Hence, instead of calling:
    
            IoSkipCurrentIrpStackLocation( Irp );

        You could instead call:

            IoCopyCurrentIrpStackLocationToNext( Irp );
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


        This example actually NULLs out the caller's I/O completion routine, but
        this driver could set its own completion routine so that it would be
        notified when the request was completed (see SfCreate for an example of
        this).

--*/

{
    //
    //  Sfilter doesn't allow handles to its control device object to be created,
    //  therefore, no other operation should be able to come through.
    //
    
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    
    //
    //  Call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}


VOID
SfDisplayCreateFileName (
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is called from SfCreate and will display the name of the
    file being created.  This is in a subroutine so that the local name buffer
    on the stack (in nameControl) is not on the stack when we call down to
    the file system for normal operations.

Arguments:

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PUNICODE_STRING name;
    GET_NAME_CONTROL nameControl;

    //
    //  Get current IRP stack
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get the name of this file object
    //

    name = SfGetFileName( irpSp->FileObject, 
                          Irp->IoStatus.Status, 
                          &nameControl );

    //
    //  Display the name
    //

    if (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) {

        SF_LOG_PRINT( SFDEBUG_DISPLAY_CREATE_NAMES,
                      ("SFilter!SfDisplayCreateFileName: Opened %08x:%08x %wZ (FID)\n", 
                       Irp->IoStatus.Status,
                       Irp->IoStatus.Information,
                       name) );

    } else {

        SF_LOG_PRINT( SFDEBUG_DISPLAY_CREATE_NAMES,
                      ("SFilter!SfDisplayCreateFileName: Opened %08x:%08x %wZ\n", 
                       Irp->IoStatus.Status,
                       Irp->IoStatus.Information,
                       name) );
    }

    //
    //  Cleanup from getting the name
    //

    SfGetFileNameCleanup( &nameControl );
}


NTSTATUS
SfCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    //  If this is for our control device object, don't allow it to be opened.
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        //
        //  Sfilter doesn't allow for any communication through its control
        //  device object, therefore it fails all requests to open a handle
        //  to its control device object.
        //
        //  See the FileSpy sample for an example of how to allow creates to 
        //  the filter's control device object and manage communication via
        //  that handle.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If debugging is enabled, do the processing required to see the packet
    //  upon its completion.  Otherwise, let the request go with no further
    //  processing.
    //

    if (!FlagOn( SfDebug, SFDEBUG_DO_CREATE_COMPLETION |
                          SFDEBUG_GET_CREATE_NAMES|
                          SFDEBUG_DISPLAY_CREATE_NAMES )) {

        //
        //  Don't put us on the stack then call the next driver
        //

        IoSkipCurrentIrpStackLocation( Irp );

        return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );

    } else {
    
        KEVENT waitEvent;

        //
        //  Initialize an event to wait for the completion routine to occur
        //

        KeInitializeEvent( &waitEvent, NotificationEvent, FALSE );

        //
        //  Copy the stack and set our Completion routine
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine(
            Irp,
            SfCreateCompletion,
            &waitEvent,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Call the next driver in the stack.
        //

        status = IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

	    if (STATUS_PENDING == status) {

            NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		    ASSERT(STATUS_SUCCESS == localStatus);
	    }

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&waitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        //
        //  Retrieve and display the filename if requested
        //

        if (FlagOn(SfDebug,
                   (SFDEBUG_GET_CREATE_NAMES|SFDEBUG_DISPLAY_CREATE_NAMES))) {

            SfDisplayCreateFileName( Irp );
        }

        //
        //  Save the status and continue processing the IRP
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;
    }
}


NTSTATUS
SfCreateCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the create/open completion routine for this filter
    file system driver.  If debugging is enabled, then this function prints
    the name of the file that was successfully opened/created by the file
    system as a result of the specified I/O request.

Arguments:

    DeviceObject - Pointer to the device on which the file was created.

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - This driver's context parameter - unused;

Return Value:

    The function value is STATUS_SUCCESS.

--*/

{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SfCleanupClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever a cleanup or a close request is to be
    processed.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    See notes for SfPassThrough for this routine.


--*/

{
    PAGED_CODE();

    //
    //  Sfilter doesn't allow handles to its control device object to be created,
    //  therefore, no other operation should be able to come through.
    //
    
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    //
    //  Now call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}


NTSTATUS
SfFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Sfilter doesn't allow handles to its control device object to be created,
    //  therefore, no other operation should be able to come through.
    //
    
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Process the minor function code.
    //

    switch (irpSp->MinorFunction) {

        case IRP_MN_MOUNT_VOLUME:

            return SfFsControlMountVolume( DeviceObject, Irp );

        case IRP_MN_LOAD_FILE_SYSTEM:

            return SfFsControlLoadFileSystem( DeviceObject, Irp );

        case IRP_MN_USER_FS_REQUEST:
        {
            switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

                case FSCTL_DISMOUNT_VOLUME:
                {
                    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

                    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                  ("SFilter!SfFsControl:                         Dismounting volume         %p \"%wZ\"\n",
                                   devExt->AttachedToDeviceObject,
                                   &devExt->DeviceName) );
                    break;
                }
            }
            break;
        }
    }        

    //
    //  Pass all other file system control requests through.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}


NTSTATUS
SfFsControlCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of an FsControl request.  It
    signals an event used to re-sync back to the dispatch routine.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the event to signal

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));
    ASSERT(Context != NULL);

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        //
        //  On Windows XP or later, the context passed in will be an event
        //  to signal.
        //

        KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, FALSE);

    } else {
#endif
        //
        //  For Windows 2000, if we are not at passive level, we should 
        //  queue this work to a worker thread using the workitem that is in 
        //  Context.
        //

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            //  We are not at passive level, but we need to be to do our work,
            //  so queue off to the worker thread.
            //
            
            ExQueueWorkItem( (PWORK_QUEUE_ITEM) Context,
                             DelayedWorkQueue );
            
        } else {

            PWORK_QUEUE_ITEM workItem = Context;

            //
            //  We are already at passive level, so we will just call our 
            //  worker routine directly.
            //

            (workItem->WorkerRoutine)(workItem->Parameter);
        }

#if WINVER >= 0x0501
    }
#endif

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SfFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This processes a MOUNT VOLUME request.

    NOTE:  The device object in the MountVolume parameters points
           to the top of the storage stack and should not be used.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The status of the operation.

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT storageStackDeviceObject;
    PSFILTER_DEVICE_EXTENSION newDevExt;
    NTSTATUS status;
    BOOLEAN isShadowCopyVolume;
    PFSCTRL_COMPLETION_CONTEXT completionContext;
    

    PAGED_CODE();

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));
    ASSERT(IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType));

    //
    //  Get the real device object (also known as the storage stack device
    //  object or the disk device object) pointed to by the vpb parameter
    //  because this vpb may be changed by the underlying file system.
    //  Both FAT and CDFS may change the VPB address if the volume being
    //  mounted is one they recognize from a previous mount.
    //

    storageStackDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

    //
    //  Determine if this is a shadow copy volume.  If so don't attach to it.
    //  NOTE:  There is no reason sfilter shouldn't attach to these volumes,
    //         this is simply a sample of how to not attach if you don't want
    //         to
    //

    status = SfIsShadowCopyVolume ( storageStackDeviceObject, 
                                    &isShadowCopyVolume );

    if (NT_SUCCESS(status) && 
        isShadowCopyVolume &&
        !FlagOn(SfDebug,SFDEBUG_ATTACH_TO_SHADOW_COPIES)) {

        UNICODE_STRING shadowDeviceName;
        WCHAR shadowNameBuffer[MAX_DEVNAME_LENGTH];

        //
        //  Get the name for the debug display
        //

        RtlInitEmptyUnicodeString( &shadowDeviceName, 
                                   shadowNameBuffer, 
                                   sizeof(shadowNameBuffer) );

        SfGetObjectName( storageStackDeviceObject, 
                         &shadowDeviceName );

        SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                      ("SFilter!SfFsControlMountVolume               Not attaching to Volume    %p \"%wZ\", shadow copy volume\n", 
                       storageStackDeviceObject,
                       &shadowDeviceName) );

        //
        //  Go to the next driver
        //

        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
    }

    //
    //  This is a mount request.  Create a device object that can be
    //  attached to the file system's volume device object if this request
    //  is successful.  We allocate this memory now since we can not return
    //  an error in the completion routine.  
    //
    //  Since the device object we are going to attach to has not yet been
    //  created (it is created by the base file system) we are going to use
    //  the type of the file system control device object.  We are assuming
    //  that the file system control device object will have the same type
    //  as the volume device objects associated with it.
    //

    status = IoCreateDevice( gSFilterDriverObject,
                             sizeof( SFILTER_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  If we can not attach to the volume, then don't allow the volume
        //  to be mounted.
        //

        KdPrint(( "SFilter!SfFsControlMountVolume: Error creating volume device object, status=%08x\n", status ));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;
    }

    //
    //  We need to save the RealDevice object pointed to by the vpb
    //  parameter because this vpb may be changed by the underlying
    //  file system.  Both FAT and CDFS may change the VPB address if
    //  the volume being mounted is one they recognize from a previous
    //  mount.
    //

    newDevExt = newDeviceObject->DeviceExtension;
    newDevExt->StorageStackDeviceObject = storageStackDeviceObject;

    //
    //  Get the name of this device
    //

    RtlInitEmptyUnicodeString( &newDevExt->DeviceName, 
                               newDevExt->DeviceNameBuffer, 
                               sizeof(newDevExt->DeviceNameBuffer) );

    SfGetObjectName( storageStackDeviceObject, 
                     &newDevExt->DeviceName );

    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-mount processing.  We need to do this work at
    //  passive level, so we will queue that work to a worker thread from
    //  the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        KEVENT waitEvent;

        KeInitializeEvent( &waitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoCopyCurrentIrpStackLocationToNext ( Irp );

        IoSetCompletionRoutine( Irp,
                                SfFsControlCompletion,
                                &waitEvent,     //context parameter
                                TRUE,
                                TRUE,
                                TRUE );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the operation to complete
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &waitEvent,
    		                                Executive,
    		                                KernelMode,
    		                                FALSE,
    		                                NULL );
    	    ASSERT( STATUS_SUCCESS == status );
    	}

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&waitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SfFsControlMountVolumeComplete( DeviceObject,
                                                 Irp,
                                                 newDeviceObject );

    } else {
#endif    
        //
        //  Initialize our completion routine
        //
        
        completionContext = ExAllocatePoolWithTag( NonPagedPool, 
                                                   sizeof( FSCTRL_COMPLETION_CONTEXT ),
                                                   SFLT_POOL_TAG );

        if (completionContext == NULL) {

            //
            //  If we cannot allocate our completion context, we will just pass 
            //  through the operation.  If your filter must be present for data
            //  access to this volume, you should consider failing the operation
            //  if memory cannot be allocated here.
            //

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        } else {

            ExInitializeWorkItem( &completionContext->WorkItem, 
                                  SfFsControlMountVolumeCompleteWorker, 
                                  completionContext );

            completionContext->DeviceObject = DeviceObject;
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = newDeviceObject;

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine( Irp,
                                    SfFsControlCompletion,
                                    &completionContext->WorkItem, //context parameter
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501        
    }
#endif

    return status;
}

VOID
SfFsControlMountVolumeCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-MountVolume work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    ASSERT( Context != NULL );

    SfFsControlMountVolumeComplete( Context->DeviceObject,
                                    Context->Irp,
                                    Context->NewDeviceObject );

    ExFreePoolWithTag( Context, SFLT_POOL_TAG );
}

NTSTATUS
SfFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    )
/*++

Routine Description:

    This does the post-Mount work and must be done at PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the mount operation.

--*/
{
    PVPB vpb;
    PSFILTER_DEVICE_EXTENSION newDevExt;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT attachedDeviceObject;
    NTSTATUS status;

    PAGED_CODE();

    newDevExt = NewDeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    //
    //  Get the correct VPB from the real device object saved in our
    //  device extension.  We do this because the VPB in the IRP stack
    //  may not be the correct VPB when we get here.  The underlying
    //  file system may change VPBs if it detects a volume it has
    //  mounted previously.
    //

    vpb = newDevExt->StorageStackDeviceObject->Vpb;

    //
    //  Display a message when we detect that the VPB for the given
    //  device object has changed.
    //

    if (vpb != irpSp->Parameters.MountVolume.Vpb) {

        SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                      ("SFilter!SfFsControlMountVolume:              VPB in IRP stack changed   %p IRPVPB=%p VPB=%p\n",
                       vpb->DeviceObject,
                       irpSp->Parameters.MountVolume.Vpb,
                       vpb) );
    }

    //
    //  See if the mount was successful.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Acquire lock so we can atomically test if we area already attached
        //  and if not, then attach.  This prevents a double attach race
        //  condition.
        //

        ExAcquireFastMutex( &gSfilterAttachLock );

        //
        //  The mount succeeded.  If we are not already attached, attach to the
        //  device object.  Note: one reason we could already be attached is
        //  if the underlying file system revived a previous mount.
        //

        if (!SfIsAttachedToDevice( vpb->DeviceObject, &attachedDeviceObject )) {

            //
            //  Attach to the new mounted volume.  The file system device
            //  object that was just mounted is pointed to by the VPB.
            //

            status = SfAttachToMountedDevice( vpb->DeviceObject,
                                              NewDeviceObject );

            if (!NT_SUCCESS( status )) { 

                //
                //  The attachment failed, cleanup.  Since we are in the
                //  post-mount phase, we can not fail this operation.
                //  We simply won't be attached.  The only reason this should
                //  ever happen at this point is if somebody already started
                //  dismounting the volume therefore not attaching should
                //  not be a problem.
                //

                SfCleanupMountedDevice( NewDeviceObject );
                IoDeleteDevice( NewDeviceObject );
            }

            ASSERT( NULL == attachedDeviceObject );

        } else {

            //
            //  We were already attached, handle it
            //

            SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                          ("SFilter!SfFsControlMountVolume               Mount volume failure for   %p \"%wZ\", already attached\n", 
                           ((PSFILTER_DEVICE_EXTENSION)attachedDeviceObject->DeviceExtension)->AttachedToDeviceObject,
                           &newDevExt->DeviceName) );

            //
            //  Cleanup and delete the device object we created
            //

            SfCleanupMountedDevice( NewDeviceObject );
            IoDeleteDevice( NewDeviceObject );

            //
            //  Dereference the returned attached device object
            //

            ObDereferenceObject( attachedDeviceObject );
        }

        //
        //  Release the lock
        //

        ExReleaseFastMutex( &gSfilterAttachLock );

    } else {

        //
        //  The mount request failed, handle it.
        //

        SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                      ("SFilter!SfFsControlMountVolume:              Mount volume failure for   %p \"%wZ\", status=%08x\n", 
                       DeviceObject,
                       &newDevExt->DeviceName, 
                       Irp->IoStatus.Status) );

        //
        //  Cleanup and delete the device object we created
        //

        SfCleanupMountedDevice( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );
    }

    //
    //  Complete the request.  
    //  NOTE:  We must save the status before completing because after
    //         completing the IRP we can not longer access it (it might be
    //         freed).
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
SfFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PFSCTRL_COMPLETION_CONTEXT completionContext;
        

    PAGED_CODE();

    //
    //  This is a "load file system" request being sent to a file system
    //  recognizer device object.  This IRP_MN code is only sent to 
    //  file system recognizers.
    //
    //  NOTE:  Since we no longer are attaching to the standard Microsoft file
    //         system recognizers we will normally never execute this code.
    //         However, there might be 3rd party file systems which have their
    //         own recognizer which may still trigger this IRP.
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFscontrolLoadFileSystem:           Loading File System, Detaching from \"%wZ\"\n", 
                   &devExt->DeviceName) );


    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-load filesystem processing.  We need to do 
    //  this work at passive level, so we will queue that work to a worker 
    //  thread from the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        KEVENT waitEvent;
        
        KeInitializeEvent( &waitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );
        
        IoSetCompletionRoutine( Irp,
                                SfFsControlCompletion,
                                &waitEvent,     //context parameter
                                TRUE,
                                TRUE,
                                TRUE );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the operation to complete
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &waitEvent,
    		                                Executive,
    		                                KernelMode,
    		                                FALSE,
    		                                NULL );
    	    ASSERT( STATUS_SUCCESS == status );
    	}

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&waitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SfFsControlLoadFileSystemComplete( DeviceObject,
                                                    Irp );

    } else {
#endif    
    
        //
        //  Set a completion routine so we can delete the device object when
        //  the load is complete.
        //

        completionContext = ExAllocatePoolWithTag( NonPagedPool, 
                                                   sizeof( FSCTRL_COMPLETION_CONTEXT ),
                                                   SFLT_POOL_TAG );

        if (completionContext == NULL) {

            //
            //  If we cannot allocate our completion context, we will just pass 
            //  through the operation.  If your filter must be present for data
            //  access to this volume, you should consider failing the operation
            //  if memory cannot be allocated here.
            //

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        } else {

            ExInitializeWorkItem( &completionContext->WorkItem,
                                  SfFsControlLoadFileSystemCompleteWorker,
                                  completionContext );
            completionContext->DeviceObject = DeviceObject;
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = NULL;
              
            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine(
                Irp,
                SfFsControlCompletion,
                completionContext,
                TRUE,
                TRUE,
                TRUE );

            //
            //  Detach from the file system recognizer device object.
            //

            IoDetachDevice( devExt->AttachedToDeviceObject );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501        
    }
#endif   
    
    return status;
}

VOID
SfFsControlLoadFileSystemCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-LoadFileSystem work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    ASSERT( NULL != Context );

    SfFsControlLoadFileSystemComplete( Context->DeviceObject,
                                       Context->Irp );

    ExFreePoolWithTag( Context, SFLT_POOL_TAG );
}

NTSTATUS
SfFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This does the post-LoadFileSystem work and must be done as PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the load file system operation.

--*/
{
    PSFILTER_DEVICE_EXTENSION devExt;
    NTSTATUS status;

    PAGED_CODE();

    devExt = DeviceObject->DeviceExtension;
    
    //
    //  Display the name if requested
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFsControlLoadFileSystem:           Detaching from recognizer  %p \"%wZ\", status=%08x\n", 
                   DeviceObject,
                   &devExt->DeviceName,
                   Irp->IoStatus.Status) );

    //
    //  Check status of the operation
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status ) && 
        (Irp->IoStatus.Status != STATUS_IMAGE_ALREADY_LOADED)) {

        //
        //  The load was not successful.  Simply reattach to the recognizer
        //  driver in case it ever figures out how to get the driver loaded
        //  on a subsequent call.  There is not a lot we can do if this
        //  reattach fails.
        //

        SfAttachDeviceToDeviceStack( DeviceObject, 
                                     devExt->AttachedToDeviceObject,
                                     &devExt->AttachedToDeviceObject );

        ASSERT(devExt->AttachedToDeviceObject != NULL);

    } else {

        //
        //  The load was successful, so cleanup this device and delete the 
        //  Device object
        //

        SfCleanupMountedDevice( DeviceObject );
        IoDeleteDevice( DeviceObject );
    }

    //
    //  Continue processing the operation
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

/////////////////////////////////////////////////////////////////////////////
//
//                      FastIO Handling routines
//
/////////////////////////////////////////////////////////////////////////////

BOOLEAN
SfFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            return (fastIoDispatch->FastIoCheckIfPossible)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            return (fastIoDispatch->FastIoRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    
    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            return (fastIoDispatch->FastIoWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            return (fastIoDispatch->FastIoQueryBasicInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            return (fastIoDispatch->FastIoQueryStandardInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            return (fastIoDispatch->FastIoLock)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            return (fastIoDispatch->FastIoUnlockSingle)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;

        if (nextDeviceObject) {

            fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

                return (fastIoDispatch->FastIoUnlockAll)(
                            FileObject,
                            ProcessId,
                            IoStatus,
                            nextDeviceObject );
            }
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            return (fastIoDispatch->FastIoUnlockAllByKey)(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

            return (fastIoDispatch->FastIoDeviceControl)(
                        FileObject,
                        Wait,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        IoControlCode,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


VOID
SfFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to my device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    ASSERT(IS_MY_DEVICE_OBJECT( SourceDevice ));

    devExt = SourceDevice->DeviceExtension;

    //
    //  Display name information
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFastIoDetachDevice:                Detaching from volume      %p \"%wZ\"\n",
                   TargetDevice,
                   &devExt->DeviceName) );

    //
    //  Detach from the file system's volume device object.
    //

    SfCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );
}


BOOLEAN
SfFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            return (fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            return (fastIoDispatch->MdlRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            return (fastIoDispatch->MdlReadComplete)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            return (fastIoDispatch->PrepareMdlWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            return (fastIoDispatch->MdlWriteComplete)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*********************************************************************************
        UNIMPLEMENTED FAST IO ROUTINES
        
        The following four Fast IO routines are for compression on the wire
        which is not yet implemented in NT.  
        
        NOTE:  It is highly recommended that you include these routines (which
               do a pass-through call) so your filter will not need to be
               modified in the future when this functionality is implemented in
               the OS.
        
        FastIoReadCompressed, FastIoWriteCompressed, 
        FastIoMdlReadCompleteCompressed, FastIoMdlWriteCompleteCompressed
**********************************************************************************/


BOOLEAN
SfFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            return (fastIoDispatch->FastIoReadCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            return (fastIoDispatch->FastIoWriteCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            return (fastIoDispatch->MdlReadCompleteCompressed)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            return (fastIoDispatch->MdlWriteCompleteCompressed)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information for it.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Before calling the next filter, we must make sure their device
            //  object is in the current stack entry for the given IRP
            //

            irpSp->DeviceObject = nextDeviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)(
                        Irp,
                        NetworkInformation,
                        nextDeviceObject );

            //
            //  Always restore the IRP back to our device object
            //

            irpSp->DeviceObject = DeviceObject;
            return result;
        }
    }
    return FALSE;
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */
/////////////////////////////////////////////////////////////////////////////
//
//                  FSFilter callback handling routines
//
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
SfPreFsFilterPassThrough(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter pre-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    CompletionContext - A context set by this operation that will be passed
        to the corresponding SfPostFsFilterOperation call.
        
Return Value:

    Returns STATUS_SUCCESS if the operation can continue or an appropriate
    error code if the operation should fail.

--*/
{
    UNREFERENCED_PARAMETER( Data );
    UNREFERENCED_PARAMETER( CompletionContext );

    ASSERT( IS_MY_DEVICE_OBJECT( Data->DeviceObject ) );

    return STATUS_SUCCESS;
}

VOID
SfPostFsFilterPassThrough (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter post-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    OperationStatus - The status of this operation.        
    
    CompletionContext - A context that was set in the pre-operation 
        callback by this driver.
        
Return Value:

    None.
    
--*/
{
    UNREFERENCED_PARAMETER( Data );
    UNREFERENCED_PARAMETER( OperationStatus );
    UNREFERENCED_PARAMETER( CompletionContext );

    ASSERT( IS_MY_DEVICE_OBJECT( Data->DeviceObject ) );
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//                  Support routines
//
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
SfAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    )
/*++

Routine Description:

    This routine attaches the SourceDevice to the TargetDevice's stack and
    returns the device object SourceDevice was directly attached to in 
    AttachedToDeviceObject.  Note that the SourceDevice does not necessarily
    get attached directly to TargetDevice.  The SourceDevice will get attached
    to the top of the stack of which TargetDevice is a member.

    VERSION NOTE:

    In Windows XP, a new API was introduced to close a rare timing window that 
    can cause IOs to start being sent to a device before its 
    AttachedToDeviceObject is set in its device extension.  This is possible
    if a filter is attaching to a device stack while the system is actively
    processing IOs.  The new API closes this timing window by setting the
    device extension field that holds the AttachedToDeviceObject while holding
    the IO Manager's lock that protects the device stack.

    A sufficient work around for earlier versions of the OS is to set the
    AttachedToDeviceObject to the device object that the SourceDevice is most
    likely to attach to.  While it is possible that another filter will attach
    in between the SourceDevice and TargetDevice, this will prevent the
    system from bug checking if the SourceDevice receives IOs before the 
    AttachedToDeviceObject is correctly set.

    For a driver built in the Windows 2000 build environment, we will always 
    use the work-around code to attach.  For a driver that is built in the 
    Windows XP or later build environments (therefore you are building a 
    multiversion driver), we will determine which method of attachment to use 
    based on which APIs are available.

Arguments:

    SourceDevice - The device object to be attached to the stack.

    TargetDevice - The device that we currently think is the top of the stack
        to which SourceDevice should be attached.

    AttachedToDeviceObject - This is set to the device object to which 
        SourceDevice is attached if the attach is successful.
        
Return Value:

    Return STATUS_SUCCESS if the device is successfully attached.  If 
    TargetDevice represents a stack to which devices can no longer be attached,
    STATUS_NO_SUCH_DEVICE is returned.

--*/
{

    PAGED_CODE();

#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSfDynamicFunctions.AttachDeviceToDeviceStackSafe );
        return (gSfDynamicFunctions.AttachDeviceToDeviceStackSafe)( SourceDevice,
                                                                    TargetDevice,
                                                                    AttachedToDeviceObject );

    } else {

        ASSERT( NULL == gSfDynamicFunctions.AttachDeviceToDeviceStackSafe );
#endif

        *AttachedToDeviceObject = TargetDevice;
        *AttachedToDeviceObject = IoAttachDeviceToDeviceStack( SourceDevice,
                                                               TargetDevice );

        if (*AttachedToDeviceObject == NULL) {

            return STATUS_NO_SUCH_DEVICE;
        }

        return STATUS_SUCCESS;

#if WINVER >= 0x0501
    }
#endif
}
    
NTSTATUS
SfAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new volumes are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PSFILTER_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;
    UNICODE_STRING fsName;
    WCHAR tempNameBuffer[MAX_DEVNAME_LENGTH];

    PAGED_CODE();

    //
    //  See if this is a file system type we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  always init NAME buffer
    //

    RtlInitEmptyUnicodeString( &fsName,
                               tempNameBuffer,
                               sizeof(tempNameBuffer) );

    //
    //  See if we should attach to the standard file system recognizer device
    //  or not
    //

    if (!FlagOn(SfDebug,SFDEBUG_ATTACH_TO_FSRECOGNIZER)) {

        //
        //  See if this is one of the standard Microsoft file system recognizer
        //  devices (see if this device is in the FS_REC driver).  If so skip
        //  it.  We no longer attach to file system recognizer devices, we
        //  simply wait for the real file system driver to load.
        //

        RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );

        SfGetObjectName( DeviceObject->DriverObject, &fsName );

        if (RtlCompareUnicodeString( &fsName, &fsrecName, TRUE ) == 0) {

            return STATUS_SUCCESS;
        }
    }

    //
    //  We want to attach to this file system.  Create a new device object we
    //  can attach with.
    //

    status = IoCreateDevice( gSFilterDriverObject,
                             sizeof( SFILTER_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if ( FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( newDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( newDeviceObject->Flags, DO_DIRECT_IO );
    }

    if ( FlagOn( DeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN ) ) {

        SetFlag( newDeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN );
    }

    //
    //  Do the attachment
    //

    devExt = newDeviceObject->DeviceExtension;

    status = SfAttachDeviceToDeviceStack( newDeviceObject, 
                                          DeviceObject, 
                                          &devExt->AttachedToDeviceObject );

    if (!NT_SUCCESS( status )) {

        goto ErrorCleanupDevice;
    }

    //
    //  Set the name
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    RtlCopyUnicodeString( &devExt->DeviceName, DeviceName );        //Save Name

    //
    //  Mark we are done initializing
    //

    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfAttachToFileSystemDevice:          Attaching to file system   %p \"%wZ\" (%s)\n",
                   DeviceObject,
                   &devExt->DeviceName,
                   GET_DEVICE_TYPE_NAME(newDeviceObject->DeviceType)) );

    //
    //  VERSION NOTE:
    //
    //  In Windows XP, the IO Manager provided APIs to safely enumerate all the
    //  device objects for a given driver.  This allows filters to attach to 
    //  all mounted volumes for a given file system at some time after the
    //  volume has been mounted.  There is no support for this functionality
    //  in Windows 2000.
    //
    //  MULTIVERSION NOTE:
    //
    //  If built for Windows XP or later, this driver is built to run on 
    //  multiple versions.  When this is the case, we will test
    //  for the presence of the new IO Manager routines that allow for volume 
    //  enumeration.  If they are not present, we will not enumerate the volumes
    //  when we attach to a new file system.
    //
    
#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSfDynamicFunctions.EnumerateDeviceObjectList &&
                NULL != gSfDynamicFunctions.GetDiskDeviceObject &&
                NULL != gSfDynamicFunctions.GetDeviceAttachmentBaseRef &&
                NULL != gSfDynamicFunctions.GetLowerDeviceObject );

        //
        //  Enumerate all the mounted devices that currently
        //  exist for this file system and attach to them.
        //

        status = SfEnumerateFileSystemVolumes( DeviceObject, &fsName );

        if (!NT_SUCCESS( status )) {

            IoDetachDevice( devExt->AttachedToDeviceObject );
            goto ErrorCleanupDevice;
        }
    }
    
#endif

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupDevice:
        SfCleanupMountedDevice( newDeviceObject );
        IoDeleteDevice( newDeviceObject );

    return status;
}


VOID
SfDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PSFILTER_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                          ("SFilter!SfDetachFromFileSystemDevice:        Detaching from file system %p \"%wZ\" (%s)\n",
                           devExt->AttachedToDeviceObject,
                           &devExt->DeviceName,
                           GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType)) );

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            SfCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

#if WINVER >= 0x0501
NTSTATUS
SfEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PSFILTER_DEVICE_EXTENSION newDevExt;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT storageStackDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    BOOLEAN isShadowCopyVolume;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = (gSfDynamicFunctions.EnumerateDeviceObjectList)(
                    FSDeviceObject->DriverObject,
                    NULL,
                    0,
                    &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         SFLT_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        ASSERT( NULL != gSfDynamicFunctions.EnumerateDeviceObjectList );
        status = (gSfDynamicFunctions.EnumerateDeviceObjectList)(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Initialize state so we can cleanup properly
            //

            storageStackDeviceObject = NULL;

            try {

                //
                //  Do not attach if:
                //      - This is the control device object (the one passed in)
                //      - The device type does not match
                //      - We are already attached to it.
                //

                if ((devList[i] == FSDeviceObject) ||
                    (devList[i]->DeviceType != FSDeviceObject->DeviceType) ||
                    SfIsAttachedToDevice( devList[i], NULL )) {

                    leave;
                }

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device (like FastFat).
                //

                SfGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length > 0) {

                    leave;
                }

                //
                //  Get the real (disk,storage stack) device object associated
                //  with this file system device object.  Only try to attach
                //  if we have a disk device object.
                //

                ASSERT( NULL != gSfDynamicFunctions.GetDiskDeviceObject );
                status = (gSfDynamicFunctions.GetDiskDeviceObject)( devList[i], 
                                                                   &storageStackDeviceObject );

                if (!NT_SUCCESS( status )) {

                    leave;
                }

                //
                //  Determine if this is a shadow copy volume.  If so don't
                //  attach to it.
                //  NOTE:  There is no reason sfilter shouldn't attach to these
                //         volumes, this is simply a sample of how to not
                //         attach if you don't want to
                //

                status = SfIsShadowCopyVolume ( storageStackDeviceObject, 
                                                &isShadowCopyVolume );

                if (NT_SUCCESS(status) &&
                    isShadowCopyVolume &&
                    !FlagOn(SfDebug,SFDEBUG_ATTACH_TO_SHADOW_COPIES)) {

                    UNICODE_STRING shadowDeviceName;
                    WCHAR shadowNameBuffer[MAX_DEVNAME_LENGTH];

                    //
                    //  Get the name for the debug display
                    //

                    RtlInitEmptyUnicodeString( &shadowDeviceName, 
                                               shadowNameBuffer, 
                                               sizeof(shadowNameBuffer) );

                    SfGetObjectName( storageStackDeviceObject, 
                                     &shadowDeviceName );

                    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                  ("SFilter!SfEnumerateFileSystemVolumes         Not attaching to Volume    %p \"%wZ\", shadow copy volume\n", 
                                   storageStackDeviceObject,
                                   &shadowDeviceName) );

                    leave;
                }

                //
                //  Allocate a new device object to attach with
                //

                status = IoCreateDevice( gSFilterDriverObject,
                                         sizeof( SFILTER_DEVICE_EXTENSION ),
                                         NULL,
                                         devList[i]->DeviceType,
                                         0,
                                         FALSE,
                                         &newDeviceObject );

                if (!NT_SUCCESS( status )) {

                    leave;
                }

                //
                //  Set disk device object
                //

                newDevExt = newDeviceObject->DeviceExtension;
                newDevExt->StorageStackDeviceObject = storageStackDeviceObject;
        
                //
                //  Set storage stack device name
                //

                RtlInitEmptyUnicodeString( &newDevExt->DeviceName,
                                           newDevExt->DeviceNameBuffer,
                                           sizeof(newDevExt->DeviceNameBuffer) );

                SfGetObjectName( storageStackDeviceObject, 
                                 &newDevExt->DeviceName );


                //
                //  We have done a lot of work since the last time
                //  we tested to see if we were already attached
                //  to this device object.  Test again, this time
                //  with a lock, and attach if we are not attached.
                //  The lock is used to atomically test if we are
                //  attached, and then do the attach.
                //

                ExAcquireFastMutex( &gSfilterAttachLock );

                if (!SfIsAttachedToDevice( devList[i], NULL )) {

                    //
                    //  Attach to volume.
                    //

                    status = SfAttachToMountedDevice( devList[i], 
                                                      newDeviceObject );
                    
                    if (!NT_SUCCESS( status )) { 

                        //
                        //  The attachment failed, cleanup.  Note that
                        //  we continue processing so we will cleanup
                        //  the reference counts and try to attach to
                        //  the rest of the volumes.
                        //
                        //  One of the reasons this could have failed
                        //  is because this volume is just being
                        //  mounted as we are attaching and the
                        //  DO_DEVICE_INITIALIZING flag has not yet
                        //  been cleared.  A filter could handle
                        //  this situation by pausing for a short
                        //  period of time and retrying the attachment a
                        //  limited number of times.
                        //

                        SfCleanupMountedDevice( newDeviceObject );
                        IoDeleteDevice( newDeviceObject );
                    }

                } else {

                    //
                    //  We were already attached, cleanup this
                    //  device object.
                    //

                    SfCleanupMountedDevice( newDeviceObject );
                    IoDeleteDevice( newDeviceObject );
                }

                //
                //  Release the lock
                //

                ExReleaseFastMutex( &gSfilterAttachLock );

            } finally {

                //
                //  Remove reference added by IoGetDiskDeviceObject.
                //  We only need to hold this reference until we are
                //  successfully attached to the current volume.  Once
                //  we are successfully attached to devList[i], the
                //  IO Manager will make sure that the underlying
                //  storageStackDeviceObject will not go away until
                //  the file system stack is torn down.
                //

                if (storageStackDeviceObject != NULL) {

                    ObDereferenceObject( storageStackDeviceObject );
                }

                //
                //  Dereference the object (reference added by 
                //  IoEnumerateDeviceObjectList)
                //

                ObDereferenceObject( devList[i] );
            }
        }

        //
        //  We are going to ignore any errors received while attaching.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}
#endif

NTSTATUS
SfAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT SFilterDeviceObject
    )
/*++

Routine Description:

    This will attach to a DeviceObject that represents a mounted volume.

Arguments:

    DeviceObject - The device to attach to

    SFilterDeviceObject - Our device object we are going to attach

Return Value:

    Status of the operation

--*/
{        
    PSFILTER_DEVICE_EXTENSION newDevExt = SFilterDeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();
    ASSERT(IS_MY_DEVICE_OBJECT( SFilterDeviceObject ));
#if WINVER >= 0x0501    
    ASSERT(!SfIsAttachedToDevice ( DeviceObject, NULL ));
#endif

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( SFilterDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( SFilterDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  It is possible for this attachment request to fail because this device
    //  object has not finished initializing.  This can occur if this filter
    //  loaded just as this volume was being mounted.
    //

    for (i=0; i < 8; i++) {
        LARGE_INTEGER interval;

        //
        //  Attach our device object to the given device object
        //  The only reason this can fail is if someone is trying to dismount
        //  this volume while we are attaching to it.
        //

        status = SfAttachDeviceToDeviceStack( SFilterDeviceObject, 
                                              DeviceObject,
                                              &newDevExt->AttachedToDeviceObject );
        if (NT_SUCCESS(status)) {

            //
            //  Finished all initialization of the new device object,  so clear the
            //  initializing flag now.  This allows other filters to now attach
            //  to our device object.
            //

            ClearFlag( SFilterDeviceObject->Flags, DO_DEVICE_INITIALIZING );

            //
            //  Display the name
            //

            SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                          ("SFilter!SfAttachToMountedDevice:             Attaching to volume        %p \"%wZ\"\n", 
                           newDevExt->AttachedToDeviceObject,
                           &newDevExt->DeviceName) );

            return STATUS_SUCCESS;
        }

        //
        //  Delay, giving the device object a chance to finish its
        //  initialization so we can try again
        //

        interval.QuadPart = (500 * DELAY_ONE_MILLISECOND);      //delay 1/2 second
        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    return status;
}

VOID
SfCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This cleans up any necessary data in the device extension to prepare for
    this memory to be freed.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

    None

--*/
{        

    UNREFERENCED_PARAMETER( DeviceObject );
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));
}


VOID
SfGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer that
           receives the name of the object.

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

//
//  VERSION NOTE:
//
//  This helper routine is only needed when enumerating all volumes in the
//  system, which is only supported on Windows XP and later.
//

#if WINVER >= 0x0501
VOID
SfGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer that
           receives the name of the device object.

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    ASSERT( NULL != gSfDynamicFunctions.GetDeviceAttachmentBaseRef );
    DeviceObject = (gSfDynamicFunctions.GetDeviceAttachmentBaseRef)( DeviceObject );

    //
    //  Get the name of that object
    //

    SfGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}
#endif

PUNICODE_STRING
SfGetFileName(
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS CreateStatus,
    IN OUT PGET_NAME_CONTROL NameControl
    )
/*++

Routine Description:

    This routine will try and get the name of the given file object.  This
    is guaranteed to always return a printable string (though it may be NULL).
    This will allocate a buffer if it needs to.

Arguments:
    FileObject - the file object we want the name for

    CreateStatus - status of the create operation

    NameControl - control structure used for retrieving the name.  It keeps
        track if a buffer was allocated or if we are using the internal
        buffer.

Return Value:

    Pointer to the unicode string with the name

--*/
{
    POBJECT_NAME_INFORMATION nameInfo;
    NTSTATUS status;
    ULONG size;
    ULONG bufferSize;

    //
    //  Mark we have not allocated the buffer
    //

    NameControl->allocatedBuffer = NULL;

    //
    //  Use the small buffer in the structure (that will handle most cases)
    //  for the name
    //

    nameInfo = (POBJECT_NAME_INFORMATION)NameControl->smallBuffer;
    bufferSize = sizeof(NameControl->smallBuffer);

    //
    //  If the open succeeded, get the name of the file, if it
    //  failed, get the name of the device.
    //
        
    status = ObQueryNameString(
                  (NT_SUCCESS( CreateStatus ) ?
                    (PVOID)FileObject :
                    (PVOID)FileObject->DeviceObject),
                  nameInfo,
                  bufferSize,
                  &size );

    //
    //  See if the buffer was to small
    //

    if (status == STATUS_BUFFER_OVERFLOW) {

        //
        //  The buffer was too small, allocate one big enough
        //

        bufferSize = size + sizeof(WCHAR);

        NameControl->allocatedBuffer = ExAllocatePoolWithTag( 
                                            NonPagedPool,
                                            bufferSize,
                                            SFLT_POOL_TAG );

        if (NULL == NameControl->allocatedBuffer) {

            //
            //  Failed allocating a buffer, return an empty string for the name
            //

            RtlInitEmptyUnicodeString(
                (PUNICODE_STRING)&NameControl->smallBuffer,
                (PWCHAR)(NameControl->smallBuffer + sizeof(UNICODE_STRING)),
                (USHORT)(sizeof(NameControl->smallBuffer) - sizeof(UNICODE_STRING)) );

            return (PUNICODE_STRING)&NameControl->smallBuffer;
        }

        //
        //  Set the allocated buffer and get the name again
        //

        nameInfo = (POBJECT_NAME_INFORMATION)NameControl->allocatedBuffer;

        status = ObQueryNameString(
                      FileObject,
                      nameInfo,
                      bufferSize,
                      &size );
    }

    //
    //  If we got a name and an error opening the file then we
    //  just received the device name.  Grab the rest of the name
    //  from the FileObject (note that this can only be done if being called
    //  from Create).  This only happens if we got an error back from the
    //  create.
    //

    if (NT_SUCCESS( status ) && 
                    !NT_SUCCESS( CreateStatus )) {

        ULONG newSize;
        PCHAR newBuffer;
        POBJECT_NAME_INFORMATION newNameInfo;

        //
        //  Calculate the size of the buffer we will need to hold
        //  the combined names
        //

        newSize = size + FileObject->FileName.Length;

        //
        //  If there is a related file object add in the length
        //  of that plus space for a separator
        //

        if (NULL != FileObject->RelatedFileObject) {

            newSize += FileObject->RelatedFileObject->FileName.Length + 
                       sizeof(WCHAR);
        }

        //
        //  See if it will fit in the existing buffer
        //

        if (newSize > bufferSize) {

            //
            //  It does not fit, allocate a bigger buffer
            //

            newBuffer = ExAllocatePoolWithTag( 
                                    NonPagedPool,
                                    newSize,
                                    SFLT_POOL_TAG );

            if (NULL == newBuffer) {

                //
                //  Failed allocating a buffer, return an empty string for the name
                //

                RtlInitEmptyUnicodeString(
                    (PUNICODE_STRING)&NameControl->smallBuffer,
                    (PWCHAR)(NameControl->smallBuffer + sizeof(UNICODE_STRING)),
                    (USHORT)(sizeof(NameControl->smallBuffer) - sizeof(UNICODE_STRING)) );

                return (PUNICODE_STRING)&NameControl->smallBuffer;
            }

            //
            //  Now initialize the new buffer with the information
            //  from the old buffer.
            //

            newNameInfo = (POBJECT_NAME_INFORMATION)newBuffer;

            RtlInitEmptyUnicodeString(
                &newNameInfo->Name,
                (PWCHAR)(newBuffer + sizeof(OBJECT_NAME_INFORMATION)),
                (USHORT)(newSize - sizeof(OBJECT_NAME_INFORMATION)) );

            RtlCopyUnicodeString( &newNameInfo->Name, 
                                  &nameInfo->Name );

            //
            //  Free the old allocated buffer (if there is one)
            //  and save off the new allocated buffer address.  It
            //  would be very rare that we should have to free the
            //  old buffer because device names should always fit
            //  inside it.
            //

            if (NULL != NameControl->allocatedBuffer) {

                ExFreePool( NameControl->allocatedBuffer );
            }

            //
            //  Readjust our pointers
            //

            NameControl->allocatedBuffer = newBuffer;
            bufferSize = newSize;
            nameInfo = newNameInfo;

        } else {

            //
            //  The MaximumLength was set by ObQueryNameString to
            //  one char larger then the length.  Set it to the
            //  true size of the buffer (so we can append the names)
            //

            nameInfo->Name.MaximumLength = (USHORT)(bufferSize - 
                                  sizeof(OBJECT_NAME_INFORMATION));
        }

        //
        //  If there is a related file object, append that name
        //  first onto the device object along with a separator
        //  character
        //

        if (NULL != FileObject->RelatedFileObject) {

            RtlAppendUnicodeStringToString(
                    &nameInfo->Name,
                    &FileObject->RelatedFileObject->FileName );

            RtlAppendUnicodeToString( &nameInfo->Name, L"\\" );
        }

        //
        //  Append the name from the file object
        //

        RtlAppendUnicodeStringToString(
                &nameInfo->Name,
                &FileObject->FileName );

        ASSERT(nameInfo->Name.Length <= nameInfo->Name.MaximumLength);
    }

    //
    //  Return the name
    //

    return &nameInfo->Name;
}


VOID
SfGetFileNameCleanup(
    IN OUT PGET_NAME_CONTROL NameControl
    )
/*++

Routine Description:

    This will see if a buffer was allocated and will free it if it was

Arguments:

    NameControl - control structure used for retrieving the name.  It keeps
        track if a buffer was allocated or if we are using the internal
        buffer.

Return Value:

    None

--*/
{

    if (NULL != NameControl->allocatedBuffer) {

        ExFreePool( NameControl->allocatedBuffer);
        NameControl->allocatedBuffer = NULL;
    }
}

//
//  VERSION NOTE:
//  
//  In Windows 2000, the APIs to safely walk an arbitrary file system device 
//  stack were not supported.  If we can guarantee that a device stack won't 
//  be torn down during the walking of the device stack, we can walk from
//  the base file system's device object up to the top of the device stack
//  to see if we are attached.  We know the device stack will not go away if
//  we are in the process of processing a mount request OR we have a file object
//  open on this device.
//  
//  In Windows XP and later, the IO Manager provides APIs that will allow us to
//  walk through the chain safely using reference counts to protect the device 
//  object from going away while we are inspecting it.  This can be done at any
//  time.
//
//  MULTIVERSION NOTE:
//
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test for the presence of
//  the new IO Manager routines that allow for a filter to safely walk the file
//  system device stack and use those APIs if they are present to determine if
//  we have already attached to this volume.  If these new IO Manager routines
//  are not present, we will assume that we are at the bottom of the file
//  system stack and walk up the stack looking for our device object.
//

BOOLEAN
SfIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
{

    PAGED_CODE();

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSfDynamicFunctions.GetLowerDeviceObject &&
                NULL != gSfDynamicFunctions.GetDeviceAttachmentBaseRef );
        
        return SfIsAttachedToDeviceWXPAndLater( DeviceObject, AttachedDeviceObject );
    } else {
#endif

        return SfIsAttachedToDeviceW2K( DeviceObject, AttachedDeviceObject );

#if WINVER >= 0x0501
    }
#endif    
}

BOOLEAN
SfIsAttachedToDeviceW2K (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows 2000

    This routine walks up the device stack from the DeviceObject passed in
    looking for a device object that belongs to our filter.

    Note:  If AttachedDeviceObject is returned with a non-NULL value,
           there is a reference on the AttachedDeviceObject that must
           be cleared by the caller.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which FileSpy
            has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevice;

    PAGED_CODE();

    for (currentDevice = DeviceObject;
         currentDevice != NULL;
         currentDevice = currentDevice->AttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( currentDevice )) {

            //
            //  We are attached.  If requested, return the found device object.
            //

            if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

                ObReferenceObject( currentDevice );
                *AttachedDeviceObject = currentDevice;
            }

            return TRUE;
        }
    }

    //
    //  We did not find ourselves on the attachment chain.  Return a NULL
    //  device object pointer (if requested) and return we did not find
    //  ourselves.
    //
    
    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}

#if WINVER >= 0x0501
BOOLEAN
SfIsAttachedToDeviceWXPAndLater (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows XP and later

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - The Sfilter device attached to this device.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    PAGED_CODE();
    
    //
    //  Get the device object at the TOP of the attachment chain
    //

    ASSERT( NULL != gSfDynamicFunctions.GetAttachedDeviceReference );
    currentDevObj = (gSfDynamicFunctions.GetAttachedDeviceReference)( DeviceObject );

    //
    //  Scan down the list to find our device object.
    //

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) {

            //
            //  We have found that we are already attached.  If we are
            //  returning the device object, leave it referenced else remove
            //  the reference.
            //

            if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

                *AttachedDeviceObject = currentDevObj;

            } else {

                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        ASSERT( NULL != gSfDynamicFunctions.GetLowerDeviceObject );
        nextDevObj = (gSfDynamicFunctions.GetLowerDeviceObject)( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    //
    //  We did not find ourselves on the attachment chain.  Return a NULL
    //  device object pointer (if requested) and return we did not find
    //  ourselves.
    //

    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}    
#endif

VOID
SfReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the sfilter-specific parameters from 
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key passed to the driver during driver entry.
        
Return Value:

    None.

--*/
{
    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING valueName;
    UCHAR buffer[sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( LONG )];

    PAGED_CODE();

    //
    //  If this value is not the default value then somebody has already
    //  explicitly set it so don't override those settings.
    //

    if (0 == SfDebug) {

        //
        //  Open the desired registry key
        //

        InitializeObjectAttributes( &attributes,
                                    RegistryPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        status = ZwOpenKey( &driverRegKey,
                            KEY_READ,
                            &attributes );

        if (!NT_SUCCESS( status )) {

            return;
        }

        //
        // Read the DebugDisplay value from the registry.
        //

        RtlInitUnicodeString( &valueName, L"DebugFlags" );
    
        status = ZwQueryValueKey( driverRegKey,
                                  &valueName,
                                  KeyValuePartialInformation,
                                  buffer,
                                  sizeof(buffer),
                                  &resultLength );

        if (NT_SUCCESS( status )) {

            SfDebug = *((PLONG) &(((PKEY_VALUE_PARTIAL_INFORMATION) buffer)->Data));
        } 

        //
        //  Close the registry entry
        //

        ZwClose(driverRegKey);
    }
}


NTSTATUS
SfIsShadowCopyVolume (
    IN PDEVICE_OBJECT StorageStackDeviceObject,
    OUT PBOOLEAN IsShadowCopy
    )
/*++

Routine Description:

    This routine will determine if the given volume is for a ShadowCopy volume
    or some other type of volume.

    VERSION NOTE:

    ShadowCopy volumes were introduced in Windows XP, therefore, if this
    driver is running on W2K, we know that this is not a shadow copy volume.

    Also note that in Windows XP, we need to test to see if the driver name
    of this device object is \Driver\VolSnap in addition to seeing if this
    device is read-only.  For Windows .NET server and later, we can infer that
    this is a ShadowCopy by looking for a DeviceType == FILE_DEVICE_VIRTUAL_DISK
    and read-only volume.
    
Arguments:

    StorageStackDeviceObject - pointer to the disk device object
    IsShadowCopy - returns TRUE if this is a shadow copy, FALSE otherwise
        
Return Value:

    The status of the operation.  If this operation fails IsShadowCopy is
    always set to FALSE.

--*/
{

    PAGED_CODE();

    //
    //  Default to NOT a shadow copy volume
    //

    *IsShadowCopy = FALSE;

#if WINVER >= 0x0501
    if (IS_WINDOWS2000()) {
#endif        

        UNREFERENCED_PARAMETER( StorageStackDeviceObject );
        return STATUS_SUCCESS;

#if WINVER >= 0x0501        
    }

    if (IS_WINDOWSXP()) {

        UNICODE_STRING volSnapDriverName;
        WCHAR buffer[MAX_DEVNAME_LENGTH];
        PUNICODE_STRING storageDriverName;
        ULONG returnedLength;
        NTSTATUS status;

        //
        //  In Windows XP, all ShadowCopy devices were of type FILE_DISK_DEVICE.
        //  If this does not have a device type of FILE_DISK_DEVICE, then
        //  it is not a ShadowCopy volume.  Return now.
        //

        if (FILE_DEVICE_DISK != StorageStackDeviceObject->DeviceType) {

            return STATUS_SUCCESS;
        }

        //
        //  Unfortunately, looking for the FILE_DEVICE_DISK isn't enough.  We
        //  need to find out if the name of this driver is \Driver\VolSnap as
        //  well.
        //

        storageDriverName = (PUNICODE_STRING) buffer;
        RtlInitEmptyUnicodeString( storageDriverName, 
                                   Add2Ptr( storageDriverName, sizeof( UNICODE_STRING ) ),
                                   sizeof( buffer ) - sizeof( UNICODE_STRING ) );

        status = ObQueryNameString( StorageStackDeviceObject,
                                    (POBJECT_NAME_INFORMATION)storageDriverName,
                                    storageDriverName->MaximumLength,
                                    &returnedLength );

        if (!NT_SUCCESS( status )) {

            return status;
        }

        RtlInitUnicodeString( &volSnapDriverName, L"\\Driver\\VolSnap" );

        if (RtlEqualUnicodeString( storageDriverName, &volSnapDriverName, TRUE )) {

            //
            // This is a ShadowCopy volume, so set our return parameter to true.
            //

            *IsShadowCopy = TRUE;

        } else {

            //
            //  This is not a ShadowCopy volume, but IsShadowCopy is already 
            //  set to FALSE.  Fall through to return to the caller.
            //

            NOTHING;
        }

        return STATUS_SUCCESS;
        
    } else {

        PIRP irp;
        KEVENT event;
        IO_STATUS_BLOCK iosb;
        NTSTATUS status;

        //
        //  For Windows .NET and later, it is sufficient to test for a
        //  device type fo FILE_DEVICE_VIRTUAL_DISK and that the device
        //  is read-only to identify a ShadowCopy.
        //

        //
        //  If this does not have a device type of FILE_DEVICE_VIRTUAL_DISK, then
        //  it is not a ShadowCopy volume.  Return now.
        //

        if (FILE_DEVICE_VIRTUAL_DISK != StorageStackDeviceObject->DeviceType) {

            return STATUS_SUCCESS;
        }

        //
        //  It has the correct device type, see if it is marked as read only.
        //
        //  NOTE:  You need to be careful which device types you do this operation
        //         on.  It is accurate for this type but for other device
        //         types it may return misleading information.  For example the
        //         current microsoft cdrom driver always returns CD media as
        //         readonly, even if the media may be writable.  On other types
        //         this state may change.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );

        irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_IS_WRITABLE,
                                             StorageStackDeviceObject,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &iosb );

        //
        //  If we could not allocate an IRP, return an error
        //

        if (irp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Call the storage stack and see if this is readonly
        //

        status = IoCallDriver( StorageStackDeviceObject, irp );

        if (status == STATUS_PENDING) {

            (VOID)KeWaitForSingleObject( &event,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL );

            status = iosb.Status;
        }

        //
        //  If the media is write protected then this is a shadow copy volume
        //

        if (STATUS_MEDIA_WRITE_PROTECTED == status) {

            *IsShadowCopy = TRUE;
            status = STATUS_SUCCESS;
        }

        //
        //  Return the status of the IOCTL.  IsShadowCopy is already set to FALSE
        //  which is what we want if STATUS_SUCCESS was returned or if an error
        //  was returned.
        //

        return status;
    }
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\clifile.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    clifile.cpp

Abstract:

    Implements CLI FILE sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "rpdata.h"

HRESULT
FileRecall(
   IN LPWSTR *FileSpecs,
   IN DWORD NumberOfFileSpecs
)
/*++

Routine Description:

    Recalls all the files that match the given specification (path + wildcards)

Arguments:

    FileSpecs           - 
    NumberOfFileSpecs   - 

Return Value:

    S_OK            - If all the files are recalled successfully.

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              hSearchHandle = INVALID_HANDLE_VALUE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                bExistingFiles = FALSE;

    WsbTraceIn(OLESTR("FileRecall"), OLESTR(""));

    try {

        // Verify that input parameters are valid
        if (0 == NumberOfFileSpecs) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_FILES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Enumerate over the file specifications
        for (ULONG i = 0; i < NumberOfFileSpecs; i++) {
            CWsbStringPtr   nameSpace;
            WCHAR*          pathEnd;
            WIN32_FIND_DATA findData;
            BOOL            bMoreFiles = TRUE;

            WsbAssert(NULL != FileSpecs[i], E_INVALIDARG);

            // Enumerate over files in each specification
            nameSpace = FileSpecs[i];
            WsbAffirmHr(nameSpace.Prepend(OLESTR("\\\\?\\")));
            pathEnd = wcsrchr(nameSpace, L'\\');
            WsbAssert(pathEnd != NULL, E_INVALIDARG);

            hSearchHandle = FindFirstFile((WCHAR *)nameSpace, &findData);
            if (INVALID_HANDLE_VALUE != hSearchHandle) {
                // Found at least one file that matches an input file specification
                bExistingFiles = TRUE;
            }

            while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
                if ( findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
                    // File may be managed by HSM:
                    CWsbStringPtr           fileName;
                    BYTE                    ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
                    PREPARSE_DATA_BUFFER    pReparseBuffer;
                    DWORD                   outSize;
                    BOOL                    bRecall = FALSE;

                    // Create full name based on the path and the find-data 
                    *(pathEnd+1) = L'\0';
                    fileName = nameSpace;
                    *(pathEnd+1) = L'\\';
                    WsbAffirmHr(fileName.Append(findData.cFileName));

                    // Open the file
                    hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_FLAG_OPEN_NO_RECALL | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
                    if (INVALID_HANDLE_VALUE == hFile) {
                        // Report on an error
                        DWORD dwErr = GetLastError();            
                        hr = HRESULT_FROM_WIN32(dwErr);
                        WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }

                    // Get reparse data and check if the file is offline (if not, just ignore it and continue)
                    if (0 == DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, 
                                ReparseBuffer, sizeof(ReparseBuffer), &outSize, NULL)) {    
                        // Report on an error
                        DWORD dwErr = GetLastError();            
                        hr = HRESULT_FROM_WIN32(dwErr);
                        WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }
                    pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;
                    if (IO_REPARSE_TAG_HSM == pReparseBuffer->ReparseTag) {
                        PRP_DATA    pHsmData = (PRP_DATA) &pReparseBuffer->GenericReparseBuffer.DataBuffer[0];
                        if( RP_FILE_IS_TRUNCATED( pHsmData->data.bitFlags ) ) {
                            // File is managed by HSM and truncated
                            bRecall = TRUE;
                        }
                    }

                    CloseHandle(hFile);
                    hFile = INVALID_HANDLE_VALUE;

                    // Recall the file if required
                    if (bRecall) {
                        // Open the file again for recall
                        hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (INVALID_HANDLE_VALUE == hFile) {
                            // Report on an error
                            DWORD dwErr = GetLastError();            
                            hr = HRESULT_FROM_WIN32(dwErr);
                            WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }

                        // Recall the file
                        if (0 == DeviceIoControl(hFile, FSCTL_RECALL_FILE, NULL, 0, 
                                    NULL, 0, &outSize, NULL)) {
                            // Report on an error
                            // TEMPORARY: Should we abort or continue recalling other files?
                            DWORD dwErr = GetLastError();            
                            hr = HRESULT_FROM_WIN32(dwErr);
                            WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }

                        CloseHandle(hFile);
                        hFile = INVALID_HANDLE_VALUE;
                    }
                }

                // Get next file
                bMoreFiles = FindNextFile(hSearchHandle, &findData);
            }

            // Prepare for next file specification
            nameSpace.Free();
            if (INVALID_HANDLE_VALUE != hSearchHandle) {
                FindClose(hSearchHandle);
                hSearchHandle = INVALID_HANDLE_VALUE;
            }
        }

        // Print warning message if no valid file was specified
        if (FALSE == bExistingFiles) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_FILES, NULL);
        }

    } WsbCatch(hr);

    // Ensure cleanup in case of an error
    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;
    }
    if (INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("FileRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\climedia.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    climedia.cpp

Abstract:

    Implements CLI MEDIA sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "engine.h"

static GUID g_nullGuid = GUID_NULL;

// Internal utilities and classes for MEDIA interface
#define CMEDIA_INVALID_INDEX      (-1)

HRESULT IsMediaValid(IN IMediaInfo *pMediaInfo);
HRESULT ShowMediaParams(IN IMediaInfo *pMediaInfo, BOOL bName, IN BOOL bStatus, IN BOOL bCapacity,
                        IN BOOL bFreeSpace, IN BOOL Version, IN BOOL Copies);
HRESULT IsCopySetValid (IN IHsmServer *pHsm, IN DWORD dwCopySetNumber);

class CMediaEnum
{

// Constructors, destructors
public:
    CMediaEnum(IN LPWSTR *pMediaNames, IN DWORD dwNumberOfMedia);
    ~CMediaEnum();

// Public methods
public:
    HRESULT First(OUT IMediaInfo **ppMediaInfo);
    HRESULT Next(OUT IMediaInfo **ppMediaInfo);
    HRESULT ErrorMedia(OUT int *pIndex);

// Private data
protected:
    LPWSTR                  *m_pMediaNames;
    DWORD                   m_dwNumberOfMedia;

    // If * enumeration or not
    BOOL                    m_bAllMedias;

    // Data for the enumeration
    CComPtr<IWsbDb>         m_pDb;
    CComPtr<IWsbDbSession>  m_pDbSession;
    CComPtr<IMediaInfo>     m_pMediaInfo;

    // Used only when m_bAllMedias == FALSE
    int                     m_nCurrent;
    BOOL                    m_bInvalidMedia;
};

inline
HRESULT CMediaEnum::ErrorMedia(OUT int *pIndex)
{
    HRESULT     hr = S_FALSE;
    if (m_bInvalidMedia) {
        // There was an error with last media
        hr = S_OK;
    }

    *pIndex = m_nCurrent;

    return(hr);
}

//
// MEDIA inetrafce implementors
//

HRESULT
MediaSynchronize(
   IN DWORD  CopySetNumber,
   IN BOOL   Synchronous
)
/*++

Routine Description:

    Creates/updates the specified media copy set

Arguments:

    CopySetNumber   -   The copy set number to create/synchronize
    Synchronous     -   If TRUE, the function waits for the operation   
                        to complete before returning. If not, it returns
                        immediately after starting the job 
                        

Return Value:

    S_OK            - If the copy set was created/updated successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("MediaSynchronize"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;

        // Get HSM server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

        // Verify that input parameters are valid
        WsbAffirmHr(ValidateLimitsArg(CopySetNumber, IDS_MEDIA_COPY_SET, HSMADMIN_MIN_COPY_SETS + 1, HSMADMIN_MAX_COPY_SETS));

        hr = IsCopySetValid(pHsm, CopySetNumber);
        if (S_FALSE == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_IVALID_COPY_SET, NULL);
            WsbThrow(E_INVALIDARG);
        } else {
            WsbAffirmHr(hr);
        }

        // Synchronize copy set
        if (Synchronous) {
            // Call directly Engine method
            WsbAffirmHr(pHsm->SynchronizeMedia(g_nullGuid, (USHORT)CopySetNumber));
        } else {
            // Use RsLaunch
            // Note: Another possibility here would be using the CLI (rss.exex) itself
            // with synchronous flag on, but it's better to depend here on internal HSM 
            // interface (RsLaunch) and not an external one (RSS) that only the parser knows
            CWsbStringPtr       cmdLine;
            WCHAR               cmdParams[40];
            STARTUPINFO         startupInfo;
            PROCESS_INFORMATION exeInfo;

            // Startup info
            memset(&startupInfo, 0, sizeof(startupInfo));
            startupInfo.cb = sizeof( startupInfo );
            startupInfo.wShowWindow = SW_HIDE;
            startupInfo.dwFlags = STARTF_USESHOWWINDOW;

            // Create command line
            swprintf(cmdParams, OLESTR(" sync %lu"), CopySetNumber);
            WsbAffirmHr(cmdLine.Alloc(MAX_PATH + wcslen(WSB_FACILITY_LAUNCH_NAME) + wcslen(cmdParams) + 10));
            WsbAffirmStatus(GetSystemDirectory(cmdLine, MAX_PATH));
            WsbAffirmHr(cmdLine.Append(OLESTR("\\")));
            WsbAffirmHr(cmdLine.Append(WSB_FACILITY_LAUNCH_NAME));
            WsbAffirmHr(cmdLine.Append(cmdParams));

            // Run the RsLaunch process
            WsbAffirmStatus(CreateProcess(NULL, cmdLine, NULL, NULL, FALSE, NULL, NULL, NULL, 
                                            &startupInfo, &exeInfo));

            // Cleanup
            CloseHandle(exeInfo.hProcess);
            CloseHandle(exeInfo.hThread);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaSynchronize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
MediaRecreateMaster(
   IN LPWSTR MediaName,
   IN DWORD  CopySetNumber,
   IN BOOL   Synchronous
)
/*++

Routine Description:

    Recreate a master for the given meida out of the specified copy

Arguments:

    MediaName       -   Master media name of media to recreate
    CopySetNumber   -   The copy number to use for recreating the master
    Synchronous     -   If TRUE, the function waits for the operation   
                        to complete before returning. If not, it returns
                        immediately after starting the job 

Return Value:

    S_OK            - If the master is recreated successfully from the specified copy

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("MediaRecreateMaster"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;
        GUID                    mediaId;

        // Get HSM server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

        // Verify that input parameters are valid
        if ((NULL == MediaName) || (NULL == *MediaName)) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(CopySetNumber, IDS_MEDIA_COPY_SET, HSMADMIN_MIN_COPY_SETS + 1, HSMADMIN_MAX_COPY_SETS));
        hr = IsCopySetValid(pHsm, CopySetNumber);
        if (S_FALSE == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_IVALID_COPY_SET, NULL);
            WsbThrow(E_INVALIDARG);
        } else {
            WsbAffirmHr(hr);
        }

        // Find the media id according to the given display name
        hr = pHsm->FindMediaIdByDescription(MediaName, &mediaId);
        if ((WSB_E_NOTFOUND == hr) || (GUID_NULL == mediaId)) {
            // Given media name is invalid
            WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaName, NULL);
            WsbThrow(E_INVALIDARG);
        }
        WsbAffirmHr(hr);

        // Mark media for recreation
        WsbAffirmHr(pHsm->MarkMediaForRecreation(mediaId));

        if (Synchronous) {
            // Recreate the master
            WsbAffirmHr(pHsm->RecreateMaster(mediaId, (USHORT)CopySetNumber));

        } else {
            // Use RsLaunch
            // Note: Another possibility here would be using the CLI (rss.exex) itself
            // with synchronous flag on, but it's better to depend here on internal HSM 
            // interface (RsLaunch) and not an external one (RSS) that only the parser knows
            CWsbStringPtr       cmdLine;
            CWsbStringPtr       cmdParams;
            STARTUPINFO         startupInfo;
            PROCESS_INFORMATION exeInfo;
            CWsbStringPtr       stringId(mediaId);

            // Startup info
            memset(&startupInfo, 0, sizeof(startupInfo));
            startupInfo.cb = sizeof( startupInfo );
            startupInfo.wShowWindow = SW_HIDE;
            startupInfo.dwFlags = STARTF_USESHOWWINDOW;

            // Create command line
            WsbAffirmHr(cmdParams.Alloc(wcslen(stringId) + 40));
            swprintf(cmdParams, OLESTR(" recreate -i %ls -c %lu"), (WCHAR *)stringId, CopySetNumber);
            WsbAffirmHr(cmdLine.Alloc(MAX_PATH + wcslen(WSB_FACILITY_LAUNCH_NAME) + wcslen(cmdParams) + 10));
            WsbAffirmStatus(GetSystemDirectory(cmdLine, MAX_PATH));
            WsbAffirmHr(cmdLine.Append(OLESTR("\\")));
            WsbAffirmHr(cmdLine.Append(WSB_FACILITY_LAUNCH_NAME));
            WsbAffirmHr(cmdLine.Append(cmdParams));

            // Run the RsLaunch process
            WsbAffirmStatus(CreateProcess(NULL, cmdLine, NULL, NULL, FALSE, NULL, NULL, NULL, 
                                            &startupInfo, &exeInfo));

            // Cleanup
            CloseHandle(exeInfo.hProcess);
            CloseHandle(exeInfo.hThread);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaRecreateMaster"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
MediaDelete(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN DWORD  CopySetNumber
)
/*++

Routine Description:

    Deletes the specified copy for all given (master) medias

Arguments:

    MediaNames      -   The list of media to delete a copy for
    NumberOfMedia   -   Number of medias in the set
    CopySetNumber   -   Which copy to delete

Return Value:

    S_OK            - If the media copy is deleted successfully for all medias

Notes:

    1. MediaNames could point tp a "*" string for enumerating all medias. NumberOfMedia should be 1 then.
    2. If a certain copy doesn't exist for a certain media, we report but not abort.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("MediaDelete"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;
        CComPtr<IRmsServer>     pRms;
        CComPtr<IMediaInfo>     pMediaInfo;
        GUID                    mediaSubsystemId;

        // Get HSM server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

        // Verify that input parameters are valid
        if ((NULL == MediaNames) || (0 == NumberOfMedia)) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(CopySetNumber, IDS_MEDIA_COPY_SET, HSMADMIN_MIN_COPY_SETS + 1, HSMADMIN_MAX_COPY_SETS));
        hr = IsCopySetValid(pHsm, CopySetNumber);
        if (S_FALSE == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_IVALID_COPY_SET, NULL);
            WsbThrow(E_INVALIDARG);
        } else {
            WsbAffirmHr(hr);
        }

        // Get RMS server
        WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));

        // Initialize an enumerator object
        CMediaEnum mediaEnum(MediaNames, NumberOfMedia);

        hr = mediaEnum.First(&pMediaInfo);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Delete a copy
            WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId((USHORT)CopySetNumber, &mediaSubsystemId));
            if (GUID_NULL == mediaSubsystemId) {
                // No such copy - report and continue
                int index;
                mediaEnum.ErrorMedia(&index);
                if (CMEDIA_INVALID_INDEX != index) {
                    // Input from user - report
                    WCHAR copyStr[6];
                    swprintf(copyStr, OLESTR("%u"), (USHORT)CopySetNumber);
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_NO_COPY, copyStr, MediaNames[index], NULL);
                } 
            } else {
                // We don't expect to get here RMS_E_CARTRIDGE_NOT_FOUND 
                //  because this has already been tested by the enumerator
                WsbAffirmHr(pRms->RecycleCartridge(mediaSubsystemId, 0));

                // Delete from the table
                WsbAffirmHr(pMediaInfo->DeleteCopy((USHORT)CopySetNumber));
                WsbAffirmHr(pMediaInfo->Write());
            }

            pMediaInfo = 0;
            hr = mediaEnum.Next(&pMediaInfo);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaDelete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
MediaShow(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN BOOL   Name,
   IN BOOL   Status,
   IN BOOL   Capacity,
   IN BOOL   FreeSpace,
   IN BOOL   Version,
   IN BOOL   Copies
)
/*++

Routine Description:

    Shows (prints to stdout) given media(s) parameters

Arguments:

    MediaNames      -   The list of media to show parameters for
    NumberOfMedia   -   Number of medias in the set
    Name            -   Media display name
    Status          -   HSM status of the media (i.e. - Healthy, Read-Only, etc.)
    Capacity,       -   Media capacity (in GB)
    FreeSpace       -   Amount of free space left on the media (in GB)
    Version         -   Last update date for that media
    Copies          -   Number of existing copies and the status of each copy

Return Value:

    S_OK            - If all the parameters could be retrieved for all medias

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("MediaShow"), OLESTR(""));

    try {
        CComPtr<IMediaInfo>     pMediaInfo;

        // Verify that input parameters are valid
        if ((NULL == MediaNames) || (0 == NumberOfMedia)) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Initialize an enumerator object
        CMediaEnum mediaEnum(MediaNames, NumberOfMedia);

        hr = mediaEnum.First(&pMediaInfo);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Show parameters
            WsbAffirmHr(ShowMediaParams(pMediaInfo, Name, Status, Capacity, 
                                        FreeSpace, Version, Copies));

            pMediaInfo = 0;
            hr = mediaEnum.Next(&pMediaInfo);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Enumerator class methods
//

CMediaEnum::CMediaEnum(IN LPWSTR *pMediaNames, IN DWORD dwNumberOfMedia)
/*++

Routine Description:

    Constructor

Arguments:

    pMediaNames         - Medias to enumerate
    dwNumberOfMedia     - Number of medias

Return Value:

    None

Notes:
    There are two kinds of enumerations:
    1) If * is specified, the base for the enumeration is the Engine media (DB) table
       In that case, there could be no error in the input media names themselves
    2) If a list of media names is given, the base for the enumeration is this list. This is
       less efficient that using the Engine media table, but it keeps the order of medias
       according to the input list. If a media name from the list is not valid, the invalid flag is set.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaEnum::CMediaEnum"), OLESTR(""));

    try {
        m_pMediaNames = pMediaNames; 
        m_dwNumberOfMedia = dwNumberOfMedia;

        m_nCurrent = CMEDIA_INVALID_INDEX;
        m_bInvalidMedia = FALSE;
        m_bAllMedias = FALSE;

        // Check mode of enumeration
        WsbAssert(dwNumberOfMedia > 0, E_INVALIDARG);
        if ((1 == dwNumberOfMedia) && (0 == wcscmp(m_pMediaNames[0], CLI_ALL_STR))) {
            // * enumeration
            m_bAllMedias = TRUE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaEnum::CMediaEnum"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

CMediaEnum::~CMediaEnum( )
/*++

Routine Description:

    Destructor - free DB resources

Arguments:

    None

Return Value:

    None

--*/
{
    WsbTraceIn(OLESTR("CMediaEnum::~CMediaEnum"), OLESTR(""));

    // Release the entity first
    if( m_pMediaInfo ) {
        m_pMediaInfo = 0;
    }

    // Close the DB
    if( m_pDb ) {
        m_pDb->Close(m_pDbSession);
    }

    // m_pDb & m_pDbSession are released when the object terminates

    WsbTraceOut(OLESTR("CMediaEnum::~CMediaEnum"), OLESTR(""));
}

HRESULT CMediaEnum::First(OUT IMediaInfo **ppMediaInfo)
/*++

Routine Description:

    Gets first media

Arguments:

    ppMediaInfo     - First media info record to get

Return Value:

    S_OK            - If first media is retrieved
    WSB_E_NOTFOUND  - If no more medias to enumerate
    E_INVALIDARG    - If media name given by the user is not found
                      (Only on a non * enumeration, m_bInvalidMedia is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaEnum::First"), OLESTR(""));

    try {
        // Open database and get a session for the enumeration (only once during the object life time)
        if (!m_pDb) {
            CComPtr<IHsmServer> pHsm;
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

            WsbAffirmHr(pHsm->GetSegmentDb(&m_pDb));
            WsbAffirmHr(m_pDb->Open(&m_pDbSession));
            WsbAffirmHr(m_pDb->GetEntity(m_pDbSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, (void**)&m_pMediaInfo));
        }

        // Enumerate
        if (m_bAllMedias) {
            // Get first media in the table
            WsbAffirmHr(m_pMediaInfo->First());

            // Validate media, if it's not valid, continue until we find a valid one
            // If no valid media is found, the loop terminates by throwing WSB_E_NOTFOUND by the Next method
            HRESULT hrValid = IsMediaValid(m_pMediaInfo);
            while (S_OK != hrValid) {
                WsbAffirmHr(m_pMediaInfo->Next());
                hrValid = IsMediaValid(m_pMediaInfo);
            }
        
            // Found a valid media
            *ppMediaInfo = m_pMediaInfo;
            (*ppMediaInfo)->AddRef();

        } else {
            CWsbStringPtr           mediaDescription;

            // Enumerate user collection and try to find it in the table
            m_nCurrent = 0;
            if (m_nCurrent >= (int)m_dwNumberOfMedia) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Find it
            hr = m_pMediaInfo->First();
            while(S_OK == hr) {
                WsbAffirmHr(m_pMediaInfo->GetDescription(&mediaDescription, 0));
                if (_wcsicmp(m_pMediaNames[m_nCurrent], mediaDescription) == 0) {
                    // Fount it !!
                    *ppMediaInfo = m_pMediaInfo;
                    (*ppMediaInfo)->AddRef();

                    // Validate media
                    if (S_OK != IsMediaValid(m_pMediaInfo)) {
                        // Return an error indication
                        m_bInvalidMedia = TRUE;
                        hr = E_INVALIDARG;
                        WsbThrow(hr);
                    }

                    break;
                }

                mediaDescription.Free();
                hr = m_pMediaInfo->Next();
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Media given by user not found
                m_bInvalidMedia = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaEnum::First"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CMediaEnum::Next(OUT IMediaInfo **ppMediaInfo)
/*++

Routine Description:

    Gets next media

Arguments:

    ppMediaInfo     - Next media info record to get

Return Value:

    S_OK            - If next media is retrieved
    WSB_E_NOTFOUND  - If no more medias to enumerate
    E_INVALIDARG    - If media name given by the user is not found
                      (Only on a non * enumeration, m_bInvalidMedia is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaEnum::Next"), OLESTR(""));

    try {
        // Enumerate
        if (m_bAllMedias) {
            // Get first media in the table
            WsbAffirmHr(m_pMediaInfo->Next());

            // Validate media, if it's not valid, continue until we find a valid one
            // If no valid media is found, the loop terminates by throwing WSB_E_NOTFOUND by the Next method
            HRESULT hrValid = IsMediaValid(m_pMediaInfo);
            while (S_OK != hrValid) {
                WsbAffirmHr(m_pMediaInfo->Next());
                hrValid = IsMediaValid(m_pMediaInfo);
            }
        
            // Found a valid media
            *ppMediaInfo = m_pMediaInfo;
            (*ppMediaInfo)->AddRef();

        } else {
            CWsbStringPtr           mediaDescription;

            // Enumerate user collection and try to find it in the table
            m_nCurrent++;
            if (m_nCurrent >= (int)m_dwNumberOfMedia) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Find it
            hr = m_pMediaInfo->First();
            while(S_OK == hr) {
                WsbAffirmHr(m_pMediaInfo->GetDescription(&mediaDescription, 0));
                if (_wcsicmp(m_pMediaNames[m_nCurrent], mediaDescription) == 0) {
                    // Fount it !!
                    *ppMediaInfo = m_pMediaInfo;
                    (*ppMediaInfo)->AddRef();

                    // Validate media
                    if (S_OK != IsMediaValid(m_pMediaInfo)) {
                        // Return an error indication
                        m_bInvalidMedia = TRUE;
                        hr = E_INVALIDARG;
                        WsbThrow(hr);
                    }

                    break;
                }

                mediaDescription.Free();
                hr = m_pMediaInfo->Next();
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Media given by user not found
                m_bInvalidMedia = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaEnum::Next"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Internal utilities
//

HRESULT IsMediaValid(IN IMediaInfo *pMediaInfo)
/*++

Routine Description:

    Checks with RMS unit (i.e. with RSM...) if the media is valid.
    The media could be gone if it was deallocated by the user for example
    Note: Currently, this utility does not check if media is enabled, online, etc -
          it just verifies that the media is still known to RSM.

Arguments:

    pMediaInfo      - Media record for media to check

Return Value:

    S_OK            - If media found in RSM
    S_FALSE         - If media is not found in RSM

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("IsMediaValid"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;
        CComPtr<IRmsServer>     pRms;
        CComPtr<IRmsCartridge>  pRmsCart;
        GUID mediaSubsystemId;

        WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaSubsystemId));
        WsbAffirm(GUID_NULL != mediaSubsystemId, S_FALSE);

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
        hr = pRms->FindCartridgeById(mediaSubsystemId, &pRmsCart);
        if (S_OK != hr) {
            // Media not found in RSM, don't care why
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("IsMediaValid"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT IsCopySetValid (IN IHsmServer *pHsm, IN DWORD dwCopySetNumber)
/*++

Routine Description:

    Checks with HSM (Engine) server that the speficied copy set number is within
    the configured copy set range.

Arguments:

    pHsm            - The HSM server to consult with
    dwCopySetNumber - The copy set number to check 

Return Value:

    S_OK            - If the copy set number is within range
    S_FALSE         - If the copy set number is out of range

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("IsCopySetValid"), OLESTR(""));

    try {
        CComPtr<IHsmStoragePool> pStoragePool;
        CComPtr<IWsbIndexedCollection> pCollection;
        ULONG count;
        USHORT numCopies;

        // Get the storage pools collection.  There should only be one member.
        WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
        WsbAffirmHr(pCollection->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));

        // Get and check number of configured copy sets
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pStoragePool->GetNumMediaCopies(&numCopies));
        if ((USHORT)dwCopySetNumber > numCopies) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("IsCopySetValid"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT ShowMediaParams(IN IMediaInfo *pMediaInfo, BOOL bName, IN BOOL bStatus, IN BOOL bCapacity,
                        IN BOOL bFreeSpace, IN BOOL bVersion, IN BOOL bCopies)
/*++

Routine Description:

    Shows (prints to stdout) media parameters

Arguments:

    pMediaInfo      -   Media record
    bName           -   Media display name
    bStatus         -   HSM status of the media (i.e. - Healthy, Read-Only, etc.)
    bCapacity,      -   Media capacity (in GB)
    bFreeSpace      -   Amount of free space left on the media (in GB)
    bVersion        -   Last update date for that media
    bCopies         -   Number of existing copies and the status of each copy

Return Value:

    S_OK            - If all the parameters could be displayed for the input media

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("ShowMediaParams"), OLESTR(""));

    try {
        CWsbStringPtr       param;
        CWsbStringPtr       data;
        WCHAR               longData[100];

        CWsbStringPtr       mediaDescription;
        GUID                mediaSubsystemId;
        LONGLONG            lCapacity, lFreeSpace;
        FILETIME            ftVersion;
        BOOL                bReadOnly, bRecreate;
        SHORT               nNextDataSet;
        HRESULT             hrLast;

        CWsbStringPtr       unusedName;
        GUID                unusedGuid1;
        GUID                unusedGuid2;
        HSM_JOB_MEDIA_TYPE  unusedType;
        LONGLONG            unusedLL1;

        // Get parameters - it is better to get them all at once even if we don't have to display everything
        WsbAffirmHr(pMediaInfo->GetMediaInfo(&unusedGuid1, &mediaSubsystemId, &unusedGuid2, 
                        &lFreeSpace, &lCapacity, &hrLast, &nNextDataSet, &mediaDescription, 0,
                        &unusedType, &unusedName, 0, &bReadOnly, &ftVersion, &unusedLL1, &bRecreate));

        WsbTraceAndPrint(CLI_MESSAGE_MEDIA_PARAMS, (WCHAR *)mediaDescription, NULL);

        // TEMPORARY: For showing most of these parameters, UI utilities and strings are duplicated
        //            To avoid that, general media utilities should be moved from rsadutil.cpp to Wsb unit
        //            and relevant strings should be moved from HsmAdmin DLL to RsCommon DLL


        // Name
        if (bName) {
            CComPtr<IHsmServer>     pHsm;
            CComPtr<IRmsServer>     pRms;
            CComPtr<IRmsCartridge>  pRmsCart;
            CWsbBstrPtr             rsmName;

                // Get RSM name
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
            WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
            WsbAffirmHr(pRms->FindCartridgeById(mediaSubsystemId, &pRmsCart));
            WsbAffirmHr(pRmsCart->GetName(&rsmName));
            if (wcscmp(rsmName, OLESTR("")) == 0 ) {
                rsmName.Free();
                WsbAffirmHr(rsmName.LoadFromRsc(g_hInstance, IDS_CAR_NAME_UNKNOWN));
            }

            // Print
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_RSM_NAME));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)(BSTR)rsmName, NULL);
        }

        // Status
        if (bStatus) {
            SHORT   nLastGoodNextDataSet;
            ULONG   resId;

            // Get more relevant status info
            WsbAffirmHr(pMediaInfo->GetLKGMasterNextRemoteDataSet(&nLastGoodNextDataSet));

            // Compute status 
            if (bRecreate) {
                resId = IDS_CAR_STATUS_RECREATE;
            } else if (nNextDataSet < nLastGoodNextDataSet) {
                resId = IDS_CAR_STATUS_ERROR_INCOMPLETE;
            } else if (SUCCEEDED(hrLast) || (RMS_E_CARTRIDGE_DISABLED == hrLast)) {
                resId = (bReadOnly ? IDS_CAR_STATUS_READONLY : IDS_CAR_STATUS_NORMAL);
            } else if (RMS_E_CARTRIDGE_NOT_FOUND == hrLast) {
                resId = IDS_CAR_STATUS_ERROR_MISSING;
            } else {
                resId = (bReadOnly ? IDS_CAR_STATUS_ERROR_RO : IDS_CAR_STATUS_ERROR_RW);
            }

            // Print
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_STATUS));
            WsbAffirmHr(data.LoadFromRsc(g_hInstance, resId));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);
        }

        // Capacity
        if (bCapacity) {
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_CAPACITY));
            WsbAffirmHr(ShortSizeFormat64(lCapacity, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }
        
        // Free Space
        if (bFreeSpace) {
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_FREE_SPACE));
            WsbAffirmHr(ShortSizeFormat64(lFreeSpace, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

        // Version
        if (bVersion) {
            data.Free();
            WsbAffirmHr(FormatFileTime(ftVersion, &data));
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_VERSION));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);
        }

        // Media copies information
        if (bCopies) {
            GUID        copySubsystemId;
            HRESULT     copyLastHr;
            SHORT       copyNextRemoteDataSet, lastGoodNextDataSet;
            ULONG       resId;

            WsbTraceAndPrint(CLI_MESSAGE_MEDIA_COPIES_LIST, NULL);
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_COPY));

            WsbAffirmHr(pMediaInfo->GetLKGMasterNextRemoteDataSet(&lastGoodNextDataSet));

            for (USHORT copyNo=1; copyNo<=HSMADMIN_MAX_COPY_SETS; copyNo++) {
                // Get copy status information
                WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copyNo, &copySubsystemId));
                WsbAffirmHr(pMediaInfo->GetCopyLastError(copyNo, &copyLastHr));
                WsbAffirmHr(pMediaInfo->GetCopyNextRemoteDataSet(copyNo, &copyNextRemoteDataSet));

                // Compute status
                switch(copyLastHr) {
                    case RMS_E_CANCELLED:
                    case RMS_E_REQUEST_REFUSED:
                    case RMS_E_WRITE_PROTECT:
                    case RMS_E_MEDIA_OFFLINE:
                    case RMS_E_TIMEOUT:
                    case RMS_E_SCRATCH_NOT_FOUND:
                    case RMS_E_CARTRIDGE_UNAVAILABLE:
                    case RMS_E_CARTRIDGE_DISABLED:
                        copyLastHr = S_OK;
                        break;

                }

                if (copySubsystemId == GUID_NULL) {
                    resId = IDS_CAR_COPYSET_NONE;
                } else if (RMS_E_CARTRIDGE_NOT_FOUND == copyLastHr) {
                    resId = IDS_CAR_COPYSET_MISSING;
                } else if (FAILED(copyLastHr)) {
                    resId = IDS_CAR_COPYSET_ERROR;
                } else if (copyNextRemoteDataSet < lastGoodNextDataSet) {
                    resId = IDS_CAR_COPYSET_OUTSYNC;
                } else {
                    resId = IDS_CAR_COPYSET_INSYNC;
                }

                // Print
                swprintf(longData, param, (int)copyNo);
                WsbAffirmHr(data.LoadFromRsc(g_hInstance, resId));
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, longData, (WCHAR *)data, NULL);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("ShowMediaParams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\cliadmin.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliadmin.cpp

Abstract:

    Implements CLI ADMIN sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "engine.h"
#include "rsstrdef.h"
#include "mstask.h"

static GUID g_nullGuid = GUID_NULL;

// Internal utilities and classes for VOLUME interface
HRESULT DisplayServiceStatus(void);
HRESULT IsHsmInitialized(IN IHsmServer *pHsm);

HRESULT
AdminSet(
   IN DWORD RecallLimit,
   IN DWORD AdminExempt,
   IN DWORD MediaCopies,
   IN DWORD Concurrency,
   IN PVOID Schedule
)
/*++

Routine Description:

    Sets Remote Storage general parameters

Arguments:

    RecallLimit     - The runaway recall limit to set
    AdminExempt     - Whether to set administrators exempt for the recall limit
    MediaCopies     - Number of media copy sets 
    Concurrency     - How many migrate jobs/recalls can be executed concurrently
    Schedule        - The schedule for the global migration ("Manage") job of all managed volumes 

Return Value:

    S_OK            - If all the parameters are set successfully

Notes:
    The scheduling implementation of HSM (in the Engine) allows only one scheduling
    for the global Manage job. The scheduling given here overrides any former scheduling.
    However, the user can add another scheduling to the same task using the Task Scheduler UI.
    Enabling that via HSM, requires changing the CHsmServer::CreateTaskEx implementation

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("AdminSet"), OLESTR(""));

    try {
        CWsbStringPtr   param;

        // Verify that input parameters are valid
        WsbAffirmHr(ValidateLimitsArg(RecallLimit, IDS_RECALL_LIMIT, HSMADMIN_MIN_RECALL_LIMIT, INVALID_DWORD_ARG));
        WsbAffirmHr(ValidateLimitsArg(MediaCopies, IDS_MEDIA_COPIES_PRM, HSMADMIN_MIN_COPY_SETS, HSMADMIN_MAX_COPY_SETS));
        WsbAffirmHr(ValidateLimitsArg(Concurrency, IDS_CONCURRENCY_PRM, HSMADMIN_MIN_CONCURRENT_TASKS, INVALID_DWORD_ARG));

        // Set parameters, if an error occurs we abort
        if ((INVALID_DWORD_ARG != RecallLimit) || (INVALID_DWORD_ARG != AdminExempt)) {
            // Need Fsa server and Fsa filter here
            CComPtr<IFsaServer> pFsa;
            CComPtr<IFsaFilter> pFsaFilter;

            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));
            WsbAffirmHr(pFsa->GetFilter( &pFsaFilter));

            // Recall limit
            if (INVALID_DWORD_ARG != RecallLimit) {
                WsbAffirmHr(pFsaFilter->SetMaxRecalls(RecallLimit));
            }

            // Admin exempt
            if (INVALID_DWORD_ARG != AdminExempt) {
                BOOL bAdminExempt = (0 == AdminExempt) ? FALSE : TRUE;
                WsbAffirmHr(pFsaFilter->SetAdminExemption(bAdminExempt));
            }
        }

        if ( (INVALID_DWORD_ARG != MediaCopies) || (INVALID_DWORD_ARG != Concurrency) ||
             (INVALID_POINTER_ARG != Schedule) ) {
            // Need Hsm server
            CComPtr<IHsmServer> pHsm;

            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

            // Concurrency
            if (INVALID_DWORD_ARG != Concurrency) {
                WsbAffirmHr(pHsm->SetCopyFilesUserLimit(Concurrency));
            }

            // Media copies
            if (INVALID_DWORD_ARG != MediaCopies) {
                CComPtr<IHsmStoragePool> pStoragePool;
                CComPtr<IWsbIndexedCollection> pCollection;
                ULONG count;

                // Get the storage pools collection.  There should only be one member.
                WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
                WsbAffirmHr(pCollection->GetEntries(&count));
                WsbAffirm(1 == count, E_FAIL);
                WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));

                WsbAffirmHr(pStoragePool->SetNumMediaCopies((USHORT)MediaCopies));
            }

            // Scheduling
            if (INVALID_POINTER_ARG != Schedule) {
                CWsbStringPtr       taskName, taskComment;
                TASK_TRIGGER_TYPE   taskType;
                PHSM_JOB_SCHEDULE   pSchedule = (PHSM_JOB_SCHEDULE)Schedule;
                SYSTEMTIME          runTime;
                DWORD               runOccurrence;

                // Set default valuess
                GetSystemTime(&runTime);
                runOccurrence = 0;

                // Set input
                switch (pSchedule->Frequency) {
                    case Daily:
                        taskType = TASK_TIME_TRIGGER_DAILY;
                        runTime = pSchedule->Parameters.Daily.Time;
                        runOccurrence = pSchedule->Parameters.Daily.Occurrence;
                        break;

                    case Weekly:
                        taskType = TASK_TIME_TRIGGER_WEEKLY;
                        runTime = pSchedule->Parameters.Weekly.Time;
                        runOccurrence = pSchedule->Parameters.Weekly.Occurrence;
                        break;

                    case Monthly:
                        taskType = TASK_TIME_TRIGGER_MONTHLYDATE;
                        runTime = pSchedule->Parameters.Monthly.Time;
                        break;

                    case Once:
                        taskType = TASK_TIME_TRIGGER_ONCE;
                        runTime = pSchedule->Parameters.Once.Time;
                        break;

                    case WhenIdle:
                        taskType = TASK_EVENT_TRIGGER_ON_IDLE;
                        runOccurrence = pSchedule->Parameters.WhenIdle.Occurrence;
                        break;

                    case SystemStartup:
                        taskType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
                        break;

                    case Login:
                        taskType = TASK_EVENT_TRIGGER_AT_LOGON;
                        break;

                    default:
                        WsbThrow(E_INVALIDARG);
                }
                
                // Create the task with the new scheduling
                // Note: Task parameters should not be localized - this is a parameter for RsLaunch.exe
                WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &taskName));
                WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_COMMENT, &taskComment));
                WsbAffirmHr(pHsm->CreateTaskEx(taskName, L"run manage", taskComment,
                                        taskType, runTime, runOccurrence, TRUE));
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("AdminSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

// Local structure for AdminShow
typedef struct _FSA_VOLUME_DATA {
    WCHAR   *Name;
    BOOL    Managed; 
} FSA_VOLUME_DATA, *PFSA_VOLUME_DATA;

#define DATA_ALLOC_SIZE     10

HRESULT
AdminShow(
   IN BOOL RecallLimit,
   IN BOOL AdminExempt,
   IN BOOL MediaCopies,
   IN BOOL Concurrency,
   IN BOOL Schedule,
   IN BOOL General,
   IN BOOL Manageables,
   IN BOOL Managed,
   IN BOOL Media
)
/*++

Routine Description:

    Shows (prints to stdout) Remote Storage general parameters

Arguments:

    RecallLimit     - The runaway recall limit
    AdminExempt     - Whether administrators are exempt from the recall limit
    MediaCopies     - Number of media copy sets 
    Concurrency     - How many migrate jobs/recalls can be executed concurrently
    Schedule        - The schedule for the global migration ("Manage") job of all managed volumes 
    General         - General information: version, status, number of volumes managed, 
                      number of tape cartridges used, data in remote storage
    Manageables     - List of volumes that may be managed by HSM
    Managed         - List of volumes that are managed by HSM
    Media           - List of medias that are allocated to HSM

Return Value:

    S_OK            - If all the required parameters are printed successfully

Notes:
    The schedule is printed in a form of a list (like the volume list), not like a single parameter. 
    The reason is that a user can specify several schedules for the global Manage job.

--*/
{
    HRESULT                 hr = S_OK;

    // Volume saved data
    PFSA_VOLUME_DATA        pVolumesData = NULL;
    ULONG                   volDataSize = 0;

    // Media save data
    BSTR*                   pMediasData = NULL;
    ULONG                   mediaDataSize = 0;
    CComPtr<IWsbDb>         pDb;
    CComPtr<IWsbDbSession>  pDbSession;

    WsbTraceIn(OLESTR("AdminShow"), OLESTR(""));

    try {
        CComPtr<IFsaServer> pFsa;
        CComPtr<IHsmServer> pHsm;
        CWsbStringPtr       param;
        CWsbStringPtr       data;
        WCHAR               longData[100];
        LPVOID              pTemp;

        // Volume data
        LONGLONG            dataInStorage = 0;
        ULONG               manageableCount = 0;
        ULONG               managedCount = 0;

        // Media data
        ULONG               mediaAllocated = 0;

        // Get required HSM servers
        if (RecallLimit || AdminExempt || Manageables || Managed || General) {
            // Need Fsa server
            hr = HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa);
            if (S_OK != hr) {
                // Just print status before aborting
                if (General) {
                    DisplayServiceStatus();
                }
            }
            WsbAffirmHr(hr);
        }
        if (MediaCopies || Concurrency || General || Media) {
            // Need Hsm (Engine) server
            hr = HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm);
            if (S_OK != hr) {
                // Just print status before aborting
                if (General) {
                    DisplayServiceStatus();
                }
            }
            WsbAffirmHr(hr);
        }

        //
        // Get basic information required according to the input settings
        //

        // Volumes data
        if (General || Manageables || Managed) {
            // Need to collect volumes information
            CComPtr<IWsbEnum> pEnum;
            CComPtr<IFsaResource> pResource;
            HRESULT hrEnum;
            BOOL    bManaged;

            LONGLONG    totalSpace  = 0;
            LONGLONG    freeSpace   = 0;
            LONGLONG    premigrated = 0;
            LONGLONG    truncated   = 0;
            LONGLONG    totalPremigrated = 0;
            LONGLONG    totalTruncated = 0;


            WsbAffirmHr(pFsa->EnumResources(&pEnum));
            hrEnum = pEnum->First(IID_IFsaResource, (void**)&pResource);
            WsbAffirm((S_OK == hrEnum) || (WSB_E_NOTFOUND == hrEnum), hrEnum);

            if (Manageables || Managed) {
                volDataSize = DATA_ALLOC_SIZE;
                pVolumesData = (PFSA_VOLUME_DATA)WsbAlloc(volDataSize * sizeof(FSA_VOLUME_DATA));
                WsbAffirm(0 != pVolumesData, E_OUTOFMEMORY);
            }

            while(S_OK == hrEnum) {
                // Don't count or display unavailable volumes
                if (S_OK != pResource->IsAvailable()) {
                    goto skip_volume;
                }

                bManaged = (pResource->IsManaged() == S_OK);

                if (Manageables) {
                    if (volDataSize == manageableCount) {
                        volDataSize += DATA_ALLOC_SIZE;
                        pTemp = WsbRealloc(pVolumesData, volDataSize * sizeof(FSA_VOLUME_DATA));
                        WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                        pVolumesData = (PFSA_VOLUME_DATA)pTemp;
                    }
                    pVolumesData[manageableCount].Name = NULL;
                    WsbAffirmHr(CliGetVolumeDisplayName(pResource, &(pVolumesData[manageableCount].Name)));
                    pVolumesData[manageableCount].Managed = bManaged;
                }

                manageableCount++;

                if(bManaged) {
                    if (General) {
                        WsbAffirmHr(pResource->GetSizes(&totalSpace, &freeSpace, &premigrated, &truncated));
                        totalPremigrated += premigrated;
                        totalTruncated += truncated;
                    }

                    if (Managed && (!Manageables)) {
                        // Collect data only for managed volumes
                        if (volDataSize == managedCount) {
                            volDataSize += DATA_ALLOC_SIZE;
                            pTemp = WsbRealloc(pVolumesData, volDataSize * sizeof(FSA_VOLUME_DATA));
                            WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                            pVolumesData = (PFSA_VOLUME_DATA)pTemp;
                        }

                        pVolumesData[managedCount].Name = NULL;
                        WsbAffirmHr(CliGetVolumeDisplayName(pResource, &(pVolumesData[managedCount].Name)));
                        pVolumesData[managedCount].Managed = TRUE;
                    }

                    managedCount++;
                }

skip_volume:
                // Prepare for next iteration
                pResource = 0;
                hrEnum = pEnum->Next( IID_IFsaResource, (void**)&pResource );
            }
            if (Manageables) {
                volDataSize = manageableCount;
            } else if (Managed) {
                volDataSize = managedCount;
            }

            if (General) {
                dataInStorage = totalPremigrated + totalTruncated;
            }
        }

        // Medias data
        if (General || Media) {
            CComPtr<IMediaInfo>     pMediaInfo;
            GUID                    mediaSubsystemId;
            CComPtr<IRmsServer>     pRms;
            CComPtr<IRmsCartridge>  pRmsCart;
            HRESULT                 hrFind;

            WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
            WsbAffirmHr(pHsm->GetSegmentDb(&pDb));
            WsbAffirmHr(pDb->Open(&pDbSession));
            WsbAffirmHr(pDb->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE,  IID_IMediaInfo, (void**)&pMediaInfo));

            if (Media) {
                mediaDataSize = DATA_ALLOC_SIZE;
                pMediasData = (BSTR *)WsbAlloc(mediaDataSize * sizeof(BSTR));
                WsbAffirm(0 != mediaDataSize, E_OUTOFMEMORY);
            }

            for (hr = pMediaInfo->First(); S_OK == hr; hr = pMediaInfo->Next()) {
                WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaSubsystemId));
                hrFind = pRms->FindCartridgeById(mediaSubsystemId, &pRmsCart);
                if (S_OK == hrFind) {  // Otherwise, the media is not valid anymore, it could have been deallocated
                    if (Media) {
                        if (mediaDataSize == mediaAllocated) {
                            mediaDataSize += DATA_ALLOC_SIZE;
                            pTemp = WsbRealloc(pMediasData, mediaDataSize * sizeof(BSTR));
                            WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                            pMediasData = (BSTR *)pTemp;
                        }

                        pMediasData[mediaAllocated] = NULL;
                        WsbAffirmHr(pRmsCart->GetName(&(pMediasData[mediaAllocated])));
                        if ( (NULL == pMediasData[mediaAllocated]) || 
                             (0 == wcscmp(pMediasData[mediaAllocated], OLESTR(""))) ) {
                            // Try decsription
                            if (NULL != pMediasData[mediaAllocated]) {
                                WsbFreeString(pMediasData[mediaAllocated]);
                            }

                            WsbAffirmHr(pRmsCart->GetDescription(&(pMediasData[mediaAllocated])));
                        }

                    }

                    mediaAllocated++;
                    pRmsCart = 0;
                }
            }
            if (Media) {
                mediaDataSize = mediaAllocated;
            }
            hr = S_OK;

            if(pDb) {
                pDb->Close(pDbSession);
                pDb = 0;
            }
        }

        //
        // Print parameters
        //

        // General parameters
        if (General) {
            WsbTraceAndPrint(CLI_MESSAGE_GENERAL_PARMS, NULL);

            // Status
            WsbAffirmHr(DisplayServiceStatus());

            // Manageable && Managed
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOF_MANAGEABLES));
            swprintf(longData, OLESTR("%lu"), manageableCount);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOF_MANAGED));
            swprintf(longData, OLESTR("%lu"), managedCount);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            // Tapes
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOF_CARTRIDGES));
            swprintf(longData, OLESTR("%lu"), mediaAllocated);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            // Data in RS
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_REMOTE_DATA));
            WsbAffirmHr(ShortSizeFormat64(dataInStorage, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            // Version
            {
                CComPtr<IWsbServer>     pWsbHsm;
                CWsbStringPtr           ntProductVersionHsm;
                ULONG                   ntProductBuildHsm;
                ULONG                   buildVersionHsm;

                WsbAffirmHr(pHsm->QueryInterface(IID_IWsbServer, (void **)&pWsbHsm));
                WsbAffirmHr(pWsbHsm->GetNtProductBuild(&ntProductBuildHsm));
                WsbAffirmHr(pWsbHsm->GetNtProductVersion(&ntProductVersionHsm, 0));
                WsbAffirmHr(pWsbHsm->GetBuildVersion(&buildVersionHsm));

                WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_HSM_VERSION));
                WsbAffirmHr(data.Realloc(wcslen(ntProductVersionHsm) + 30));
                swprintf(data, L"%ls.%d [%ls]", (WCHAR*)ntProductVersionHsm, ntProductBuildHsm, RsBuildVersionAsString(buildVersionHsm));
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);
            }
        }

        // Manageable volumes
        if (Manageables) {
            WsbTraceAndPrint(CLI_MESSAGE_MANAGEABLE_VOLS, NULL);

            for (ULONG i=0; i<volDataSize; i++) {
                if (pVolumesData[i].Name) {
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, pVolumesData[i].Name, NULL);
                }
            }
        }

        // Managed volumes
        if (Managed) {
            WsbTraceAndPrint(CLI_MESSAGE_MANAGED_VOLS, NULL);

            for (ULONG i=0; i<volDataSize; i++) {
                if (pVolumesData[i].Name && pVolumesData[i].Managed) {
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, pVolumesData[i].Name, NULL);
                }
            }
        }

        // Allocated Medias
        if (Media) {
            WsbTraceAndPrint(CLI_MESSAGE_MEDIAS, NULL);

            for (ULONG i=0; i<mediaDataSize; i++) {
                if (NULL != pMediasData[i]) {
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, (WCHAR *)pMediasData[i], NULL);
                }
            }
        }

        // Schedule
        if (Schedule) {
            // Use Task Scheduler objects to get the data
            CComPtr<ISchedulingAgent>   pSchedAgent;
            CComPtr<ITask>              pTask;
            CWsbStringPtr               manageJobName;

            // Initialize scheduling agent
            WsbAffirmHr(CoCreateInstance(CLSID_CSchedulingAgent, 0, CLSCTX_SERVER, IID_ISchedulingAgent, (void **)&pSchedAgent));
            pSchedAgent->SetTargetComputer(NULL); // local machine

            // Get the relevant task
            WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &manageJobName));
            hr = pSchedAgent->Activate(manageJobName, IID_ITask, (IUnknown**)&pTask);
            if (E_INVALIDARG == hr) {
                // Print no scheduling message (Manage job is not found as a scheduled task)
                WsbTraceAndPrint(CLI_MESSAGE_NO_SCHEDULING, NULL);
                hr = S_OK;

            } else if (S_OK == hr) {
                // Get scheduling strings and print
                WORD wTriggerCount;
                WsbAffirmHr(pTask->GetTriggerCount(&wTriggerCount));
                if (wTriggerCount == 0) {
                    WsbTraceAndPrint(CLI_MESSAGE_NO_SCHEDULING, NULL);
                } else {
                    WsbTraceAndPrint(CLI_MESSAGE_SCHEDULING_LIST, NULL);
                }
                for (WORD triggerIndex = 0; triggerIndex < wTriggerCount; triggerIndex++) {
                    WCHAR *pTriggerString = NULL;
                    WsbAffirmHr(pTask->GetTriggerString(triggerIndex, &pTriggerString));

                    // Print
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, pTriggerString, NULL);

                    CoTaskMemFree(pTriggerString);
                }

            } else {
                WsbAffirmHr(hr);
            }
        }

        // Limits and Media Copies
        if (RecallLimit || AdminExempt) {
            // Need Fsa filter here
            CComPtr<IFsaFilter> pFsaFilter;
            WsbAffirmHr(pFsa->GetFilter(&pFsaFilter));

            if (RecallLimit) {
                ULONG maxRecalls;
                WsbAffirmHr(pFsaFilter->GetMaxRecalls(&maxRecalls));
                WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_RECALL_LIMIT));
                swprintf(longData, OLESTR("%lu"), maxRecalls);
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
            }

            if (AdminExempt) {
                BOOL adminExempt;
                WsbAffirmHr(pFsaFilter->GetAdminExemption(&adminExempt));
                WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_ADMIN_EXEMPT));
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, WsbBoolAsString(adminExempt), NULL);
            }
        }

        if (Concurrency) {
            ULONG concurrentTasks;
            WsbAffirmHr(pHsm->GetCopyFilesUserLimit(&concurrentTasks));
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_CONCURRENCY));
            swprintf(longData, OLESTR("%lu"), concurrentTasks);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

        if (MediaCopies) {
            CComPtr<IHsmStoragePool> pStoragePool;
            CComPtr<IWsbIndexedCollection> pCollection;
            ULONG count;
            USHORT numCopies;

            // Get the storage pools collection.  There should only be one member.
            WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
            WsbAffirmHr(pCollection->GetEntries(&count));
            WsbAffirm(1 == count, E_FAIL);
            WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
            WsbAffirmHr(pStoragePool->GetNumMediaCopies(&numCopies));

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_COPIES));
            swprintf(longData, OLESTR("%ld"), (int)numCopies);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

    } WsbCatchAndDo(hr,
            if(pDb) {
                pDb->Close(pDbSession);
                pDb = 0;
            }
        );

    // Free stored data
    if (pVolumesData) {
        for (ULONG i=0; i<volDataSize; i++) {
            if (pVolumesData[i].Name) {
                WsbFree(pVolumesData[i].Name);
            }
        }
        WsbFree(pVolumesData);
        pVolumesData = NULL;
    }

    if (pMediasData) {
        for (ULONG i=0; i<mediaDataSize; i++) {
            if (NULL != pMediasData[i]) {
                WsbFreeString(pMediasData[i]);
            }
        }
        WsbFree(pMediasData);
        pMediasData = NULL;
    }

    WsbTraceOut(OLESTR("AdminShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Internal utilities
//
HRESULT DisplayServiceStatus(void)
/*++

Routine Description:

    Displays HSM service status. 

Arguments:

    None

Return Value:

    S_OK            - If status is retrieved and displayed succeessfully

Notes:
    The function handle cases such as the service not runnig, pending, not initialized, etc.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("DisplayServiceStatus"), OLESTR(""));

    try {
        CWsbStringPtr   param, data;
        ULONG           statusId = INVALID_DWORD_ARG; 
        DWORD           serviceStatus;
        HRESULT         hrService;

        hrService = WsbGetServiceStatus(NULL, APPID_RemoteStorageEngine, &serviceStatus);
        if (S_OK != hrService) {
            // HSM service not registered at all
            WsbTrace(OLESTR("DisplayServiceStatus: Got hr = <%ls> from WsbGetServiceStatus\n"), WsbHrAsString(hrService));
            statusId = IDS_SERVICE_STATUS_NOT_REGISTERED;
        } else {
            if (SERVICE_RUNNING == serviceStatus) {
                CComPtr<IHsmServer> pHsm;
                HRESULT             hrSetup;

                WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
                hrSetup = IsHsmInitialized(pHsm);
                if (S_FALSE == hrSetup) {
                    // HSM running but no initialized yet (Startup Wizard was not completed yet)
                    statusId = IDS_SERVICE_STATUS_NOT_SETUP;
                } else if (S_OK == hrSetup) {
                    // Service is running, life is good
                    statusId = IDS_SERVICE_STATUS_RUNNING;
                } else {
                    // Unexpected error
                    WsbAffirmHr(hrSetup);
                }
            } else {
                // Service is not running, set exact string according to status
                switch(serviceStatus) {
                    case SERVICE_STOPPED:
                        statusId = IDS_SERVICE_STATUS_STOPPED;
                        break;
                    case SERVICE_START_PENDING:
                        statusId = IDS_SERVICE_STATUS_START_PENDING;
                        break;
                    case SERVICE_STOP_PENDING:
                        statusId = IDS_SERVICE_STATUS_STOP_PENDING;
                        break;
                    case SERVICE_CONTINUE_PENDING:
                        statusId = IDS_SERVICE_STATUS_CONTINUE_PENDING;
                        break;
                    case SERVICE_PAUSE_PENDING:
                        statusId = IDS_SERVICE_STATUS_PAUSE_PENDING;
                        break;
                    case SERVICE_PAUSED:
                        statusId = IDS_SERVICE_STATUS_PAUSED;
                        break;
                    default:
                        WsbThrow(E_FAIL);
                }
            }
        }

        WsbAffirm(INVALID_DWORD_ARG != statusId, E_UNEXPECTED)
        WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_HSM_STATUS));
        WsbAffirmHr(data.LoadFromRsc(g_hInstance, statusId));
        WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("DisplayServiceStatus"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT IsHsmInitialized(IN IHsmServer *pHsm)
/*++

Routine Description:

    Check if HSM is initialized, i.e. if Startup wizard was completed successfully 

Arguments:

    pHsm            - The HSM server to check with

Return Value:

    S_OK            - HSM initialized
    S_FALSE         - HSM not initialized

--*/
{
    HRESULT                     hr = S_FALSE;

    WsbTraceIn(OLESTR("IsHsmInitialized"), OLESTR(""));

    try {
        GUID                            guid;
        CWsbBstrPtr                     poolName;
        CComPtr<IWsbIndexedCollection>  pCollection;
        ULONG                           count;
        CComPtr<IHsmStoragePool>        pPool;

        WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
        WsbAffirmHr(pCollection->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pPool));

        WsbAffirmHr(pPool->GetMediaSet(&guid, &poolName));
        if(! IsEqualGUID(guid, GUID_NULL)) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("IsHsmInitialized"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT AdminJob(IN BOOL Enable)
/*++

Routine Description:

    Enable/Disable HSM jobs

Arguments:

    None

Return Value:

    S_OK                        - Success
    HSM_E_DISABLE_RUNNING_JOBS  - Returned by Engine when trying to disbale jobs 
                                  while jobs are running
    Other                       - Other unexpected error

--*/
{
    HRESULT                     hr = S_FALSE;

    WsbTraceIn(OLESTR("AdminJob"), OLESTR(""));

    try {
        CComPtr<IHsmServer> pHsm;

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        if (Enable) {
            hr = pHsm->EnableAllJobs();
        } else {
            hr = pHsm->DisableAllJobs();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("AdminJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\cliparse.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliparse.h

Abstract:

    Definitions for CLI parse module

Author:

    Ravisankar Pudipeddi   [ravisp]  21-March-2000

Revision History:

--*/
#ifndef _CLIPARSE_H_
#define _CLIPARSE_H_
//
// Return codes from main()
//
#define     CLIP_ERROR_SUCCESS              0
#define     CLIP_ERROR_INVALID_PARAMETER    1

#define     CLIP_ERROR_INSUFFICIENT_MEMORY  2
#define     CLIP_ERROR_UNKNOWN              0xFF

//
// Token separators on command line
//
#define SEPARATORS              L" \t\n"
//
// Delimiter which distinguishes a switch
//
#define SWITCH_DELIMITERS       L"/-"
//
// Argument separator for a switch
//
#define SWITCH_ARG_DELIMITERS    L":"

//
// Argument separator for a rule spec (distinguishes
// path from file spec)
//
#define RULE_DELIMITERS          L":"

//
// Quotes to delimit tokens with embedded whitespace
//
#define QUOTE                    L'\"'

//
// Rss command line interfaces
//
typedef enum _RSS_INTERFACE {
    UNKNOWN_IF = 0,
    ADMIN_IF,
    VOLUME_IF,
    FILE_IF,
    MEDIA_IF,
    HELP_IF,
    SHOW_IF,
    SET_IF,
    MANAGE_IF,
    UNMANAGE_IF,
    DELETE_IF,
    JOB_IF,
    RECALL_IF,
    SYNCHRONIZE_IF,
    RECREATEMASTER_IF
} RSS_INTERFACE, *PRSS_INTERFACE;

//
// All switches supported by the CLI
//
typedef enum _RSS_SWITCH_TYPE {
    UNKNOWN_SW = 0,
    RECALLLIMIT_SW,
    MEDIACOPIES_SW,
    SCHEDULE_SW,
    CONCURRENCY_SW,
    ADMINEXEMPT_SW,
    GENERAL_SW,
    MANAGEABLES_SW,
    MANAGED_SW,
    MEDIA_SW,
    DFS_SW,
    SIZE_SW,
    ACCESS_SW,
    INCLUDE_SW,
    EXCLUDE_SW,
    RECURSIVE_SW,
    QUICK_SW,
    FULL_SW,
    RULE_SW,
    STATISTICS_SW,
    TYPE_SW,
    RUN_SW,
    CANCEL_SW,
    WAIT_SW,
    COPYSET_SW,
    NAME_SW,
    STATUS_SW,
    CAPACITY_SW,
    FREESPACE_SW,
    VERSION_SW,
    COPIES_SW,
    HELP_SW
} RSS_SWITCH_TYPE, *PRSS_SWITCH_TYPE;

//
// Switches structure: compiled by parsing command line
//
typedef struct _RSS_SWITCHES {
    RSS_SWITCH_TYPE SwitchType;
    LPWSTR          Arg;
} RSS_SWITCHES, *PRSS_SWITCHES;



typedef struct _RSS_KEYWORD {
    //
    // Long version of the keyword
    //
    LPWSTR        Long;
    //
    // Short version of the keyword
    //
    LPWSTR        Short;
    RSS_INTERFACE  Interface;
} RSS_KEYWORD, *PRSS_KEYWORD;

//
// Switches are described in this structure
// First, some defines for RSS_SWITCH_DEFINITION structure 
//
#define RSS_NO_ARG              0
#define RSS_ARG_DWORD           1
#define RSS_ARG_STRING          2
typedef struct _RSS_SWITCH_DEFINITION {
    //
    // Long version of the keyword
    //
    LPWSTR          Long;
    //
    // Short version of the keyword
    //
    LPWSTR          Short;
    RSS_SWITCH_TYPE SwitchType;
    DWORD           ArgRequired;
} RSS_SWITCH_DEFINITION, *PRSS_SWITCH_DEFINITION;

//
// Job type definition
//
typedef struct _RSS_JOB_DEFINITION {
    //
    // Long version of the keyword
    //
    LPWSTR          Long;
    //
    // Short version of the keyword
    //
    LPWSTR          Short;
    HSM_JOB_TYPE    JobType;
} RSS_JOB_DEFINITION, *PRSS_JOB_DEFINITION;



#define HSM_SCHED_AT               L"At"
#define HSM_SCHED_EVERY            L"Every"
#define HSM_SCHED_SYSTEMSTARTUP    L"Startup"
#define HSM_SCHED_LOGIN            L"Login"
#define HSM_SCHED_IDLE             L"Idle"
#define HSM_SCHED_DAILY            L"Day"
#define HSM_SCHED_WEEKLY           L"Week"
#define HSM_SCHED_MONTHLY          L"Month"
#define HSM_SCHED_TIME_SEPARATORS  L":"

#endif // _CLIPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\cli.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cli.cpp

Abstract:

    DLL main for Cli

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

// cli.cpp : Implementation of DLL standard exports.

// Note: Currently, this DLL does not expose any COM objects.
//      

#include "stdafx.h"

CComModule  _Module;
HINSTANCE   g_hInstance;
/*** CComPtr<IWsbTrace> g_pTrace;   ***/

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);

/***        // Initialize trace mechanizm
        if (S_OK == CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace, (void **)&g_pTrace)) {
            CWsbStringPtr   tracePath;
            CWsbStringPtr   regPath;
            CWsbStringPtr   outString;

            // Registry path for CLI settings
            // If those expand beyond Trace settings, this path should go to a header file
            regPath = L"SOFTWARE\\Microsoft\\RemoteStorage\\CLI";
        
            // Check if tracing path already exists, if not - set it (this should happen only once)
            WsbAffirmHr(outString.Alloc(WSB_TRACE_BUFF_SIZE));
            if( WsbGetRegistryValueString(NULL, regPath, L"WsbTraceFileName", outString, WSB_TRACE_BUFF_SIZE, 0) != S_OK) {
                // No trace settings yet
                WCHAR *systemPath;
                systemPath = _wgetenv(L"SystemRoot");
                WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace\\RsCli.Trc", systemPath));

                // Set default settings in the Registry
                WsbEnsureRegistryKeyExists(0, regPath);
                WsbSetRegistryValueString(0, regPath, L"WsbTraceFileName", tracePath);

                // Make sure the trace directory exists.
                WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage", systemPath));
                CreateDirectory(tracePath, 0);
                WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace", systemPath));
                CreateDirectory(tracePath, 0);
            }
        
            g_pTrace->SetRegistryEntry(regPath);
            g_pTrace->LoadFromRegistry();
        }   ***/

    } else if (dwReason == DLL_PROCESS_DETACH) {
/***         g_pTrace = 0;  ***/
    }


    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\cliutils.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliutils.cpp

Abstract:

    Implements internal CLI unit utilities

Author:

    Ran Kalach          [rankala]         8-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"

static GUID g_nullGuid = GUID_NULL;

HRESULT
ValidateLimitsArg(
   IN DWORD dwArgValue,
   IN DWORD dwArgId,
   IN DWORD dwMinLimit,
   IN DWORD dwMaxLimit
)
/*++

Routine Description:

    Validates the argument and print error message if necessary

Arguments:

    dwArgValue      - The value to check
    dwArgId         - Id for resource string of the arg
    dwMinLimit      - The Min limit to compare, INVALID_DWORD_ARG for Max compare
    dwMaxLimit      - The Max limit to compare, INVALID_DWORD_ARG for Min compare

Return Value:

    S_OK            - The argument is OK (or not in use)
    E_INVALIDARG    - The argument is not in the limit range

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("ValidateOneLimitArg"), OLESTR(""));

    try {
        CWsbStringPtr   param;
        WCHAR           strLongParm1[30];
        WCHAR           strLongParm2[30];
        WCHAR           strLongParm3[30];

        if (INVALID_DWORD_ARG != dwArgValue) {
            if ((INVALID_DWORD_ARG != dwMinLimit) && (INVALID_DWORD_ARG != dwMaxLimit)) {
                // Min-Max test
                if ((dwArgValue < dwMinLimit) || (dwArgValue > dwMaxLimit)) {
                    WsbAffirmHr(param.LoadFromRsc(g_hInstance, dwArgId));
                    swprintf(strLongParm1, OLESTR("%lu"), dwArgValue);
                    swprintf(strLongParm2, OLESTR("%lu"), dwMinLimit);
                    swprintf(strLongParm3, OLESTR("%lu"), dwMaxLimit);
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_ARG3, (WCHAR *)param, 
                            strLongParm1, strLongParm2, strLongParm3, NULL);
                    WsbThrow(E_INVALIDARG);
                }
            } else if (INVALID_DWORD_ARG != dwMinLimit) {
                // Min test
                if (dwArgValue < dwMinLimit) {
                    WsbAffirmHr(param.LoadFromRsc(g_hInstance, dwArgId));
                    swprintf(strLongParm1, OLESTR("%lu"), dwArgValue);
                    swprintf(strLongParm2, OLESTR("%lu"), dwMinLimit);
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_ARG1, (WCHAR *)param, 
                            strLongParm1, strLongParm2, NULL);
                    WsbThrow(E_INVALIDARG);
                }
            } else if (INVALID_DWORD_ARG != dwMaxLimit) {
                // Max test
                if (dwArgValue > dwMaxLimit) {
                    WsbAffirmHr(param.LoadFromRsc(g_hInstance, dwArgId));
                    swprintf(strLongParm1, OLESTR("%lu"), dwArgValue);
                    swprintf(strLongParm2, OLESTR("%lu"), dwMaxLimit);
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_ARG2, (WCHAR *)param, 
                            strLongParm1, strLongParm2, NULL);
                    WsbThrow(E_INVALIDARG);
                }
             }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("ValidateOneLimitArg"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT SaveServersPersistData(
    void
)
/*++

Routine Description:

    Save persistent data for HSM servers

Arguments:

    None

Return Value:

    S_OK            - The persistent data is saved successfully for all HSM servers

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("SaveServersPersistData"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IFsaServer>             pFsa;
        CComPtr<IWsbServer>             pWsbServer;

        // Engine
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->SavePersistData());

        // Fsa
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));
        WsbAffirmHr(pFsa->QueryInterface(IID_IWsbServer, (void**)&pWsbServer));
        WsbAffirmHr(pWsbServer->SaveAll());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("SaveServersPersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

// NOTE: This code is cloned from MS source /shell/shelldll/util.c (and from \hsm\gui\inc\rsutil.cpp)

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

const int pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, 10);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = (TCHAR)( TEXT('0') + 3 - wLen );
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(g_hInstance, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return S_OK;
}

/*
 * takes a DWORD add commas etc to it and puts the result in the buffer
 */

// NOTE: This code is cloned from MS source /shell/shelldll/util.c (and from \hsm\gui\inc\rsutil.cpp)

LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen)
{
    TCHAR  szTemp[20];  // more than enough for a DWORD
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = _tcstol(szSep, NULL, 10);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, nResLen) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

HRESULT 
FormatFileTime(
    IN FILETIME ft, 
    OUT WCHAR **ppTimeString
)
/*++

Routine Description:

    Fotmat a time given in GMT (system) time to a string

Arguments:

    ft              - The input time in FILETIME format
    ppTimeString    - Output buffer. Caller is expected to free using WsbFree in case of success

Return Value:

    S_OK            - If the time is formatted successfully

--*/
{
    HRESULT                     hr = S_OK;
    WCHAR*                      pTime = NULL;

    WsbTraceIn(OLESTR("FormatFileTime"), OLESTR(""));

    try {
        FILETIME        ftLocal;
        SYSTEMTIME      stLocal;

        WsbAffirm(0 != ppTimeString, E_INVALIDARG);
        *ppTimeString = NULL;

        // Translate to local time in SYSTEMTIME format
        WsbAffirmStatus(FileTimeToLocalFileTime(&ft, &ftLocal));
        WsbAffirmStatus(FileTimeToSystemTime(&ftLocal, &stLocal));

        // Find required buffer
        int nChars1 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, NULL, 0);
        int nChars2 = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, NULL, 0);
        pTime = (WCHAR *)WsbAlloc((nChars1+nChars2+1) * sizeof(WCHAR));
        WsbAffirm(0 != pTime, E_OUTOFMEMORY);

        // Create time string
        WsbAffirmStatus(GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, pTime, nChars1));
        pTime[nChars1-1] = L' ';
        WsbAffirmStatus(GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, &(pTime[nChars1]), nChars2));

        *ppTimeString = pTime;
        
    } WsbCatchAndDo(hr,
        // Free in case of an error
        if (pTime) {
            WsbFree(pTime);
            pTime = NULL;
        }
    );

    WsbTraceOut(OLESTR("FormatFileTime"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT 
CliGetVolumeDisplayName(
    IN IUnknown *pResourceUnknown, 
    OUT WCHAR **ppDisplayName
)
/*++

Routine Description:

    Produce a display name for a volume

Arguments:

    pResourceUnknown    - The input Fsa Resource object
    ppDisplayName       - Output buffer. Caller is expected to free using WsbFree in case of success

Return Value:

    S_OK            - If the name is retrieved successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CliGetVolumeDisplayName"), OLESTR(""));

    try {
        CComPtr<IFsaResource>   pResource;

        // Check and initialize parameters
        WsbAffirm(0 != ppDisplayName, E_INVALIDARG);
        *ppDisplayName = NULL;
        WsbAffirmHr(pResourceUnknown->QueryInterface(IID_IFsaResource, (void **)&pResource));

        // Prefer user friendly name
        //  If not exists, use label
        //  If no label, use constant
        CWsbStringPtr userName;
        WsbAffirmHr(pResource->GetUserFriendlyName(&userName, 0));

        if (userName.IsEqual(L"")) {
            userName.Free();
            WsbAffirmHr(pResource->GetName(&userName, 0));
            if (userName.IsEqual(L"")) {
                userName.Free();
                WsbAffirmHr(userName.LoadFromRsc(g_hInstance, IDS_UNLABELED_VOLUME));
            }
        } 

        *ppDisplayName = (WCHAR *)WsbAlloc((wcslen(userName) + 1) * sizeof(WCHAR));
        WsbAffirm(0 != *ppDisplayName, E_OUTOFMEMORY);
        wcscpy(*ppDisplayName, userName);
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CliGetVolumeDisplayName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\cliparse.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliparse.cpp

Abstract:

    Implements CLI parsing engine

Author:

    Ravisankar Pudipeddi   [ravisp]  3-March-2000

Revision History:

--*/

//
// Throughout this parse module, we return E_NOINTERFACE
// to indicate invalid command line syntax/parameters.
// This is to explicitly distinguish from E_INVALIDARG that may
// be returned by the CLI dll: we wish to distinguish a syntax error
// detected by the parser from a syntax error detected  by the CLI dll
// because in the latter case we do not print the usage for the interface.
// Whereas for errors detected by the parser, we *do* print the usage.
// This rule needs to be strictly adhered to
//

#include "stdafx.h"
#include "stdlib.h"
#include "cliparse.h"
#include "string.h"
#include "locale.h"

#pragma warning( disable : 4100 )

CComModule  _Module;
CComPtr<IWsbTrace> g_pTrace;  

#define MAX_ARGS        40
#define MAX_SWITCHES    20
// 
// List of all CLI keywords
// TBD: Sort them!
//
RSS_KEYWORD RssInterfaceStrings[] =  {
    {L"ADMIN",          L"AD",     ADMIN_IF},
    {L"VOLUME",         L"VL",     VOLUME_IF},
    {L"MEDIA",          L"MD",     MEDIA_IF},
    {L"FILE",           L"FL",     FILE_IF},
    {L"SHOW",           L"SH",     SHOW_IF},
    {L"SET",            L"ST",     SET_IF},
    {L"MANAGE",         L"MG",     MANAGE_IF},
    {L"UNMANAGE",       L"UM",     UNMANAGE_IF},
    {L"DELETE",         L"DL",     DELETE_IF},
    {L"JOB",            L"JB",     JOB_IF},
    {L"RECALL",         L"RC",     RECALL_IF},
    {L"SYNCHRONIZE",    L"SN",     SYNCHRONIZE_IF},
    {L"RECREATEMASTER", L"RM",     RECREATEMASTER_IF},
    {L"HELP",           L"/?",     HELP_IF},
//
// Duplicate entry for HELP to recognize -? also as a help
// interface
//
    {L"HELP",           L"-?",     HELP_IF},
    {NULL,              NULL,      UNKNOWN_IF}
};

//
// Rss option strings - listed here without the preceding
// '/' or '-' (or whatever that distinguishes a switch from
// an argument)
// TBD: Sort them!
//

RSS_SWITCH_DEFINITION RssSwitchStrings[] = {
    {L"RECALLLIMIT",    L"LM",        RECALLLIMIT_SW, RSS_ARG_DWORD},
    {L"MEDIACOPIES",    L"MC",        MEDIACOPIES_SW, RSS_ARG_DWORD},
    {L"SCHEDULE",       L"SC",        SCHEDULE_SW,    RSS_ARG_STRING},
    {L"CONCURRENCY",    L"CN",        CONCURRENCY_SW, RSS_ARG_DWORD},
    {L"ADMINEXEMPT",    L"AE",        ADMINEXEMPT_SW, RSS_ARG_DWORD},
    {L"GENERAL",        L"GN",        GENERAL_SW,     RSS_NO_ARG},
    {L"MANAGEABLES",    L"MS",        MANAGEABLES_SW, RSS_NO_ARG},
    {L"MANAGED",        L"MN",        MANAGED_SW,     RSS_NO_ARG},
    {L"MEDIA",          L"MD",        MEDIA_SW,       RSS_NO_ARG},
    {L"DFS",            L"DF",        DFS_SW,         RSS_ARG_DWORD},
    {L"SIZE",           L"SZ",        SIZE_SW,        RSS_ARG_DWORD},
    {L"ACCESS",         L"AC",        ACCESS_SW,      RSS_ARG_DWORD},
    {L"INCLUDE",        L"IN",        INCLUDE_SW,     RSS_ARG_STRING},
    {L"EXCLUDE",        L"EX",        EXCLUDE_SW,     RSS_ARG_STRING},
    {L"RECURSIVE",      L"RC",        RECURSIVE_SW,   RSS_NO_ARG},
    {L"QUICK",          L"QK",        QUICK_SW,       RSS_NO_ARG},
    {L"FULL",           L"FL",        FULL_SW,        RSS_NO_ARG},
    {L"RULE",           L"RL",        RULE_SW,        RSS_ARG_STRING},
    {L"STATISTICS",     L"ST",        STATISTICS_SW,  RSS_NO_ARG},
    {L"TYPE",           L"TY",        TYPE_SW,        RSS_ARG_STRING},
    {L"RUN",            L"RN",        RUN_SW,         RSS_NO_ARG},
    {L"CANCEL",         L"CX",        CANCEL_SW,      RSS_NO_ARG},
    {L"WAIT",           L"WT",        WAIT_SW,        RSS_NO_ARG},
    {L"COPYSET",        L"CS",        COPYSET_SW,     RSS_ARG_DWORD},
    {L"NAME",           L"NM",        NAME_SW,        RSS_ARG_STRING},
    {L"STATUS",         L"SS",        STATUS_SW,      RSS_NO_ARG},
    {L"CAPACITY",       L"CP",        CAPACITY_SW,    RSS_NO_ARG},
    {L"FREESPACE",      L"FS",        FREESPACE_SW,   RSS_NO_ARG},
    {L"VERSION",        L"VR",        VERSION_SW,     RSS_NO_ARG},
    {L"COPIES",         L"CP",        COPIES_SW,      RSS_NO_ARG},
    {L"HELP",           L"?",         HELP_SW,        RSS_NO_ARG},
    {NULL,              NULL,         UNKNOWN_SW, RSS_NO_ARG}
}; 

RSS_JOB_DEFINITION  RssJobTypeStrings[] = {
    {L"CREATEFREESPACE", L"F", CreateFreeSpace},
    {L"COPYFILES",       L"C", CopyFiles},
    {L"VALIDATE",        L"V", Validate},
    {NULL,               NULL,  InvalidJobType}
};

//
// Global  arrays of arguments and switches
// These will be used as 'known' entities by all
// the interface implementations instead of passing
// them around as parameters
//
LPWSTR       Args[MAX_ARGS];
RSS_SWITCHES Switches[MAX_SWITCHES];
DWORD        NumberOfArguments = 0;
DWORD        NumberOfSwitches = 0;

//
// Useful macros
//

#define CLIP_ARGS_REQUIRED()            {           \
        if (NumberOfArguments <= 0) {               \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_ARGS_NOT_REQUIRED()            {       \
        if (NumberOfArguments > 0) {                \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_SWITCHES_REQUIRED()            {       \
        if (NumberOfSwitches <= 0) {                \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_SWITCHES_NOT_REQUIRED()            {   \
        if (NumberOfSwitches > 0) {                 \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_TRANSLATE_HR_AND_RETURN(__HR)     {   \
    if (__HR == S_OK) {                            \
        return CLIP_ERROR_SUCCESS;                 \
    } else if ((__HR == E_NOINTERFACE) ||          \
               (__HR == E_INVALIDARG)) {           \
        return CLIP_ERROR_INVALID_PARAMETER;       \
    } else if (__HR == E_OUTOFMEMORY) {            \
        return CLIP_ERROR_INSUFFICIENT_MEMORY;     \
    } else  {                                      \
        return CLIP_ERROR_UNKNOWN;                 \
    }                                              \
} 

#define CLIP_GET_DWORD_ARG(__VAL, __STRING, __STOPSTRING) {      \
        __VAL = wcstol(__STRING, &(__STOPSTRING), 10);           \
        if (*(__STOPSTRING) != L'\0') {                          \
            WsbThrow(E_NOINTERFACE);                              \
        }                                                        \
}

#define CLIP_VALIDATE_DUPLICATE_DWORD_ARG(__ARG)         {       \
        if ((__ARG) !=  INVALID_DWORD_ARG)               {       \
            WsbThrow(E_NOINTERFACE);                              \
        }                                                        \
}

#define CLIP_VALIDATE_DUPLICATE_POINTER_ARG(__ARG)       {       \
        if ((__ARG) !=  INVALID_POINTER_ARG)               {     \
            WsbThrow(E_NOINTERFACE);                              \
        }                                                        \
}

//
// Local function prototypes
//

RSS_INTERFACE
ClipGetInterface(
                IN LPWSTR InterfaceString
                );

DWORD
ClipGetSwitchTypeIndex(
                      IN LPWSTR SwitchString
                      );

HSM_JOB_TYPE
ClipGetJobType(
              IN LPWSTR JobTypeString
              );

HRESULT          
ClipCompileSwitchesAndArgs(
                          IN LPWSTR CommandLine, 
                          IN RSS_INTERFACE Interface,
                          IN RSS_INTERFACE SubInterface
                          );

VOID
ClipCleanup(
           VOID
           );

HRESULT
ClipAdminShow(
             VOID
             );

HRESULT 
ClipAdminSet(
            VOID
            );

HRESULT 
ClipVolumeShow(
              VOID
              );

HRESULT
ClipVolumeUnmanage(
                  VOID
                  );

HRESULT
ClipVolumeSetManage(
                   IN BOOL Set
                   );

HRESULT 
ClipVolumeDelete(
                VOID
                );

HRESULT
ClipVolumeJob(
             VOID
             );

HRESULT 
ClipMediaShow(
             VOID
             );

HRESULT 
ClipMediaSynchronize(
                    VOID
                    );

HRESULT 
ClipMediaRecreateMaster(
                       VOID
                       );

HRESULT 
ClipMediaDelete(
               VOID
               );

HRESULT 
ClipFileRecall(
              VOID
              );

VOID
ClipHelp(
        IN RSS_INTERFACE Interface,
        IN RSS_INTERFACE SubInterface
        );

HRESULT
ClipParseTime(
             IN  LPWSTR        TimeString,
             OUT PSYSTEMTIME   ScheduledTime
             );

HRESULT
ClipParseSchedule(
                 IN  LPWSTR ScheduleString,
                 OUT PHSM_JOB_SCHEDULE Schedule
                 );
BOOL
ClipInitializeTrace(
                   VOID
                   );

VOID
ClipUninitializeTrace(
                     VOID
                     );


VOID
ClipHandleErrors(
                IN HRESULT RetCode,
                IN RSS_INTERFACE Interface,
                IN RSS_INTERFACE SubInterface
                );
//
// Function bodies start here
//

RSS_INTERFACE
ClipGetInterface(
                IN LPWSTR InterfaceString
                ) 
/*++
Routine Description:

    Maps the interface string that is supplied to an enum

Arguments
    
    InterfaceString - Pointer to the interface string
    TBD: implement a binary search

Return Value

    UNKNOWN_IF - if the interface string is not recognized
    An RSS_INTERFACE value if it is.

--*/
{
    DWORD i;
    RSS_INTERFACE ret = UNKNOWN_IF;

    WsbTraceIn(OLESTR("ClipHandleErrors"), OLESTR(""));

    for (i=0 ; TRUE ; i++) {
        if (RssInterfaceStrings[i].Long == NULL) {
            //
            // Reached end of table.
            // 
            break;

        } else if ((_wcsicmp(RssInterfaceStrings[i].Short, 
                             InterfaceString) == 0) ||
                   (_wcsicmp(RssInterfaceStrings[i].Long, 
                             InterfaceString) == 0)) {
            ret = RssInterfaceStrings[i].Interface;
            break;

        }
    }

    WsbTraceOut(OLESTR("ClipGetInterface"), OLESTR("Interface = <%ls>"), WsbLongAsString((LONG) ret));
    return ret;
}


DWORD
ClipGetSwitchTypeIndex(
                      IN LPWSTR SwitchString
                      )
/*++
Routine Description

    Maps the Switch to an entry in the global list of switches
    and returns the index

Arguments

    SwitchString  -  Pointer to switch string
    TBD: implement a binary search

Return Value

    -1  - If the switch is not recognized
    A positive value (index to the entry) if it is
--*/
{
    DWORD i;

    WsbTraceIn(OLESTR("ClipGetSwitchTypeIndex"), OLESTR(""));

    for (i = 0; TRUE; i++) {
        if (RssSwitchStrings[i].Long == NULL) {
            //
            // Reached end of table.
            // 
            i = -1;
            break;
        } else if ((_wcsicmp(RssSwitchStrings[i].Short,
                             SwitchString) == 0) ||
                   (_wcsicmp(RssSwitchStrings[i].Long,
                             SwitchString) == 0)) {

            break;
        }
    }

    WsbTraceOut(OLESTR("ClipGetSwitchTypeIndex"), OLESTR("index = <%ls>"), WsbLongAsString((LONG) i));
    return i;
}


HSM_JOB_TYPE
ClipGetJobType(
              IN LPWSTR JobTypeString
              )
/*++
Routine Description

    Maps the job string to an enum

Arguments

    JobTypeString  -  Pointer to JobType string
    TBD: implement a binary search

Return Value

    InvalidJobType  - If the job type is not recognized
    HSM_JOB_TYPE value if it is
--*/
{
    DWORD i;
    HSM_JOB_TYPE jobType = InvalidJobType;

    WsbTraceIn(OLESTR("ClipGetJobType"), OLESTR(""));

    for (i = 0; TRUE; i++) {
        if (RssJobTypeStrings[i].Long == NULL) {
            //
            // Reached end of table.
            // 
            break;
        }
        if ((_wcsicmp(RssJobTypeStrings[i].Short,
                      JobTypeString) == 0) ||
            (_wcsicmp(RssJobTypeStrings[i].Long,
                      JobTypeString) == 0)) {
            jobType = RssJobTypeStrings[i].JobType;
            break;
        }
    }

    WsbTraceOut(OLESTR("ClipGetJobType"), OLESTR("JobType = <%ls>"), WsbLongAsString((LONG) jobType));

    return jobType;
}   


HRESULT
ClipCompileSwitchesAndArgs(
                          IN LPWSTR CommandLine, 
                          IN RSS_INTERFACE Interface,
                          IN RSS_INTERFACE SubInterface
                          )
/*++

Routine Description

    Parses the passed in string and compiles all switches
    (a switch is identified by an appropriate delimiter preceding
    it, such as a '/') into a global switches array (along with
    the arguments to the switch) and the rest of the parameters
    into an Args array

Arguments

    CommandLine - String to be parsed

Return Value

    S_OK if success
--*/
{
    HRESULT hr = S_OK;
    WCHAR token[MAX_PATH];
    LPWSTR p = CommandLine, pToken = token, switchArg, switchString;
    RSS_SWITCH_TYPE switchType;
    DWORD index;
    BOOL  isSwitch, skipSpace;

    WsbTraceIn(OLESTR("ClipCompileSwitchesAndArgs"), OLESTR(""));

    try {
        if (p == NULL) {
            WsbThrow(S_OK);
        }

        while (*p != L'\0') {

            if (wcschr(SEPARATORS, *p) != NULL) {
                //
                // Skip white space
                //
                p++;
                continue;
            }
            if (wcschr(SWITCH_DELIMITERS, *p) != NULL) {
                isSwitch = TRUE;
                p++;
                if (*p == L'\0') {
                    //
                    // Badly formed - a SWITCH_DELIMITER with no switch
                    // 
                    WsbThrow(E_NOINTERFACE);
                }
            } else {
                isSwitch = FALSE;
            }
            //
            // Get the rest of the word
            //
            skipSpace = FALSE;
            while (*p != L'\0' && *p != L'\n') {
                //
                // We wish to consider stuff enclosed entirely in 
                // quotes as a single token. As a result
                // we won't consider white space to be a delimiter
                // for tokens when they are in quotes.
                //
                if (*p == QUOTE) {
                    if (skipSpace) {
                        //
                        // A quote was encountered previously.
                        // This signifies - hence -  the end of the token
                        //
                        p++;
                        break;
                    } else {
                        //
                        // Start of quoted string..don't treat whitespace
                        // as a delimiter anymore, only a quote will end the token 
                        //
                        skipSpace = TRUE;
                        p++;
                        continue;
                    }
                }

                if (!skipSpace && (wcschr(SEPARATORS, *p) != NULL)) {
                    //
                    // This is not quoted and white space was encountered..
                    //
                    break;
                }
                *pToken++ = *p++;
            }

            *pToken = L'\0';

            if (isSwitch) {
                //
                // For a switch, we will have to further split it into
                // the switch part and the argument part
                // 
                switchString = wcstok(token, SWITCH_ARG_DELIMITERS);

                index = ClipGetSwitchTypeIndex(switchString);
                if (index == -1) {
                    //
                    // Invalid switch. Get out.
                    //
                    WsbThrow(E_NOINTERFACE);
                }
                switchType = RssSwitchStrings[index].SwitchType;

                switchArg = wcstok(NULL, L"");
                //
                // Validation -  badly formed commandline if either:
                // 1. An argument was supplied and the switch definition indicated
                // no argument was required
                //     OR
                // 2. This is a non-SHOW interface (by default show interface 
                // don't require arguments for options), and an argument was not 
                // supplied even though the switch definition indicated one is
                // required.
                //  
                // 3. This is a SHOW interface and an argument was supplied
                //
                if ( ((switchArg != NULL) &&
                      (RssSwitchStrings[index].ArgRequired == RSS_NO_ARG)) ||

                     ((SubInterface != SHOW_IF) && (switchArg == NULL) &&
                      (RssSwitchStrings[index].ArgRequired != RSS_NO_ARG)) ||
                     ((SubInterface == SHOW_IF) && (switchArg != NULL))) {
                    WsbThrow(E_NOINTERFACE);
                }

                Switches[NumberOfSwitches].SwitchType = switchType;        

                if (switchArg != NULL) {
                    Switches[NumberOfSwitches].Arg = new WCHAR [wcslen(switchArg)+1];

                    if (Switches[NumberOfSwitches].Arg == NULL) {
                        WsbThrow(E_OUTOFMEMORY);
                    }

                    wcscpy(Switches[NumberOfSwitches].Arg, switchArg);

                } else {
                    //
                    // No arg for this switch
                    //
                    Switches[NumberOfSwitches].Arg = NULL;
                }

                NumberOfSwitches++;
            } else {
                //
                // This is an argument..
                //
                Args[NumberOfArguments] = new WCHAR [wcslen(token)+1];

                if (Args[NumberOfArguments] == NULL) {
                    WsbThrow(E_OUTOFMEMORY);
                }

                wcscpy(Args[NumberOfArguments], 
                       token); 
                NumberOfArguments++;
            }
            pToken = token;
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipCompileSwitchesAndArgs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


VOID
ClipCleanup(VOID)
/*++

Routine Description

    Performs global cleanup for CLI parse module.
    Mainly - frees up all allocated arguments and switches

Arguments

    None

Return Value

    None
--*/
{
    DWORD i;

    WsbTraceIn(OLESTR("ClipCleanup"), OLESTR(""));

    for (i = 0; i < NumberOfArguments; i++) {
        delete [] Args[i];
    }
    for (i = 0; i < NumberOfSwitches; i++) {
        if (Switches[i].Arg != NULL) {
            delete [] Switches[i].Arg;
        }
    }

    WsbTraceOut(OLESTR("ClipCleanup"), OLESTR(""));
}


HRESULT
ClipAdminShow(VOID)
/*++

Routine Description

    Implements RSS ADMIN SHOW interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK              if everything's ok
    E_NOINTERFACE       if args/switches are bad
--*/
{
    DWORD i;
    HRESULT hr;
    BOOL recallLimit = FALSE; 
    BOOL adminExempt = FALSE;
    BOOL mediaCopies = FALSE;
    BOOL concurrency = FALSE;
    BOOL schedule = FALSE;
    BOOL general = FALSE;
    BOOL manageables = FALSE;
    BOOL managed = FALSE;
    BOOL media = FALSE;


    WsbTraceIn(OLESTR("ClipAdminShow"), OLESTR(""));
    try {
        //
        // No arguments needed for this interface
        //
        CLIP_ARGS_NOT_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case RECALLLIMIT_SW: {
                        recallLimit = TRUE;
                        break;
                    }
                case ADMINEXEMPT_SW: {
                        adminExempt = TRUE;
                        break;
                    }
                case MEDIACOPIES_SW: {
                        mediaCopies = TRUE;
                        break;
                    }
                case CONCURRENCY_SW: {
                        concurrency = TRUE;
                        break;
                    }
                case SCHEDULE_SW: {
                        schedule = TRUE;
                        break;
                    }
                case GENERAL_SW: {
                        general = TRUE;
                        break;
                    }
                case MANAGEABLES_SW: {
                        manageables = TRUE;   
                        break;
                    } 
                case MANAGED_SW: {
                        managed = TRUE;
                        break;
                    }
                case MEDIA_SW: {
                        media = TRUE;
                        break;
                    }
                default: {
                        // Unknown switch - get out
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
            hr = AdminShow(recallLimit,
                           adminExempt,
                           mediaCopies,
                           concurrency,
                           schedule,
                           general,
                           manageables,
                           managed,
                           media);

        } else {
            hr = AdminShow(TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE);
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipAdminShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT 
ClipAdminSet(VOID)
/*++
Routine Description

    Implements RSS ADMIN SET interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{  
    DWORD             i;
    HRESULT           hr; 
    LPWSTR            stopString = NULL;
    DWORD             recallLimit = INVALID_DWORD_ARG;
    DWORD             adminExempt = INVALID_DWORD_ARG;
    DWORD             mediaCopies = INVALID_DWORD_ARG;
    DWORD             concurrency = INVALID_DWORD_ARG;
    PHSM_JOB_SCHEDULE schedule    = INVALID_POINTER_ARG;
    HSM_JOB_SCHEDULE  schedAllocated;

    WsbTraceIn(OLESTR("ClipAdminSet"), OLESTR(""));
    try {
        //
        // No arguments needed for this interface
        //
        CLIP_ARGS_NOT_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case RECALLLIMIT_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(recallLimit);
                        CLIP_GET_DWORD_ARG(recallLimit,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case ADMINEXEMPT_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(adminExempt);
                        CLIP_GET_DWORD_ARG(adminExempt,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case MEDIACOPIES_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(mediaCopies);
                        CLIP_GET_DWORD_ARG(mediaCopies,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case CONCURRENCY_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(concurrency);
                        CLIP_GET_DWORD_ARG(concurrency,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case SCHEDULE_SW: {
                        CLIP_VALIDATE_DUPLICATE_POINTER_ARG(schedule);
                        hr = ClipParseSchedule(Switches[i].Arg,
                                               &schedAllocated);
                        if (!SUCCEEDED(hr)) {
                            WsbThrow(E_NOINTERFACE);
                        } else {
                            //
                            // schedAllocated has the schedule
                            //
                            schedule = &schedAllocated;
                        }
                        break;
                    }

                default: {
                        // Unknown switch - get out
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
        hr = AdminSet(recallLimit,
                      adminExempt,
                      mediaCopies,
                      concurrency,
                      schedule);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipAdminSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}



HRESULT 
ClipVolumeShow(VOID)
/*++

Routine Description

    Implements RSS VOLUME SHOW interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i;
    HRESULT hr;
    LPWSTR stopString = NULL;
    BOOL   dfs = FALSE;
    BOOL   size = FALSE;
    BOOL   access = FALSE;
    BOOL   rules = FALSE;
    BOOL   statistics = FALSE;

    WsbTraceIn(OLESTR("ClipVolumeShow"), OLESTR(""));
    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches == 0) {
            dfs = size = access = rules = statistics = TRUE;
        } else {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case DFS_SW: {
                        dfs = TRUE;
                        break;
                    }
                case SIZE_SW: {
                        size = TRUE;
                        break;
                    }
                case ACCESS_SW: {
                        access = TRUE;
                        break;
                    }
                case RULE_SW: {
                        rules = TRUE;
                        break;
                    }
                case STATISTICS_SW: {
                        statistics = TRUE;
                        break;
                    }
                default: {
                        //
                        // Invalid option   
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
        hr = VolumeShow(Args,
                        NumberOfArguments,
                        dfs,
                        size,
                        access,
                        rules,
                        statistics);
    }WsbCatch(hr);


    WsbTraceOut(OLESTR("ClipVolumeShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;                   
}


HRESULT
ClipVolumeUnmanage(VOID)
/*++
Routine Description

    Implements RSS VOLUME UNMANAGE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i = 0;
    HRESULT hr;


#define QUICK_UNMANAGE 0
#define FULL_UNMANAGE 1

    DWORD  fullOrQuick = INVALID_DWORD_ARG;

    WsbTraceIn(OLESTR("ClipVolumeUnmanage"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case FULL_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(fullOrQuick);
                        fullOrQuick = FULL_UNMANAGE;
                        break;
                    }
                case QUICK_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(fullOrQuick);
                        fullOrQuick = QUICK_UNMANAGE;
                        break;
                    }
                default: {
                        //
                        // Invalid option
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
//
//  The default for UNMANAGE is quick. So if fullOrQuick is either 
//  QUICK_UNMANAGE  or INVALID_DWORD_ARG, we call unmanage of the quick 
//  variety
//
        hr = VolumeUnmanage(Args,
                            NumberOfArguments,
                            (fullOrQuick == FULL_UNMANAGE)? TRUE : FALSE);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipVolumeUnmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}


HRESULT
ClipVolumeSetManage(IN BOOL Set)    
/*++
Routine Description

    Implements RSS VOLUME MANAGE & RSS VOLUME SET interfaces.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    CLIP_ERROR_SUCCESS              if everything's ok
    CLIP_ERROR_INVALID_PARAMETER    if args/switches are bad
    CLIP_ERROR_UNKNOWN              any other error

--*/
{
    DWORD i = 0;
    HRESULT hr;
    LPWSTR stopString = NULL;
    DWORD  dfs =  INVALID_DWORD_ARG;
    DWORD  size = INVALID_DWORD_ARG;
    DWORD  access = INVALID_DWORD_ARG;
    LPWSTR rulePath = INVALID_POINTER_ARG;
    LPWSTR ruleFileSpec = INVALID_POINTER_ARG;
    BOOL   include = FALSE;
    BOOL   recursive = FALSE;

    WsbTraceIn(OLESTR("ClipVolumeSetManage"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case DFS_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(dfs);
                        CLIP_GET_DWORD_ARG(dfs, Switches[i].Arg, stopString);
                        break;
                    }

                case SIZE_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(size);
                        CLIP_GET_DWORD_ARG(size, Switches[i].Arg, stopString);
                        break;
                    }

                case ACCESS_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(access);
                        CLIP_GET_DWORD_ARG(access, Switches[i].Arg, stopString);
                        break;
                    }
                case INCLUDE_SW: {
                        include = TRUE;
                        //
                        // Deliberately fall down to the EXCLUDE case
                        // (break intentionally omitted)
                        // 
                    }
                case EXCLUDE_SW: {

                        CLIP_VALIDATE_DUPLICATE_POINTER_ARG(rulePath);

                        rulePath = wcstok(Switches[i].Arg, RULE_DELIMITERS);
                        ruleFileSpec = wcstok(NULL, L"");
                        if (ruleFileSpec == NULL) {
                            //
                            // Omission of this indicates all files
                            //
                            ruleFileSpec = CLI_ALL_STR;
                        }
                        break;
                    }
                case RECURSIVE_SW: {
                        recursive = TRUE;
                        break;
                    }
                default: {
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
        //
        // Validate the rule arguments
        //
        if ((rulePath == INVALID_POINTER_ARG) && recursive) {
            //
            // The recursive flag is valid only if a rule was specified
            //
            WsbThrow(E_NOINTERFACE);
        }

        if (Set) {
            hr = VolumeSet(Args,
                           NumberOfArguments,
                           dfs,
                           size,
                           access,
                           rulePath,
                           ruleFileSpec,
                           include,
                           recursive);
        } else {
            hr = VolumeManage(Args,
                              NumberOfArguments,
                              dfs,
                              size,
                              access,
                              rulePath,
                              ruleFileSpec,
                              include,
                              recursive);
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipVolumeSetManage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}          


HRESULT 
ClipVolumeDelete(VOID)
/*++
Routine Description

    Implements RSS VOLUME DELETE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i;
    HRESULT hr;
    BOOL rule = FALSE;
    LPWSTR rulePath = INVALID_POINTER_ARG;
    LPWSTR ruleFileSpec = INVALID_POINTER_ARG;

    WsbTraceIn(OLESTR("ClipVolumeDelete"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case RULE_SW:  {
                    CLIP_VALIDATE_DUPLICATE_POINTER_ARG(rulePath);
                    rule = TRUE;
                    rulePath = wcstok(Switches[i].Arg, RULE_DELIMITERS);
                    ruleFileSpec = wcstok(NULL, L"");
                    if (ruleFileSpec == NULL) {
                        //
                        // Omission of this indicates all files
                        //
                        ruleFileSpec = CLI_ALL_STR;
                    }
                    break;
                }
            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Only deleting rules is supported now
        //
        if (rule) {
            hr = VolumeDeleteRule(Args,
                                  NumberOfArguments,
                                  rulePath,
                                  ruleFileSpec);
        } else {
            hr = E_NOINTERFACE;
        }
    }WsbCatch(hr);


    WsbTraceOut(OLESTR("ClipVolumeDelete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}        


HRESULT
ClipVolumeJob(VOID)
/*++
Routine Description

    Implements RSS VOLUME JOB interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid
--*/
{
    DWORD i;
    HRESULT hr;
    HSM_JOB_TYPE jobType =  InvalidJobType;

#define CANCEL_JOB    0
#define RUN_JOB       1

    DWORD  runOrCancel    = INVALID_DWORD_ARG;
    BOOL  synchronous = FALSE;

    WsbTraceIn(OLESTR("ClipVolumeJob"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case RUN_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(runOrCancel);
                    runOrCancel = RUN_JOB;
                    break;
                }
            case CANCEL_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(runOrCancel);
                    runOrCancel = CANCEL_JOB;
                    break;
                }
            case WAIT_SW: {
                    synchronous = TRUE;
                    break;
                }
            case TYPE_SW: {
                    if (jobType != InvalidJobType) {
                        //
                        // Duplicate switch. Bail
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                    jobType = ClipGetJobType(Switches[i].Arg);
                    if (jobType == InvalidJobType) {
                        //
                        // Invalid job type supplied..
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                    break;
                }
            default: {
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }

        //
        // More validation: 
        //  job type should be valid i.e., specified
        //        
        if (jobType == InvalidJobType) {
            WsbThrow(E_NOINTERFACE);
        }

//
//  Run is the default.. (i.e. TRUE). So if runOrCancel is either 
//  INVALID_DWORD_ARG or RUN_JOB, we pass TRUE
//
        hr =  VolumeJob(Args,
                        NumberOfArguments,
                        jobType,
                        (runOrCancel == CANCEL_JOB)? FALSE: TRUE,
                        synchronous);

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipVolumeJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}        


HRESULT
ClipMediaShow(VOID)
/*++
Routine Description

    Implements RSS MEDIA SHOW interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid
--*/
{
    DWORD i;
    HRESULT hr;
    BOOL name = FALSE;
    BOOL status = FALSE;
    BOOL capacity = FALSE;
    BOOL freeSpace = FALSE;
    BOOL version = FALSE;
    BOOL copies = FALSE;

    WsbTraceIn(OLESTR("ClipMediaShow"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches == 0) {
            name = status = capacity = freeSpace = version = copies = TRUE;
        } else {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case NAME_SW: {
                        name = TRUE;
                        break;
                    }
                case STATUS_SW: {
                        status = TRUE;
                        break;
                    }
                case CAPACITY_SW: {
                        capacity = TRUE;
                        break;
                    }
                case FREESPACE_SW: {
                        freeSpace = TRUE;
                        break;
                    }
                case VERSION_SW: {
                        version = TRUE;
                        break;
                    }
                case COPIES_SW: {
                        copies = TRUE;
                        break;
                    }
                default: {
                        //
                        // Invalid option   
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }

        hr = MediaShow(Args,
                       NumberOfArguments,
                       name,
                       status,
                       capacity,
                       freeSpace,
                       version,
                       copies); 
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipMediaShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;

}


HRESULT
ClipMediaSynchronize(VOID)
/*++
Routine Description

    Implements RSS MEDIA SYNCHRONIZE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid
--*/
{
    DWORD i;
    HRESULT hr;
    DWORD copySetNumber = INVALID_DWORD_ARG;
    BOOL  synchronous = FALSE;
    LPWSTR stopString = NULL;

    WsbTraceIn(OLESTR("ClipMediaSynchronize"), OLESTR(""));

    try {
        //
        // No arguments needed
        //
        CLIP_ARGS_NOT_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case COPYSET_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(copySetNumber);
                    CLIP_GET_DWORD_ARG(copySetNumber, Switches[i].Arg, stopString);
                    break;
                }
            case WAIT_SW: {
                    synchronous = TRUE;
                    break;
                }
            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Need copy set number..
        //
        if (copySetNumber == INVALID_DWORD_ARG) {
            //
            // None was specified
            //
            WsbThrow(E_NOINTERFACE);
        }
        hr = MediaSynchronize(copySetNumber, synchronous);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipMediaRecreateMaster"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}        


HRESULT
ClipMediaRecreateMaster(VOID)
/*++
Routine Description

    Implements RSS MEDIA RECREATEMASTER interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{

    DWORD i;
    HRESULT hr;
    DWORD copySetNumber = INVALID_DWORD_ARG;
    LPWSTR stopString = NULL;
    BOOL  synchronous = FALSE;

    WsbTraceIn(OLESTR("ClipMediaRecreateMaster"), OLESTR(""));

    try {

        //
        // Atleast one arg required
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfArguments > 1) {
            //
            // Only one argument supported...
            //
            WsbThrow(E_NOINTERFACE);
        }

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case COPYSET_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(copySetNumber);
                    CLIP_GET_DWORD_ARG(copySetNumber, Switches[i].Arg, stopString);
                    break;
                }

            case WAIT_SW: {
                    synchronous = TRUE;
                    break;
                }

            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Need copy set number..
        //
        if (copySetNumber == INVALID_DWORD_ARG) {
            //
            // None was specified
            //
            WsbThrow(E_NOINTERFACE);
        }

        hr = MediaRecreateMaster(Args[0],
                                 copySetNumber,
                                 synchronous);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipRecreateMaster"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}        


HRESULT
ClipMediaDelete(VOID)
/*++
Routine Description

    Implements RSS MEDIA DELETE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i;
    HRESULT hr;
    DWORD copySetNumber = INVALID_DWORD_ARG;
    LPWSTR stopString = NULL;

    WsbTraceIn(OLESTR("ClipMediaDelete"), OLESTR(""));

    try {
        //
        // Atleast one arg required
        //
        CLIP_ARGS_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case COPYSET_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(copySetNumber);
                    CLIP_GET_DWORD_ARG(copySetNumber, Switches[i].Arg, stopString);
                    break;
                }
            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Need copy set number..
        //
        if (copySetNumber == INVALID_DWORD_ARG) {
            //
            // None was specified
            //
            WsbThrow(E_NOINTERFACE);
        }
        hr = MediaDelete(Args,
                         NumberOfArguments,
                         copySetNumber);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipMediaDelete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT
ClipFileRecall(VOID)
/*++
Routine Description

    Implements RSS FILE RECALL interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    HRESULT hr;

    WsbTraceIn(OLESTR("ClipFileRecall"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();
        //
        // No switches supported
        //
        CLIP_SWITCHES_NOT_REQUIRED();

        hr = FileRecall(Args,
                        NumberOfArguments);

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipFileRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


VOID
ClipHelp(
        IN RSS_INTERFACE Interface,
        IN RSS_INTERFACE SubInterface
        )
/*++
    
Routine Description

    Prints appropriate help message depending on the interface
    
Arguments

    Interface    - Specifies interface for which help has to be 
                   displayed
    SubInterface - Specifies sub-interface for which help has to be 
                   displayed

Return Value:
    
    NONE

--*/
{

#define BREAK_IF_NOT_UNKNOWN_IF(__INTERFACE) {      \
    if (((__INTERFACE) != UNKNOWN_IF) &&            \
        ((__INTERFACE) != HELP_IF)) {               \
            break;                                  \
     }                                              \
}


    WsbTraceIn(OLESTR("ClipHelp"), OLESTR(""));

    switch (Interface) {
    
    case HELP_IF:
    case UNKNOWN_IF: {
            WsbTraceAndPrint(CLI_MESSAGE_MAIN_HELP, NULL);
            BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
        }

    case ADMIN_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case SHOW_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_ADMIN_SHOW_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case SET_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_ADMIN_SET_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }
    case VOLUME_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case SHOW_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_SHOW_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case SET_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_SET_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case MANAGE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_MANAGE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case UNMANAGE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_UNMANAGE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case JOB_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_JOB_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case DELETE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_DELETE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }

    case MEDIA_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case SHOW_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_SHOW_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case DELETE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_DELETE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case SYNCHRONIZE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_SYNCHRONIZE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case RECREATEMASTER_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_RECREATEMASTER_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }
    case FILE_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case RECALL_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_FILE_RECALL_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }
    }
    WsbTraceOut(OLESTR("ClipHelp"), OLESTR(""));
}


HRESULT
ClipParseTime(
             IN  LPWSTR        TimeString,
             OUT PSYSTEMTIME   ScheduledTime)
/*++

Routine Description
    

    Parses the passed in TimeString as a 24 hour format 
    (hh:mm:ss) and sets hour/minute/sec/millisec in the passed
    in SYSTEMTIME structure
    
Arguments

    TimeString      - String in the format "hh:mm:ss"
    ScheduledTime   - Pointer to SYSTEMTIME structure. Time parsed from TimeString
                      (if ok) will be used to set hour/min/sec/millisec fields in this struc.


Return Value

    S_OK        - TimeString is valid and time was successfully parsed
    Any other   - Syntax error in TimeString


--*/
{
    LPWSTR stopString = NULL, hourString = NULL, minuteString = NULL, secondString = NULL;
    DWORD hour, minute, second = 0;
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("ClipParseTime"), OLESTR(""));

    try {
        hourString = wcstok(TimeString, HSM_SCHED_TIME_SEPARATORS);
        WsbAssert(hourString != NULL, E_NOINTERFACE);
        CLIP_GET_DWORD_ARG(hour, hourString, stopString);

        if (hour > 23) {
            WsbThrow(E_NOINTERFACE);
        }


        minuteString = wcstok(NULL, HSM_SCHED_TIME_SEPARATORS);
        WsbAssert(minuteString != NULL, E_NOINTERFACE);
        CLIP_GET_DWORD_ARG(minute, minuteString, stopString);

        if (minute > 59) {
            WsbThrow(E_NOINTERFACE);
        }

        secondString = wcstok(NULL, HSM_SCHED_TIME_SEPARATORS);
        if (secondString != NULL) {
            CLIP_GET_DWORD_ARG(second, secondString, stopString);
            if (second > 59) {
                WsbThrow(E_NOINTERFACE);
            }
        }

        ScheduledTime->wHour = (WORD) hour;
        ScheduledTime->wMinute = (WORD) minute;
        ScheduledTime->wSecond = (WORD) second;
        ScheduledTime->wMilliseconds = 0;

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipParseTime"), OLESTR(""));

    return hr;
}


HRESULT
ClipParseSchedule(
                 IN  LPWSTR ScheduleString,
                 OUT PHSM_JOB_SCHEDULE Schedule
                 )
/*++

Routine Description

    Parses the passed in schedule string, and constructs the canonical schedule
    form (of type HSM_JOB_SCHEDULE)
    
    Examples of schedule parameter:
     
    "At 21:03:00"
    "At Startup"
    "At Login"
    "At Idle"
    "Every 1 Week 1   21:03:00"
    "Every 2 Day      21:03:00"
    "Every 1 Month 2  21:03:00"
    
Arguments

    ScheduleString  - String specifying the schedule in user-readable syntax
    Schedule        - Pointer to canonical schedule form will be returned in this var.
    
Return Value

    S_OK            - Successful, Schedule contains a pointer to the constructed schedule.
    E_OUTOFMEMORY   - Lack of sufficient system resources 
    Any other error: incorrect schedule specification
--*/
{
    LPWSTR token;
    DWORD occurrence;
    HSM_JOB_FREQUENCY frequency;
    SYSTEMTIME scheduledTime;
    DWORD day;
    HRESULT hr = S_OK; 

    WsbTraceIn(OLESTR("ClipParseSchedule"), OLESTR(""));

    try {
        token = wcstok(ScheduleString, SEPARATORS);

        WsbAssert(token != NULL, E_NOINTERFACE);

        if (!_wcsicmp(token, HSM_SCHED_AT)) {

            token = wcstok(NULL, SEPARATORS);

            if (token == NULL) {
                //
                // Bad arguments
                //
                WsbThrow(E_NOINTERFACE);
            } else if (!_wcsicmp(token, HSM_SCHED_SYSTEMSTARTUP)) {
                //
                // Once at system startup
                //
                Schedule->Frequency = SystemStartup;
                WsbThrow(S_OK);
            } else if (!_wcsicmp(token, HSM_SCHED_LOGIN)) {
                //
                // Once at login time
                //
                Schedule->Frequency = Login;
                WsbThrow(S_OK);
            } else if (!_wcsicmp(token, HSM_SCHED_IDLE)) {
                //
                //  Whenever system's idle
                //
                Schedule->Frequency = WhenIdle;
                WsbThrow(S_OK);
            } else {

                GetSystemTime(&scheduledTime);
                //
                // Once at specified time.
                // Parse the time string and obtain it
                // TBD - Add provision to specify date as well as time
                //
                hr = ClipParseTime(token,
                                   &scheduledTime);
                WsbAssertHr(hr);

                Schedule->Frequency = Once;
                Schedule->Parameters.Once.Time = scheduledTime;
                WsbThrow(S_OK);
            }
        } else if (!_wcsicmp(token, HSM_SCHED_EVERY)) {
            LPWSTR stopString = NULL;

            //
            // Get the occurrence
            //
            token = wcstok(NULL, SEPARATORS);
            WsbAssert(token != NULL, E_NOINTERFACE);
            CLIP_GET_DWORD_ARG(occurrence, token, stopString);

            //
            // Get the qualifier: Daily/Weekly/Monthly
            //
            token = wcstok(NULL, SEPARATORS);
            WsbAssert(token != NULL, E_NOINTERFACE);
            if (!_wcsicmp(token, HSM_SCHED_DAILY)) {
                frequency = Daily;
            } else if (!_wcsicmp(token, HSM_SCHED_WEEKLY)) {
                frequency = Weekly;
            } else if (!_wcsicmp(token, HSM_SCHED_MONTHLY)) {
                frequency = Monthly;
            } else {
                //
                // Badly constructed argument
                //
                WsbThrow(E_NOINTERFACE);
            }
            //
            // Get current time
            //
            GetSystemTime(&scheduledTime);
            //
            // For weekly/monthly we also need to get the day of the week/month
            // Monday = 1, Sunday = 7 for weekly
            //
            if ((frequency == Weekly) || (frequency == Monthly)) {
                token = wcstok(NULL, SEPARATORS);
                WsbAssert(token != NULL, E_NOINTERFACE);

                CLIP_GET_DWORD_ARG(day, token, stopString);

                //
                // Validate & update the parameters
                //
                if (frequency == Weekly) {
                    if (day > 6) {
                        WsbThrow(E_NOINTERFACE);
                    }
                    scheduledTime.wDayOfWeek = (WORD) day;
                }
                if (frequency == Monthly) {
                    if ((day > 31) || (day < 1)) {
                        WsbThrow(E_NOINTERFACE);
                    }
                    scheduledTime.wDay = (WORD) day;
                }
            }
            //
            // Fetch the time
            //
            token = wcstok(NULL, SEPARATORS);
            WsbAssert(token != NULL, E_NOINTERFACE);
            hr = ClipParseTime(token,
                               &scheduledTime);

            WsbAssertHr(hr);

            Schedule->Frequency = frequency;
            Schedule->Parameters.Daily.Occurrence = occurrence;
            Schedule->Parameters.Daily.Time = scheduledTime;
        } else {
            WsbThrow(E_NOINTERFACE);
        }
    }WsbCatch(hr); 

    WsbTraceOut(OLESTR("ClipParseSchedule"), OLESTR(""));

    return hr;
}

   
BOOL
ClipInitializeTrace(
                   VOID
                   )
/*++

Routine Description
    
    Initializes the trace/printing mechanism for CLI

Arguments

    NONE

Return Value

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL ret = TRUE;


    if (S_OK == CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace, (void **)&g_pTrace)) {
        CWsbStringPtr   tracePath;
        CWsbStringPtr   regPath;
        CWsbStringPtr   outString;

        // Registry path for CLI settings
        // If those expand beyond Trace settings, this path should go to a header file
        regPath = L"SOFTWARE\\Microsoft\\RemoteStorage\\CLI";

        // Check if tracing path already exists, if not - set it (this should happen only once)
        WsbAffirmHr(outString.Alloc(WSB_TRACE_BUFF_SIZE));
        if ( WsbGetRegistryValueString(NULL, regPath, L"WsbTraceFileName", outString, WSB_TRACE_BUFF_SIZE, 0) != S_OK) {
            // No trace settings yet
            WCHAR *systemPath;
            systemPath = _wgetenv(L"SystemRoot");
            WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace\\RsCli.Trc", systemPath));

            // Set default settings in the Registry
            WsbEnsureRegistryKeyExists(0, regPath);
            WsbSetRegistryValueString(0, regPath, L"WsbTraceFileName", tracePath);

            // Make sure the trace directory exists.
            WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage", systemPath));
            CreateDirectory(tracePath, 0);
            WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace", systemPath));
            CreateDirectory(tracePath, 0);
        }

        g_pTrace->SetRegistryEntry(regPath);
        g_pTrace->LoadFromRegistry();
    }

    return ret;    
}



VOID
ClipUninitializeTrace(
                     VOID
                     )
/*++

Routine Description
    
    Uninitializes the trace/print mechansim
    Paired with ClipInitializeTrace

Arguments

    NONE

Return Value

    NONE

--*/
{
    g_pTrace = 0;
}


VOID
ClipHandleErrors(
                IN HRESULT RetCode,
                IN RSS_INTERFACE Interface,
                IN RSS_INTERFACE SubInterface
                )
/*++

Routine Description

    Translates the main return value & displays any appropriate
    error messages and returns

Arguments

    RetCode      - Error to handle
    Interface    - RSS interface specified in the command
    SubInterface - RSS sub-interface specified in the command

Return Value

    None

--*/
{
    WsbTraceIn(OLESTR("ClipHandleErrors"), OLESTR(""));

    switch (RetCode) {
    case E_INVALIDARG:
    case S_OK:{
            //
            // Nothing to print
            //
            break;}

    case E_NOINTERFACE:{
            WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, WsbHrAsString(E_INVALIDARG));
            ClipHelp(Interface,
                     SubInterface);
            break;}
    default:{
            WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, WsbHrAsString(RetCode));
            break;}
    }

    WsbTraceOut(OLESTR("ClipHandleErrors"), OLESTR(""));
}              


extern "C" 
int  __cdecl 
wmain()
{
    LPWSTR commandLine, token;
    HRESULT hr = E_NOINTERFACE;
    RSS_INTERFACE intrface = HELP_IF, subInterface = UNKNOWN_IF;

    try {
        WsbAffirmHr(CoInitialize(NULL));

        //
        // Set to OEM page locale
        //
        _wsetlocale(LC_ALL, L".OCP");

        ClipInitializeTrace();

        commandLine = GetCommandLine();
        //
        // Get argv[0] out of the way
        //
        token = wcstok(commandLine, SEPARATORS);

        //
        // Get the interface string
        //
        token = wcstok(NULL, SEPARATORS);

        if (token == NULL) {
            ClipHelp(HELP_IF,
                     UNKNOWN_IF);
            hr = S_OK;
            goto exit;
        }

        intrface = ClipGetInterface(token);

        if (intrface == UNKNOWN_IF) {
            hr = E_NOINTERFACE;
            intrface = HELP_IF;
            goto exit;
        }

        if (intrface == HELP_IF) {
            ClipHelp(HELP_IF,
                     UNKNOWN_IF);
            hr = S_OK;
            goto exit;
        }

        //
        // Get sub interface string
        //
        token = wcstok(NULL, SEPARATORS);

        if (token == NULL) {
            hr =  E_NOINTERFACE;
            goto exit;
        }
        subInterface = ClipGetInterface(token);

        if (subInterface == UNKNOWN_IF) {
            hr = E_NOINTERFACE;
            goto exit;
        }

        if (subInterface == HELP_IF) {
            ClipHelp(intrface,
                     UNKNOWN_IF);
            hr = S_OK;
            goto exit;
        }
        //
        // Now compile the switches & arguments into separate arrays
        // First, get the rest of line ..
        //
        token = wcstok(NULL, L"");
        hr = ClipCompileSwitchesAndArgs(token,
                                        intrface,
                                        subInterface);

        if (hr != S_OK) {
            goto exit;
        }

        switch (intrface) {
        
        case ADMIN_IF:{ 
                if (subInterface == SHOW_IF) {
                    hr = ClipAdminShow();
                } else if (subInterface == SET_IF) {
                    hr = ClipAdminSet();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            } 

        case VOLUME_IF:{
                if (subInterface == MANAGE_IF) {
                    hr = ClipVolumeSetManage(FALSE);
                } else if (subInterface == UNMANAGE_IF) {
                    hr = ClipVolumeUnmanage();
                } else if (subInterface == SET_IF) {
                    hr = ClipVolumeSetManage(TRUE);
                } else if (subInterface == SHOW_IF) {
                    hr = ClipVolumeShow();
                } else if (subInterface == DELETE_IF) {
                    hr = ClipVolumeDelete();
                } else if (subInterface == JOB_IF) {
                    hr = ClipVolumeJob();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            }

        case FILE_IF:{
                if (subInterface == RECALL_IF) {
                    hr = ClipFileRecall();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            }

        case MEDIA_IF:{
                if (subInterface == SYNCHRONIZE_IF) {
                    hr = ClipMediaSynchronize();
                } else if (subInterface == RECREATEMASTER_IF) {
                    hr = ClipMediaRecreateMaster();
                } else if (subInterface == DELETE_IF) {
                    hr = ClipMediaDelete();
                } else if (subInterface == SHOW_IF) {
                    hr = ClipMediaShow();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            }

        default:{
                hr = E_NOINTERFACE;
                break;
            }
        }

        exit:

        ClipHandleErrors(hr,
                         intrface,
                         subInterface);

        ClipCleanup();
        ClipUninitializeTrace();
        CoUninitialize();

    }WsbCatchAndDo(hr,
                   WsbTraceAndPrint(CLI_MESSAGE_GENERIC_ERROR, WsbHrAsString(hr));
                  );

    CLIP_TRANSLATE_HR_AND_RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cluster\rsclustr\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\cliutils.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    clutils.h

Abstract:

    This module defines internal utilities for CLI unit

Author:

    Ran Kalach (rankala)  3/8/00

--*/

#ifndef _CLIUTILS_
#define _CLIUTILS_

HRESULT ValidateLimitsArg(IN DWORD dwArgValue, IN DWORD dwArgId, IN DWORD dwMinLimit, IN DWORD dwMaxLimit);
HRESULT SaveServersPersistData(void);
HRESULT CliGetVolumeDisplayName(IN IUnknown *pResourceUnknown, OUT WCHAR **ppDisplayName);
HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);
HRESULT FormatFileTime(IN FILETIME ft, OUT WCHAR **ppTimeString);
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen);

#endif // _CLIUTILS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\exe\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\clivol.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    clivol.cpp

Abstract:

    Implements CLI VOLUME sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "fsa.h"
#include "job.h"

static GUID g_nullGuid = GUID_NULL;

// Internal utilities and classes for VOLUME interface
HRESULT SetResourceParams(IN IFsaResource *pResource, IN DWORD dwDfs, IN DWORD dwSize, IN DWORD dwAccess,
                          IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bInclude, IN BOOL bRecursive,
                          IN BOOL bSetDefaults);
HRESULT ShowResourceParams(IN IFsaResource *pResource, IN BOOL bDfs, IN BOOL bSize,
                           IN BOOL bAccess, IN BOOL bRules, IN BOOL bStatistics);
HRESULT FindAndDeleteRule(IN IFsaResource *pResource, IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bDelete);
HRESULT StartJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job, IN BOOL bWait);
HRESULT CancelJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job);
HRESULT QuickUnmanage(IN IFsaResource *pResource);
HRESULT CreateJobName(IN HSM_JOB_TYPE Job, IN IFsaResource *pResource, OUT WCHAR **pJobName);

#define CVOL_INVALID_INDEX      (-1)

class CVolumeEnum
{

// Constructors
public:
    CVolumeEnum(IN LPWSTR *pVolumes, IN DWORD dwNumberOfVolumes, IN BOOL bSkipUnavailable = TRUE);

// Public methods
public:
    HRESULT First(OUT IFsaResource **ppResource);
    HRESULT Next(OUT IFsaResource **ppResource);
    HRESULT ErrorVolume(OUT int *pIndex);

// Private data
protected:
    LPWSTR              *m_pVolumes;
    DWORD               m_dwNumberOfVolumes;

    // If * enumeration or not
    BOOL                m_bAllVols;

    CComPtr<IWsbEnum>   m_pEnumResources;

    // Used only when m_bAllVols == FALSE
    int                 m_nCurrent;
    BOOL                m_bInvalidVol;

    // Used only when m_bAllVols == TRUE
    BOOL                m_bSkipUnavailable;
};

inline
HRESULT CVolumeEnum::ErrorVolume(OUT int *pIndex)
{
    HRESULT     hr = S_FALSE;
    if (m_bInvalidVol) {
        // There was an error with last volume
        hr = S_OK;
    }

    *pIndex = m_nCurrent;

    return(hr);
}

//
// VOLUME inetrafce implementors
//

HRESULT
VolumeManage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
)
/*++

Routine Description:

    Sets volume(s) to be managed by HSM

Arguments:

    Volumes         - List of volumes to manage
    NumberOfVolumes - List size
    Dfs             - Desired free space
    Size            - Minimal size to manage
    Access          - Minimal not-accessed time (in days)
    RulePath        - Path for the rule
    RuleFileSpec    - File specification for the rule
    Include         - Is this an include or exclude rule
    Recursive       - Is the rule recursive or not

Return Value:

    S_OK            - If all the volumes are added to the managed list

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeManage"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;
        CWsbStringPtr   param;

        CComPtr<IHsmServer>             pHsm;
        CComPtr<IWsbCreateLocalObject>  pCreateObj;
        CComPtr<IWsbIndexedCollection>  pMRCollection;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(Dfs, IDS_DFS, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE));
        WsbAffirmHr(ValidateLimitsArg(Size, IDS_MIN_SIZE, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE));
        WsbAffirmHr(ValidateLimitsArg(Access, IDS_NOT_ACCESSED, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY));

        if (INVALID_POINTER_ARG != RuleFileSpec) {
            // Must have a rule path then
            if (INVALID_POINTER_ARG == RulePath) {
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_RULE, NULL);
                WsbThrow(E_INVALIDARG);
            }
        }

        // Get necessary objects
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
        WsbAffirmHr(pHsm->GetManagedResources(&pMRCollection));

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            CComPtr<IHsmManagedResource>    pManagedResource;
            CComPtr<IHsmManagedResource>    pFoundResource;

            // Find out if the volume is the Engine's managed resources list, if not - add it
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmManagedResource, IID_IHsmManagedResource, (void**) &pManagedResource));
            WsbAffirmHr(pManagedResource->InitFromFsaResource(pResource));
            hr = pMRCollection->Find(pManagedResource, IID_IHsmManagedResource, (void**) &pFoundResource);
            if (WSB_E_NOTFOUND == hr) {
                // Add it
                WsbAffirmHr(pMRCollection->Add(pManagedResource));
            } else {
                // Verify no other error
                WsbAffirmHr(hr);

                // No other error: notify the user that parameters will still be set for the already managed volume
                CWsbStringPtr volName;
                WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
                WsbTraceAndPrint(CLI_MESSAGE_ONLY_SET, (WCHAR *)volName, NULL);
            }

            // Set the parameters (whether it was managed before or not)
            WsbAffirmHr(SetResourceParams(pResource, Dfs, Size, Access, RulePath, 
                            RuleFileSpec, Include, Recursive, TRUE));

            pManagedResource = 0;
            pFoundResource = 0;
            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbAssert(CVOL_INVALID_INDEX != index, E_UNEXPECTED);
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeManage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
VolumeUnmanage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Full
)
/*++

Routine Description:

    Unmanage volume(s)

Arguments:

    Volumes         - List of volumes to manage
    NumberOfVolumes - List size
    Full            - If TRUE, run unmanage job which recalls all the files back
                    - If FALSE, just remove volume from the managed volumes list.
  
Return Value:

    S_OK            - If all the volumes are unmanaged successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeUnmanage"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Initialize an enumerator object
        // Eumerate also unavailable volumes
        CVolumeEnum volEnum(Volumes, NumberOfVolumes, FALSE);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            if (pResource->IsManaged() == S_OK) {
                BOOL bForceQuick = FALSE;

                // If it is an unavailable volume, must set a quick unmanage
                if (S_OK != pResource->IsAvailable()) {
                    bForceQuick = TRUE;
                }

                // Unmanage the volume 
                if (Full && (! bForceQuick)) {
                    WsbAffirmHr(StartJob(pResource, Unmanage, FALSE));
                } else {
                    WsbAffirmHr(QuickUnmanage(pResource));
                }
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeUnmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
VolumeSet(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
)
/*++

Routine Description:

    Sets parameters for volume(s) which are already managed by HSM

Arguments:

    Volumes         - List of volumes to manage
    NumberOfVolumes - List size
    Dfs             - Desired free space
    Size            - Minimal size to manage
    Access          - Minimal not-accessed time (in days)
    RulePath        - Path for the rule
    RuleFileSpec    - File specification for the rule
    Include         - Is this an include or exclude rule
    Recursive       - Is the rule recursive or not

Return Value:

    S_OK            - If all the parameters are set for all the volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeSet"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;
        CWsbStringPtr   param;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(Dfs, IDS_DFS, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE));
        WsbAffirmHr(ValidateLimitsArg(Size, IDS_MIN_SIZE, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE));
        WsbAffirmHr(ValidateLimitsArg(Access, IDS_NOT_ACCESSED, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY));

        if (INVALID_POINTER_ARG != RuleFileSpec) {
            // Must have a rule path then
            if (INVALID_POINTER_ARG == RulePath) {
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_RULE, NULL);
                WsbThrow(E_INVALIDARG);
            }
        }

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Set the parameters (only if the volume is managed)
            if (pResource->IsManaged() == S_OK) {
                WsbAffirmHr(SetResourceParams(pResource, Dfs, Size, Access, RulePath, 
                                RuleFileSpec, Include, Recursive, FALSE));
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
      
HRESULT
VolumeShow(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Dfs, 
   IN BOOL   Size,
   IN BOOL   Access,
   IN BOOL   Rules,
   IN BOOL   Statistics
)
/*++

Routine Description:

    Shows (prints) parameters for the given volume(s)

Arguments:

    Volumes         - 
    NumberOfVolumes - 
    Dfs             -
    Size            -
    Access          -
    Rules           -
    Statistics      -

Return Value:

    S_OK            - If all the parameters could be retrieved for all volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeShow"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;
        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Show the parameters (only if the volume is managed)
            if (pResource->IsManaged() == S_OK) {
                // Show volume settings
                WsbAffirmHr(ShowResourceParams(pResource, Dfs, Size, Access, Rules, Statistics));
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
          
HRESULT
VolumeDeleteRule(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec
)
/*++

Routine Description:

    Deletes a specific rule from all of the given volumes

Arguments:

    Volumes         - 
    NumberOfVolumes - 
    RulePath        -
    RuleFileSpec    -

Return Value:

    S_OK            - If the rule is found and deleted successfully for all volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeDeleteRule"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        if (INVALID_POINTER_ARG != RuleFileSpec) {
            // Must have a rule path then
            if (INVALID_POINTER_ARG == RulePath) {
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_RULE, NULL);
                WsbThrow(E_INVALIDARG);
            }
        }

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Delete rules only if the volume is managed
            if (pResource->IsManaged() == S_OK) {
                // Delete the rule
                hr = FindAndDeleteRule(pResource, RulePath, RuleFileSpec, TRUE);
                if (WSB_E_NOTFOUND == hr) {
                    CWsbStringPtr volName;
                    WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
                    WsbTraceAndPrint(CLI_MESSAGE_RULE_NOT_FOUND, RulePath, RuleFileSpec, (WCHAR *)volName, NULL);
                }
                WsbAffirmHr(hr);
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeDeleteRule"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
          
HRESULT
VolumeJob(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN HSM_JOB_TYPE Job,
   IN BOOL  RunOrCancel,
   IN BOOL  Synchronous
)
/*++

Routine Description:

    Runs the specified job on the given volume(s)

Arguments:

    Volumes         - 
    NumberOfVolumes - 
    Job             -
    RunOrCancel     -
    Synchronous     -

Return Value:

    S_OK            - If the job is started successfully for all volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeJob"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }
        if ((! RunOrCancel) && Synchronous) {
            // Wait is available only with Run
            WsbTraceAndPrint(CLI_MESSAGE_WAIT_FOR_CANCEL, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            if (pResource->IsManaged() == S_OK) {
                // Run or Cancel a job 
                if (RunOrCancel) {
                    WsbAffirmHr(StartJob(pResource, Job, Synchronous));
                } else {
                    WsbAffirmHr(CancelJob(pResource, Job));
                }
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Internal utilities
//
HRESULT SetResourceParams(IN IFsaResource *pResource, IN DWORD dwDfs, IN DWORD dwSize, IN DWORD dwAccess,
                          IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bInclude, IN BOOL bRecursive,
                          IN BOOL bSetDefaults)
/*++

Routine Description:

    Sets parameters for a specific volume

Arguments:

    pResourse       - A resource object to set parameters for
    ... (see above)

Return Value:

    S_OK            - If all the parameters are set succeessfully for the volume

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("SetResourceParams"), OLESTR(""));

    try {
        // DFS
        if (INVALID_DWORD_ARG != dwDfs) {
            WsbAffirmHr(pResource->SetHsmLevel((ULONG)(dwDfs * FSA_HSMLEVEL_1)));
        } else if (bSetDefaults) {
            dwDfs = HSMADMIN_DEFAULT_FREESPACE;
            WsbAffirmHr(pResource->SetHsmLevel((ULONG)(dwDfs * FSA_HSMLEVEL_1)));
        }

        // Min size
        if (INVALID_DWORD_ARG != dwSize) {
            WsbAffirmHr(pResource->SetManageableItemLogicalSize(dwSize * 1024));
        } else if (bSetDefaults) {
            dwSize = HSMADMIN_DEFAULT_MINSIZE;
            WsbAffirmHr(pResource->SetManageableItemLogicalSize(dwSize * 1024));
        }

        // Not Accessed
        if (INVALID_DWORD_ARG != dwAccess) {
            FILETIME ftAccess = WsbLLtoFT(((LONGLONG)dwAccess) * WSB_FT_TICKS_PER_DAY);
            WsbAffirmHr(pResource->SetManageableItemAccessTime(TRUE, ftAccess));
        } else if (bSetDefaults) {
            FILETIME ftAccess = WsbLLtoFT(((LONGLONG)HSMADMIN_DEFAULT_INACTIVITY) * WSB_FT_TICKS_PER_DAY);
            WsbAffirmHr(pResource->SetManageableItemAccessTime(TRUE, ftAccess));
        }

        // Rules
        if (INVALID_POINTER_ARG != pRulePath) {
            // Verify that Rule does not exist
            hr = FindAndDeleteRule(pResource, pRulePath, pRuleFileSpec, FALSE);
            if (S_OK == hr) {
                // Rule is already there - print a warning message and ignore it
                CWsbStringPtr volName;
                WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
                WsbTraceAndPrint(CLI_MESSAGE_RULE_ALREADY_EXIST, pRulePath, pRuleFileSpec, (WCHAR *)volName, NULL);
                pRulePath = INVALID_POINTER_ARG;
            }
            else if (WSB_E_NOTFOUND == hr) {
                // Rule is not there yet
                hr = S_OK;
            } else {
                // unexpected error - abort
                WsbAffirmHr(hr);
            }
        }

        if (INVALID_POINTER_ARG != pRulePath) {
            CComPtr<IFsaServer>             pFsa;
            CComPtr<IWsbCreateLocalObject>  pCreateObj;
            CComPtr<IWsbCollection>         pDefaultRules;
            CComPtr<IWsbIndexedCollection>  pRulesIndexedCollection;
            CComPtr<IHsmRule>               pRule;
            CComPtr<IWsbCollection>         pCriteriaCollection;
            CComPtr<IHsmCriteria>           pCriteria;

            // Get Fsa server for creating objects in Fsa scope
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));
            WsbAffirmHr(pFsa->QueryInterface(IID_IWsbCreateLocalObject, (void **)&pCreateObj));

            // get rules collection as an indexed collection
            WsbAffirmHr(pResource->GetDefaultRules(&pDefaultRules));
            WsbAffirmHr(pDefaultRules->QueryInterface (IID_IWsbIndexedCollection, (void **) &pRulesIndexedCollection));

            // Create a rule and set parameters
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
            WsbAffirmHr(pRule->SetPath(pRulePath));
            if (INVALID_POINTER_ARG != pRuleFileSpec) {
                WsbAffirmHr(pRule->SetName(pRuleFileSpec));
            } else {
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
            }
            WsbAffirmHr(pRule->SetIsInclude(bInclude));
            WsbAffirmHr(pRule->SetIsUsedInSubDirs(bRecursive));
            WsbAffirmHr(pRule->SetIsUserDefined(TRUE));

            // Set the criteria appropriately, depending on whether it is an include or exclude rule.
            WsbAssertHr(pRule->Criteria(&pCriteriaCollection));
    
            if (bInclude) {
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritManageable, IID_IHsmCriteria, (void**) &pCriteria));
            } else {
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritAlways, IID_IHsmCriteria, (void**) &pCriteria));
            }

            WsbAssertHr(pCriteria->SetIsNegated(FALSE));
            WsbAssertHr(pCriteriaCollection->Add(pCriteria));

            // Now that the rule has been set up properly, add it to the default rules collection.
            WsbAffirmHr(pRulesIndexedCollection->Append(pRule));            
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("SetResourceParams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT ShowResourceParams(IN IFsaResource *pResource, IN BOOL bDfs, IN BOOL bSize,
                           IN BOOL bAccess, IN BOOL bRules, IN BOOL bStatistics)
/*++

Routine Description:

    Get and display parameters for a specific volume

Arguments:

    pResourse       - A resource object to get parameters for
    ... (see above)

Return Value:

    S_OK            - If all the parameters are retrieved succeessfully for the volume

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("ShowResourceParams"), OLESTR(""));

    try {
        CWsbStringPtr    volName;
        CWsbStringPtr    param, param2;
        WCHAR           longData[100];

        WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
        WsbTraceAndPrint(CLI_MESSAGE_VOLUME_PARAMS, (WCHAR *)volName, NULL);

        // Dfs
        if (bDfs) {
            ULONG       hsmLevel;

            WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));
            hsmLevel = hsmLevel / FSA_HSMLEVEL_1;
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_DFS));
            WsbAffirmHr(param2.LoadFromRsc(g_hInstance, IDS_PERCENT_SUFFIX));
            swprintf(longData, OLESTR("%lu"), hsmLevel);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, (WCHAR *)param2, NULL);
        }

        // Min size
        if (bSize) {
            LONGLONG    fileSize;
            ULONG       fileSizeKb;

            WsbAffirmHr(pResource->GetManageableItemLogicalSize(&fileSize));
            fileSizeKb = (ULONG)(fileSize / 1024);  // Show KBytes
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MIN_SIZE));
            WsbAffirmHr(param2.LoadFromRsc(g_hInstance, IDS_KB_SUFFIX));
            swprintf(longData, OLESTR("%lu"), fileSizeKb);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, (WCHAR *)param2, NULL);
        }

        // Not accessed
        if (bAccess) {
            FILETIME    accessTime;
            ULONG       accessTimeDays;
            BOOL        dummy;

            WsbAffirmHr(pResource->GetManageableItemAccessTime(&dummy, &accessTime));
            accessTimeDays = (ULONG)(WsbFTtoLL(accessTime) / WSB_FT_TICKS_PER_DAY);
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOT_ACCESSED));
            WsbAffirmHr(param2.LoadFromRsc(g_hInstance, IDS_DAYS_SUFFIX));
            swprintf(longData, OLESTR("%lu"), accessTimeDays);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, (WCHAR *)param2, NULL);
        }

        //Statistics
        if (bStatistics) {
            LONGLONG    total;
            LONGLONG    free;
            LONGLONG    premigrated;
            LONGLONG    truncated;
            LONGLONG    hsmData;
            LONGLONG    notHsmData;

            WCHAR       pctData[10];
            int         freePct;
            int         premigratedPct;
            int         notHsmDataPct;

            // Get and calculate sizes
            WsbAffirmHr(pResource->GetSizes(&total, &free, &premigrated, &truncated));
            hsmData = premigrated + truncated;
            notHsmData = max((total - free - premigrated ), 0);
            freePct = (int)((free * 100) / total);
            premigratedPct = (int)((premigrated * 100) / total);
            notHsmDataPct = (int)((notHsmData * 100) / total);

            // Print statistics
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_CAPACITY));
            WsbAffirmHr(ShortSizeFormat64(total, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_FREE_SPACE));
            WsbAffirmHr(ShortSizeFormat64(free, longData));
            swprintf(pctData, OLESTR(" (%d%%%%)"), freePct);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, pctData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_NOT_RSS_DATA));
            WsbAffirmHr(ShortSizeFormat64(notHsmData, longData));
            swprintf(pctData, OLESTR(" (%d%%%%)"), notHsmDataPct);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, pctData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_CACHED_DATA));
            WsbAffirmHr(ShortSizeFormat64(premigrated, longData));
            swprintf(pctData, OLESTR(" (%d%%%%)"), premigratedPct);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, pctData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_RSS_DATA));
            WsbAffirmHr(ShortSizeFormat64(hsmData, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

        // Rules
        if (bRules) {
            CComPtr<IWsbCollection>         pDefaultRules;
            CComPtr<IWsbIndexedCollection>  pRulesIndexedCollection;
            CComPtr<IHsmRule>               pHsmRule;
            CWsbStringPtr                    rulePath;
            CWsbStringPtr                    ruleFileSpec;
            BOOL                            include;
            CWsbStringPtr                    includeStr;
            BOOL                            recursive;
            CWsbStringPtr                    recursiveStr;
            ULONG                           count;

            WsbTraceAndPrint(CLI_MESSAGE_RULES_LIST, NULL);

            // Get the rules collection
            WsbAffirmHr(pResource->GetDefaultRules(&pDefaultRules));
            WsbAffirmHr(pDefaultRules->QueryInterface(IID_IWsbIndexedCollection, (void **)&pRulesIndexedCollection));

            // Itterate through the indexed collection
            WsbAffirmHr(pRulesIndexedCollection->GetEntries(&count));
            for (int i = 0; i < (int) count; i++) {
                // Get rule and rule parameters
                WsbAffirmHr(pRulesIndexedCollection->At(i, IID_IHsmRule, (void**) &pHsmRule));
                WsbAffirmHr(pHsmRule->GetPath(&rulePath, 0));
                WsbAffirmHr(pHsmRule->GetName(&ruleFileSpec, 0));
                include = (S_OK == pHsmRule->IsInclude()) ? TRUE : FALSE;
                recursive = (S_OK == pHsmRule->IsUsedInSubDirs()) ? TRUE : FALSE;

                // Print rule
                if (include) {
                    WsbAffirmHr(includeStr.LoadFromRsc(g_hInstance, IDS_INCLUDE_RULE));
                } else {
                    WsbAffirmHr(includeStr.LoadFromRsc(g_hInstance, IDS_EXCLUDE_RULE));
                }
                if (recursive) {
                    WsbAffirmHr(recursiveStr.LoadFromRsc(g_hInstance, IDS_RECURSIVE_RULE));
                } else {
                    WsbAffirmHr(recursiveStr.LoadFromRsc(g_hInstance, IDS_NON_RECURSIVE_RULE));
                }
                WsbTraceAndPrint(CLI_MESSAGE_RULE_SPEC, (WCHAR *)rulePath, (WCHAR *)ruleFileSpec,
                                    (WCHAR *)includeStr, (WCHAR *)recursiveStr, NULL);

                // Free resources before next iteration
                pHsmRule = 0;
                rulePath.Free();
                ruleFileSpec.Free();
                includeStr.Free();
                recursiveStr.Free();
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("ShowResourceParams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT FindAndDeleteRule(IN IFsaResource *pResource, IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bDelete)
/*++

Routine Description:

    Deletes a rule that match the given path & file specification from a specific volume
    If more than one exists, the first one found is deleted

Arguments:

    bDelete         - A flag of whether to delete or just find the rule
    pResourse       - A resource object to delete rule from
    ... (see above)

Return Value:

    S_OK            - If the rule is found and deleted (deleted only if bDelete is TRUE)
    WSB_E_NOTFOUND  - If the rule could not be found

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("DeleteRule"), OLESTR(""));

    try {
        CComPtr<IWsbCollection>         pDefaultRules;
        CComPtr<IWsbIndexedCollection>  pRulesIndexedCollection;
        CComPtr<IHsmRule>               pHsmRule;
        ULONG                           count;
        SHORT                           dummy;

        // Get the default rules collection
        WsbAffirmHr(pResource->GetDefaultRules(&pDefaultRules));
        WsbAffirmHr(pDefaultRules->QueryInterface(IID_IWsbIndexedCollection, (void **) &pRulesIndexedCollection));
        
        // Itterate through the indexed collection
        hr = WSB_E_NOTFOUND;
        WsbAffirmHr(pRulesIndexedCollection->GetEntries(&count));
        for (int i = 0; i < (int)count; i++) {
            WsbAffirmHr(pRulesIndexedCollection->At(i, IID_IHsmRule, (void**)&pHsmRule));
                        
            if (pHsmRule->CompareToPathAndName(pRulePath, pRuleFileSpec, &dummy) == S_OK) {
                if (bDelete) {
                    pHsmRule = 0;
                    WsbAffirmHr(pRulesIndexedCollection->RemoveAt(i, IID_IHsmRule, (void**) &pHsmRule));
                }
                hr = S_OK;
                break;
            }

            // Release before continuing loop
            pHsmRule = 0;
        }

        // If we got to the end of the for loop without a match, hr stays WSB_E_NOTFOUND

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("DeleteRule"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT QuickUnmanage(IN IFsaResource *pResource)
/*++

Routine Description:

    Remove a volume from the set of managed volumes

Arguments:

    pResourse       - A resource object to unmanage

Return Value:

    S_OK            - If the volume is removed from the list of managed volumes successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("QuickUnmanage"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IWsbCreateLocalObject>  pCreateObj;
        CComPtr<IHsmManagedResource>    pManagedResource;
        CComPtr<IWsbIndexedCollection>  pMRCollection;

        // Get Hsm (Engine) server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));

        // Create an object to remove
        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmManagedResource, IID_IHsmManagedResource, (void**) &pManagedResource));
        WsbAffirmHr(pManagedResource->InitFromFsaResource(pResource));

        // Remove from the collection
        WsbAffirmHr(pHsm->GetManagedResources(&pMRCollection));
        WsbAffirmHr(pMRCollection->RemoveAndRelease(pManagedResource));

        // TEMPORARY: Should we call now SaveServersPersistData to flush changes into
        //  servers persistency files ?! What about Manage, Set, ... ?

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("QuickUnmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT StartJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job, IN BOOL bWait)
/*++

Routine Description:

    Start a job of the specified type

Arguments:

    pResourse       - A resource object to start a job on
    Job             - The job type
    bWait           - If TRUE, wait until the job is done
                      If FALSE, return immediately after starting the job

Return Value:

    S_OK            - If the job is started successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("StartJob"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IHsmJob>                pJob;
        CWsbStringPtr                   jobName;
        HSM_JOB_DEF_TYPE                jobType;

        // Set job type
        switch (Job) {
            case CopyFiles:
                jobType = HSM_JOB_DEF_TYPE_MANAGE;
                break;
            case CreateFreeSpace:
                jobType = HSM_JOB_DEF_TYPE_TRUNCATE;
                break;
            case Validate:
                jobType = HSM_JOB_DEF_TYPE_VALIDATE;
                break;
            case Unmanage:
                jobType = HSM_JOB_DEF_TYPE_FULL_UNMANAGE;
                break;
            default:
                WsbThrow(E_INVALIDARG);
        }

        // Create job name
        // TEMPORARY: Should the job name and job object match those that are created by the GUI ?!
        //            If so, RsCreateJobName (rsadutil.cpp) + all the resource strings that it uses,
        //            should be moved from HsmAdmin DLL to RsCommon DLL
        WsbAffirmHr(CreateJobName(Job, pResource, &jobName));

        // If job exists - use it, otherwize, craete and add an appropriate job object
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        hr = pHsm->FindJobByName(jobName, &pJob);
        if (S_OK == hr) {
            // Job already exists

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job yet
            CComPtr<IWsbCreateLocalObject>  pCreateObj;
            CComPtr<IWsbIndexedCollection>  pJobs;
            CComPtr<IWsbIndexedCollection>  pCollection;
            CComPtr<IHsmStoragePool>        pStoragePool;
            GUID                            poolId;
            ULONG                           count;

            hr = S_OK;
            pJob = 0;

            // Create and add the job
            WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmJob, IID_IHsmJob, (void**) &pJob));

            WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
            WsbAffirmHr(pCollection->GetEntries(&count));
            WsbAffirm(1 == count, E_FAIL);
            WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
            WsbAffirmHr(pStoragePool->GetId(&poolId));

            WsbAffirmHr(pJob->InitAs(jobName, NULL, jobType, poolId, pHsm, TRUE, pResource));
            WsbAffirmHr(pHsm->GetJobs(&pJobs));
            WsbAffirmHr(pJobs->Add(pJob));

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

        // Start the job
        WsbAffirmHr(pJob->Start());

        // Wait if required
        if (bWait) {
            WsbAffirmHr(pJob->WaitUntilDone());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("StartJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT CancelJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job)
/*++

Routine Description:

    Cancel a job on the volume

Arguments:

    pResourse       - A resource object to cancel a job for
    Job             - The job type

Return Value:

    S_OK            - If the job is canceled

Notes:
    
    1) The function just issue the cancellation, it does not wait for it to finish
    2) If the job is not found or not started, it is not considered as an error

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CancelJob"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IHsmJob>                pJob;
        CWsbStringPtr                   jobName;
        HSM_JOB_DEF_TYPE                jobType;

        // Set job type
        switch (Job) {
            case CopyFiles:
                jobType = HSM_JOB_DEF_TYPE_MANAGE;
                break;
            case CreateFreeSpace:
                jobType = HSM_JOB_DEF_TYPE_TRUNCATE;
                break;
            case Validate:
                jobType = HSM_JOB_DEF_TYPE_VALIDATE;
                break;
            case Unmanage:
                jobType = HSM_JOB_DEF_TYPE_FULL_UNMANAGE;
                break;
            default:
                WsbThrow(E_INVALIDARG);
        }

        // Create job name
        WsbAffirmHr(CreateJobName(Job, pResource, &jobName));

        // If job exists, try to cancel it
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        hr = pHsm->FindJobByName(jobName, &pJob);
        if (S_OK == hr) {
            // Cancel (we don't care if it's actually running or not)
            WsbAffirmHr(pJob->Cancel(HSM_JOB_PHASE_ALL));

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job, for sure it is not running...
            hr = S_OK;

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CancelJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT
CreateJobName(IN HSM_JOB_TYPE Job, IN IFsaResource *pResource, OUT WCHAR **ppJobName)
/*++

Routine Description:

    Create a job name based on its type and the volume properties

Arguments:

    Job             - The job type
    pResource       - Fsa resource that the job is created for
    ppJobName       - The job name

Return Value:

    S_OK            - The job name is created successfully

Notes:

    This utility uses similar algorithm to RsCreateJobName (rsadutil.cpp).
    Howevere, since RsCreateJobName uses internal HsmAdmin resource strings, the final
    name might be different than the GUI name, especially in a localaized system.
    Therefore, I use here different strings for CLI jobs to ensure consistent behavior.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CreateJobName"), OLESTR(""));

    try {
        CWsbStringPtr    jobPrefix;
        CWsbStringPtr    jobTypeString;
        CWsbStringPtr    volumeName;
        CWsbStringPtr    volumeString;

        // Type string
        switch (Job) {
            case CopyFiles:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_MANAGE));
                break;
            case CreateFreeSpace:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_TRUNCATE));
                break;
            case Validate:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_VALIDATE));
                break;
            case Unmanage:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_FULL_UNMANAGE));
                break;
            default:
                WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(pResource->GetUserFriendlyName(&volumeName, 0));

        // For now, ignore the user-name if it's not a drive letter
        size_t nameLen = wcslen(volumeName);
        if ((nameLen != 3) || (volumeName[1] != L':')) {
            volumeName = L"";
        }

        if (volumeName.IsEqual(L"")) {
            // No drive letter - use the volume name and serial number instead
            ULONG           serial;
            CWsbStringPtr   name;

            WsbAffirmHr(pResource->GetName(&name, 0 ));
            WsbAffirmHr(pResource->GetSerial(&serial));

            if (name == L"" ) {
                // No name, no drive letter - just have serial number
                WsbAffirmHr(volumeString.Alloc(40));
                swprintf(volumeString, L"%8.8lx", serial);
            } else {
                // Use name and serial
                WsbAffirmHr(volumeString.Alloc(40 + wcslen(name)));
                swprintf(volumeString, L"%ls-%8.8lx", (WCHAR *)name, serial);
            }

        } else {
            // Use drive letter
            WsbAffirmHr(volumeString.Alloc(1));
            volumeString[0] = volumeName[0];
            volumeString[1] = L'\0';
        }

        // Create job name
        WsbAffirmHr(jobPrefix.LoadFromRsc(g_hInstance, IDS_JOB_NAME_PREFIX));
        int allocLen = wcslen(jobPrefix) + wcslen(jobTypeString) + wcslen(volumeString) + 40;
        WCHAR* tmpString = (WCHAR*)WsbRealloc(*ppJobName, allocLen * sizeof(WCHAR));
        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppJobName = tmpString;
        swprintf(*ppJobName, jobPrefix, (WCHAR *)jobTypeString, (WCHAR *)volumeString);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CreateJobName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

//
// Enumerator class methods
//

CVolumeEnum::CVolumeEnum(IN LPWSTR *pVolumes, IN DWORD dwNumberOfVolumes, IN BOOL bSkipUnavailable)
/*++

Routine Description:

    Constructor

Arguments:

    pVolumes            - Volumes to enumerate
    dwNumberOfVolumes   - Number of volumes

Return Value:

    None

Notes:
    There are two kinds of enumerations:
    1) If * is specified, the base for the enumeration is the FSA resource collection
       In that case, there could be no error in the input volumes themselves
    2) If a list of volumes is given, the base for the enumeration is this list. This is
       less efficient that using the FSA collection, but it keeps the order of volumes
       according to the input list. If a volume from the list is not valid, the invalid flag is set.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CVolumeEnum::CVolumeEnum"), OLESTR(""));

    try {
        m_pVolumes = pVolumes; 
        m_dwNumberOfVolumes = dwNumberOfVolumes;

        m_nCurrent = CVOL_INVALID_INDEX;
        m_bInvalidVol = FALSE;
        m_bAllVols = FALSE;
        m_bSkipUnavailable = bSkipUnavailable;

        // Check mode of enumeration
        WsbAssert(m_dwNumberOfVolumes > 0, E_INVALIDARG);
        if ((1 == m_dwNumberOfVolumes) && (0 == wcscmp(m_pVolumes[0], CLI_ALL_STR))) {
            // * enumeration
            m_bAllVols = TRUE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolumeEnum::CVolumeEnum"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

HRESULT CVolumeEnum::First(OUT IFsaResource **ppResource)
/*++

Routine Description:

    Gets first volume

Arguments:

    ppResourse      - First resource to get

Return Value:

    S_OK            - If first volume is retrieved
    WSB_E_NOTFOUND  - If no more volumes to enumerate
    E_INVALIDARG    - If volume given by the user is not found
                      (Only on a non * enumeration, m_bInvalidVol is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CVolumeEnum::First"), OLESTR(""));

    try {
        // Get FSA resources collection (only once during the object life time)
        if (!m_pEnumResources) {
            CComPtr<IFsaServer> pFsa;
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));

            WsbAffirmHr(pFsa->EnumResources(&m_pEnumResources));
        }

        if (m_bAllVols) {
            if (m_bSkipUnavailable) {
                // Get first volume, skip unavailable resources
                CComPtr<IFsaResource>   pFindResource;

                hr = m_pEnumResources->First(IID_IFsaResource, (void**)&pFindResource);
                while (S_OK == hr) {
                    if (S_OK == pFindResource->IsAvailable()) {
                        // Found one
                        *ppResource = pFindResource;
                        (*ppResource)->AddRef();
                        break;

                    } else {
                        // Skip it
                        pFindResource = 0;
                    }
                    hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
                }
                WsbAffirmHr(hr);

            } else {
                // Get first volume
                hr = m_pEnumResources->First(IID_IFsaResource, (void**)ppResource);
                WsbAffirmHr(hr);
            }

        } else {
            CWsbStringPtr           volName;
            CWsbStringPtr           findName;
            CComPtr<IFsaResource>   pFindResource;

            // Enumerate user collection and try to find it in FSA
            m_nCurrent = 0;
            if (m_nCurrent >= (int)m_dwNumberOfVolumes) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Validate current name and add trailing backslash if missing
            volName = m_pVolumes[m_nCurrent];
            WsbAssert (NULL != (WCHAR *)volName, E_UNEXPECTED);
            int len = wcslen(volName);
            WsbAssert (0 != len, E_UNEXPECTED);
            if (volName[len-1] != L'\\') {
                volName.Append(OLESTR("\\"));
            }

            // Find it
            hr = m_pEnumResources->First(IID_IFsaResource, (void**)&pFindResource);
            while(S_OK == hr) {
                WsbAffirmHr(pFindResource->GetUserFriendlyName(&findName, 0));
                if (_wcsicmp(volName, findName) == 0) {
                    // Fount it !!
                    *ppResource = pFindResource;
                    (*ppResource)->AddRef();
                    break;
                }

                findName.Free();
                pFindResource = 0;
                hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Volume given by user not found
                m_bInvalidVol = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolumeEnum::First"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CVolumeEnum::Next(OUT IFsaResource **ppResource)
/*++

Routine Description:

    Gets next volume

Arguments:

    ppResourse      - Next resource to get

Return Value:

    S_OK            - If next volume is retrieved
    WSB_E_NOTFOUND  - If no more volumes to enumerate
    E_INVALIDARG    - If volume given by the user is not found
                      (Only on a non * enumeration, m_bInvalidVol is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CVolumeEnum::Next"), OLESTR(""));

    try {
        if (m_bAllVols) {
            if (m_bSkipUnavailable) {
                // Get next volume, skip unavailable resources
                CComPtr<IFsaResource>   pFindResource;

                hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
                while (S_OK == hr) {
                    if (S_OK == pFindResource->IsAvailable()) {
                        // Found one
                        *ppResource = pFindResource;
                        (*ppResource)->AddRef();
                        break;

                    } else {
                        // Skip it
                        pFindResource = 0;
                    }

                    hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
                }
                WsbAffirmHr(hr);

            } else {
                // Get next volume
                hr = m_pEnumResources->Next(IID_IFsaResource, (void**)ppResource);
                WsbAffirmHr(hr);
            }

        } else {
            CWsbStringPtr           volName;
            CWsbStringPtr           findName;
            CComPtr<IFsaResource>   pFindResource;

            // Enumerate user collection and try to find it in FSA
            m_nCurrent++;
            if (m_nCurrent >= (int)m_dwNumberOfVolumes) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Validate current name and add trailing backslash if missing
            volName = m_pVolumes[m_nCurrent];
            WsbAssert (NULL != (WCHAR *)volName, E_UNEXPECTED);
            int len = wcslen(volName);
            WsbAssert (0 != len, E_UNEXPECTED);
            if (volName[len-1] != L'\\') {
                volName.Append(OLESTR("\\"));
            }

            // Find it
            hr = m_pEnumResources->First(IID_IFsaResource, (void**)&pFindResource);
            while(S_OK == hr) {
                WsbAffirmHr(pFindResource->GetUserFriendlyName(&findName, 0));
                if (_wcsicmp(volName, findName) == 0) {
                    // Fount it !!
                    *ppResource = pFindResource;
                    (*ppResource)->AddRef();
                    break;
                }

                findName.Free();
                pFindResource = 0;
                hr = m_pEnumResources->Next( IID_IFsaResource, (void**)&pFindResource );
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Volume given by user not found
                m_bInvalidVol = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolumeEnum::Next"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cli.rc
//
#define IDS_PRODUCT_NAME                103
#define IDC_CURSOR1                     201

#define IDS_RECALL_LIMIT                1024
#define IDS_ADMIN_EXEMPT                1025
#define IDS_CONCURRENCY                 1026
#define IDS_MEDIA_COPIES                1027
#define IDS_HSM_VERSION                 1028
#define IDS_HSM_STATUS                  1029
#define IDS_NOF_CARTRIDGES              1030
#define IDS_NOF_MANAGEABLES             1031
#define IDS_NOF_MANAGED                 1032
#define IDS_REMOTE_DATA                 1033
#define IDS_BYTES_STR                   1034
#define IDS_CONCURRENCY_PRM             1035
#define IDS_MEDIA_COPIES_PRM            1036

#define IDS_DFS                         1056
#define IDS_MIN_SIZE                    1057
#define IDS_NOT_ACCESSED                1058
#define IDS_VOL_FREE_SPACE              1059
#define IDS_VOL_RSS_DATA                1060
#define IDS_VOL_CACHED_DATA             1061
#define IDS_VOL_NOT_RSS_DATA            1062
#define IDS_INCLUDE_RULE                1063
#define IDS_EXCLUDE_RULE                1064
#define IDS_RECURSIVE_RULE              1065
#define IDS_NON_RECURSIVE_RULE          1066
#define IDS_KB_SUFFIX                   1067
#define IDS_DAYS_SUFFIX                 1068
#define IDS_PERCENT_SUFFIX              1069
#define IDS_VOL_CAPACITY                1070
#define IDS_UNLABELED_VOLUME            1071

#define IDS_JOB_MANAGE                  1088
#define IDS_JOB_TRUNCATE                1089
#define IDS_JOB_VALIDATE                1090
#define IDS_JOB_FULL_UNMANAGE           1091
#define IDS_JOB_NAME_PREFIX             1082

#define IDS_CAR_STATUS_NORMAL           1104       
#define IDS_CAR_STATUS_READONLY         1105
#define IDS_CAR_STATUS_RECREATE         1106
#define IDS_CAR_STATUS_ERROR_RO         1107
#define IDS_CAR_STATUS_ERROR_RW         1108
#define IDS_CAR_STATUS_ERROR_INCOMPLETE 1109
#define IDS_CAR_STATUS_ERROR_MISSING    1110

#define IDS_MEDIA_COPY_SET              1120
#define IDS_MEDIA_STATUS                1121
#define IDS_MEDIA_CAPACITY              1122
#define IDS_MEDIA_FREE_SPACE            1123
#define IDS_MEDIA_RSM_NAME              1124
#define IDS_CAR_NAME_UNKNOWN            1125
#define IDS_MEDIA_VERSION               1126
#define IDS_MEDIA_COPY                  1127

#define IDS_BYTES                       1136
#define IDS_ORDERKB                     1137
#define IDS_ORDERMB                     1138
#define IDS_ORDERGB                     1139
#define IDS_ORDERTB                     1140
#define IDS_ORDERPB                     1141
#define IDS_ORDEREB                     1142

#define IDS_CAR_COPYSET_NONE            1152
#define IDS_CAR_COPYSET_INSYNC          1153
#define IDS_CAR_COPYSET_OUTSYNC         1154
#define IDS_CAR_COPYSET_ERROR           1155
#define IDS_CAR_COPYSET_MISSING         1156

#define IDS_SERVICE_STATUS_RUNNING          1178
#define IDS_SERVICE_STATUS_STOPPED          1179
#define IDS_SERVICE_STATUS_START_PENDING    1180
#define IDS_SERVICE_STATUS_STOP_PENDING     1181
#define IDS_SERVICE_STATUS_CONTINUE_PENDING 1182
#define IDS_SERVICE_STATUS_PAUSE_PENDING    1183
#define IDS_SERVICE_STATUS_PAUSED           1184
#define IDS_SERVICE_STATUS_NOT_SETUP        1185
#define IDS_SERVICE_STATUS_NOT_REGISTERED   1186



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H
//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS        WSB_TRACE_BIT_UI // TEMPORARY: should be replaced with WSB_TRACE_BIT_CLI + required support in Wsb Trace
#include <wsb.h>
#include "cli.h"
#include "climsg.h"
#include "rslimits.h"
#include "resource.h"
#include "cliutils.h"

extern HINSTANCE    g_hInstance;

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cli\dll\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmcln.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmcln.cpp

Abstract:

    This component is an provides helper functions to access to the 
    collections maintained by the HSM engine.

Author:

    Cat Brant   [cbrant]   09-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "job.h"
#include "metalib.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

//  Local functions
static HRESULT LoadCollection(IStream* pStream, IWsbIndexedCollection* pIWC);
static HRESULT StoreCollection(IStream* pStream, IWsbIndexedCollection* pIWC);


HRESULT 
CHsmServer::LoadJobs(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for Jobs

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadJobs"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pJobs));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::LoadJobs"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreJobs(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for Jobs.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreJobs"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pJobs));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreJobs"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadJobDefs(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for Job Definitions

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadJobDefs"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pJobDefs));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadJobDefs"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreJobDefs(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for Job Definitons

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreJobDefs"),OLESTR(""));
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pJobDefs));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreJobDefs"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadPolicies(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for policies

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadPolicies"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pPolicies));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadPolicies"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StorePolicies(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for policies.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StorePolicies"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pPolicies));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StorePolicies"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadManagedResources(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for managed resources

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadManagedResources"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pManagedResources));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadManagedResources"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreManagedResources(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for managed resources.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreManagedResources"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pManagedResources));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreManagedResources"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadStoragePools(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for storage pools

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadStoragePools"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pStoragePools));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadStoragePools"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreStoragePools(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for managed resources.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreStoragePools"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pStoragePools));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreStoragePools"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadSegmentInformation(
    void 
    ) 
/*++

Routine Description:

    Loads the persistent data for the segment information

Arguments:

    None

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CHsmServer::LoadSegmentInformation"),OLESTR(""));

    try {
        BOOL                CreateFlag = FALSE;
        CComPtr<ISegDb>     l_pSegmentDatabase;

        // Determine if we should try to create the DB or just open it.
        // If the persistence file was just created we're probably starting
        // for the first time so creating the DB is correct.  Also, if
        // the media count is still zero, then even if there was an old
        // DB that got deleted, it probably didn't have any useful information
        // in it anyway so creating a new one is OK.
        if (m_persistWasCreated || 0 == m_mediaCount) {
            CreateFlag = TRUE;
        }

        // Initialize the Engine database
        //
        WsbAffirmHr(CoCreateInstance( CLSID_CSegDb, 0, CLSCTX_SERVER, IID_ISegDb, (void **)&l_pSegmentDatabase ));
        WsbAffirmHr(GetIDbPath(&tmpString, 0));
        WsbAffirmHr(l_pSegmentDatabase->Initialize(tmpString, m_pDbSys, &CreateFlag));

        WsbAffirmHr(l_pSegmentDatabase->QueryInterface(IID_IWsbDb, (void**) &m_pSegmentDatabase));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadSegmentInformation"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreSegmentInformation(
    void
    ) 
/*++

Routine Description:

  Saves the persistent data for the segment information.

Arguments:

  None

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;
//  CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CHsmServer::StoreSegmentInformation"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAssert(m_pSegmentDatabase != 0, E_POINTER);
//  This should not be necessary for a real DB
//      WsbAffirmHr(m_pSegmentDatabase->Close());
//      WsbAffirmHr(m_pSegmentDatabase->Open());
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreSegmentInformation"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreSegmentInformationFinal(
    void
    ) 
/*++

Routine Description:

  Saves the segment information

Arguments:

  None

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CHsmServer::StoreSegmentInformationFinal"),OLESTR(""));

    try {
        WsbAssert(m_pSegmentDatabase.p != 0, E_POINTER);
//  This should not be necessary for a real DB
//      WsbAffirmHr(m_pSegmentDatabase->Close());
        m_pSegmentDatabase = 0;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreSegmentInformationFinal"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadMessages(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for messages

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadMessages"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pMessages));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadMessages"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreMessages(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for messages.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was saved OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreMessages"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pMessages));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreMessages"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

//  LoadCollection - load a collection from the given stream
static HRESULT LoadCollection(IStream* pStream, IWsbIndexedCollection* pIWC)
{
    HRESULT     hr = S_OK;

    try {
        CComPtr<IPersistStream> pIStream;
        
        WsbAffirm(0 != pStream, E_POINTER);
        WsbAffirm(0 != pIWC, E_POINTER);
        
        //  Load the ordered collection from the persistent file
        WsbAffirmHr(pIWC->QueryInterface(IID_IPersistStream, (void**)&pIStream));
        WsbAffirmHr(pIStream->Load(pStream));
    } WsbCatch(hr);

    return(hr);
}

//  StoreCollection - store a collection to the given stream
static HRESULT StoreCollection(IStream* pStream, IWsbIndexedCollection* pIWC)
{
    HRESULT     hr = S_OK;

    try {
        CComPtr<IPersistStream> pIStream;
        
        // Get the IPersistStream interface for the collection
        WsbAffirm(0 != pStream, E_POINTER);
        WsbAffirm(0 != pIWC, E_POINTER);
        WsbAffirmHr(pIWC->QueryInterface(IID_IPersistStream, (void**)&pIStream));
        
        //  Store the ordered collection to the persistent file
        WsbAffirmHr(pIStream->Save(pStream, TRUE));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmmgdrc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmmgdrc.cpp

Abstract:

    Implementation of CHsmManagedResourceCollection

Author:

    Cat Brant   [cbrant]   24-Jan-1997

Revision History:

--*/

#include "stdafx.h"

#include "resource.h"
#include "wsb.h"
#include "HsmEng.h"
#include "hsmserv.h"
#include "hsmmgdrc.h"
#include "fsa.h"
#include "hsmconn.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG



HRESULT
CHsmManagedResourceCollection::Add(
    IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::Add

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Add"), OLESTR(""));
    try {
        CComPtr<IHsmManagedResource> pHsmResource;
        CComPtr<IUnknown> pResourceUnknown;
        CComPtr<IFsaResource> pFsaResource;
        CComPtr<IHsmServer> pHsmServer;
        
        GUID     hsmId;
        ULONG    level;

        // 
        // Contact the FSA Resource to tell it
        // that it is managed.
        //
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmManagedResource, 
                (void**)&pHsmResource));
        WsbAffirmHr(pHsmResource->GetFsaResource(&pResourceUnknown));
        WsbAffirmHr(pResourceUnknown->QueryInterface(IID_IFsaResource, 
                (void**)&pFsaResource));
        WsbAffirmHr(pFsaResource->GetHsmLevel(&level));        

        // this may have to change if HsmConn starts using the service id (second parameter)
        WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, GUID_NULL, IID_IHsmServer, (void**) &pHsmServer));

        WsbAffirmHr(pHsmServer->GetID(&hsmId));
        WsbAffirmHr(pFsaResource->ManagedBy(hsmId, level, FALSE));
        
        // 
        // If FSA added OK add it to the engine
        //
        WsbAffirmHr(m_icoll->Add(pCollectable));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Add"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmManagedResourceCollection::DeleteAllAndRelease(
    void
    )

/*++

Implements:

  IWsbCollection::DeleteAllAndRelease().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::DeleteAllAndRelease"), OLESTR(""));

    Lock();
    try {

        //  Release the resources without unmanaging them
        if (m_coll) {
            WsbAffirmHr(m_coll->RemoveAllAndRelease());
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::DeleteAllAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Remove(
    IUnknown* pCollectable,
    REFIID riid, 
    void** ppElement
    )

/*++

Implements:

  IWsbCollection::Remove

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Remove"), OLESTR(""));
    try {
        CComPtr<IHsmManagedResource> pHsmResource;
        CComPtr<IUnknown> pResourceUnknown;
        CComPtr<IFsaResource> pFsaResource;
        CComPtr<IHsmServer> pHsmServer;
        
        GUID     hsmId;
        ULONG    level;

        // Contact the FSA Resource to tell it that it is no longer 
        // managed.
        //
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmManagedResource, 
                (void**)&pHsmResource));
        WsbAffirmHr(pHsmResource->GetFsaResource(&pResourceUnknown));
        WsbAffirmHr(pResourceUnknown->QueryInterface(IID_IFsaResource, 
                (void**)&pFsaResource));
        WsbAffirmHr(pFsaResource->GetHsmLevel(&level));        
        
        // this may have to change if HsmConn starts using the service id (second parameter)
        WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, GUID_NULL, IID_IHsmServer, (void**) &pHsmServer));

        WsbAffirmHr(pHsmServer->GetID(&hsmId));
        
        //
        // We don't care if the resource complains that we
        // don't have it.  Just tell the resource and
        // then delete it from our collection
        //
        (void)pFsaResource->ManagedBy(hsmId, level, TRUE);
        
        WsbAffirmHr(m_icoll->Remove(pCollectable, riid, ppElement));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Remove"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmManagedResourceCollection::RemoveAndRelease(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IHsmManagedResourceCollection::RemoveAndRelease().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::RemoveAndRelease"), OLESTR(""));

    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(Remove(pCollectable,  IID_IWsbCollectable, NULL));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::RemoveAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::RemoveAllAndRelease(
    void
    )

/*++

Implements:

  IWsbCollection::RemoveAllAndRelease().

--*/
{
    CComPtr<IWsbCollectable>    pCollectable;
    CComPtr<IWsbEnum>           pEnum;
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::RemoveAllAndRelease"), OLESTR(""));

    Lock();
    try {

        // Get an enumerator
        WsbAffirmHr(Enum(&pEnum));

        // Start at the end of the list, and keep removing from the
        // back. For some types of collections, this may not be the most
        // efficient way to remove all the elements.
        for (hr = pEnum->Last(IID_IWsbCollectable, (void**) &pCollectable);
             SUCCEEDED(hr);
             hr = pEnum->Last(IID_IWsbCollectable, (void**) &pCollectable)) {

            hr = RemoveAndRelease(pCollectable);
            pCollectable = 0;
        }

        // We should have emptied the list.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::RemoveAllAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::FinalConstruct"), OLESTR(""));
    try {
        WsbAffirmHr(CWsbPersistStream::FinalConstruct());
        WsbAssertHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, 
                IID_IWsbIndexedCollection, (void**) &m_icoll));
        WsbAssertHr(m_icoll->QueryInterface(IID_IWsbCollection, 
                (void**)&m_coll));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


void CHsmManagedResourceCollection::FinalRelease(
    )
{
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::FinalRelease"), OLESTR(""));

    // Force a release of the resources
    if (m_coll) {
        m_coll->RemoveAllAndRelease();
    }

    // Let the parent class do his thing.   
    CWsbPersistStream::FinalRelease();

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::FinalRelease"), OLESTR(""));
}


HRESULT
CHsmManagedResourceCollection::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmManagedResourceCollection;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::GetSizeMax"), OLESTR(""));

    try {
        CComPtr<IPersistStream> pPStream;

        WsbAffirmHr(m_icoll->QueryInterface(IID_IPersistStream,
                (void**)&pPStream));
        WsbAffirmHr(pPStream->GetSizeMax(pSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Load"), OLESTR(""));

    try {
        CComPtr<IPersistStream> pPStream;

        WsbAffirmHr(m_icoll->QueryInterface(IID_IPersistStream,
                (void**)&pPStream));
        WsbAffirmHr(pPStream->Load(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        CComPtr<IPersistStream> pPStream;

        WsbAffirmHr(m_icoll->QueryInterface(IID_IPersistStream,
                (void**)&pPStream));
        WsbAffirmHr(pPStream->Save(pStream, clearDirty));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if defined(_DEBUG)
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Test"), OLESTR(""));

    try {
        ULONG entries;
        CComPtr<IWsbLong> pLong1;
        CComPtr<IWsbLong> pLong2;
        CComPtr<IWsbLong> pLong3;
        CComPtr<IWsbLong> pLong4;

        hr = S_OK;

        // Check that collection is empty
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(entries == 0, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        //  Add some elements to the collection
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong1));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong2));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong3));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong4));
        WsbAssertHr(pLong1->SetLong(57));
        WsbAssertHr(pLong2->SetLong(-48));
        WsbAssertHr(pLong3->SetLong(23));
        WsbAssertHr(pLong4->SetLong(187));

        try {
            WsbAssertHr(Add(pLong1));
            WsbAssertHr(Add(pLong2));
            WsbAssertHr(Add(pLong3));
            WsbAssertHr(Add(pLong4));
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(entries == 4, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        // Check the order
/*      try {
            ULONG             fetched;
            int               i;
            CComPtr<IWsbEnum> pEnum;
            CComPtr<IWsbLong> pLong[5];
            LONG              value[4];

            WsbAssertHr(Enum(&pEnum));
            WsbAssertHr(pEnum->First(5, IID_IWsbLong, (void**)&pLong, 
                    &fetched));
            WsbAssert(fetched == 4, E_FAIL);
            for (i = 0; i < 4; i++) {
                WsbAssertHr(pLong[i]->GetLong(&value[i]));
            }
            for (i = 0; i < 3; i++) {
                WsbAssert(value[i] < value[i+1], E_FAIL);
            }
        } WsbCatch(hr);
*/        

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        // Save/load
        try {
            CComPtr<IPersistFile>       pFile;
            CComPtr<IWsbCollection>     pSorted2;

            WsbAssertHr(((IUnknown*)(IWsbPersistStream*)this)->QueryInterface(IID_IPersistFile, 
                    (void**) &pFile));
            WsbAssertHr(pFile->Save(OLESTR("c:\\WsbTests\\WsbSorted.tst"), TRUE));
            pFile = 0;

            WsbAssertHr(CoCreateInstance(CLSID_CHsmManagedResourceCollection, NULL, 
                    CLSCTX_ALL, IID_IPersistFile, (void**) &pFile));
            WsbAssertHr(pFile->Load(OLESTR("c:\\WsbTests\\WsbSorted.tst"), 0));
            WsbAssertHr(pFile->QueryInterface(IID_IWsbCollection, 
                    (void**) &pSorted2));

            WsbAssertHr(pSorted2->GetEntries(&entries));
            WsbAssert(entries == 4, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }
    } WsbCatch(hr);


    // Tally up the results
    if (*failed) {
        hr = S_FALSE;
    } else {
        hr = S_OK;
    }

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // _DEBUG

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmmgdrc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.


Module Name:

    Wsbcltn.h

Abstract:

    These classes provide support for collections (lists) of "collectable"
    objects.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"
#include "Wsbpstbl.h"

#ifndef _HSMMGDRC_
#define _HSMMGDRC_
/*++

Class Name:
    
    CHsmManagedResourceCollection 

Class Description:

    A sorted collection of objects.

--*/

class CHsmManagedResourceCollection : 
    public CWsbPersistStream,
    public IWsbIndexedCollection,
    public IHsmManagedResourceCollection,
    public IWsbTestable,
    public CComCoClass<CHsmManagedResourceCollection,&CLSID_CHsmManagedResourceCollection>
{
public:
    CHsmManagedResourceCollection() {}
BEGIN_COM_MAP(CHsmManagedResourceCollection)
    COM_INTERFACE_ENTRY2(IWsbCollection, IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IHsmManagedResourceCollection)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmManagedResourceCollection)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollection
public:
    STDMETHOD(Add)(IUnknown* pCollectable);
    STDMETHOD(Contains)(IUnknown* pCollectable) {
        return(m_coll->Contains(pCollectable)); }
    STDMETHOD(Enum)(IWsbEnum** ppEnum) {
        return(m_coll->Enum(ppEnum)); }
    STDMETHOD(EnumUnknown)(IEnumUnknown** ppEnum) {
        return(m_coll->EnumUnknown(ppEnum)); }
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElement) {
        return(m_coll->Find(pCollectable, riid, ppElement)); }
    STDMETHOD(GetEntries)(ULONG* pEntries) {
        return(m_coll->GetEntries(pEntries)); }
    STDMETHOD(IsEmpty)(void) {
        return(m_coll->IsEmpty()); }
    STDMETHOD(IsLocked)(void) {
        return(m_coll->IsLocked()); }
    STDMETHOD(Lock)(void) {
        return(m_coll->Lock()); }
    STDMETHOD(OccurencesOf)(IUnknown* pCollectable, ULONG* occurences) {
        return(m_coll->OccurencesOf(pCollectable, occurences)); }
    STDMETHOD(Remove)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(RemoveAndRelease)(IUnknown* pCollectable); 
    STDMETHOD(RemoveAllAndRelease)(void);
    STDMETHOD(Unlock)(void) {
        return(m_coll->Unlock()); }

// IWsbIndexedCollection
    STDMETHOD(AddAt)(IUnknown* pCollectable, ULONG /*index*/) {
        return(Add(pCollectable)); }
    STDMETHOD(Append)(IUnknown* pCollectable) {
        return(Add(pCollectable)); }
    STDMETHOD(At)(ULONG index, REFIID riid, void** ppElement) {
        return(m_icoll->At(index, riid, ppElement)); }
    STDMETHOD(Copy)(ULONG start, ULONG stop, REFIID riid, void** rgElement, 
            ULONG* pElementsFetched) {
        return(m_icoll->Copy(start, stop, riid, rgElement,pElementsFetched)); }
    STDMETHOD(CopyIfMatches)(ULONG start, ULONG stop, IUnknown* pCollectable, 
            ULONG element, REFIID riid, void** rgElement, ULONG* pElementsFetched, 
            ULONG* pStoppedAt) {
        return(m_icoll->CopyIfMatches(start, stop, pCollectable, element,
                riid, rgElement, pElementsFetched, pStoppedAt)); }
    STDMETHOD(First)(REFIID riid, void** ppElement) {
        return(m_icoll->First(riid, ppElement)); }
    STDMETHOD(Index)(IUnknown* pCollectable, ULONG* index) {
        return(m_icoll->Index(pCollectable, index)); }
    STDMETHOD(Last)(REFIID riid, void** ppElement) {
        return(m_icoll->Last(riid, ppElement)); }
    STDMETHOD(Prepend)(IUnknown* pCollectable) {
        return(Add(pCollectable)); }
    STDMETHOD(RemoveAt)(ULONG index, REFIID riid, void** ppElement) {
        return(m_icoll->RemoveAt(index, riid, ppElement)); }

// IHsmManagedResourceCollection
    STDMETHOD(DeleteAllAndRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

// Data
protected:
    CComPtr<IWsbCollection>        m_coll;
    CComPtr<IWsbIndexedCollection> m_icoll;
};

#endif // _HSMMGDRC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmmgdrs.h ===
/////////////////////////////////////////////////////////////////////////////
// HsmMgdRs.h : Declaration of the CHsmServer
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"
#include "wsb.h"

/////////////////////////////////////////////////////////////////////////////


class CHsmManagedResource : 
    public CWsbObject,
    public IHsmManagedResource,
    public CComCoClass<CHsmManagedResource,&CLSID_CHsmManagedResource>
{

public:
    CHsmManagedResource( ) {}
BEGIN_COM_MAP( CHsmManagedResource )
    COM_INTERFACE_ENTRY( IHsmManagedResource )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IHsmManagedResource)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP( )


DECLARE_REGISTRY_RESOURCEID( IDR_CHsmManagedResource )

//CComObjectRoot
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IHsmManagedResource
public:
    STDMETHOD( GetResourceId )( GUID  *pResourceId );
    STDMETHOD( SetResourceId )( GUID  resourceId );
    STDMETHOD( InitFromFsaResource )( IUnknown  *pFsa );
    STDMETHOD( GetFsaResource )( IUnknown  **ppFsa );
    STDMETHOD( CompareToIHsmManagedResource )( IHsmManagedResource* pHsmManagedResource, short* psResult );


// Internal Helper functions

private:
    GUID                            m_ResourceId;
    GUID                            m_HsmId;
    CComPtr<IUnknown>               m_pFsaResourceInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmmgdrs.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmMgdRs.cpp

Abstract:

    This component is an object representation of the HSM managed resource. It
    is both a persistable and collectable.

Author:

    Cat Brant   [cbrant]   13-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "Wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "HsmMgdRs.h"
#include "Fsa.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

HRESULT 
CHsmManagedResource::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbObject::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbTrace(OLESTR("CHsmManagedResource::FinalConstruct: this = %p\n"),
                static_cast<void*>(this));
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_ResourceId = GUID_NULL;
    } WsbCatch(hr);

    return(hr);
}


void CHsmManagedResource::FinalRelease(
    )
{
    WsbTrace(OLESTR("CHsmManagedResource::FinalRelease: this = %p\n"),
            static_cast<void*>(this));
    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();
}


HRESULT 
CHsmManagedResource::GetResourceId(
    OUT GUID *pResourceId
    ) 
/*++

Routine Description:

  See IHsmManagedResource::GetResourceId

Arguments:

  See IHsmManagedResource::GetResourceId

Return Value:
  
    See IHsmManagedResource::GetResourceId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetResourceId"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pResourceId, E_POINTER);

        //Provide the data members
        *pResourceId = m_ResourceId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::GetResourceId"),
        OLESTR("hr = <%ls>, ResourceId = <%ls>>"),WsbHrAsString(hr), WsbPtrToGuidAsString(pResourceId));

    return(hr);
}

HRESULT 
CHsmManagedResource::InitFromFsaResource( 
    IN  IUnknown  *pFsaResource 
    )
/*++

Routine Description:

  See IHsmManagedResource::InitFromFsaResource

Arguments:

  See IHsmManagedResource::InitFromFsaResource

Return Value:
  
    See IHsmManagedResource::InitFromFsaResource

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::InitFromFsaResource"),OLESTR(""));

    try {
        CComPtr<IFsaResource>       l_pFsaResource;
        
        //Make sure we can provide data memebers
        WsbAssert(pFsaResource != 0, E_POINTER);

        //Provide the data members
        WsbAffirmHr(pFsaResource->QueryInterface(IID_IFsaResource, (void**) &l_pFsaResource));
        WsbAffirmHr(l_pFsaResource->GetIdentifier(&m_ResourceId));
        m_pFsaResourceInterface = pFsaResource;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::InitFromFsaResource"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmManagedResource::GetFsaResource(     
    OUT IUnknown  **ppFsa 
    )
        
/*++

Routine Description:

  See IHsmManagedResource::GetFsaResource

Arguments:

  See IHsmManagedResource::GetFsaResource

Return Value:
  
    See IHsmManagedResource::GetFsaResource

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetFsaResource"),OLESTR(""));

    try {
        CComPtr<IUnknown>       l_pFsaResource;
        
        WsbAssert( 0 != ppFsa, E_POINTER);
        //
        // Using the GUID for this managed resource, get the COM
        // IFsaResource interface
        //
        WsbAffirmHr(HsmConnectFromId (HSMCONN_TYPE_RESOURCE, m_ResourceId, IID_IUnknown, (void **)ppFsa) );

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmManagedResource::GetFsaResource"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmManagedResource::SetResourceId
(
    IN GUID ResourceId
    )
 /*++

Routine Description:

  See IHsmManagedResource::Set().

Arguments:

  See IHsmManagedResource::Set().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CHsmManagedResource::SetResourceId"), 
        OLESTR("ResourceId = <%ls>"), 
        WsbGuidAsString(ResourceId));

    m_isDirty = TRUE;
    m_ResourceId = ResourceId;

    WsbTraceOut(OLESTR("CHsmManagedResource::SetResourceId"), OLESTR("hr = <%ls>"),
        WsbHrAsString(S_OK));
    return(S_OK);
}

HRESULT 
CHsmManagedResource::GetClassID (
    OUT LPCLSID pClsId
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pClsId, E_POINTER);
        *pClsId = CLSID_CHsmManagedResource;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsId));
    return(hr);
}

HRESULT 
CHsmManagedResource::GetSizeMax (
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT 
CHsmManagedResource::Load (
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes;

    WsbTraceIn(OLESTR("CHsmManagedResource::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(pStream->Read((void*) &m_ResourceId, sizeof(GUID), &ulBytes));
        WsbAffirm(ulBytes == sizeof(GUID), E_FAIL);

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmManagedResource::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>"), 
        WsbHrAsString(hr), 
        WsbGuidAsString(m_ResourceId));
    return(hr);
}

HRESULT 
CHsmManagedResource::Save (
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes;

    WsbTraceIn(OLESTR("CHsmManagedResource::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(pStream->Write((void*) &m_ResourceId, sizeof(GUID), &ulBytes));
        WsbAffirm(ulBytes == sizeof(GUID), E_FAIL);


        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmManagedResource::Test (
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
#if 0
    HRESULT                 hr = S_OK;
    CComPtr<IHsmManagedResource>        pHsmManagedResource1;
    CComPtr<IHsmManagedResource>        pHsmManagedResource2;
    SHORT                   result;
    GUID                    l_ResourceId;

    WsbTraceIn(OLESTR("CHsmManagedResource::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pHsmManagedResource interface.
        WsbAffirmHr(((IUnknown*)(IHsmManagedResource*) this)->QueryInterface(IID_IHsmManagedResource,
                    (void**) &pHsmManagedResource1));


        try {
            // Set the HsmManagedResource to a value, and see if it is returned.
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CHsmManagedResource));

            WsbAffirmHr(pHsmManagedResource1->GetResourceId(&l_ResourceId));

            WsbAffirm((l_ResourceId == CLSID_CHsmManagedResource), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmManagedResource, NULL, CLSCTX_ALL, IID_IHsmManagedResource, (void**) &pHsmManagedResource2));

            // Check the default values.
            WsbAffirmHr(pHsmManagedResource2->GetResourceId(&l_ResourceId));
            WsbAffirm((l_ResourceId == GUID_NULL), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            // IsEqual()
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
            WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbBool));

            WsbAffirmHr(pHsmManagedResource1->IsEqual(pHsmManagedResource2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
            WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbLong));

            WsbAffirm((pHsmManagedResource1->IsEqual(pHsmManagedResource2) == S_FALSE), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             // CompareTo()
             WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
             WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbBool));

             WsbAffirm((pHsmManagedResource1->CompareTo(pHsmManagedResource2, &result) == S_OK) && (result != 0), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
            WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbLong));

            WsbAffirm(((pHsmManagedResource1->CompareTo(pHsmManagedResource2, &result) == S_FALSE) && (result > 0)), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
             WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbBool));

             WsbAffirm((pHsmManagedResource1->CompareTo(pHsmManagedResource2, &result) == S_OK), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
        // Try out the persistence stuff.
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;

            WsbAffirmHr(pHsmManagedResource1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAffirmHr(pHsmManagedResource2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

            LPOLESTR    szTmp = NULL;
            // The item should be dirty.
            try {
                WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbLong));
                WsbAffirmHr(pFile2->IsDirty());
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Save the item, and remember.
                WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\mngdRes.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // It shouldn't be dirty.
                WsbAffirm((pFile2->IsDirty() == S_FALSE), E_FAIL);

            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Try reading it in to another object.
                WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbLong));
                WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\mngdRes.tst"), 0));

                WsbAffirmHr(pHsmManagedResource1->CompareToIHsmManagedResource(pHsmManagedResource2, &result));
            }WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }
        } WsbCatch(hr);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::Test"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));
#else
    UNREFERENCED_PARAMETER(pTestsPassed);
    UNREFERENCED_PARAMETER(pTestsFailed);
#endif
    return(S_OK);
}


HRESULT CHsmManagedResource::CompareTo (
    IN IUnknown* pCollectable, 
    OUT short* pResult
    ) 
/*++

Routine Description:

        1  : object > value
        0  : object = value
        -1 : object < value
    In addition, the return code is S_OK if the object = value and
    S_FALSE otherwise.

Arguments:


Return Value:

    S_OK        - object = value

    S_FALSE     - object != value

--*/

{
    HRESULT                      hr = S_OK;
    CComPtr<IHsmManagedResource> pHsmManagedResource;

    WsbTraceIn(OLESTR("CHsmManagedResource::CompareTo"), OLESTR(""));


    // Did they give us a valid item to compare to?
    try {
        WsbAssert(pCollectable != NULL, E_POINTER);

        // We need the IWsbLong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmManagedResource, (void**) &pHsmManagedResource));
        hr = pHsmManagedResource->CompareToIHsmManagedResource(this, pResult);
        } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::CompareTo"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}

HRESULT CHsmManagedResource::CompareToIHsmManagedResource (
    IN IHsmManagedResource* pHsmManagedResource, 
    OUT short* pResult
    )
{
    HRESULT                 hr = S_OK;
    GUID                    l_ResourceId;
    BOOL                    areGuidsEqual;


    WsbTraceIn(OLESTR("CHsmManagedResource::CompareToIHsmManagedResource"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pHsmManagedResource != NULL, E_POINTER);

        WsbAffirmHr(((IHsmManagedResource *)pHsmManagedResource)->GetResourceId(&l_ResourceId));

        // Make sure the GUID matches.  Then see if the SegStartLoc is in the range of this entry
        areGuidsEqual = IsEqualGUID(m_ResourceId, l_ResourceId);
        WsbAffirm( (areGuidsEqual == TRUE), S_FALSE); 

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::CompareToIHsmManagedResource"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\cluster\rsclustr\rsclustr.c ===
/*++

Copyright (c) 1999 Microsoft Corp.

Module Name:

    clusres.c

Abstract:

    Resource DLL for Remote Storage Server

Author:

   Ravisankar Pudipeddi (ravisp) 1 Sept 1999

Revision History:

--*/

#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#include <windows.h>
#include <resapi.h>
#include <stdio.h>
#include "userenv.h"
#include "winsvc.h"


#define LOG_CURRENT_MODULE LOG_MODULE_RSCLUSTER

#define SERVICES_ROOT L"SYSTEM\\CurrentControlSet\\Services\\"

#define DBG_PRINT printf

#pragma warning( disable : 4115 )  // named type definition in parentheses
#pragma warning( disable : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )  // nonstandard extension used : bit field types other than int



#pragma warning( default : 4214 )  // nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )  // named type definition in parentheses



//
// Type and constant definitions.
//

#define RSCLUSTER_RESNAME  L"Remote Storage Server"
#define RSCLUSTER_SVCNAME  TEXT("Remote_Storage_Server")

// Handle to service controller,  set by the first create resource call.

SC_HANDLE g_ScHandle = NULL;

typedef struct _RSCLUSTER_RESOURCE {
	RESID			ResId; // for validation
    HRESOURCE       hResource;
    SC_HANDLE       ServiceHandle;
    RESOURCE_HANDLE ResourceHandle;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    LPWSTR          ResourceName;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    CLUS_WORKER     OnlineThread;
    CLUSTER_RESOURCE_STATE  State;
    DWORD           dwServicePid;
    HANDLE          hSem;
} RSCLUSTER_RESOURCE, *PRSCLUSTER_RESOURCE;


//
// Global data.
//

// Event Logging routine.

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_RSClusterFunctionTable;

//
// RSCluster resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
RSClusterResourcePrivateProperties[] = {
    { 0 }
};


//
// Function prototypes.
//

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

RESID
WINAPI
RSClusterOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
RSClusterClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
RSClusterOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
RSClusterOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );

DWORD
WINAPI
RSClusterOffline(
    IN RESID ResourceId
    );

DWORD
RSClusterOfflineThread(
    PCLUS_WORKER pWorker,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );


VOID
WINAPI
RSClusterTerminate(
    IN RESID ResourceId
    );

DWORD
RSClusterDoTerminate(
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );

BOOL
WINAPI
RSClusterLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
RSClusterIsAlive(
    IN RESID ResourceId
    );

BOOL
RSClusterCheckIsAlive(
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );

DWORD
WINAPI
RSClusterResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );


BOOLEAN
WINAPI
DllMain(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( DllHandle );
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);

} // DllMain



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( lstrcmpiW( ResourceType, RSCLUSTER_RESNAME ) != 0 ) {
        return(ERROR_MOD_NOT_FOUND);
    }
    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_RSClusterFunctionTable;

    return(ERROR_SUCCESS);

} // Startup


RESID
WINAPI
RSClusterOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for RSCluster resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        RSClusterStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;

// how many do I need actually??
    HKEY    resKey = NULL;
    PRSCLUSTER_RESOURCE resourceEntry = NULL;
    HCLUSTER hCluster;
 


    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegCreateKey( ResourceKey,
                                  L"Parameters",
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &parametersKey,
                                  &disposition );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }


    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error %1!u!.\n",
                status);
            goto error_exit;
        }
    }


	resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(RSCLUSTER_RESOURCE) );


    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

	ZeroMemory( resourceEntry, sizeof(RSCLUSTER_RESOURCE) );
	
    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;

	resourceEntry->ResourceKey = resKey;
	resourceEntry->hSem= NULL;

    resourceEntry->ResourceName = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceName ) + 1) * sizeof(WCHAR) );
    if ( resourceEntry->ResourceName == NULL ) {
        goto exit;
    }
    lstrcpyW( resourceEntry->ResourceName, ResourceName );


    resourceEntry->hSem=CreateSemaphore(NULL,0,1,L"RemoteStorageServer"); 
    status=GetLastError();
    if(resourceEntry->hSem)
    {
        if(status==ERROR_ALREADY_EXISTS)
        {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Remote Storage is controlled by another resource. Error: %2!u!.\n",status );
            CloseHandle(resourceEntry->hSem);
            resourceEntry->hSem = NULL;
            goto error_exit;
        }  
    }
    else
    {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create semaphore for Remote Storage Server Service  . Error: %2!u!.\n",status );
        goto error_exit;
    }    
    
    status = ERROR_SUCCESS;

    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster, error %1!u!.",
            status );
        goto error_exit;
    }

    resourceEntry->hResource = OpenClusterResource(hCluster, ResourceName);
    status = GetLastError();
    CloseCluster(hCluster);
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.", status );
        goto error_exit;
    }

    resid = (RESID)resourceEntry;

error_exit:
exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resourceEntry != NULL ) {
            LocalFree( resourceEntry->ResourceName );
            LocalFree( resourceEntry );
        }
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return(resid);

} // RSClusterOpen



VOID
WINAPI
RSClusterClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for RSCluster resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
	
	PRSCLUSTER_RESOURCE resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Close request for a nonexistent resource id %p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif


    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }


    RSClusterTerminate( ResourceId );
    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );
    CloseHandle(resourceEntry->hSem);


    LocalFree( resourceEntry->ResourceName );
    LocalFree( resourceEntry );

} // RSClusterClose



DWORD
WINAPI
RSClusterOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for RSCluster resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{

    DWORD               status;
    PRSCLUSTER_RESOURCE resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Online request for a nonexistent resource id %p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOffline;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               (PWORKER_START_ROUTINE)RSClusterOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // RSClusterOnline



DWORD
WINAPI
RSClusterOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    ResourceEntry - A pointer to the RSCLUSTER_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{

    SERVICE_STATUS_PROCESS      ServiceStatus;
    LPWSTR *                    serviceArgArray = NULL;
    DWORD                       serviceArgCount = 0;
    DWORD                       valueSize;
    LPVOID                      Environment = NULL;
    WCHAR *                     p;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;
    DWORD                       cbBytesNeeded, i;
    LPQUERY_SERVICE_CONFIG      lpquerysvcconfig=NULL;
    HANDLE                      processToken = NULL;




    RESOURCE_STATUS     resourceStatus;
    DWORD               status = ERROR_SUCCESS;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    // resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    ResourceEntry->dwServicePid = 0;


    ResourceEntry->ServiceHandle = OpenService( g_ScHandle,
                                                RSCLUSTER_SVCNAME,
                                                SERVICE_ALL_ACCESS );

    if ( ResourceEntry->ServiceHandle == NULL ) {
        status = GetLastError();

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    valueSize = sizeof(QUERY_SERVICE_CONFIG);
AllocSvcConfig:
    lpquerysvcconfig=(LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_FIXED, valueSize);
    if(lpquerysvcconfig==NULL){
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Remote Storage Server: Failed to allocate memory for query_service_config, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!QueryServiceConfig(ResourceEntry->ServiceHandle,
                            lpquerysvcconfig,
                            valueSize,
                            &cbBytesNeeded))
    {
        status=GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER){
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Remote Storage Server: Failed to query service configuration, error= %1!u!.\n",
                         status );
            goto error_exit;
        }

        status=ERROR_SUCCESS; 
        LocalFree(lpquerysvcconfig);
        lpquerysvcconfig=NULL;
        valueSize = cbBytesNeeded;
        goto AllocSvcConfig;
    }

    if (lpquerysvcconfig->dwStartType == SERVICE_DISABLED)
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Remote Storage Server: the service is DISABLED\n");    
        status=ERROR_SERVICE_DISABLED;
        goto error_exit;
    }

    ChangeServiceConfig( ResourceEntry->ServiceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );

    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)&valueSize, sizeof(DWORD), &cbBytesNeeded)))
    {
        status = GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER)
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Remote Storage Server: Failed to query service configuration for size, error= %1!u!.\n",
                status );
            goto error_exit;
        }
        else
            status = ERROR_SUCCESS;
    }

    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS)LocalAlloc(LMEM_FIXED, cbBytesNeeded);

    if ( pSvcFailureActions == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Remote Storage Server: Failed to allocate memory, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)pSvcFailureActions, cbBytesNeeded, &cbBytesNeeded)))
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Remote Storage Server: Failed to query service configuration, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for (i=0; i<pSvcFailureActions->cActions;i++)
    {
        if (pSvcFailureActions->lpsaActions[i].Type == SC_ACTION_RESTART)
            pSvcFailureActions->lpsaActions[i].Type = SC_ACTION_NONE;
    }

    ChangeServiceConfig2(ResourceEntry->ServiceHandle,
                         SERVICE_CONFIG_FAILURE_ACTIONS,
                         pSvcFailureActions);

    if ( 0 ) 
    {
        Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    }
    else        
    {
        BOOL success;

        OpenProcessToken( GetCurrentProcess(), MAXIMUM_ALLOWED, &processToken );

        success = CreateEnvironmentBlock(&Environment, processToken, FALSE );
        if ( processToken != NULL ) {
            CloseHandle( processToken );
        }

        if ( !success ) {
            status = GetLastError();
            goto error_exit;
        }
    }

    if (Environment != NULL) {
        HKEY ServicesKey;
        HKEY hKey;

        p = (WCHAR *)Environment;
        while (*p) {
            while (*p++) {
            }
        }
        valueSize = (DWORD)((PUCHAR)p - (PUCHAR)Environment) + 
                    sizeof(WCHAR);

        status = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                SERVICES_ROOT,
                                0,
                                KEY_READ,
                                &ServicesKey );
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to open services key, error = %1!u!.\n",
                status );
            goto error_exit;
        }

        status = RegOpenKeyExW( ServicesKey,
                                RSCLUSTER_SVCNAME,
                                0,
                                KEY_READ | KEY_WRITE,
                                &hKey );
        RegCloseKey(ServicesKey);
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to open service key, error = %1!u!.\n",
                status );
            goto error_exit;
        }

        status = RegSetValueExW( hKey,
                                 L"Environment",
                                 0,
                                 REG_MULTI_SZ,
                                 Environment,
                                 valueSize );
        RegCloseKey(hKey);
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to set service environment value, error = %1!u!.\n",
                status );
            goto error_exit;
        }
    }

    if ( !StartServiceW( ResourceEntry->ServiceHandle,
                         serviceArgCount,
                         serviceArgArray ) )
    {
        status = GetLastError();

        if (status != ERROR_SERVICE_ALREADY_RUNNING) {

            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to start service. Error: %1!u!.\n",
                         status );
            status = ERROR_SERVICE_NEVER_STARTED;
            goto error_exit;
        }
		
		// add code to stop the service that is running 
		// and start the service again..

    }

    while (!ClusWorkerCheckTerminate(WorkerPtr))  {


		if (!QueryServiceStatusEx(
				ResourceEntry->ServiceHandle,
                SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 
                sizeof(SERVICE_STATUS_PROCESS), &cbBytesNeeded ) )
        {
            status = GetLastError();

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                status );

            goto error_exit;
        }

        if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            break;
        }

        Sleep(250);
    }

    if (ClusWorkerCheckTerminate(WorkerPtr))  {
        goto error_exit;
    }

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {


        (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to start service. Error: %1!u!.\n",
                ERROR_SERVICE_NEVER_STARTED );

        status = ERROR_SERVICE_NEVER_STARTED;
        goto error_exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnline;
    if (!(ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS)) {
        ResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    }

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }
	
	// more setting here to ensure no problems
	ResourceEntry->State = resourceStatus.ResourceState;


    //cleanup
    if (pSvcFailureActions) 
        LocalFree(pSvcFailureActions);
    if (lpquerysvcconfig)
        LocalFree(lpquerysvcconfig);
    LocalFree( serviceArgArray );
    if (Environment != NULL) {
        DestroyEnvironmentBlock(Environment);
    }

    return(status);


} // RSClusterOnlineThread



DWORD
WINAPI
RSClusterOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for RSCluster resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{

	// extra code here
	DWORD status;
	PRSCLUSTER_RESOURCE resourceEntry;


    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Offline request for a nonexistent resource id %p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif


	
	ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               (PWORKER_START_ROUTINE)RSClusterOfflineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);



} // RSClusterOffline


DWORD
RSClusterOfflineThread(
    PCLUS_WORKER pWorker,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings remote storage service resource offline

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    RESOURCE_STATUS resourceStatus;
    DWORD           retryTick = 300;      // 300 msec at a time
    DWORD           status = ERROR_SUCCESS;
    BOOL            didStop = FALSE;
    SERVICE_STATUS  ServiceStatus;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    if ( ResourceEntry->ServiceHandle == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto FnExit;
    }

    while (!ClusWorkerCheckTerminate(pWorker)) {


        status = (ControlService(
                        ResourceEntry->ServiceHandle,
                        (didStop
                         ? SERVICE_CONTROL_INTERROGATE
                         : SERVICE_CONTROL_STOP),
                        &ServiceStatus )
                  ? NO_ERROR
                  : GetLastError());

        if (status == NO_ERROR) {

            didStop = TRUE;

            if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service stopped.\n" );

                //set the status                                    
                ResourceEntry->Online = FALSE;
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service is now offline.\n" );
                break;
            }
        }

        if (status == ERROR_EXCEPTION_IN_SERVICE ||
            status == ERROR_PROCESS_ABORTED ||
            status == ERROR_SERVICE_NOT_ACTIVE) {

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service died or not active any more; status = %1!u!.\n",
                status);
                
            ResourceEntry->Online = FALSE;
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( ResourceEntry->ServiceHandle );
            ResourceEntry->ServiceHandle = NULL;
            ResourceEntry->dwServicePid = 0;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service is now offline.\n" );
            break;

        }

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Offline: retrying...\n" );

        Sleep(retryTick);
    }


FnExit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

} // RSClusterOfflineThread






VOID
WINAPI
RSClusterTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for RSCluster resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
// extra code here

    PRSCLUSTER_RESOURCE resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Terminate request for a nonexistent resource id %p\n",
            ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    RSClusterDoTerminate( resourceEntry );
    resourceEntry->State = ClusterResourceOffline;

} // RSClusterTerminate



DWORD
RSClusterDoTerminate(
    IN PRSCLUSTER_RESOURCE resourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for RSCluster resources.

Arguments:

    ResourceEntry - Supplies resource entry for resource to be terminated

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;
	SERVICE_STATUS ServiceStatus;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );


    ClusWorkerTerminate( &resourceEntry->PendingThread );

    if ( resourceEntry->ServiceHandle != NULL ) 
    {
        DWORD   dwRetryCount= 100;
        BOOL    didStop = FALSE;
        DWORD   dwRetryTick = 300;      // 300 msec at a time
        DWORD   dwStatus;  

            
        while (dwRetryCount--)
        {

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"RSClusterTerminate : calling SCM\n" );

            dwStatus = (ControlService(
                            resourceEntry->ServiceHandle,
                            (didStop
                             ? SERVICE_CONTROL_INTERROGATE
                             : SERVICE_CONTROL_STOP),
                            &ServiceStatus )
                      ? NO_ERROR
                      : GetLastError());

            if (dwStatus == NO_ERROR) 
            {
                didStop = TRUE;
                if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
                {

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Service stopped.\n" );

                    //set the status                                    
                    resourceEntry->Online = FALSE;
                    resourceEntry->dwServicePid = 0;
                    break;
                }
            }

            if (dwStatus == ERROR_EXCEPTION_IN_SERVICE ||
                dwStatus == ERROR_PROCESS_ABORTED ||
                dwStatus == ERROR_SERVICE_NOT_ACTIVE) 
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service died; status = %1!u!.\n",
                    dwStatus);
                
                //set the status                                    
                resourceEntry->Online = FALSE;
                resourceEntry->dwServicePid = 0;
                break;
            }

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"RSClusterTerminate: retrying...\n" );

            Sleep(dwRetryTick);

        }

        
		if (resourceEntry->dwServicePid)
        {
            HANDLE hSvcProcess = NULL;
            
            hSvcProcess = OpenProcess(PROCESS_TERMINATE, 
                FALSE, resourceEntry->dwServicePid);
            if (hSvcProcess)
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"RSClusterTerminate: terminating processid=%1!u!\n",
                    resourceEntry->dwServicePid);
                TerminateProcess(hSvcProcess, 0);
                CloseHandle(hSvcProcess);
            }
        }                
        CloseServiceHandle( resourceEntry->ServiceHandle );
        resourceEntry->ServiceHandle = NULL;
        resourceEntry->dwServicePid = 0;
    }        
    resourceEntry->Online = FALSE;

// // 
	resourceEntry->State = ClusterResourceOffline;
/* 
    if ( status == ERROR_SUCCESS ) {
        ResourceEntry->State = ClusterResourceOffline;
    }

	return(status);
*/
    return(ERROR_SUCCESS);

} // RSClusterDoTerminate



BOOL
WINAPI
RSClusterLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for RSCluster resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PRSCLUSTER_RESOURCE  resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("RSCluster: LooksAlive request for a nonexistent resource id %p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    //
    return(RSClusterCheckIsAlive( resourceEntry ));

} // RSClusterLooksAlive



BOOL
WINAPI
RSClusterIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for RSCluster resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PRSCLUSTER_RESOURCE  resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("RSCluster: IsAlive request for a nonexistent resource id %p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    return(RSClusterCheckIsAlive( resourceEntry ));

} // RSClusterIsAlive



BOOL
RSClusterCheckIsAlive(
    IN PRSCLUSTER_RESOURCE resourceEntry
    )

/*++

Routine Description:

    Check to see if the resource is alive for RSCluster resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{

	SERVICE_STATUS ServiceStatus;
	DWORD status = TRUE;

    if ( !QueryServiceStatus( resourceEntry->ServiceHandle,
                              &ServiceStatus ) ) {

         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError() );
         return(FALSE);
    }



    if ( (ServiceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (ServiceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        status = FALSE;
    }

    if (!status) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed the IsAlive test. Current State is %1!u!.\n",
            ServiceStatus.dwCurrentState );
    }

    return(status);

} // RSClusterCheckIsAlive



DWORD
WINAPI
RSClusterResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for RSCluster resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PRSCLUSTER_RESOURCE  resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("RSCluster: ResourceControl request for a nonexistent resource id %p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // RSClusterResourceControl


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_RSClusterFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         RSCluster,                    // Prefix
                         NULL,                        // Arbitrate
                         NULL,                        // Release
                         RSClusterResourceControl,     // ResControl
                         NULL);                       // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmdeflt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.


Module Name:

    hsmdeflt.cpp

Abstract:

    This component is an provides functions to access the HSM
    default settings.  These settings are maintained in the 
    NT system registry.

Author:

    Cat Brant   [cbrant]   13-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "job.h"
#include "engine.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

enum HSM_PARM_SETTING_VISIBILITY  {
     HSM_PARM_PERSISTANT =  1,    // Always seen in the registry 
     HSM_PARM_INVISIBLE  =  2     // Only written if different from the default 
};


HRESULT 
CHsmServer::CreateDefaultJobs(
    void
    ) 
/*++

Routine Description:

    Creates the default jobs and adds them to the engine's data base.

Arguments:

    None

Return Value:
  
    S_OK:  

--*/
{
    
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJob>            pJob;
    CComPtr<IHsmStoragePool>    pStoragePool;
    GUID                        storagePoolId;

    WsbTraceIn(OLESTR("CHsmServer::CreateDefaultJobs"),OLESTR(""));

    try {

        // Currently the only default job is the manage job.
        if (FindJobByName(HSM_DEFAULT_MANAGE_JOB_NAME, &pJob) == WSB_E_NOTFOUND) {

            // The manage job needs a storage pool, so make sure that one exists.
            hr = m_pStoragePools->First(IID_IHsmStoragePool, (void**) &pStoragePool);

            if (hr == WSB_E_NOTFOUND) {
                WsbAffirmHr(CoCreateInstance(CLSID_CHsmStoragePool, 0, CLSCTX_ALL, IID_IHsmStoragePool, (void**) &pStoragePool));
                WsbAffirmHr(pStoragePool->SetMediaSet(GUID_NULL, OLESTR("Default")));
                WsbAssertHr(m_pStoragePools->Add(pStoragePool));
                //
                // Since we added one, save the data
                //
                WsbAffirmHr(SavePersistData());
                hr = S_OK;
            }
            
            WsbAffirmHr(hr);
            WsbAssertHr(pStoragePool->GetId(&storagePoolId));

            // Create a new job, configure it as a default manage job, and add it
            // to the job collection.
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmJob, 0, CLSCTX_ALL, IID_IHsmJob, (void**) &pJob));
            WsbAffirmHr(pJob->InitAs(HSM_DEFAULT_MANAGE_JOB_NAME, 0, HSM_JOB_DEF_TYPE_MANAGE, storagePoolId, (IHsmServer*) this, FALSE, 0));
            WsbAffirmHr(m_pJobs->Add(pJob));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CreateDefaultJobs"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::GetSavedTraceSettings(
    LONGLONG* pTraceSettings,
    BOOLEAN *pTraceOn
    ) 
/*++

Routine Description:

    Loads the settings for the HSM engine trace

Arguments:

    None

Return Value:
  
    S_OK:  The value was obtained

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetSavedTraceSettings"),OLESTR(""));

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        //
        // Get the values
        //
        WsbAffirmHr(WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_SETTINGS,
                                            dataString, 100, &sizeGot));
        *pTraceSettings  = wcstoul( dataString,  &stopString, 10 );
        
        WsbAffirmHr(WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_ON,
                                            dataString, 100, &sizeGot));
        *pTraceOn  = (BOOLEAN) wcstoul( dataString,  &stopString, 10 );
        
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetSavedTraceSettings"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::SetSavedTraceSettings(
    LONGLONG traceSettings,
    BOOLEAN traceOn
    ) 
/*++

Routine Description:

    Saves the settings for trace in the NT registry.

Arguments:

    None

Return Value:
  
    S_OK:  The value was obtained

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SetSavedTraceSettings"),OLESTR(""));

    try {
        OLECHAR dataString[64];
        //
        // Save the Saved value
        //
        swprintf(dataString, OLESTR("%l64x"), traceSettings);
        WsbAffirmHr(WsbSetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_SETTINGS, 
                                            dataString));
        swprintf(dataString, OLESTR("%d"), traceOn);
        WsbAffirmHr(WsbSetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_ON, 
                                            dataString));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SetSavedTraceSettings"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmeng.cpp ===
/*++

 

Module Name:

    hsmeng.cpp

Abstract:

    DLL main for Engine

Author:

    Ran Kalach          [rankala]         28-July-1999

Revision History:

--*/

// hsmeng.cpp : Implementation of DLL Exports.

// Note: Currently, Engine proxy/stub is compiled into a different DLL.
//      Below is relevant information if it is decided to merge the two DLLs.
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ...int.idl by adding the following 
//      files to the Outputs.
//          ...
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ...ps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"

#include "HsmServ.h"
#include "HsmMgdRs.h"
#include "HsmMgdRc.h"
#include "HsmStgPl.h"
#include "mountmed.h"
#include "task.h"
#include "metalib.h"

#include <stdio.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMENG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_HsmServer, CHsmServer)
    OBJECT_ENTRY(CLSID_CHsmUpgradeRmsDb, CHsmUpgradeRmsDb)
    OBJECT_ENTRY(CLSID_CHsmManagedResource, CHsmManagedResource)
    OBJECT_ENTRY(CLSID_CHsmManagedResourceCollection, CHsmManagedResourceCollection)
    OBJECT_ENTRY(CLSID_CHsmStoragePool, CHsmStoragePool)
    OBJECT_ENTRY(CLSID_CMountingMedia, CMountingMedia)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmserv.h ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmServ.h

Abstract:

    This header file defines the CHsmServer object, which acts as the 'entry point'
    for the HSM Engine.

Author:

    Cat Brant       [cbrant]    24-Jan-1997

Revision History:

    Chris Timmes    [chris.timmes] 11-Sep-1997  - Renamed FindStoragePoolById()
                                                  to FindHsmStoragePoolByMediaSetId()
                                                  and added FindHsmStoragePoolById()

    Chris Timmes    [chris.timmes] 22-Sep-1997  - Added FindMediaIdByDisplayName()
                                                  and RecreateMaster() methods to
                                                  IHsmServer

    Chris Timmes    [chris.timmes] 21-Oct-1997  - Added MarkMediaForRecreation()
                                                  method to IHsmServer

    Chris Timmes    [chris.timmes] 18-Nov-1997  - Added CreateTask() method to IHsmServer

--*/

#ifndef _HSMSERV_H
#define _HSMSERV_H

#include <rswriter.h>


#define ENG_DB_DIRECTORY    OLESTR("EngDb")


class CHsmServer : 
    public CWsbPersistable,
    public IHsmServer,
    public IWsbServer,
    public IWsbCreateLocalObject,
    public CComCoClass<CHsmServer,&CLSID_HsmServer>
{

public:
    CHsmServer( ) {}
BEGIN_COM_MAP( CHsmServer )
    COM_INTERFACE_ENTRY( IHsmServer )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY( IWsbCreateLocalObject )
    COM_INTERFACE_ENTRY( IWsbServer )
END_COM_MAP( )

DECLARE_NOT_AGGREGATABLE( CHsmServer) 

DECLARE_REGISTRY_RESOURCEID( IDR_HsmServer )
DECLARE_PROTECT_FINAL_CONSTRUCT()


// CComObjectRoot
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease( void );

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbServer
public:
    STDMETHOD( GetId )( GUID* pId );
    STDMETHOD( GetRegistryName )( OLECHAR **pRegistryName, ULONG bufferSize );
    STDMETHOD( SetId )( GUID  id );
    STDMETHOD( GetBuildVersion )( ULONG *pBuildVersion );
    STDMETHOD( GetNtProductVersion )( OLECHAR **pNtProductVersion, ULONG bufferSize );
    STDMETHOD( GetNtProductBuild )( ULONG *pNtProductBuild );
    STDMETHOD( GetDatabaseVersion )( ULONG *pDatabaseVersion );
    STDMETHOD( SaveAll )( void );
    STDMETHOD( Unload )( void );
    STDMETHOD( CheckAccess )( WSB_ACCESS_TYPE AccessType );
    STDMETHOD( GetTrace )( OUT IWsbTrace ** ppTrace );
    STDMETHOD( SetTrace )( IN IWsbTrace *pTrace );
    STDMETHOD( DestroyObject )( void );

// IHsmServer
public:
    STDMETHOD( Init )( void );

    STDMETHOD( GetID )( GUID  *phid );
    STDMETHOD( GetDbPath )( OLECHAR** pPath, ULONG bufferSize );
    STDMETHOD( GetIDbPath )( OLECHAR** pPath, ULONG bufferSize );
    STDMETHOD( GetDbPathAndName )( OLECHAR** pPath, ULONG bufferSize );
    STDMETHOD( GetName )( OLECHAR **ppName );

    STDMETHOD( GetHsmExtVerHi )( SHORT *pExtVerHi );
    STDMETHOD( GetHsmExtVerLo )( SHORT *pExtVerLo );
    STDMETHOD( GetHsmExtRev )( SHORT *pExtRev );

    STDMETHOD( GetAutosave )( ULONG* pMilliseconds );
    STDMETHOD( SetAutosave )( ULONG milliseconds );

    STDMETHOD( GetCopyFilesLimit )( ULONG* pLimit );
    STDMETHOD( GetCopyFilesUserLimit )( ULONG* pLimit );
    STDMETHOD( SetCopyFilesUserLimit )( ULONG limit );

    STDMETHOD( GetManagedResources )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( FindHsmStoragePoolById )( GUID StoragePoolId, 
                                            IHsmStoragePool** ppStoragePool );
    STDMETHOD( FindHsmStoragePoolByMediaSetId )( GUID RmsMediaSetId, 
                                            IHsmStoragePool** ppStoragePool );
    STDMETHOD( FindMediaIdByDescription )( IN OLECHAR* description, 
                                            OUT GUID* pMediaId );
    STDMETHOD( FindStoragePoolByName )(OLECHAR* name, IHsmStoragePool** ppStoragePool );
    STDMETHOD( GetStoragePools )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetOnlineInformation )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetMessages )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetUsrToNotify )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetJobs )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( FindJobByName )(OLECHAR* name, IHsmJob** ppJob );
    STDMETHOD( GetJobDefs )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetPolicies )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetActions )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetCriteria )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetMediaRecs )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetMountingMedias ) ( IWsbIndexedCollection  **ppCollection);

    STDMETHOD( LockMountingMedias )( void );
    STDMETHOD( UnlockMountingMedias )( void );

    STDMETHOD( GetNextMedia )( LONG *pNextMedia );
    STDMETHOD( GetSegmentDb )( IWsbDb  **ppDb);
    STDMETHOD( BackupSegmentDb )( void );
    STDMETHOD( GetHsmFsaTskMgr )( IHsmFsaTskMgr  **ppHsmFsaTskMgr);
    STDMETHOD( SaveMetaData )( void  );
    STDMETHOD( SavePersistData )( void  );
    STDMETHOD( CloseOutDb )( void );
    STDMETHOD( CancelAllJobs )( void );
    STDMETHOD( AreJobsEnabled )( void );
    STDMETHOD( EnableAllJobs )( void );
    STDMETHOD( DisableAllJobs )( void );
    STDMETHOD( RestartSuspendedJobs )( void );
    
    STDMETHOD( CreateTask )( IN const OLECHAR * jobName, IN const OLECHAR * jobParameters, 
                             IN const OLECHAR * jobComments, 
                             IN const TASK_TRIGGER_TYPE jobTriggerType, 
                             IN const WORD jobStartHour, IN const WORD jobStartMinute, 
                             IN const BOOL scheduledJob );

    STDMETHOD( CreateTaskEx )( IN const OLECHAR * jobName, IN const OLECHAR * jobParameters, 
                               IN const OLECHAR * jobComments, 
                               IN const TASK_TRIGGER_TYPE jobTriggerType, 
                               IN const SYSTEMTIME runTime,
                               IN const DWORD runOccurrence,
                               IN const BOOL scheduledJob );

    STDMETHOD( CancelCopyMedia )( void );
    STDMETHOD( MarkMediaForRecreation )( IN REFGUID masterMediaId );
    STDMETHOD( RecreateMaster )( IN REFGUID masterMediaId, USHORT copySet );
    STDMETHOD( SynchronizeMedia )( GUID poolId, USHORT copySet );
    STDMETHOD( GetHsmMediaMgr )( IRmsServer  **ppHsmMediaMgr);

    STDMETHOD( ResetSegmentValidMark )( void );
    STDMETHOD( ResetMediaValidBytes )( void );

    STDMETHOD( GetSegmentPosition )( IN REFGUID bagId, 
                                     IN LONGLONG fileStart,
                                     IN LONGLONG fileSize, 
                                     OUT GUID* pPosMedia,
                                     OUT LONGLONG* pPosOfffset );
// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IWsbCreateLocalServer
    STDMETHOD( CreateInstance )( REFCLSID rclsid, REFIID riid, void **ppv );

// Internal Helper functions
    STDMETHOD( Autosave )(void);
    STDMETHOD( LoadJobs )( IStream* pStream  );
    STDMETHOD( StoreJobs )( IStream* pStream );
    STDMETHOD( LoadJobDefs )( IStream* pStream );
    STDMETHOD( StoreJobDefs )( IStream* pStream );
    STDMETHOD( LoadPolicies )( IStream* pStream  );
    STDMETHOD( StorePolicies )( IStream* pStream );
    STDMETHOD( LoadManagedResources )( IStream* pStream  );
    STDMETHOD( StoreManagedResources )( IStream* pStream );
    STDMETHOD( LoadStoragePools )( IStream* pStream  );
    STDMETHOD( StoreStoragePools )( IStream* pStream );
    STDMETHOD( LoadSegmentInformation )( void  );
    STDMETHOD( StoreSegmentInformation )( void );
    STDMETHOD( StoreSegmentInformationFinal )( void );
    STDMETHOD( LoadMessages )( IStream* pStream  );
    STDMETHOD( StoreMessages )( IStream* pStream );
    STDMETHOD( LoadPersistData )( void  );
    STDMETHOD( NotifyAllJobs )(HSM_JOB_STATE jobState);
    STDMETHOD( CreateDefaultJobs )( void );
    STDMETHOD( GetSavedTraceSettings )( LONGLONG  *pTraceSettings, BOOLEAN *pTraceOn);
    STDMETHOD( SetSavedTraceSettings )( LONGLONG  traceSettings, BOOLEAN traceOn);
    STDMETHOD( CheckManagedResources )( void );
    STDMETHOD( InternalSavePersistData)( void );
    STDMETHOD( CancelMountingMedias ) (void);
    void StopAutosaveThread(void);

protected:
    ULONG                           m_autosaveInterval; // Autosave interval in 
                                                        // milliseconds; 0 turns it off
    HANDLE                          m_autosaveThread;
    HANDLE                          m_savingEvent;      // An event for synchronizing saving of persistent data
    HANDLE                          m_terminateEvent;   // An event for signaling termination to the autosave thread
    HANDLE                          m_CheckManagedResourcesThread;
    GUID                            m_hId;
    CWsbStringPtr                   m_name;
    CWsbStringPtr                   m_dir;
    BOOL                            m_initializationCompleted;
    BOOL                            m_persistWasCreated; // TRUE if persistence file was created

    ULONG                           m_traceSettings;
    BOOL                            m_traceOn;
    BOOL                            m_cancelCopyMedia;
    BOOL                            m_inCopyMedia;
    BOOL                            m_Suspended;
    BOOL                            m_JobsEnabled;     // Not persistent !!

    CWsbStringPtr                   m_dbPath;
    CComPtr<IHsmFsaTskMgr>          m_pHsmFsaTskMgr;
    CComPtr<IRmsServer>             m_pHsmMediaMgr;
    CRssJetWriter                   *m_pRssWriter;

    CComPtr<IWsbTrace>              m_pTrace;
    CComPtr<IWsbDbSys>              m_pDbSys;
    CComPtr<IWsbDb>                 m_pSegmentDatabase;
    CComPtr<IWsbIndexedCollection>  m_pJobs;
    CComPtr<IWsbIndexedCollection>  m_pJobDefs;
    CComPtr<IWsbIndexedCollection>  m_pPolicies;
    CComPtr<IWsbIndexedCollection>  m_pManagedResources;
    CComPtr<IWsbIndexedCollection>  m_pStoragePools;
    CComPtr<IWsbIndexedCollection>  m_pMessages;
    CComPtr<IWsbIndexedCollection>  m_pOnlineInformation;
    CComPtr<IWsbIndexedCollection>  m_pMountingMedias;

    LONG                            m_mediaCount;

    ULONG                           m_buildVersion;
    ULONG                           m_databaseVersion;

    ULONG                           m_copyfilesUserLimit;

    CRITICAL_SECTION                m_JobDisableLock;
    CRITICAL_SECTION                m_MountingMediasLock;
};

class CHsmUpgradeRmsDb :
    public CWsbPersistable,
    public IHsmUpgradeRmsDb,
    public CComCoClass<CHsmUpgradeRmsDb,&CLSID_CHsmUpgradeRmsDb>
{
public:
    CHsmUpgradeRmsDb( ) {}
BEGIN_COM_MAP( CHsmUpgradeRmsDb )
    COM_INTERFACE_ENTRY( IHsmUpgradeRmsDb )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
END_COM_MAP( )

DECLARE_REGISTRY_RESOURCEID( IDR_HsmUpgradeRmsDb )

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmUpgradeRmsDb
    STDMETHOD(Init)( IRmsServer *pHsmMediaMgr);

private:
    IRmsServer  *m_pServer;
};

#endif // _HSMSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmstgpl.h ===
/////////////////////////////////////////////////////////////////////////////
// HsmStgPl.h : Declaration of the CHsmStoragePool collectable
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"
#include "wsb.h"

/////////////////////////////////////////////////////////////////////////////


class CHsmStoragePool : 
    public CWsbObject,
    public IHsmStoragePool,
    public CComCoClass<CHsmStoragePool,&CLSID_CHsmStoragePool>
{

public:
    CHsmStoragePool( ) {}
BEGIN_COM_MAP( CHsmStoragePool )
    COM_INTERFACE_ENTRY( IHsmStoragePool )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IHsmStoragePool)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP( )


DECLARE_REGISTRY_RESOURCEID( IDR_CHsmStoragePool )

//CComObjectRoot
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IHsmStoragePool
public:
    STDMETHOD( GetId )( GUID  *pId );
    STDMETHOD( SetId )( GUID  Id );
    STDMETHOD( GetMediaSet)( GUID *pMediaSetId, BSTR *pMediaSetName );
    STDMETHOD( SetMediaSet)( GUID mediaSetId, BSTR mediaSetName );
    STDMETHOD( GetNumOnlineMedia )( ULONG *pNumOnlineMedia );
    STDMETHOD( SetNumOnlineMedia )( ULONG numOnlineMedia );
    STDMETHOD( GetNumMediaCopies )( USHORT *pNumMediaCopies );
    STDMETHOD( SetNumMediaCopies )( USHORT numMediaCopies );
    STDMETHOD( GetManagementPolicy )( GUID *pManagementPolicyId );
    STDMETHOD( SetManagementPolicy )( GUID managementPolicyId );
    STDMETHOD( InitFromRmsMediaSet )( IUnknown  *pRmsMediaSet );
    STDMETHOD( GetRmsMediaSet )( IUnknown  **ppRmsMediaSet );

    STDMETHOD( CompareToIHsmStoragePool )( IHsmStoragePool* pHsmStoragePool, short* psResult );

    STDMETHOD( GetMediaSetType )( USHORT *pMediaType );

// Internal Helper functions

private:
    GUID                            m_Id;               //HSM engine storage pool ID
    GUID                            m_MediaSetId;       //HSM RMS/NTMS media pool ID
    GUID                            m_PolicyId;         //None for Sakkara
    ULONG                           m_NumOnlineMedia;   //None for Sakkara                      
    USHORT                          m_NumMediaCopies;   //Number of media copies
    CWsbBstrPtr                     m_MediaSetName;     //HSM RMS/NTMS media pool name
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmstgpl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmStgPl.cpp

Abstract:

    This component is an object representation of the HSM Storage Pool. It
    is both a persistable and collectable.

Author:

    Cat Brant   [cbrant]   09-Feb-1997

Revision History:

--*/


#include "stdafx.h"
#include "Wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "HsmStgPl.h"
#include "Fsa.h"
#include "Rms.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

HRESULT 
CHsmStoragePool::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbObject::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        
        m_MediaSetId = GUID_NULL;
        m_PolicyId = GUID_NULL;
        m_NumOnlineMedia = 0;
        m_NumMediaCopies = 0;
        m_MediaSetName = "  ";
        
        WsbAffirmHr(CoCreateGuid( &m_Id ));
        
    } WsbCatch(hr);

    return(hr);
}

HRESULT 
CHsmStoragePool::GetId(
    OUT GUID *pId
    ) 
/*++

Routine Description:

  See IHsmStoragePool::GetId

Arguments:

  See IHsmStoragePool::GetId

Return Value:
  
    See IHsmStoragePool::GetId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::GetId"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pId, E_POINTER);

        //Provide the data members
        *pId = m_Id;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::GetId"),
        OLESTR("hr = <%ls>, Id = <%ls>>"),WsbHrAsString(hr), WsbPtrToGuidAsString(pId));

    return(hr);
}

HRESULT 
CHsmStoragePool::SetId(
    GUID Id
    ) 
/*++

Routine Description:

  See IHsmStoragePool::SetId

Arguments:

  See IHsmStoragePool::SetId

Return Value:
  
    See IHsmStoragePool::SetId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::SetId"),OLESTR("Id = <%ls>>"), WsbGuidAsString(Id));

    try {

        //Provide the data members
        m_Id = Id;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::SetId"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmStoragePool::GetClassID (
    OUT LPCLSID pClsId
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pClsId, E_POINTER);
        *pClsId = CLSID_CHsmStoragePool;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsId));
    return(hr);
}

HRESULT 
CHsmStoragePool::GetSizeMax (
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::GetSizeMax"), OLESTR(""));

    try {
        ULONG nameLen;
        
        WsbAssert(0 != pcbSize, E_POINTER);
        
        nameLen = SysStringByteLen(m_MediaSetName);

        pcbSize->QuadPart = ((3 * WsbPersistSizeOf(GUID)) +  // m_id + m_MediaSetID + m_PolicyId
                             WsbPersistSizeOf(ULONG) +       // m_NumOnlineMedia
                             WsbPersistSizeOf(USHORT) +      // m_NumMediaCopies
                             nameLen);                       // m_MediaSetName
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT 
CHsmStoragePool::Load (
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);


        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_MediaSetId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_PolicyId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumOnlineMedia));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumMediaCopies));
        m_MediaSetName.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_MediaSetName));
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmStoragePool::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>"), 
        WsbHrAsString(hr), 
        WsbGuidAsString(m_Id));
    return(hr);
}

HRESULT 
CHsmStoragePool::Save (
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_Id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_MediaSetId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_PolicyId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_NumOnlineMedia));
        WsbAffirmHr(WsbSaveToStream(pStream, m_NumMediaCopies));
        WsbAffirmHr(WsbBstrToStream(pStream, m_MediaSetName));
        
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmStoragePool::Test (
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmStoragePool>        pHsmStoragePool1;
    CComPtr<IHsmStoragePool>        pHsmStoragePool2;
    GUID                    l_Id;

    WsbTraceIn(OLESTR("CHsmStoragePool::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pHsmStoragePool interface.
        WsbAffirmHr(((IUnknown*)(IHsmStoragePool*) this)->QueryInterface(IID_IHsmStoragePool,
                    (void**) &pHsmStoragePool1));


        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmStoragePool, NULL, CLSCTX_ALL, IID_IHsmStoragePool, (void**) &pHsmStoragePool2));

            // Check the default values.
            WsbAffirmHr(pHsmStoragePool2->GetId(&l_Id));
            WsbAffirm((l_Id == GUID_NULL), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::Test"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(S_OK);
}

HRESULT 
CHsmStoragePool::CompareTo (
    IN IUnknown* pCollectable, 
    OUT short* pResult
    ) 
/*++

Routine Description:

        1  : object > value
        0  : object = value
        -1 : object < value
    In addition, the return code is S_OK if the object = value and
    S_FALSE otherwise.

Arguments:


Return Value:

    S_OK        - object = value

    S_FALSE     - object != value

--*/

{
    HRESULT                  hr = S_OK;
    CComPtr<IHsmStoragePool> pHsmStoragePool;

    WsbTraceIn(OLESTR("CHsmStoragePool::CompareTo"), OLESTR(""));


    // Did they give us a valid item to compare to?
    try {
        WsbAssert(pCollectable != NULL, E_POINTER);

        // We need the IWsbLong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmStoragePool, (void**) &pHsmStoragePool));
        hr = pHsmStoragePool->CompareToIHsmStoragePool(this, pResult);
        } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::CompareTo"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}

HRESULT 
CHsmStoragePool::CompareToIHsmStoragePool (
    IN IHsmStoragePool* pHsmStoragePool, 
    OUT short* pResult
    )
{
    HRESULT                 hr = S_OK;
    GUID                    l_Id;
    BOOL                    areGuidsEqual;


    WsbTraceIn(OLESTR("CHsmStoragePool::CompareToIHsmStoragePool"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pHsmStoragePool != NULL, E_POINTER);

        WsbAffirmHr(((IHsmStoragePool *)pHsmStoragePool)->GetId(&l_Id));

        // Make sure the GUID matches.  Then see if the SegStartLoc is in the range of this entry
        areGuidsEqual = IsEqualGUID(m_Id, l_Id);
        WsbAffirm( (areGuidsEqual == TRUE), S_FALSE); 

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::CompareToIHsmStoragePool"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}

HRESULT 
CHsmStoragePool::GetMediaSet( 
    GUID *pMediaSetId, 
    BSTR *pMediaSetName 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetMediaSet"),OLESTR(""));
    
    try  {
        WsbAssert(0 != pMediaSetId, E_POINTER);
        WsbAssert(0 != pMediaSetName, E_POINTER);
        *pMediaSetName = WsbAllocString( m_MediaSetName );
        
        *pMediaSetId = m_MediaSetId;
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetMediaSet"),
        OLESTR("hr = <%ls>, Id = <%ls>>"),WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSetId));
    return( hr );
}    
    

HRESULT 
CHsmStoragePool::SetMediaSet( 
    GUID mediaSetId, 
    BSTR mediaSetName 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::SetMediaSet"),OLESTR(""));
    
    try  {
        m_MediaSetId = mediaSetId;
        m_MediaSetName = mediaSetName;
        
        m_isDirty = TRUE;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetMediaSet"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetNumOnlineMedia( 
    ULONG *pNumOnlineMedia 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    WsbTraceIn(OLESTR("CHsmStoragePool::GetNumOnlineMedia"),OLESTR(""));
    
    try  {
        
        WsbAffirm(0 != pNumOnlineMedia, E_POINTER);
        *pNumOnlineMedia = m_NumOnlineMedia;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetNumOnlineMedia"),
        OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::SetNumOnlineMedia( 
    ULONG numOnlineMedia 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    WsbTraceIn(OLESTR("CHsmStoragePool::SetNumOnlineMedia"),OLESTR(""));
    
    m_NumOnlineMedia = numOnlineMedia;
    m_isDirty = TRUE;
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetNumOnlineMedia"),
        OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetNumMediaCopies( 
    USHORT *pNumMediaCopies 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    WsbTraceIn(OLESTR("CHsmStoragePool::GetNumMediaCopies"),OLESTR(""));
    
    try  {
        
        WsbAffirm(0 != pNumMediaCopies, E_POINTER);
        *pNumMediaCopies = m_NumMediaCopies;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetNumMediaCopies"),
        OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::SetNumMediaCopies( 
    USHORT numMediaCopies 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::SetNumMediaCopies"),OLESTR(""));

    m_NumMediaCopies = numMediaCopies;
    m_isDirty = TRUE;
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetNumMediaCopies"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}    

HRESULT 
CHsmStoragePool::GetManagementPolicy( 
    GUID *pManagementPolicyId 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetManagementPolicy"),OLESTR(""));
    
    try  {
        
        WsbAffirm(0 != pManagementPolicyId, E_POINTER);
        *pManagementPolicyId = m_PolicyId;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetManagementPolicy"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::SetManagementPolicy( 
    GUID managementPolicyId 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::SetManagementPolicy"),OLESTR(""));

    m_PolicyId = managementPolicyId;
    m_isDirty = TRUE;
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetManagementPolicy"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetRmsMediaSet (
    IUnknown **ppIRmsMediaSet
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetRmsMediaSet"),OLESTR(""));
    
    try  {
        WsbAffirm(0 != ppIRmsMediaSet, E_POINTER );
        hr = E_NOTIMPL;
        
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmStoragePool::GetRmsMediaSet"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::InitFromRmsMediaSet (
    IUnknown *pIRmsMediaSet
    )
/*++

Routine Description:                                                                

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::InitFromRmsMediaSet"),OLESTR(""));
    
    try  {
        WsbAffirm(0 != pIRmsMediaSet, E_POINTER );
        //
        // Get the real interface                                                                            
        //
        CComPtr<IRmsMediaSet>       l_pIRmsMediaSet;
        WsbAffirmHr(pIRmsMediaSet->QueryInterface(IID_IRmsMediaSet, (void **)&l_pIRmsMediaSet));
        WsbAffirmHr(l_pIRmsMediaSet->GetMediaSetId(&m_MediaSetId));
        m_MediaSetName.Free();
        WsbAffirmHr(l_pIRmsMediaSet->GetName(&m_MediaSetName));

        // Set in the Registry which media type is being used
        //  Note: This hack should be removed when HSM supports more than one media type on the same system
        LONG            mediaType;
        DWORD           dwType;
        WsbAffirmHr(l_pIRmsMediaSet->GetMediaSupported(&mediaType));
        switch (mediaType) {
        case RmsMediaOptical: 
        case RmsMediaFixed:
        case RmsMediaDVD:
            dwType = HSM_VALUE_TYPE_DIRECTACCESS;
            break;
        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:
            dwType = HSM_VALUE_TYPE_SEQUENTIAL;
            break;
        default:
            // This is not expected, however, we set tape as default
            WsbTraceAlways(OLESTR("CHsmStoragePool::InitFromRmsMediaSet : Got an unexpected media type %ld !!!\n"), mediaType);
            dwType = HSM_VALUE_TYPE_SEQUENTIAL;
            break;
        }

        WsbAffirmHr(WsbSetRegistryValueDWORD(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MEDIA_TYPE, dwType));

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmStoragePool::InitFromRmsMediaSet"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetMediaSetType (
    USHORT *pMediaType
    )
/*++

Routine Description:                                                                

  Gets the media type of the corresponding media set

Arguments:

  pMediaType - media type, currently, the only options are direct-access or sequential

Return Value:

  S_OK for success

Notes:

  Future: Might consider keeping the media type instead of asking the media-set object again and again -
          Media type is not a dynamic propery. However, this reuires a change in the .col file structure.

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetMediaSetType"),OLESTR(""));
    
    try  {
        WsbAffirm(0 != pMediaType, E_POINTER );

        // Get media-set object
        CComPtr<IHsmServer>         pHsmServer;
        CComPtr<IRmsServer>         pRmsServer;
        CComPtr<IRmsMediaSet>       pRmsMediaSet;

        WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, GUID_NULL, IID_IHsmServer, (void**) &pHsmServer));
        WsbAffirmHr(pHsmServer->GetHsmMediaMgr(&pRmsServer));
        WsbAffirmHr(pRmsServer->CreateObject(m_MediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **)&pRmsMediaSet));

        // Determine media type
        LONG            mediaType;
        WsbAffirmHr(pRmsMediaSet->GetMediaSupported(&mediaType));
        switch (mediaType) {
            case RmsMediaOptical: 
            case RmsMediaFixed:
            case RmsMediaDVD:
                *pMediaType = HSM_VALUE_TYPE_DIRECTACCESS;
                break;
            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                *pMediaType = HSM_VALUE_TYPE_SEQUENTIAL;
                break;
            default:
                // This is not expected, however, we set tape as default
                WsbTraceAlways(OLESTR("CHsmStoragePool::GetMediaSetType : Got an unexpected media type %hu !!!\n"), *pMediaType);
                *pMediaType = HSM_VALUE_TYPE_SEQUENTIAL;
                break;
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmStoragePool::GetMediaSetType"),OLESTR("Media-type = %hu hr = <%ls>"), *pMediaType, WsbHrAsString(hr));

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\makefile.inc ===
$(O)\HsmEng.res: HsmServ.rgs   \
                 HsmMgdRs.rgs  \
                 HsmMgdRc.rgs  \
                 HsmStgPl.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\hsmserv.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmServ.cpp

Abstract:

    This component provides the functions to access the HSM
    IHsmServer interfaces.

Author:

    Cat Brant   [cbrant]   24-Jan-1997

Revision History:

    Chris Timmes    [ctimmes]   11-Sep-1997

    - renamed COM method FindStoragePoolById() to FindHSMStoragePoolByMediaSetId()
      to better reflect its purpose.  Also created new COM method 
      FindHsmStoragePoolById().  Action required since the Engine maintains 2
      sets of (original/master) secondary storage media set ids (GUIDs).  First, 
      the Engine maintains its own 'media set' id, called a Storage Pool id, which
      is only maintained by the Engine.  Second, the Engine also maintains the NT 
      Media Services (NTMS) id, called the Media Set id, which comes from NTMS and 
      is passed to the Engine by RMS (the Remote Storage Subsystem).  (Note that the
      concept of a Storage Pool encompasses more info than that of a Media Set.)
      These 2 lookup functions allow for lookup by either id.

    Chris Timmes    [ctimmes]   22-Sep-1997

    - added new COM methods FindMediaIdByDisplayName() and RecreateMaster().  Changes
      made to enable Copy Set usage.  Code written to be both Sakkara and Phoenix
      compatible.

    Chris Timmes    [ctimmes]   21-Oct-1997  
    
    - added new COM method MarkMediaForRecreation().  Change made to allow 
      RecreateMaster() to be invokable directly from RsLaunch (without going through
      the UI).  

    Chris Timmes    [ctimmes]   18-Nov-1997  
    
    - added new COM method CreateTask().  Change made to move NT Task Scheduler task
      creation code from the UI to the Engine.  Change required to allow Remote
      Storage system to run under LocalSystem account.  CreateTask() is a generic
      method callable by anyone wanting to create any supported type of Remote Storage
      task in Task Scheduler.

--*/

#include "stdafx.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "metalib.h"
#include "task.h"
#include "wsbdb.h"
#include "rsbuild.h"
#include "wsb.h"
#include "ntverp.h"                 // for GetNtProductVersion() and GetNtProductBuild()
#include "Rms.h"
#include "rsevents.h"
#include "HsmEng.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

#define HSM_PERSIST_FILE           "\\RsEng.col"
#define RMS_WIN2K_PERSIST_FILE     "\\RsSub.col"

#define DEFAULT_COPYFILES_USER_LIMIT         10

BOOL g_HsmSaveInProcess  = FALSE;


/////////////////////////////////////////////////////////////////////////////
//


//  Non-member function initially called for autosave thread
static DWORD HsmengStartAutosave(
    void* pVoid
    )
{
    return(((CHsmServer*) pVoid)->Autosave());
}

//  Non-member function run in a separate thread to call CheckManagedResources
static DWORD HsmengStartCheckManagedResources(
    void* pVoid
    )
{
    DWORD result;

    result = ((CHsmServer*) pVoid)->CheckManagedResources();
    return(result);
}


HRESULT
CHsmServer::Autosave(
    void
    )

/*++

Routine Description:

  Implements an autosave loop.

Arguments:

  None.
  
Return Value:

  Doesn't matter.


--*/
{

    HRESULT         hr = S_OK;
    ULONG           l_autosaveInterval = m_autosaveInterval;
    BOOL            exitLoop = FALSE;

    WsbTraceIn(OLESTR("CHsmServer::Autosave"), OLESTR(""));

    try {


        while (m_autosaveInterval && (! exitLoop)) {

            // Wait for termination event, if timeout occurs, check if we can perform Autosave
            switch (WaitForSingleObject(m_terminateEvent, l_autosaveInterval)) {
                case WAIT_OBJECT_0:
                    // Need to terminate
                    WsbTrace(OLESTR("CHsmServer::Autosave: signaled to terminate\n"));
                    exitLoop = TRUE;
                    break;

                case WAIT_TIMEOUT: 
                    // Check if backup need to be performed
                    WsbTrace(OLESTR("CHsmServer::Autosave: Autosave awakened\n"));

                    //  Don't do this if we're suspended
                    if (!m_Suspended) {
                        //  Save data
                        //  NOTE: Because this is a separate thread, there is the possibility
                        //  of a conflict if the main thread is changing some data at the same
                        //  time we're trying to save it.
                        //  If a save is already happening, just skip this one and
                        //  go back to sleep
                        hr = SaveAll();
    
                        //  If the save fails, increase the sleep time to avoid filling
                        //  the event log
                        if (!SUCCEEDED(hr)) {
                            if ((MAX_AUTOSAVE_INTERVAL / 2) < l_autosaveInterval) {
                                l_autosaveInterval = MAX_AUTOSAVE_INTERVAL;
                            } else {
                                l_autosaveInterval *= 2;
                            }
                        } else {
                            l_autosaveInterval = m_autosaveInterval;
                        }
                    }

                    break;  // end of timeout case

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CHsmServer::Autosave: WaitForSingleObject returned error %lu\n"), GetLastError());
                    exitLoop = TRUE;
                    break;

            } // end of switch

        } // end of while

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::Autosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::GetAutosave(
    OUT ULONG* pMilliseconds
    )

/*++

Implements:

  CHsmServer::GetAutosave().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetAutosave"), OLESTR(""));

    try {

        WsbAssert(0 != pMilliseconds, E_POINTER);
        *pMilliseconds = m_autosaveInterval;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetAutosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::SetAutosave(
    IN ULONG milliseconds
    )

/*++

Implements:

  CHsmServer::SetAutosave().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SetAutosave"), OLESTR("milliseconds = <%ls>"), WsbPtrToUlongAsString( &milliseconds ) );

    try {
        // Don't do anything if interval isn't changing
        if (milliseconds != m_autosaveInterval) {
            // Close the current thread
            if (m_autosaveThread) {
                StopAutosaveThread();
            }
            m_autosaveInterval = milliseconds;

            // Start/restart the autosave thread
            if (m_autosaveInterval) {
                DWORD  threadId;

                WsbAffirm((m_autosaveThread = CreateThread(0, 0, HsmengStartAutosave, (void*) this, 0, &threadId)) 
                        != 0, HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SetAutosave"), OLESTR("hr = <%ls> m_runInterval = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString( &m_autosaveInterval ) );

    return(hr);
}


HRESULT CHsmServer::GetID(
    GUID  *phid
    )
{
    if( !phid )
        return E_INVALIDARG;

    *phid = m_hId;

    return S_OK;
}


HRESULT CHsmServer::GetId(
    GUID  *phid
    )
{
    return (GetID(phid));
}


HRESULT CHsmServer::SetId(
    GUID  id
    )
{

    m_hId = id;
    return S_OK;
}


HRESULT
CHsmServer::GetDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmServer::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        WsbAffirmHr(m_dbPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CHsmServer::GetDbPathAndName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmServer::GetDbPathAndName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        tmpString = m_dbPath;
        WsbAffirmHr(tmpString.Append(HSM_PERSIST_FILE));
        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmServer::GetIDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Routine Description:

  Returns the path (directory) for the Engine IDB files

Arguments:

  pPath      - address of pointer to buffer

  bufferSize - size of buffer (or zero)
  
Return Value:

  S_OK  - On success

--*/
{
    HRESULT         hr = S_OK;

    try {
        CWsbStringPtr temp;

        WsbAssert(0 != pPath, E_POINTER); 

        temp = m_dbPath;

        temp.Append(OLESTR("\\"));
        temp.Append(ENG_DB_DIRECTORY);

        WsbAffirmHr(temp.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT CHsmServer::GetName ( 
    OLECHAR **ppName 
    )  
{

    HRESULT hr = S_OK;
    
    try  {
        WsbAssert(0 != ppName,  E_POINTER);
        WsbAffirmHr(m_name.CopyTo(ppName));
    } WsbCatch( hr );
    
    return (hr);
}

HRESULT CHsmServer::GetRegistryName ( 
    OLECHAR **pName, 
    ULONG bufferSize
    )  
{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pName,  E_POINTER);
        
        tmpString = HSM_ENGINE_REGISTRY_NAME;
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}



HRESULT CHsmServer::GetHsmExtVerHi ( 
    SHORT * /*pExtVerHi*/
    )  
{
    return( E_NOTIMPL );
    
}

HRESULT CHsmServer::GetHsmExtVerLo ( 
    SHORT * /*pExtVerLo*/
    )  
{
    return( E_NOTIMPL );
    
}

HRESULT CHsmServer::GetHsmExtRev ( 
    SHORT * /*pExtRev*/
    )  
{
    return( E_NOTIMPL );
    
};


HRESULT CHsmServer::GetManagedResources(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmServer::GetManagedResources"),OLESTR(""));

    //
    // If the resources have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pManagedResources;
        WsbAffirm(m_pManagedResources != 0, E_FAIL);
        m_pManagedResources->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetManagedResources"),OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return (hr);
}


HRESULT CHsmServer::SaveMetaData( 
    void 
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SaveMetaData"), OLESTR(""));

    //
    // Force a save of all metadata
    //

    try {

        if (m_pSegmentDatabase != 0) {
            WsbAffirmHr(StoreSegmentInformation());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SaveMetaData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT CHsmServer::LoadPersistData( 
    void 
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadPersistData"), OLESTR(""));

    //
    // Create persistent collections and attempt to load from file
    //

    try {
        CComPtr<IWsbServer>    pWsbServer;
        CWsbStringPtr          tmpString;

        //  Create the collections
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pJobs ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pJobDefs ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pPolicies ));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmManagedResourceCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pManagedResources ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pStoragePools ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pMessages ));

        // Try to read from the persistence file
        // Note: currently Engine doesn't verify the service id in the Registry
        //  If Engine would ever start without an Fsa in the HSM server process - 
        //  this should be changed
        WsbAffirmHr(((IUnknown*) (IHsmServer*) this)->QueryInterface(IID_IWsbServer, 
                (void**) &pWsbServer));
        WsbAffirmHr(WsbServiceSafeInitialize(pWsbServer, FALSE, TRUE, &m_persistWasCreated));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::LoadPersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT CHsmServer::SavePersistData( 
    void 
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SavePersistData"), OLESTR(""));

    if (FALSE == g_HsmSaveInProcess)  {
        g_HsmSaveInProcess  = TRUE;
        
        //
        // Force a save of all non-meta persistent data
        //
        hr = InternalSavePersistData();
        g_HsmSaveInProcess = FALSE;
    } else  {
        WsbTrace( OLESTR("Save already occurring - so wait"));
        while (TRUE == g_HsmSaveInProcess)  {
            //
            // Sleep a half a second then see if flag
            // is cleared.  We want to wait until the
            // save is done before returning.
            //
            Sleep(500);
        }
    }

    WsbTraceOut(OLESTR("CHsmServer::SavePersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}



HRESULT
CHsmServer::FindHsmStoragePoolById(
    IN GUID StoragePoolId,
    OUT IHsmStoragePool** ppStoragePool
    )

/*++

Implements:

  IHsmServer::FindHsmStoragePoolById().

Routine Description:

    This routine implements the COM method for looking up an HSM (Engine) 
    Storage Pool object by the HSM Storage Pool id (a GUID).  If found, a 
    COM interface pointer to that object is returned.

    After using the Engine's stored pointer to an indexed collection of valid 
    storage pools to obtain an iterator (enumerator) to the collection, the 
    code searches the collection.  For each record it obtains that Storage
    Pool's interface pointer, which it uses to get that pool's id.  Once
    it finds the record whose Storage Pool id matches the HSM pool id
    passed in, it returns the interface pointer .

    Note that with Sakkara there is only 1 storage pool, so a match should be
    found on the first (and only) record.  However, the code is written to
    allow for future enhancements where there may be more than 1 storage pool.
     
Arguments:

    StoragePoolId - The HSM id (GUID) - as opposed to the NTMS id - for the 
            Storage Pool whose interface pointer is to be returned by this method.

    ppStoragePool - a pointer to the Storage Pool Interface Pointer which will
            be returned by this method.

Return Value:

    S_OK - The call succeeded (the specified storage pool record was found and
            its interface pointer was returned to the caller.

    Any other value - The call failed.  Generally this should only happen if
            a matching storage pool record is not found in the storage pool
            indexed collection (this error will return HR = 81000001, 'search
            of a collection failed', aka WSB_E_NOTFOUND).
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    GUID                        poolId = GUID_NULL;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmStoragePool>    pStoragePool;


    WsbTraceIn(OLESTR("CHsmServer::FindHsmStoragePoolById"), 
                    OLESTR("StoragePoolId = <%ls>"), WsbGuidAsString(StoragePoolId));

    try {

        // ensure the OUT parameter pointer is valid 
        WsbAssert(0 != ppStoragePool, E_POINTER);

        // null out the interface pointer so garbage is not returned
        *ppStoragePool = 0;

        // obtain an iterator (enumerator) to the indexed storage pool collection
        // from the engine's stored storage pool pointer.
        WsbAffirmHr(m_pStoragePools->Enum(&pEnum));

        // get the first record in the collection.  Get that storage pool's id (GUID).
        WsbAffirmHr(pEnum->First(IID_IHsmStoragePool, (void**) &pStoragePool));
        WsbAffirmHr(pStoragePool->GetId(&poolId));

        // if the ids (GUIDs) don't match, iterate through the collection until
        // a match is found.  Note that no match being found will cause an error
        // to be thrown when the Next() call is made after reaching the end of the 
        // collection.
        while (poolId != StoragePoolId) {
            pStoragePool.Release();
            WsbAffirmHr(pEnum->Next(IID_IHsmStoragePool, (void**) &pStoragePool));
            WsbAffirmHr(pStoragePool->GetId(&poolId));
        }

        // Match found: return requested interface pointer after increasing COM
        // ref count 
        *ppStoragePool = pStoragePool;
        if (pStoragePool != 0)  {
            (*ppStoragePool)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindHsmStoragePoolById"), 
                                        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::FindHsmStoragePoolByMediaSetId(
    IN GUID RmsMediaSetId,
    OUT IHsmStoragePool** ppStoragePool
    )

/*++

Implements:

  IHsmServer::FindHsmStoragePoolByMediaSetId().

Routine Description:

    This routine implements the COM method for looking up an HSM (Engine) 
    Storage Pool object by the remote media subsystem Media Set id (a GUID which 
    comes from NTMS in the case where tape is used as secondary storage).  If found, 
    a COM interface pointer to that object is returned.

    After using the Engine's stored pointer to an indexed collection of valid 
    storage pools to obtain an iterator (enumerator) to the collection, the 
    code searches the collection.  For each record it obtains that Storage
    Pool's interface pointer, which it uses to get that pool's media set id.  
    Once it finds the record whose Media Set (Storage Pool) id matches the media 
    set id passed in, it returns that record's interface pointer.

    Note that with Sakkara there is only 1 storage pool, so a match should be
    found on the first (and only) record.  However, the code is written to
    allow for future enhancements where there may be more than 1 storage pool.
     
Arguments:

    MediaSetId - The Remote Storage Subsystem id (GUID) - as opposed to the Engine's 
            local HSM id - for the Storage Pool (referred to by the subsystem as a 
            Media Set) whose interface pointer is to be returned by this method.

    ppStoragePool - a pointer to the Storage Pool Interface Pointer which will
            be returned by this method.

Return Value:

    S_OK - The call succeeded (the specified storage pool record was found and
            its interface pointer was returned to the caller).

    Any other value - The call failed.  Generally this should only happen if
            a matching storage pool record is not found in the storage pool
            indexed collection (this error will return HR = 81000001, 'search
            of a collection failed', aka WSB_E_NOTFOUND).
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    GUID                        mediaSetId = GUID_NULL;
    CWsbBstrPtr                 mediaSetName;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmStoragePool>    pStoragePool;

    WsbTraceIn(OLESTR("CHsmServer::FindHsmStoragePoolByMediaSetId"), 
                    OLESTR("RmsMediaSetId = <%ls>"), WsbGuidAsString(RmsMediaSetId));

    try {

        // ensure OUT parameter is valid
        WsbAssert(0 != ppStoragePool, E_POINTER);

        // null out the returned interface pointer so garbage is not returned
        *ppStoragePool = 0;

        // obtain an iterator (enumerator) to the indexed storage pool collection
        WsbAffirmHr(m_pStoragePools->Enum(&pEnum));

        // Get first record in the collection and its Remote Storage Subsystem
        // Media Set GUID using its interface pointer.
        WsbAffirmHr(pEnum->First(IID_IHsmStoragePool, (void**) &pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &mediaSetName));

        // if the ids (GUIDs) don't match, iterate through the collection until
        // a match is found.  Note that no match being found will cause an error
        // to be thrown when the Next() call is made after reaching the end of the 
        // collection.
        while (mediaSetId != RmsMediaSetId) {
            pStoragePool.Release();
            WsbAffirmHr(pEnum->Next(IID_IHsmStoragePool, (void**) &pStoragePool));
            mediaSetName.Free();
            WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &mediaSetName));
        }

        // Match found: return the requested interface pointer after increasing COM
        // ref count.
        *ppStoragePool = pStoragePool;
        if (pStoragePool != 0)  {
            (*ppStoragePool)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindHsmStoragePoolByMediaSetId"), 
                                        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::FindMediaIdByDescription(
    IN OLECHAR* description,
    OUT GUID* pMediaId
    )

/*++

Implements:

  IHsmServer::FindMediaIdByDescription().

Routine Description:

    This routine implements the COM method for looking up the secondary storage 
    master media's id (a GUID) by its description (display name).  Both the id and 
    description are fields stored in the Engine's MediaInfo database.  (The MediaInfo 
    database is actually a separate entity stored within the Engine's Segment database.)

    After opening the Engine's Segment database and getting the MediaInfo entity,
    the routine loops through the MediaInfo records to find the one whose Description 
    matches that passed into this method.  When it finds the matching record 
    it gets and returns that record's media id.  Any error conditions encountered
    result in the appropriate error HRESULT being thrown and returned to the caller.

Arguments:

    description - Originally called the media's 'name', then the 'display name', later 
            clarified to be the media's 'description', this is what is displayed in the 
            UI to identify the Remote Storage secondary storage (master) media.

    pMediaId - a pointer to the media's id (a GUID) for that media whose description 
            matches the one passed in as the first argument above.

Return Value:

    S_OK - The call succeeded (the specified media record was found and a pointer to
            its id was returned to the caller.

    E_POINTER - Returned if an invalid pointer was passed in as the 'pMediaId' argument.

    WSB_E_NOTFOUND - Value 81000001.  Returned if no media info record was found whose
            description matched the one passed in.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit from this source module's default setting
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    CWsbStringPtr               mediaDescription;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IMediaInfo>         pMediaInfo;

    WsbTraceIn( OLESTR("CHsmServer::FindMediaIdByDescription"), 
                    OLESTR("description = <%ls>"), description );

    try {

        // ensure OUT parameter is valid
        WsbAssert( pMediaId != 0, E_POINTER );

        // null out the returned value so garbage is not returned
        *pMediaId = GUID_NULL;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));

        try {

            // get an interface pointer to the MediaInfo entity (records) in the
            // Segment database.
            WsbAffirmHr(m_pSegmentDatabase->GetEntity( pDbSession, HSM_MEDIA_INFO_REC_TYPE,
                                        IID_IMediaInfo, (void**) &pMediaInfo ));

            // Get the first media record and its description
            WsbAffirmHr( pMediaInfo->First() );
            WsbAffirmHr( pMediaInfo->GetDescription( &mediaDescription, 0 ) );

            // Iterate through all media records until a record is found with a matching   
            // description.  Since an architectural feature of HSM is that all 
            // descriptions (display names) are unique, even across storage pools, 
            // a match means we found the media record we want.  Note that no match 
            // being found will cause an error to be thrown when the Next() call is 
            // made after reaching the last media record.

            // check for description (display name) match (CASE INSENSITIVE)
            while ( _wcsicmp( description, mediaDescription ) != 0 ) {
                WsbAffirmHr( pMediaInfo->Next() );
                WsbAffirmHr( pMediaInfo->GetDescription( &mediaDescription, 0 ));
            }

            // We found the record we want.  Get that media's id for return
            WsbAffirmHr( pMediaInfo->GetId( pMediaId ));

        } WsbCatch (hr); // 'try' to get MediaInfo entity and main processing body

        // close the database
        WsbAffirmHr( m_pSegmentDatabase->Close( pDbSession ));

    } WsbCatch (hr); // 'try' to open the Segment database

    // Done.  Interface pointers used above are singly assigned smart pointers so 
    // don't explicitly Release() them.  They will do auto-garbage collection.
    
    WsbTraceOut(OLESTR("CHsmServer::FindMediaIdByDescription"), 
                        OLESTR("hr = <%ls>, media id = <%ls>"), 
                            WsbHrAsString(hr), WsbGuidAsString(*pMediaId));

    return(hr);

// leaving CopyMedia code, reset Tracing bit to Hsm Engine (default for this module)
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::FindStoragePoolByName(
    IN OLECHAR* name,
    OUT IHsmStoragePool** ppStoragePool
    )

/*++

Implements:

  IHsmServer::FindStoragePoolByName().

--*/
{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    GUID                        id;
    CWsbStringPtr               storagePoolName;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmStoragePool>    pStoragePool;

    WsbTraceIn(OLESTR("CHsmServer::FindStoragePoolByName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppStoragePool, E_POINTER);

        *ppStoragePool = 0;

        WsbAffirmHr(m_pStoragePools->QueryInterface(IID_IWsbCollection, (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));

        WsbAffirmHr(pEnum->First(IID_IHsmStoragePool, (void**) &pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&id, &storagePoolName));

        while (_wcsicmp(name, storagePoolName) != 0) {
            pStoragePool = 0;
            WsbAffirmHr(pEnum->Next(IID_IHsmStoragePool, (void**) &pStoragePool));
            storagePoolName.Free();
            WsbAffirmHr(pStoragePool->GetMediaSet(&id, &storagePoolName));
        }

        *ppStoragePool = pStoragePool;
        if (pStoragePool != 0)  {
            (*ppStoragePool)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindStoragePoolByName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT CHsmServer::GetStoragePools(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the pools have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pStoragePools;
        WsbAffirm(m_pStoragePools != 0, E_FAIL);
        m_pStoragePools->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetOnlineInformation(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the online information has been loaded, return it
    // Otherwise, fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pOnlineInformation;
        WsbAffirm(m_pOnlineInformation != 0, E_FAIL);
        m_pOnlineInformation->AddRef();
    } WsbCatch(hr);

    return (hr);
}

HRESULT CHsmServer::GetMountingMedias(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pMountingMedias;
        WsbAffirm(m_pMountingMedias != 0, E_FAIL);
        m_pMountingMedias->AddRef();
    } WsbCatch(hr);

    return (hr);
}



HRESULT CHsmServer::GetMessages(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If messages have been loaded, return them.
    // Otherwise, fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pMessages;
        WsbAffirm(m_pMessages != 0, E_FAIL);
        m_pMessages->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetUsrToNotify(
    IWsbIndexedCollection** /*ppCollection*/
    )
{
    return E_NOTIMPL;
}


HRESULT CHsmServer::GetJobs(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the jobs have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pJobs;
        WsbAffirm(m_pJobs != 0, E_FAIL);
        m_pJobs->AddRef();
    } WsbCatch(hr);

    return (hr);
}

HRESULT
CHsmServer::FindJobByName(
    IN OLECHAR* name,
    OUT IHsmJob** ppJob
    )

/*++

Implements:

  IHsmServer::FindJobByName().

--*/
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               jobName;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmJob>            pJob;

    WsbTraceIn(OLESTR("CHsmServer::FindJobByName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppJob, E_POINTER);

        *ppJob = 0;

        WsbAffirmHr(m_pJobs->QueryInterface(IID_IWsbCollection, (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));

        hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
        while (S_OK == hr) {
            WsbAffirmHr(pJob->GetName(&jobName, 0));
            WsbTrace(OLESTR("CHsmServer::FindJobByName: name = <%ls>\n"), 
                    jobName);

            if (_wcsicmp(name, jobName) == 0) break;
            pJob = 0;
            hr = pEnum->Next(IID_IHsmJob, (void**) &pJob);
        }

        if (S_OK == hr) {
            *ppJob = pJob;
            if (pJob != 0)  {
                (*ppJob)->AddRef();
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindJobByName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CHsmServer::GetJobDefs(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the job definitions have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pJobDefs;
        WsbAffirm(m_pJobDefs != 0, E_FAIL);
        m_pJobDefs->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetMediaRecs(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetMediaRecs"), OLESTR(""));

    try {
        HRESULT                        hr2;
        CComPtr<IWsbIndexedCollection> pCol;
        CComPtr<IWsbDbSession>         pDbSes;
        CComPtr<IWsbDbEntity>          pRec;

        WsbAffirm(m_pSegmentDatabase != 0, E_FAIL);
        WsbAssert(0 != ppCollection, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&pCol ));

        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSes));
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSes, HSM_MEDIA_INFO_REC_TYPE, 
                IID_IWsbDbEntity, (void**)&pRec));

        //  Loop over records in DB and copy to collection
        hr2 = pRec->First();
        while(S_OK == hr2) {
            CComPtr<IMediaInfo>      pCopy;
            CComPtr<IMediaInfo>      pOrig;
            GUID                     MediaId;
            GUID                     MediaSubsystemId; 
            GUID                     StoragePoolId; 
            LONGLONG                 FreeBytes; 
            LONGLONG                 Capacity; 
            HRESULT                  LastError; 
            short                    NextRemoteDataSet; 
            OLECHAR *                pDescription = NULL; 
            HSM_JOB_MEDIA_TYPE       Type;
            OLECHAR *                pName = NULL;
            BOOL                     ReadOnly;
            FILETIME                 Update;
            LONGLONG                 LogicalValidBytes;
            BOOL                     Recreate;

            //  Create a copy for the collection
            WsbAffirmHr(CoCreateInstance(CLSID_CMediaInfo, NULL, CLSCTX_ALL, 
                IID_IMediaInfo, (void**) &pCopy));

            //  Copy data
            WsbAffirmHr(pRec->QueryInterface(IID_IMediaInfo, (void**)&pOrig));
            WsbAffirmHr(pOrig->GetMediaInfo(&MediaId, &MediaSubsystemId, 
                    &StoragePoolId, &FreeBytes, &Capacity, &LastError, &NextRemoteDataSet, 
                    &pDescription, 0, &Type, &pName,  0, &ReadOnly, &Update, &LogicalValidBytes,
                    &Recreate));
            WsbTrace(OLESTR("CHsmServer::GetMediaRecs: after GetMediaInfo\n"));
            WsbAffirmHr(pCopy->SetMediaInfo(MediaId, MediaSubsystemId, 
                    StoragePoolId, FreeBytes, Capacity, LastError, NextRemoteDataSet, 
                    pDescription, Type, pName, ReadOnly, Update, LogicalValidBytes,
                    Recreate));
            WsbTrace(OLESTR("CHsmServer::GetMediaRecs: after SetMediaInfo\n"));
            if (pDescription) {
                WsbFree(pDescription);
                pDescription = NULL;
            }
            if (pName) {
                WsbFree(pName);
                pName = NULL;
            }

            WsbAffirmHr(pCol->Add(pCopy));

            hr2 = pRec->Next();
        }
        WsbAffirm(WSB_E_NOTFOUND == hr2, hr2);

        *ppCollection = pCol;
        pCol->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetMediaRecs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT CHsmServer::GetPolicies(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the policies have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pPolicies;
        WsbAffirm(m_pPolicies != 0, E_FAIL);
        m_pPolicies->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetActions(
    IWsbIndexedCollection** /*ppCollection*/
    )
{
    return E_NOTIMPL;
}


HRESULT CHsmServer::GetCriteria(
    IWsbIndexedCollection** /*ppCollection*/
    )
{
    return E_NOTIMPL;
}


HRESULT CHsmServer::GetSegmentDb(
    IWsbDb **ppDb
    )
{
    HRESULT hr = S_OK;

    //
    // If the segment table has been created, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppDb, E_POINTER);
        WsbAffirm(m_pSegmentDatabase != 0, E_FAIL);
        *ppDb = m_pSegmentDatabase;
        m_pSegmentDatabase->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetHsmFsaTskMgr(
    IHsmFsaTskMgr  **ppHsmFsaTskMgr
    )
{
    HRESULT hr = S_OK;

    //
    // If the Task Manager has been created, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppHsmFsaTskMgr, E_POINTER);
        *ppHsmFsaTskMgr = m_pHsmFsaTskMgr;
        WsbAffirm(m_pHsmFsaTskMgr != 0, E_FAIL);
        m_pHsmFsaTskMgr->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT 
CHsmServer::CreateInstance ( 
    REFCLSID rclsid, 
    REFIID riid, 
    void **ppv 
    )
{
    HRESULT     hr = S_OK;
    
    hr = CoCreateInstance( rclsid, NULL, CLSCTX_SERVER, riid, ppv );

    return hr;
}


HRESULT CHsmServer::FinalConstruct(
    )
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::FinalConstruct"), OLESTR(""));

    //
    // Initialize member data
    //
    m_pRssWriter = NULL;
    m_savingEvent = NULL;
    m_terminateEvent = NULL;
    m_hId = GUID_NULL;
    m_initializationCompleted = FALSE;
    m_persistWasCreated = FALSE;
    m_mediaCount = 0;
    m_copyfilesUserLimit = DEFAULT_COPYFILES_USER_LIMIT;
    m_autosaveThread = 0;
    m_CheckManagedResourcesThread = 0;
    m_cancelCopyMedia = FALSE;
    m_inCopyMedia = FALSE;
    m_Suspended = FALSE;
    m_JobsEnabled = TRUE;

    InitializeCriticalSectionAndSpinCount(&m_JobDisableLock, 1000);
    InitializeCriticalSectionAndSpinCount(&m_MountingMediasLock, 1000);

    try {
        WsbAffirmHr(CWsbPersistable::FinalConstruct( ));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FinalConstruct"), OLESTR("hr = <%ls>\n"), WsbHrAsString(hr));
    return( hr );
}


void CHsmServer::FinalRelease(
    )
{
    WsbTraceIn(OLESTR("CHsmServer::FinalRelease"), OLESTR(""));

    if (TRUE == m_initializationCompleted)  {
        HSM_SYSTEM_STATE SysState;

        SysState.State = HSM_STATE_SHUTDOWN;
        ChangeSysState(&SysState);
    } else {
        WsbTrace(OLESTR("CHsmServer::FinalRelease not saving persistent information.\n"));
    }

    // Let the parent class do his thing.   
    CWsbPersistable::FinalRelease();

    DeleteCriticalSection(&m_JobDisableLock);
    DeleteCriticalSection(&m_MountingMediasLock);

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the 
    // smart-pointer destructor is being called (as part of this object destruction)
    m_name.Free();
    m_dir.Free();
    m_dbPath.Free();

    if (m_terminateEvent != NULL) {
        CloseHandle(m_terminateEvent);
        m_terminateEvent = NULL;
    }

    // Cleanup the writer
    m_pRssWriter->Terminate();
    delete m_pRssWriter;
    m_pRssWriter = NULL;

    // Clean up database system
    m_pDbSys->Terminate();

    if (m_savingEvent != NULL) {
        CloseHandle(m_savingEvent);
        m_savingEvent = NULL;
    }

    WsbTraceOut(OLESTR("CHsmServer::FinalRelease"), OLESTR(""));
}


HRESULT
CHsmServer::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_HsmServer;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT CHsmServer::Init(
    void
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Init"),OLESTR(""));
    
    try  {
        CComPtr<IPersistFile>  pPersistFile;
        DWORD                  threadId;
        CWsbStringPtr          tmpString;
        LUID                   backupValue;
        HANDLE                 tokenHandle;
        TOKEN_PRIVILEGES       newState;
        DWORD                  lErr;
        HANDLE                 pHandle;

        // Get our Name
        WsbAffirmHr(WsbGetComputerName(m_name));

        // Set the build and database parameters
        WsbAffirmHr(WsbGetMetaDataPath(m_dbPath));
        m_databaseVersion = ENGINE_CURRENT_DB_VERSION;
        m_buildVersion = RS_BUILD_VERSION;

        // Set the autosave parameters.
        m_autosaveInterval = DEFAULT_AUTOSAVE_INTERVAL;
        m_autosaveThread = 0;
        
        // Enable the backup operator privilege.  This is required to insure that we 
        // have full access to all resources on the system.
        pHandle = GetCurrentProcess();
        WsbAffirmStatus(OpenProcessToken(pHandle, MAXIMUM_ALLOWED, &tokenHandle));

        // adjust backup token privileges
        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeBackupPrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( HSM_MESSAGE_SERVICE_UNABLE_TO_SET_BACKUP_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }

        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeRestorePrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( HSM_MESSAGE_SERVICE_UNABLE_TO_SET_RESTORE_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }
        CloseHandle(tokenHandle);

        // Create the Writer
        m_pRssWriter = new CRssJetWriter;
        WsbAffirm(NULL != m_pRssWriter, E_OUTOFMEMORY);

        //  Create the event that synchronize saving of persistent data with snapshots
        WsbAffirmHandle(m_savingEvent = CreateEvent(NULL, FALSE, TRUE, HSM_ENGINE_STATE_EVENT));

        //
        // Create one instance of the Media Server Interface 
        // (It must be created before the persistent data is loaded.
        //
        WsbTrace(OLESTR("Creating Rsm Server member.\n"));
        WsbAffirmHr(CoCreateInstance(CLSID_CRmsServer, NULL, CLSCTX_SERVER,
                                     IID_IRmsServer, (void**)&m_pHsmMediaMgr));

        //
        // Load the persistent information
        //
        WsbTrace(OLESTR("Loading Persistent Information.\n"));
        WsbAffirmHr(LoadPersistData());

        // Create mounting-medias collection - Note: this collection is not persistent!
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                            IID_IWsbIndexedCollection, (void **)&m_pMountingMedias));

        // Initialize the Media Server object
        WsbAffirmHr(m_pHsmMediaMgr->InitializeInAnotherThread());
        
        // Initialize the IDB system for this process
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbSys, NULL, CLSCTX_SERVER, 
                IID_IWsbDbSys, (void**) &m_pDbSys));
        WsbAffirmHr(GetIDbPath(&tmpString, 0));
        WsbAffirmHr(m_pDbSys->Init(tmpString, IDB_SYS_INIT_FLAG_FULL_LOGGING));

        // Start automatic backup of DBs
        WsbAffirmHr(m_pDbSys->Backup(NULL, IDB_BACKUP_FLAG_AUTO));
        
        // Initialize Rss Writer
        WsbAffirmHr(m_pRssWriter->Init());
        
        WsbTrace(OLESTR("Loading Segment Information.\n"));
        WsbAffirmHr(LoadSegmentInformation());

        WsbAffirmHr(CreateDefaultJobs());        
        WsbTrace(OLESTR("CreateDefaultJobs OK\n"));
        
        //
        // Create one instance of the Hsm Task Manager Interface and one instance
        // of the Hsm Fsa Task Manager Interface
        //
        WsbTrace(OLESTR("Creating Task Manager.\n"));
        WsbAffirmHr(CoCreateInstance( CLSID_CHsmTskMgr, 0, CLSCTX_SERVER, 
                                      IID_IHsmFsaTskMgr, (void **)&m_pHsmFsaTskMgr ));
        WsbAffirmHr(m_pHsmFsaTskMgr->Init((IUnknown*) (IHsmServer*) this));

        // 
        // Tell the world that we are here
        //
        // Currently, avoid publishing HSM in the AD - if this becomes necessary, 
        // remove the comments from the following code
        //
/***        WsbAffirmHr(HsmPublish (HSMCONN_TYPE_HSM, m_name, m_hId, m_name, CLSID_HsmServer ));
        WsbTrace(OLESTR("Published OK\n"));         ***/

        // Create termination event for auto-backup thread
        WsbAffirmHandle((m_terminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL)));

        // If the autosave interval is non-zero, start the autosave thread
        if (m_autosaveInterval) {
            ULONG  interval = m_autosaveInterval;

            WsbAffirm(0 == m_autosaveThread, E_FAIL);
            m_autosaveInterval = 0;

            //  Trick SetAutosave into starting the thread
            WsbAffirmHr(SetAutosave(interval));
        }

        m_initializationCompleted = TRUE;

        //  Start a thread that will check on the managed resources. This is done
        //  as a separate thread because the Resource code can call back into this
        //  process and hang the FSA and the Engine since the Engine code hasn't
        //  gotten to it's message loop yet.
        WsbAffirm((m_CheckManagedResourcesThread = CreateThread(0, 0, HsmengStartCheckManagedResources, 
                (void*) this, 0, &threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));
        
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmServer::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}

HRESULT
CHsmServer::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetSizeMax"), OLESTR(""));

    try {
    
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = 2000000;
    
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmServer::GetSizeMax"), OLESTR("hr = <%ls>, size = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToUliAsString(pSize));
    
    return( hr );
}    

HRESULT
CHsmServer::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Load"), OLESTR(""));

    try {
        
        WsbAssert(0 != pStream, E_POINTER);
        //
        // Make sure these are in the same order as Save
        //
        // Make sure this is the right version of the database to load
        //
        ULONG tmpDatabaseVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpDatabaseVersion));
        if (tmpDatabaseVersion == ENGINE_WIN2K_DB_VERSION) {
            // We are upgrading from an older version of the database
            WsbLogEvent( HSM_MESSAGE_DATABASE_VERSION_UPGRADE, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&m_databaseVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&tmpDatabaseVersion)), NULL );
        } else if (tmpDatabaseVersion != m_databaseVersion)  {
            //
            // The database version this server is expecting does not
            // match that of the saved database - so error out.
            WsbLogEvent( HSM_MESSAGE_DATABASE_VERSION_MISMATCH, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&m_databaseVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&tmpDatabaseVersion)), NULL );
            WsbThrow(HSM_E_DATABASE_VERSION_MISMATCH);
        }
        //
        // Now read in the build version but don't do anything with it.  It is in the
        // databases for dump programs to display
        //
        ULONG tmpBuildVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpBuildVersion));
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_hId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_autosaveInterval));
        if (tmpDatabaseVersion == ENGINE_WIN2K_DB_VERSION) {
            LONGLONG mediaCount;
            WsbAffirmHr(WsbLoadFromStream(pStream, &mediaCount));
            m_mediaCount = (LONG)mediaCount;
            m_copyfilesUserLimit = DEFAULT_COPYFILES_USER_LIMIT;
        } else {
            WsbAffirmHr(WsbLoadFromStream(pStream, &m_mediaCount));
            WsbAffirmHr(WsbLoadFromStream(pStream, &m_copyfilesUserLimit));
        }

        WsbTrace(OLESTR("Loading Jobs.\n"));
        WsbAffirmHr(LoadJobs(pStream));
        
        WsbTrace(OLESTR("Loading Job Definitions.\n"));
        WsbAffirmHr(LoadJobDefs(pStream));
        
        WsbTrace(OLESTR("Loading Policies.\n"));
        WsbAffirmHr(LoadPolicies(pStream));
        
        WsbTrace(OLESTR("Loading Managed Resources.\n"));
        WsbAffirmHr(LoadManagedResources(pStream));
        
        WsbTrace(OLESTR("Loading Storage Pools.\n"));
        WsbAffirmHr(LoadStoragePools(pStream));
        
        WsbTrace(OLESTR("Loading Messages.\n"));
        WsbAffirmHr(LoadMessages(pStream));

        WsbTrace(OLESTR("Loading Media Manager objects.\n"));
        if (tmpDatabaseVersion == ENGINE_WIN2K_DB_VERSION) {
            // Special procedure for upgrading a Win2K media manager data, which is located in a separate file
            CComPtr<IHsmUpgradeRmsDb> pUpgrade;
            CComPtr<IPersistFile>  pServerPersist;
            CWsbStringPtr   rmsDbName; 

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmUpgradeRmsDb, NULL, CLSCTX_SERVER,
                                 IID_IHsmUpgradeRmsDb, (void**)&pUpgrade));
            WsbAffirmHr(pUpgrade->Init(m_pHsmMediaMgr));
            WsbAffirmHr(pUpgrade->QueryInterface(IID_IPersistFile, (void **)&pServerPersist));
            rmsDbName = m_dbPath;
            WsbAffirmHr(rmsDbName.Append(RMS_WIN2K_PERSIST_FILE));
            hr = WsbSafeLoad(rmsDbName, pServerPersist, FALSE);
            if (WSB_E_NOTFOUND == hr) {
                // In case of upgrade, the Rms database must be there
                hr = WSB_E_SERVICE_MISSING_DATABASES;
            }
            WsbAffirmHr(hr);
        } else {
            CComPtr<IPersistStream> pIStream;
            WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IPersistStream, (void **)&pIStream));
            WsbAffirmHr(pIStream->Load(pStream));
        }

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmServer::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        //  Make sure these are in the same order as Load
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_databaseVersion));
        WsbAffirmHr(WsbSaveToStream(pStream, m_buildVersion));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_hId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_autosaveInterval));
        WsbAffirmHr(WsbSaveToStream(pStream, m_mediaCount));
        WsbAffirmHr(WsbSaveToStream(pStream, m_copyfilesUserLimit));

        WsbTrace(OLESTR("Storing Jobs.\n"));
        WsbAffirmHr(StoreJobs(pStream));
        
        WsbTrace(OLESTR("Storing Job Definitions.\n"));
        WsbAffirmHr(StoreJobDefs(pStream));
        
        WsbTrace(OLESTR("Storing Policies.\n"));
        WsbAffirmHr(StorePolicies(pStream));
        
        WsbTrace(OLESTR("Storing Managed Resources.\n"));
        WsbAffirmHr(StoreManagedResources(pStream));
        
        WsbTrace(OLESTR("Storing Storage Pools.\n"));
        WsbAffirmHr(StoreStoragePools(pStream));
        
        WsbTrace(OLESTR("Storing Messages.\n"));
        WsbAffirmHr(StoreMessages(pStream));

        WsbTrace(OLESTR("Storing Media Manager objects.\n"));
        CComPtr<IPersistStream> pIStream;
        WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IPersistStream, (void **)&pIStream));
        WsbAffirmHr(pIStream->Save(pStream, clearDirty));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CHsmServer::SaveAll(
    void
    )

/*++

Implements:

  IwsbServer::SaveAll

Return Value:
    S_OK     - Success
    S_FALSE  - Already saving
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SaveAll"), OLESTR(""));

    try {
        WsbAffirm(!g_HsmSaveInProcess, S_FALSE);
        g_HsmSaveInProcess = TRUE;
        hr = InternalSavePersistData();
        g_HsmSaveInProcess = FALSE;

        // call Media Server SaveAll
        WsbAffirmHr(m_pHsmMediaMgr->SaveAll());
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SaveAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
        
        

HRESULT
CHsmServer::GetNextMedia(
    LONG *pNextMedia
    )

/*++

Implements:

  IHsmServer::GetNextMedia().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetNextMedia"), OLESTR(""));
    
    try {
        WsbAssert(0 != pNextMedia, E_POINTER);
        
        //  Always increment media count
        //  If prior scratch mount failed, the mounting component should save the id that
        //  it got on the first call
        //  NOTE:  One possible consequence is that if a job fails mounting scratch (one time 
        //  or more) and gives up, one increment has already done, hence skipping one number.
        *pNextMedia = InterlockedIncrement(&m_mediaCount);

        //
        // We want to make sure we never reuse this count so
        // save it now
        //
        WsbAffirmHr(SavePersistData());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetNextMedia"), OLESTR("hr = <%ls>, nextMedia = <%ls>"), 
                        WsbHrAsString(hr), WsbPtrToLongAsString(pNextMedia));

    return(hr);
}



HRESULT 
CHsmServer::CreateTask(
    IN const OLECHAR *          jobName,
    IN const OLECHAR *          jobParameters,
    IN const OLECHAR *          jobComments,
    IN const TASK_TRIGGER_TYPE  jobTriggerType,
    IN const WORD               jobStartHour,
    IN const WORD               jobStartMinute,
    IN const BOOL               scheduledJob
    )

/*++

Implements:

  IHsmServer::CreateTask().

Routine Description:

    This routine implements the Engine's COM method for creating a task (aka job) in the 
    NT Task Scheduler.  If the task is to be run on a scheduled basis, that schedule
    will be set.  If the task is a disabled task (does not run on a scheduled basis), 
    it will be run at the end of this method.

    The method creates a Task Scheduler object, which is first used to delete any old
    task with the same name as the one about to be created, and then to create the new
    task (aka job).  The rest of the method deals with setting the various fields in 
    the NT Task Scheduler needed to run the job.  The logic is straight forward, except
    possibly for the code dealing with the Task Trigger.  
    
    The Task Trigger is a struct defined in the 'mstask.idl' file (nt\public\sdk\inc) 
    which is used to set the schedule for a scheduled task.  (Note it is not used for 
    a disabled, or non-scheduled, job, since that type of job only runs once (at the end 
    of this method).)  While a number of scheduling options are defined, this method 
    only supports 5 of the 8 defined.  See 'jobTriggerType' in the 'Arguments' section, 
    and 'E_INVALIDARG' in the 'Return Value' section below for a listing of which options 
    are, and are not, supported.  Also note that a filled-out Task Trigger structure can 
    not be passed to this method as an argument since a Task Trigger is non-marshallable 
    (by virtue of containing a simple union field).  (This is why 3 of the fields 
    contained within the Task Trigger struct are passed as args.)  

    Note that this method does not create a job object in the HSM Engine.  If a job
    needs to be created, it is the caller's responsibility to do so.

Arguments:

    jobName - The fully formatted task name as it will appear in the NT Task Scheduler UI.
                It is the caller's responsibility to build/format this string prior to
                calling this method.  Can not be NULL.

    jobParameters - The fully formatted parameter string for the program the task will
                invoke.  For Sakkara the invoked program is RsLaunch.  'jobParameters'
                is the string added to the RsLaunch command line which specifies the
                Remote Storage job to run (e.g., 'run manage').  Can not be NULL.

    jobComments - The fully formatted comments string as it will appear in the NT Task 
                Scheduler UI.  Can be null.

    jobTriggerType - The value which specifies to the Task Scheduler the frequency with
                which to run a scheduled task.  For scheduled tasks, used to build the
                Task Trigger structure.  (Not used for non-scheduled (one time only) 
                tasks.)  Supported values are 'TASK_TIME_TRIGGER_ONCE', 
                'TASK_TIME_TRIGGER_DAILY', 'TASK_TIME_TRIGGER_ON_IDLE', 
                'TASK_TIME_TRIGGER_AT_SYSTEMSTART', and 'TASK_TIME_TRIGGER_AT_LOGON'.
                See return value 'E_INVALIDARG' below for a list of non-supported options.

    jobStartHour - The value which specifies to the Task Scheduler the hour at which to
                start a scheduled task.  For scheduled tasks, used to build the Task 
                Trigger structure.  (Not used for non-scheduled (one time only) tasks.)

    jobStartMinute - The value which specifies to the Task Scheduler the minutes past 
                the hour at which to start a scheduled task.  For scheduled tasks, used 
                to build the Task Trigger structure.  (Not used for non-scheduled (one 
                time only) tasks.)

    scheduledJob - A Boolean which indicates whether or not the task to be created is to 
                run as a scheduled task, or as a one time only task.  One time only tasks 
                are run immediately at the end of this method.

Return Value:

    S_OK - The call succeeded (the specified task was created (and run, in the case of
                one time only tasks) in NT Task Scheduler).

    E_INVALIDARG - Either an invalid (not supported by this method) or non-existent 
                'jobTriggerType' value was passed into this method.  Non-supported values
                are 'TASK_TIME_TRIGGER_WEEKLY', 'TASK_TIME_TRIGGER_MONTHLYDATE', and
                'TASK_TIME_TRIGGER_MONTHLYDOW'.  Supported values are listed in argument
                'jobTriggerType' above.

    E_POINTER - Either the 'jobName' or 'jobParameters' argument was passed as NULL.

    Any other value - The call failed because one of the Remote Storage API calls 
                contained internally in this method failed.  The error value returned is
                specific to the API call which failed.
            
--*/

{
// The below 'define' statement is used to control conditional compilation of the code
// which sets the account info in NT Task Scheduler.  Once Task Scheduler is fixed to 
// not need a specific user name and password to run a task, simply remove or comment 
// out this statement.

    HRESULT hr = S_OK;
    CComPtr<ITaskScheduler>     pTaskScheduler;
    CComPtr<ITask>              pTask;
    CComPtr<IPersistFile>       pPersist;
    DWORD                       TaskFlags;


    WsbTraceIn(OLESTR("CHsmServer::CreateTask"), 
        OLESTR("jobName = <%ls>, jobParameters = <%ls>, jobComments = <%ls>, "
                L"jobTriggerType = <%d>, jobStartHour = <%d>, jobStartMinute = <%d>, "
                L"scheduledJob = <%ls>"), jobName, jobParameters, jobComments,
                jobTriggerType, jobStartHour, jobStartMinute, 
                WsbBoolAsString( scheduledJob ) );

    try {

        WsbAffirmPointer( jobName );
        WsbAffirmPointer( jobParameters );
        
        // Create a Task Scheduler object, which defaults to pointing to this computer's
        // NT Task Scheduler.
        WsbAffirmHr( CoCreateInstance( CLSID_CTaskScheduler, 0, CLSCTX_SERVER,
                        IID_ITaskScheduler, (void **) &pTaskScheduler ) );

        // Delete any old job with the same name from the scheduler, if it exists.
        // Ignore error.
        pTaskScheduler->Delete( jobName );

        // Create the new job in the scheduler
        WsbAffirmHr( pTaskScheduler->NewWorkItem( jobName, CLSID_CTask, IID_ITask, 
                                                (IUnknown**)&pTask ) );

        CWsbStringPtr appName;
        WsbAffirmHr(appName.LoadFromRsc(_Module.m_hInst, IDS_PRODUCT_NAME));

        // Set the Creator field for the task
        WsbAffirmHr( pTask->SetCreator( appName ) );

        // Branch on whether or not the task is to run by schedule
        if ( scheduledJob ) {

            CComPtr<ITaskTrigger>       pTrigger;
            WORD                        triggerNumber;
            TASK_TRIGGER                taskTrigger;
            SYSTEMTIME                  sysTime;

            // create Trigger scheduling object for the job 
            WsbAffirmHr( pTask->CreateTrigger( &triggerNumber, &pTrigger ) );
        
            // Zero out Task Trigger struct contents, then init its structure size field
            memset( &taskTrigger, 0, sizeof( taskTrigger ) );
            taskTrigger.cbTriggerSize = sizeof( taskTrigger );

            // Set up schedule for the job in the Task Trigger struct
            GetSystemTime( &sysTime );
            taskTrigger.wBeginYear   = sysTime.wYear;
            taskTrigger.wBeginMonth  = sysTime.wMonth;
            taskTrigger.wBeginDay    = sysTime.wDay;

            taskTrigger.wStartHour   = jobStartHour;
            taskTrigger.wStartMinute = jobStartMinute;

            taskTrigger.TriggerType  = jobTriggerType;

            // Finish setting schedule info based on case, reject non-supported cases
            switch ( jobTriggerType )
            {
            case TASK_TIME_TRIGGER_DAILY: 
                {
                taskTrigger.Type.Daily.DaysInterval = 1;
                }
                break;

            // these are supported cases that need no further set up
            case TASK_TIME_TRIGGER_ONCE: 
            case TASK_EVENT_TRIGGER_ON_IDLE: 
            case TASK_EVENT_TRIGGER_AT_SYSTEMSTART: 
            case TASK_EVENT_TRIGGER_AT_LOGON: 
                {
                }
                break;

            // non-supported cases
            case TASK_TIME_TRIGGER_WEEKLY: 
            case TASK_TIME_TRIGGER_MONTHLYDATE: 
            case TASK_TIME_TRIGGER_MONTHLYDOW: 
                {
                WsbTrace( 
                OLESTR("(CreateTask) Job Trigger Type passed <%d> is invalid (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
                break;

            default: 
                {
                WsbTrace( 
                OLESTR("(CreateTask) Nonexistent Job Trigger Type passed <%d> (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
            }

            // Set the job schedule
            WsbAffirmHr( pTrigger->SetTrigger( &taskTrigger ) );
        }

        // Note that for Disabled (non-scheduled) tasks, there is no need to 'SetFlags()'
        // on the task (pTask) to 'TASK_FLAG_DISABLED'.  In fact, this method will hang 
        // for an undetermined reason if you do issue that call.

        // Below steps finish creating an entry for NT Task Scheduler

        // Set the program that the Scheduler is to run (for Sakkara this is RsLaunch)
        WsbAffirmHr( pTask->SetApplicationName( WSB_FACILITY_LAUNCH_NAME ) );

        // Put the job name in as the task parameter - for Sakkara this is how RsLaunch
        // knows which job to run.
        WsbAffirmHr( pTask->SetParameters( jobParameters ) );

        // Set the comments field for the task
        WsbAffirmHr( pTask->SetComment( jobComments ) );

        // Set Task Scheduler account info by passing nulls
        WsbAffirmHr( pTask->SetAccountInformation( OLESTR(""), NULL ) );

        // Set the SYSTEM_REQUIRED flag to deal with standby/sleep mode
        WsbAffirmHr(pTask->GetTaskFlags(&TaskFlags));
        TaskFlags |= TASK_FLAG_SYSTEM_REQUIRED;
        WsbAffirmHr(pTask->SetTaskFlags(TaskFlags));

        // Save the scheduled task
        WsbAffirmHr( pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );
        WsbAffirmHr( pPersist->Save( 0, 0 ) );

        // If this is not a scheduled job, run it now
        if ( !scheduledJob ) {
            WsbAffirmHr( pTask->Run() );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CHsmServer::CreateTask", L"hr = <%ls>", WsbHrAsString( hr ) );

    return( hr );
}


HRESULT 
CHsmServer::CreateTaskEx(
    IN const OLECHAR *          jobName,
    IN const OLECHAR *          jobParameters,
    IN const OLECHAR *          jobComments,
    IN const TASK_TRIGGER_TYPE  jobTriggerType,
    IN const SYSTEMTIME         runTime,
    IN const DWORD              runOccurrence,
    IN const BOOL               scheduledJob
    )

/*++

Implements:

  IHsmServer::CreateTaskEx().

Routine Description:

    This routine implements the Engine's COM method for creating a task (aka job) in the 
    NT Task Scheduler.  If the task is to be run on a scheduled basis, that schedule
    will be set.  If the task is a disabled task (does not run on a scheduled basis), 
    it will be run at the end of this method.

    The method creates a Task Scheduler object, which is first used to delete any old
    task with the same name as the one about to be created, and then to create the new
    task (aka job).  The rest of the method deals with setting the various fields in 
    the NT Task Scheduler needed to run the job.  The logic is straight forward, except
    possibly for the code dealing with the Task Trigger.  
    
    The Task Trigger is a struct defined in the 'mstask.idl' file (nt\public\sdk\inc) 
    which is used to set the schedule for a scheduled task.  (Note it is not used for 
    a disabled, or non-scheduled, job, since that type of job only runs once (at the end 
    of this method).)  While a number of scheduling options are defined, this method 
    only supports 5 of the 8 defined.  See 'jobTriggerType' in the 'Arguments' section, 
    and 'E_INVALIDARG' in the 'Return Value' section below for a listing of which options 
    are, and are not, supported.  Also note that a filled-out Task Trigger structure can 
    not be passed to this method as an argument since a Task Trigger is non-marshallable 
    (by virtue of containing a simple union field).  (This is why 3 of the fields 
    contained within the Task Trigger struct are passed as args.)  

    Note that this method does not create a job object in the HSM Engine.  If a job
    needs to be created, it is the caller's responsibility to do so.

Arguments:

    jobName - The fully formatted task name as it will appear in the NT Task Scheduler UI.
                It is the caller's responsibility to build/format this string prior to
                calling this method.  Can not be NULL.

    jobParameters - The fully formatted parameter string for the program the task will
                invoke.  For Sakkara the invoked program is RsLaunch.  'jobParameters'
                is the string added to the RsLaunch command line which specifies the
                Remote Storage job to run (e.g., 'run manage').  Can not be NULL.

    jobComments - The fully formatted comments string as it will appear in the NT Task 
                Scheduler UI.  Can be null.

    jobTriggerType - The value which specifies to the Task Scheduler the frequency with
                which to run a scheduled task.  For scheduled tasks, used to build the
                Task Trigger structure.  (Not used for non-scheduled (one time only) 
                tasks.)  Supported values are 'TASK_TIME_TRIGGER_ONCE', 
                'TASK_TIME_TRIGGER_DAILY', TASK_TIME_TRIGGER_WEEKLY ,
                TASK_TIME_TRIGGER_MONTHLYDATE, 'TASK_TIME_TRIGGER_ON_IDLE', 
                'TASK_TIME_TRIGGER_AT_SYSTEMSTART', and 'TASK_TIME_TRIGGER_AT_LOGON'.
                See return value 'E_INVALIDARG' below for a list of non-supported options.

    runTime      - Time when the job should be scheduled

    runOccurrence - Occurrence for the job should to be scheduled, relevant for several trigger types

    scheduledJob - A Boolean which indicates whether or not the task to be created is to 
                run as a scheduled task, or as a one time only task.  One time only tasks 
                are run immediately at the end of this method.

Return Value:

    S_OK - The call succeeded (the specified task was created (and run, in the case of
                one time only tasks) in NT Task Scheduler).

    E_INVALIDARG - Either an invalid (not supported by this method) or non-existent 
                'jobTriggerType' value was passed into this method.  Non-supported values
                are 'TASK_TIME_TRIGGER_WEEKLY', 'TASK_TIME_TRIGGER_MONTHLYDATE', and
                'TASK_TIME_TRIGGER_MONTHLYDOW'.  Supported values are listed in argument
                'jobTriggerType' above.

    E_POINTER - Either the 'jobName' or 'jobParameters' argument was passed as NULL.

    Any other value - The call failed because one of the Remote Storage API calls 
                contained internally in this method failed.  The error value returned is
                specific to the API call which failed.
            
--*/

{
// The below 'define' statement is used to control conditional compilation of the code
// which sets the account info in NT Task Scheduler.  Once Task Scheduler is fixed to 
// not need a specific user name and password to run a task, simply remove or comment 
// out this statement.

    HRESULT hr = S_OK;
    CComPtr<ITaskScheduler>     pTaskScheduler;
    CComPtr<ITask>              pTask;
    CComPtr<IPersistFile>       pPersist;
    DWORD                       TaskFlags;


    WsbTraceIn(OLESTR("CHsmServer::CreateTaskEx"), 
        OLESTR("jobName = <%ls>, jobParameters = <%ls>, jobComments = <%ls>, "
                L"jobTriggerType = <%d>, jobStartHour = <%d>, jobStartMinute = <%d>, "
                L"scheduledJob = <%ls>"), jobName, jobParameters, jobComments,
                jobTriggerType, runTime.wHour, runTime.wMinute, 
                WsbBoolAsString( scheduledJob ) );

    try {

        WsbAffirmPointer( jobName );
        WsbAffirmPointer( jobParameters );
        
        // Create a Task Scheduler object, which defaults to pointing to this computer's
        // NT Task Scheduler.
        WsbAffirmHr( CoCreateInstance( CLSID_CTaskScheduler, 0, CLSCTX_SERVER,
                        IID_ITaskScheduler, (void **) &pTaskScheduler ) );

        // Delete any old job with the same name from the scheduler, if it exists.
        // Ignore error.
        pTaskScheduler->Delete( jobName );

        // Create the new job in the scheduler
        WsbAffirmHr( pTaskScheduler->NewWorkItem( jobName, CLSID_CTask, IID_ITask, 
                                                (IUnknown**)&pTask ) );

        CWsbStringPtr appName;
        WsbAffirmHr(appName.LoadFromRsc(_Module.m_hInst, IDS_PRODUCT_NAME));

        // Set the Creator field for the task
        WsbAffirmHr( pTask->SetCreator( appName ) );

        // Branch on whether or not the task is to run by schedule
        if ( scheduledJob ) {

            CComPtr<ITaskTrigger>       pTrigger;
            WORD                        triggerNumber;
            TASK_TRIGGER                taskTrigger;

            // create Trigger scheduling object for the job 
            WsbAffirmHr( pTask->CreateTrigger( &triggerNumber, &pTrigger ) );
        
            // Zero out Task Trigger struct contents, then init its structure size field
            memset( &taskTrigger, 0, sizeof( taskTrigger ) );
            taskTrigger.cbTriggerSize = sizeof( taskTrigger );

            // Set up schedule for the job in the Task Trigger struct
            taskTrigger.wBeginYear   = runTime.wYear;
            taskTrigger.wBeginMonth  = runTime.wMonth;
            taskTrigger.wBeginDay    = runTime.wDay;

            taskTrigger.wStartHour   = runTime.wHour;
            taskTrigger.wStartMinute = runTime.wMinute;

            taskTrigger.TriggerType  = jobTriggerType;

            // Finish setting schedule info based on case, reject non-supported cases
            switch ( jobTriggerType )
            {
            case TASK_TIME_TRIGGER_DAILY: 
                {
                taskTrigger.Type.Daily.DaysInterval = (WORD)runOccurrence;
                }
                break;

            case TASK_TIME_TRIGGER_WEEKLY: 
                {
                taskTrigger.Type.Weekly.WeeksInterval = (WORD)runOccurrence;
                switch (runTime.wDayOfWeek) {
                case 0:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_SUNDAY;
                    break;
                case 1:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY;
                    break;
                case 2:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_TUESDAY;
                    break;
                case 3:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_WEDNESDAY;
                    break;
                case 4:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_THURSDAY;
                    break;
                case 5:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_FRIDAY;
                    break;
                case 6:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_SATURDAY;
                    break;
                }
                }
                break;

            case TASK_TIME_TRIGGER_MONTHLYDATE: 
                {
                WsbAssert(runTime.wDay < 32, E_INVALIDARG);
                taskTrigger.Type.MonthlyDate.rgfDays = (1 << (runTime.wDay-1));
                taskTrigger.Type.MonthlyDate.rgfMonths = (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH |TASK_APRIL | 
                                                          TASK_MAY | TASK_JUNE |TASK_JULY | TASK_AUGUST |
                                                          TASK_SEPTEMBER | TASK_OCTOBER | TASK_NOVEMBER | TASK_DECEMBER);
                }
                break;

            case TASK_EVENT_TRIGGER_ON_IDLE: 
                {
                WORD wIdle, wTemp;
                WsbAffirmHr(pTask->GetIdleWait(&wIdle, &wTemp));
                wIdle = (WORD)runOccurrence;
                WsbAffirmHr(pTask->SetIdleWait(wIdle, wTemp));
                }

            // these are supported cases that need no further set up
            case TASK_TIME_TRIGGER_ONCE: 
            case TASK_EVENT_TRIGGER_AT_SYSTEMSTART: 
            case TASK_EVENT_TRIGGER_AT_LOGON: 
                {
                }
                break;

            // non-supported cases
            case TASK_TIME_TRIGGER_MONTHLYDOW: 
                {
                WsbTrace( 
                OLESTR("(CreateTaskEx) Job Trigger Type passed <%d> is invalid (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
                break;

            default: 
                {
                WsbTrace( 
                OLESTR("(CreateTaskEx) Nonexistent Job Trigger Type passed <%d> (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
            }

            // Set the job schedule
            WsbAffirmHr( pTrigger->SetTrigger( &taskTrigger ) );
        }

        // Note that for Disabled (non-scheduled) tasks, there is no need to 'SetFlags()'
        // on the task (pTask) to 'TASK_FLAG_DISABLED'.  In fact, this method will hang 
        // for an undetermined reason if you do issue that call.

        // Below steps finish creating an entry for NT Task Scheduler

        // Set the program that the Scheduler is to run (for Sakkara this is RsLaunch)
        WsbAffirmHr( pTask->SetApplicationName( WSB_FACILITY_LAUNCH_NAME ) );

        // Put the job name in as the task parameter - for Sakkara this is how RsLaunch
        // knows which job to run.
        WsbAffirmHr( pTask->SetParameters( jobParameters ) );

        // Set the comments field for the task
        WsbAffirmHr( pTask->SetComment( jobComments ) );

        // Set Task Scheduler account info by passing nulls
        WsbAffirmHr( pTask->SetAccountInformation( OLESTR(""), NULL ) );

        // Set the SYSTEM_REQUIRED flag to deal with standby/sleep mode
        WsbAffirmHr(pTask->GetTaskFlags(&TaskFlags));
        TaskFlags |= TASK_FLAG_SYSTEM_REQUIRED;
        WsbAffirmHr(pTask->SetTaskFlags(TaskFlags));

        // Save the scheduled task
        WsbAffirmHr( pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );
        WsbAffirmHr( pPersist->Save( 0, 0 ) );

        // If this is not a scheduled job, run it now
        if ( !scheduledJob ) {
            WsbAffirmHr( pTask->Run() );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CHsmServer::CreateTaskEx", L"hr = <%ls>", WsbHrAsString( hr ) );

    return( hr );
}


HRESULT
CHsmServer::CancelCopyMedia(
    void
    )

/*++

Implements:

  IHsmServer::CancelCopyMedia().

Routine Description:

    Cancel any active media copy operations (synchronize copy or recreate master).

Arguments:

    None.

Return Value:

    S_OK    - The call succeeded.

    S_FALSE - No media copy operation is active.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;


    WsbTraceIn( OLESTR("CHsmServer::CancelCopyMedia"), 
            OLESTR("m_inCopyMedia = %ls, m_cancelCopyMedia = %ls"),
            WsbQuickString(WsbBoolAsString(m_inCopyMedia)), 
            WsbQuickString(WsbBoolAsString(m_cancelCopyMedia)));

    Lock();
    if (m_inCopyMedia) {
        m_cancelCopyMedia = TRUE;
    } else {
        hr = S_FALSE;
    }
    Unlock();
    
    WsbTraceOut(OLESTR("CHsmServer::CancelCopyMedia"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}


HRESULT
CHsmServer::MarkMediaForRecreation(
    IN REFGUID masterMediaId
    )

/*++

Implements:

  IHsmServer::MarkMediaForRecreation().

Routine Description:

    This routine implements the Engine's COM method for marking a master media for re-creation
    Should we mark such a media as Recall Only as well ?

Arguments:

    masterMediaId - The id (GUID) for the master media to be marked.

Return Value:

    S_OK - The call succeeded (the specified master media was marked).

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;
    CComPtr<IMediaInfo>             pMediaInfo;
    CComPtr<IWsbDbSession>          pDbSession;


    WsbTraceIn( OLESTR("CHsmServer::MarkMediaForRecreation"), 
                        OLESTR("masterMediaId = <%ls>"), WsbGuidAsString(masterMediaId) );

    // no event logging since this method is presently for development use only
    
    try {

        // open the Engine's Segment database
        WsbAffirmHr( m_pSegmentDatabase->Open( &pDbSession ));

        try {

            // get an interface pointer to the MediaInfo records (entity) in the
            // Segment database
            WsbAffirmHr( m_pSegmentDatabase->GetEntity( pDbSession, 
                                        HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, 
                                        (void**) &pMediaInfo ));

            // get the MediaInfo database record for the master media we will mark for 
            // re-creation
            WsbAffirmHr( pMediaInfo->SetId( masterMediaId ));
            WsbAffirmHr( pMediaInfo->FindEQ());

            // mark this media for re-creation and as read only
            WsbAffirmHr( pMediaInfo->SetRecreate( TRUE ) );
/***        WsbAffirmHr( pMediaInfo->RecreateMaster() ); TEMPORARY: Call this one instead for marking as Read Only as well  ***/

            // write updated record into the database
            WsbAffirmHr( pMediaInfo->Write());

        } WsbCatch(hr); // inner 'try' - get media info entity and process

        WsbAffirmHr( m_pSegmentDatabase->Close(pDbSession));

    } WsbCatch(hr); // 'try' to open the database

    // processing is done.  The singly-assigned smart interface pointers will auto-garbage
    // collect themselves.
    
    WsbTraceOut(OLESTR("CHsmServer::MarkMediaForRecreation"), OLESTR("hr = <%ls>"), 
                                                                WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::RecreateMaster(
    IN REFGUID masterMediaId,
    IN USHORT  copySet
    )

/*++

Implements:

  IHsmServer::RecreateMaster().

Routine Description:

    This routine implements the COM method for replacing (re-creating) a secondary
    storage original (master) media.  To replace the master, a duplicate is made of
    the copy specified.  The master record for that media in the Engine's 
    MediaInfo database is then updated to point to the 're-created' master (duplicated
    media).  For safety purposes all re-created masters are marked 'read only' if
    the copy was not up to date with the original master.  
    Because of the potential for data loss (if the most recent copy is not up to date 
    with the original master which is being re-created), the user (System Administrator) 
    is urged to run a Validate job against the appropriate volume (via the UI) after 
    re-creating any master.

    After opening the Segment database (a single database containing all Engine
    database tables), getting the MediaInfo (remote storage master media) records 
    (entity) and connecting to the RMS subsystem, the method gets the media record
    corresponding to the master to be re-created.  It then checks that the specified
    copy exists for that master.  After ensuring the copy exists,
    a 're-created master' is made by duplicating the that copy.  The 
    database info for the media record is then updated to point to the newly 're-created' 
    master media.  The method then cleans up (i.e., closes the database) and returns.

Arguments:

    masterMediaId - The id (GUID) for the master media which is to be re-created.

    copySet       - The copyset number of the copy to use or zero, which means use the
                    most recent copy.

Return Value:

    S_OK - The call succeeded (the specified master media was re-created from the
            specified copy media).

    HSM_E_RECREATE_FLAG_WRONGVALUE - Returned if the 'recreate' flag for the master
            media record whose id was passed in, indicating it is to be recreated,
            is not set properly.  (The UI is supposed to set it to TRUE prior to
            calling this method via RsLaunch.)

    HSM_E_NO_COPIES_CONFIGURED - Returned if no copies have been configured or created
            for the master which is to be recreated.  Without a valid copy we can not
            recreate a master secondary storage media.

    HSM_E_NO_COPIES_EXIST - Returned if copies have been configured but they either
            haven't been created yet, or had previously been created but the System
            Administrator deleted them via UI action.

    WSB_E_NOTFOUND - Value 81000001.  Returned if no storage pool record was found whose
            id matched the one contained in the media record.

    HSM_E_BUSY - Another media copy operation was already in progress.

    HSM_E_WORK_SKIPPED_CANCELLED - Operation was cancelled.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;
    HRESULT                         currentLastError      = S_OK;
    BOOL                            haveMasterMediaRecord = FALSE;
    BOOL                            recreateMaster        = FALSE;
    BOOL                            currentRecallOnly     = FALSE;
    BOOL                            newRecallOnly         = FALSE;
    SHORT                           currentNextRemoteDataSet = 0;
    SHORT                           copyNextRemoteDataSet    = 0;
    SHORT                           lastKnownGoodMasterNextRemoteDataSet = 0;
    USHORT                          maxSets        = 0;
    GUID                            poolId                  = GUID_NULL;
    GUID                            newMasterId             = GUID_NULL;
    GUID                            mediaSetId              = GUID_NULL;
    GUID                            currentMediaId          = GUID_NULL;
    GUID                            currentMediaSubsystemId = GUID_NULL;
    GUID                            lastKnownGoodMasterId   = GUID_NULL;
    GUID                            copyMediaSubsystemId    = GUID_NULL;
    LONGLONG                        newFreeBytes            = 0;
    LONGLONG                        currentFreeBytes        = 0;
    LONGLONG                        currentLogicalValidBytes = 0;
    LONGLONG                        newCapacity             = 0;
    LONGLONG                        currentCapacity         = 0;
    FILETIME                        copyUpdate;
    FILETIME                        currentUpdate;
    FILETIME                        lastKnownGoodMasterUpdate;
    CComPtr<IHsmStoragePool>        pPool;
    CComPtr<IMediaInfo>             pMediaInfo;
    CComPtr<IRmsCartridge>          pNewMasterMedia;
    CComPtr<IRmsCartridge>          pCopyMedia;
    CComPtr<IWsbDbSession>          pDbSession;
    CWsbStringPtr                   currentName;
    CWsbStringPtr                   currentDescription;
    CWsbStringPtr                   copyDescription;
    CWsbBstrPtr                     copyDescriptionAsBstr;
    CWsbBstrPtr                     mediaSetName;
    CWsbBstrPtr                     newName;
    HSM_JOB_MEDIA_TYPE              currentType;


    WsbTraceIn( OLESTR("CHsmServer::RecreateMaster"), OLESTR("masterMediaId = <%ls>"), 
                                                    WsbGuidAsString(masterMediaId) );

    // log 'information' message
    WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_START, 0, NULL, NULL );
    
    try {
        BOOL                okToContinue = TRUE;

        //  Make sure we're not already busy & haven't been cancelled
        Lock();
        if (m_inCopyMedia) {
            okToContinue = FALSE;
        } else {
            m_inCopyMedia = TRUE;
        }
        Unlock();
        WsbAffirm(okToContinue, HSM_E_BUSY);
        WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

        // open the Engine's Segment database 
        WsbAffirmHr( m_pSegmentDatabase->Open( &pDbSession ));

        try {

            // get an interface pointer to the MediaInfo records (entity) in the
            // Segment database
            WsbAffirmHr( m_pSegmentDatabase->GetEntity( pDbSession, 
                                        HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, 
                                        (void**) &pMediaInfo ));

            // get the MediaInfo db record for the master media we want to re-create
            WsbAffirmHr( pMediaInfo->SetId( masterMediaId ));
            WsbAffirmHr( pMediaInfo->FindEQ());
            haveMasterMediaRecord = TRUE;

            // to check if this master has in fact been marked for re-creation, get
            // the re-created flag value
            WsbAffirmHr( pMediaInfo->GetRecreate( &recreateMaster ));

            // do not proceed if re-created flag is not set
            if ( recreateMaster == FALSE ) {
                // log 'error' message and exit
                WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_INVALID_FLAG_VALUE, 
                                        0, NULL, NULL );
                WsbThrow( HSM_E_RECREATE_FLAG_WRONGVALUE );
            } 

            // recreateMaster flag is TRUE, so proceed to re-create...
            // Get the storage pool the master to be re-created belongs to.  We'll
            // use this pool to determine number of copy sets configured for this
            // media, and to specify what storage pool the 'new' (re-created) master
            // is to belong to.
            WsbAffirmHr( pMediaInfo->GetStoragePoolId( &poolId ));

            // Get the storage pool object.
            hr = FindHsmStoragePoolById( poolId, &pPool );
            if (S_OK != hr) {
                // log the returned error and throw the error
                WsbLogEvent( HSM_MESSAGE_SEARCH_STGPOOL_BY_HSMID_ERROR,
                                        0, NULL, WsbHrAsString(hr), NULL );
                WsbThrow( hr );
            }

            // get the number of copy sets configured for this pool
            WsbAffirmHr( pPool->GetNumMediaCopies( &maxSets ));
            // if none have been configured by SysAdmin, error out
            WsbAffirm( maxSets > 0, HSM_E_NO_COPIES_CONFIGURED );

            // If the copySet number was specified, make sure it is valid
            WsbAffirm(((copySet == 0) || (copySet <= maxSets)), E_INVALIDARG);

            // If the copySet was not specified, determine
            // which copy belonging to this master is most recent, otherwise
            // get information about specified copy.

            if (copySet == 0) {
                USHORT    mostRecentCopy = 0;
                USHORT    mostDataSets = 0;
                FILETIME  mostRecentCopyUpdate = WsbLLtoFT(0);

                // set invalid value for validity testing (testing if any media
                // copies exist)
                mostRecentCopy = (USHORT)( maxSets + 1 );

                // loop through the configured copy sets
                for (copySet = 1; copySet <= maxSets; copySet++ ) {
                    //
                    // We use the NextDataSet count to determine most recent copy.
                    //
                    WsbAffirmHr(pMediaInfo->GetCopyNextRemoteDataSet(copySet, 
                                                                    &copyNextRemoteDataSet));

                    if (copyNextRemoteDataSet > mostDataSets)  {

                        //
                        // We need to make sure this copy is available.
                        //

                        WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copySet, 
                                                                        &copyMediaSubsystemId));

                        try {

                            //
                            // Check the copy to make sure it exists and is enabled.
                            //
                            WsbAffirm(copyMediaSubsystemId != GUID_NULL, E_FAIL);
                            WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(copyMediaSubsystemId, &pCopyMedia));

                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pCartCom = pCopyMedia;
                            WsbAffirmPointer(pCartCom);
                            if( S_OK == pCartCom->IsEnabled( ) ) {

                                //
                                // This copy is more recent, and available, so save info
                                //
                                WsbAffirmHr(pMediaInfo->GetCopyUpdate(copySet, &copyUpdate));

                                // set the NextRemoteDataSet to this copy's count
                                mostDataSets = copyNextRemoteDataSet;

                                // capture copy number, and update time
                                mostRecentCopy = copySet;
                                mostRecentCopyUpdate = copyUpdate;

                            }

                        } WsbCatchAndDo(hr,
                                hr = S_OK;
                            );

                    }
                } // end 'for' loop

                // Check to be sure there was a copy.  If not, error out.
                WsbAffirm( ((maxSets + 1) > mostRecentCopy), HSM_E_NO_COPIES_EXIST );

                copySet = mostRecentCopy;
                copyUpdate = mostRecentCopyUpdate;
            } else {
                WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copySet, &copyMediaSubsystemId));
                WsbAffirm(copyMediaSubsystemId != GUID_NULL, HSM_E_NO_COPY_EXISTS);
                WsbAffirmHr(pMediaInfo->GetCopyUpdate(copySet, &copyUpdate));
            }

            WsbTrace(OLESTR("Source for re-creation:  copySet number = %d; version: %ls\n"),
                                copySet, WsbFiletimeAsString(FALSE, copyUpdate) );

            // Check to see if we are going to loose data because of re-creating 
            // the master.
            
            // !!! IMPORTANT NOTE - bmd !!!
            //
            // We need to handle the case where we are recreating multiple times
            // from out of sync copies.  The last known good master always holds the info
            // of the master in its last known good state.  We are looking at the update
            // timestamp which represent the version of the master or copy.  The dataset
            // number may be one more than what is store with the last known good master
            // because of the particular logic required to handle partial/incomplete data sets:
            // a) either the data set was written, but not committed, or b) the data set was started,
            // but data was actually written.


            CWsbStringPtr      name;
            CWsbStringPtr      description;

            GUID        unusedGuid1;
            GUID        unusedGuid2;  // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
            LONGLONG    unusedLL1;
            LONGLONG    unusedLL2;    // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
            BOOL        lastKnownGoodMasterRecallOnly;
            HRESULT     lastKnownGoodMasterLastError;
            HSM_JOB_MEDIA_TYPE unusedJMT;

            // Get date the original master was last updated, this is stored with
            // the last known good master.

            WsbAffirmHr(pMediaInfo->GetLastKnownGoodMasterInfo(
                &unusedGuid1, &lastKnownGoodMasterId, &unusedGuid2,
                &unusedLL1, &unusedLL2,
                &lastKnownGoodMasterLastError, &description, 0, &unusedJMT, &name, 0,
                &lastKnownGoodMasterRecallOnly,
                &lastKnownGoodMasterUpdate,
                &lastKnownGoodMasterNextRemoteDataSet));

            name.Free( );
            description.Free( );

            // If the original master is newer than the most 
            // recent copy...  (it should not be possible for the master
            //                  to be older than a copy!)
            if (CompareFileTime(&lastKnownGoodMasterUpdate, &copyUpdate) != 0)  {
                // ...we may lose data, so log it.
                WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_COPY_OLD, 0, NULL, NULL );
            }

            // Set up done.  Now get/build necessary parameters for the call
            // to actually duplicate the most recent copy onto scratch media.  
            // This copy will be the re-created master.
            WsbAffirmHr(pMediaInfo->GetCopyDescription(copySet, &copyDescription, 0));
            copyDescriptionAsBstr = copyDescription;    // auto-allocates the BSTR

            // Something simple for now.
            copyDescriptionAsBstr.Prepend(OLESTR("RM-"));

            WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copySet, 
                                                            &copyMediaSubsystemId));

            // get the media set the storage pool contains so we assign the
            // re-created master to the proper media set
            WsbAffirmHr( pPool->GetMediaSet( &mediaSetId, &mediaSetName ));

            // Parameters built.  Call HSM subsystem to copy the most recent copy 
            // onto scratch media
            WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);
            GUID firstSideId = GUID_NULL;
            WsbAffirmHrOk(m_pHsmMediaMgr->DuplicateCartridge(copyMediaSubsystemId, 
                                                        firstSideId, &newMasterId, mediaSetId, 
                                                        copyDescriptionAsBstr,
                                                        &newFreeBytes, &newCapacity,
                                                        RMS_DUPLICATE_RECYCLEONERROR));

            // now that a replacement master media has been created, prepare
            // to update the master media info in the database

            // first get an interface pointer to the new re-created master 
            WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(newMasterId, &pNewMasterMedia));

            // Get re-created master's label name.  Note that if secondary
            // storage is tape, this 'name' is the tape's bar code.  For
            // other media (e.g., optical) this is a name.
            WsbAffirmHr(pNewMasterMedia->GetName(&newName));

            // Get Next Remote Data Set value from the copy.  Used by the Validate
            // job to determine what bags are on a master, it will be carried 
            // forward to the re-created master.
            WsbAffirmHr(pMediaInfo->GetCopyNextRemoteDataSet(copySet, 
                                                            &copyNextRemoteDataSet));

            // get current master media info since some fields will not change
            WsbAffirmHr(pMediaInfo->GetMediaInfo( &currentMediaId, 
                                                    &currentMediaSubsystemId,
                                                    &poolId, &currentFreeBytes,
                                                    &currentCapacity, 
                                                    &currentLastError,
                                                    &currentNextRemoteDataSet,
                                                    &currentDescription, 0, 
                                                    &currentType, &currentName, 0, 
                                                    &currentRecallOnly,
                                                    &currentUpdate,
                                                    &currentLogicalValidBytes,
                                                    &recreateMaster ));

            WsbTrace(OLESTR("Original Master next dataset, ver     = %d, %ls\n"), currentNextRemoteDataSet, WsbFiletimeAsString(FALSE, currentUpdate));
            WsbTrace(OLESTR("Copy next dataset, ver                = %d, %ls\n"), copyNextRemoteDataSet, WsbFiletimeAsString(FALSE, copyUpdate));
            WsbTrace(OLESTR("LastKnownGoodMaster next dataset, ver = %d, %ls\n"), lastKnownGoodMasterNextRemoteDataSet, WsbFiletimeAsString(FALSE, lastKnownGoodMasterUpdate));

            //
            // Initialize the state of the recreated master
            //
            newRecallOnly = lastKnownGoodMasterRecallOnly;

            BOOL inSync = (CompareFileTime(&lastKnownGoodMasterUpdate, &copyUpdate) == 0) &&
                (lastKnownGoodMasterNextRemoteDataSet == copyNextRemoteDataSet);

            if (!inSync) {

                // If the copy was not up to date, mark the new master as RecallOnly.
                // Also clear free bytes since we won't know this value

                newRecallOnly = TRUE;
                newFreeBytes = 0;

            } else {

                // This is an in-sync copy... check LastKnownGoodMaster RecallOnly and LastError to
                // determine how to mark the recreated master RecallOnly status. Since the current,
                // maybe recreated from an incomplete copy, we must use information about the
                // LastKnownGoodMaster to determine the new RecallOnly status.

                if (lastKnownGoodMasterRecallOnly) {

                    if (S_OK == lastKnownGoodMasterLastError) {

                        // If media is RecallOnly and there is no error (i.e. the media is full, or
                        // was marked RecallOnly via tool), we leave the media RecallOnly.

                        newRecallOnly = TRUE;

                    } else {

                        // If the original master was RecallOnly because of an error, reset
                        // the RecallOnly bit, since we should now have corrected the problem.

                        newRecallOnly = FALSE;

                    }

                }

            }

            //
            // Now we need to determine what to do with the old media...
            //
            HRESULT hrRecycle;

            if (inSync) {

                // We recreated an in sync master.  The old LastKnownGoodMaster will be
                // overwritten with the new recreated master, so we can safely recycle
                // the LastKnownGoodMaster media.

                // If the cartridge cannot be found we assume it
                // was already deallocated through the media manager UI.
                hrRecycle = m_pHsmMediaMgr->RecycleCartridge( lastKnownGoodMasterId, 0 );
                WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );

                // if the current media is not the same as the LastKnownGoodMaster, we
                // can recyle the current media, as well.  This happens when the
                // current media was recreated from an incomplete (out-of-sync) copy.
                if (lastKnownGoodMasterId != currentMediaSubsystemId) {

                    // If the cartridge cannot be found we assume it
                    // was already deallocated through the media manager UI.
                    hrRecycle = m_pHsmMediaMgr->RecycleCartridge( currentMediaSubsystemId, 0 );
                    WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );
                }

            } else {

                // We recreated from an out-of-sync copy.  If the current media
                // and the LastKnownGoodMaster are different, we recycle the current
                // media, since this will be overwritten with the new recreated master.
                // This handles the case where we recreate from an out of sync copy
                // multiple times.

                if (lastKnownGoodMasterId != currentMediaSubsystemId) {

                    // If the cartridge cannot be found we assume it
                    // was already deallocated through the media manager UI.
                    hrRecycle = m_pHsmMediaMgr->RecycleCartridge( currentMediaSubsystemId, 0 );
                    WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );
                }

            }

            // Reset master media info - use new values where needed and original
            // values where appropriate.  The copy's Next Remote
            // Data Set value allows the Validate job to handle managed files 
            // that are 'lost' by re-creating with an out of date copy.
            WsbAffirmHr(pMediaInfo->SetMediaInfo(currentMediaId, newMasterId,
                                                poolId,
                                                newFreeBytes,
                                                newCapacity, S_OK,
                                                copyNextRemoteDataSet,
                                                currentDescription, currentType,
                                                newName,
                                                newRecallOnly,
                                                copyUpdate,
                                                currentLogicalValidBytes, FALSE));

            if (inSync) {
                // we've alread recycled the media, above.
                WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
            }

            // write the updated media record into the database
            WsbAffirmHr(pMediaInfo->Write());

        } WsbCatch(hr); // inner 'try' - get media info entity and process

        // if any error was thrown after getting the master media record reset
        // the 'recreate master' state to off (FALSE) for safety and so it appears
        // correctly in the UI
        if (( haveMasterMediaRecord ) && ( hr != S_OK )) {
            WsbAffirmHr( pMediaInfo->SetRecreate( FALSE ) );
            WsbAffirmHr( pMediaInfo->Write() );
        }

        // close the database
        WsbAffirmHr( m_pSegmentDatabase->Close(pDbSession) );

    } WsbCatch(hr);

    // processing is done.  Singly-assigned smart interface pointers will 
    // auto-garbage collect themselves.
    
    if (S_OK == hr) {
        WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_END, 0, NULL, WsbHrAsString(hr), NULL );
    } else {
        WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_ERROR_END, 0, NULL, WsbHrAsString(hr), NULL );
    }

    //  Reset flags
    Lock();
    if (m_inCopyMedia && HSM_E_BUSY != hr) {
        m_inCopyMedia = FALSE;
        m_cancelCopyMedia = FALSE;
    }
    Unlock();
    
    WsbTraceOut(OLESTR("CHsmServer::RecreateMaster"), OLESTR("hr = <%ls>"), 
                                                                WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::SynchronizeMedia(
    IN GUID poolId,
    IN USHORT copySet
    )

/*++

Implements:

  IHsmServer::SynchronizeMedia().

Routine Description:

    This routine implements the COM method for updating a specified Copy Set.
    All copy media in the Copy Set either out of date (aka not synchronized
    with the master) or non-existent (either hasn't been made or has been
    deleted by the SysAdmin) will be 'synchronized' by this method.  Out of 
    date media are copied (from the master) and the MediaInfo database is 
    updated to reflect the new info.

    After opening the Segment database (a single database containing all Engine
    database tables), getting the MediaInfo (secondary storage master media) records 
    (entity) and connecting to the RMS subsystem, the method enters its main loop.  
    The loop iterates through all MediaInfo records.  Those that belong to the specified 
    storage pool are processed.  First a check is made to ensure that the copy set
    requested to be updated is valid.  If valid, and if that copy set's media is out of 
    sync with the master (meaning it is outdated), the copy media is then duplicated 
    from the master.  (The copy media is actually 'updated', meaning only that
    portion of the master that was not previously written to the copy is copied.)  
    Finally, that master's specified Copy Set media record is updated in the database.  
    The loop then iterates to the next MediaInfo record.  After all MediaInfo 
    records have been processed the database is closed and the method returns.
    
Arguments:

    poolId - The id (GUID) for the Storage Pool whose copy set specified in the 
            following parameter is to synchronized (aka updated).  (Sakkara only
            has one storage pool.)

    copySet - the number of the copy set that is to be updated.  (Sakkara allows
            anywhere from 1 to 3 copy sets of secondary storage media, as configured
            by the System Administrator.)

Return Value:

    S_OK - The call succeeded (the specified copy set in the specified storage
            pool was updated).

    HSM_E_BUSY - Another media copy operation was already in progress.

    HSM_E_WORK_SKIPPED_CANCELLED - Operation was cancelled.

    Any other value - The call failed in either opening the Engine's Segment
            database, in getting the MediaInfo database entity, or in connecting
            to the RMS subsystem.
            
            NOTE that any error thrown during this routine's main loop will be
            logged to the Event Log, but will then be over-written to S_OK.  That 
            record is skipped and the next record in the loop is processed.  Due
            to this it is possible that an out of sync copy set media will not be
            updated.

--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;
    USHORT                          maxSets = 0;
    FILETIME                        mediaTime;
    GUID                            mediaId     = GUID_NULL;
    GUID                            mediaSetId  = GUID_NULL;
    GUID                            copyPoolId  = GUID_NULL;
    HRESULT                         hrDup = S_OK;
    BOOL                            atLeastOneCopyError = FALSE;
    SHORT                           masterNextRemoteDataSet;
    CComPtr<IHsmStoragePool>        pPool;
    CComPtr<IMediaInfo>             pMediaInfo;
    CComPtr<IRmsCartridge>          pCopyMedia;
    CComPtr<IWsbDbSession>          pDbSession;
    CWsbStringPtr                   mediaDescription;


    WsbTraceIn(OLESTR("CHsmServer::SynchronizeMedia"), 
                OLESTR("poolId = <%ls>, copySet = <%d>"), 
                WsbGuidAsString(poolId), copySet);

    // log 'information' message
    WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_START, 0, NULL, NULL );
    
    try {
        wchar_t             copySetAsString[20];
        BOOLEAN             done = FALSE;
        BOOLEAN             firstPass = TRUE;
        BOOL                okToContinue = TRUE;

        //  Make sure we're not already busy & haven't been cancelled
        Lock();
        if (m_inCopyMedia) {
            okToContinue = FALSE;
        } else {
            m_inCopyMedia = TRUE;
        }
        Unlock();
        WsbAffirm(okToContinue, HSM_E_BUSY);
        WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

        // open the Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));

        // get interface pointer to the MediaInfo records (entity) in the
        // Segment database
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, 
                                    HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, 
                                    (void**) &pMediaInfo));

        WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

        // Convert copySet number to a sting for use later
        _itow( copySet, copySetAsString, 10 );

        // Main processing loop -- loop through all media at least once to
        // check for out-of-date copies.  Keep looping if any copies were
        // skipped because the mount request timed out.
        while (!done) {
            LONG        nTimedOut = 0;

            // Iterate through the (master secondary storage) media looking for 
            // duplicate (copy) media in this copy set that either haven't been made 
            // or haven't been synchronized since the last time the master was updated.  

            for (hr = pMediaInfo->First(); SUCCEEDED(hr); hr = pMediaInfo->Next()) {
                CWsbStringPtr   copyDescription;
                HRESULT         copyError = S_OK;
                GUID            copyMediaId = GUID_NULL;
                SHORT           copyNextRemoteDataSet = 0;
                CWsbStringPtr   copyName;
                FILETIME        copyTime = WsbLLtoFT(0);
                BOOL            gotCopyInfo = FALSE;
                BOOL            updateMediaInfo = FALSE;
                BOOLEAN         mountingScratch = FALSE;

                try {
                    WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

                    // get the storage pool GUID of this master media (& its copies)
                    WsbAffirmHr(pMediaInfo->GetStoragePoolId(&copyPoolId));

                    // If the media is from the desired pool (or any pool) then check it.
                    // (Passing in a poolId of NULL has the effect of indicating the 
                    // SysAdmin wants copy set 'x' in all storage pools updated in one 
                    // operation.  Note that Sakkara currently uses this technique
                    // when the 'Update Copyset x' command is issued via the UI 
                    // (it launches RsLaunch with no pool id specified).)
                    if ((poolId == GUID_NULL) || (poolId == copyPoolId)) {

                        // Ensure the copy set requested for update is valid:

                        // Get the storage pool using the pool's HSM (not remote media 
                        // subsystem) id (GUID).
                        hr = FindHsmStoragePoolById(copyPoolId, &pPool);
                        if (S_OK != hr) {
                            // log and throw the returned error (this media will be
                            // skipped)
                            WsbLogEvent( HSM_MESSAGE_SEARCH_STGPOOL_BY_HSMID_ERROR,
                                            0, NULL, WsbHrAsString(hr), NULL );
                            WsbThrow( hr );
                        }

                        // get the number of copy sets configured for this pool
                        WsbAffirmHr(pPool->GetNumMediaCopies(&maxSets));

                        // ensure requested copy set is valid
                        WsbAffirm(copySet <= maxSets, E_INVALIDARG);
            
                        // to determine if the copy set media needs to be updated
                        // get the date the master media was last updated,
                        // and the last dataset written to the media...
                        //
                        // !!! IMPORTANT NOTE !!!
                        // This is the current time and data set count.  If a migrate
                        // is in progress this is NOT the final update time.
                        //
                        WsbAffirmHr(pMediaInfo->GetUpdate(&mediaTime));
                        WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&masterNextRemoteDataSet));

                        // ...and get the date the copy media was last updated - 
                        // for efficiency get all copy media info in 1 call
                        // (copyMediaId is used later).
                        WsbAffirmHr(pMediaInfo->GetCopyInfo(copySet, &copyMediaId, 
                                                &copyDescription, 0, &copyName, 0, 
                                                &copyTime, &copyError, 
                                                &copyNextRemoteDataSet));
                        gotCopyInfo = TRUE;
                    
                        // If the copy media is out of date (copy's date last
                        // updated < master media's date last updated OR nextDataSet don't
                        // match), synchronize it.
                        //
                        // If this is not the first pass through the media records, we only
                        // want to retry copies that timed out.
                        if ((CompareFileTime( &copyTime, &mediaTime ) < 0 ||
                             copyNextRemoteDataSet != masterNextRemoteDataSet) &&
                                (firstPass ||
                                (RMS_E_TIMEOUT == copyError) ||
                                (RMS_E_SCRATCH_NOT_FOUND == copyError) ||
                                (RMS_E_CARTRIDGE_UNAVAILABLE == copyError))) {
                            CWsbBstrPtr      mediaDescriptionAsBstr;
                            CWsbBstrPtr      mediaSetName;
                            GUID             copySecondSideId = GUID_NULL;
                            DWORD            nofDrives = 0;

                            mountingScratch = FALSE;

                            // get media set id the storage pool contains so we assign
                            // the synchronized copy media to the proper media set
                            WsbAffirmHr(pPool->GetMediaSet( &mediaSetId, &mediaSetName ));

                            // since the duplication itself will be done by the remote
                            // media subsystem, get the subsystem GUID of the master 
                            WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaId));

                            // build the description (display name) for the copy set 
                            // media as a BSTR (required format for duplicate call)
                            WsbAffirmHr(pMediaInfo->GetDescription(&mediaDescription, 0));

                            // check if we have at least 2 enabled drives for synchronizing the media
                            // if not - abort
                            WsbAffirmHr(m_pHsmMediaMgr->GetNofAvailableDrives(mediaSetId, &nofDrives));
                            WsbAffirm(nofDrives > 1, HSM_E_NO_TWO_DRIVES);

                            // If no media has been allocated for this copy, we need
                            // to construct a media description string
                            if (GUID_NULL == copyMediaId) {
                                mountingScratch = TRUE;

                                mediaDescriptionAsBstr = mediaDescription;
                                mediaDescriptionAsBstr.Append(" (Copy ");
                                mediaDescriptionAsBstr.Append(copySetAsString);
                                mediaDescriptionAsBstr.Append(")");
                                WsbTrace(OLESTR("CHsmServer::SynchronizeMedia: scratch desc = %ls\n"),
                                        mediaDescriptionAsBstr);

                                // In case of two-sided medias, we need to check whether the
                                //  original has a second side which has an existing copy
                                // If so, we want to allocate the second side of this existing copy
                                if (S_OK == m_pHsmMediaMgr->IsMultipleSidedMedia(mediaSetId)) {
                                    GUID    secondSideId;
                                    BOOL    bValid;

                                    // Get second side of original
                                    WsbAffirmHr(m_pHsmMediaMgr->CheckSecondSide(mediaId, &bValid, &secondSideId));
                                    if (bValid && (GUID_NULL != secondSideId)) {
                                        CComPtr<IMediaInfo> pSecondSideInfo;
                                        GUID                idFromDb;

                                        // Get second side record (if second side exists and allocated - it must be allocated by us!)
                                        //  Since the subsystem-id is not a key, we must traverse the table
                                        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE, 
                                                        IID_IMediaInfo, (void**) &pSecondSideInfo));
                                        for (hr = pSecondSideInfo->First(); SUCCEEDED(hr); hr = pSecondSideInfo->Next()) {
                                            WsbAffirmHr(pSecondSideInfo->GetMediaSubsystemId(&idFromDb));
                                            if (idFromDb == secondSideId) {
                                                // Just set second side copy for allocation the other side of the as existing copy.cartridge
                                                WsbAffirmHr(pSecondSideInfo->GetCopyMediaSubsystemId(copySet, &copySecondSideId));

                                                break;
                                            }
                                        }
                                    }
                                }
                            } else {
                                mediaDescriptionAsBstr = copyDescription;
                            }

                            // call remote media subsystem to copy the master 
                            // onto the copy set media indicated
                            WsbAffirm(!m_cancelCopyMedia, 
                                    HSM_E_WORK_SKIPPED_CANCELLED);

                            
                            // These two LONGLONGs are not used, but simply placeholders for the DuplicateCartridge
                            // function call (avoids passing null reference pointer errors).
                            LONGLONG FreeSpace = 0;
                            LONGLONG Capacity = 0;
                            hrDup = m_pHsmMediaMgr->DuplicateCartridge(mediaId, 
                                    copySecondSideId, &copyMediaId, mediaSetId, 
                                    mediaDescriptionAsBstr, &FreeSpace, &Capacity, 0);

                            WsbTrace(OLESTR("CHsmServer::SynchronizeMedia: DuplicateCartridge = <%ls>\n"),
                                    WsbHrAsString(hrDup));

                            // Make sure the status get saved in DB
                            copyError = hrDup;
                            updateMediaInfo = TRUE;

                            //
                            // We need to refresh the mediaTime and next data set.  This
                            // handles case were DuplicateCartridge was waiting on migrate to finish.
                            //
                            WsbAffirmHr(pMediaInfo->GetUpdate(&mediaTime));
                            WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&masterNextRemoteDataSet));

                            // If we got a new piece of media, save the info about
                            // it in the DB.
                            // The DuplicateCartridge operation may fail after the media was
                            // allocated, so we need to record the copy media id in our databases
                            // no matter what.  If copyMediaId is still GUID_NULL we know the
                            // failure occurred while allocating the media and skip this step.
                            if (mountingScratch && copyMediaId != GUID_NULL) {
                                CWsbBstrPtr      mediaNameAsBstr;

                                // get the copy media
                                WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(copyMediaId, 
                                        &pCopyMedia));

                                // Get the label name of the copy media that was just
                                // created. Note that if secondary storage is tape, 
                                // this 'name' is the tape's bar code.  For other media 
                                // (e.g., optical) this is a name.
                                copyName.Free();
                                WsbAffirmHr(pCopyMedia->GetName(&mediaNameAsBstr));
                                copyName = mediaNameAsBstr;

                                // Save the description string
                                copyDescription = mediaDescriptionAsBstr;
                            }

                            // If the duplication succeeded, update the MediaInfo
                            // data
                            if (S_OK == hrDup) {
                                copyTime = mediaTime;
                                copyNextRemoteDataSet = masterNextRemoteDataSet;

                            // If the duplication failed because of a mount timeout,
                            // count it and we'll try again on the next pass
                            } else if ((RMS_E_TIMEOUT == hrDup) ||
                                       (RMS_E_SCRATCH_NOT_FOUND == hrDup) ||
                                       (RMS_E_CARTRIDGE_UNAVAILABLE == hrDup)) {
                                nTimedOut++;
                            } else {
                                WsbThrow(hrDup);
                            }

                        } // end 'if copy set media is out of date'
                    } // end 'if poolId is valid'

                } WsbCatchAndDo(hr,  // 'try' in the for loop

                    //  If user cancelled, don't count it as an error, just exit
                    if (HSM_E_WORK_SKIPPED_CANCELLED == hr) {
                        WsbThrow(hr);
                    }

                    // If there are no 2 enabled drives, log a message but don't count it as a media error
                    if (HSM_E_NO_TWO_DRIVES == hr) {
                        WsbLogEvent(HSM_MESSAGE_SYNCHRONIZE_MEDIA_ABORT, 0, NULL, 
                                    copySetAsString, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }

                    // If a piece of media fails during the 'for' loop log the error in
                    // the Event Log, then continue through loop to try the others.

                    atLeastOneCopyError = TRUE;

                    // Update the media info with the error
                    copyError = hr;
                    if (gotCopyInfo) {
                        updateMediaInfo = TRUE;
                    }

                    pMediaInfo->GetDescription( &mediaDescription, 0 );
                    WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_ERROR, 0, NULL, 
                                    copySetAsString, (OLECHAR*)mediaDescription, 
                                    WsbHrAsString( hr ), NULL );

                );

                // Update the MediaInfo record if anything changed
                if (updateMediaInfo) {

                    // It may have been a while since we got the the media info
                    // record and some of the data could have changed (e.g. if a
                    // synchronize media job on a different copy set completed) so
                    // we re-read the record before the update and we do it inside 
                    // a transaction to make sure it can't get changed while we're
                    // doing this
                    hr = S_OK;
                    WsbAffirmHr(pDbSession->TransactionBegin());
                    try {
                        // This FindEQ call will synchronize the data in our local
                        // MediaInfo record with what is in the DB
                        WsbAffirmHr(pMediaInfo->FindEQ());

                        // Update the copy media info - specifically the media id
                        // (if the copy media was just created), description,
                        // name (bar code for tape), date last updated (which
                        // is set to the master's date last updated) and the
                        // next remote dataset (conceptually same as next bag).
                        WsbAffirmHr(pMediaInfo->SetCopyInfo(copySet, copyMediaId, 
                                copyDescription, copyName, copyTime, copyError,
                                copyNextRemoteDataSet));
                        // write the changes into the database
                        WsbAffirmHr(pMediaInfo->Write());
                    } WsbCatch(hr);

                    if (S_OK == hr) {
                        WsbAffirmHr(pDbSession->TransactionEnd());
                    } else {
                        WsbAffirmHr(pDbSession->TransactionCancel());

                        atLeastOneCopyError = TRUE;

                        //
                        // If the copy info could not be updated in the database and this is a new copy, 
                        //  we need to recycle the copy, otherwise, the RSS database is inconsistent
                        //
                        if (mountingScratch && copyMediaId != GUID_NULL) {
                            HRESULT hrRecycle = m_pHsmMediaMgr->RecycleCartridge( copyMediaId, 0 );
                            WsbTraceAlways(OLESTR("CHsmServer::SynchronizeMedia: Recycling copy cartridge after DB_update failure, hrRecycle = <%ls>\n"), WsbHrAsString(hrRecycle));
                        }

                        //
                        // Log a message on the error
                        //
                        mediaDescription = L"";
                        pMediaInfo->GetDescription( &mediaDescription, 0 );
                        WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_ERROR, 0, NULL, 
                                        copySetAsString, (OLECHAR*)mediaDescription, 
                                        WsbHrAsString( hr ), NULL );

                        //
                        // Make sure we don't continue the job if an unexpected database-update error occurs
                        //
                        WsbThrow(hr);
                    }
                }

                // Release the interface pointers that will be reassigned during the 
                // next iteration of the 'for' loop.
                pPool = 0;
                pCopyMedia = 0;

            }   // end 'for' loop

            // We will fall out of the 'for' loop after processing all MediaInfo
            // records.  This is indicated by the Next() call returning WSB_E_NOTFOUND.
            // Since this is normal, reset hr to indicate so.
            if (WSB_E_NOTFOUND == hr) {
                hr = S_OK;
            }

            if (0 == nTimedOut) {
                done = TRUE;
            }
            firstPass = FALSE;

        }  // End of while loop

    } WsbCatch(hr);

    // Close the database (if it was opened)
    if (pDbSession) {
        m_pSegmentDatabase->Close(pDbSession);
    }

    // Report an error if any copy failed
    if (S_OK == hr && atLeastOneCopyError) {
        hr = HSM_E_MEDIA_COPY_FAILED;
    }
    
    WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_END, 0, NULL, WsbHrAsString(hr), NULL );

    //  Reset flags
    Lock();
    if (m_inCopyMedia && HSM_E_BUSY != hr) {
        m_inCopyMedia = FALSE;
        m_cancelCopyMedia = FALSE;
    }
    Unlock();
    
    WsbTraceOut(OLESTR("CHsmServer::SynchronizeMedia"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}


HRESULT
CHsmServer::CloseOutDb( void )

/*++

Implements:

  IHsmServer::CloseOutDb().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::CloseOutDb"), OLESTR(""));
    
    try {
        if (m_pDbSys != 0) {
            WsbAffirmHr(m_pDbSys->Backup(NULL, 0));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CloseOutDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::BackupSegmentDb( void )

/*++

Implements:

  IHsmServer::BackupSegmentDb().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::BackupSegmentDb"), OLESTR(""));
    
    try {
        if (m_pDbSys != 0) {
            WsbAffirmHr(m_pDbSys->Backup(NULL, 0));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::BackupSegmentDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::ChangeSysState"), OLESTR("State = %lx"),
        pSysState->State);
    
    try {

        if (pSysState->State & HSM_STATE_SUSPEND) {
            if (!m_Suspended) {
                m_Suspended = TRUE;

                //  Pause the jobs
                NotifyAllJobs(HSM_JOB_STATE_PAUSING);

                //  Save data
                SavePersistData();
                SaveMetaData();
            }
        } else if (pSysState->State & HSM_STATE_RESUME) {
            m_Suspended = FALSE;

            //  Resume the jobs
            NotifyAllJobs(HSM_JOB_STATE_RESUMING);
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Kill the CheckManagedResources thread
            if (m_CheckManagedResourcesThread) {
                //  Could this cause a problem if the thread is in the middle
                //  of something?
                TerminateThread(m_CheckManagedResourcesThread, 0);
                CloseHandle(m_CheckManagedResourcesThread);
                m_CheckManagedResourcesThread = 0;
            }

            //  Close the autosave thread
            StopAutosaveThread();

            // 
            // Since MediaCopy operations do not run as standard jobs,
            // the only way to cancel these is to suspend or shutdown RMS
            // directly.
            //
            try {
                CComPtr<IHsmSystemState>    pISysState;
                HSM_SYSTEM_STATE            SysState;

                WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IHsmSystemState, (void**) &pISysState));
                WsbAffirmPointer(pISysState);

                SysState.State = HSM_STATE_SUSPEND;
                WsbAffirmHr(pISysState->ChangeSysState(&SysState));

                SysState.State = HSM_STATE_RESUME;
                WsbAffirmHr(pISysState->ChangeSysState(&SysState));

            } WsbCatch(hr);

            //  Cancel jobs
            CancelAllJobs();

            //  Save data
            SavePersistData();
            SaveMetaData();
        }

        //  Notify the task manager
        if (m_pHsmFsaTskMgr) {
            m_pHsmFsaTskMgr->ChangeSysState(pSysState);
        }

        // Notify the Media Server
        try {
            CComPtr<IHsmSystemState>    pISysState;

            WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IHsmSystemState, (void**) &pISysState));
            WsbAffirmPointer(pISysState);

            WsbAffirmHr(pISysState->ChangeSysState(pSysState));

        } WsbCatch(hr);

        if (pSysState->State & HSM_STATE_SHUTDOWN) {
            CloseOutDb();

            //  Release collections
            if (m_pMountingMedias) {
                m_pMountingMedias->RemoveAllAndRelease();
            }
            //  Release collections
            if (m_pJobs) {
                m_pJobs->RemoveAllAndRelease();
            }
            if (m_pJobDefs) {
                m_pJobDefs->RemoveAllAndRelease();
            }
            if (m_pPolicies) {
                m_pPolicies->RemoveAllAndRelease();
            }
            if (m_pManagedResources) {
                ULONG                                  count;
                CComPtr<IHsmManagedResourceCollection> pIMRC;

                //  We can't use RemoveAllAndRelease because the Remove function for
                //  this non-standard collection tells the FSA to unmanage the resource.
                //  Then when the FSA shuts down, the list of managed resources is empty.
                //  The next time the FSA starts up, it loads an empty list of managed
                //  resources, which is wrong. The method DeleteAllAndRelesae avoids
                //  this problem.
                WsbAffirmHr(m_pManagedResources->QueryInterface(IID_IHsmManagedResourceCollection, 
                        (void**) &pIMRC));
                pIMRC->DeleteAllAndRelease();
                pIMRC = 0;
                WsbAffirmHr(m_pManagedResources->GetEntries(&count));
            }
            if (m_pStoragePools) {
                m_pStoragePools->RemoveAllAndRelease();
            }
            if (m_pMessages) {
                m_pMessages->RemoveAllAndRelease();
            }
            if (m_pOnlineInformation) {
                m_pOnlineInformation->RemoveAllAndRelease();
            }

            //  Dump object table info
            WSB_OBJECT_TRACE_TYPES;
            WSB_OBJECT_TRACE_POINTERS(WSB_OTP_STATISTICS | WSB_OTP_ALL);

            m_initializationCompleted = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CHsmServer::Unload(
    void
    )

/*++

Implements:

  IwsbServer::Unload

Return Value:
    S_OK     - Success
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Unload"), OLESTR(""));

    try {

        //  We only need to release what may have gotten set/created by
        //  a failed Load attempt.
        if (m_pJobs) {
            m_pJobs->RemoveAllAndRelease();
        }
        if (m_pJobDefs) {
            m_pJobDefs->RemoveAllAndRelease();
        }
        if (m_pPolicies) {
            m_pPolicies->RemoveAllAndRelease();
        }
        if (m_pManagedResources) {
            CComPtr<IHsmManagedResourceCollection> pIMRC;

            //  We can't use RemoveAllAndRelease because the Remove function for
            //  this non-standard collection tells the FSA to unmanage the resource.
            //  Then when the FSA shuts down, the list of managed resources is empty.
            //  The next time the FSA starts up, it loads an empty list of managed
            //  resources, which is wrong. The method DeleteAllAndRelesae avoids
            //  this problem.
            WsbAffirmHr(m_pManagedResources->QueryInterface(IID_IHsmManagedResourceCollection, 
                    (void**) &pIMRC));
            pIMRC->DeleteAllAndRelease();
        }
        if (m_pStoragePools) {
            m_pStoragePools->RemoveAllAndRelease();
        }
        if (m_pMessages) {
            m_pMessages->RemoveAllAndRelease();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CHsmServer::DestroyObject(
    void
    )
/*++

Implements:

  IWsbServer::DestroyObject

Return Value:
    S_OK     - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::DestroyObject"), OLESTR(""));

    CComObject<CHsmServer> *pEngDelete = (CComObject<CHsmServer> *)this;
    delete pEngDelete;

    WsbTraceOut(OLESTR("CHsmServer::DestroyObject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::CancelAllJobs( void )

/*++

Implements:

  IHsmServer::CancelAllJobs().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    BOOL                        foundRunningJob = FALSE;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmJob>            pJob;

    WsbTraceIn(OLESTR("CHsmServer::CancelAllJobs"), OLESTR(""));
    
    try {
        //
        // Set up for the loops
        //
        WsbAffirmHr(m_pJobs->QueryInterface(IID_IWsbCollection, (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));
        //
        // Loop through all jobs and cancel any currently running jobs
        //
        pJob = 0;
        for (hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
            SUCCEEDED(hr);
            pJob = 0, hr = pEnum->Next(IID_IHsmJob, (void**) &pJob)) {
            try  {
                WsbAffirmHrOk(pJob->IsActive());
                foundRunningJob = TRUE;
                WsbAffirmHr(pJob->Cancel(HSM_JOB_PHASE_ALL));
            } WsbCatchAndDo(hr2, hr = S_OK;);
        }
        //
        // Clean up end of scan return
        //
        if (WSB_E_NOTFOUND == hr)  {
            hr = S_OK;
        }

        //
        // Cancel all mounting medias so all jobs can finish
        //
        CancelMountingMedias();
            
        //
        // Make sure all jobs are done
        //
        if (TRUE == foundRunningJob)  {
            pJob = 0;
            for (hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
                SUCCEEDED(hr);
                pJob = 0, hr = pEnum->Next(IID_IHsmJob, (void**) &pJob)) {
                try  {
                    WsbAffirmHrOk(pJob->IsActive());
                    WsbAffirmHr(pJob->WaitUntilDone());
                } WsbCatchAndDo(hr2, hr = S_OK;);
            }
        }
        
        //
        // Clean up end of scan return
        //
        if (WSB_E_NOTFOUND == hr)  {
            hr = S_OK;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CancelAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::CheckManagedResources( void )

/*++

Implements:

  IHsmServer::CheckManagedResources().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IHsmManagedResource>    pMngdRes;
    CComPtr<IUnknown>               pFsaResUnknown;
    CComPtr<IFsaResource>           pFsaRes;
    
    WsbTraceIn(OLESTR("CHsmServer::CheckManagedResources"), OLESTR(""));
    
    try {
        //
        // Get an enumerator for the managed resource collection
        //
        WsbAffirmHr(m_pManagedResources->Enum(&pEnum));
        
        //
        // Scan through all managed resources and start the validation
        // job for each
        //
        pMngdRes = 0;
        for (hr = pEnum->First(IID_IHsmManagedResource,(void **)&pMngdRes );
            SUCCEEDED(hr);
            pMngdRes = 0, hr = pEnum->Next(IID_IHsmManagedResource, (void **)&pMngdRes)) {

            try  {

                pFsaResUnknown = 0;
                pFsaRes = 0;
                WsbAffirmHr(pMngdRes->GetFsaResource((IUnknown **)&pFsaResUnknown));
                WsbAffirmHr(pFsaResUnknown->QueryInterface(IID_IFsaResource, (void**) &pFsaRes));
                
                if ((pFsaRes->IsActive() == S_OK) && (pFsaRes->IsAvailable() == S_OK)) {
                    WsbAffirmHr(pFsaRes->CheckForValidate(FALSE));
                }

            } WsbCatchAndDo(hr, hr = S_OK; );
        }
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }
        
    
    } WsbCatch(hr);

    //  Release the thread (the thread should terminate on exit
    //  from the routine that called this routine)
    CloseHandle(m_CheckManagedResourcesThread);
    m_CheckManagedResourcesThread = 0;

    WsbTraceOut(OLESTR("CHsmServer::CheckManagedResources"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::GetBuildVersion( 
    ULONG *pBuildVersion
    )

/*++

Implements:

  IWsbServer::GetBuildVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CHsmServer::GetBuildVersion"), OLESTR(""));
   
    try {
        WsbAssertPointer(pBuildVersion);

        *pBuildVersion = m_buildVersion;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::GetBuildVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), RsBuildVersionAsString(m_buildVersion));
    return ( hr );
}

HRESULT
CHsmServer::GetDatabaseVersion( 
    ULONG *pDatabaseVersion
    )

/*++

Implements:

  IWsbServer::GetDatabaseVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CHsmServer::GetDatabaseVersion"), OLESTR(""));
    
    *pDatabaseVersion = m_databaseVersion;
    
    WsbTraceOut(OLESTR("CHsmServer::GetDatabaseVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbPtrToUlongAsString(pDatabaseVersion));
    return ( hr );
}

HRESULT
CHsmServer::GetNtProductVersion ( 
    OLECHAR **pNtProductVersion, 
    ULONG bufferSize
    )  
/*++

Implements:

  IWsbServer::GetNtProductVersion().

--*/

{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pNtProductVersion,  E_POINTER);
        
        tmpString = VER_PRODUCTVERSION_STRING;
        WsbAffirmHr(tmpString.CopyTo(pNtProductVersion, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}

HRESULT
CHsmServer::GetNtProductBuild( 
    ULONG *pNtProductBuild
    )

/*++

Implements:

  IWsbServer::GetNtProductBuild().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CHsmServer::GetNtProductBuild"), OLESTR(""));
   
    *pNtProductBuild = VER_PRODUCTBUILD;
    
    WsbTraceOut(OLESTR("CHsmServer::GetNtProductBuild"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbLongAsString(VER_PRODUCTBUILD));
    return ( hr );
}

HRESULT
CHsmServer::CheckAccess(
    WSB_ACCESS_TYPE AccessType
    )
/*++

Implements:

  IWsbServer::CheckAccess().

--*/
{
    WsbTraceIn(OLESTR("CHsmServer::CheckAccess"), OLESTR(""));
    HRESULT hr = S_OK;
    
    try  {

        //
        // Do the impersonation
        //
        WsbAffirmHr( CoImpersonateClient() );

        hr = WsbCheckAccess( AccessType );
    
        CoRevertToSelf();
        
    } WsbCatchAndDo( hr,

        //
        // Handle case where there is no COM context to check against
        // in which case we are the service so any security is allowed.
        //
        if( ( hr == RPC_E_NO_CONTEXT ) || ( hr != RPC_E_CALL_COMPLETE ) ) {
        
            hr = S_OK;
        
        }                      

    );
    
    WsbTraceOut(OLESTR("CHsmServer::CheckAccess"), OLESTR("hr = <%ls>"), WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CHsmServer::GetTrace(
    OUT IWsbTrace ** ppTrace
    )
/*++

Implements:

  IWsbServer::GetTrace().

--*/
{
    WsbTraceIn(OLESTR("CHsmServer::GetTrace"), OLESTR("ppTrace = <0x%p>"), ppTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(ppTrace);
        *ppTrace = 0;

        WsbAffirmPointer(m_pTrace);
        
        *ppTrace = m_pTrace;
        (*ppTrace)->AddRef();
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::GetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmServer::SetTrace(
    OUT IWsbTrace * pTrace
    )
/*++

Implements:

  IWsbServer::SetTrace().

--*/
{
    WsbTraceIn(OLESTR("CHsmServer::SetTrace"), OLESTR("pTrace = <0x%p>"), pTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(pTrace);

        m_pTrace = pTrace;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::SetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmServer::NotifyAllJobs( HSM_JOB_STATE jobState )

/*++


Routine Description:

    Notify all jobs of a change in status.

Arguments:

    jobState - New job state.

Return Value:

    S_OK - Success
            
--*/

{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmJob>            pJob;

    WsbTraceIn(OLESTR("CHsmServer::NotifyAllJobs"), OLESTR(""));
    
    try {
        //
        // Set up for the loops
        //
        WsbAffirmHr(m_pJobs->QueryInterface(IID_IWsbCollection, 
                (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));
        //
        // Loop through all jobs and notify any currently running jobs
        //
        pJob = 0;
        for (hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
            SUCCEEDED(hr);
            pJob = 0, hr = pEnum->Next(IID_IHsmJob, (void**) &pJob)) {
            try  {
                if (S_OK == pJob->IsActive()) {
                    if (HSM_JOB_STATE_PAUSING == jobState) {
                        WsbAffirmHr(pJob->Pause(HSM_JOB_PHASE_ALL));
                    } else {
                        WsbAffirmHr(pJob->Resume(HSM_JOB_PHASE_ALL));
                    }
                }
            } WsbCatchAndDo(hr2, hr = S_OK;);
        }
        //
        // Clean up end of scan return
        //
        if (WSB_E_NOTFOUND == hr)  {
            hr = S_OK;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::NotifyAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

//
// Retrieves the Media Manager object
//
HRESULT CHsmServer::GetHsmMediaMgr(
    IRmsServer  **ppHsmMediaMgr
    )
{
    HRESULT hr = S_OK;

    // If the Media Manager has been created, return the pointer. Otherwise, fail.
    try {
        WsbAssert(0 != ppHsmMediaMgr, E_POINTER);
        *ppHsmMediaMgr = m_pHsmMediaMgr;
        WsbAffirm(m_pHsmMediaMgr != 0, E_FAIL);
        m_pHsmMediaMgr->AddRef();
    } WsbCatch(hr);

    return (hr);
}

HRESULT
CHsmServer::GetCopyFilesUserLimit(
    OUT ULONG* pLimit
    )

/*++

Implements:

  CHsmServer::GetCopyFilesUserLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetCopyFilesUserLimit"), OLESTR(""));

    try {

        WsbAssert(0 != pLimit, E_POINTER);
        *pLimit = m_copyfilesUserLimit;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetCopyFilesUserLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::SetCopyFilesUserLimit(
    IN ULONG limit
    )

/*++

Implements:

  CHsmServer::SetCopyFilesUserLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SetCopyFilesUserLimit"), OLESTR(""));

    m_copyfilesUserLimit= limit;

    WsbTraceOut(OLESTR("CHsmServer::SetCopyFilesUserLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::GetCopyFilesLimit(
    OUT ULONG* pLimit
    )

/*++

Implements:

  CHsmServer::GetCopyFilesLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetCopyFilesLimit"), OLESTR(""));

    try {
        CComPtr<IHsmStoragePool>    pStoragePool;
        ULONG                       count;
        GUID                        mediaSetId;
        CWsbBstrPtr                 dummy;
        DWORD                       dwNofDrives;

        WsbAssert(0 != pLimit, E_POINTER);

        // Get relevant media set - assume only one pool !!
        WsbAffirmHr(m_pStoragePools->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(m_pStoragePools->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &dummy));

        // Get number of available drives in the system
        WsbAffirmHr(m_pHsmMediaMgr->GetNofAvailableDrives(mediaSetId, &dwNofDrives));

        // Deteremine actual limit
        *pLimit = max(1, min(m_copyfilesUserLimit, dwNofDrives));
        WsbTrace(OLESTR("CHsmServer::GetCopyFilesLimit: Limit is %lu\n"), *pLimit);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetCopyFilesLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::AreJobsEnabled( void )

/*++

Implements:

  IHsmServer::AreJobsDisabled().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::AreJobsEnabled"), OLESTR(""));

    EnterCriticalSection(&m_JobDisableLock);

    hr = (m_JobsEnabled ? S_OK : S_FALSE);

    LeaveCriticalSection(&m_JobDisableLock);

    WsbTraceOut(OLESTR("CHsmServer::AreJobsEnabled"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::EnableAllJobs( void )

/*++

Implements:

  IHsmServer::EnableAllJobs().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::EnableAllJobs"), OLESTR(""));

    EnterCriticalSection(&m_JobDisableLock);

    try {

        m_JobsEnabled = TRUE;
        WsbAffirmHr(RestartSuspendedJobs());

    } WsbCatch(hr);

    LeaveCriticalSection(&m_JobDisableLock);

    WsbTraceOut(OLESTR("CHsmServer::EnableAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::DisableAllJobs( void )

/*++

Implements:

  IHsmServer::DisableAllJobs().

Notes:

  The medthod tries to disable all jobs.
  If any job is active or starting, it fails with HSM_E_DISABLE_RUNNING_JOBS and calls 
  RestartSuspendedJobs to restart any job that alreay became suspended beacuse of this 
  unsuccessful disabling attempt.

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::DisableAllJobs"), OLESTR(""));

    EnterCriticalSection(&m_JobDisableLock);

    try {
        ULONG                          nJobs;

        m_JobsEnabled = FALSE;

        // Loop over jobs
        WsbAffirmHr(m_pJobs->GetEntries(&nJobs));
        for (ULONG i = 0; i < nJobs; i++) {
            CComPtr<IHsmJob>               pJob;
            HSM_JOB_STATE                  state;

            WsbAffirmHr(m_pJobs->At(i, IID_IHsmJob, (void**) &pJob));

            // Check if this job is suspended
            WsbAffirmHr(pJob->GetState(&state));
            if ((HSM_JOB_STATE_ACTIVE == state) || (HSM_JOB_STATE_STARTING == state)) {
                // Cannot disable jobs
                m_JobsEnabled = TRUE;
                hr = HSM_E_DISABLE_RUNNING_JOBS;
                RestartSuspendedJobs();
                break;
            }
        }

    } WsbCatch(hr);

    LeaveCriticalSection(&m_JobDisableLock);

    WsbTraceOut(OLESTR("CHsmServer::DisableAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::RestartSuspendedJobs(
    void
    )

/*++

Implements:

  IHsmServer::RestartSuspendedJobs().

--*/
{
    HRESULT                        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::RestartSuspendedJobs"), OLESTR(""));
    try {
        ULONG                          nJobs;

        // Loop over jobs
        // Note: this algorithm is unfair because jobs at the end of the
        // list could "starve" because jobs at the beginning are more likely
        // to get started.  The assumption is that there should be very few
        // jobs waiting to run.  If this assumption proves to be false, some
        WsbAffirmHr(m_pJobs->GetEntries(&nJobs));
        // sort of priority scheme will be needed.
        for (ULONG i = 0; i < nJobs; i++) {
            CComPtr<IHsmJob>               pJob;
            HSM_JOB_STATE                  state;

            WsbAffirmHr(m_pJobs->At(i, IID_IHsmJob, (void**) &pJob));

            // Check if this job is suspended
            WsbAffirmHr(pJob->GetState(&state));
            if (HSM_JOB_STATE_SUSPENDED == state) {
                // This may fail, but we don't care
                pJob->Restart();
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::RestartSuspendedJobs"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmServer::LockMountingMedias( void )

/*++

Implements:

  IHsmServer::LockMountingMedias().

--*/
{
    HRESULT     hr = S_OK;

    EnterCriticalSection(&m_MountingMediasLock);

    return(hr);
}

HRESULT
CHsmServer::UnlockMountingMedias( void )

/*++

Implements:

  IHsmServer::UnlockMountingMedias().

--*/
{
    HRESULT     hr = S_OK;

    LeaveCriticalSection(&m_MountingMediasLock);

    return(hr);
}

HRESULT
CHsmServer::ResetSegmentValidMark( void )

/*++

Implements:

  IHsmServer::ResetSegmentValidMark().

--*/
{
    HRESULT                 hr = S_OK;

    BOOL                    bOpenDb = FALSE;
    CComPtr<IWsbDbSession>  pDbSession;

    WsbTraceIn(OLESTR("CHsmServer::ResetSegmentValidMark"), OLESTR(""));

    try {
        CComPtr<ISegRec>    pSegRec;
        USHORT              uSegFlags;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));
        bOpenDb = TRUE;

        // Traverse segment records
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, HSM_SEG_REC_TYPE, 
                IID_ISegRec, (void**)&pSegRec));

        for (hr = pSegRec->First(); S_OK == hr; hr = pSegRec->Next()) {
            WsbAffirmHr(pSegRec->GetSegmentFlags(&uSegFlags));
            if (uSegFlags & SEG_REC_MARKED_AS_VALID) {
                // Need to reset this bit
                uSegFlags &= ~SEG_REC_MARKED_AS_VALID;
                WsbAffirmHr(pSegRec->SetSegmentFlags(uSegFlags));
                WsbAffirmHr(pSegRec->Write());
            }
        }

        // If we fell out of the loop because we ran out of segments, reset the HRESULT
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        } else {
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    if (bOpenDb) {
        hr = m_pSegmentDatabase->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CHsmServer::ResetSegmentValidMark"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::ResetMediaValidBytes( void )

/*++

Implements:

  IHsmServer::ResetMediaValidBytes().

--*/
{
    HRESULT                 hr = S_OK;

    BOOL                    bOpenDb = FALSE;
    CComPtr<IWsbDbSession>  pDbSession;

    WsbTraceIn(OLESTR("CHsmServer::ResetMediaValidBytes"), OLESTR(""));

    try {
        CComPtr<IMediaInfo>    pMediaInfo;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));
        bOpenDb = TRUE;

        // Traverse segment records
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE,
                        IID_IMediaInfo, (void**)&pMediaInfo));

        for (hr = pMediaInfo->First(); S_OK == hr; hr = pMediaInfo->Next()) {
            WsbAffirmHr(pMediaInfo->SetLogicalValidBytes(0));
            WsbAffirmHr(pMediaInfo->Write());
        }

        // If we fell out of the loop because we ran out of segments, reset the HRESULT
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        } else {
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    if (bOpenDb) {
        hr = m_pSegmentDatabase->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CHsmServer::ResetMediaValidBytes"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::GetSegmentPosition( 
    IN REFGUID bagId, 
    IN LONGLONG fileStart,
    IN LONGLONG fileSize, 
    OUT GUID* pPosMedia,
    OUT LONGLONG* pPosOffset)

/*++

Implements:

  IHsmServer::GetSegmentPosition().

--*/
{
    HRESULT                 hr = S_OK;

    BOOL                    bOpenDb = FALSE;
    CComPtr<IWsbDbSession>  pDbSession;
    CComPtr<ISegDb>         pSegDb;

    WsbTraceIn(OLESTR("CHsmServer::GetSegmentPosition"), OLESTR(""));

    try {
        CComPtr<ISegRec>    pSegRec;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));
        bOpenDb = TRUE;

        // Find segemnt
        WsbAffirmHr(m_pSegmentDatabase->QueryInterface(IID_ISegDb, (void**) &pSegDb));
        WsbAffirmHr(pSegDb->SegFind(pDbSession, bagId, fileStart, fileSize, &pSegRec));

        // Extract output
        WsbAffirmHr(pSegRec->GetPrimPos(pPosMedia));
        WsbAffirmHr(pSegRec->GetSecPos(pPosOffset));

    } WsbCatch(hr);

    if (bOpenDb) {
        hr = m_pSegmentDatabase->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CHsmServer::GetSegmentPosition"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

void
CHsmServer::StopAutosaveThread(
    void
    )
/*++

Routine Description:

  Stop the Autosave thread:
    First try gracefully, using the termination event
    If doesn't work, just terminate the thread

Arguments:

  None.
  
Return Value:

  S_OK  - Success.

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StopAutosaveThread"), OLESTR(""));

    try {
        // Terminate the autosave thread
        if (m_autosaveThread) {
            // Signal thread to terminate
            SetEvent(m_terminateEvent);

            // Wait for the thread, if it doesn't terminate gracefully - kill it
            switch (WaitForSingleObject(m_autosaveThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: force terminating of autosave thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_autosaveThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_autosaveThread, 0)) {
                                WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: Autosave thread terminated gracefully\n"));
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_autosaveThread);
            m_autosaveThread = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StopAutosaveThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

HRESULT
CHsmServer::InternalSavePersistData(
    void
    )

/*++

Implements:

  CHsmServer::InternalSavePersistData().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::InternalSavePersistData"), OLESTR(""));

    try {
        DWORD   status, errWait;
        CComPtr<IPersistFile>  pPersistFile;
    
        // Synchronize saving of persistent data with snapshot signaling event
        status = WaitForSingleObject(m_savingEvent, EVENT_WAIT_TIMEOUT);
        
        // Save anyway, then report if the Wait function returned an unexpected error
        errWait = GetLastError();
        
        // Note: Don't throw exception here because even if saving fails, we still need 
        //  to set the saving event.
        hr = (((IUnknown*) (IHsmServer*) this)->QueryInterface(IID_IPersistFile, 
                (void**) &pPersistFile));
        if (SUCCEEDED(hr)) {
            hr = WsbSafeSave(pPersistFile);
        }

        // Check Wait status... Note that hr remains OK because the saving itself completed fine
        switch (status) {
            case WAIT_OBJECT_0: 
                // The expected case
                SetEvent(m_savingEvent);
                break;

            case WAIT_TIMEOUT: 
                // Don't log anything for now: This might happen if snapshot process takes 
                //  too long for some reason, but logging seems to just confuse the user -
                //  he really can not (and should not) do anything...
                WsbTraceAlways(OLESTR("CHsmServer::InternalSavePersistData: Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                break;

            case WAIT_FAILED:
                WsbTraceAlways(OLESTR("CHsmServer::InternalSavePersistData: Wait for Single Object returned error %lu\n"), errWait);
                break;

            default:
                WsbTraceAlways(OLESTR("CHsmServer::InternalSavePersistData: Wait for Single Object returned unexpected status %lu\n"), status);
                break;
        }         

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::InternalSavePersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::CancelMountingMedias( void )

/*++

Implements:

  CHsmServer::CancelMountingMedias().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IMountingMedia>     pMountingMedia;

    WsbTraceIn(OLESTR("CHsmServer::CancelMountingMedias"), OLESTR(""));
    
    try {

        WsbAffirmHr(m_pMountingMedias->Enum(&pEnum));

        // Loop through all mounting media and release waiting mounting clients
        for (hr = pEnum->First(IID_IMountingMedia, (void**) &pMountingMedia);
            SUCCEEDED(hr);
            hr = pEnum->Next(IID_IMountingMedia, (void**) &pMountingMedia)) {

            pMountingMedia->MountDone();
            pMountingMedia = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CancelMountingMedias"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



//
// Methods of the class which uses to upgrade a Win2K rms to current rms
//
HRESULT
CHsmUpgradeRmsDb::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::FinalConstruct"), OLESTR("") );

    try {
        WsbAffirmHr(CWsbPersistable::FinalConstruct());

        m_pServer = NULL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

void
CHsmUpgradeRmsDb::FinalRelease(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::FinalRelease"), OLESTR(""));

    CWsbPersistable::FinalRelease();

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}

HRESULT
CHsmUpgradeRmsDb::GetClassID(
    OUT CLSID* pClsid)
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        // Return Rms class id since this is what the old col file represents
        *pClsid = CLSID_CRmsServer;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return hr;
}

HRESULT
CHsmUpgradeRmsDb::Save(
    IN IStream* /*pStream*/,
    IN BOOL /*clearDirty*/
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::Save"), OLESTR(""));
    
    // Not implemented - this class should be used only for load

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmUpgradeRmsDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::Load"), OLESTR(""));

    try {
        ULONG   buildVersion;
        ULONG   databaseVersion;
        ULONG   expectedVersion = RMS_WIN2K_DB_VERSION;
        
        WsbAssert(0 != pStream, E_POINTER);

        // Make sure this is the right version of the Rms database to load
        WsbAffirmHr(WsbLoadFromStream(pStream, &databaseVersion));
        if (databaseVersion != expectedVersion) {
            WsbLogEvent( RMS_MESSAGE_DATABASE_VERSION_MISMATCH, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&expectedVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&databaseVersion)), NULL );
            WsbThrow(RMS_E_DATABASE_VERSION_MISMATCH);
        }

        // Read in the build version but don't do anything with it.
        WsbAffirmHr(WsbLoadFromStream(pStream, &buildVersion));
        
        // Let Rms manager to this its load
        CComPtr<IPersistStream> pIStream;
        WsbAffirmHr(m_pServer->QueryInterface(IID_IPersistStream, (void **)&pIStream));
        WsbAffirmHr(pIStream->Load(pStream));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CHsmUpgradeRmsDb::Init(
    IN IRmsServer *pHsmMediaMgr
    )
/*++

Implements:

  IHsmUpgradeRmsDb::Init().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::Init"),OLESTR(""));

    try {
       WsbAssert(0 != pHsmMediaMgr, E_POINTER);

       m_pServer = pHsmMediaMgr;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\mountmed.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    mountmed.cpp

Abstract:

    This component is an object representing a mounting media, i.e. a media in the process of mounting.

Author:

    Ran Kalach   [rankala]   28-Sep-2000

Revision History:

--*/

#include "stdafx.h"
#include "mountmed.h"

static USHORT iCountMount = 0;  // Count of existing objects

HRESULT
CMountingMedia::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::FinalConstruct"), OLESTR(""));

    m_mediaId = GUID_NULL;
    m_mountEvent = NULL;
    m_bReadOnly = FALSE;

    iCountMount++;

    WsbTraceOut(OLESTR("CMountingMedia::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"), WsbHrAsString(hr), (int)iCountMount);

    return(hr);
}

void
CMountingMedia::FinalRelease(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CMountingMedia::FinalRelease"), OLESTR(""));

    // Free event handle
    if (m_mountEvent != NULL) {
        // Set the event (just to be on the safe side - we expect the event to be signaled at this point)
        SetEvent(m_mountEvent);

        CloseHandle(m_mountEvent);
        m_mountEvent = NULL;
    }

    iCountMount--;

    WsbTraceOut(OLESTR("CMountingMedia::FinalRelease"), OLESTR("Count is <%d>"), (int)iCountMount);
}

HRESULT
CMountingMedia::Init(
    REFGUID mediaId,
    BOOL bReadOnly
    )
/*++

Implements:

  IMountingMedia::Init().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::Init"), OLESTR(""));

    try {
        m_mediaId = mediaId;
        m_bReadOnly = bReadOnly;

        WsbAffirmHandle(m_mountEvent= CreateEvent(NULL, TRUE, FALSE, NULL));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMountingMedia::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::GetMediaId(
    GUID *pMediaId
    )
/*++

Implements:

  IMountingMedia::GetMediaId().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::GetMediaId"), OLESTR(""));

    try {
        WsbAffirm(0 != pMediaId, E_POINTER);

        *pMediaId = m_mediaId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMountingMedia::GetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::SetMediaId(
    REFGUID mediaId
    )
/*++

Implements:

  IMountingMedia::SetMediaId().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::SetMediaId"), OLESTR(""));

    m_mediaId = mediaId;

    WsbTraceOut(OLESTR("CMountingMedia::SetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::SetIsReadOnly(
    BOOL bReadOnly
    )
/*++

Implements:

  IMountingMedia::SetIsReadOnly().

--*/
{
    WsbTraceIn(OLESTR("CMountingMedia::SetIsReadOnly"), OLESTR("bReadOnly = %d"), bReadOnly);

    m_bReadOnly = bReadOnly;

    WsbTraceOut(OLESTR("CMountingMedia::SetIsReadOnly"), OLESTR(""));

    return(S_OK);
}

HRESULT
CMountingMedia::IsReadOnly(
    void    
    )
/*++

Implements:

  IMountingMedia::IsReadOnly().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::IsReadOnly"), OLESTR(""));

    hr = (m_bReadOnly ? S_OK : S_FALSE);

    WsbTraceOut(OLESTR("CMountingMedia::IsReadOnly"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
                                
HRESULT
CMountingMedia::WaitForMount(
    DWORD dwTimeout
    )
/*++

Implements:

  IMountingMedia::WaitForMount().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::WaitForMount"), OLESTR(""));

    // Wait for the mount event for the given timeout
    switch (WaitForSingleObject(m_mountEvent, dwTimeout)) {
        case WAIT_OBJECT_0:
            WsbTrace(OLESTR("CMountingMedia::WaitForMount: signaled that media is mounted\n"));
            break;

        case WAIT_TIMEOUT: 
            WsbTrace(OLESTR("CMountingMedia::WaitForMount: WaitForSingleObject timed out after waiting for %lu ms\n"), dwTimeout);
            hr = E_FAIL;
            break;

        case WAIT_FAILED:
        default:
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
            WsbTrace(OLESTR("CMountingMedia::WaitForMount: WaitForSingleObject returned error %lu\n"), dwErr);
            break;
    }

    WsbTraceOut(OLESTR("CMountingMedia::WaitForMount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::MountDone(
    void
    )
/*++

Implements:

  IMountingMedia::MountDone().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::MountDone"), OLESTR(""));

    // Mount is done: set the mount event
    if (! SetEvent(m_mountEvent)) {
        DWORD dwErr = GetLastError();
        WsbTrace(OLESTR("CMountingMedia::MountDone: SetEvent returned error %lu\n"), dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    WsbTraceOut(OLESTR("CMountingMedia::MountDone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::IsEqual(
    IUnknown* pCollectable
    )
/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::IsEqual"), OLESTR(""));

    hr = CompareTo(pCollectable, NULL);

    WsbTraceOut(OLESTR("CMountingMedia::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::CompareTo(
    IUnknown* pCollectable, 
    SHORT* pResult
    )
/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    SHORT                       result = 0;
    CComPtr<IMountingMedia>     pMountingMedia;
    GUID                        mediaId;

    WsbTraceIn(OLESTR("CMountingMedia::CompareTo"), OLESTR(""));

    try {
        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(pCollectable->QueryInterface(IID_IMountingMedia, (void**) &pMountingMedia));
        WsbAffirmHr(pMountingMedia->GetMediaId(&mediaId));

        // Compare
        if (IsEqualGUID(m_mediaId, mediaId)) {
            hr = S_OK;
            result = 0;
        } else {
            // Need to provide signed result...
            hr = S_FALSE;
            result = WsbSign(memcmp(&m_mediaId, &mediaId, sizeof(GUID)));
        }

        // If they asked for the relative value back, then return it to them.
        if (pResult != NULL) {
            *pResult = result;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMountingMedia::CompareTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\mountmed.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    mountmed.h

Abstract:

    This component is an object representing a mounting media, i.e. a media in the process of mounting.

Author:

    Ran Kalach   [rankala]   28-Sep-2000

Revision History:

--*/

#ifndef _MOUNTMED_
#define _MOUNTMED_

#include "wsbcltbl.h"

/*++

Class Name:
    
    CMountingMedia

Class Description:

    An object representing a media in the process of mounting. 
    It is collectable but not persistable.

--*/
class CMountingMedia : 
    public CComObjectRoot,
    public IMountingMedia,
    public IWsbCollectable,
    public CComCoClass<CMountingMedia, &CLSID_CMountingMedia>
{
public:
    CMountingMedia() {}
BEGIN_COM_MAP(CMountingMedia)
    COM_INTERFACE_ENTRY(IMountingMedia)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CMountingMedia)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IN IUnknown* pCollectable, OUT SHORT* pResult);
    STDMETHOD(IsEqual)(IN IUnknown* pCollectable);

// IMountingMedia
public:
    STDMETHOD(Init)(IN REFGUID mediaId, IN BOOL bReadOnly);
    STDMETHOD(GetMediaId)(OUT GUID *pMediaId);
    STDMETHOD(SetMediaId)(IN REFGUID MediaId);
    STDMETHOD(WaitForMount)(IN DWORD dwTimeout);
    STDMETHOD(MountDone) (void);
    STDMETHOD(SetIsReadOnly)(IN BOOL bReadOnly);
    STDMETHOD(IsReadOnly)(void);

protected:
    GUID            m_mediaId;
    HANDLE          m_mountEvent;
    BOOL            m_bReadOnly;
};

#endif // _MOUNTMED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HsmEng.rc
//
#define IDS_HSMSERVER_DESC              1
#define IDR_HsmServer                   1
#define IDS_SERVICENAME                 100
#define IDR_HsmEng                      100
#define IDS_SERVICE_DISPLAYNAME         101
#define IDS_SERVICE_DESCRIPTION         102
#define IDS_PRODUCT_NAME                103
#define IDR_CHsmManagedResource         201
#define IDR_CHsmManagedResourceCollection 301
#define IDR_CHsmStoragePool             401
#define IDR_HsmUpgradeRmsDb             501
#define IDR_CMountingMedia              601

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        701
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         301
#define _APS_NEXT_SYMED_VALUE           301
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMENG

#include <wsb.h>
#include <Engine.h>
#include "engcommn.h"
#include "resource.h"
#include "esent.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\rswriter.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    rswriter.cpp

Abstract:

    Implements CRssJetWriter methods

Author:

    Ran Kalach          [rankala]         4/4/2000

Revision History:

--*/

#include "stdafx.h"
#include "rsevents.h"
#include "rswriter.h"

// Include these 2 files just for VSS_E_WRITERERROR_TIMEOUT definition
#include "vss.h"
#include "vswriter.h"   

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(RSS_WRITER_GUID, 0xb959d2c3L, 0x18bb, 0x4607,  0xb0, 0xca, 
0x68,  0x8c, 0xd0, 0xd4, 0x1a, 0x50);       // {b959d2c3-18bb-4607-b0ca-688cd0d41a50}

#ifdef __cplusplus
}
#endif


#define     FILES_TO_EXCLUDE    OLESTR("%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*;%SystemRoot%\\System32\\RemoteStorage\\Trace\\*")
#define     FILES_TO_INCLUDE    OLESTR("")

CRssJetWriter::CRssJetWriter()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

Notes:
    We create the events in the constructor because these events might be required
    before the Init code could be done (Init must be called after Jet is initialized

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::CRssJetWriter"), OLESTR(""));

    m_bTerminating = FALSE;

    try {
        for (int index=0; index<WRITER_EVENTS_NUM; index++) {
            m_syncHandles[index] = NULL;
        }

        // Create the events
        WsbAffirmHandle(m_syncHandles[INTERNAL_EVENT_INDEX] = CreateEvent(NULL, FALSE, TRUE, NULL));
        WsbAffirmHandle(m_syncHandles[1] = CreateEvent(NULL, FALSE, TRUE, HSM_ENGINE_STATE_EVENT));
        WsbAffirmHandle(m_syncHandles[2] = CreateEvent(NULL, FALSE, TRUE, HSM_FSA_STATE_EVENT));
        WsbAffirmHandle(m_syncHandles[3] = CreateEvent(NULL, FALSE, TRUE, HSM_IDB_STATE_EVENT));

    } WsbCatch(hr);

    m_hrInit = hr;

    WsbTraceOut(OLESTR("CRssJetWriter::CRssJetWriter"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

CRssJetWriter::~CRssJetWriter( )
/*++

Routine Description:

    Destructor - free resources

Arguments:

    None

Return Value:

    None

--*/
{
    WsbTraceIn(OLESTR("CRssJetWriter::~CRssJetWriter"), OLESTR(""));

    // Close event handles
    for (int index=0; index<WRITER_EVENTS_NUM; index++) {
        if (NULL != m_syncHandles[index]) {
            CloseHandle(m_syncHandles[index]);
            m_syncHandles[index] = NULL;
        }
    }

    WsbTraceOut(OLESTR("CRssJetWriter::~CRssJetWriter"), OLESTR(""));
}

HRESULT CRssJetWriter::Init(void)
/*++

Routine Description:

    Initialize Snapshot synchronization

Arguments:

    None

Return Value:

    S_OK            - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::Init"), OLESTR(""));

    try {
        // Don't do anything if the basic initialization done in the constructor failed
        WsbAffirmHr(m_hrInit);

        GUID rssGuid = RSS_WRITER_GUID;
        WsbAffirmHr(Initialize(
                		rssGuid,
		                RSS_BACKUP_NAME,
                		TRUE,
                		FALSE,
		                FILES_TO_INCLUDE,
		                FILES_TO_EXCLUDE
		                ));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRssJetWriter::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CRssJetWriter::Terminate(void)
/*++

Routine Description:

    Terminate Snapshot synchronization

Arguments:

    None

Return Value:

    S_OK            - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::Terminate"), OLESTR(""));

    try {
        DWORD   status, errWait;

        WsbAffirmHr(m_hrInit);

        // Avoid terminating in the middle of snapshot
        status = WaitForSingleObject(m_syncHandles[INTERNAL_EVENT_INDEX], INTERNAL_WAIT_TIMEOUT);
        errWait = GetLastError();

        // Whatever the status is - uninitialize underlying writer mechanizm
        m_bTerminating = TRUE;
        Uninitialize();

        // Check Wait status:
        if (status == WAIT_OBJECT_0) {
            // The expected case
            if (! SetEvent(m_syncHandles[INTERNAL_EVENT_INDEX])) {
                // Don't abort, just trace error
                WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: SetEvent returned unexpected error %lu\n"), GetLastError());
            }
            WsbTrace(OLESTR("CRssJetWriter::Terminate: Terminating after a successful wait\n"));

        } else {
            // In case of failure we cannot trust Thaw/Abort to be called so we signal the evnets
            InternalEnd();

            switch (status) {
                case WAIT_TIMEOUT: 
                    WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: Wait for Single Object timed out after %lu ms\n"), INTERNAL_WAIT_TIMEOUT);
                    hr = E_FAIL;
                    break;

                case WAIT_FAILED:
                    WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: Wait for Single Object returned error %lu\n"), errWait);
                    hr = HRESULT_FROM_WIN32(errWait);
                    break;

                default:
                    WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: Wait for Single Object returned unexpected status %lu\n"), status);
                    hr = E_UNEXPECTED;
                    break;
            }         
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRssJetWriter::Terminate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CRssJetWriter::InternalEnd(void)
/*++

Routine Description:

    Set all events

Arguments:

    None

Return Value:

    S_OK            - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::InternalEnd"), OLESTR(""));

    try {
        WsbAffirmHr(m_hrInit);

        // Set all events
        DWORD errSet;
        for (int index=0; index<WRITER_EVENTS_NUM; index++) {
            if (NULL != m_syncHandles[index]) {
                if (! SetEvent(m_syncHandles[index])) {
                    // Don't abort, just save error
                    errSet = GetLastError();
                    WsbTraceAlways(OLESTR("CRssJetWriter::InternalEnd: SetEvent returned error %lu for event number %d\n"), errSet, index);
                    hr  = HRESULT_FROM_WIN32(errSet);
                }
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRssJetWriter::InternalEnd"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
//  CVssJetWriter overloaded methods
//
bool STDMETHODCALLTYPE CRssJetWriter::OnFreezeBegin()
/*++

Routine Description:

    Handles Freeze Start event

Arguments:

    None

Return Value:

    TRUE            - Success, OK to freeze
    FALSE           - Failure, Don't freeze

--*/
{
    HRESULT                     hr = S_OK;
    bool                        bRet;

    WsbTraceIn(OLESTR("CRssJetWriter::OnFreezeBegin"), OLESTR(""));

    try {
        WsbAffirmHr(m_hrInit);

        // Just wait for all sync events
        DWORD status = WaitForMultipleObjects(WRITER_EVENTS_NUM, m_syncHandles, TRUE, EVENT_WAIT_TIMEOUT);

        // Comparing (status == WAIT_OBJECT_0) || (status > WAIT_OBJECT_0) intsead of (status >= WAIT_OBJECT_0) 
        //  to avoid error C4296 - "expression is always true"
        if ( ((status == WAIT_OBJECT_0) || (status > WAIT_OBJECT_0)) && 
             (status <= WAIT_OBJECT_0 + WRITER_EVENTS_NUM - 1) ) {
            // Freeze is ready to go...
            WsbTrace(OLESTR("CRssJetWriter::OnFreezeBegin: All events are nonsignaled, freeze is reday to go\n"));

            // If we are terminating, no Thaw/Abort will be called - therefore, set the events
            if (m_bTerminating) {
                InternalEnd();
            }

        } else {
            // Something wrong...            
            DWORD errWait = GetLastError();

            // Set all events in case of an error 
            InternalEnd();

            switch(status) {
                case WAIT_FAILED:
                    WsbTraceAlways(OLESTR("CRssJetWriter::OnFreezeBegin: Wait for Multiple Objects returned error %lu\n"), errWait);
                    WsbThrow(HRESULT_FROM_WIN32(errWait));
                    break;

                case WAIT_TIMEOUT:
                    // Timeout means that one of the sync components is taking too long
                    WsbTraceAlways(OLESTR("CRssJetWriter::OnFreezeBegin: Wait for Multiple Objects timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                    WsbThrow(VSS_E_WRITERERROR_TIMEOUT);
                    break;

                default:
                    WsbTraceAlways(OLESTR("CRssJetWriter::OnFreezeBegin: Wait for Multiple Objects returned unexpected status %lu\n"), status);
                    WsbThrow(E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    if (S_OK == hr) {
        bRet = CVssJetWriter::OnFreezeBegin();
    } else {
        bRet = false;
    }

    WsbTraceOut(OLESTR("CRssJetWriter::OnFreezeBegin"), OLESTR("hr = <%ls> , bRet = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(bRet));

    return bRet;
}

bool STDMETHODCALLTYPE CRssJetWriter::OnThawEnd(IN bool fJetThawSucceeded)
/*++

Routine Description:

    Handles Thaw End event

Arguments:

    fJetThawSucceeded      - Ignored

Return Value:

    TRUE            - Success
    FALSE           - Failure

--*/
{
    bool                        bRet;

    WsbTraceIn(OLESTR("CRssJetWriter::OnThawEnd"), OLESTR(""));

    // Return value is determined by base class, ignore internal errors here
    bRet = CVssJetWriter::OnThawEnd(fJetThawSucceeded);

    // Release all waiting events
    InternalEnd();

    WsbTraceOut(OLESTR("CRssJetWriter::OnThawEnd"), OLESTR("bRet = <%ls>"), WsbBoolAsString(bRet));

    return bRet;
}

void STDMETHODCALLTYPE CRssJetWriter::OnAbortEnd()
/*++

Routine Description:

    Handles Abort End event

Arguments:

    None

Return Value:

    None

--*/
{
    WsbTraceIn(OLESTR("CRssJetWriter::OnAbortEnd"), OLESTR(""));

    // Call base class imp.
    CVssJetWriter::OnAbortEnd();

    // Release all waiting events
    InternalEnd();

    WsbTraceOut(OLESTR("CRssJetWriter::OnAbortEnd"), OLESTR(""));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\baghole.h ===
// BagHole.h : Declaration of the CBagHole


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// Task

class CBagHole : 
    public CWsbDbEntity,
    public IBagHole,
    public CComCoClass<CBagHole,&CLSID_CBagHole>
{
public:
    CBagHole() {}
BEGIN_COM_MAP(CBagHole)
    COM_INTERFACE_ENTRY(IBagHole)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CBagHole, _T("Task.BagHole.1"), _T("Task.BagHole"), IDS_BAGHOLE_DESC, THREADFLAGS_BOTH)

// IBagHole
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
//*/
// IBagHole
public:
    STDMETHOD(GetBagHole)(GUID* pBagId, LONGLONG *pSegStartLoc, LONGLONG *pSegLen );
    STDMETHOD(SetBagHole)(GUID bagId, LONGLONG segStartLoc, LONGLONG SegLen );

private:
    GUID            m_BagId;
    LONGLONG        m_SegStartLoc;
    LONGLONG        m_SegLen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\baghole.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BagHole.cpp

Abstract:

    This component is an object representation of the HSM Metadata bag hole record.

Author:

    Cat Brant   [cbrant]   26-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "BagHole.h"

#undef  WSB_TRACE_IS        
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

HRESULT 
CBagHole::GetBagHole(
    OUT GUID *pBagId, 
    OUT LONGLONG *pSegStartLoc, 
    OUT LONGLONG *pSegLen 
    ) 
/*++

Routine Description:

  See IBagHole::GetBagHole

Arguments:

  See IBagHole::GetBagHole

Return Value:
  
    See IBagHole::GetBagHole

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::GetBagHole"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pSegStartLoc, E_POINTER);
        WsbAssert(0 != pSegLen, E_POINTER);

        //Provide the data members
        *pBagId = m_BagId;
        *pSegStartLoc = m_SegStartLoc;
        *pSegLen = m_SegLen;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::GetBagHole"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>"),
        WsbPtrToGuidAsString(pBagId), 
        WsbStringCopy(WsbPtrToLonglongAsString(pSegStartLoc)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSegLen)));
    return(hr);

}


HRESULT 
CBagHole::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_SegStartLoc = 0;
        m_SegLen = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CBagHole::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CBagHole;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CBagHole::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(ULONG) +  WsbPersistSizeOf(ULONG);

        pcbSize->QuadPart = WsbPersistSizeOf(CBagHole); //???????
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CBagHole::Load
(
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegStartLoc));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegLen));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CBagHole::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>, SegStartLoc = <%lu>, SegLen = <%lu>"), 
        WsbHrAsString(hr), WsbGuidAsString(m_BagId),m_SegStartLoc, m_SegLen);

    return(hr);
}


HRESULT CBagHole::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                WsbGuidAsString(m_BagId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", StartLoc = %ls"), 
                WsbLonglongAsString(m_SegStartLoc)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegLen = %ls"), 
                WsbLonglongAsString(m_SegLen)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CBagHole::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegStartLoc));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegLen));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CBagHole::SetBagHole
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Routine Description:

  See IBagHole::SetBagHole().

Arguments:

  See IBagHole::SetBagHole().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CBagHole::SetBagHole"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>"), WsbGuidAsString(BagId), 
        WsbLonglongAsString(SegStartLoc), WsbLonglongAsString(SegLen));

    m_isDirty = TRUE;
    m_BagId = BagId;
    m_SegStartLoc = SegStartLoc;
    m_SegLen = SegLen;

    WsbTraceOut(OLESTR("CBagHole::SetBagHole"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CBagHole::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
#if 0
    HRESULT                 hr = S_OK;
    CComPtr<IBagHole>       pBagHole1;
    CComPtr<IBagHole>       pBagHole2;
    GUID                    l_BagId;
    LONGLONG                    l_SegStartLoc;
    LONGLONG                    l_SegLen;

    WsbTraceIn(OLESTR("CBagHole::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pBagHole interface.
        WsbAssertHr(((IUnknown*)(IBagHole*) this)->QueryInterface(IID_IBagHole,
                    (void**) &pBagHole1));


        try {
            // Set the BagHole to a value, and see if it is returned.
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CBagHole, 0, 6 ));

            WsbAssertHr(pBagHole1->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));

            WsbAssert((l_BagId == CLSID_CBagHole) && (l_SegStartLoc == 0) &&
                      (l_SegLen == 6), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

#ifdef OLD_CODE
        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAssertHr(CoCreateInstance(CLSID_CBagHole, NULL, CLSCTX_ALL, IID_IBagHole, (void**) &pBagHole2));

            // Check the default values.
            WsbAssertHr(pBagHole2->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));
            WsbAssert(((l_BagId == GUID_NULL) && (l_SegStartLoc == 0) && (l_SegLen == 0)), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            // IsEqual()
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 1, 100));
            WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbBool, 1, 100));

            WsbAssertHr(pBagHole1->IsEqual(pBagHole2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 5, 6));
            WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbLong, 0, 6));

            WsbAssert((pBagHole1->IsEqual(pBagHole2) == S_FALSE), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             // CompareTo()
             WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 1, 100));
             WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbBool, 10, 6));

             WsbAssert((pBagHole1->CompareTo(pBagHole2, &result) == S_FALSE) && (result != 0), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 0, 6));
            WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbLong, 0, 6));

            WsbAssert(((pBagHole1->CompareTo(pBagHole2, &result) == S_FALSE) && (result > 0)), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 0, 6));
             WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbBool, 0, 6));

             WsbAssert((pBagHole1->CompareTo(pBagHole2, &result) == S_OK), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
        // Try out the persistence stuff.
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;

            WsbAssertHr(pBagHole1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAssertHr(pBagHole2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

            LPOLESTR    szTmp = NULL;
            // The item should be dirty.
            try {
                WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbLong, 0, 6));
                WsbAssertHr(pFile2->IsDirty());
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Save the item, and remember.
                WsbAssertHr(pFile2->Save(OLESTR("c:\\WsbTests\\BagHole.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // It shouldn't be dirty.
                WsbAssert((pFile2->IsDirty() == S_FALSE), E_FAIL);

            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Try reading it in to another object.
                WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbLong, 0, 6));
                WsbAssertHr(pFile1->Load(OLESTR("c:\\WsbTests\\BagHole.tst"), 0));

                WsbAssertHr(pBagHole1->CompareToIBagHole(pBagHole2, &result));
            }WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

        } WsbCatch(hr);
#endif
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
#else
    UNREFERENCED_PARAMETER(pTestsPassed);
    UNREFERENCED_PARAMETER(pTestsFailed);
#endif
    return(S_OK);
}



HRESULT 
CBagHole::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
        WsbAffirmHr(pKey->AppendLonglong(m_SegStartLoc));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\hsmeng\rswriter.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    rswriter.h

Abstract:

    This module defines the CRssJetWriter class.

Author:

    Ran Kalach (rankala)  4/4/00

--*/


#ifndef _RSWRITER_
#define _RSWRITER_


#include <jetwriter.h>
#include <rsevents.h>

/*++

Class Name:
    
    CRssJetWriter

Class Description:

    This class is HSM implementation to the Jet-Writer base class, which synchronize
    a jet user application with snapshots mechanizm

--*/

#define     WRITER_EVENTS_NUM       (SYNC_STATE_EVENTS_NUM+1)
#define     INTERNAL_EVENT_INDEX    0
#define     INTERNAL_WAIT_TIMEOUT   (10*1000)   // 10 seconds

class CRssJetWriter : public CVssJetWriter
{

// Constructors
public:
    CRssJetWriter();

// Destructor
public:
    virtual ~CRssJetWriter();

// Public methods
public:
    HRESULT Init();
    HRESULT Terminate();

// CVssJetWriter overloading
	virtual bool STDMETHODCALLTYPE OnFreezeBegin();
	virtual bool STDMETHODCALLTYPE OnThawEnd(IN bool fJetThawSucceeded);
	virtual void STDMETHODCALLTYPE OnAbortEnd();

// Private methods
protected:
    HRESULT InternalEnd(void);

// Member Data
protected:
    HRESULT                 m_hrInit;
    HANDLE                  m_syncHandles[WRITER_EVENTS_NUM];
    BOOL                    m_bTerminating;
};


#endif // _RSWRITER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\baginfo.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BagHole.cpp

Abstract:

    This component is an object representation of the HSM Metadata bag hole record.

Author:

    Cat Brant   [cbrant]   26-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "BagInfo.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

static USHORT iCount = 0;

HRESULT 
CBagInfo::GetBagInfo(
    HSM_BAG_STATUS *pStatus,
    GUID* pBagId, 
    FILETIME *pBirthDate, 
    LONGLONG *pLen, 
    USHORT *pType, 
    GUID *pVolId,
    LONGLONG *pDeletedBagAmount,
    SHORT *pRemoteDataSet
    ) 
/*++

Routine Description:

  See IBagInfo::GetBagInfo

Arguments:

  See IBagInfo::GetBagInfo

Return Value:
  
    See IBagInfo::GetBagInfo

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::GetBagInfo"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pStatus, E_POINTER);
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pBirthDate, E_POINTER);
        WsbAssert(0 != pLen, E_POINTER);
        WsbAssert(0 != pType, E_POINTER);
        WsbAssert(0 != pVolId, E_POINTER);
        WsbAssert(0 != pDeletedBagAmount, E_POINTER);
        WsbAssert(0 != pRemoteDataSet, E_POINTER);

        //Provide the data members
        *pStatus = m_BagStatus;
        *pBagId = m_BagId;
        *pBirthDate = m_BirthDate;
        *pLen = m_Len;
        *pType = m_Type;
        *pVolId = m_VolId;
        *pDeletedBagAmount = m_DeletedBagAmount;
        *pRemoteDataSet = m_RemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::GetBagInfo"), 
        OLESTR("hr = <%ls>, status = <%ls>, ID = <%ls>, Birthdate = <%ls>, length = <%ls>, type = <%ls>, volId = <%ls>, deletedAmount = <%ls>, remoteDataSet = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToUshortAsString((USHORT *)pStatus), WsbPtrToGuidAsString(pBagId), WsbPtrToFiletimeAsString(FALSE, pBirthDate),
        WsbPtrToLonglongAsString(pLen), WsbPtrToUshortAsString(pType), WsbPtrToGuidAsString(pVolId), WsbPtrToLonglongAsString(pDeletedBagAmount),
        WsbPtrToShortAsString(pRemoteDataSet));
    
    return(hr);

}


HRESULT 
CBagInfo::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagStatus = HSM_BAG_STATUS_NONE;
        m_BagId = GUID_NULL;
        m_BirthDate = WsbLLtoFT(0);
        m_Len = 0;
        m_Type = 0;
        m_VolId = GUID_NULL;
        m_DeletedBagAmount = 0;
        m_RemoteDataSet = 0;

    } WsbCatch(hr);
    iCount++;
    WsbTraceOut(OLESTR("CBagInfo::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"), 
                WsbHrAsString(hr), iCount);

    return(hr);
}

void
CBagInfo::FinalRelease(
    void
    )

/*++

Implements:

  CBagInfo::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CBagInfo::FinalRelease"), OLESTR(""));
    
    CWsbDbEntity::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CBagInfo::FinalRelease"), OLESTR("Count is <%d>"), iCount);
}

HRESULT CBagInfo::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CBagInfo;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CBagInfo::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(CBagInfo); //???????
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CBagInfo::Load
(
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::Load"), OLESTR(""));

    try {
        USHORT  tmpUShort;
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpUShort));
        m_BagStatus = (HSM_BAG_STATUS)tmpUShort;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BirthDate));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Len));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Type));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_VolId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_DeletedBagAmount));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_RemoteDataSet));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CBagInfo::Load"), 
        OLESTR("hr = <%ls>, status = <%d>, ID = <%ls>, Birthdate = <%ls>, length = <%ls>, type = <%ls>, volId = <%d>, deletedAmount = <%ls>, remoteDataSet = <%d>"), 
        WsbHrAsString(hr), (USHORT)m_BagStatus, WsbGuidAsString(m_BagId), WsbFiletimeAsString(FALSE, m_BirthDate),
        WsbLonglongAsString(m_Len), m_Type, WsbGuidAsString(m_VolId), 
        WsbLonglongAsString(m_DeletedBagAmount), m_RemoteDataSet);
    
    return(hr);
}

HRESULT CBagInfo::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::Save"), 
        OLESTR("clearDirty = <%ls>, status = <%d>, ID = <%ls>, Birthdate = <%ls>, length = <%ls>, type = <%d>, volId = <%ls>, deletedAmount = <%ls>, RemoteDataSet = <%d>"), 
        WsbBoolAsString(clearDirty),
        (USHORT)m_BagStatus, WsbGuidAsString(m_BagId), WsbFiletimeAsString(FALSE, m_BirthDate),
        WsbLonglongAsString(m_Len), m_Type, WsbGuidAsString(m_VolId), 
        WsbLonglongAsString(m_DeletedBagAmount), m_RemoteDataSet);

    try {
        USHORT  tmpUShort;
        WsbAssert(0 != pStream, E_POINTER);

        tmpUShort = (USHORT)m_BagStatus;
        WsbAffirmHr(WsbSaveToStream(pStream, tmpUShort));
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_BirthDate));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Len));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Type));
        WsbAffirmHr(WsbSaveToStream(pStream, m_VolId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_DeletedBagAmount));
        WsbAffirmHr(WsbSaveToStream(pStream, m_RemoteDataSet));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CBagInfo::SetBagInfo(
    HSM_BAG_STATUS bagStatus,
    GUID bagId, 
    FILETIME birthDate, 
    LONGLONG len, 
    USHORT type, 
    GUID volId ,
    LONGLONG deletedBagAmount,
    SHORT remoteDataSet
    )
 /*++

Routine Description:

  See IBagInfo::SetBagInfo().

Arguments:

  See IBagInfo::SetBagInfo().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CBagInfo::SetBagInfo"), 
                    OLESTR("status = <%d>, bagId = <%ls>, birthdate = <%ls>, length = <%ls>, type = %d, volId = <%ls>, deletedAmount = <%ls>, remoteDataSet = <%d>"), 
                    bagStatus,
                    WsbGuidAsString(bagId),
                    WsbFiletimeAsString(FALSE, birthDate),
                    WsbLonglongAsString(len),
                    type,
                    WsbGuidAsString(volId),
                    WsbLonglongAsString(deletedBagAmount),
                    remoteDataSet);

    m_isDirty = TRUE;

    m_BagStatus = bagStatus;    
    m_BagId = bagId;
    m_BirthDate = birthDate;
    m_Len = len;
    m_Type = type;
    m_VolId = volId;
    m_DeletedBagAmount = deletedBagAmount;
    m_RemoteDataSet = remoteDataSet;

    WsbTraceOut(OLESTR("CBagInfo::SetBagInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CBagInfo::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>       pBagInfo1;
    CComPtr<IBagInfo>       pBagInfo2;

    WsbTraceIn(OLESTR("CBagInfo::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    
    hr  = E_NOTIMPL;
    
    WsbTraceOut(OLESTR("CBagInfo::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(S_OK);
}


HRESULT CBagInfo::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Status = %d"), 
                (USHORT)m_BagStatus));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", BagId = %ls"), 
                WsbGuidAsString(m_BagId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", BirthDate = %ls"), 
                WsbFiletimeAsString(FALSE, m_BirthDate)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Len = %ls"), 
                WsbLonglongAsString(m_Len)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Type = %d"), 
                m_Type));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", VolId = %ls"), 
                WsbGuidAsString(m_VolId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", DeletedAmount = %ls"), 
                WsbLonglongAsString(m_DeletedBagAmount)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", RemoteDataSet = %d"), 
                m_RemoteDataSet));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CBagInfo::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\baginfo.h ===
// baginfo.h : Declaration of the CBagHole


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// Task

class CBagInfo : 
    public CWsbDbEntity,
    public IBagInfo,
    public CComCoClass<CBagInfo,&CLSID_CBagInfo>
{
public:
    CBagInfo() {}
BEGIN_COM_MAP(CBagInfo)
    COM_INTERFACE_ENTRY(IBagInfo)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//  COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CBagHole, _T("Task.BagInfo.1"), _T("Task.BagInfo"), IDS_BAGINFO_DESC, THREADFLAGS_BOTH)

// IBagHole
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);
    void FinalRelease(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
//*/
// IBagHole
public:
    STDMETHOD(GetBagInfo)(HSM_BAG_STATUS *pStatus, GUID* pBagId, FILETIME *pBirthDate, LONGLONG *pLen, USHORT *pType, GUID *pVolId, LONGLONG *pDeletedBagAmount, SHORT *pRemoteDataSet);
    STDMETHOD(SetBagInfo)(HSM_BAG_STATUS status, GUID bagId, FILETIME birthDate, LONGLONG len, USHORT type, GUID volId, LONGLONG deletedBagAmount, SHORT remoteDataSet );

private:
    HSM_BAG_STATUS      m_BagStatus;
    GUID                m_BagId;
    FILETIME            m_BirthDate;
    LONGLONG            m_Len;
    USHORT              m_Type;
    GUID                m_VolId;
    LONGLONG            m_DeletedBagAmount; 
    SHORT               m_RemoteDataSet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\inc\engcommn.h ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    EngCommn.h

Abstract:

    This header file defines some constants for the HSM Engine.

Author:

    Rohde Wakefield       [rohde]    31-Aug-1998

Revision History:

--*/

#ifndef _ENGCOMMN_H
#define _ENGCOMMN_H

//
// Registry strings
//
#define HSM_DEFAULT_RESOURCE_MANAGEMENT_LEVEL       OLESTR("Resource_Management_Level")
#define HSM_DEFAULT_INACT_DAYS                      OLESTR("Default_Inactivity_Days")
#define HSM_DEFAULT_RESULTS_DAYS                    OLESTR("Default_Results_Days")
#define HSM_DEFAULT_RESULTS_LEVEL                   OLESTR("Default_Results_Level")
#define HSM_MRU_ENABLED                             OLESTR("MRU_Enabled")
#define HSM_FULL_ACTION                             OLESTR("Full_Action")
#define HSM_STATUS                                  OLESTR("Status")
#define HSM_TRACE_SETTINGS                          OLESTR("SystemTraceSettings")
#define HSM_TRACE_ON                                OLESTR("SystemTraceOn")
#define HSM_FILES_BEFORE_COMMIT                     OLESTR("NumberOfFilesBeforeCommit")
#define HSM_MAX_BYTES_BEFORE_COMMIT                 OLESTR("MaximumNumberOfBytesBeforeCommit")
#define HSM_MIN_BYTES_BEFORE_COMMIT                 OLESTR("MinimumNumberOfBytesBeforeCommit")
#define HSM_MAX_BYTES_AT_END_OF_MEDIA               OLESTR("MaximumNumberOfBytesAtEndOfMedia")
#define HSM_MIN_BYTES_AT_END_OF_MEDIA               OLESTR("MinimumNumberOfBytesAtEndOfMedia")
#define HSM_MAX_PERCENT_AT_END_OF_MEDIA             OLESTR("MaximumPercentageAtEndOfMedia")
#define HSM_DONT_SAVE_DATABASES                     OLESTR("DoNotSaveCriticalDataToMedia")
#define HSM_QUEUE_ITEMS_TO_PAUSE                    OLESTR("QueueItemsToPause")
#define HSM_QUEUE_ITEMS_TO_RESUME                   OLESTR("QueueItemsToResume")
#define HSM_MEDIA_BASE_NAME                         OLESTR("MediaBaseName")
#define HSM_JOB_ABORT_CONSECUTIVE_ERRORS            OLESTR("JobAbortConsecutiveErrors")
#define HSM_JOB_ABORT_TOTAL_ERRORS                  OLESTR("JobAbortTotalErrors")
#define HSM_JOB_ABORT_SYS_DISK_SPACE                OLESTR("JobAbortSysDiskSpace")
#define HSM_MIN_BYTES_TO_MIGRATE                    OLESTR("MinimumNumberOfBytesToMigrate")
#define HSM_MIN_FILES_TO_MIGRATE                    OLESTR("MinimumFreeSpaceInF")
#define HSM_MIN_FREE_SPACE_IN_FULL_MEDIA            OLESTR("MinimumFreeSpaceInFullMedia")
#define HSM_MAX_FREE_SPACE_IN_FULL_MEDIA            OLESTR("MaximumFreeSpaceInFullMedia")

#define HSM_MEDIA_TYPE                              OLESTR("MediaType")
#define HSM_VALUE_TYPE_SEQUENTIAL                   0
#define HSM_VALUE_TYPE_DIRECTACCESS                 1

#define HSM_ENG_DIR_LEN                             256

#define HSM_ENGINE_REGISTRY_NAME                    OLESTR("Remote_Storage_Server")

#endif // _ENGCOMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmrecli.cpp ===
/*++


Module Name:

    hsmrecli.cpp

Abstract:

    This class represents an HSM recall queue work item - a unit of work
    that is performed by the HSM engine for recalls

Author:

    Ravisankar Pudipeddi [ravisp]

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
#include "wsb.h"
#include "fsa.h"
#include "task.h"
#include "hsmrecli.h"

static USHORT iCount = 0;

HRESULT
CHsmRecallItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmRecallItem>   pWorkItem;

    WsbTraceIn(OLESTR("CHsmRecallItem::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IHsmRecallItem interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmRecallItem, (void**) &pWorkItem));

        // Compare the items
        hr = CompareToIHsmRecallItem(pWorkItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRecallItem::CompareToIHsmRecallItem(
    IN IHsmRecallItem* pWorkItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmRecallItem::CompareToIHsmRecallItem().

--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_Id;           // Type of work to do

    WsbTraceIn(OLESTR("CHsmRecallItem::CompareToIHsmRecallItem"), OLESTR(""));

    try {
        //
        // Did they give us a valid item to compare to?
        //
        WsbAssert(0 != pWorkItem, E_POINTER);

        //
        // Get the ID
        //
        WsbAffirmHr(pWorkItem->GetId(&l_Id));

        if (l_Id != m_MyId){
            hr = S_FALSE;
        }
        // If they asked for the relative value back, then return it to them.
        if (pResult != NULL) {
            if (S_OK == hr)  {
                *pResult = 0;
            } else {
                *pResult = 1;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::CompareToIHsmRecallItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRecallItem::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::FinalConstruct"), OLESTR(""));
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        //
        // The comparison for database searches is based on the
        // ID of this object (m_MyId).
        //
        WsbAffirmHr(CoCreateGuid(&m_MyId));
        m_WorkType = HSM_WORK_ITEM_NONE;
        m_MediaId = GUID_NULL;
        m_MediaLastUpdate =  WsbLLtoFT(0);
        m_MediaLastError = S_OK;
        m_MediaRecallOnly = FALSE;
        m_MediaFreeBytes = 0;
        m_JobState    = HSM_JOB_STATE_IDLE;
        m_JobPhase    = HSM_JOB_PHASE_MOVE_ACTION;
        m_StateCookie = 0;
        m_EventCookie = 0;

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmRecallItem::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmRecallItem::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CHsmRecallItem::FinalRelease"), OLESTR(""));
    // Let the parent class do his thing.
    CWsbObject::FinalRelease();

    iCount--;
    WsbTraceOut(OLESTR("CHsmRecallItem::FinalRelease"), OLESTR("Count is <%d>"), iCount);

}


HRESULT
CHsmRecallItem::GetFsaPostIt (
    OUT IFsaPostIt  **ppFsaPostIt
    )

/*++

Implements:

  IHsmRecallItem::GetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaPostIt, E_POINTER);
        *ppFsaPostIt = m_pFsaPostIt;
        if (0 != *ppFsaPostIt)  {
            (*ppFsaPostIt)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::GetFsaResource (
    OUT IFsaResource  **ppFsaResource
    )

/*++

Implements:

  IHsmRecallItem::GetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaResource, E_POINTER);
        *ppFsaResource = m_pFsaResource;
        if (0 != *ppFsaResource)  {
            (*ppFsaResource)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::GetId(
    OUT GUID *pId
    )

/*++

Implements:

  IHsmRecallItem::GetId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetId"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pId, E_POINTER);
        *pId = m_MyId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetId"), OLESTR("hr = <%ls>, Id = <%ls>"),
            WsbHrAsString(hr), WsbPtrToGuidAsString(pId));

    return(hr);
}

HRESULT
CHsmRecallItem::GetMediaInfo (
    OUT GUID *pMediaId,
    OUT FILETIME *pMediaLastUpdate,
    OUT HRESULT *pMediaLastError,
    OUT BOOL *pMediaRecallOnly,
    OUT LONGLONG *pMediaFreeBytes,
    OUT short *pMediaRemoteDataSet
    )

/*++

Implements:

  IHsmRecallItem::GetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetMediaInfo"), OLESTR(""));

    try {

        // Did they give us  valid pointers?
        WsbAssert(0 != pMediaId, E_POINTER);
        WsbAssert(0 != pMediaLastUpdate, E_POINTER);
        WsbAssert(0 != pMediaLastError, E_POINTER);
        WsbAssert(0 != pMediaRecallOnly, E_POINTER);
        WsbAssert(0 != pMediaFreeBytes, E_POINTER);
        WsbAssert(0 != pMediaRemoteDataSet, E_POINTER);

        *pMediaId = m_MediaId;
        *pMediaLastUpdate = m_MediaLastUpdate;
        *pMediaLastError = m_MediaLastError;
        *pMediaRecallOnly = m_MediaRecallOnly;
        *pMediaFreeBytes = m_MediaFreeBytes;
        *pMediaRemoteDataSet = m_MediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetMediaInfo"),
        OLESTR("hr = <%ls>, Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%ls>"),
        WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaId), WsbPtrToFiletimeAsString(FALSE, pMediaLastUpdate),
        WsbPtrToHrAsString(pMediaLastError), WsbPtrToBoolAsString(pMediaRecallOnly),
        WsbPtrToLonglongAsString(pMediaFreeBytes), WsbPtrToShortAsString(pMediaRemoteDataSet));

    return(hr);
}


HRESULT
CHsmRecallItem::GetResult(
    OUT HRESULT *pHr
    )

/*++

Implements:

  IHsmRecallItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetResult"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pHr, E_POINTER);
        *pHr = m_WorkResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetResult"), OLESTR("hr = <%ls>, Result = <%ls>"),
            WsbHrAsString(hr), WsbPtrToHrAsString(pHr));

    return(hr);
}

HRESULT
CHsmRecallItem::GetWorkType(
    OUT HSM_WORK_ITEM_TYPE *pWorkType
    )

/*++

Implements:

  IHsmRecallItem::GetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetWorkType"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pWorkType, E_POINTER);
        *pWorkType = m_WorkType;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetEventCookie(
    OUT DWORD *pEventCookie
    )

/*++

Implements:

  IHsmRecallItem::GetEventCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetEventCookie"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pEventCookie, E_POINTER);
        *pEventCookie = m_EventCookie;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CHsmRecallItem::GetEventCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetStateCookie(
    OUT DWORD *pStateCookie
    )

/*++

Implements:

  IHsmRecallItem::GetStateCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetStateCookie"), OLESTR(""));
    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pStateCookie, E_POINTER);
        *pStateCookie = m_StateCookie;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetStateCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetJobState(
    OUT HSM_JOB_STATE *pJobState
    )

/*++

Implements:

  IHsmRecallItem::GetJobState()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetJobState"), OLESTR(""));


    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pJobState, E_POINTER);
        *pJobState = m_JobState;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetJobState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetJobPhase(
    OUT HSM_JOB_PHASE *pJobPhase
    )

/*++

Implements:

  IHsmRecallItem::GetJobPhase

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetJobPhase"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pJobPhase, E_POINTER);
        *pJobPhase = m_JobPhase;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetJobPhase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetSeekOffset(
    OUT LONGLONG *pSeekOffset
    )

/*++

Implements:

  IHsmRecallItem::GetSeekOffset

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetSeekOffset"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pSeekOffset, E_POINTER);
        *pSeekOffset = m_SeekOffset;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetSeekOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetBagId(
    OUT GUID *pBagId
    )

/*++

Implements:

  IHsmRecallItem::GetBagId

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetBagId"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pBagId, E_POINTER);
        *pBagId = m_BagId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetBagId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetDataSetStart(
    OUT LONGLONG *pDataSetStart
    )

/*++

Implements:

  IHsmRecallItem::GetDataSetStart

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetDataSetStart"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pDataSetStart,E_POINTER);
        *pDataSetStart =  m_DataSetStart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetDataSetStart"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetFsaPostIt (
    IN IFsaPostIt  *pFsaPostIt
    )

/*++

Implements:

  IHsmRecallItem::SetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaPostIt, E_POINTER);
        m_pFsaPostIt = pFsaPostIt;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::SetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::SetFsaResource (
    IN IFsaResource  *pFsaResource
    )

/*++

Implements:

  IHsmRecallItem::SetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaResource, E_POINTER);
        m_pFsaResource = pFsaResource;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::SetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetMediaInfo (
    IN GUID mediaId,
    IN FILETIME mediaLastUpdate,
    IN HRESULT mediaLastError,
    IN BOOL mediaRecallOnly,
    IN LONGLONG mediaFreeBytes,
    IN short mediaRemoteDataSet
    )

/*++

Implements:

  IHsmRecallItem::SetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetMediaInfo"),
        OLESTR("Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%d>"),
        WsbGuidAsString(mediaId), WsbFiletimeAsString(FALSE, mediaLastUpdate),
        WsbHrAsString(mediaLastError), WsbBoolAsString(mediaRecallOnly),
        WsbLonglongAsString(mediaFreeBytes), mediaRemoteDataSet);

    try {
        m_MediaId          = mediaId;
        m_MediaLastUpdate  = mediaLastUpdate;
        m_MediaLastError   = mediaLastError;
        m_MediaRecallOnly  = mediaRecallOnly;
        m_MediaFreeBytes   = mediaFreeBytes;
        m_MediaRemoteDataSet = mediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetMediaInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::SetResult(
    IN HRESULT workResult
    )

/*++

Implements:

  IHsmRecallItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetResult"), OLESTR("Result is <%ls>"), WsbHrAsString(workResult));

    try {

        m_WorkResult = workResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetResult"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetWorkType(
    IN HSM_WORK_ITEM_TYPE workType
    )

/*++

Implements:

  IHsmRecallItem::SetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetWorkType"), OLESTR(""));

    m_WorkType = workType;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetEventCookie(
    IN DWORD eventCookie
    )

/*++

Implements:

  IHsmRecallItem::SetEventCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetEventCookie"), OLESTR(""));

    m_EventCookie = eventCookie;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetEventCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetStateCookie(
    IN DWORD stateCookie
    )

/*++

Implements:

  IHsmRecallItem::SetStateCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetStateCookie"), OLESTR(""));

    m_StateCookie = stateCookie;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetStateCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetJobState(
    IN HSM_JOB_STATE jobState
    )

/*++

Implements:

  IHsmRecallItem::SetJobState()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetJobState"), OLESTR(""));

    m_JobState = jobState;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetJobState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetJobPhase(
    IN HSM_JOB_PHASE jobPhase
    )

/*++

Implements:

  IHsmRecallItem::SetJobPhase

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetJobPhase"), OLESTR(""));

    m_JobPhase = jobPhase;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetJobPhase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetSeekOffset(
    IN LONGLONG seekOffset
    )

/*++

Implements:

  IHsmRecallItem::SetSeekOffset

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetSeekOffset"), OLESTR(""));

    m_SeekOffset = seekOffset;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetSeekOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetBagId(
    IN GUID * pBagId
    )

/*++

Implements:

  IHsmRecallItem::SetBagId

--*/
{
    HRESULT         hr = S_OK;


    WsbTraceIn(OLESTR("CHsmRecallItem::SetBagId"), OLESTR(""));

    m_BagId = *pBagId;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetBagId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetDataSetStart(
    IN LONGLONG dataSetStart
    )

/*++

Implements:

  IHsmRecallItem::SetDataSetStart

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetDataSetStart"), OLESTR(""));

    m_DataSetStart = dataSetStart;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetDataSetStart"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT CHsmRecallItem::GetClassID(
    OUT LPCLSID pclsid
    )
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CHsmRecallItem;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CHsmRecallItem::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = 0;
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetSizeMax"),
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr),
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CHsmRecallItem::Load
(
    IN IStream* /*pStream*/
    )
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::Load"), OLESTR(""));

    try {
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CHsmRecallItem::Save
(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::Test
(
    OUT USHORT *pTestsPassed,
    OUT USHORT *pTestsFailed
    )
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {

        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmreclq.cpp ===
/*++


Module Name:

     hsmreclq.cpp

Abstract:

     This class represents the HSM Demand Recall Queue manager
     It handles recalls initiated by users accessing HSM managed
     files. Based on the regular HSM queue manager (CHsmWorkQueue)

Author:

     Ravisankar Pudipeddi [ravisp] 1 Oct. 1999


Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
static USHORT iCount = 0;

#include "fsa.h"
#include "rms.h"
#include "metadef.h"
#include "jobint.h"
#include "hsmconn.h"
#include "wsb.h"
#include "hsmeng.h"
#include "mover.h"
#include "hsmreclq.h"

#include "engine.h"
#include "task.h"
#include "tskmgr.h"
#include "segdb.h"

#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );

// Local prototypes
DWORD HsmRecallQueueThread(void *pVoid);
static const OLECHAR * JobStateAsString (HSM_JOB_STATE state);

static const OLECHAR *
JobStateAsString (
                 IN  HSM_JOB_STATE  state
                 )
/*++

Routine Description:

     Gives back a static string representing the connection state.

Arguments:

     state - the state to return a string for.

Return Value:

     NULL - invalid state passed in.

     Otherwise, a valid char *.

--*/
{
    //
    // Do the Switch
    //

    switch (state) {

    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_ACTIVE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_DONE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_FAILED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_IDLE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_RESUMING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SKIPPED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_STARTING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDING );

    default:

        return( OLESTR("Invalid Value") );

    }
}



HRESULT
CHsmRecallQueue::FinalConstruct(
                               void
                               )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CComObjectRoot::FinalConstruct());

        //
        // Initialize the member data
        //
        m_pServer           = 0;
        m_pHsmServerCreate  = 0;
        m_pTskMgr             = 0;

        m_pRmsServer        = 0;
        m_pRmsCartridge     = 0;
        m_pDataMover        = 0;

        m_pWorkToDo         = 0;

        UnsetMediaInfo();

        m_HsmId          = GUID_NULL;
        m_RmsMediaSetId  = GUID_NULL;
        m_RmsMediaSetName = OLESTR("");
        m_QueueType      = HSM_WORK_TYPE_FSA_DEMAND_RECALL;


        m_JobPriority = HSM_JOB_PRIORITY_NORMAL;

        m_WorkerThread = 0;
        m_CurrentPath    = OLESTR("");

        // Job abort on errors parameters
        m_JobAbortMaxConsecutiveErrors = 5;
        m_JobAbortMaxTotalErrors = 25;
        m_JobConsecutiveErrors = 0;
        m_JobTotalErrors = 0;
        m_JobAbortSysDiskSpace = 2 * 1024 * 1024;

        m_CurrentSeekOffset = 0;

        WSB_OBJECT_ADD(CLSID_CHsmRecallQueue, this);

    }WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmRecallQueue::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), iCount);
    return(hr);
}


HRESULT
CHsmRecallQueue::FinalRelease(
                             void
                             )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  before destruction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalDestruct().

--*/
{
    HRESULT     hr = S_OK;
    HSM_SYSTEM_STATE SysState;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FinalRelease"),OLESTR(""));

    SysState.State = HSM_STATE_SHUTDOWN;
    ChangeSysState(&SysState);

    WSB_OBJECT_SUB(CLSID_CHsmRecallQueue, this);
    CComObjectRoot::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the
    // smart-pointer destructor is being called (as part of this object destruction)
    m_MediaName.Free();
    m_MediaBarCode.Free();
    m_RmsMediaSetName.Free();
    m_CurrentPath.Free();

    iCount--;
    WsbTraceOut(OLESTR("CHsmRecallQueue::FinalRelease"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), iCount);
    return(hr);
}


HRESULT
CHsmRecallQueue::Init(
                     IUnknown                *pServer,
                     IHsmFsaTskMgr           *pTskMgr
                     )
/*++
Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:


Return Value:


--*/
{
    HRESULT     hr = S_OK;
    LONG                    rmsCartridgeType;
    CComPtr<IRmsCartridge>  pMedia;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Init"),OLESTR(""));
    try {
        //
        // Establish contact with the server and get the
        // databases
        //
        WsbAffirmHr(pServer->QueryInterface(IID_IHsmServer, (void **)&m_pServer));
        //We want a weak link to the server so decrement the reference count
        m_pServer->Release();

        m_pTskMgr = pTskMgr;
        m_pTskMgr->AddRef();
        m_QueueType = HSM_WORK_TYPE_FSA_DEMAND_RECALL;

        WsbAffirmHr(m_pServer->QueryInterface(IID_IWsbCreateLocalObject, (void **)&m_pHsmServerCreate));
        // We want a weak link to the server so decrement the reference count
        m_pHsmServerCreate->Release();
        WsbAffirmHr(m_pServer->GetID(&m_HsmId));
        //
        // Make sure our connection to RMS is current
        //
        WsbAffirmHr(CheckRms());

        //
        // Get the media type. We assume mediaId is set before this
        // is called. Imperative!
        //
        WsbAffirmHr(m_pRmsServer->FindCartridgeById(m_MediaId, &pMedia));
        WsbAffirmHr(pMedia->GetType( &rmsCartridgeType ));
        WsbAffirmHr(ConvertRmsCartridgeType(rmsCartridgeType, &m_MediaType));

        //
        // Make a collection for the work items
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                       IID_IWsbIndexedCollection,
                                                       (void **)&m_pWorkToDo ));


        // Check the registry to see if there are changes to default settings
        CheckRegistry();
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmRecallQueue::ContactOk(
                          void
                          )
/*++
Routine Description:

  This allows the caller to see if the RPC connection
  to the task manager is OK

Arguments:

  None.

Return Value:

  S_OK
--*/ {

    return( S_OK );

}

HRESULT
CHsmRecallQueue::ProcessSessionEvent( IHsmSession *pSession,
                                      HSM_JOB_PHASE phase,
                                      HSM_JOB_EVENT event
                                    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CHsmRecallQueue::ProcessSessionEvent"),OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to us (MOVER or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_MOVE_ACTION == phase)) {

            switch (event) {
            
            case HSM_JOB_EVENT_SUSPEND:
            case HSM_JOB_EVENT_CANCEL:
            case HSM_JOB_EVENT_FAIL:
                WsbAffirmHr(Cancel(phase, pSession));
                break;

            case HSM_JOB_EVENT_RAISE_PRIORITY:
                WsbAffirmHr(RaisePriority(phase, pSession));
                break;

            case HSM_JOB_EVENT_LOWER_PRIORITY:
                WsbAffirmHr(LowerPriority(phase, pSession));
                break;

            default:
            case HSM_JOB_EVENT_START:
                WsbAssert(FALSE, E_UNEXPECTED);
                break;
            }
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::ProcessSessionEvent"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );
}


HRESULT
CHsmRecallQueue::ProcessSessionState(
                                    IHsmSession* /*pSession*/,
                                    IHsmPhase*   pPhase,
                                    OLECHAR*         /*currentPath*/
                                    )
/*++

Routine Description:

Arguments:

Return Value:


--*/ {
    HRESULT         hr = S_OK;
    HSM_JOB_PHASE   phase;
    HSM_JOB_STATE   state;

    WsbTraceIn(OLESTR("CHsmRecallQueue::ProcessSessionState"),OLESTR(""));
    try {

        WsbAffirmHr(pPhase->GetState(&state));
        WsbAffirmHr(pPhase->GetPhase(&phase));
        WsbTrace( OLESTR("CHsmRecallQueue::ProcessSessionState - State = <%d>, phase = <%d>\n"), state, phase );

        if (HSM_JOB_PHASE_SCAN == phase) {

            // If the session has finished, then we have some cleanup to do so that it can go
            // away.
            if ((state == HSM_JOB_STATE_DONE) || (state == HSM_JOB_STATE_FAILED) || (state == HSM_JOB_STATE_SUSPENDED)) {
                WsbTrace( OLESTR("Job is done, failed, or suspended\n") );
                //
                // Do nothing: when one recall item is done, we don't need to wait
                // for the FSA in order to perform cleanup code
                //
/***				WsbAffirmHr(MarkWorkItemAsDone(pSession, phase));   ***/
            }
        }

    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::ProcessSessionState"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );

}


HRESULT
CHsmRecallQueue::Add(
                    IFsaPostIt *pFsaWorkItem,
                    GUID       *pBagId,
                    LONGLONG   dataSetStart
                    )
/*++

Implements:

  IHsmFsaTskMgr::Add

--*/ {
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pSession;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmRecallItem>     pWorkItem, pWorkItem2;
    LONGLONG                    seekOffset, currentSeekOffset, prevSeekOffset;
    LARGE_INTEGER               remoteFileStart, remoteDataStart;
    LONGLONG                    readOffset;
    FSA_PLACEHOLDER             placeholder;
    HSM_WORK_ITEM_TYPE          workType;
    BOOL                        workItemAllocated=FALSE, insert;
    CComPtr<IFsaFilterRecall>   pRecall;
    DWORD                       index = 0;
    BOOL                        qLocked = FALSE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Add"),OLESTR(""));
    try {
        //
        // Make sure there is a work allocater for this session
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        //
        // Create a work item, load it up and add it to this
        // Queue's collection
        //
        CComPtr<IHsmRecallItem>   pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallItem, IID_IHsmRecallItem,
                                                       (void **)&pWorkItem));
        workItemAllocated = TRUE;
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_WORK));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(CheckSession(pSession, pWorkItem));

        WsbAffirmHr(pWorkItem->SetBagId(pBagId));
        WsbAffirmHr(pWorkItem->SetDataSetStart(dataSetStart));

        if (m_MediaType == HSM_JOB_MEDIA_TYPE_TAPE) {
            //
            // For sequential media we order the requests to achieve
            // optimal perf.
            //
            WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
            remoteFileStart.QuadPart = placeholder.fileStart;
            remoteDataStart.QuadPart = placeholder.dataStart;
            WsbAffirmHr(pFsaWorkItem->GetFilterRecall(&pRecall));
            WsbAffirmHr(pRecall->GetOffset( &readOffset ));

            //
            // Calculate the offset in the media that needs to be seeked to
            // for the recall. This will be only used for ordering the queue
            // performance reasons. 
            //
            seekOffset = dataSetStart + remoteFileStart.QuadPart + remoteDataStart.QuadPart +  readOffset;


            WsbAffirmHr(pWorkItem->SetSeekOffset(seekOffset));
            index = 0;
            //
            // Find a position in the queue to insert it
            // First, we lock the queue while we search for the position
            // & insert the item into the queue. We make the assumption
            // the lock protecting the queue is recursively acquirable.
            // If this is not true, the code that adds to the queue will
            // deadlock because it tries to lock the queue too!
            //
            m_pWorkToDo->Lock();
            qLocked = TRUE;

            WsbAffirmHr(m_pWorkToDo->Enum(&pEnum));
            //
            // If the seek offset of the item we wish to insert is
            // > the current seek offset of the item that is in progress,
            // we just insert it in the first monotonic ascending sequence.
            // If not, we insert in the *second* monotonic ascending sequence,
            // to prevent the head from seeking back prematurely
            //
            hr = pEnum->First(IID_IHsmRecallItem, (void **)&pWorkItem2);
            if (seekOffset > m_CurrentSeekOffset) {
                //
                // Insert in the first ascending sequence
                //
                insert = TRUE;
            } else {
                //
                // Skip the first ascending sequence
                //
                insert = FALSE;
            }

            prevSeekOffset = 0;
            while (hr != WSB_E_NOTFOUND) {
                WsbAffirmHr(pWorkItem2->GetWorkType(&workType));

                if (workType != HSM_WORK_ITEM_FSA_WORK) {
                    //
                    // Not interested in this. Release it before getting the next
                    //
                    pWorkItem2 = 0;
                    hr = pEnum->Next(IID_IHsmRecallItem, (void **)&pWorkItem2);
                    index++;
                    continue;
                }

                WsbAffirmHr(pWorkItem2->GetSeekOffset(&currentSeekOffset));

                if (insert && (currentSeekOffset > seekOffset)) {
                    //
                    // place to insert the item..
                    // 
                    break;
                }

                if (!insert && (currentSeekOffset < prevSeekOffset)) {
                    //
                    // Start of second monotone sequence. We wish to insert 
                    // the item in this sequence
                    //
                    insert = TRUE;
                    //
                    // Check if pWorkItem is eligible to be inserted at this
                    // index position
                    //
                    if (currentSeekOffset > seekOffset) {
                      //
                      // place to insert the item..
                      // 
                      break;
                    }
                }  else {
                    prevSeekOffset = currentSeekOffset;
                }
                //
                // Move on to the next. Release the current item first
                //
                pWorkItem2 = 0;
                hr = pEnum->Next(IID_IHsmRecallItem, (void **)&pWorkItem2);
                index++;

            } 
            if (hr == WSB_E_NOTFOUND) {
                WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));
            } else {
                WsbAffirmHr(m_pWorkToDo->AddAt(pWorkItem, index));
            }
            //
            // Safe to unlock the queue
            //
            m_pWorkToDo->Unlock();
            qLocked = FALSE;

        } else  {
            //
            // For non-sequential media, we just add it to the queue ...
            // No ordering is done, we let the file system do the optimizations
            //
            WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));
        } 
        hr = S_OK;
    }WsbCatchAndDo(hr,
                  //
                  // Add code to release queue lock if acquired
                  //
                  if (qLocked) {
                     m_pWorkToDo->Unlock();
                  }
                  );

    WsbTraceOut(OLESTR("CHsmRecallQueue::Add"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::Start( void )
/*++

Implements:

  IHsmRecallQueue::Start

--*/
{
    HRESULT                     hr = S_OK;
    DWORD                       tid;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Start"),OLESTR(""));
    try {
        //
        // If the worker thread is already started, just return
        //
        WsbAffirm(m_WorkerThread == 0, S_OK);
        // Launch a thread to do work that is queued
        WsbAffirm((m_WorkerThread = CreateThread(0, 0, HsmRecallQueueThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));

        if (m_WorkerThread == NULL) {
            WsbAssertHr(E_FAIL);     // TBD What error to return here??
        }

    }WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::Start"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::Stop( void )
/*++

Implements:

  IHsmRecallQueue::Stop

--*/ {
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Stop"),OLESTR(""));

    //  Stop the thread
    if (m_WorkerThread) {
        TerminateThread(m_WorkerThread, 0);
    }

    WsbTraceOut(OLESTR("CHsmRecallQueue::Stop"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmRecallQueue::RecallIt(
                         IHsmRecallItem * pWorkItem
                         )
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaScanItem>           pScanItem;
    CComPtr<IFsaPostIt>             pFsaWorkItem;
    LONGLONG                        readOffset;
    FSA_REQUEST_ACTION              requestAction;
    ULARGE_INTEGER                  remoteDataSetStart;
    GUID                            bagId;

    CComPtr<IWsbIndexedCollection>  pMountingCollection;
    CComPtr<IMountingMedia>         pMountingMedia;
    CComPtr<IMountingMedia>         pMediaToFind;
    BOOL                            bMediaMounting = FALSE;
    BOOL                            bMediaMountingAdded = FALSE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::RecallIt"),OLESTR(""));
    try {

        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));

        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&requestAction));
        GetScanItem(pFsaWorkItem, &pScanItem);

        WsbAffirmHr(pWorkItem->GetBagId(&bagId));
        WsbAffirmHr(pWorkItem->GetDataSetStart((LONGLONG *) &remoteDataSetStart.QuadPart));

        //
        // Check if we are mounting a new media: recall-queue is created on a per-media basis, therefore,
        //  media cannot change. The only test is whether the media for this queue is already mounted
        //
        if (m_MountedMedia == GUID_NULL) {

            // Check if the media is already in the process of mounting
            WsbAffirmHr(m_pServer->LockMountingMedias());

            try {
                // Check if the media to mount is already mounting
                WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                WsbAffirmHr(pMediaToFind->SetMediaId(m_MediaId));
                hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                if (hr == S_OK) {
                    // Media is already mounting...
                    bMediaMounting = TRUE;

                } else if (hr == WSB_E_NOTFOUND) {
                    // New media to mount - add to the mounting list
                    hr = S_OK;
                    WsbAffirmHr(pMediaToFind->Init(m_MediaId, TRUE));
                    WsbAffirmHr(pMountingCollection->Add(pMediaToFind));
                    bMediaMountingAdded = TRUE;

                } else {
                    WsbAffirmHr(hr);
                }
            } WsbCatchAndDo(hr,
                // Unlock mounting media
                m_pServer->UnlockMountingMedias();

                WsbTraceAlways(OLESTR("CHsmRecallQueue::RecallIt: error while trying to find/add mounting media. hr=<%ls>\n"),
                                WsbHrAsString(hr));                                

                // Bale out
                WsbThrow(hr);
            );

            // Release the lock
            WsbAffirmHr(m_pServer->UnlockMountingMedias());
        }

        //
        // If the media is already mounting - wait for the mount event
        //
        if (bMediaMounting) {
            WsbAffirmHr(pMountingMedia->WaitForMount(INFINITE));
            pMountingMedia = 0;
        }

        //
        // Get the media mounted (hr is checked only after removing from the mounting-media list)
        //
        hr = MountMedia(pWorkItem, m_MediaId);

        //
        // If added to the mounting list - remove
        //
        if (bMediaMountingAdded) {
            HRESULT hrRemove = S_OK;

            // No matter how the Mount finished - free waiting clients and remove from the list
            hrRemove = m_pServer->LockMountingMedias();
            WsbAffirmHr(hrRemove);

            try {
                WsbAffirmHr(pMediaToFind->MountDone());
                WsbAffirmHr(pMountingCollection->RemoveAndRelease(pMediaToFind));
                pMediaToFind = 0;

            } WsbCatch(hrRemove);

            m_pServer->UnlockMountingMedias();

            // We don't expect any errors while removing the mounting media -
            // The thread that added to the collection is always the one that removes
            if (! SUCCEEDED(hrRemove)) {
                WsbTraceAlways(OLESTR("CHsmRecallQueue::RecallIt: error while trying to remove a mounting media. hr=<%ls>\n"),
                                WsbHrAsString(hrRemove));                                

                WsbThrow(hrRemove);
            }
        }

        //
        // Check the Mount result
        //
        WsbAffirmHr(hr);

        //
        // Copy the data
        //
        // Build the source path
        CWsbStringPtr tmpString;
        WsbAffirmHr(GetSource(pFsaWorkItem, &tmpString));
        CWsbBstrPtr localName = tmpString;
        // Ask the Data mover to store the data
        LONGLONG       requestSize;
        LONGLONG       requestStart;
        ULARGE_INTEGER localDataStart;
        ULARGE_INTEGER localDataSize;
        ULARGE_INTEGER remoteFileStart;
        ULARGE_INTEGER remoteFileSize;
        ULARGE_INTEGER remoteDataStart;
        ULARGE_INTEGER remoteDataSize;
        ULARGE_INTEGER remoteVerificationData;
        ULONG          remoteVerificationType;

        FSA_PLACEHOLDER             placeholder;
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
        WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
        WsbAffirmHr(pFsaWorkItem->GetRequestOffset(&requestStart));

        //
        // Build strings
        //
        CWsbBstrPtr sessionName = HSM_BAG_NAME;
        CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;
        sessionName.Append(WsbGuidAsString(bagId));
        sessionDescription.Append(WsbGuidAsString(m_HsmId));

        localDataStart.QuadPart = requestStart;
        localDataSize.QuadPart = requestSize;
        remoteFileStart.QuadPart = placeholder.fileStart;
        remoteFileSize.QuadPart = placeholder.fileSize;
        remoteDataStart.QuadPart = placeholder.dataStart;
        remoteDataSize.QuadPart = placeholder.dataSize;
        remoteVerificationData.QuadPart = placeholder.verificationData;
        remoteVerificationType = placeholder.verificationType;


        ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRING, hr);

        CComPtr<IStream> pLocalStream;
        CComPtr<IStream> pRemoteStream;
        ULARGE_INTEGER offset, read, written;
        DWORD   verifyType;

        //
        // We are doing a demand recall, so get the
        // recall object's data mover
        //
        CComPtr<IFsaFilterRecall> pRecall;
        WsbAffirmHr(pFsaWorkItem->GetFilterRecall(&pRecall));
        WsbAffirmHr(pRecall->CreateLocalStream( &pLocalStream));
        WsbAffirmHr(pRecall->GetSize( (LONGLONG *) &remoteDataSize.QuadPart ));
        WsbAffirmHr(pRecall->GetOffset( &readOffset ));
        if (readOffset == 0) {
            verifyType = MVR_VERIFICATION_TYPE_HEADER_CRC;
        } else {
            verifyType = MVR_VERIFICATION_TYPE_NONE;
        }

        //
        // Set the current seek offset used for ordering items in the queue
        //
        m_CurrentSeekOffset = remoteDataSetStart.QuadPart + remoteFileStart.QuadPart+remoteDataStart.QuadPart+requestStart;

        //
        // Create remote data mover stream
        // TEMPORARY: Consider removing the NO_CACHING flag for a NO_RECALL recall
        //

        WsbAssert(0 != remoteDataSetStart.QuadPart, HSM_E_BAD_SEGMENT_INFORMATION);
        WsbAffirmHr( m_pDataMover->CreateRemoteStream(
                                                     CWsbBstrPtr(L""),
                                                     MVR_MODE_READ | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_NO_CACHING,
                                                     sessionName,
                                                     sessionDescription,
                                                     remoteDataSetStart,
                                                     remoteFileStart,
                                                     remoteFileSize,
                                                     remoteDataStart,
                                                     remoteDataSize,
                                                     verifyType,
                                                     remoteVerificationData,
                                                     &pRemoteStream ) );

        //
        // The offset given here is the offset into the stream itself (readOffset).  
        // The actual position on remote media will be the bag start plus the file start
        // plus the file-data start (all given in CreateRemoteStream) plus this offset.
        //
        WsbTrace(OLESTR("Setting offset to %I64d reading %I64u\n"), readOffset, remoteDataSize.QuadPart);

        offset.QuadPart = readOffset;
        WsbAffirmHr( m_pDataMover->SetInitialOffset( offset ) );

        //
        // Once the remote stream has been created we must make sure we detach it
        //

        try {

            WsbAffirmHr( pRemoteStream->CopyTo( pLocalStream, remoteDataSize, &read, &written ) );
            WsbAffirmHr( pLocalStream->Commit( STGC_DEFAULT ) );

            //
            // The CopyTo succeeded... make sure we got all the bytes
            // we asked for.
            //
            // If we attempt to read from a incomplete Master that
            // does not contain the migrated data we'll fail here with
            // MVR_S_NO_DATA_DETECTED.
            //
            WsbAffirm( written.QuadPart == remoteDataSize.QuadPart, HSM_E_VALIDATE_DATA_NOT_ON_MEDIA );

            WsbAffirmHr( m_pDataMover->CloseStream() );
        }WsbCatchAndDo(hr,
                       WsbAffirmHr( m_pDataMover->CloseStream() );
                      );

        ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRED, hr);
        WsbTrace(OLESTR("RecallData returned hr = <%ls>\n"),WsbHrAsString(hr));

    }WsbCatch( hr );

    // Tell the session whether or not the work was done.
    // We don't really care about the return code, there is nothing
    // we can do if it fails.
    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
    if (pScanItem) {
        CComPtr<IHsmSession> pSession;
        HSM_JOB_PHASE  jobPhase;

        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));

        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));

        pSession->ProcessItem(jobPhase, HSM_JOB_ACTION_RECALL , pScanItem, hr);
    }

    WsbTraceOut(OLESTR("CHsmRecallQueue::RecallIt"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmRecallQueue::RaisePriority(
                              IN HSM_JOB_PHASE jobPhase,
                              IN IHsmSession *pSession
                              )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::RaisePriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(pSession != 0, E_UNEXPECTED);

        switch (m_JobPriority) {
        
        case HSM_JOB_PRIORITY_IDLE:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
            m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
            break;

        case HSM_JOB_PRIORITY_LOWEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_LOW;
            break;

        case HSM_JOB_PRIORITY_LOW:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
            break;

        case HSM_JOB_PRIORITY_NORMAL:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_HIGH;
            break;

        case HSM_JOB_PRIORITY_HIGH:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
            m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
            break;

        case HSM_JOB_PRIORITY_HIGHEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_TIME_CRITICAL));
            m_JobPriority = HSM_JOB_PRIORITY_CRITICAL;
            break;

        default:
        case HSM_JOB_PRIORITY_CRITICAL:
            WsbAffirm(FALSE, E_UNEXPECTED);
            break;
        }

        WsbAffirmHr(pSession->ProcessPriority(jobPhase, m_JobPriority));

    }WsbCatch(hr);
    WsbTraceOut(OLESTR("CHsmRecallQueue::RaisePriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::LowerPriority(
                              IN HSM_JOB_PHASE jobPhase,
                              IN IHsmSession *pSession
                              )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::LowerPriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(pSession != 0, E_UNEXPECTED);

        switch (m_JobPriority) {
        case HSM_JOB_PRIORITY_IDLE:
            WsbAffirm(FALSE, E_UNEXPECTED);
            break;

        case HSM_JOB_PRIORITY_LOWEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_IDLE));
            m_JobPriority = HSM_JOB_PRIORITY_IDLE;
            break;

        case HSM_JOB_PRIORITY_LOW:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
            m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
            break;

        case HSM_JOB_PRIORITY_NORMAL:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_LOW;
            break;

        case HSM_JOB_PRIORITY_HIGH:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
            break;

        case HSM_JOB_PRIORITY_HIGHEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_HIGH;
            break;

        default:
        case HSM_JOB_PRIORITY_CRITICAL:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
            m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
            break;
        }

        WsbAffirmHr(pSession->ProcessPriority(jobPhase, m_JobPriority));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::LowerPriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}




HRESULT
CHsmRecallQueue::CheckRms(
                         void
                         )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::CheckRms"),OLESTR(""));
    try {
        //
        // Make sure we can still talk to the RMS
        //
        if (m_pRmsServer != 0) {
            CWsbBstrPtr name;
            hr = m_pRmsServer->GetServerName( &name );
            if (hr != S_OK) {
                m_pRmsServer = 0;
                hr = S_OK;
            }
        }
        //
        // Get RMS that runs on this machine
        //
        if (m_pRmsServer == 0) {
            WsbAffirmHr(m_pServer->GetHsmMediaMgr(&m_pRmsServer));

            // wait for RMS to come ready
            // (this may not be needed anymore - if Rms initialization is
            //  synced with Engine initialization)
            CComObject<CRmsSink> *pSink = new CComObject<CRmsSink>;
            CComPtr<IUnknown> pSinkUnk = pSink; // holds refcount for use here
            WsbAffirmHr( pSink->Construct( m_pRmsServer ) );
            WsbAffirmHr( pSink->WaitForReady( ) );
            WsbAffirmHr( pSink->DoUnadvise( ) );
        }
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::CheckRms"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::CheckSession(
                             IHsmSession *pSession,
                             IHsmRecallItem *pWorkItem
                             )

/*++


--*/ {
    HRESULT                 hr = S_OK;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::CheckSession"),OLESTR(""));
    try {

        //
        // Check to see if we have dealt with this or any other session before.
        WsbTrace(OLESTR("New session.\n"));

        //
        // We have no on going session so we need to establish communication
        // with this session.
        //
        CComPtr<IHsmSessionSinkEveryState>  pSinkState;
        CComPtr<IHsmSessionSinkEveryEvent>  pSinkEvent;
        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IConnectionPoint>           pCP;
        CComPtr<IFsaResource>               pFsaResource;
        HSM_JOB_PHASE                       jobPhase;
        DWORD                               stateCookie, eventCookie;
        ULONG                                           refCount;

        // Tell the session we are starting up.
        pWorkItem->SetJobState(HSM_JOB_STATE_STARTING);
        pWorkItem->GetJobPhase(&jobPhase);
        WsbTrace(OLESTR("Before Process State.\n"));
        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before 1st process state: %ls \n"), WsbLongAsString((LONG) refCount));
        WsbAffirmHr(pSession->ProcessState(jobPhase, HSM_JOB_STATE_STARTING, m_CurrentPath, bLog));
        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after 1st process state: %ls \n"), WsbLongAsString((LONG) refCount));
        WsbTrace(OLESTR("After Process State.\n"));

        // Get the interface to the callback that the sessions should use.
        WsbTrace(OLESTR("Before QI's for sinks.\n"));
        WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSinkState));
        WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSinkEvent));
        WsbTrace(OLESTR("After QI's for sinks.\n"));
        // Ask the session to advise of every state changes.
        WsbTrace(OLESTR("Before QI for connection point containers.\n"));

        WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
        WsbAffirmHr(pCP->Advise(pSinkState, &stateCookie));

        pWorkItem->SetStateCookie(stateCookie);
        pCP = 0;

        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
        WsbAffirmHr(pCP->Advise(pSinkEvent, &eventCookie));
        pWorkItem->SetEventCookie(eventCookie);

        pCP = 0;
        WsbTrace(OLESTR("After Advises.\n"));
        //
        // Get the resource for this work from the session
        //
        WsbAffirmHr(pSession->GetResource(&pFsaResource));
        pWorkItem->SetJobState(HSM_JOB_STATE_ACTIVE);

        WsbTrace(OLESTR("Before Process State.\n"));

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before 2nd process state: %ls \n"), WsbLongAsString((LONG) refCount));

        WsbAffirmHr(pSession->ProcessState(jobPhase, HSM_JOB_STATE_ACTIVE, m_CurrentPath, bLog));

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after 2nd process state: %ls \n"), WsbLongAsString((LONG) refCount));

        WsbTrace(OLESTR("After Process State.\n"));

    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::CheckSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::DoWork( void )
/*++


--*/ 
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    CComPtr<IHsmRecallItem> pWorkItem;
    HSM_WORK_ITEM_TYPE      workType;
    BOOLEAN                 done = FALSE;
    HRESULT                 skipWork = S_FALSE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::DoWork"),OLESTR(""));

    //  Make sure this object isn't released (and our thread killed
    //  before finishing up in this routine
    ((IUnknown*)(IHsmRecallQueue*)this)->AddRef();

    try {
        while (!done) {
            //
            // Get the next work to do from the queue
            //
            hr = m_pWorkToDo->First(IID_IHsmRecallItem, (void **)&pWorkItem);

            if (WSB_E_NOTFOUND == hr) {
                //
                //  We might be done with this queue.
                //  Attempt to destroy it: if we cannot it means there are more items
                //  that were being added so we continue looping
                //
                hr = m_pTskMgr->WorkQueueDone(NULL, HSM_WORK_TYPE_FSA_DEMAND_RECALL, &m_MediaId);
                if (hr == S_OK) {
                    //
                    // Queue is really done - break out of the while loop
                    //
                    done = TRUE;
                    break;
                } else if (hr == S_FALSE) {
                    //
                    // More items in the queue
                    //
                    continue;
                } else {
                    //
                    // Some sort of error happened, bale out
                    //
                    WsbTraceAlways(OLESTR("CHsmRecallQueue::DoWork: WorkQueueDone failed with <%ls> - terminating queue thread\n"),
                                WsbHrAsString(hr));
                    WsbAffirmHr(hr);
                }
            } else {
                WsbAffirmHr(hr);
                //
                // Remove it from the queue
                //           
                Remove(pWorkItem);

            }

            WsbAffirmHr(pWorkItem->GetWorkType(&workType));

             switch (workType) {
                
                case HSM_WORK_ITEM_FSA_DONE: {
                        //
                        // TBD:Code path should not be reached
                        //
                        WsbTraceAlways(OLESTR("Unexpected: CHsmRecallQueue::DoWork - FSA WORK DONE item\n"));

                        break;
                    }

                case HSM_WORK_ITEM_FSA_WORK: {
                        if (S_FALSE == skipWork) {
                            //
                            // Get the FSA Work Item and do the work
                            //
                            hr = DoFsaWork(pWorkItem);
                        } else {
                            //
                            // Skip the work
                            //
                            try {
                                CComPtr<IFsaPostIt>      pFsaWorkItem;
                                CComPtr<IFsaScanItem>    pScanItem;
                                CComPtr<IFsaResource>    pFsaResource;
                                CComPtr<IHsmSession>     pSession;
                                HSM_JOB_PHASE            jobPhase;

                                WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                                WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));
                                WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
                                WsbAffirmHr(pSession->GetResource(&pFsaResource));
                                WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));

                                hr = pFsaWorkItem->SetResult(skipWork);

                                if (S_OK == hr) {
                                    WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
                                    hr = pFsaResource->ProcessResult(pFsaWorkItem);
                                    WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                                }
                                (void)pSession->ProcessHr(jobPhase, 0, 0, hr);
                                WsbAffirmHr(pSession->ProcessItem(jobPhase,
                                                                  HSM_JOB_ACTION_RECALL,
                                                                  pScanItem,
                                                                  skipWork));
                            }WsbCatch( hr );
                        }
                        EndRecallSession(pWorkItem, FALSE);

                        break;
                    }

                case HSM_WORK_ITEM_MOVER_CANCELLED: {
                        CComPtr<IHsmRecallItem> pWorkItemToCancel;

                        WsbTrace(OLESTR("CHsmRecallQueue::DoWork - Mover Cancelled\n"));
                        try {
                            //
                            // Get hold of the work item that needs to be cancelled.
                            // This is indicated by the session pointer in the cancel work item
                            //
                            hr = FindRecallItemToCancel(pWorkItem, &pWorkItemToCancel);
                            if (hr == S_OK) {
                                EndRecallSession(pWorkItemToCancel, TRUE);
                                //
                                // Remove the *cancelled* work item
                                //
                                Remove(pWorkItemToCancel);
                            }

                            //
                            // Remove the cancel work item
                            //
                            hr = S_OK;
                        }WsbCatch( hr );
                        //
                        // We are done completely with one more work item
                        //
                        break;
                    }

                default: {
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
               pWorkItem = 0;
           }
    }WsbCatch( hr );

    //
    // Dismount the media..
    //
    DismountMedia(FALSE);

    // Pretend everything is OK
    hr = S_OK;

    //  Release the thread (the thread should terminate on exit
    //  from the routine that called this routine)
    CloseHandle(m_WorkerThread);
    m_WorkerThread = 0;

    //  Allow this object to be released
    ((IUnknown*)(IHsmRecallQueue*)this)->Release();

    WsbTraceOut(OLESTR("CHsmRecallQueue::DoWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmRecallQueue::DoFsaWork(
                          IHsmRecallItem *pWorkItem
                          )
/*++


--*/ 
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2 = S_OK;
    HRESULT                 workHr = S_OK;
    HSM_JOB_PHASE           jobPhase;

    CWsbStringPtr           path;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    CComPtr<IHsmSession>    pSession;
    CComPtr<IFsaResource>   pFsaResource;

    WsbTraceIn(OLESTR("CHsmRecallQueue::DoFsaWork"),OLESTR(""));
    try {
        //
        // Do the work.
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pSession->GetResource(&pFsaResource));

        WsbTrace(OLESTR("Handling file <%s>.\n"), WsbAbbreviatePath(path, 120));
        workHr = RecallIt(pWorkItem);
        //
        // Tell the recaller right away about the success or failure
        // of the recall, we do this here so the recall filter can
        // release the open as soon as possible
        //
        hr = pFsaWorkItem->SetResult(workHr);
        if (S_OK == hr) {
            WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
            hr = pFsaResource->ProcessResult(pFsaWorkItem);
            WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
        }

        // Note: In case that the recall item is/was canceling at any time, we don't want
        //  to report on errors. If the cancel occurred  while the recall item was queued, 
        //  we won't get here at all, but if it was cancelled while being executed, we 
        //  might end up here with some bad workHr returned by the Mover code
        if ((S_OK != workHr) && (S_OK != pSession->IsCanceling())) {
            // Tell the session how things went if they didn't go well.
            (void) pSession->ProcessHr(jobPhase, 0, 0, workHr);
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::DoFsaWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::MountMedia(
                           IHsmRecallItem *pWorkItem,
                           GUID           mediaToMount,
                           BOOL           bShortWait
                           )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_MediaToMount = mediaToMount;
    CComPtr<IRmsDrive>      pDrive;
    CWsbBstrPtr             pMediaName;
    DWORD                   dwOptions = RMS_NONE;
    DWORD                   threadId;
    CComPtr<IFsaPostIt>     pFsaWorkItem;

    WsbTraceIn(OLESTR("CHsmRecallQueue::MountMedia"),OLESTR("Display Name = <%ls>"), (WCHAR *)m_MediaName);
    try {
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetThreadId(&threadId));

        // If we're switching tapes, dismount the current one
        if ((m_MountedMedia != l_MediaToMount) && (m_MountedMedia != GUID_NULL)) {
            WsbAffirmHr(DismountMedia());
        }
        // Ask RMS for short timeout, both for Mount and Allocate
        if (bShortWait) {
            dwOptions |= RMS_SHORT_TIMEOUT;
        }
        dwOptions |= RMS_USE_MOUNT_NO_DEADLOCK;

        if (m_MountedMedia != l_MediaToMount) {
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTING, hr);
            hr = m_pRmsServer->MountCartridge( l_MediaToMount, &pDrive, &m_pRmsCartridge, &m_pDataMover, dwOptions, threadId);
            hr = TranslateRmsMountHr(hr);
            //
            //  If failure is because cartridge is disabled, need to get media label to put in error.
            //
            if (hr == RMS_E_CARTRIDGE_DISABLED) {

                // Since this is just to get label, if any of these functions fail,
                // don't throw, error will simply have blank label.
                //
                CComPtr<IRmsCartridge>  pMedia;
                HRESULT                 hrName;

                hrName = m_pRmsServer->FindCartridgeById(l_MediaToMount , &pMedia);
                if (hrName == S_OK) {
                    pMedia->GetName(&pMediaName);
                }
                if ((hrName != S_OK) || ((WCHAR *)pMediaName == NULL)) {
                    // Cannot get media name - set to blanks
                    pMediaName = L"";
                }

                WsbThrow(hr);
            }

            WsbAffirmHr(hr);
            m_MountedMedia = l_MediaToMount;
            WsbTrace( OLESTR("Mount completed.\n") );

            WsbAffirmHr(GetMediaParameters());

        }
    }WsbCatchAndDo(hr,
                   switch (hr){case HSM_E_STG_PL_NOT_CFGD:case HSM_E_STG_PL_INVALID:
                   FailJob(pWorkItem);
                  break;case RMS_E_CARTRIDGE_DISABLED:
                  WsbLogEvent(HSM_MESSAGE_MEDIA_DISABLED, 0, NULL, pMediaName, NULL);
                  break;
                  default:
                  break;}
                  );

    WsbTraceOut(OLESTR("CHsmRecallQueue::MountMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::GetSource(
                          IFsaPostIt                  *pFsaWorkItem,
                          OLECHAR                     **pSourceString
                          )
/*++

Routine Description:

  This function builds the Source file name

Arguments:

  pFsaWorkItem - the item to be migrated
  pSourceString - the Source file name.

Return Value:

  S_OK

--*/ {
    HRESULT             hr = S_OK;

    CComPtr<IFsaResource>   pResource;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    CWsbStringPtr           path;

    WsbTraceIn(OLESTR("CHsmRecallQueue::GetSource"),OLESTR(""));
    try {
        //
        // Get the real session pointer from the IUnknown
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirm(pSession != 0, E_POINTER);

        // First get the name of the resource from the session
        WsbAffirmHr(pSession->GetResource(&pResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));

        tmpString.Alloc(1000);
        WsbAffirmHr(pResource->GetPath(&tmpString, 0));
        tmpString.Append(&(path[1]));
        // tmpString.Prepend(OLESTR("\\\\?\\"));
        WsbAffirmHr(tmpString.GiveTo(pSourceString));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::GetSource"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::GetScanItem(
                            IFsaPostIt *pFsaWorkItem,
                            IFsaScanItem ** ppIFsaScanItem
                            )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;
    CComPtr<IHsmSession>        pSession;
    CComPtr<IFsaResource>       pFsaResource;


    WsbTraceIn(OLESTR("CHsmRecallQueue::GetScanItem"),OLESTR(""));

    try {
        WsbAffirmPointer(ppIFsaScanItem);
        WsbAffirm(!*ppIFsaScanItem, E_INVALIDARG);
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pSession->GetResource(&pFsaResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(pFsaResource->FindFirst(path, pSession, ppIFsaScanItem));

    }WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmRecallQueue::GetScanItem"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


DWORD HsmRecallQueueThread(
                          void *pVoid
                          )

/*++


--*/ {
    HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CHsmRecallQueue*) pVoid)->DoWork();

    CoUninitialize();
    return(hr);
}


HRESULT
CHsmRecallQueue::SetState(
                         IN HSM_JOB_STATE state,
                         IN HSM_JOB_PHASE phase,
                         IN IHsmSession * pSession
                         )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmRecallQueue:SetState"), OLESTR("state = <%ls>"), JobStateAsString( state ) );

    try {
        //
        // Change the state and report the change to the session.  Unless the current state is
        // failed then leave it failed.  Is is necessary because when this guy fails, it will
        // cancel all sessions so that no more work is sent in and so we will skip any queued work.
        // If the current state is failed, we don't need to spit out the failed message every time,
        // so we send ProcessState a false fullmessage unless the state is cancelled.
        //
        WsbAffirmHr(pSession->ProcessState(phase, state, m_CurrentPath, TRUE));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::SetState"), OLESTR("hr = <%ls> "), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallQueue::Cancel(
                       IN HSM_JOB_PHASE jobPhase,
                       IN IHsmSession *pSession
                       )

/*++

Implements:

  CHsmRecallQueue::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    UNREFERENCED_PARAMETER(pSession);

    WsbTraceIn(OLESTR("CHsmRecallQueue::Cancel"), OLESTR(""));

    (void)SetState(HSM_JOB_STATE_CANCELLING, jobPhase, pSession);

    try {
        //
        // This needs to be prepended and the queue emptied out!
        //
        CComPtr<IHsmRecallItem>  pWorkItem;
        CComPtr<IFsaPostIt>      pFsaWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallItem, IID_IHsmRecallItem,
                                                       (void **)&pWorkItem));
        //
        // Create the minimal postit needed to contain the session so that DoWork
        // can retrieve it from the work item.
        // TBD: make pSession a member of CHsmRecallItem, so that we don't need
        // to keep obtaining it via the IFsaPostIt. Also it saves us the trouble
        // of creating a dummy FsaPostIt here.
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CFsaPostIt, IID_IFsaPostIt,
                                                       (void **)&pFsaWorkItem));

        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_MOVER_CANCELLED));
        WsbAffirmHr(pWorkItem->SetJobPhase(jobPhase));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->SetSession(pSession));
        //
        // Our work item is ready now, ship it
        //
        WsbAffirmHr(m_pWorkToDo->Prepend(pWorkItem));
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::FailJob(
                        IHsmRecallItem *pWorkItem
                        )

/*++

Implements:

  CHsmRecallQueue::FailJob().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    HSM_JOB_PHASE           jobPhase;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FailJob"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));

        WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED, jobPhase, pSession));
        if (pSession != 0) {
            WsbAffirmHr(pSession->Cancel( HSM_JOB_PHASE_ALL ));
        }

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::FailJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}


void
CHsmRecallQueue::ReportMediaProgress(
                                    HSM_JOB_MEDIA_STATE state,
                                    HRESULT               /*status*/
                                    )

/*++

Implements:

  CHsmRecallQueue::ReportMediaProgress().

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           mediaName;
    HSM_JOB_MEDIA_TYPE      mediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;

    UNREFERENCED_PARAMETER(state);

    WsbTraceIn(OLESTR("CHsmRecallQueue::ReportMediaProgress"), OLESTR(""));

//
// TBD : we have to figure out a way to report media progress!
// Without the session pointer this is tough..
//
    // Report Progress but we don't really care if it succeeds.
//		hr = m_pSession->ProcessMediaState(m_JobPhase, state, m_MediaName, m_MediaType, 0);
    WsbTraceOut(OLESTR("CHsmRecallQueue::ReportMediaProgress"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
}


HRESULT
CHsmRecallQueue::GetMediaParameters( void )

/*++

Implements:

  CHsmRecallQueue::GetMediaParameters

--*/ {
    HRESULT                 hr = S_OK;
    LONG                    rmsCartridgeType;
    CWsbBstrPtr             barCode;


    WsbTraceIn(OLESTR("CHsmRecallQueue::GetMediaParameters"), OLESTR(""));
    try {
        //
        // Get some information about the media
        //
        WsbAffirmHr(m_pDataMover->GetLargestFreeSpace( &m_MediaFreeSpace, &m_MediaCapacity ));
        WsbAffirmHr(m_pRmsCartridge->GetType( &rmsCartridgeType ));
        WsbAffirmHr(ConvertRmsCartridgeType(rmsCartridgeType, &m_MediaType));
        WsbAffirmHr(m_pRmsCartridge->GetName(&barCode));
        WsbAffirmHr(CoFileTimeNow(&m_MediaUpdate));
        m_MediaBarCode = barCode;
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::GetMediaParameters"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::DismountMedia( BOOL bNoDelay)

/*++

Implements:

  CHsmRecallQueue::DismountMedia

--*/ {
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::DismountMedia"), OLESTR(""));
    try {
        if ((m_pRmsCartridge != 0) && (m_MountedMedia != GUID_NULL)) {
            //
            // End the session with the data mover.  If this doesn't work, report
            // the problem but continue with the dismount.
            //

            //
            // Tell the session that we are dismounting media. Ignore any problems
            // with the reporting
            //
            (void )ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTING, S_OK);

            //
            // Dismount the cartridge and report progress
            //

            // !!! IMPORTANT NOTE !!!
            //
            // Must free Rms resources used before dismounting...
            //
            m_pRmsCartridge = 0;
            m_pDataMover    = 0;

            DWORD dwOptions = RMS_NONE;
            if (bNoDelay) {
                dwOptions |= RMS_DISMOUNT_DEFERRED_ONLY;
            }
            hr = m_pRmsServer->DismountCartridge(m_MountedMedia, dwOptions);
            (void) ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTED, hr);

            //
            // Clear out the knowledge of media that was just dismounted
            //
            WsbAffirmHr(UnsetMediaInfo());

            WsbAffirmHr(hr);
            WsbTrace( OLESTR("Dismount completed OK.\n") );
        } else {
            WsbTrace( OLESTR("There is no media to dismount.\n") );
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::DismountMedia"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::ConvertRmsCartridgeType(
                                        LONG                rmsCartridgeType,
                                        HSM_JOB_MEDIA_TYPE  *pMediaType
                                        )

/*++

Implements:

  CHsmRecallQueue::ConvertRmsCartridgeType

--*/ {
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::ConvertRmsCartridgeType"), OLESTR(""));
    try {

        WsbAssert(0 != pMediaType, E_POINTER);

        switch (rmsCartridgeType) {
        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:
            *pMediaType = HSM_JOB_MEDIA_TYPE_TAPE;
            break;
        case RmsMediaOptical:
        case RmsMediaMO35:
        case RmsMediaWORM:
        case RmsMediaCDR:
        case RmsMediaDVD:
            *pMediaType = HSM_JOB_MEDIA_TYPE_OPTICAL;
            break;
        case RmsMediaDisk:
            *pMediaType = HSM_JOB_MEDIA_TYPE_REMOVABLE_MAG;
            break;
        case RmsMediaFixed:
            *pMediaType = HSM_JOB_MEDIA_TYPE_FIXED_MAG;
            break;
        case RmsMediaUnknown:default:
            *pMediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
            break;
        }
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::ConvertRmsCartridgeType"), OLESTR("hr = <%ls>"),
                WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmRecallQueue::MarkWorkItemAsDone(IN IHsmSession *pSession,
                                    IN HSM_JOB_PHASE jobPhase)

/*++

Implements:

  CHsmRecallQueue::MarkWorkItemAsDone

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmRecallQueue::MarkWorkItemAsDone"), OLESTR(""));
    try {
        // Create a work item and append it to the work queue to
        // indicate that the job is done
        CComPtr<IHsmRecallItem>  pWorkItem;
        CComPtr<IFsaPostIt>      pFsaWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallItem, IID_IHsmRecallItem,
                                                       (void **)&pWorkItem));

        //
        // Create the minimal postit needed to contain the session so that DoWork
        // can retrieve it from the work item.
        // TBD: make pSession a member of CHsmRecallItem, so that we don't need
        // to keep obtaining it via the IFsaPostIt. Also it saves us the trouble
        // of creating a dummy FsaPostIt here.
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CFsaPostIt, IID_IFsaPostIt,
                                                       (void **)&pFsaWorkItem));

        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_DONE));
        WsbAffirmHr(pWorkItem->SetJobPhase(jobPhase));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->SetSession(pSession));
        //
        // Our work item is ready now, ship it
        //
        WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::MarkWorkItemAsDone"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::CheckRegistry(void)
{
    HRESULT      hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::CheckRegistry"), OLESTR(""));

    try {
        //  Check for change to number of errors to allow before cancelling
        //  a job
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_CONSECUTIVE_ERRORS,
                                                  &m_JobAbortMaxConsecutiveErrors));
        WsbTrace(OLESTR("CHsmRecallQueue::CheckRegistry: m_JobAbortMaxConsecutiveErrors = %lu\n"),
                 m_JobAbortMaxConsecutiveErrors);
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_TOTAL_ERRORS,
                                                  &m_JobAbortMaxTotalErrors));
        WsbTrace(OLESTR("CHsmRecallQueue::CheckRegistry: m_JobAbortMaxTotalErrors = %lu\n"),
                 m_JobAbortMaxTotalErrors);


    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::CheckRegistry"), OLESTR("hr = <%ls>"),
                WsbHrAsString(hr));

    return( hr );
}



HRESULT
CHsmRecallQueue::TranslateRmsMountHr(
                                    HRESULT     rmsMountHr
                                    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::TranslateRmsMountHr"),OLESTR("rms hr = <%ls>"), WsbHrAsString(rmsMountHr));
    try {
        switch (rmsMountHr) {
        case S_OK:
            hr = S_OK;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTED, hr);
            break;
        case RMS_E_MEDIASET_NOT_FOUND:
            if (m_RmsMediaSetId == GUID_NULL) {
                hr = HSM_E_STG_PL_NOT_CFGD;
            } else {
                hr = HSM_E_STG_PL_INVALID;
            }
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        case RMS_E_SCRATCH_NOT_FOUND:
            hr = HSM_E_NO_MORE_MEDIA;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        case RMS_E_CARTRIDGE_UNAVAILABLE:
        case RMS_E_RESOURCE_UNAVAILABLE:
        case RMS_E_DRIVE_UNAVAILABLE:
        case RMS_E_LIBRARY_UNAVAILABLE:
            hr = HSM_E_MEDIA_NOT_AVAILABLE;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        case RMS_E_CARTRIDGE_BUSY:
        case RMS_E_RESOURCE_BUSY:
        case RMS_E_DRIVE_BUSY:
            hr = HSM_E_MEDIA_BUSY;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_BUSY, hr);
            break;
        case RMS_E_CARTRIDGE_NOT_FOUND:
        case RMS_E_CARTRIDGE_DISABLED:
        case RMS_E_TIMEOUT:
            hr = rmsMountHr;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        default:
            hr = rmsMountHr;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        }
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::TranslateRmsMountHr"),
                OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::Remove(
                       IHsmRecallItem *pWorkItem
                       )
/*++

Implements:

  IHsmFsaTskMgr::Remove

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Remove"),OLESTR(""));
    try {
        //
        // Remove the item from the queue
        //
        (void)m_pWorkToDo->RemoveAndRelease(pWorkItem);
    }WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::Remove"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::ChangeSysState(
                               IN OUT HSM_SYSTEM_STATE* pSysState
                               )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::ChangeSysState"), OLESTR(""));

    try {

        if (pSysState->State & HSM_STATE_SUSPEND) {
            // Should have already been paused via the job}else if (pSysState->State & HSM_STATE_RESUME){
            // Should have already been resumed via the job}else if (pSysState->State & HSM_STATE_SHUTDOWN){

            //  Release the thread (we assume it has been stopped already)
            if (m_WorkerThread) {
                CloseHandle(m_WorkerThread);
                m_WorkerThread = 0;
            }

            if (m_pDataMover) {
                //
                // Cancel any active I/O
                //
                (void) m_pDataMover->Cancel();
            }
/* TBD
          // If Session is valid - unadvise and free session, otherwise, just try to
          // dismount media if it is mounted (which we don't know at this point)
          // Best effort dismount, no error checking so following resources will get released.
          if (m_pSession != 0) {
              EndSessions(FALSE, TRUE);
          } else {
              (void) DismountMedia(TRUE);
          }
*/
            (void) DismountMedia(TRUE);
        }

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallQueue::EndRecallSession(
                                 IN IHsmRecallItem   *pWorkItem,
                                 IN BOOL               cancelled
                                 )
{
    HRESULT             hr = S_OK;
    CComPtr<IFsaPostIt> pFsaWorkItem;
    DWORD               stateCookie;
    DWORD               eventCookie;

    ULONG                     refCount;

    WsbTraceIn(OLESTR("CHsmRecallQueue::EndRecallSession"),OLESTR(""));
    try {
        HRESULT dismountHr = S_OK;

        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IConnectionPoint>           pCP;
        CComPtr<IHsmSession>                pSession;
        HSM_JOB_PHASE                       jobPhase;
        //
        // Get the session
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->GetStateCookie(&stateCookie));
        WsbAffirmHr(pWorkItem->GetEventCookie(&eventCookie));
        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));
        //
        // Tell the session that we don't want to be advised anymore.
        //
        try {
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));

            refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
            ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
            WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before stateCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

            WsbAffirmHr(pCP->Unadvise(stateCookie));
        }WsbCatch( hr );

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after stateCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

        pCPC = 0;
        pCP = 0;

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before eventCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

        try {
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(pCP->Unadvise(eventCookie));
        }WsbCatch( hr );

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after eventCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

        pCPC = 0;
        pCP = 0;

        WsbTrace( OLESTR("Telling Session Data mover is done\n") );
        if (cancelled) {
            (void)SetState(HSM_JOB_STATE_DONE, jobPhase, pSession);
        } else {
            (void)SetState(HSM_JOB_STATE_CANCELLED, jobPhase, pSession);
        }
        pSession = 0;
        WsbAffirmHr(hr);
    }WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::EndRecallSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::UnsetMediaInfo( void )

/*++

Routine Description:

     Sets the media data members back to their default (unset) values.

Arguments:

     None.

Return Value:

     S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::UnsetMediaInfo"), OLESTR(""));

    m_MediaId        = GUID_NULL;
    m_MountedMedia   = GUID_NULL;
    m_MediaType      = HSM_JOB_MEDIA_TYPE_UNKNOWN;
    m_MediaName      = OLESTR("");
    m_MediaBarCode   = OLESTR("");
    m_MediaFreeSpace = 0;
    m_MediaCapacity = 0;
    m_MediaReadOnly = FALSE;
    m_MediaUpdate = WsbLLtoFT(0);

    WsbTraceOut(OLESTR("CHsmRecallQueue::UnsetMediaInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::GetMediaId (OUT GUID *mediaId)
/*++

Routine Description:

     Gets the media id for the queue

Arguments:

     None.

Return Value:

     S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::GetMediaId"), OLESTR(""));
    *mediaId = m_MediaId;
    WsbTraceOut(OLESTR("CHsmRecallQueue::GetMediaId"),OLESTR("hr = <%ls>, Id = <%ls>"),
                WsbHrAsString(hr), WsbPtrToGuidAsString(mediaId));
    return(hr);
}


HRESULT
CHsmRecallQueue::SetMediaId (IN GUID *mediaId)
/*++

Routine Description:

     Sets the media id for the queue

Arguments:

     None.

Return Value:

     S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::SetMediaId"), OLESTR(""));
    m_MediaId = *mediaId;
    WsbTraceOut(OLESTR("CHsmRecallQueue::SetMediaId"),OLESTR("hr = <%ls>, Id = <%ls>"),
                WsbHrAsString(hr), WsbPtrToGuidAsString(mediaId));
    return(hr);
}


HRESULT
CHsmRecallQueue::IsEmpty ( void )
/*++

Routine Description:

    Checks if the queue is empty

Arguments:

     None.

Return Value:

     S_OK:    Queue is empty
     S_FALSE: Queue is non-empty

--*/
{
    HRESULT hr;
    hr = m_pWorkToDo->IsEmpty();
    return(hr);
}


HRESULT
CHsmRecallQueue::FindRecallItemToCancel(
                                       IHsmRecallItem *pWorkItem,
                                       IHsmRecallItem **pWorkItemToCancel
                                       )
/*++

Routine Description:

     Pulls the work item that needs to be cancelled
     indicated by pWorkItem and returns it
     (by matching the pSession pointer)

Arguments:

     None.

Return Value:


--*/
{
    CComPtr<IFsaPostIt>   pFsaWorkItem;
    CComPtr<IHsmSession>  pSession;
    CComPtr<IHsmSession>  pWorkSession;
    HRESULT                  hr;
    ULONG index = 0;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FindRecallItemToCancel"), OLESTR(""));

    pWorkItem->GetFsaPostIt(&pFsaWorkItem);
    pFsaWorkItem->GetSession(&pSession);
    pFsaWorkItem = 0;
    do {
        hr = m_pWorkToDo->At(index, IID_IHsmRecallItem, (void **)pWorkItemToCancel);
        if (S_OK == hr) {
            (*pWorkItemToCancel)->GetFsaPostIt(&pFsaWorkItem);
            pFsaWorkItem->GetSession(&pWorkSession);
            if ((pWorkItem != (*pWorkItemToCancel)) && (pSession == pWorkSession)) {
                WsbTrace(OLESTR("CHsmRecallQueue::FindRecallItemToCancel: Found item to cancel, pSession = %p\n"), pSession);
                break;
            }
            (*pWorkItemToCancel)->Release();
            (*pWorkItemToCancel) = 0;
            pWorkSession = 0;
            pFsaWorkItem = 0;
        }
        index++;
    } while (S_OK == hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::FindRecallItemToCancel"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmreclq.h ===
/*++


Module Name:

    hsmreclq.h

Abstract:

    This header file defines the CHsmRecallQueue object, which is used by the HSM
    Engine to direct work to be performed by the Remote Storage system.

Author:

    Ravisankar Pudipeddi       [ravisp]

Revision History:

--*/


#include "resource.h"       // main symbols
#include "wsb.h"            // Wsb structure definitions
#include "rms.h"            // RMS structure definitions
#include "job.h"            // RMS structure definitions
#include "metalib.h"        // metadata library structure definitions
#include "fsalib.h"         // FSA structure definitions
#include "tsklib.h"         // FSA structure definitions
#include "mvrint.h"         // Datamover interface


#ifndef __HSMRECALLQUEUE__
#define __HSMRECALLQUEUE__
/////////////////////////////////////////////////////////////////////////////
// task

class CHsmRecallQueue :
    public CComObjectRoot,
    public IHsmRecallQueue,
    public IHsmSessionSinkEveryEvent,
    public IHsmSessionSinkEveryState,
    public CComCoClass<CHsmRecallQueue,&CLSID_CHsmRecallQueue>
{
public:
    CHsmRecallQueue() {}
BEGIN_COM_MAP(CHsmRecallQueue)
    COM_INTERFACE_ENTRY(IHsmRecallQueue)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryState)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmRecallQueue )

// IHsmRecallQueue
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Add)(IFsaPostIt *pFsaWorkItem, IN GUID *pBagId, IN LONGLONG dataSetStart);
    STDMETHOD(Init)(IUnknown *pServer, IHsmFsaTskMgr *pTskMgr);
    STDMETHOD(Start)( void );
    STDMETHOD(Stop)( void );
    STDMETHOD(ContactOk)( void );

    STDMETHOD(ProcessSessionEvent)(IHsmSession *pSession, HSM_JOB_PHASE phase,
                                    HSM_JOB_EVENT event);
    STDMETHOD(ProcessSessionState)(IHsmSession* pSession, IHsmPhase* pPhase,
                                    OLECHAR* currentPath);
    STDMETHOD(RaisePriority)(HSM_JOB_PHASE jobPhase, IHsmSession *pSession);
    STDMETHOD(Remove)(IHsmRecallItem *pWorkItem);
    STDMETHOD(LowerPriority)(HSM_JOB_PHASE jobPhase, IHsmSession *pSession);
    STDMETHOD(GetMediaId) (OUT GUID *mediaId);
    STDMETHOD(SetMediaId) (IN GUID  *mediaId);
    STDMETHOD(IsEmpty) (	void	);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );


// Internal Helper functions
    STDMETHOD(RecallIt)( IHsmRecallItem *pWorkItem );
    STDMETHOD(CheckRms)(void);
    STDMETHOD(CheckSession)(IHsmSession* pSession, IHsmRecallItem *pWorkItem);
    STDMETHOD(MountMedia)(IHsmRecallItem *pWorkItem, GUID mediaToMount, BOOL bShortWait=FALSE );
    STDMETHOD(GetSource)(IFsaPostIt *pFsaWorkItem, OLECHAR **pSourceString);
    STDMETHOD(EndRecallSession)(IHsmRecallItem *pWorkItem, BOOL cancelled);
    STDMETHOD(GetScanItem)(IFsaPostIt *fsaWorkItem, IFsaScanItem** ppIFsaScanItem);
    STDMETHOD(DoWork)(void);
    STDMETHOD(DoFsaWork)(IHsmRecallItem *pWorkItem);
    STDMETHOD(SetState)(HSM_JOB_STATE state, HSM_JOB_PHASE phase, IHsmSession *pSession);
    STDMETHOD(Cancel)(HSM_JOB_PHASE jobPhase, IHsmSession *pSession);
    STDMETHOD(FailJob)(IHsmRecallItem *pWorkItem);
    STDMETHOD(GetMediaParameters)(void);
    STDMETHOD(DismountMedia)( BOOL bNoDelay = FALSE);
    STDMETHOD(ConvertRmsCartridgeType)(LONG rmsCartridgeType,
                                        HSM_JOB_MEDIA_TYPE *pMediaType);
    void (ReportMediaProgress)(HSM_JOB_MEDIA_STATE state, HRESULT status);
    STDMETHOD(MarkWorkItemAsDone)(IHsmSession *pSession, HSM_JOB_PHASE jobPhase);
    STDMETHOD(CheckRegistry)(void);
    STDMETHOD(TranslateRmsMountHr)(HRESULT rmsHr);
    STDMETHOD(UnsetMediaInfo)(void);
    STDMETHOD(FindRecallItemToCancel(IHsmRecallItem *pWorkItem, IHsmRecallItem **pWorkItemToCancel));

    // Data
    // We want the next pointers (to the Hsm Server) to be weak
    // references and **not** add ref the object.  This is so shutting
    // down the server really works.
    IHsmServer                          *m_pServer;
    IWsbCreateLocalObject               *m_pHsmServerCreate;
    IHsmFsaTskMgr                       *m_pTskMgr;

    CComPtr<IRmsServer>                 m_pRmsServer;
    CComPtr<IRmsCartridge>              m_pRmsCartridge;
    CComPtr<IDataMover>                 m_pDataMover;

    //
    // The recall queue..
    //
    CComPtr<IWsbIndexedCollection>      m_pWorkToDo;

    // Data mover info
    GUID                                m_MediaId;
    GUID                                m_MountedMedia;
    HSM_JOB_MEDIA_TYPE                  m_MediaType;
    CWsbStringPtr                       m_MediaName;
    CWsbStringPtr                       m_MediaBarCode;
    LONGLONG                            m_MediaFreeSpace;
    LONGLONG                            m_MediaCapacity;
    BOOL                                m_MediaReadOnly;
    GUID                                m_HsmId;
    GUID                                m_RmsMediaSetId;
    CWsbBstrPtr                         m_RmsMediaSetName;
    HSM_WORK_QUEUE_TYPE                 m_QueueType;
    FILETIME                            m_MediaUpdate;

    // Session reporting information
    HSM_JOB_PRIORITY                    m_JobPriority;

    HANDLE                              m_WorkerThread;
    CWsbStringPtr                       m_CurrentPath;
    CWsbStringPtr                       m_MediaBaseName;


    // Job abort on errors parameters
    ULONG                               m_JobAbortMaxConsecutiveErrors;
    ULONG                               m_JobAbortMaxTotalErrors;
    ULONG                               m_JobConsecutiveErrors;
    ULONG                               m_JobTotalErrors;
    ULONG                               m_JobAbortSysDiskSpace;
    LONGLONG                            m_CurrentSeekOffset;
};

#endif // __HSMRECALLQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmrecli.h ===
#ifndef _HSMRECLI_
#define _HSMRECLI_

/*++


Module Name:

    HSMRECLI.H

Abstract:

    This class represents an HSM work item - a unit of work
    that is performed by the HSM engine

Author:

    Ravisankar Pudipeddi [ravisp]

Revision History:

--*/

#include "resource.h"       // main symbols

#include "job.h"
#include "task.h"

/*++

Class Name:
    
    CHsmRecallItem

Class Description:


--*/


class CHsmRecallItem : 
    public CWsbObject,
    public IHsmRecallItem,
    public CComCoClass<CHsmRecallItem,&CLSID_CHsmRecallItem>
{
public:
    CHsmRecallItem() {}
BEGIN_COM_MAP(CHsmRecallItem)
    COM_INTERFACE_ENTRY(IHsmRecallItem)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmRecallItem )

// CWsbCollectable
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
    
// IHsmRecallItem
public:
    STDMETHOD(CompareToIHsmRecallItem)(IHsmRecallItem* pWorkItem, SHORT* pResult);

    STDMETHOD(GetFsaPostIt)(IFsaPostIt  **ppFsaPostIt);
    STDMETHOD(GetFsaResource)(IFsaResource **ppFsaResource);
    STDMETHOD(GetId)(GUID *pId);
    STDMETHOD(GetMediaInfo)(GUID *pMediaId, FILETIME *pMediaLastUpdate,
                            HRESULT *pMediaLastError, BOOL *pMediaRecallOnly,
                            LONGLONG *pMediaFreeBytes, short *pMediaRemoteDataSet);
    STDMETHOD(GetResult)(HRESULT  *pHr);
    STDMETHOD(GetWorkType)(HSM_WORK_ITEM_TYPE *pWorkType);

    STDMETHOD(GetEventCookie)(OUT DWORD *pEventCookie);
    STDMETHOD(GetStateCookie)(OUT DWORD *pStateCookie);
    STDMETHOD(GetJobState)(OUT HSM_JOB_STATE *pJobState);
    STDMETHOD(GetJobPhase)(OUT HSM_JOB_PHASE *pJobPhase);
    STDMETHOD(GetSeekOffset)(OUT LONGLONG *pSeekOffset);
    STDMETHOD(GetBagId)(OUT GUID *bagId);
    STDMETHOD(GetDataSetStart)(OUT LONGLONG *dataSetStart);

    STDMETHOD(SetFsaPostIt)(IFsaPostIt  *pFsaPostIt);
    STDMETHOD(SetFsaResource)(IFsaResource *pFsaResource);
    STDMETHOD(SetMediaInfo)(GUID mediaId, FILETIME mediaLastUpdate,
                            HRESULT mediaLastError, BOOL mediaRecallOnly,
                            LONGLONG mediaFreeBytes, short mediaRemoteDataSet);
    STDMETHOD(SetResult)(HRESULT  hr);
    STDMETHOD(SetWorkType)(HSM_WORK_ITEM_TYPE workType);

    STDMETHOD(SetEventCookie)(IN DWORD eventCookie);
    STDMETHOD(SetStateCookie)(IN DWORD stateCookie);
    STDMETHOD(SetJobState)(IN HSM_JOB_STATE jobState);
    STDMETHOD(SetJobPhase)(IN HSM_JOB_PHASE jobPhase);
    STDMETHOD(SetSeekOffset)(IN LONGLONG seekOffset);
    STDMETHOD(SetBagId)(IN GUID *bagId);
    STDMETHOD(SetDataSetStart)(IN LONGLONG dataSetStart);

protected:
    HSM_WORK_ITEM_TYPE      m_WorkType;         // Type of work to do
    CComPtr<IFsaPostIt>     m_pFsaPostIt;       // FSA work to do
    HRESULT                 m_WorkResult;       // Result of premigrate
    CComPtr<IFsaResource>   m_pFsaResource;     // Resource that had work

// Information about media containing the data - premigrates only
    GUID                    m_MyId;                 // Identifier for database searches
    GUID                    m_MediaId;              // HSM Engine Media ID
    FILETIME                m_MediaLastUpdate;      // Last update of copy
    HRESULT                 m_MediaLastError;       // S_OK or the last exception 
                                                    // ..encountered when accessing
                                                    // ..the media
    BOOL                    m_MediaRecallOnly;      // True if no more data is to
                                                    // ..be premigrated to the media
                                                    // ..Set by internal operations, 
                                                    // ..may not be changed externally
    LONGLONG                m_MediaFreeBytes;       // Real free space on media
    SHORT                   m_MediaRemoteDataSet;   // Next remote data set
    DWORD                   m_EventCookie;
    DWORD                   m_StateCookie;
    HSM_JOB_STATE           m_JobState;
    HSM_JOB_PHASE           m_JobPhase;
    LONGLONG                m_SeekOffset;       //parameter used to order the work-item in the queue           

    GUID                    m_BagId;
    LONGLONG                m_DataSetStart;
};

#endif  // _HSMRECLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmworkq.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmWorkQ.h

Abstract:

    This header file defines the CHsmWorkQueue object, which is used by the HSM
    Engine to direct work to be performed by the Remote Storage system.

Author:

    Cat Brant       [cbrant]    24-Jan-1997

Revision History:

--*/


#include "resource.h"       // main symbols
#include "wsb.h"            // Wsb structure definitions
#include "rms.h"            // RMS structure definitions
#include "job.h"            // RMS structure definitions
#include "metalib.h"        // metadata library structure definitions
#include "fsalib.h"         // FSA structure definitions
#include "tsklib.h"         // FSA structure definitions
#include "mvrint.h"         // Datamover interface

 
#ifndef __HSMWORKQUEUE__
#define __HSMWORKQUEUE__
/////////////////////////////////////////////////////////////////////////////
// task

class CHsmWorkQueue : 
    public CComObjectRoot,
    public IHsmWorkQueue,
    public IHsmSessionSinkEveryEvent,
    public IHsmSessionSinkEveryState,
    public CComCoClass<CHsmWorkQueue,&CLSID_CHsmWorkQueue>
{
public:
    CHsmWorkQueue() {}
BEGIN_COM_MAP(CHsmWorkQueue)
    COM_INTERFACE_ENTRY(IHsmWorkQueue)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryState)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmWorkQueue )

// IHsmWorkQueue
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Add)(IFsaPostIt *pFsaWorkItem);
    STDMETHOD(Init)(IUnknown *pServer, IHsmSession *pSession, IHsmFsaTskMgr *pTskMgr, 
                    HSM_WORK_QUEUE_TYPE type);
    STDMETHOD(Start)( void );
    STDMETHOD(Stop)( void );
    STDMETHOD(ContactOk)( void );
    STDMETHOD(GetCurrentSessionId)(GUID *pSessionId);
    STDMETHOD(GetNumWorkItems)(ULONG *pNumWorkItems);

    STDMETHOD(ProcessSessionEvent)(IHsmSession *pSession, HSM_JOB_PHASE phase, 
                                    HSM_JOB_EVENT event);
    STDMETHOD(ProcessSessionState)(IHsmSession* pSession, IHsmPhase* pPhase, 
                                    OLECHAR* currentPath);
    STDMETHOD(RaisePriority)(void);
    STDMETHOD(Remove)(IHsmWorkItem *pWorkItem);
    STDMETHOD(LowerPriority)(void);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// Internal Helper functions
    STDMETHOD(PremigrateIt)( IFsaPostIt *pFsaWorkItem );
    STDMETHOD(RecallIt)( IFsaPostIt *pFsaWorkItem );
    STDMETHOD(validateIt)(IFsaPostIt *pFsaWorkItem );
    STDMETHOD(CheckForChanges)(IFsaPostIt *pFsaWorkItem);
    STDMETHOD(CheckForDiskSpace)(void);

    STDMETHOD(CheckRms)(void);
    STDMETHOD(CheckSession)(IHsmSession* pSessionUnknown);
    STDMETHOD(StartNewBag)(void);
    STDMETHOD(StartNewMedia)(IFsaPostIt *pFsaWorkItem);
    STDMETHOD(StartNewSession)(void);
    STDMETHOD(UpdateBagInfo)(IHsmWorkItem *pWorkItem );
    STDMETHOD(CompleteBag)( void );
    STDMETHOD(UpdateSegmentInfo)(IHsmWorkItem *pWorkItem );
    STDMETHOD(UpdateMediaInfo)(IHsmWorkItem *pWorkItem );
    STDMETHOD(UpdateMetaData)(IHsmWorkItem *pWorkItem );
    STDMETHOD(GetMediaSet)(IFsaPostIt *pFsaWorkItem );
    STDMETHOD(FindMigrateMediaToUse)(IFsaPostIt *pFsaWorkItem, GUID *pMediaToUse, GUID *pFirstSideToUse, BOOL *pMediaChanged );
    STDMETHOD(FindRecallMediaToUse)(IFsaPostIt *pFsaWorkItem, GUID *pMediaToUse, BOOL *pMediaChanged );
    STDMETHOD(MountMedia)(IFsaPostIt *pFsaWorkItem, GUID mediaToMount, GUID firstSide = GUID_NULL, 
                            BOOL bShortWait = FALSE, BOOL bSerialize = FALSE);
    STDMETHOD(MarkMediaFull)(IFsaPostIt *pFsaWorkItem, GUID mediaToMark );
    STDMETHOD(MarkMediaBad)(IFsaPostIt *pFsaWorkItem, GUID mediaToMark, HRESULT lastError);
    STDMETHOD(GetSource)(IFsaPostIt *pFsaWorkItem, OLECHAR **pSourceString);
    STDMETHOD(EndSessions)(BOOL done, BOOL bNoDelay);
    STDMETHOD(GetScanItem)(IFsaPostIt *fsaWorkItem, IFsaScanItem** ppIFsaScanItem);
    STDMETHOD(DoWork)(void);
    STDMETHOD(DoFsaWork)(IHsmWorkItem *pWorkItem);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(Pause)(void);
    STDMETHOD(Resume)(void);
    STDMETHOD(Cancel)(void);
    STDMETHOD(FailJob)(void);
    STDMETHOD(PauseScanner)(void);
    STDMETHOD(ResumeScanner)(void);
    STDMETHOD(BuildMediaName)(OLECHAR **pMediaName);
    STDMETHOD(GetMediaParameters)(LONGLONG defaultFreeSpace = -1);
    STDMETHOD(DismountMedia)(BOOL bNoDelay = FALSE);
    STDMETHOD(ConvertRmsCartridgeType)(LONG rmsCartridgeType, 
                                        HSM_JOB_MEDIA_TYPE *pMediaType);
    void (ReportMediaProgress)(HSM_JOB_MEDIA_STATE state, HRESULT status);
    STDMETHOD(MarkQueueAsDone)( void );
    STDMETHOD(CopyToWaitingQueue)( IHsmWorkItem *pWorkItem );
    STDMETHOD(CompleteWorkItem)( IHsmWorkItem *pWorkItem );
    STDMETHOD(TimeToCommit)( void );
    STDMETHOD(TimeToCommit)( LONGLONG numFiles, LONGLONG amountOfData );
    STDMETHOD(CommitWork)(void);
    STDMETHOD(CheckMigrateMinimums)(void);
    STDMETHOD(CheckRegistry)(void);
    STDMETHOD(TranslateRmsMountHr)(HRESULT rmsHr);
    STDMETHOD(StoreDatabasesOnMedia)( void );
    STDMETHOD(StoreDataWithRetry)(BSTR localName, ULARGE_INTEGER localDataStart,
        ULARGE_INTEGER localDataSize, DWORD flags, ULARGE_INTEGER *pRemoteDataSetStart,
        ULARGE_INTEGER *pRemoteFileStart, ULARGE_INTEGER *pRemoteFileSize,
        ULARGE_INTEGER *pRemoteDataStart, ULARGE_INTEGER *pRemoteDataSize,
        DWORD *pRemoteVerificationType, ULARGE_INTEGER *pRemoteVerificationData,
        DWORD *pDatastreamCRCType, ULARGE_INTEGER *pDatastreamCRC, ULARGE_INTEGER *pUsn,
        BOOL *bFullMessage);
    STDMETHOD(ShouldJobContinue)(HRESULT problemHr);
    STDMETHOD(UnsetMediaInfo)(void);
    STDMETHOD(UpdateMediaFreeSpace)(void);
    STDMETHOD(GetMediaFreeSpace)(LONGLONG *pFreeSpace);

// Data
    // We want the next pointers (to the Hsm Server) to be weak
    // references and **not** add ref the object.  This is so shutting
    // down the server really works.
    IHsmServer                          *m_pServer;
    IWsbCreateLocalObject               *m_pHsmServerCreate;
    IHsmFsaTskMgr                       *m_pTskMgr;
    
    CComPtr<IFsaResource>               m_pFsaResource;
    CComPtr<IHsmSession>                m_pSession;
    CComPtr<IRmsServer>                 m_pRmsServer;
    CComPtr<IRmsCartridge>              m_pRmsCartridge;
    CComPtr<IDataMover>                 m_pDataMover;

    // Databases 
    CComPtr<IWsbDb>                     m_pSegmentDb;
    CComPtr<IWsbDbSession>              m_pDbWorkSession;
    CComPtr<IWsbIndexedCollection>      m_pStoragePools;
    CComPtr<IWsbIndexedCollection>      m_pWorkToDo;
    CComPtr<IWsbIndexedCollection>      m_pWorkToCommit;

    // Data mover info
    GUID                                m_BagId;
    GUID                                m_MediaId;
    GUID                                m_MountedMedia;
    HSM_JOB_MEDIA_TYPE                  m_MediaType;
    CWsbStringPtr                       m_MediaName;
    CWsbStringPtr                       m_MediaBarCode;
    LONGLONG                            m_MediaFreeSpace;
    LONGLONG                            m_MediaCapacity;
    BOOL                                m_MediaReadOnly;
    GUID                                m_HsmId;
    ULARGE_INTEGER                      m_RemoteDataSetStart;
    GUID                                m_RmsMediaSetId;
    CWsbBstrPtr                         m_RmsMediaSetName;
    SHORT                               m_RemoteDataSet;
    FSA_REQUEST_ACTION                  m_RequestAction;
    HSM_WORK_QUEUE_TYPE                 m_QueueType;
    HRESULT                             m_BadMedia;
    FILETIME                            m_MediaUpdate;
    HRESULT                             m_BeginSessionHr;

    // Session reporting information
    DWORD                               m_StateCookie;
    DWORD                               m_EventCookie;
    
    HSM_JOB_PRIORITY                    m_JobPriority;
    HSM_JOB_ACTION                      m_JobAction;
    HSM_JOB_STATE                       m_JobState;
    HSM_JOB_PHASE                       m_JobPhase;

    HANDLE                              m_WorkerThread;
    BOOL                                m_WorkInProgress;
    CWsbStringPtr                       m_CurrentPath;
    CWsbStringPtr                       m_MediaBaseName;

    // Minimum migrate parameters
    ULONG                               m_MinBytesToMigrate;
    ULONG                               m_MinFilesToMigrate;

    // Commit parameters
    //  Force a commit after writing this many bytes:
    ULONG                               m_MaxBytesBeforeCommit;
    //  Don't commit unless we've written at least this many bytes:
    ULONG                               m_MinBytesBeforeCommit;
    //  Force a commit after writing this many files IF also m_MinBytesBeforeCommit:
    ULONG                               m_FilesBeforeCommit;
    //  Force a commit if free bytes on media is less than this IF also m_MinBytesBeforeCommit:
    ULONG                               m_FreeMediaBytesAtEndOfMedia;

    LONGLONG                            m_DataCountBeforeCommit;
    LONGLONG                            m_FilesCountBeforeCommit;

    BOOL                                m_StoreDatabasesInBags;

    // Pause/Resume parameters  
    ULONG                               m_QueueItemsToPause;
    ULONG                               m_QueueItemsToResume;
    BOOL                                m_ScannerPaused;

    // Job abort on errors parameters
    ULONG                               m_JobAbortMaxConsecutiveErrors;
    ULONG                               m_JobAbortMaxTotalErrors;
    ULONG                               m_JobConsecutiveErrors;
    ULONG                               m_JobTotalErrors;
    ULONG                               m_JobAbortSysDiskSpace;

    // Media id parameters
    LONG                                m_mediaCount;
    BOOL                                m_ScratchFailed;

    // Full media watermark parameters:
    //  Stop storing data after reaching this percent of free space
    ULONG                               m_MinFreeSpaceInFullMedia;
    //  Mark media as full after reaching this percent of free space
    ULONG                               m_MaxFreeSpaceInFullMedia;
};

#endif // __HSMWORKQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmworkq.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmWorkQ.cpp

Abstract:

    This class represents the HSM task manager

Author:

    Cat Brant   [cbrant]   6-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
static USHORT icountWorkq = 0;

#include "fsa.h"
#include "rms.h"
#include "metadef.h"
#include "jobint.h"
#include "hsmconn.h"
#include "wsb.h"
#include "hsmeng.h"
#include "mover.h"
#include "hsmWorkQ.h"

#include "engine.h"
#include "task.h"
#include "tskmgr.h"
#include "segdb.h"

#define HSM_STORAGE_OVERHEAD        5000

#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );

// Local prototypes
DWORD HsmWorkQueueThread(void *pVoid);
static const OLECHAR * JobStateAsString (HSM_JOB_STATE state);




static const OLECHAR *
JobStateAsString (
    IN  HSM_JOB_STATE  state
    )
/*++

Routine Description:

    Gives back a static string representing the connection state.

Arguments:

    state - the state to return a string for.

Return Value:

    NULL - invalid state passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( state ) {

    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_ACTIVE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_DONE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_FAILED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_IDLE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_RESUMING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SKIPPED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_STARTING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDING );

    default:

        return ( OLESTR("Invalid Value") );

    }
}



HRESULT
CHsmWorkQueue::FinalConstruct(
    void
    )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CComObjectRoot::FinalConstruct());

        //
        // Initialize the member data
        //
        m_pServer           = 0;
        m_pHsmServerCreate  = 0;
        m_pTskMgr;

        m_pFsaResource      = 0;
        m_pSession          = 0;
        m_pRmsServer        = 0;
        m_pRmsCartridge     = 0;
        m_pDataMover        = 0;

        m_pSegmentDb        = 0;
        m_pDbWorkSession    = 0;
        m_pStoragePools     = 0;
        m_pWorkToDo         = 0;
        m_pWorkToCommit     = 0;

        UnsetMediaInfo();

        m_BagId          = GUID_NULL;
        m_HsmId          = GUID_NULL;
        m_RemoteDataSetStart.QuadPart   = 0;
        m_RmsMediaSetId  = GUID_NULL;
        m_RmsMediaSetName = OLESTR("");
        m_RequestAction  = FSA_REQUEST_ACTION_NONE;
        m_QueueType      = HSM_WORK_TYPE_NONE;
        m_BeginSessionHr = S_FALSE;

        m_StateCookie = 0;
        m_EventCookie = 0;

        m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
        m_JobAction   = HSM_JOB_ACTION_UNKNOWN;
        m_JobState    = HSM_JOB_STATE_IDLE;
        m_JobPhase    = HSM_JOB_PHASE_MOVE_ACTION;

        m_WorkerThread = 0;

        m_WorkInProgress = FALSE;
        m_CurrentPath    = OLESTR("");

        // Set threshold defaults
        m_MinFilesToMigrate          =       100;
        m_MinBytesToMigrate          =  10000000;
        m_FilesBeforeCommit          =      2000;
        m_MaxBytesBeforeCommit       = 750000000;
        m_MinBytesBeforeCommit       =  10000000;
        m_FreeMediaBytesAtEndOfMedia =  10000000;
        m_MinFreeSpaceInFullMedia    =         4;
        m_MaxFreeSpaceInFullMedia    =         5;

        m_DataCountBeforeCommit  = 0;
        m_FilesCountBeforeCommit = 0;
        m_StoreDatabasesInBags = TRUE;

        m_QueueItemsToPause = 500;
        m_QueueItemsToResume = 450;
        m_ScannerPaused = FALSE;

        // Job abort on errors parameters
        m_JobAbortMaxConsecutiveErrors = 5;
        m_JobAbortMaxTotalErrors = 25;
        m_JobConsecutiveErrors = 0;
        m_JobTotalErrors = 0;
        m_JobAbortSysDiskSpace = 2 * 1024 * 1024;

        m_mediaCount = 0;
        m_ScratchFailed = FALSE;
        WSB_OBJECT_ADD(CLSID_CHsmWorkQueue, this);

    } WsbCatch(hr);

    icountWorkq++;
    WsbTraceOut(OLESTR("CHsmWorkQueue::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), icountWorkq);
    return(hr);
}

HRESULT
CHsmWorkQueue::FinalRelease(
    void
    )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  before destruction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalDestruct().

--*/
{
    HRESULT     hr = S_OK;
    HSM_SYSTEM_STATE SysState;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FinalRelease"),OLESTR(""));

    SysState.State = HSM_STATE_SHUTDOWN;
    ChangeSysState(&SysState);

    WSB_OBJECT_SUB(CLSID_CHsmWorkQueue, this);
    CComObjectRoot::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the
    // smart-pointer destructor is being called (as part of this object destruction)
    m_MediaName.Free();
    m_MediaBarCode.Free();
    m_RmsMediaSetName.Free();
    m_CurrentPath.Free();

    icountWorkq--;
    WsbTraceOut(OLESTR("CHsmWorkQueue::FinalRelease"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), icountWorkq);
    return(hr);
}

HRESULT
CHsmWorkQueue::Init(
    IUnknown                *pServer,
    IHsmSession             *pSession,
    IHsmFsaTskMgr           *pTskMgr,
    HSM_WORK_QUEUE_TYPE     queueType
    )
/*++
Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Init"),OLESTR(""));
    try  {
        //
        // Establish contact with the server and get the
        // databases
        //
        WsbAffirmHr(pServer->QueryInterface(IID_IHsmServer, (void **)&m_pServer));
        //We want a weak link to the server so decrement the reference count
        m_pServer->Release();

        m_pTskMgr = pTskMgr;
        m_pTskMgr->AddRef();
        m_QueueType = queueType;

        WsbAffirmHr(m_pServer->GetSegmentDb(&m_pSegmentDb));
        WsbAffirmHr(m_pServer->GetStoragePools(&m_pStoragePools));
        WsbAffirmHr(m_pServer->QueryInterface(IID_IWsbCreateLocalObject, (void **)&m_pHsmServerCreate));
        // We want a weak link to the server so decrement the reference count
        m_pHsmServerCreate->Release();
        WsbAffirmHr(m_pServer->GetID(&m_HsmId));

        WsbAffirmHr(CheckSession(pSession));

        //
        // Make a collection for the work items
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                       IID_IWsbIndexedCollection,
                                                       (void **)&m_pWorkToDo ));

        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                       IID_IWsbIndexedCollection,
                                                       (void **)&m_pWorkToCommit ));

        //
        // Make sure our connection to RMS is current
        //
        WsbAffirmHr(CheckRms());

        // Check the registry to see if there are changes to default settings
        CheckRegistry();

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );

}

HRESULT
CHsmWorkQueue::ContactOk(
    void
    )
/*++
Routine Description:

  This allows the caller to see if the RPC connection
  to the task manager is OK

Arguments:

  None.

Return Value:

  S_OK
--*/
{

    return( S_OK );

}

HRESULT
CHsmWorkQueue::ProcessSessionEvent(
    IHsmSession *pSession,
    HSM_JOB_PHASE phase,
    HSM_JOB_EVENT event
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CHsmWorkQueue::ProcessSessionEvent"),OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to us (MOVER or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_MOVE_ACTION == phase)) {

            switch(event) {

                case HSM_JOB_EVENT_SUSPEND:
                case HSM_JOB_EVENT_CANCEL:
                case HSM_JOB_EVENT_FAIL:
                    WsbAffirmHr(Cancel());
                    break;

                case HSM_JOB_EVENT_PAUSE:
                    WsbAffirmHr(Pause());
                    break;

                case HSM_JOB_EVENT_RESUME:
                    WsbAffirmHr(Resume());
                    break;

                case HSM_JOB_EVENT_RAISE_PRIORITY:
                    WsbAffirmHr(RaisePriority());
                    break;

                case HSM_JOB_EVENT_LOWER_PRIORITY:
                    WsbAffirmHr(LowerPriority());
                    break;

                default:
                case HSM_JOB_EVENT_START:
                    WsbAssert(FALSE, E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ProcessSessionEvent"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );

}


HRESULT
CHsmWorkQueue::ProcessSessionState(
    IHsmSession* /*pSession*/,
    IHsmPhase* pPhase,
    OLECHAR* /*currentPath*/
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    HRESULT         hr = S_OK;
    HSM_JOB_PHASE   phase;
    HSM_JOB_STATE   state;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ProcessSessionState"),OLESTR(""));
    try  {

        WsbAffirmHr(pPhase->GetState(&state));
        WsbAffirmHr(pPhase->GetPhase(&phase));
        WsbTrace( OLESTR("CHsmWorkQueue::ProcessSessionState - State = <%d>, phase = <%d>\n"), state, phase );

        if ( HSM_JOB_PHASE_SCAN == phase ) {

            // If the session has finished, then we have some cleanup to do so that it can go
            // away.
            if ((state == HSM_JOB_STATE_DONE) || (state == HSM_JOB_STATE_FAILED) || (state == HSM_JOB_STATE_SUSPENDED) ) {
                WsbTrace( OLESTR("Job is done, failed, or suspended\n") );
                // Create a work item and append it to the work queue to
                // indicate that the job is done
                WsbAffirmHr(MarkQueueAsDone());
            }
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::ProcessSessionState"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );

}


HRESULT
CHsmWorkQueue::Add(
    IFsaPostIt *pFsaWorkItem
    )
/*++

Implements:

  IHsmFsaTskMgr::Add

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pSession;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Add"),OLESTR(""));
    try  {
        //
        // Make sure there is a work allocater for this session
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(CheckSession(pSession));

        //
        // Create a work item, load it up and add it to this
        // Queue's collection
        //
        CComPtr<IHsmWorkItem>   pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkItem, IID_IHsmWorkItem,
                                                        (void **)&pWorkItem));
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_WORK));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));

        //
        // If adding this item to the queue meets or exceeds the count for pausing
        // pause the scanner so there is no more work submitted.
        //
        ULONG numItems;
        WsbAffirmHr(m_pWorkToDo->GetEntries(&numItems));
        WsbTrace(OLESTR("CHsmWorkQueue::Add - num items in queue = <%lu>\n"),numItems);
        if (numItems >= m_QueueItemsToPause)  {
            WsbAffirmHr(PauseScanner());
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Add"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::Start( void )
/*++

Implements:

  IHsmWorkQueue::Start

--*/
{
    HRESULT                     hr = S_OK;
    DWORD                       tid;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Start"),OLESTR(""));
    try  {
        //
        // If the worker thread is already started, just return
        //
        WsbAffirm(m_WorkerThread == 0, S_OK);
        // Launch a thread to do work that is queued
        WsbAffirm((m_WorkerThread = CreateThread(0, 0, HsmWorkQueueThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));

        if (m_WorkerThread == NULL) {
            WsbAssertHr(E_FAIL);  // TBD What error to return here??
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Start"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::Stop( void )
/*++

Implements:

  IHsmWorkQueue::Stop

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Stop"),OLESTR(""));

    //  Stop the thread
    if (m_WorkerThread) {
        TerminateThread(m_WorkerThread, 0);
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::Stop"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}



HRESULT
CHsmWorkQueue::PremigrateIt(
    IFsaPostIt *pFsaWorkItem
    )
{
    HRESULT                     hr = S_OK;
    GUID                        mediaToUse;
    GUID                        firstSide;
    BOOLEAN                     done = FALSE;
    FSA_PLACEHOLDER             placeholder;
    LONGLONG                    requestSize;
    LONGLONG                    requestStart;
    LONGLONG                    fileVersionId;

    WsbTraceIn(OLESTR("CHsmWorkQueue::PremigrateIt"),OLESTR(""));
    try  {
        //
        // Check to see if anything has changed since the request
        //
        WsbAffirmHr(CheckForChanges(pFsaWorkItem));

        // Check for sufficient space on system volume
        WsbAffirmHr(CheckForDiskSpace());

        //
        // Go to the Storage Pool and get the media set associated
        // with this data
        //
        WsbAffirmHr(GetMediaSet(pFsaWorkItem));

        //
        // Loop here to try to recover from certain types of errors
        //
        while (done == FALSE){
            CComPtr<IWsbIndexedCollection>  pMountingCollection;
            CComPtr<IMountingMedia>         pMountingMedia;
            CComPtr<IMountingMedia>         pMediaToFind;
            BOOL                            bMediaMounting = FALSE;
            BOOL                            bMediaMountingAdded = FALSE;
            BOOL                            bMediaChanged = FALSE;

            // Lock mounting media while searching for a media to use
            WsbAffirmHr(m_pServer->LockMountingMedias());

            // Find a media to use and set up interfaces to RMS
            try {
                WsbAffirmHr(FindMigrateMediaToUse(pFsaWorkItem, &mediaToUse, &firstSide, &bMediaChanged));

                // Check if the media-to-use have changed and is a non-scratch media
                if ((GUID_NULL != mediaToUse) && bMediaChanged) {

                    // Check if the media to mount is already mounting
                    WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                    WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                    WsbAffirmHr(pMediaToFind->SetMediaId(mediaToUse));
                    hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                    if (hr == S_OK) {
                        // Media is already mounting...
                        bMediaMounting = TRUE;
                        WsbAffirmHr(pMediaToFind->SetIsReadOnly(FALSE));

                    } else if (hr == WSB_E_NOTFOUND) {
                        // New media to mount - add to the mounting list
                        hr = S_OK;
                        WsbAffirmHr(pMediaToFind->Init(mediaToUse, FALSE));
                        WsbAffirmHr(pMountingCollection->Add(pMediaToFind));
                        bMediaMountingAdded = TRUE;

                    } else {
                        WsbAffirmHr(hr);
                    }
                }

            } WsbCatchAndDo(hr,
                    // Unlock mounting media
                    m_pServer->UnlockMountingMedias();

                    WsbTraceAlways(OLESTR("CHsmWorkQueue::PremigrateIt: error while trying to find/add mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hr));                                

                    // Bale out
                    WsbThrow(hr);
                );

            // Release the lock
            WsbAffirmHr(m_pServer->UnlockMountingMedias());

            // If the media is mounting - wait for the mount event
            if (bMediaMounting) {
                WsbAffirmHr(pMountingMedia->WaitForMount(INFINITE));
                pMountingMedia = 0;
            }

            // Mount the media. Ask for short timeout.
            hr = MountMedia(pFsaWorkItem, mediaToUse, firstSide, TRUE, TRUE);

            // If we added a mounting media to the list - remove it once the mount is done
            if (bMediaMountingAdded) {
                HRESULT hrRemove = S_OK;

                // No matter how the Mount finished - free waiting clients and remove from the list
                hrRemove = m_pServer->LockMountingMedias();
                WsbAffirmHr(hrRemove);

                try {
                    WsbAffirmHr(pMediaToFind->MountDone());
                    WsbAffirmHr(pMountingCollection->RemoveAndRelease(pMediaToFind));
                    pMediaToFind = 0;

                } WsbCatch(hrRemove);

                m_pServer->UnlockMountingMedias();

                // We don't expect any errors while removing the mounting media -
                // The thread that added to the collection is always the one that removes
                if (! SUCCEEDED(hrRemove)) {
                    WsbTraceAlways(OLESTR("CHsmWorkQueue::PremigrateIt: error while trying to remove a mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hrRemove));                                

                    WsbThrow(hrRemove);
                }
            }

            //   Check for job cancellation
            if (HSM_JOB_STATE_CANCELLING == m_JobState) {
                WsbThrow(HSM_E_WORK_SKIPPED_CANCELLED);
            }

            //
            // Process RMS errors
            //
            switch (hr) {
                case RMS_E_CARTRIDGE_NOT_FOUND: {
                    // If this media wasn't found, mark it as bad and try a different one
                    WsbAffirmHr(MarkMediaBad(pFsaWorkItem, m_MediaId, hr));
                    hr = S_OK;
                    continue;
                }

                case RMS_E_TIMEOUT:
                case HSM_E_NO_MORE_MEDIA:
                case RMS_E_CARTRIDGE_DISABLED:
                case HSM_E_MEDIA_NOT_AVAILABLE: {
                    // In all these cases, let FindMigrateMediaToUse try to find a different media
    				hr = S_OK;
	    			continue;
                }

                default: {
                    WsbAffirmHr(hr);
                }
            }

            //
            // Make sure the data has not been modified since the
            // FSA determined the migration request
            //
            hr = CheckForChanges(pFsaWorkItem);
            if (S_OK == hr)  {
                //
                // Build the source path
                //
                CWsbStringPtr tmpString;
                WsbAffirmHr(GetSource(pFsaWorkItem, &tmpString));
                CWsbBstrPtr localName = tmpString;
                //
                // Ask the Data mover to store the data
                //
                ULARGE_INTEGER localDataStart;
                ULARGE_INTEGER localDataSize;
                ULARGE_INTEGER remoteFileStart;
                ULARGE_INTEGER remoteFileSize;
                ULARGE_INTEGER remoteDataSetStart;
                ULARGE_INTEGER remoteDataStart;
                ULARGE_INTEGER remoteDataSize;
                ULARGE_INTEGER remoteVerificationData;
                ULONG          remoteVerificationType;
                ULARGE_INTEGER dataStreamCRC;
                ULONG          dataStreamCRCType;
                ULARGE_INTEGER usn;


                WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
                WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
                WsbAffirmHr(pFsaWorkItem->GetRequestOffset(&requestStart));
                WsbAffirmHr(pFsaWorkItem->GetFileVersionId(&fileVersionId));
                localDataStart.QuadPart = requestStart;
                localDataSize.QuadPart = requestSize;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRING, hr);
                // Make sure data mover is ready for work.
                WsbAffirmPointer(m_pDataMover);

                hr =  m_pDataMover->StoreData(  localName,
                                                localDataStart,
                                                localDataSize,
                                                MVR_FLAG_BACKUP_SEMANTICS | MVR_FLAG_POSIX_SEMANTICS,
                                                &remoteDataSetStart,
                                                &remoteFileStart,
                                                &remoteFileSize,
                                                &remoteDataStart,
                                                &remoteDataSize,
                                                &remoteVerificationType,
                                                &remoteVerificationData,
                                                &dataStreamCRCType,
                                                &dataStreamCRC,
                                                &usn);
                WsbTrace(OLESTR("StoreData returned hr = <%ls>\n"),WsbHrAsString(hr));
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRED, hr);

                if (S_OK == hr)  {

                    //  Save the offset on the tape of the data set if we
                    //  don't have it; confirm it if we do
                    if (0 == m_RemoteDataSetStart.QuadPart) {
                        m_RemoteDataSetStart = remoteDataSetStart;
                    } else {
                        WsbAssert(m_RemoteDataSetStart.QuadPart ==
                                remoteDataSetStart.QuadPart,
                                WSB_E_INVALID_DATA);
                    }

                    //
                    // Fill in the placeholder data
                    //
                    placeholder.bagId = m_BagId;
                    placeholder.hsmId = m_HsmId;
                    placeholder.fileStart = remoteFileStart.QuadPart;
                    placeholder.fileSize = remoteFileSize.QuadPart;
                    placeholder.dataStart = remoteDataStart.QuadPart;
                    placeholder.dataSize = remoteDataSize.QuadPart;
                    placeholder.verificationData = remoteVerificationData.QuadPart;
                    placeholder.verificationType = remoteVerificationType;
                    placeholder.fileVersionId = fileVersionId;
                    placeholder.dataStreamCRCType = dataStreamCRCType;
                    placeholder.dataStreamCRC = dataStreamCRC.QuadPart;
                    WsbAffirmHr(pFsaWorkItem->SetPlaceholder(&placeholder));
                    WsbAffirmHr(pFsaWorkItem->SetUSN(usn.QuadPart));

                    //
                    // Update media information
                    WsbAffirmHr(GetMediaParameters());

                    done = TRUE;
                } else {
                    switch (hr) {

                    case MVR_E_END_OF_MEDIA:
                    case MVR_E_DISK_FULL:
                        //
                        // We have run out of disk space so mark the media full
                        // and try again
                        //
                        // To really cleanup, we should remove the portion
                        // written  TBD
                        //
                        WsbAffirmHr(MarkMediaFull(pFsaWorkItem, m_MediaId));
                        mediaToUse = GUID_NULL;
                        break;

                    case MVR_E_MEDIA_ABORT:
                        //
                        // Media is most likely bad - mark it as such, then abort
                        //
                        WsbAffirmHr(MarkMediaBad(pFsaWorkItem, m_MediaId, hr));
                        done = TRUE;
                        break;

                    default:
                        // We failed the copy somehow.  Report this error.
                        done = TRUE;
                        break;
                    }
                }
            } else {
                done = TRUE;
            }
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::PremigrateIt"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmWorkQueue::RecallIt(
    IFsaPostIt *pFsaWorkItem
    )
{
    HRESULT                     hr = S_OK;
    GUID                        mediaToUse = GUID_NULL;
    CComPtr<IFsaScanItem>       pScanItem;
    LONGLONG                    readOffset;

    WsbTraceIn(OLESTR("CHsmWorkQueue::RecallIt"),OLESTR(""));
    try  {

        GetScanItem(pFsaWorkItem, &pScanItem);

        if ((m_RequestAction != FSA_REQUEST_ACTION_FILTER_READ) &&
            (m_RequestAction != FSA_REQUEST_ACTION_FILTER_RECALL))  {
            //
            // Non-demand recall - make sure the file has not changed
            //
            hr = CheckForChanges(pFsaWorkItem);
        } else {
            //
            // For demand recalls we have to assume the file has not changed since we
            // recall on the first read or write.
            //
            hr = S_OK; //CheckForChanges(pFsaWorkItem);
        }
        if ( S_OK == hr ) {
            CComPtr<IWsbIndexedCollection>  pMountingCollection;
            CComPtr<IMountingMedia>         pMountingMedia;
            CComPtr<IMountingMedia>         pMediaToFind;
            BOOL                            bMediaMounting = FALSE;
            BOOL                            bMediaMountingAdded = FALSE;
            BOOL                            bMediaChanged = FALSE;

            // Find the media that contains the file
            WsbAffirmHr(FindRecallMediaToUse(pFsaWorkItem, &mediaToUse, &bMediaChanged));

            if (bMediaChanged) {
                // Check if the media is already in the process of mounting
                WsbAffirmHr(m_pServer->LockMountingMedias());

                try {
                    // Check if the media to mount is already mounting
                    WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                    WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                    WsbAffirmHr(pMediaToFind->SetMediaId(mediaToUse));
                    hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                    if (hr == S_OK) {
                        // Media is already mounting...
                        bMediaMounting = TRUE;

                    } else if (hr == WSB_E_NOTFOUND) {
                        // New media to mount - add to the mounting list
                        hr = S_OK;
                        WsbAffirmHr(pMediaToFind->Init(mediaToUse, TRUE));
                        WsbAffirmHr(pMountingCollection->Add(pMediaToFind));
                        bMediaMountingAdded = TRUE;

                    } else {
                        WsbAffirmHr(hr);
                    }
                } WsbCatchAndDo(hr,
                    // Unlock mounting media
                    m_pServer->UnlockMountingMedias();

                    WsbTraceAlways(OLESTR("CHsmWorkQueue::RecallIt: error while trying to find/add mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hr));                                

                    // Bale out
                    WsbThrow(hr);
                );

                // Release the lock
                WsbAffirmHr(m_pServer->UnlockMountingMedias());
            }

            // If the media is mounting - wait for the mount event
            if (bMediaMounting) {
                WsbAffirmHr(pMountingMedia->WaitForMount(INFINITE));
                pMountingMedia = 0;
            }

            //
            // Get the media mounted (hr is checked only after removing from the mounting-media list)
            //
            hr = MountMedia(pFsaWorkItem, mediaToUse);

            // If added to the mounting list - remove
            if (bMediaMountingAdded) {
                HRESULT hrRemove = S_OK;

                // No matter how the Mount finished - free waiting clients and remove from the list
                hrRemove = m_pServer->LockMountingMedias();
                WsbAffirmHr(hrRemove);

                try {
                    WsbAffirmHr(pMediaToFind->MountDone());
                    WsbAffirmHr(pMountingCollection->RemoveAndRelease(pMediaToFind));
                    pMediaToFind = 0;

                } WsbCatch(hrRemove);

                m_pServer->UnlockMountingMedias();

                // We don't expect any errors while removing the mounting media -
                // The thread that added to the collection is always the one that removes
                if (! SUCCEEDED(hrRemove)) {
                    WsbTraceAlways(OLESTR("CHsmWorkQueue::RecallIt: error while trying to remove a mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hrRemove));                                

                    WsbThrow(hrRemove);
                }
            }

            //
            // Check the Mount result
            //
            WsbAffirmHr(hr);

            //
            // Copy the data
            //
            // Build the source path
            CWsbStringPtr tmpString;
            WsbAffirmHr(GetSource(pFsaWorkItem, &tmpString));
            CWsbBstrPtr localName = tmpString;
            // Ask the Data mover to store the data
            LONGLONG       requestSize;
            LONGLONG       requestStart;
            ULARGE_INTEGER localDataStart;
            ULARGE_INTEGER localDataSize;
            ULARGE_INTEGER remoteFileStart;
            ULARGE_INTEGER remoteFileSize;
            ULARGE_INTEGER remoteDataStart;
            ULARGE_INTEGER remoteDataSize;
            ULARGE_INTEGER remoteVerificationData;
            ULONG          remoteVerificationType;

            FSA_PLACEHOLDER             placeholder;
            WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
            WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
            WsbAffirmHr(pFsaWorkItem->GetRequestOffset(&requestStart));

            //
            // Build strings
            //
            CWsbBstrPtr sessionName = HSM_BAG_NAME;
            CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;
            sessionName.Append(WsbGuidAsString(m_BagId));
            sessionDescription.Append(WsbGuidAsString(m_HsmId));

            localDataStart.QuadPart = requestStart;
            localDataSize.QuadPart = requestSize;
            remoteFileStart.QuadPart = placeholder.fileStart;
            remoteFileSize.QuadPart = placeholder.fileSize;
            remoteDataStart.QuadPart = placeholder.dataStart;
            remoteDataSize.QuadPart = placeholder.dataSize;
            remoteVerificationData.QuadPart = placeholder.verificationData;
            remoteVerificationType = placeholder.verificationType;


            ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRING, hr);

            CComPtr<IStream> pLocalStream;
            CComPtr<IStream> pRemoteStream;
            ULARGE_INTEGER offset, read, written;
            DWORD   verifyType;


            if ((m_RequestAction == FSA_REQUEST_ACTION_FILTER_READ) ||
                (m_RequestAction == FSA_REQUEST_ACTION_FILTER_RECALL))  {
                //
                // We are doing a read without recall, so get the
                // recall object's data mover
                //
                CComPtr<IFsaFilterRecall> pRecall;
                WsbAffirmHr(pFsaWorkItem->GetFilterRecall(&pRecall));
                WsbAffirmHr(pRecall->CreateLocalStream( &pLocalStream));
                WsbAffirmHr(pRecall->GetSize( (LONGLONG *) &remoteDataSize.QuadPart ));
                WsbAffirmHr(pRecall->GetOffset( &readOffset ));
                if (readOffset == 0) {
                    verifyType = MVR_VERIFICATION_TYPE_HEADER_CRC;
                } else {
                    verifyType = MVR_VERIFICATION_TYPE_NONE;
                }
            } else  {
                //
                // We are doing a file recall (not a demand recall) so get the FSA data mover
                //
                verifyType = MVR_VERIFICATION_TYPE_HEADER_CRC;
                readOffset = 0;
                WsbAffirmPointer(pScanItem);
                WsbAffirmHr(pScanItem->CreateLocalStream( &pLocalStream ) );
            }

            //
            // Create remote data mover stream
            // TEMPORARY: Consider removing the NO_CACHING flag for a NO_RECALL recall
            //

            WsbAssert(0 != m_RemoteDataSetStart.QuadPart, HSM_E_BAD_SEGMENT_INFORMATION);
            WsbAffirmHr( m_pDataMover->CreateRemoteStream(
                CWsbBstrPtr(L""),
                MVR_MODE_READ | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_NO_CACHING,
                sessionName,
                sessionDescription,
                m_RemoteDataSetStart,
                remoteFileStart,
                remoteFileSize,
                remoteDataStart,
                remoteDataSize,
                verifyType,
                remoteVerificationData,
                &pRemoteStream ) );

            //
            // The offset given here is the offset into the stream itself (readOffset).  
            // The actual position on remote media will be the bag start plus the file start
            // plus the file-data start (all given in CreateRemoteStream) plus this offset.
            //
            WsbTrace(OLESTR("Setting offset to %I64d reading %I64u\n"), readOffset, remoteDataSize.QuadPart);

            offset.QuadPart = readOffset;
            WsbAffirmHr( m_pDataMover->SetInitialOffset( offset ) );

            //
            // Once the remote stream has been created we must make sure we detach it
            //

            try {

                WsbAffirmHr( pRemoteStream->CopyTo( pLocalStream, remoteDataSize, &read, &written ) );
                WsbAffirmHr( pLocalStream->Commit( STGC_DEFAULT ) );

                //
                // The CopyTo succeeded... make sure we got all the bytes
                // we asked for.
                //
                // If we attempt to read from a incomplete Master that
                // does not contain the migrated data we'll fail here with
                // MVR_S_NO_DATA_DETECTED.
                //
                WsbAffirm( written.QuadPart == remoteDataSize.QuadPart, HSM_E_VALIDATE_DATA_NOT_ON_MEDIA );

                WsbAffirmHr( m_pDataMover->CloseStream() );
            } WsbCatchAndDo(hr,
                WsbAffirmHr( m_pDataMover->CloseStream() );
                );

            ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRED, hr);
            WsbTrace(OLESTR("RecallData returned hr = <%ls>\n"),WsbHrAsString(hr));
        } else {
            //
            // The file has changed or is not in the correct state
            //
            WsbTrace(OLESTR("The file has changed between asking for the recall and the actual recall\n"));
            WsbAffirmHr( hr );
        }

    } WsbCatch( hr );

    // Tell the session whether or not the work was done.
    // We don't really care about the return code, there is nothing
    // we can do if it fails.
    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
    if (pScanItem) {
        m_pSession->ProcessItem(m_JobPhase, m_JobAction, pScanItem, hr);
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::RecallIt"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}



HRESULT
CHsmWorkQueue::validateIt(
    IFsaPostIt *pFsaWorkItem
    )
/*

Routine Description:

    This Engine internal helper method is used to validate a scan item which has a
    reparse point (found by the FSA during a resource scan).

    When this method gets control it already knows the resource (e.g., volume) it is
    operating against by virtue of the work queue being tied to a volume.  The PostIt
    object whose interface pointer has been passed into this method is tied to a
    specific scan item (e.g.,file).  So on call this method knows both the resource
    and scan item it is validating.

    Validating a file with a reparse point on it means verifying that this file's info
    is properly contained in the HSM databases and that the file's bag is contained on
    its master secondary storage media.

    After getting basic info (the resource id and the file's placeholder info), the method
    first verifies that the placeholder's bag is contained in the Bag Info Table.  If so,
    the file's segment is then verified as being contained in the Segment Table.  Providing
    it is, the master media id contained in the Segment Table record is verified as
    being contained in the Media Info Table.  Finally the Remote Data Set (bag) the file
    belongs to is verified as being contained on the master media.

    If any of the above verifications fail the PostIt object is marked to request a
    Result Action of 'Validate Bad' from the FSA, and the PostIt is sent back to the
    FSA to perform that action.  (Validate Bad action means that a file in a Premigrated
    state will have its placeholder removed, changing it to a normal (unmanaged) file,
    and a Truncated file will be deleted.)

    If the file validates up to this point, then the PostIt is marked accordingly (which
    will cause the FSA to update the Premigrated/Truncated stats as appropriate) and a
    couple of final checks are made.  First, if the resource the file is presently on
    does not agree with the resource stored in the Bag Info Table record (meaning
    the reparsed file was moved without being recalled, e.g., backing up the file and
    restoring it to another volume), an entry is added to the Volume Assignment Table.
    Secondly, if the file is present in the Bag Hole Table (meaning it has been deleted)
    it is removed from there.

Arguments:

    pFsaWorkItem - Interface pointer to the PostIt object initiated by the FSA.  The
            PostIt object correlates to a specific scan item.

Return Value:

    S_OK - The call succeeded (the specified scan item was validated, and the appropriate
            result action was filled into the PostIt, which will be sent back to the
            FSA for action).

    Any other value - The call failed in one of the embedded Remote Storage API calls.
            The result will be specific to the call that failed.

*/

{
    HRESULT                         hr = S_OK;
    GUID                            l_BagVolId;
    GUID                            resourceId;
    LONGLONG                        l_FileStart = 0;
    FSA_PLACEHOLDER                 placeholder;
    CWsbStringPtr                   path;
    CComQIPtr<ISegDb, &IID_ISegDb>  pSegDb = m_pSegmentDb;
    CComPtr<IRmsServer>             pRmsServer;
    CComPtr<IRmsCartridge>          pMedia;
    GUID                            mediaSubsystemId;


    WsbTraceIn(OLESTR("CHsmWorkQueue::validateIt"),OLESTR(""));

    try  {

        memset(&placeholder, 0, sizeof(FSA_PLACEHOLDER));

        //
        // Get starting info and set hsm work queue object's bag id to that contained
        // in the scan item's placeholder
        //
        WsbAffirmHr( m_pFsaResource->GetIdentifier( &resourceId ));
        WsbAffirmHr( pFsaWorkItem->GetPlaceholder( &placeholder ));
        m_BagId = placeholder.bagId;
        l_FileStart = placeholder.fileStart;

        WsbAffirmHr( pFsaWorkItem->GetPath( &path, 0 ));
        WsbTrace( OLESTR("Beginning to validate <%s>.\n"), path );

        //
        // Make sure the segment is in the Segment Table (seek the segment record
        // whose keys (bag id, file start and file size) match what is in the placeholder).
        // Note: We need to start with this table since the real BAG is different for indirect segments.
        //
        CComPtr<ISegRec>            pSegRec;
        GUID                        l_BagId;
        LONGLONG                    l_FileSize;
        USHORT                      l_SegFlags;
        GUID                        l_PrimPos;
        LONGLONG                    l_SecPos;

        hr =  pSegDb->SegFind( m_pDbWorkSession, m_BagId, placeholder.fileStart,
                        placeholder.fileSize, &pSegRec );
        if (S_OK != hr )  {
            hr = HSM_E_VALIDATE_SEGMENT_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }


        // Segment is in the table.  Get segment record since we use l_PrimPos in next step
        WsbTrace( OLESTR("(validateIt) <%s> found in Segment table, continuing...\n"),
                                                path );
        WsbAffirmHr( pSegRec->GetSegmentRecord( &l_BagId, &l_FileStart, &l_FileSize,
                                                &l_SegFlags, &l_PrimPos, &l_SecPos ));

        //
        // In case of an indirect record, go to the dirtect record to get real location info
        //
        if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
            pSegRec = 0;

            hr = pSegDb->SegFind(m_pDbWorkSession, l_PrimPos, l_SecPos,
                                 placeholder.fileSize, &pSegRec);
            if (S_OK != hr )  {
                // We couldn't find the direct segment record for this segment!
                hr = HSM_E_VALIDATE_SEGMENT_NOT_FOUND;
                WsbAffirmHr(pFsaWorkItem->SetResult(hr));
                WsbThrow(hr);
            }

            WsbTrace( OLESTR("(validateIt) direct segment for <%s> found in Segment table, continuing...\n"), 
                       path );
            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, 
                                                  &l_SegFlags, &l_PrimPos, &l_SecPos));

            // Don't support a second indirection for now !!
            if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
                hr = HSM_E_BAD_SEGMENT_INFORMATION;
                WsbAffirmHr(pFsaWorkItem->SetResult(hr));
                WsbThrow(hr);
            }

            // Change Bag id to the real one
            m_BagId = l_BagId;
        }

        //
        // Make sure the BAG ID is in the Bag Info Table (get the Bag Info Table
        // (entity) in the Segment database, set the key value (bag id) to that
        // contained in the placeholder and get that record.  If found, the Bag
        // is in the Bag Info Table).
        //
        CComPtr<IBagInfo>           pBagInfo;
        FILETIME                    l_BirthDate;
        HSM_BAG_STATUS              l_BagStatus;
        LONGLONG                    l_BagLen;
        USHORT                      l_BagType;
        LONGLONG                    l_DeletedBagAmount;
        SHORT                       l_RemoteDataSet;

        WsbAffirmHr( m_pSegmentDb->GetEntity( m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE,
                                            IID_IBagInfo, (void**)&pBagInfo ));

        GetSystemTimeAsFileTime(&l_BirthDate);
        WsbAffirmHr( pBagInfo->SetBagInfo( HSM_BAG_STATUS_IN_PROGRESS, m_BagId,
                                            l_BirthDate, 0, 0, GUID_NULL, 0, 0 ));
        hr = pBagInfo->FindEQ();
        if (S_OK != hr )  {
            hr = HSM_E_VALIDATE_BAG_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }

        // Bag is in the table.  Trace, then get bag record since we will use some
        // info later (l_RemoteDataSet, l_BagVolId).
        WsbTrace( OLESTR("(validateIt) <%s> found in Bag Info table, continuing...\n"),
                                        path );
        WsbAffirmHr( pBagInfo->GetBagInfo( &l_BagStatus, &l_BagId, &l_BirthDate,
                                        &l_BagLen, &l_BagType, &l_BagVolId,
                                        &l_DeletedBagAmount, &l_RemoteDataSet ));

        //
        // Make sure the media is in the Media Info table (get Media Info Table, set
        // the key (media id) to what is in the Segment record and get the record).
        // Note that for Sakkara the Primary Position field in the Segment record
        // (l_PrimPos) contains the id (GUID) of the media where the bag/segment is stored.
        //
        CComPtr<IMediaInfo>         pMediaInfo;

        WsbAffirmHr( m_pSegmentDb->GetEntity( m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE,
                                            IID_IMediaInfo, (void**)&pMediaInfo ));
        WsbAffirmHr( pMediaInfo->SetId( l_PrimPos ));
        hr =  pMediaInfo->FindEQ();
        if (S_OK != hr )  {
            hr = HSM_E_VALIDATE_MEDIA_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }

        WsbTrace( OLESTR("(validateIt) <%s> found in Media Info table, continuing...\n"),
                                            path );

        //
        // Media is in the Media Info Table.  Next step is to verify that the Remote Data
        // Set (in concept equal to a bag) containing this scan item (e.g., file) is
        // actually on the media.
        //
        SHORT                       l_MediaNextRemoteDataSet;

        WsbAffirmHr( pMediaInfo->GetNextRemoteDataSet( &l_MediaNextRemoteDataSet ));
        WsbTrace(
         OLESTR("(validateIt) <%ls>: Bag remote dataset <%hd> Media remote dataset <%hd>\n"),
                      (OLECHAR*)path, l_RemoteDataSet, l_MediaNextRemoteDataSet );
        if ( l_RemoteDataSet >= l_MediaNextRemoteDataSet ) {
            // Remote data set containing the item is not on the media; we have a validate
            // error, so set up to have FSA delete it
            hr = HSM_E_VALIDATE_DATA_NOT_ON_MEDIA;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbTrace( OLESTR("(validateIt) <%s>: remote data set not on media.\n"),
                      path );
            WsbThrow(hr);
        }

        //
        // Now verify that the media manager still knows about the media
        //
        WsbAffirmHr( pMediaInfo->GetMediaSubsystemId( &mediaSubsystemId ));

        if (m_pRmsServer->FindCartridgeById(mediaSubsystemId , &pMedia) != S_OK) {
             hr = HSM_E_VALIDATE_MEDIA_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }

    } WsbCatch( hr );

    //
    // If item failed to validate it has an invalid reparse point, tell FSA to remove it.
    //

    if (FAILED(hr)) {
        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_BAD ));
        WsbTrace(OLESTR("<%s> failed validation, result action = Validate Bad.\n"), path);
        // No logging done here.  Logging needs to be added to FSA (ProcessResult()).
        // Clean up hr for return (tell caller this method completed).
        hr = S_OK;

    // Item validated, tell the FSA and do final clean-up checks
    } else try {
        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_OK ));
        WsbTrace(OLESTR("<%s> passed validation, result action = Validate Ok.\n"), path);

        //
        // If the resource (volume) this item is on doesn't match that stored in the Bag
        // Info Table, add an entry to the Volume Assignment Table
        //
//
// Note: This code is commented out since nobody uses the Volume Assignment table.
//       See bug 159449 in "Windows Bugs" database for more details.
//        
//        if ( !IsEqualGUID( resourceId, l_BagVolId )) {
//            WsbAffirmHr( pSegDb->VolAssignAdd( m_pDbWorkSession, m_BagId, l_FileStart,
//                                               placeholder.fileSize, resourceId));
//            WsbTrace(OLESTR("(validateIt) <%s> volume mismatch. Entered in Vol Asgmnt Table\n"),
//                         path);
//        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::validateIt"), OLESTR("hr = <%ls>"),
                                                        WsbHrAsString(hr));
    return( hr );
}



HRESULT
CHsmWorkQueue::CheckForChanges(
    IFsaPostIt *pFsaWorkItem
    )
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckForChanges"),OLESTR(""));

    //
    // Validate that the file is still migratable.  Ask FSA
    // for the latest USN of the file.  If they match, then
    // file is migratable, otherwise it is not.  If it is
    // not change the FSA_RESULT_ACTION to FSA_RESULT_ACTION_NONE.
    // and quit.
    //

    try  {
        CComPtr<IFsaScanItem>      pScanItem;

        // Get a current scan item from the FSA for this work item
        hr = GetScanItem(pFsaWorkItem, &pScanItem);
        if (WSB_E_NOTFOUND == hr)  {
            //
            // We cannot find the file, so just return not OK
            //
            WsbThrow(S_FALSE);
        }

        //
        // Make sure we did not get some other kind of error.
        //
        WsbAffirmHr(hr);


        // Check to see that the file is in the correct
        // state to do the requested action
        //
        FSA_REQUEST_ACTION          workAction;
        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&workAction));
        switch (workAction)  {
            case FSA_REQUEST_ACTION_VALIDATE:
                //
                // No Checks required here
                //
                hr = S_OK;
                break;
            case FSA_REQUEST_ACTION_DELETE:
                //
                // Make it is still OK to delete the file
                //
                WsbAffirmHr(pScanItem->IsDeleteOK(pFsaWorkItem) );
                break;
            case FSA_REQUEST_ACTION_PREMIGRATE:
                //
                // Make sure the file is still manageable by asking the FSA
                //
                WsbAffirmHr(pScanItem->IsMigrateOK(pFsaWorkItem));
                break;
            case FSA_REQUEST_ACTION_FILTER_RECALL:
            case FSA_REQUEST_ACTION_RECALL:
                //
                // Make sure the file is recallable by asking the FSA
                //
                WsbAffirmHr(pScanItem->IsRecallOK(pFsaWorkItem));
                break;
            case FSA_REQUEST_ACTION_FILTER_READ:
                //
                // Cannot check for truncated because the file is open
                //
                hr = S_OK;
                break;
            default:
                hr = E_NOTIMPL;
                break;
        }
    } WsbCatch (hr)

    if (FSA_E_FILE_CHANGED == hr )  {
        hr = HSM_E_FILE_CHANGED;
    } else if (FSA_E_FILE_ALREADY_MANAGED == hr ) {
        hr = HSM_E_FILE_ALREADY_MANAGED;
    } else if (FSA_E_FILE_NOT_TRUNCATED == hr ) {
        hr = HSM_E_FILE_NOT_TRUNCATED;
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckForChanges"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}




HRESULT
CHsmWorkQueue::RaisePriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::RaisePriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_JobPriority) {

            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
                m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_HIGH;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
                m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_TIME_CRITICAL));
                m_JobPriority = HSM_JOB_PRIORITY_CRITICAL;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(m_JobPhase, m_JobPriority));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::RaisePriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::LowerPriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::LowerPriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_JobPriority) {
            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_IDLE));
                m_JobPriority = HSM_JOB_PRIORITY_IDLE;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
                m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_HIGH;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
                m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(m_JobPhase, m_JobPriority));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::LowerPriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}




HRESULT
CHsmWorkQueue::CheckRms(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckRms"),OLESTR(""));
    try {
        //
        // Make sure we can still talk to the RMS
        //
        if (m_pRmsServer != 0) {
            CWsbBstrPtr name;
            hr = m_pRmsServer->GetServerName( &name );
            if (hr != S_OK) {
                m_pRmsServer = 0;
                hr = S_OK;
            }
        }
        //
        // Get RMS that runs on this machine
        //
        if (m_pRmsServer == 0)  {
            WsbAffirmHr(m_pServer->GetHsmMediaMgr(&m_pRmsServer));

            // wait for RMS to come ready
            // (this may not be needed anymore - if Rms initialization is
            //  synced with Engine initialization)
            CComObject<CRmsSink> *pSink = new CComObject<CRmsSink>;
            WsbAffirm(0 != pSink, E_OUTOFMEMORY);
            CComPtr<IUnknown> pSinkUnk = pSink; // holds refcount for use here
            WsbAffirmHr( pSink->Construct( m_pRmsServer ) );
            WsbAffirmHr( pSink->WaitForReady( ) );
            WsbAffirmHr( pSink->DoUnadvise( ) );
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckRms"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmWorkQueue::CheckSession(
    IHsmSession *pSession
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckSession"),OLESTR(""));
    try {

        if ((m_pSession != 0) && (m_pSession != pSession))  {
            //Don't expect this queue guy to switch sessions
            WsbTrace(OLESTR("Not Switching sessions at this time so we are failing.\n"));
            WsbThrow( E_UNEXPECTED );
        }

        //
        // Check to see if we have dealt with this or any other session before.
        if (m_pSession == 0)  {
            WsbTrace(OLESTR("New session.\n"));
            //
            // We have no on going session so we need to establish communication
            // with this session.
            //
            CComPtr<IHsmSessionSinkEveryState>  pSinkState;
            CComPtr<IHsmSessionSinkEveryEvent>  pSinkEvent;
            CComPtr<IConnectionPointContainer>  pCPC;
            CComPtr<IConnectionPoint>           pCP;

            // Tell the session we are starting up.
            m_JobState = HSM_JOB_STATE_STARTING;
            WsbTrace(OLESTR("Before Process State.\n"));
            WsbAffirmHr(pSession->ProcessState(m_JobPhase, m_JobState, m_CurrentPath, bLog));
            WsbTrace(OLESTR("After Process State.\n"));

            // Get the interface to the callback that the sessions should use.
            WsbTrace(OLESTR("Before QI's for sinks.\n"));
            WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSinkState));
            WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSinkEvent));
            WsbTrace(OLESTR("After QI's for sinks.\n"));
            // Ask the session to advise of every state changes.
            WsbTrace(OLESTR("Before QI for connection point containers.\n"));
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
            WsbAffirmHr(pCP->Advise(pSinkState, &m_StateCookie));
            pCP = 0;
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(pCP->Advise(pSinkEvent, &m_EventCookie));
            pCP = 0;
            WsbTrace(OLESTR("After Advises.\n"));

            //
            // Get the resource for this work from the session
            //
            WsbAffirmHr(pSession->GetResource(&m_pFsaResource));

            // Since this is a new session, reset the counter that has become our bag start
            // location
            m_RemoteDataSetStart.QuadPart = 0;

            m_JobState = HSM_JOB_STATE_ACTIVE;
            WsbTrace(OLESTR("Before Process State.\n"));
            WsbAffirmHr(pSession->ProcessState(m_JobPhase, m_JobState, m_CurrentPath, bLog));
            WsbTrace(OLESTR("After Process State.\n"));
            m_pSession = pSession;

        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::StartNewBag(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>           pBagInfo;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StartNewBag"),OLESTR(""));
    try {
        if (0 == m_RemoteDataSetStart.QuadPart)  {
            //
            // Get a new ID
            //
            WsbAffirmHr(CoCreateGuid(&m_BagId));

            // Add an entry into the Bag Info Table
            FILETIME                birthDate;
            GUID                    resourceId;

            WsbAffirmHr(m_pFsaResource->GetIdentifier(&resourceId));

            WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                    (void**)&pBagInfo));
            GetSystemTimeAsFileTime(&birthDate);

//??? what is the type for this bag? Need a define for Primary bag and Reorg bag
            WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, m_BagId, birthDate, 0, 0, resourceId, 0, 0));
            WsbAffirmHr(pBagInfo->MarkAsNew());
            WsbAffirmHr(pBagInfo->Write());
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::StartNewBag"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}



HRESULT
CHsmWorkQueue::UpdateBagInfo(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>       pBagInfo;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    FSA_PLACEHOLDER         placeholder;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateBagInfo"),OLESTR(""));
    try {
        //
        // Get the Bag id from the work item.  It is in the placeholder
        // information in the postit
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));

        //
        // Go to the Bag Info database and get the bag for this work
        //
        FILETIME                pDummyFileTime;

        GetSystemTimeAsFileTime(&pDummyFileTime);

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                (void**)&pBagInfo));
        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, placeholder.bagId, pDummyFileTime, 0, 0, GUID_NULL, 0, 0 ));
        WsbAffirmHr(pBagInfo->FindEQ());

        // Update the bag Info table - mostly just change the size of the bag
        FILETIME                birthDate;
        USHORT                  bagType;
        GUID                    bagVolId;
        LONGLONG                bagLength;
        LONGLONG                requestSize;
        LONGLONG                deletedBagAmount;
        SHORT                   remoteDataSet;
        HSM_BAG_STATUS          bagStatus;
        GUID                    bagId;

        WsbAffirmHr(pBagInfo->GetBagInfo(&bagStatus, &bagId, &birthDate,  &bagLength, &bagType, &bagVolId, &deletedBagAmount, &remoteDataSet));
        WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
        bagLength += requestSize;
        WsbAffirmHr(pBagInfo->SetBagInfo(bagStatus, bagId, birthDate, bagLength, bagType, bagVolId, deletedBagAmount, remoteDataSet));
        WsbAffirmHr(pBagInfo->Write());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateBagInfo"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);


}

HRESULT
CHsmWorkQueue::CompleteBag( void )
/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>           pBagInfo;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CompleteBag"),OLESTR(""));
    try {
        //
        // Go to the Bag Info database and get the bag for this work
        //
        FILETIME                pDummyFileTime;

        GetSystemTimeAsFileTime(&pDummyFileTime);

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                (void**)&pBagInfo));
        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, m_BagId, pDummyFileTime, 0, 0, GUID_NULL, 0, 0 ));
        WsbAffirmHr(pBagInfo->FindEQ());

        // Update the bag Info table - mostly just change the size of the bag
        FILETIME                birthDate;
        USHORT                  bagType;
        GUID                    bagVolId;
        LONGLONG                bagLength;
        LONGLONG                deletedBagAmount;
        SHORT                   remoteDataSet;
        HSM_BAG_STATUS          bagStatus;
        GUID                    bagId;

        WsbAffirmHr(pBagInfo->GetBagInfo(&bagStatus, &bagId, &birthDate,  &bagLength, &bagType, &bagVolId, &deletedBagAmount, &remoteDataSet));
        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_COMPLETED, bagId, birthDate, bagLength, bagType, bagVolId, deletedBagAmount, remoteDataSet));
        WsbAffirmHr(pBagInfo->Write());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::CompleteBag"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);


}

HRESULT
CHsmWorkQueue::DoWork( void )
/*++


--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    CComPtr<IHsmWorkItem>   pWorkItem;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    CComPtr<IHsmSession>    pSaveSessionPtr;
    HSM_WORK_ITEM_TYPE      workType;
    BOOLEAN                 done = FALSE;
    BOOLEAN                 OpenedDb = FALSE;
    HRESULT                 skipWork = S_FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::DoWork"),OLESTR(""));

    //  Make sure this object isn't released (and our thread killed
    //  before finishing up in this routine
    ((IUnknown*)(IHsmWorkQueue*)this)->AddRef();

    try {
        while (!done) {
            BOOL WaitForMore = FALSE;

            //
            // Get the next work to do from the queue
            //
            hr = m_pWorkToDo->First(IID_IHsmWorkItem, (void **)&pWorkItem);
            if (WSB_E_NOTFOUND == hr)  {
                // There are no entries in the queue so sleep and check
                // again later
                WaitForMore = TRUE;
                hr = S_OK;
            } else if (hr == S_OK)  {
                hr = CheckMigrateMinimums();
                if (S_FALSE == hr) {
                    WaitForMore = TRUE;
                    hr = S_OK;
                }
            }
            WsbAffirmHr(hr);

            if (WaitForMore) {
                if (OpenedDb) {
                    //
                    // Close the db before we wait for more work
                    //
                    hr = m_pSegmentDb->Close(m_pDbWorkSession);
                    OpenedDb = FALSE;
                    m_pDbWorkSession = 0;
                }
                Sleep(1000);
            } else {
                if (!OpenedDb)  {
                    //
                    // Open DB for this thread
                    //
                    hr = m_pSegmentDb->Open(&m_pDbWorkSession);
                    if (S_OK == hr)  {
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Database Opened OK\n"));
                        OpenedDb = TRUE;
                    } else  {
                        //
                        // We cannot open the database - this is a catastrophic
                        // problem.  So skip all work in the queue
                        //
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Database Opened failed with hr = <%ls>\n"), WsbHrAsString(hr));
                        skipWork = HSM_E_WORK_SKIPPED_DATABASE_ACCESS;
                        hr = S_OK;
                    }
                }

                WsbAffirmHr(pWorkItem->GetWorkType(&workType));
                switch (workType) {
                    case HSM_WORK_ITEM_FSA_DONE: {
                        BOOL    bNoDelay = FALSE;   // whether to dismount immediately

                        //
                        // There is no more work to do for this queue
                        //
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - FSA WORK DONE\n"));

                        //
                        // Finish any work that needs to be committed
                        // Mark the bag as complete if we are premigrating
                        //
                        if (HSM_JOB_ACTION_PREMIGRATE == m_JobAction)  {
                            try  {
                                WsbAffirmHr(CommitWork());
                                WsbAffirmHr(CompleteBag());
                                //
                                // Now save the databases at the end of the bag
                                // But make sure the begin session was OK.
                                // Note: even if there were errors while storing the data, we still want to try 
                                // keeping the databases on the media, because some files were migrated
                                //
                                if (m_StoreDatabasesInBags && (S_OK == m_BeginSessionHr)) {
                                    WsbAffirmHr(StoreDatabasesOnMedia());
                                }
                            } WsbCatch( hr );

                            // In case of premigrate - dismount immediately
                            bNoDelay = TRUE;
                        }

                        if (HSM_E_WORK_SKIPPED_CANCELLED == skipWork)  {
                            //
                            // Let them know we are cancelled
                            //
                            (void)SetState(HSM_JOB_STATE_CANCELLED);
                        } else  {
                            (void)SetState(HSM_JOB_STATE_DONE);
                        }
                        pSaveSessionPtr = m_pSession;
                        Remove(pWorkItem);

                        EndSessions(FALSE, bNoDelay);

                        // Close the DB
                        if (OpenedDb) {
                            WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Closing the database\n"));
                            m_pSegmentDb->Close(m_pDbWorkSession);
                            OpenedDb = FALSE;
                            m_pDbWorkSession = 0;
                        }
                        m_pTskMgr->WorkQueueDone(pSaveSessionPtr, m_QueueType, NULL);
                        done = TRUE;
                        break;
                    }

                    case HSM_WORK_ITEM_FSA_WORK: {
                        if (S_FALSE == skipWork)  {
                            //
                            // Get the FSA Work Item and do the work
                            //
                            hr = DoFsaWork(pWorkItem);
                            if (hr == RPC_E_DISCONNECTED) {
                              //
                              // This is a problem case. This means the FSA has done away with 
                              // the recall. We would not be able process this recall any more.
                              // Just bail out.
                              //
                              WsbLogEvent(HSM_MESSAGE_ABORTING_RECALL_QUEUE,
                                            0, NULL,NULL);
                              //
                              // Indicate we're done
                              //
                              (void)SetState(HSM_JOB_STATE_DONE);
                              pSaveSessionPtr = m_pSession;
                              Remove(pWorkItem);
                             // Clear out any remaining items in the queue.
                              do {
                                  hr = m_pWorkToDo->First(IID_IHsmWorkItem, (void **)&pWorkItem)  ;
                                  if (hr == S_OK) {
                                      Remove(pWorkItem);
                                  }
                              } while (hr == S_OK);

                              EndSessions(FALSE, FALSE);

                              //
                              // Close the DB
                              //
                              if (OpenedDb) {
                                  WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Closing the database\n"))  ;
                                  m_pSegmentDb->Close(m_pDbWorkSession);
                                  OpenedDb = FALSE;
                                  m_pDbWorkSession = 0;
                              }

                              //
                              // Finish with the queue & get out
                              //
                              m_pTskMgr->WorkQueueDone(pSaveSessionPtr, m_QueueType, NULL);
                              done = TRUE;
                          } else {
                              (void)Remove(pWorkItem);
                          }
                        } else  {
                            //
                            // Skip the work
                            //
                            try  {
                                CComPtr<IFsaScanItem>    pScanItem;

                                WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                                WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));

                                WsbAffirmHr(pFsaWorkItem->GetRequestAction(&m_RequestAction));
                                if ((m_RequestAction == FSA_REQUEST_ACTION_FILTER_RECALL) ||
                                    (m_RequestAction ==  FSA_REQUEST_ACTION_FILTER_READ) ||
                                    (m_RequestAction ==  FSA_REQUEST_ACTION_RECALL))  {
                                        hr = pFsaWorkItem->SetResult(skipWork);
                                        if (S_OK == hr)  {
                                            WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
                                            hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                                            WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                                        }
                                    }

                                // Avoid logging errors if job is just cancelled
                                if (HSM_E_WORK_SKIPPED_CANCELLED != skipWork) {
                                    (void)m_pSession->ProcessHr(m_JobPhase, 0, 0, hr);
                                }

                                WsbAffirmHr(m_pSession->ProcessItem(m_JobPhase,
                                        m_JobAction, pScanItem, skipWork));

                            } WsbCatch( hr );

                            (void)Remove(pWorkItem);
                        }
                        break;
                    }

                    case HSM_WORK_ITEM_MOVER_CANCELLED: {
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Mover Cancelled\n"));
                        try  {
                            //
                            // We are cancelled, so skip all of the rest of the
                            // work in the queue
                            //
                            WsbAffirmHr(MarkQueueAsDone());
                            //
                            // Remove the cancelled work item
                            //
                            Remove(pWorkItem);
                            //
                            // Skip any other work to do
                            //
                            skipWork = HSM_E_WORK_SKIPPED_CANCELLED;

                        } WsbCatch( hr );
                        break;
                    }

                    default: {
                        hr = E_UNEXPECTED;
                        break;
                    }

                }
            }

            pSaveSessionPtr = 0;
            pWorkItem = 0;
            pFsaWorkItem = 0;
        }

    } WsbCatch( hr );

    if (OpenedDb) {
        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Closing the database\n"));
        m_pSegmentDb->Close(m_pDbWorkSession);
        OpenedDb = FALSE;
        m_pDbWorkSession = 0;
    }

    // Pretend everything is OK
    hr = S_OK;

    //  Release the thread (the thread should terminate on exit
    //  from the routine that called this routine)
    CloseHandle(m_WorkerThread);
    m_WorkerThread = 0;

    //  Allow this object to be released
    ((IUnknown*)(IHsmWorkQueue*)this)->Release();

    WsbTraceOut(OLESTR("CHsmWorkQueue::DoWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::DoFsaWork(
    IHsmWorkItem *pWorkItem
)
/*++


--*/
{
    HRESULT                 hr = S_OK;
    HRESULT                 workHr = S_OK;
    HRESULT                 originalHr = S_OK;

    CWsbStringPtr           path;
    FSA_RESULT_ACTION       resultAction;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    LONGLONG                requestSize;

    WsbTraceIn(OLESTR("CHsmWorkQueue::DoFsaWork"),OLESTR(""));
    try {
        CComPtr<IFsaScanItem>   pScanItem;

        //
        // Do the work.
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        try {
            WsbAffirmHr(pFsaWorkItem->GetRequestAction(&m_RequestAction));
            WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
            WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));
        } WsbCatchAndDo (hr,
                originalHr = hr;

                // Not-found error is expected if the file was renamed or deleted after 
                // the FSA scanning. There is no need to log an error.
                if (hr != WSB_E_NOTFOUND) {
                    if (path == NULL){
                        WsbLogEvent(HSM_MESSAGE_PROCESS_WORK_ITEM_ERROR,
                            sizeof(m_RequestAction), &m_RequestAction, OLESTR("Path is NULL"),
                            WsbHrAsString(hr), NULL);
                    } else {
                        WsbLogEvent(HSM_MESSAGE_PROCESS_WORK_ITEM_ERROR,
                            sizeof(m_RequestAction), &m_RequestAction, (WCHAR *)path,
                            WsbHrAsString(hr), NULL);
                    }
                }

                // Report back to FSA on the error unless the error indiactes 
                // lost of connection with FSA.
                if (hr != RPC_E_DISCONNECTED) {
                    hr = pFsaWorkItem->SetResult(hr);
                    if (hr != RPC_E_DISCONNECTED) {
                        hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                    }
                }
            );

        if (originalHr != S_OK) {
            goto my_try_exit;
        }

        WsbTrace(OLESTR("Handling file <%s>.\n"), WsbAbbreviatePath(path, 120));
        switch (m_RequestAction) {
            case FSA_REQUEST_ACTION_DELETE:
                m_JobAction = HSM_JOB_ACTION_DELETE;
                hr = E_NOTIMPL;
                break;
            case FSA_REQUEST_ACTION_PREMIGRATE:
                m_JobAction = HSM_JOB_ACTION_PREMIGRATE;
                WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
                workHr = PremigrateIt(pFsaWorkItem);
                //
                // Fill in the work item, placeholder information in
                // postit is set by premigrate code.
                //
                WsbAffirmHr(pWorkItem->SetResult(workHr));
                if (S_OK == workHr)  {
                    WsbAffirmHr(pWorkItem->SetMediaInfo(m_MediaId, m_MediaUpdate, m_BadMedia,
                                                        m_MediaReadOnly, m_MediaFreeSpace, m_RemoteDataSet));
                    WsbAffirmHr(pWorkItem->SetFsaResource(m_pFsaResource));
                    //
                    // Copy the work item to the work in waiting queue
                    //
                    WsbAffirmHr(CopyToWaitingQueue(pWorkItem));
                    if (S_OK == TimeToCommit())  {
                        workHr = CommitWork();
                    }
                } else  {
                    WsbTrace(OLESTR("Failed premigrate work.\n"));
                    if (pScanItem)   {
                        WsbAffirmHr(m_pSession->ProcessItem(m_JobPhase,
                                m_JobAction, pScanItem, workHr));
                    }

                    //
                    // An item that was changed while waiting to be migrated is not really an error -
                    // the item is just skipped. Change hr here to avoid unnecessary error message 
                    // and unnecessary count as error in ShouldJobContinue                    
                    //
                    if (HSM_E_FILE_CHANGED == workHr) {
                        workHr = S_OK;
                    }
                }
                break;
            case FSA_REQUEST_ACTION_FILTER_RECALL:
            case FSA_REQUEST_ACTION_FILTER_READ:
            case FSA_REQUEST_ACTION_RECALL:
                m_JobAction = HSM_JOB_ACTION_RECALL;
                workHr = RecallIt(pFsaWorkItem);
                //
                // Tell the recaller right away about the success or failure
                // of the recall, we do this here so the recall filter can
                // release the open as soon as possible
                //
                hr = pFsaWorkItem->SetResult(workHr);
                if (S_OK == hr)  {
                    WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
                    hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                    WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                }
                break;
            case FSA_REQUEST_ACTION_VALIDATE:
                m_JobAction = HSM_JOB_ACTION_VALIDATE;
                workHr = validateIt(pFsaWorkItem);
                if (S_OK == workHr)  {
                    WsbAffirmHr(pFsaWorkItem->GetResultAction(&resultAction));
                    if (FSA_RESULT_ACTION_NONE != resultAction)  {
                        WsbTrace(OLESTR("HSM validate complete, calling FSA\n"));
                        hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                        WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                    }
                }
                //
                // Tell the session whether or not the work was done.
                //
                // For validate, we may not have a scan item
                //
                if (pScanItem)     {
                    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
                    m_pSession->ProcessItem(m_JobPhase, m_JobAction, pScanItem, workHr);
                } else {
                    WsbTrace(OLESTR("Couldn't get scan item for validation.\n"));
                }
                break;
            case FSA_REQUEST_ACTION_VALIDATE_FOR_TRUNCATE: {
                HRESULT truncateHr = S_OK;

                m_JobAction = HSM_JOB_ACTION_VALIDATE;
                workHr = validateIt(pFsaWorkItem);
                if (S_OK == workHr)  {
                    WsbAffirmHr(pFsaWorkItem->GetResultAction(&resultAction));
                    if (resultAction == FSA_RESULT_ACTION_VALIDATE_BAD) {
                        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD ));
                        resultAction = FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD;
                    }
                    if (resultAction == FSA_RESULT_ACTION_VALIDATE_OK) {
                        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK ));
                        resultAction = FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK;
                    }

                    if (FSA_RESULT_ACTION_NONE != resultAction)  {
                        WsbTrace(OLESTR("HSM validate for truncate complete, calling FSA\n"));
                        hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                        WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));

                        if (resultAction == FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK) {
                            // Analyze result of truncation: for expected errors, such as file-changed, set to S_FALSE
                            // in order to signal skipping, otherwize leave original error/success code
                            switch (hr) {
                                case FSA_E_ITEMCHANGED:
                                case FSA_E_ITEMINUSE:
                                case FSA_E_NOTMANAGED:
                                case FSA_E_FILE_ALREADY_MANAGED:
                                    truncateHr = S_FALSE;
                                    break;
                                default:
                                    truncateHr = hr;
                                    break;
                            }
                        } else if (resultAction == FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD) {
                            // Set truncateHr to S_FALSE to signal for skipping this file in regards to truncation
                            truncateHr = S_FALSE;
                        }
                    }
                }
                //
                // Tell the session whether or not the work was done.
                //
                // For validate, we may not have a scan item
                //
                if (pScanItem)     {
                    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
                    //
                    // For validate, the work-hr is always set to OK, therefore report on the truncate-hr instead
                    //
                    m_pSession->ProcessItem(m_JobPhase, m_JobAction, pScanItem, truncateHr);
                } else {
                    WsbTrace(OLESTR("Couldn't get scan item for validation.\n"));
                }
                break;
                }

            default:
                m_JobAction = HSM_JOB_ACTION_UNKNOWN;
                hr = E_NOTIMPL;
                break;
            }

        if (S_OK != workHr)  {
            // Tell the session how things went if they didn't go well.
            (void) m_pSession->ProcessHr(m_JobPhase, 0, 0, workHr);
        }

        //
        // Now, evaluate the work result to see if we should fail the job.
        //
        (void)ShouldJobContinue(workHr);

        my_try_exit:
        ;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::DoFsaWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmWorkQueue::UpdateMetaData(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    transactionBegun = FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateMetaData"),OLESTR(""));
    try {
        //
        // Start transaction
        //
        WsbAffirmHr(m_pDbWorkSession->TransactionBegin());
        transactionBegun = TRUE;

        //
        // Update the various metadata records
        //
        WsbAffirmHr(UpdateBagInfo(pWorkItem));
        WsbAffirmHr(UpdateSegmentInfo(pWorkItem));
        WsbAffirmHr(UpdateMediaInfo(pWorkItem));

        //
        // End transaction
        //
        WsbAffirmHr(m_pDbWorkSession->TransactionEnd());
        transactionBegun = FALSE;

    } WsbCatchAndDo( hr, if (transactionBegun == TRUE)  {m_pDbWorkSession->TransactionCancel();});

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateMetaData"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::UpdateSegmentInfo(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateSegmentInfo"),OLESTR(""));
    try {
        // Add a record to the segment database or extend an existing one
        CComQIPtr<ISegDb, &IID_ISegDb> pSegDb = m_pSegmentDb;
        BOOLEAN                 done = FALSE;
        FSA_PLACEHOLDER         placeholder;
        CComPtr<IFsaPostIt>     pFsaWorkItem;

        //
        // Get the placeholder information from the postit in the work item
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
        WsbAssert(0 != m_RemoteDataSetStart.QuadPart, WSB_E_INVALID_DATA);

        WsbTrace(OLESTR("Adding SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                    WsbGuidAsString(placeholder.bagId),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileStart)),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));
        WsbAffirmHr(pSegDb->SegAdd(m_pDbWorkSession, placeholder.bagId, placeholder.fileStart,
                placeholder.fileSize, m_MediaId, m_RemoteDataSetStart.QuadPart));

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateSegmentInfo"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::UpdateMediaInfo(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateMediaInfo"),OLESTR(""));
    try
    {
        LONGLONG                mediaCapacity;
        CComPtr<IFsaPostIt>     pFsaWorkItem;
        CComPtr<IMediaInfo>     pMediaInfo;
        GUID                    l_MediaId;          // HSM Engine Media ID
        FILETIME                l_MediaLastUpdate;  // Last update of copy
        HRESULT                 l_MediaLastError;   // S_OK or the last exception
                                                    // ..encountered when accessing
                                                    // ..the media
        BOOL                    l_MediaRecallOnly;  // True if no more data is to
                                                    // ..be premigrated to the media
                                                    // ..Set by internal operations,
                                                    // ..may not be changed externally
        LONGLONG                l_MediaFreeBytes;   // Real free space on media
        short                   l_MediaRemoteDataSet;
        HRESULT                 currentMediaLastError;

        //
        // Get the PostIt and the media information for the work item
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pWorkItem->GetMediaInfo(&l_MediaId, &l_MediaLastUpdate,
                            &l_MediaLastError, &l_MediaRecallOnly,
                            &l_MediaFreeBytes, &l_MediaRemoteDataSet));
        //
        // Update the media information with the name, used space, and free space of
        // the media.
        //
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));

        WsbAffirmHr(pMediaInfo->SetId(l_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->SetUpdate(l_MediaLastUpdate));
        WsbAffirmHr(pMediaInfo->SetFreeBytes(l_MediaFreeBytes));
        WsbAffirmHr(pMediaInfo->SetNextRemoteDataSet(l_MediaRemoteDataSet));

        // Avoid setting last error if the existing one already indicates an error
        WsbAffirmHr(pMediaInfo->GetLastError(&currentMediaLastError));
        if (SUCCEEDED(currentMediaLastError)) {
            WsbAffirmHr(pMediaInfo->SetLastError(l_MediaLastError));
        }

        // Mark the media as RecallOnly if it's mostly full (passed the high watermark level)
        WsbAffirmHr(pMediaInfo->GetCapacity(&mediaCapacity));
        if (l_MediaRecallOnly || (l_MediaFreeBytes < ((mediaCapacity * m_MaxFreeSpaceInFullMedia) / 100) )) {
            WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(TRUE));

            WsbTrace(OLESTR("CHsmWorkQueue::UpdateMediaInfo: Marking media as Recall Only - Capacity = %I64d, Free Bytes = %I64d\n"), 
                mediaCapacity, l_MediaFreeBytes);

/*** If we like to allocate immediately a second side of a full meida, than the code below should be completed...
            if (S_OK == m_pRmsServer->IsMultipleSidedMedia(m_RmsMediaSetId)) {

                // Check if second size is avalaible for allocation

                // Allocate (non-blocking) the second side

            }   ***/

        }
        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateMediaInfo"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::GetMediaSet(
    IFsaPostIt *pFsaWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    GUID                    storagePoolId;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetMediaSet"),OLESTR(""));
    try {
        CComPtr<IHsmStoragePool>    pStoragePool1;
        CComPtr<IHsmStoragePool>    pStoragePool2;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmStoragePool, IID_IHsmStoragePool,
                                                        (void **)&pStoragePool1));
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));
        WsbAffirmHr(pStoragePool1->SetId(storagePoolId));
        WsbAffirmHr(m_pStoragePools->Find(pStoragePool1, IID_IHsmStoragePool, (void **) &pStoragePool2));
        //
        // If the storage pool cannot be found, make it a meaningful message
        //
        m_RmsMediaSetName.Free();
        hr = pStoragePool2->GetMediaSet(&m_RmsMediaSetId, &m_RmsMediaSetName);
        if (S_OK != hr)  {
            hr = HSM_E_STG_PL_NOT_FOUND;
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetMediaSet"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::FindMigrateMediaToUse(
    IFsaPostIt *pFsaWorkItem,
    GUID       *pMediaToUse,
    GUID       *pFirstSideToUse,
    BOOL       *pMediaChanged
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse"),OLESTR(""));
    try {
        BOOLEAN                 found = FALSE;
        GUID                    mediaId;
        GUID                    storageId;
        GUID                    storagePoolId;
        CComPtr<IMediaInfo>     pMediaInfo;
        LONGLONG                requestSize;

        DWORD                   dwMediaCount= 0;

        // data of alternative (offline or busy) media to use
        GUID                    alternativeMediaId = GUID_NULL;
        GUID                    alternativeMediaToUse = GUID_NULL;
        CWsbStringPtr           alternativeMediaName;
        HSM_JOB_MEDIA_TYPE      alternativeMediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
        SHORT                   alternativeRemoteDataSet= 0;

        // data of meida candidates for second-side allocation
        BOOL                    bTwoSidedMedias = FALSE;
        CComPtr<IWsbCollection> pFirstSideCollection;
        CComPtr<IWsbGuid>       pFirstSideGuid;
        GUID                    firstSideGuid;


        WsbAssert(pMediaToUse != 0, E_POINTER);
        *pMediaToUse = GUID_NULL;
        WsbAssert(pFirstSideToUse != 0, E_POINTER);
        *pFirstSideToUse = GUID_NULL;
        WsbAssert(pMediaChanged != 0, E_POINTER);
        *pMediaChanged = FALSE;

        // Determine how much space we need on the media for this file
        // (we add some for overhead)
        WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
        requestSize += HSM_STORAGE_OVERHEAD;
        WsbTrace(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse: size needed (with overhead) =%ls, free space on media = %ls\n"),
                WsbQuickString(WsbLonglongAsString(requestSize)),
                WsbQuickString(WsbLonglongAsString(m_MediaFreeSpace)));

        // Set up for search
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));

        // If we already have media mounted, use it if possible
        if (GUID_NULL != m_MountedMedia && !m_MediaReadOnly && 
            (m_MediaFreeSpace > requestSize) && 
            ((m_MediaFreeSpace - requestSize) > ((m_MediaCapacity * m_MinFreeSpaceInFullMedia) / 100)) ) {

            // Make sure the storage pool is correct
            WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
            WsbAffirmHr(pMediaInfo->FindEQ());
            WsbAffirmHr(pMediaInfo->GetStoragePoolId(&storageId));
            if ((storageId == storagePoolId)) {
                found = TRUE;
            }
        }

        if (!found) {
            // Not found ==> going to use a new media
            *pMediaChanged = TRUE;

            // If there's currently a mounted media and we aren't going to use it, 
            // make sure work is committed and media is dismounted
            if (GUID_NULL != m_MountedMedia) {
                WsbTrace(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse: Dismounting current media - Capacity = %I64d, Free Bytes = %I64d\n"), 
                    m_MediaCapacity, m_MediaFreeSpace);

                WsbAffirmHr(CommitWork());
                WsbAffirmHr(DismountMedia(TRUE));
            }
        }

        // Search for a media
        if (!found) {
            LONGLONG            freeSpace;
            LONGLONG            mediaCapacity;
            BOOL                readOnly;
            HRESULT             hrLastError;
            BOOL                bDataForOffline = FALSE;

            // Check if we deal with two-sided medias
            if (S_OK == m_pRmsServer->IsMultipleSidedMedia(m_RmsMediaSetId)) {
                bTwoSidedMedias = TRUE;
                WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                    IID_IWsbCollection, (void **)&pFirstSideCollection));
            }

            // Search media table through all previously used media
            for (hr = pMediaInfo->First(); S_OK == hr;
                     hr = pMediaInfo->Next()) {

                // TEMPORARY - Just for debugging
                {
                    CWsbStringPtr   debugMediaName;
                    GUID            debugSubsystemId;
                    CHAR            *buff = NULL;
                    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&debugSubsystemId));
                    debugMediaName.Free();
                    WsbAffirmHr(pMediaInfo->GetDescription(&debugMediaName,0));
                    WsbTraceAlways(OLESTR("RANK: Checking media <%ls> <%ls>\n"),
                        WsbGuidAsString(debugSubsystemId), (WCHAR *)debugMediaName);
                    debugMediaName.CopyTo (&buff);
                    if (buff)
                        WsbFree(buff);
                }

                WsbAffirmHr(pMediaInfo->GetStoragePoolId(&storageId));
                WsbAffirmHr(pMediaInfo->GetFreeBytes(&freeSpace));
                WsbAffirmHr(pMediaInfo->GetRecallOnlyStatus(&readOnly));
                WsbAffirmHr(pMediaInfo->GetCapacity(&mediaCapacity));
                WsbAffirmHr(pMediaInfo->GetLastError(&hrLastError));
                WsbTrace( OLESTR("Looking for storagePool <%ls> and freeSpace <%ls>.\n"),
                        WsbGuidAsString(storagePoolId),
                        WsbLonglongAsString(requestSize));
                WsbTrace( OLESTR("Found media with storagePool <%ls>, freeSpace <%ls> and read only <%ls>.\n"),
                        WsbGuidAsString(storageId),
                        WsbLonglongAsString(freeSpace),
                        WsbBoolAsString(readOnly));

                // Reject media if it's ReadOnly or not from the right pool
                if ((readOnly && (hrLastError != S_OK)) || (storageId != storagePoolId)) {
                    continue;
                }

                // Check full & mostly full condition & free space 
                // Note: a medias which is read-only because  it's bad, is rejected in the previous if
                if (readOnly || (freeSpace <= requestSize) ||
                    ((freeSpace - requestSize) < ((mediaCapacity * m_MinFreeSpaceInFullMedia) / 100)) ) {

                    // in case of two-sided medias, such a media is candidate for second side allocation
                    if (bTwoSidedMedias) {
        			    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&firstSideGuid));
                        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbGuid, IID_IWsbGuid, (void**) &pFirstSideGuid));
                        WsbAffirmHr(pFirstSideGuid->SetGuid(firstSideGuid));
                        WsbAffirmHr(pFirstSideCollection->Add(pFirstSideGuid));
                        pFirstSideGuid = 0;
                    }

                    continue;
                }

                // get media status data
                DWORD dwStatus;
                GUID mediaSubsystemId;
				HRESULT hrStat;
			    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaSubsystemId));
				hrStat = m_pRmsServer->FindCartridgeStatusById(mediaSubsystemId ,&dwStatus);
				if (hrStat != S_OK) {
                    WsbTraceAlways(OLESTR("FindMigrateMediaToUse: Skipping media <%ls> (failed to retrieve its status)\n"),
                        WsbGuidAsString(mediaSubsystemId));
					continue;
				}

                // If media disabled - skip it
                if (!(dwStatus & RMS_MEDIA_ENABLED)) {
                    continue;
                }

                // From this point, the media is considered as a valid R/W media and should
                //  be counted as such
                dwMediaCount++;

                if ((dwStatus & RMS_MEDIA_ONLINE) && (dwStatus & RMS_MEDIA_AVAILABLE)) {
                    // Check if media is in the process of mounting: 
                    //  if so, it is also considered a busy media
                    CComPtr<IWsbIndexedCollection>  pMountingCollection;
                    CComPtr<IMountingMedia>         pMountingMedia;
                    CComPtr<IMountingMedia>         pMediaToFind;

                    // Lock mounting media while searching the collection
                    WsbAffirmHr(m_pServer->LockMountingMedias());

                    try {
                        WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                        WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                        WsbAffirmHr(pMediaToFind->SetMediaId(mediaSubsystemId));
                        hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                        if (hr == S_OK) {
                            // Media is mounting...

                            // Consider adding here a check for media type and reason for mounting:
                            //  If it's direct-access and mounting for read, it's not really busy
                            //
                            //  Problem: for already mounted media, we don't track the mount reason (read or write)
                            //  
                            // Also, one could argue that if we are below the concurrency limit, for better performance,
                            //  we better use a different media, even if it's a direct-access media mounted for read

                            dwStatus &= ~ RMS_MEDIA_AVAILABLE;
                            pMountingMedia = 0;

                        } else if (hr == WSB_E_NOTFOUND) {
                            hr = S_OK;
                        }

                    } WsbCatch(hr);

                    m_pServer->UnlockMountingMedias();

                    if (! SUCCEEDED(hr)) {
                        WsbTraceAlways(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse: Failed to check mounting media, hr= <%ls>\n"),
                                        WsbHrAsString(hr));
                    }
                }

                if ((dwStatus & RMS_MEDIA_ONLINE) && (dwStatus & RMS_MEDIA_AVAILABLE)) {
                    // found a media to use
                    found = TRUE;
                    break;
                } else {
                    // Save up to one offline or one busy media, because we may have to use it...
                    //  Priority is given to offline medias over busy medias.
                    if ((alternativeMediaId != GUID_NULL) && bDataForOffline) {
                        // Already Have best alternative media
                        continue;
                    }
                    if ((alternativeMediaId != GUID_NULL) && (dwStatus & RMS_MEDIA_ONLINE)) {
                        // Media is busy, can't improve the alternative
                        continue;
                    }
                    // Determine which kind of alternative media are we saving
                    if (dwStatus & RMS_MEDIA_ONLINE) {
                        bDataForOffline = FALSE;
                    } else {
                        bDataForOffline = TRUE;
                    }

                    // Save data for alternative media
                    WsbAffirmHr(pMediaInfo->GetId(&alternativeMediaId));
                    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&alternativeMediaToUse));
                    alternativeMediaName.Free();
                    WsbAffirmHr(pMediaInfo->GetDescription(&alternativeMediaName,0));
                    WsbAffirmHr(pMediaInfo->GetType(&alternativeMediaType));
                    WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&alternativeRemoteDataSet));
                }

            }

            // If we fell out of the loop because we ran out of media
            // in our list, reset the HRESULT
            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            } else {
                WsbAffirmHr(hr);
            }
        }

        // If we found a media to use, save information
        if (found) {
            WsbAffirmHr(pMediaInfo->GetId(&mediaId));
            WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(pMediaToUse));
            if (mediaId != m_MediaId) {
                m_MediaId = mediaId;
                m_MediaName.Free();
                WsbAffirmHr(pMediaInfo->GetDescription(&m_MediaName,0));
                WsbAffirmHr(pMediaInfo->GetType(&m_MediaType));
                WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&m_RemoteDataSet));
            }
        //
        // If we didn't find a media to use, check whether we should
        //  1. Choose to allocate a second side of a full media (only for 2-sided medias)
        //  2. Clear the information so we'll get a new piece of media
        //  2. Return the id of an offline or busy R/W meida
        } else {
            
            if (bTwoSidedMedias) {
                try {
                    // Go over the candidates, look for one with valid and non-allocated second side
                    CComPtr<IWsbEnum>   pEnumIds;
                    GUID                secondSideGuid;
                    BOOL                bValid;

                    WsbAffirmHr(pFirstSideCollection->Enum(&pEnumIds));
                    for (hr = pEnumIds->First(IID_IWsbGuid, (void**) &pFirstSideGuid);
                         (hr == S_OK);
                         hr = pEnumIds->Next(IID_IWsbGuid, (void**) &pFirstSideGuid)) {

                        WsbAffirmHr(pFirstSideGuid->GetGuid(&firstSideGuid));
                        WsbAffirmHr(m_pRmsServer->CheckSecondSide(firstSideGuid, &bValid, &secondSideGuid));
                        if (bValid && (GUID_NULL == secondSideGuid)) {
                            // Found a valid & non-allocated second side - verify fisrt side status
                            DWORD status;
            				WsbAffirmHr(m_pRmsServer->FindCartridgeStatusById(firstSideGuid ,&status));
                            if ((status & RMS_MEDIA_ENABLED) && (status & RMS_MEDIA_ONLINE)) {
                                *pFirstSideToUse = firstSideGuid;
                                break;
                            }
                        }

                        pFirstSideGuid = 0;
                    }

                    if (hr == WSB_E_NOTFOUND) {
                        hr = S_OK;
                    }

                } WsbCatchAndDo(hr,
                        WsbTraceAlways(OLESTR("FindMigrateMediaToUse: Skipping search for second side allocation, hr=<%ls>\n"),
                                    WsbHrAsString(hr));
                        hr = S_OK;
                    );

            }  // if two sides

            // Get max number for R/W medias
            DWORD           dwMaxMedia;
            WsbAffirmHr(m_pServer->GetCopyFilesLimit(&dwMaxMedia));

            if ((*pFirstSideToUse != GUID_NULL) || (dwMediaCount < dwMaxMedia) || (alternativeMediaId == GUID_NULL)) {
                // Allowed to allocate a new piece of media OR no alternative media found OR second side found
                m_MediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
                WsbAffirmHr(BuildMediaName(&m_MediaName));
                m_MediaReadOnly = FALSE;
            } else {
                // Use the alternative (which is offline or busy) R/W media
                *pMediaToUse = alternativeMediaToUse;
                if (alternativeMediaId != m_MediaId) {
                    m_MediaId = alternativeMediaId;
                    m_MediaName.Free();
                    alternativeMediaName.CopyTo(&m_MediaName);
                    m_MediaType = alternativeMediaType;
                    m_RemoteDataSet = alternativeRemoteDataSet;
                }
            }
        }

        alternativeMediaName.Free();
        if (pFirstSideCollection) {
            WsbAffirmHr(pFirstSideCollection->RemoveAllAndRelease());
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::MountMedia(
    IFsaPostIt *pFsaWorkItem,
    GUID       mediaToMount,
    GUID       firstSide,
    BOOL       bShortWait,
    BOOL       bSerialize
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_MediaToMount = mediaToMount;
    CComPtr<IRmsDrive>      pDrive;
    CWsbBstrPtr             pMediaName;
    DWORD                   dwOptions = RMS_NONE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::MountMedia"),OLESTR("Display Name = <%ls>"), (WCHAR *)m_MediaName);
    try {
        // If we're switching tapes, dismount the current one
        if ((m_MountedMedia != l_MediaToMount) && (m_MountedMedia != GUID_NULL)) {
            WsbAffirmHr(DismountMedia());
        }

        // Ask RMS for short timeout, both for Mount and Allocate
        if (bShortWait) {
            dwOptions |= RMS_SHORT_TIMEOUT;
        }

        // Ask RMS to serialize mounts if required
        if (bSerialize) {
            dwOptions |= RMS_SERIALIZE_MOUNT;
        }

        if (l_MediaToMount == GUID_NULL) {
            CComPtr<IRmsCartridge>      pCartridge;
            CComPtr<IMediaInfo>         pMediaInfo;
            CWsbBstrPtr                 displayName;

            //
            // We are mounting scratch media so we provide the name and then need to find
            // out the type of what got mounted
            //
            WsbTrace( OLESTR("Mounting Scratch Media <%ls>.\n"), (WCHAR *)m_MediaName );
            displayName = m_MediaName;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTING, hr);
            LONGLONG freeSpace = 0; // 0 to select media in the pool of any capacity.
            hr = m_pRmsServer->MountScratchCartridge( &l_MediaToMount, m_RmsMediaSetId, firstSide, &freeSpace, 0, displayName, &pDrive, &m_pRmsCartridge, &m_pDataMover, dwOptions );
            hr = TranslateRmsMountHr(hr);
            if (FAILED(hr)) {
                m_ScratchFailed = TRUE;
            } else {
                m_ScratchFailed = FALSE;
            }

            WsbAffirmHr(hr);
            WsbTrace( OLESTR("Mount Scratch completed.\n") );
            m_MountedMedia = l_MediaToMount;

            //
            // Add a new Media
            //
            WsbAffirmHr(StartNewMedia(pFsaWorkItem));

            if (m_RequestAction == FSA_REQUEST_ACTION_PREMIGRATE)  {
                //
                // Start a new Bag to receive data
                //
                WsbAffirmHr(StartNewBag());

                //
                // Start a new session for the bag
                //
                WsbAffirmHr(StartNewSession());

                // Getting media parameters after we start a new session ensures updated data
                //  (No need to supply default free-space - if driver doesn't support this info,
                //   mover will set free space to capacity. This is what we want for new media).
                WsbAffirmHr(GetMediaParameters());
            }

            //
            // Now check the capacity of the media and the size of the
            // file to see if the file can even fit on this scratch
            // media.  If not, return the error.
            //
            LONGLONG                requestSize;
            WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));

            if ((requestSize  + HSM_STORAGE_OVERHEAD) > m_MediaCapacity) {
               WsbThrow( HSM_E_WORK_SKIPPED_FILE_TOO_BIG );
            }

        } else {
            if (m_MountedMedia != l_MediaToMount) {
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTING, hr);
                hr = m_pRmsServer->MountCartridge( l_MediaToMount, &pDrive, &m_pRmsCartridge, &m_pDataMover, dwOptions );
                hr = TranslateRmsMountHr(hr);
                //
                //  If failure is because cartridge is disabled, need to get media label to put in error.
                //
                if (hr == RMS_E_CARTRIDGE_DISABLED) {

                    // Since this is just to get label, if any of these functions fail,
                    // don't throw, error will simply have blank label.
                    //
                    CComPtr<IRmsCartridge>  pMedia;
                    HRESULT                 hrName;

                    hrName = m_pRmsServer->FindCartridgeById(l_MediaToMount , &pMedia);
                    if (hrName == S_OK) {
                        hrName = pMedia->GetName(&pMediaName);
                    }
                    if ((hrName != S_OK) || ((WCHAR *)pMediaName == NULL)) {
                        // Cannot get media name - set to blanks
                        pMediaName = L"";
                    }

                    WsbThrow(hr);
                }

                WsbAffirmHr(hr);
                m_MountedMedia = l_MediaToMount;
                WsbTrace( OLESTR("Mount completed.\n") );

                if (m_RequestAction == FSA_REQUEST_ACTION_PREMIGRATE)  {
                    //
                    // Start a new Bag since bags can't yet span media.
                    //
                    WsbAffirmHr(StartNewBag());

                    //
                    // Start a session
                    WsbAffirmHr(StartNewSession());
                }

                // Getting media parameters after we start a new session ensures updated data
                LONGLONG internalFreeSpace;
                WsbAffirmHr(GetMediaFreeSpace(&internalFreeSpace));
                WsbAffirmHr(GetMediaParameters(internalFreeSpace));
            }
        }
    } WsbCatchAndDo(hr,
            switch (hr) {
            case HSM_E_STG_PL_NOT_CFGD:
            case HSM_E_STG_PL_INVALID:
                FailJob();
                break;

            case RMS_E_CARTRIDGE_DISABLED:
                WsbLogEvent(HSM_MESSAGE_MEDIA_DISABLED, 0, NULL, pMediaName, NULL);
                break;

            default:
                break;
            }
        );

    WsbTraceOut(OLESTR("CHsmWorkQueue::MountMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::MarkMediaFull(
    IFsaPostIt* /*pFsaWorkItem*/,
    GUID        mediaId
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::MarkMediaFull"),OLESTR(""));
    try {
        //
        // Update the media database
        //

        CComPtr<IMediaInfo>     pMediaInfo;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(mediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        m_MediaReadOnly = TRUE;
        WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());

/*** If we like to allocate immediately a second side of a full meida, than the code below should be completed...

        if (S_OK == m_pRmsServer->IsMultipleSidedMedia(m_RmsMediaSetId)) {

            // Check if second size is avalaible for allocation

            // Allocate (non-blocking) the second side

        }   ***/

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::MarkMediaFull"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::MarkMediaBad(
    IFsaPostIt * /*pFsaWorkItem */,
    GUID        mediaId,
    HRESULT     lastError
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::MarkMediaBad"),OLESTR(""));
    try {
        //
        // Update the media database
        //

        CComPtr<IMediaInfo>     pMediaInfo;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(mediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->SetLastError(lastError));
        m_MediaReadOnly = TRUE;
        WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
        WsbAffirmHr(pMediaInfo->Write());

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::MarkMediaBad"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::FindRecallMediaToUse(
    IFsaPostIt *pFsaWorkItem,
    GUID       *pMediaToUse,
    BOOL       *pMediaChanged
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FindRecallMediaToUse"),OLESTR(""));
    try {
        WsbAssert(pMediaToUse != 0, E_POINTER);
        *pMediaToUse = GUID_NULL;
        WsbAssert(pMediaChanged != 0, E_POINTER);
        *pMediaChanged = FALSE;

        CComQIPtr<ISegDb, &IID_ISegDb> pSegDb = m_pSegmentDb;
        CComPtr<ISegRec>        pSegRec;
        GUID                    l_BagId;
        LONGLONG                l_FileStart;
        LONGLONG                l_FileSize;
        USHORT                  l_SegFlags;
        GUID                    l_PrimPos;
        LONGLONG                l_SecPos;
        GUID                    storagePoolId;
        FSA_PLACEHOLDER         placeholder;

        //
        // Go to the segment database to find out where the data
        // is located.
        //
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
        m_BagId = placeholder.bagId;
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));

        WsbTrace(OLESTR("Finding SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                            WsbGuidAsString(placeholder.bagId),
                            WsbStringCopy(WsbLonglongAsString(placeholder.fileStart)),
                            WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

        hr = pSegDb->SegFind(m_pDbWorkSession, placeholder.bagId, placeholder.fileStart,
                             placeholder.fileSize, &pSegRec);
        if (S_OK != hr)  {
            //
            // We couldn't find the segment record for this information!
            //
            hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
            WsbAffirmHr(hr);
        }
        WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
                            &l_PrimPos, &l_SecPos));
        WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

        //
        // In case of an indirect record, go to the dirtect record to get real location info
        //
        if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
            pSegRec = 0;

            WsbTrace(OLESTR("Finding indirect SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                    WsbGuidAsString(l_PrimPos), WsbStringCopy(WsbLonglongAsString(l_SecPos)),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

            hr = pSegDb->SegFind(m_pDbWorkSession, l_PrimPos, l_SecPos,
                                 placeholder.fileSize, &pSegRec);
            if (S_OK != hr)  {
                //
                // We couldn't find the direct segment record for this segment!
                //
                hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
                WsbAffirmHr(hr);
            }

            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
                                &l_PrimPos, &l_SecPos));
            WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

            // Don't support a second indirection for now !!
            WsbAssert(0 == (l_SegFlags & SEG_REC_INDIRECT_RECORD), HSM_E_BAD_SEGMENT_INFORMATION);
        }

        //
        // Go to the media database to get the media ID
        //
        CComPtr<IMediaInfo>     pMediaInfo;
        GUID                    l_RmsMediaId;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(l_PrimPos));
        hr = pMediaInfo->FindEQ();
        if (S_OK != hr)  {
            hr = HSM_E_MEDIA_INFO_NOT_FOUND;
            WsbAffirmHr(hr);
        }
        WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&l_RmsMediaId));

        //  If the current tape isn't the one ==> media changed
        if (m_MountedMedia != l_RmsMediaId) {
            *pMediaChanged = TRUE;
            //  If there is a current tape and it isn't the one, dismount it
            if (m_MountedMedia != GUID_NULL) {
                WsbAffirmHr(DismountMedia());
            }
        }

        m_RemoteDataSetStart.QuadPart = l_SecPos;
        *pMediaToUse = l_RmsMediaId;

        // Keep HSM id of mounted media
        m_MediaId = l_PrimPos;

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::FindRecallMediaToUse"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}




HRESULT
CHsmWorkQueue::GetSource(
    IFsaPostIt                  *pFsaWorkItem,
    OLECHAR                     **pSourceString
    )
/*++

Routine Description:

  This function builds the Source file name

Arguments:

  pFsaWorkItem - the item to be migrated
  pSourceString - the Source file name.

Return Value:

  S_OK

--*/
{
    HRESULT             hr = S_OK;

    CComPtr<IFsaResource>   pResource;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    CWsbStringPtr           path;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetSource"),OLESTR(""));
    try  {
        //
        // Get the real session pointer from the IUnknown
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirm(pSession != 0, E_POINTER);

        // First get the name of the resource from the session
        WsbAffirmHr(pSession->GetResource(&pResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));

        tmpString.Alloc(1000);
        WsbAffirmHr(pResource->GetPath(&tmpString, 0));
        tmpString.Append(&(path[1]));
        // tmpString.Prepend(OLESTR("\\\\?\\"));
        WsbAffirmHr(tmpString.GiveTo(pSourceString));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetSource"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::EndSessions(
    BOOL            done,
    BOOL            bNoDelay
)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::EndSessions"),OLESTR(""));
    try  {
        HRESULT dismountHr = S_OK;

        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IConnectionPoint>           pCP;

        //
        // Release resources: should be earlier in completion
        //
        dismountHr = DismountMedia(bNoDelay);

        // Tell the session that we don't want to be advised anymore.
        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
            WsbAffirmHr(pCP->Unadvise(m_StateCookie));
        } WsbCatch( hr );
        pCPC = 0;
        pCP = 0;
        m_StateCookie = 0;

        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(pCP->Unadvise(m_EventCookie));
        } WsbCatch( hr );
        pCPC = 0;
        pCP = 0;
        m_EventCookie = 0;

        if (done)  {
            try {
                WsbTrace( OLESTR("Telling Session Data mover is done\n") );
                WsbAffirmHr(SetState(HSM_JOB_STATE_DONE));
            } WsbCatch( hr );
        }

        m_pSession = 0;
        m_pFsaResource = 0;

        WsbAffirmHr(dismountHr);
        WsbAffirmHr(hr);

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::EndSessions"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}



HRESULT
CHsmWorkQueue::GetScanItem(
    IFsaPostIt *    pFsaWorkItem,
    IFsaScanItem ** ppIFsaScanItem
    )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetScanItem"),OLESTR(""));

    try  {
        WsbAffirmPointer(ppIFsaScanItem);
        WsbAffirm(!*ppIFsaScanItem, E_INVALIDARG);
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(m_pFsaResource->FindFirst(path, m_pSession, ppIFsaScanItem));

    } WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetScanItem"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}

HRESULT
CHsmWorkQueue::GetNumWorkItems (
    ULONG *pNumWorkItems
    )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetNumWorkItems"),OLESTR(""));


    try  {
        WsbAffirm(0 != pNumWorkItems, E_POINTER);
        *pNumWorkItems = 0;
        WsbAffirmHr(m_pWorkToDo->GetEntries(pNumWorkItems));
    } WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetNumWorkItems"),OLESTR("hr = <%ls>, NumItems = <%ls>"),
                WsbHrAsString(hr), WsbPtrToUlongAsString(pNumWorkItems));
    return( hr );
}

HRESULT
CHsmWorkQueue::GetCurrentSessionId (
    GUID *pSessionId
    )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;

    WsbTraceIn(OLESTR("CsmWorkQueue::GetCurrentSessionId"),OLESTR(""));
    try  {
        WsbAffirm(0 != pSessionId, E_POINTER);
        WsbAffirmHr(m_pSession->GetIdentifier(pSessionId));
    } WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetCurrentSessionId"),OLESTR("hr = <%ls>, Id = <%ls>"),
                WsbHrAsString(hr), WsbPtrToGuidAsString(pSessionId));
    return( hr );
}

DWORD HsmWorkQueueThread(
    void *pVoid
)

/*++


--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CHsmWorkQueue*) pVoid)->DoWork();

    CoUninitialize();
    return(hr);
}

HRESULT
CHsmWorkQueue::Pause(
    void
    )

/*++

Implements:

  CHsmWorkQueue::Pause().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Pause"), OLESTR(""));

    try {

        // If we are running, then suspend the thread.
        WsbAffirm((HSM_JOB_STATE_STARTING == m_JobState) ||
                (HSM_JOB_STATE_ACTIVE == m_JobState) ||
                (HSM_JOB_STATE_RESUMING == m_JobState), E_UNEXPECTED);
        oldState = m_JobState;
        WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSING));

        // if we are unable to suspend, then return to the former state.
        try {
            WsbAffirm(0xffffffff != SuspendThread(m_WorkerThread), HRESULT_FROM_WIN32(GetLastError()));
            WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSED));
        } WsbCatchAndDo(hr, SetState(oldState););

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(hr);
}


HRESULT
CHsmWorkQueue::Resume(
    void
    )

/*++

Implements:

  CHsmWorkQueue::Resume().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Resume"), OLESTR(""));
    try {

        // If we are paused, then suspend the thread.
        WsbAffirm((HSM_JOB_STATE_PAUSING == m_JobState) || (HSM_JOB_STATE_PAUSED == m_JobState), E_UNEXPECTED);

        // If we are running, then suspend the thread.

        oldState = m_JobState;
        WsbAffirmHr(SetState(HSM_JOB_STATE_RESUMING));

        // If we are unable to resume, then return to the former state.
        try {
            WsbAffirm(0xffffffff != ResumeThread(m_WorkerThread), HRESULT_FROM_WIN32(GetLastError()));
            WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));
        } WsbCatchAndDo(hr, SetState(oldState););

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::SetState(
    IN HSM_JOB_STATE state
    )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmWorkQueue:SetState"), OLESTR("state = <%ls>"), JobStateAsString( state ) );

    try {
        //
        // Change the state and report the change to the session.  Unless the current state is
        // failed then leave it failed.  Is is necessary because when this guy fails, it will
        // cancel all sessions so that no more work is sent in and so we will skip any queued work.
        // If the current state is failed, we don't need to spit out the failed message every time,
        // so we send ProcessState a false fullmessage unless the state is cancelled.
        //
        if (HSM_JOB_STATE_FAILED != m_JobState)  {
            m_JobState = state;
        }
		
		if ((HSM_JOB_STATE_FAILED == m_JobState) && (HSM_JOB_STATE_CANCELLED != state)) {
            bLog = FALSE;
        }

        WsbAffirmHr(m_pSession->ProcessState(m_JobPhase, m_JobState, m_CurrentPath, bLog));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::SetState"), OLESTR("hr = <%ls> m_JobState = <%ls>"), WsbHrAsString(hr), JobStateAsString( m_JobState ) );

    return(hr);
}

HRESULT
CHsmWorkQueue::Cancel(
    void
    )

/*++

Implements:

  CHsmWorkQueue::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Cancel"), OLESTR(""));
    try {

        WsbAffirmHr(SetState(HSM_JOB_STATE_CANCELLING));
        //
        // This needs to be prepended and the queue emptied out!
        //
        CComPtr<IHsmWorkItem>  pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkItem, IID_IHsmWorkItem,
                                                (void **)&pWorkItem));
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_MOVER_CANCELLED));
        WsbAffirmHr(m_pWorkToDo->Prepend(pWorkItem));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::FailJob(
    void
    )

/*++

Implements:

  CHsmWorkQueue::FailJob().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FailJob"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED));
        if (m_pSession != 0)  {
            WsbAffirmHr(m_pSession->Cancel( HSM_JOB_PHASE_ALL ));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::FailJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::PauseScanner(
    void
    )

/*++

Implements:

  CHsmWorkQueue::PauseScanner().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::PauseScanner"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        if (m_pSession != 0)  {
            WsbAffirmHr(m_pSession->Pause( HSM_JOB_PHASE_SCAN ));
            m_ScannerPaused = TRUE;
        } else  {
            //
            // We should never get here - this means we have been processing work but we
            // have no session established
            //
            WsbThrow(E_POINTER);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::PauseScanner"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::ResumeScanner(
    void
    )

/*++

Implements:

  CHsmWorkQueue::ResumeScanner().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ResumeScanner"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        if (m_pSession != 0)  {
            if (TRUE == m_ScannerPaused && HSM_JOB_STATE_ACTIVE == m_JobState)  {
                WsbAffirmHr(m_pSession->Resume( HSM_JOB_PHASE_SCAN ));
                m_ScannerPaused = FALSE;
            }
        } else  {
            //
            // We should never get here - this means we have been processing work but we
            // have no session established
            //
            WsbThrow(E_POINTER);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ResumeScanner"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

void
CHsmWorkQueue::ReportMediaProgress(
    HSM_JOB_MEDIA_STATE state,
    HRESULT             /*status*/
    )

/*++

Implements:

  CHsmWorkQueue::ReportMediaProgress().

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           mediaName;
    HSM_JOB_MEDIA_TYPE      mediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ReportMediaProgress"), OLESTR(""));
    try {

        // Report Progress but we don't really care if it succeeds.
        hr = m_pSession->ProcessMediaState(m_JobPhase, state, m_MediaName, m_MediaType, 0);
        hr = S_OK;
//      if (status != S_OK)  {
//              (void) m_pSession->ProcessHr(m_JobPhase, __FILE__, __LINE__, status);
//      }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ReportMediaProgress"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
}

HRESULT
CHsmWorkQueue::BuildMediaName(
    OLECHAR **pMediaName
    )

/*++

Implements:

  CHsmWorkQueue::BuildMediaName

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           tmpName;

    WsbTraceIn(OLESTR("CHsmWorkQueue::BuildMediaName"), OLESTR(""));
    try {
        ULONG len = 0;


        // Get the next media number only when last scratch mount succeeded
        //  (which means, either first time or we need a second media for the same queue)
        if (! m_ScratchFailed) {
            WsbAffirmHr(m_pServer->GetNextMedia(&m_mediaCount));
        }
        WsbAssert(0 != m_mediaCount, E_UNEXPECTED);

        // Use the base name from the registry if available
        WsbAffirmHr(m_MediaBaseName.GetLen(&len));
        if (len) {
            tmpName = m_MediaBaseName;
        } else {
            // Otherwise use the name of the HSM
            tmpName.Realloc(512);
            WsbAffirmHr(m_pServer->GetName(&tmpName));
            tmpName.Prepend("RS-");
        }
        tmpName.Append("-");
        tmpName.Append(WsbLongAsString(m_mediaCount));

        tmpName.GiveTo(pMediaName);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::BuildMediaName"), OLESTR("hr = <%ls>, name = <%ls>"), WsbHrAsString(hr),
                    WsbPtrToStringAsString(pMediaName));
    return(hr);
}



HRESULT
CHsmWorkQueue::GetMediaParameters( LONGLONG defaultFreeSpace )

/*++

Implements:

  CHsmWorkQueue::GetMediaParameters

Note:
  The defaultFreeSpace parameter is passed to the mover to maintain internally 
  media free space in case that the device doesn't provide this information.
  If the device supports reporting on free space, then this parameter has no affect.

--*/
{
    HRESULT                 hr = S_OK;
    LONG                    rmsCartridgeType;
    CWsbBstrPtr             barCode;


    WsbTraceIn(OLESTR("CHsmWorkQueue::GetMediaParameters"), OLESTR(""));
    try {
        //
        // Get some information about the media
        //
        LARGE_INTEGER tempFreeSpace;
        tempFreeSpace.QuadPart = defaultFreeSpace;
        WsbAffirmHr(m_pDataMover->GetLargestFreeSpace(&m_MediaFreeSpace, &m_MediaCapacity, 
                                        tempFreeSpace.LowPart, tempFreeSpace.HighPart));

        WsbAffirmHr(m_pRmsCartridge->GetType(&rmsCartridgeType));
        WsbAffirmHr(ConvertRmsCartridgeType(rmsCartridgeType, &m_MediaType));
        WsbAffirmHr(m_pRmsCartridge->GetName(&barCode));
        WsbAffirmHr(CoFileTimeNow(&m_MediaUpdate));
        m_MediaBarCode = barCode;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetMediaParameters"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::DismountMedia(BOOL bNoDelay)

/*++

Implements:

  CHsmWorkQueue::DismountMedia

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::DismountMedia"), OLESTR(""));
    try {
        if ((m_pRmsCartridge != 0) && (m_MountedMedia != GUID_NULL)) {
            //
            // End the session with the data mover.  If this doesn't work, report
            // the problem but continue with the dismount.
            //
            try  {
                if ((m_RequestAction == FSA_REQUEST_ACTION_PREMIGRATE) && (m_pDataMover != 0)) {
                    if (S_OK == m_BeginSessionHr)  {
                        //
                        // Don't do an end session if the Begin didn't work OK
                        //
                        m_BeginSessionHr = S_FALSE;
                        WsbAffirmHr(m_pDataMover->EndSession());

                        // Update media free space after all data has been written to the media
                        WsbAffirmHr(UpdateMediaFreeSpace());
                    }
                }
            } WsbCatchAndDo( hr,
                    WsbTraceAlways(OLESTR("CHsmWorkQueue::DismountMedia: End session or DB update failed, hr = <%ls>\n"), 
                            WsbHrAsString(hr));
                );

            //
            // Tell the session that we are dismounting media. Ignore any problems
            // with the reporting
            //
            (void )ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTING, S_OK);

            //
            // Dismount the cartridge and report progress
            //

            // !!! IMPORTANT NOTE !!!
            //
            // Must free Rms resources used before dismounting...
            //
            m_pRmsCartridge = 0;
            m_pDataMover    = 0;

            DWORD dwOptions = RMS_NONE;
            if (bNoDelay) {
                dwOptions |= RMS_DISMOUNT_DEFERRED_ONLY;
            }
            hr = m_pRmsServer->DismountCartridge(m_MountedMedia, dwOptions);
            (void) ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTED, hr);

            //
            // Clear out the knowledge of media that was just dismounted
            //
            WsbAffirmHr(UnsetMediaInfo());

            WsbAffirmHr(hr);
            WsbTrace( OLESTR("Dismount completed OK.\n") );
        } else  {
            WsbTrace( OLESTR("There is no media to dismount.\n") );
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::DismountMedia"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::ConvertRmsCartridgeType(
    LONG                rmsCartridgeType,
    HSM_JOB_MEDIA_TYPE  *pMediaType
    )

/*++

Implements:

  CHsmWorkQueue::ConvertRmsCartridgeType

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ConvertRmsCartridgeType"), OLESTR(""));
    try  {

        WsbAssert(0 != pMediaType, E_POINTER);

        switch (rmsCartridgeType)  {
            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                *pMediaType = HSM_JOB_MEDIA_TYPE_TAPE;
                break;
            case RmsMediaOptical:
            case RmsMediaMO35:
            case RmsMediaWORM:
            case RmsMediaCDR:
            case RmsMediaDVD:
                *pMediaType = HSM_JOB_MEDIA_TYPE_OPTICAL;
                break;
            case RmsMediaDisk:
                *pMediaType = HSM_JOB_MEDIA_TYPE_REMOVABLE_MAG;
                break;
            case RmsMediaFixed:
                *pMediaType = HSM_JOB_MEDIA_TYPE_FIXED_MAG;
                break;
            case RmsMediaUnknown:
            default:
                *pMediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
                break;
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::ConvertRmsCartridgeType"), OLESTR("hr = <%ls>"),
                WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::MarkQueueAsDone( void )

/*++

Implements:

  CHsmWorkQueue::MarkQueueAsDone

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmWorkQueue::MarkQueueAsDone"), OLESTR(""));
    try {
        // Create a work item and append it to the work queue to
        // indicate that the job is done
        CComPtr<IHsmWorkItem>  pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkItem, IID_IHsmWorkItem,
                                                    (void **)&pWorkItem));
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_DONE));
        WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::MarkQueueAsDone"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::CopyToWaitingQueue(
    IHsmWorkItem *pWorkItem
    )

/*++

Implements:

  CHsmWorkQueue::CopyToWaitingQueue

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    FSA_PLACEHOLDER         placeholder;


    WsbTraceIn(OLESTR("CHsmWorkQueue::CopyToWaitingQueue"), OLESTR(""));
    try {
        //
        // Append the work item to the end of the waiting queue
        //
        WsbAffirmHr(m_pWorkToCommit->Append(pWorkItem));

        //
        // If adding this item to the waiting queue triggers
        // then cause the commit
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));

        m_DataCountBeforeCommit += placeholder.fileSize;
        m_FilesCountBeforeCommit++;


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::CopyToWaitingQueue"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::CompleteWorkItem(
    IHsmWorkItem *pWorkItem
    )
{
    HRESULT                 hr = S_OK;

    CWsbStringPtr           path;
    FSA_RESULT_ACTION       resultAction;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    CComPtr<IFsaResource>   pFsaResource;
    FSA_REQUEST_ACTION      requestAction;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CompleteWorkItem"), OLESTR(""));
    try {
        //
        // Get the stuff
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pWorkItem->GetFsaResource(&pFsaResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&requestAction));
        WsbTrace(OLESTR("Completing work for <%s>.\n"), (OLECHAR *)path);

        //
        // Update the metadata - If this fails don't process
        // results.
        //
        WsbAffirmHr(UpdateMetaData(pWorkItem));

        //
        // Complete the work
        //
        WsbAffirmHr(pFsaWorkItem->GetResultAction(&resultAction));
        if ((resultAction != FSA_RESULT_ACTION_NONE)  &&
            (requestAction != FSA_REQUEST_ACTION_FILTER_RECALL) &&
            (requestAction != FSA_REQUEST_ACTION_FILTER_READ) &&
            (requestAction != FSA_REQUEST_ACTION_RECALL) ) {
            WsbTrace(OLESTR("HSM work item complete, calling FSA\n"));
            hr = pFsaResource->ProcessResult(pFsaWorkItem);
            WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));

            //
            // If the process results fails, find out if the reparse point has been written,
            // if not, put the file in the bag hole table.
            //
            if ( FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED == hr )  {
                //
                // Put the file in the bag hole table
                //
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CompleteWorkItem"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}

HRESULT
CHsmWorkQueue::TimeToCommit( void )
{
    HRESULT                 hr = S_OK;

    //  Call the other version since it has the trace in it
    hr = TimeToCommit(0, 0);
    return( hr );
}

HRESULT
CHsmWorkQueue::TimeToCommit(
    LONGLONG    numFiles,
    LONGLONG    amountOfData
    )
{
    HRESULT                 hr = S_FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::TimeToCommit"), OLESTR("numFiles = <%ls>, amountOfData = <%ls>"),
            WsbQuickString(WsbLonglongAsString(numFiles)), WsbQuickString(WsbLonglongAsString(amountOfData)));
    WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: m_DataCountBeforeCommit = %ls, ")
            OLESTR("m_FilesCountBeforeCommit = %ls, m_MediaFreeSpace = %ls\n"),
            WsbQuickString(WsbLonglongAsString(m_DataCountBeforeCommit)),
            WsbQuickString(WsbLonglongAsString(m_FilesCountBeforeCommit)),
            WsbQuickString(WsbLonglongAsString(m_MediaFreeSpace)));
    WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: m_MaxBytesBeforeCommit = %lu, m_MinBytesBeforeCommit = %lu\n"),
            m_MaxBytesBeforeCommit, m_MinBytesBeforeCommit);
    WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: m_FilesBeforeCommit = %lu, m_FreeMediaBytesAtEndOfMedia = %lu\n"),
            m_FilesBeforeCommit, m_FreeMediaBytesAtEndOfMedia);
    try {
        //
        // If we have enough data or enough files then say it is time

        // Check for lots of data written to media:
        if ((m_DataCountBeforeCommit + amountOfData) >= m_MaxBytesBeforeCommit) {
            WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: commit because enough data was written\n"));
            hr = S_OK;

        // Check for lots of files written
        } else if (((m_FilesCountBeforeCommit + numFiles) >= m_FilesBeforeCommit) &&
                ((m_DataCountBeforeCommit + amountOfData) >= m_MinBytesBeforeCommit)) {
            WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: commit because enough files were written\n"));
            hr = S_OK;

        // Check for shortage of space on the media
        } else if (((m_MediaFreeSpace - amountOfData) <= m_FreeMediaBytesAtEndOfMedia) &&
                ((m_DataCountBeforeCommit + amountOfData) >= m_MinBytesBeforeCommit))  {
            WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: commit because end of media is near\n"));
            hr = S_OK;
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::TimeToCommit"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmWorkQueue::CheckMigrateMinimums(void)

/*++

Routine Description:

  Check that there is enough work in the queue to start a migrate session.

Arguments:

  None.

Return Value:

  S_OK                         - There is enough to start a session,
           we hit the end of the queue, or this isn't a migrate queue.
  S_FALSE                      - There isn't enough yet.
  E_*                          - An error was encountered.

--*/
{
    HRESULT      hr = S_FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckMigrateMinimums"), OLESTR(""));

    // Only check if the session has not already started (or been attempted).
    if (S_FALSE != m_BeginSessionHr) {
        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: session already started\n"));
        hr = S_OK;
    } else {
        try {
            ULONG                   BytesOfData = 0;
            ULONG                   NumEntries;

            // Get the number of items in the queue
            WsbAffirmHr(m_pWorkToDo->GetEntries(&NumEntries));
            WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: size of queue = %lu, Min = %lu\n"),
                    NumEntries, m_MinFilesToMigrate);

            // If the queue is already large enough, don't check individual
            // items.
            if (NumEntries >= m_MinFilesToMigrate)  {
                WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: enough queue items\n"));
                hr = S_OK;
            } else {

                // Loop over the items in the queue
                for (ULONG i = 0; i < NumEntries; i++) {
                    CComPtr<IFsaPostIt>     pFsaWorkItem;
                    CComPtr<IHsmWorkItem>   pWorkItem;
                    FSA_REQUEST_ACTION      RequestAction;
                    LONGLONG                RequestSize;
                    HSM_WORK_ITEM_TYPE      workType;

                    WsbAffirmHr(m_pWorkToDo->At(i, IID_IHsmWorkItem,
                            (void **)&pWorkItem));
                    WsbAffirmHr(pWorkItem->GetWorkType(&workType));

                    // Check the type of work item
                    if (HSM_WORK_ITEM_FSA_WORK != workType) {
                        // Hit the end of the queue or some other unusual
                        // condition.  Allow processing of the queue.
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: non-standard work type\n"));
                        hr = S_OK;
                        break;
                    }

                    // Make sure this is a migrate queue.  (This assumes a queue
                    // doesn't contain different types of FSA requests.)
                    WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                    WsbAffirmHr(pFsaWorkItem->GetRequestAction(&RequestAction));
                    WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: RequestAction = %d\n"),
                            static_cast<int>(RequestAction));
                    if (FSA_REQUEST_ACTION_PREMIGRATE != RequestAction) {
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: item is not migrate\n"));
                        hr = S_OK;
                        break;
                    }

                    // Check for minimum amount of data
                    WsbAffirmHr(pFsaWorkItem->GetRequestSize(&RequestSize));
                    WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: RequestSize = %ls, Min = %lu\n"),
                            WsbLonglongAsString(RequestSize), m_MinBytesToMigrate);
                    if ((static_cast<LONGLONG>(BytesOfData) + RequestSize) >=
                            static_cast<LONGLONG>(m_MinBytesToMigrate)) {
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: enough data\n"));
                        hr = S_OK;
                        break;
                    } else {
                        BytesOfData += static_cast<ULONG>(RequestSize);
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: new BytesOfData = %lu\n"),
                                BytesOfData);
                    }
                }
            }
        } WsbCatch( hr );
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckMigrateMinimums"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}


HRESULT
CHsmWorkQueue::CheckRegistry(void)
{
    OLECHAR      dataString[100];
    HRESULT      hr = S_OK;
    ULONG        l_value;
    DWORD        sizeGot;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckRegistry"), OLESTR(""));

    try {
        // Minimum files to migrate
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_FILES_TO_MIGRATE,
                &m_MinFilesToMigrate));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinFilesToMigrate = %lu\n"),
                m_MinFilesToMigrate);

        // Minimum bytes to migrate
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_BYTES_TO_MIGRATE,
                &m_MinBytesToMigrate));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinBytesToMigrate = %lu\n"),
                m_MinBytesToMigrate);

        // Minimum files before commit
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_FILES_BEFORE_COMMIT,
                &m_FilesBeforeCommit));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_FilesBeforeCommit = %lu\n"),
                m_FilesBeforeCommit);

        // Maximum bytes before commit
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_BYTES_BEFORE_COMMIT,
                &m_MaxBytesBeforeCommit));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MaxBytesBeforeCommit = %lu\n"),
                m_MaxBytesBeforeCommit);

        // Minimum bytes before commit
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_BYTES_BEFORE_COMMIT,
                &m_MinBytesBeforeCommit));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinBytesBeforeCommit = %lu\n"),
                m_MinBytesBeforeCommit);

        // Bytes to perserve at end of tape (This is really just for security, we shouldn't reach this threshold at all)
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_BYTES_AT_END_OF_MEDIA,
                &m_FreeMediaBytesAtEndOfMedia));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_FreeMediaBytesAtEndOfMedia = %lu\n"),
                m_FreeMediaBytesAtEndOfMedia);

        // Minimum percent to preserve as free space in end of meida
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_FREE_SPACE_IN_FULL_MEDIA,
                &m_MinFreeSpaceInFullMedia));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinFreeSpaceInFullMedia = %lu\n"),
                m_MinFreeSpaceInFullMedia);

        // Maximum percent to preserve as free space in end of meida
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_FREE_SPACE_IN_FULL_MEDIA,
                &m_MaxFreeSpaceInFullMedia));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MaxFreeSpaceInFullMedia = %lu\n"),
                m_MaxFreeSpaceInFullMedia);

        // Save DBs in dataset? (Note: registry value has opposite meaning!)
        l_value = m_StoreDatabasesInBags ? 0 : 1;
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_DONT_SAVE_DATABASES,
                &l_value));
        m_StoreDatabasesInBags  = !l_value;
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_StoreDatabasesInBags = <%ls>\n"),
            WsbBoolAsString(m_StoreDatabasesInBags));

        // Queue length to pause scan
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_QUEUE_ITEMS_TO_PAUSE,
                &m_QueueItemsToPause));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_QueueItemsToPause = %lu\n"),
                m_QueueItemsToPause);

        // Queue length to resume scan
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_QUEUE_ITEMS_TO_RESUME,
                &m_QueueItemsToResume));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_QueueItemsToResume = %lu\n"),
                m_QueueItemsToResume);

        //  See if the user defined a media base name to use
        if (S_OK == WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MEDIA_BASE_NAME,
                dataString, 100, &sizeGot)) {
            m_MediaBaseName  = dataString;
            WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MediaBaseName = <%ls>\n"),
                    static_cast<OLECHAR *>(m_MediaBaseName));
        }

        //  Check for change to number of errors to allow before cancelling
        //  a job
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_CONSECUTIVE_ERRORS,
                &m_JobAbortMaxConsecutiveErrors));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_JobAbortMaxConsecutiveErrors = %lu\n"),
                m_JobAbortMaxConsecutiveErrors);
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_TOTAL_ERRORS,
                &m_JobAbortMaxTotalErrors));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_JobAbortMaxTotalErrors = %lu\n"),
                m_JobAbortMaxTotalErrors);

        //  Check for amount of system disk space required for a manage job
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_SYS_DISK_SPACE,
                &m_JobAbortSysDiskSpace));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_JobAbortSysDiskSpace = %lu\n"),
                m_JobAbortSysDiskSpace);

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckRegistry"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}


HRESULT
CHsmWorkQueue::CheckForDiskSpace(void)

/*++

Routine Description:

    Check system volume for sufficient space to complete a manage job.

Arguments:

    None

Return Value:

    S_OK                   - There is enough space
    WSB_E_SYSTEM_DISK_FULL - There isn't enough space
    E_*                    - Some error occurred

--*/
{
    HRESULT        hr = S_OK;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckForDiskSpace"), OLESTR(""));

    if (GetDiskFreeSpaceEx(NULL, &FreeBytesAvailableToCaller,
            &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
        if (FreeBytesAvailableToCaller.QuadPart < m_JobAbortSysDiskSpace) {
            hr = WSB_E_SYSTEM_DISK_FULL;
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckForDiskSpace"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}


HRESULT
CHsmWorkQueue::CommitWork(void)
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrComplete = S_OK;
    HRESULT                 hrFlush = E_FAIL;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CommitWork"),OLESTR(""));
    try {
        LONGLONG                lastByteWritten = -1;
        ULONG                   numItems;
        CWsbStringPtr           path;
        CComPtr<IHsmWorkItem>   pWorkItem;
        CComPtr<IFsaPostIt>     pFsaWorkItem;
        HSM_WORK_ITEM_TYPE      workType;
        BOOLEAN                 done = FALSE;
        BOOL                    skipWork = FALSE;

        // Do we actually have work to commit?
        WsbAffirmHr(m_pWorkToCommit->GetEntries(&numItems));
        if (0 == numItems) {
            return(S_OK);
        }

        //
        // We expect the data mover to be ready for work
        //
        WsbAffirm(m_pDataMover != 0, E_UNEXPECTED);

        //
        // If we never got a valid session going, we cannot
        // commit the work.  So check here to make sure the
        // session is really established OK
        if (S_OK == m_BeginSessionHr)  {
            CComPtr<IStream> pIStream;
            ULARGE_INTEGER   position;
            LARGE_INTEGER    zero = {0, 0};

            // Force a flush of the buffers
            //
            hrFlush = m_pDataMover->FlushBuffers();

            // Determine where we are on the tape
            WsbAffirmHr(m_pDataMover->QueryInterface(IID_IStream,
                    (void **)&pIStream));
            if (S_OK != pIStream->Seek(zero, STREAM_SEEK_END, &position)) {
                // If we didn't get useful information
                // about the amount of data written to media, we'll have
                // to skip everything in the queue
                skipWork = TRUE;
            } else {
                lastByteWritten = position.QuadPart;
            }
        } else  {
            // Skip all of the work -  none of it gets committed
            skipWork = TRUE;
        }
        WsbTrace(OLESTR("CHsmWorkQueue::CommitWork: hrFlush = <%ls>, lastByteWritten = %ls\n"),
                WsbHrAsString(hrFlush), WsbLonglongAsString(lastByteWritten));


        while ( (!done) && (S_OK == hr) ) {
            //
            // Get the next work item from the queue
            //
            hr = m_pWorkToCommit->First(IID_IHsmWorkItem, (void **)&pWorkItem);
            if (hr == S_OK)  {
                //
                // Find out about the work, should be FSA work
                //
                WsbAffirmHr(pWorkItem->GetWorkType(&workType));

                if (HSM_WORK_ITEM_FSA_WORK == workType)  {

                    try  {
                        CComPtr<IFsaScanItem>     pScanItem;

                        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                        WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));
                        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&m_RequestAction));

                        // If FlushBuffers failed, some items may not have
                        // gotten written to tape.  This code assumes the items
                        // in the queue are in the same order they were written
                        // onto the media
                        if (!skipWork && S_OK != hrFlush) {
                            FSA_PLACEHOLDER       placeholder;

                            WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
                            if (((LONGLONG)m_RemoteDataSetStart.QuadPart + placeholder.fileStart +
                                    placeholder.fileSize) > lastByteWritten) {
                                skipWork = TRUE;
                            }
                        }

                        (void) pFsaWorkItem->GetPath(&path, 0);
                        if (!skipWork)  {
                            //
                            // Get the FSA Work Item and complete the work
                            //
                            hr = CompleteWorkItem(pWorkItem);
                            //
                            // Do the stats counts
                            //
                            (void)m_pSession->ProcessItem(m_JobPhase, m_JobAction,
                                    pScanItem, hr);

                            //
                            // This is not a failure - change to OK 
                            //
                            if ( FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED == hr )  {
                                hr = S_OK;
                            }

                            if (S_OK != hr)  {
                                // Tell the session how things went if they didn't go well.
                                (void) m_pSession->ProcessHr(m_JobPhase, 0, 0, hr);
                            }   

                            // Check if the job needs to be canceled
                            if (S_OK != ShouldJobContinue(hr)) {
                                // Log a message if the disk is full
                                if (FSA_E_REPARSE_NOT_CREATED_DISK_FULL == hr) {
                                    WsbLogEvent(HSM_MESSAGE_MANAGE_FAILED_DISK_FULL,
                                            0, NULL, WsbAbbreviatePath(path, 120), NULL);
                                }
                                hrComplete = hr;
                                skipWork = TRUE;
                            }
                            WsbAffirmHr(hr);
                        } else  {
                            //
                            // Skip the work
                            //
                            WsbLogEvent(HSM_MESSAGE_WORK_SKIPPED_COMMIT_FAILED,
                                    0, NULL, WsbAbbreviatePath(path, 120),
                                    WsbHrAsString(hr), NULL);
                            (void)m_pSession->ProcessItem(m_JobPhase,
                                    m_JobAction, pScanItem,
                                    HSM_E_WORK_SKIPPED_COMMIT_FAILED);
                        }
                    } WsbCatchAndDo(hr, hr = S_OK;);
                    (void)m_pWorkToCommit->RemoveAndRelease(pWorkItem);
                } else  {
                    //
                    // Found non fsa work - don't expect that!
                    //
                    ULONG tmp;
                    tmp = (ULONG)workType;
                    WsbTrace(OLESTR("Expecting FSA work, found <%lu>\n"), tmp);
                    hr = E_UNEXPECTED;
                }
            } else if (WSB_E_NOTFOUND == hr)  {
                // There are no more entries in the queue so we are done
                done = TRUE;
                hr = S_OK;
                m_DataCountBeforeCommit  = 0;
                m_FilesCountBeforeCommit = 0;
            }

            pWorkItem = 0;
            pFsaWorkItem = 0;
        }
    } WsbCatch(hr);

    if (S_OK != hrFlush) {
        FailJob();
    }

    if (S_OK != hrComplete) {
        hr = hrComplete;
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CommitWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::StartNewMedia(
    IFsaPostIt *pFsaWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    dummyBool;
    CComPtr<IMediaInfo>     pMediaInfo;
    GUID                    storagePoolId;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StartNewMedia"),OLESTR(""));
    try {
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));
        WsbAffirmHr(GetMediaParameters());

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(CoCreateGuid(&m_MediaId));
        WsbAffirmHr(CoFileTimeNow(&m_MediaUpdate));
        WsbAffirmHr(pMediaInfo->GetRecreate(&dummyBool));
        WsbAffirmHr(pMediaInfo->SetMediaInfo(m_MediaId, m_MountedMedia, storagePoolId,
                                            m_MediaFreeSpace, m_MediaCapacity, m_BadMedia,
                                            1, m_MediaName, m_MediaType,
                                            m_MediaBarCode, m_MediaReadOnly, m_MediaUpdate,
                                            0, dummyBool));
        WsbAffirmHr(pMediaInfo->MarkAsNew());

        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::StartNewMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::StartNewSession( void )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrSession = S_OK;
    CComPtr<IMediaInfo>     pMediaInfo;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StartNewSession"),OLESTR(""));
    try {

        CWsbBstrPtr sessionName = HSM_BAG_NAME;
        CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;

        sessionName.Append(WsbGuidAsString(m_BagId));
        sessionDescription.Append(WsbGuidAsString(m_HsmId));

        //
        // Find the media record to know the next remote data set
        //
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&m_RemoteDataSet));

        //
        // Now call the data mover to begin a session.  If this doesn't work then
        // we want to mark the media as read only so that we will not overwrite
        // data.
        //
        m_BeginSessionHr = m_pDataMover->BeginSession(sessionName, sessionDescription, m_RemoteDataSet, MVR_SESSION_AS_LAST_DATA_SET);
        if (S_OK != m_BeginSessionHr)  {
            try  {
                //
                // Check the reason for the failure of the begin session.  If it is
                // MVR_E_DATA_SET_MISSING then the last begin session actually failed when
                // it was committed.  So, let's decrement the remote data set count and
                // redo the begin session that failed.
                //
                if (MVR_E_DATA_SET_MISSING == m_BeginSessionHr)  {
                    m_RemoteDataSet--;

                    //
                    // Try again...
                    m_BeginSessionHr = m_pDataMover->BeginSession(sessionName, sessionDescription, m_RemoteDataSet, MVR_SESSION_OVERWRITE_DATA_SET);

                    //
                    // !!! IMPORTANT NOTE !!!
                    //
                    // Update the media info to reflect new RemoteDataSet count.
                    // This will also correct any out of sync copies.
                    WsbAffirmHr(pMediaInfo->SetNextRemoteDataSet(m_RemoteDataSet));
                }
                switch (m_BeginSessionHr) {
                case S_OK:
                case MVR_E_BUS_RESET:
                case MVR_E_MEDIA_CHANGED:
                case MVR_E_NO_MEDIA_IN_DRIVE:
                case MVR_E_DEVICE_REQUIRES_CLEANING:
                case MVR_E_SHARING_VIOLATION:
                case MVR_E_ERROR_IO_DEVICE:
                case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                case MVR_E_ERROR_NOT_READY:
                    break;

                case MVR_E_INVALID_BLOCK_LENGTH:
                case MVR_E_WRITE_PROTECT:
                case MVR_E_CRC:
                default:
                    // Note the error
                    WsbAffirmHr(pMediaInfo->SetLastError(m_BeginSessionHr));
                    // Mark media as read only
                    m_MediaReadOnly = TRUE;
                    WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
                    // Write this out
                    WsbAffirmHr(pMediaInfo->Write());
                    break;
                }
            } WsbCatch( hrSession );
        }

        // If the BeginSession() failed, skip everything else.
        WsbAffirmHr(m_BeginSessionHr);

        //
        // Up the count of the remote data set and write it out
        m_RemoteDataSet++;
        WsbAffirmHr(pMediaInfo->SetNextRemoteDataSet(m_RemoteDataSet));

        // Write all of this out
        WsbAffirmHr(pMediaInfo->Write());

        //
        // Now set the Bag remote data set value
        //
        HSM_BAG_STATUS          l_BagStatus;
        LONGLONG                l_BagLen;
        USHORT                  l_BagType;
        FILETIME                l_BirthDate;
        LONGLONG                l_DeletedBagAmount;
        SHORT                   l_RemoteDataSet;
        GUID                    l_BagVolId;
        GUID                    l_BagId;
        CComPtr<IBagInfo>       pBagInfo;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                         (void**)&pBagInfo));

        GetSystemTimeAsFileTime(&l_BirthDate);

        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, m_BagId, l_BirthDate,
                0, 0, GUID_NULL, 0, 0 ));
        WsbAffirmHr(pBagInfo->FindEQ());
        WsbAffirmHr(pBagInfo->GetBagInfo(&l_BagStatus, &l_BagId, &l_BirthDate,
                &l_BagLen, &l_BagType, &l_BagVolId, &l_DeletedBagAmount, &l_RemoteDataSet ));
        WsbAffirmHr(pBagInfo->SetBagInfo(l_BagStatus, l_BagId, l_BirthDate,
                l_BagLen, l_BagType, l_BagVolId, l_DeletedBagAmount, (SHORT)(m_RemoteDataSet - 1)));
        WsbAffirmHr(pBagInfo->Write());

        // Reset error counts
        m_JobConsecutiveErrors = 0;
        m_JobTotalErrors = 0;

    } WsbCatchAndDo(hr,
            FailJob();
        );

    WsbTraceOut(OLESTR("CHsmWorkQueue::StartNewSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmWorkQueue::TranslateRmsMountHr(
    HRESULT     rmsMountHr
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::TranslateRmsMountHr"),OLESTR("rms hr = <%ls>"), WsbHrAsString(rmsMountHr));
    try {
        switch (rmsMountHr)  {
            case S_OK:
                hr = S_OK;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTED, hr);
                break;
            case RMS_E_MEDIASET_NOT_FOUND:
                if (m_RmsMediaSetId == GUID_NULL)  {
                    hr = HSM_E_STG_PL_NOT_CFGD;
                } else {
                    hr = HSM_E_STG_PL_INVALID;
                }
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_SCRATCH_NOT_FOUND:
                hr = HSM_E_NO_MORE_MEDIA;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_SCRATCH_NOT_FOUND_FINAL:
                hr = HSM_E_NO_MORE_MEDIA_FINAL;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_CARTRIDGE_UNAVAILABLE:
            case RMS_E_RESOURCE_UNAVAILABLE:
            case RMS_E_DRIVE_UNAVAILABLE:
            case RMS_E_LIBRARY_UNAVAILABLE:
                hr = HSM_E_MEDIA_NOT_AVAILABLE;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_CARTRIDGE_BUSY:
            case RMS_E_RESOURCE_BUSY:
            case RMS_E_DRIVE_BUSY:
                hr = HSM_E_MEDIA_BUSY;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_BUSY, hr);
                break;
			case RMS_E_CARTRIDGE_NOT_FOUND:
			case RMS_E_CARTRIDGE_DISABLED:
            case RMS_E_TIMEOUT:
                hr = rmsMountHr;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            default:
                hr = rmsMountHr;
                (void) m_pSession->ProcessHr(m_JobPhase, __FILE__, __LINE__, rmsMountHr);
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::TranslateRmsMountHr"),
                OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::StoreDatabasesOnMedia( void )
/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StoreDatabasesOnMedia"),OLESTR(""));
    try {
        //
        // For ultimate disaster recovery, write some files to media.  We want
        // to save the engine metadata and collection, the rms colleciton, NTMS
        // data and the fsa collection if it exists.
        //
        ULARGE_INTEGER  remoteDataSetStart;
        ULARGE_INTEGER  remoteFileStart;
        ULARGE_INTEGER  remoteFileSize;
        ULARGE_INTEGER  remoteDataStart;
        ULARGE_INTEGER  remoteDataSize;
        ULARGE_INTEGER  remoteVerificationData;
        ULONG           remoteVerificationType;
        ULARGE_INTEGER  dataStreamCRC;
        ULONG           dataStreamCRCType;
        ULARGE_INTEGER  usn;
        ULARGE_INTEGER  localDataSize;
        ULARGE_INTEGER  localDataStart;
        HANDLE          handle = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA findData;
        CWsbStringPtr   localName;
        CWsbBstrPtr     bStrLocalName;
        CWsbStringPtr   rootName;
        BOOL            foundFile = TRUE;
        BOOL            bFullMessage = TRUE;
        LONG            mediaType;
        BOOL            bNewSession = FALSE;

        //
        // Force a save of the persistent databases
        // We are not doing FSA here
        //
        try  {
            hr = m_pRmsServer->SaveAll();
            hr = m_pServer->SavePersistData();
        } WsbCatch( hr );


        //
        // In case of direct-access media, we terminate the Mover Session and open
        //  an additional special metadata session
        WsbAssert(m_pRmsCartridge != 0, E_UNEXPECTED);
        WsbAffirmHr(m_pRmsCartridge->GetType(&mediaType));
        switch (mediaType) {
            case RmsMediaOptical:
            case RmsMediaFixed:
            case RmsMediaDVD:
                bNewSession = TRUE;
                break;

            default:
                bNewSession = FALSE;
                break;
        }

        if (bNewSession) {
            // End current session
            m_BeginSessionHr = S_FALSE;
            WsbAffirmHr(m_pDataMover->EndSession());

            // Start a new one
            CWsbBstrPtr sessionName = HSM_METADATA_NAME;
            CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;

            sessionDescription.Append(WsbGuidAsString(m_HsmId));

            m_BeginSessionHr = m_pDataMover->BeginSession(
                    sessionName, 
                    sessionDescription, 
                    0, 
                    MVR_SESSION_METADATA | MVR_SESSION_AS_LAST_DATA_SET);

            if (S_OK != m_BeginSessionHr)  {
                HRESULT             hrSession = S_OK;
                CComPtr<IMediaInfo> pMediaInfo;

                try  {
                    // Check the error (some errors requires marking the media is Read Only
                    switch (m_BeginSessionHr) {
                    case S_OK:
                    case MVR_E_BUS_RESET:
                    case MVR_E_MEDIA_CHANGED:
                    case MVR_E_NO_MEDIA_IN_DRIVE:
                    case MVR_E_DEVICE_REQUIRES_CLEANING:
                    case MVR_E_SHARING_VIOLATION:
                    case MVR_E_ERROR_IO_DEVICE:
                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                    case MVR_E_ERROR_NOT_READY:
                        break;

                    case MVR_E_INVALID_BLOCK_LENGTH:
                    case MVR_E_WRITE_PROTECT:
                    case MVR_E_CRC:
                    default:
                        // Get the media record
                        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, 
                             IID_IMediaInfo, (void**)&pMediaInfo));
                        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
                        WsbAffirmHr(pMediaInfo->FindEQ());
                        // Note the error
                        WsbAffirmHr(pMediaInfo->SetLastError(m_BeginSessionHr));
                        // Mark media as read only
                        m_MediaReadOnly = TRUE;
                        WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
                        // Write this out
                        WsbAffirmHr(pMediaInfo->Write());
                        break;
                    }
                } WsbCatch( hrSession );
            } // end if BeginSession error

            WsbAffirmHr(m_BeginSessionHr);
        } // end if new mover session

        //
        // Start at the beginning of all files
        //
        localDataStart.LowPart = 0;
        localDataStart.HighPart = 0;

        //
        // First go the the remote storage and save the collections
        //
        try  {
            // Get the name of the file
            WsbAffirmHr(m_pServer->GetDbPath(&rootName, 0));
            WsbAffirmHr(rootName.Append(OLESTR("\\")));
            localName = rootName;
            WsbAffirmHr(localName.Append(OLESTR("Rs*.bak")));


            // Find out the file(s)
            handle = FindFirstFile(localName, &findData);
            localName = rootName;
            WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));

            // Copy each file to tape
            while ((INVALID_HANDLE_VALUE != handle) && (foundFile == TRUE))  {
                if ((FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes) != FILE_ATTRIBUTE_DIRECTORY) {
                    localDataSize.LowPart = findData.nFileSizeLow;
                    localDataSize.HighPart = findData.nFileSizeHigh;
                    bStrLocalName = localName;
                    hr =  StoreDataWithRetry(  bStrLocalName,
                                                    localDataStart,
                                                    localDataSize,
                                                    MVR_FLAG_BACKUP_SEMANTICS,
                                                    &remoteDataSetStart,
                                                    &remoteFileStart,
                                                    &remoteFileSize,
                                                    &remoteDataStart,
                                                    &remoteDataSize,
                                                    &remoteVerificationType,
                                                    &remoteVerificationData,
                                                    &dataStreamCRCType,
                                                    &dataStreamCRC,
                                                    &usn,
                                                    &bFullMessage);
                }

                foundFile = FindNextFile(handle, &findData);
                localName = rootName;
                WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));
            }

        } WsbCatch(hr);
        if ( INVALID_HANDLE_VALUE != handle ) {
            FindClose(handle);
            handle = INVALID_HANDLE_VALUE;
        }

        //
        // Next save the hsm metadata
        //
        try  {
            //
            // First backup the databases since the backup files
            // are the ones that are saved.
            //
            WsbAffirmHr(m_pServer->BackupSegmentDb());

            // Create the search path
            localName = "";
            WsbAffirmHr(m_pServer->GetIDbPath(&rootName, 0));
            WsbAffirmHr(rootName.Append(OLESTR(".bak\\")));
            localName = rootName;
            WsbAffirmHr(localName.Append(OLESTR("*.*")));

            // Find the first file
            handle = FindFirstFile(localName, &findData);
            localName = rootName;
            WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));

            // Copy each file to tape
            foundFile = TRUE;
            while ((INVALID_HANDLE_VALUE != handle) && (foundFile == TRUE))  {
                if ((FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes) != FILE_ATTRIBUTE_DIRECTORY) {
                    localDataSize.LowPart = findData.nFileSizeLow;
                    localDataSize.HighPart = findData.nFileSizeHigh;
                    bStrLocalName = localName;
                    hr =  StoreDataWithRetry(  bStrLocalName,
                                                    localDataStart,
                                                    localDataSize,
                                                    MVR_FLAG_BACKUP_SEMANTICS,
                                                    &remoteDataSetStart,
                                                    &remoteFileStart,
                                                    &remoteFileSize,
                                                    &remoteDataStart,
                                                    &remoteDataSize,
                                                    &remoteVerificationType,
                                                    &remoteVerificationData,
                                                    &dataStreamCRCType,
                                                    &dataStreamCRC,
                                                    &usn,
                                                    &bFullMessage);
                }
                foundFile = FindNextFile(handle, &findData);
                localName = rootName;
                WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));
            }
        } WsbCatch(hr);
        if ( INVALID_HANDLE_VALUE != handle ) {
            FindClose(handle);
            handle = INVALID_HANDLE_VALUE;
        }

        //
        // Next go the the NTMS databases and save them
        //
        try  {
            DWORD               sizeGot;
            //
            // NTMS saves databases in a subdirectory parallel to the
            // RemoteStorage subdirectory.  So go there and just take
            // the necessary files.
            //
            localName = "";
            WsbAffirmHr(localName.Realloc(1024));
            //
            // Use the relocatable meta-data path if it's available,
            // otherwise default to the %SystemRoot%\System32\RemoteStorage
            //
            hr = WsbGetRegistryValueString(NULL, WSB_RSM_CONTROL_REGISTRY_KEY, WSB_RSM_METADATA_REGISTRY_VALUE, localName, 256, &sizeGot);
            if (hr == S_OK) {
                WsbAffirmHr(localName.Append(OLESTR("NtmsData\\NTMSDATA.BAK")));
            } else {
                WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY));
                WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, localName, 256, &sizeGot));
                WsbAffirmHr(localName.Append(OLESTR("\\system32\\NtmsData\\NTMSDATA.BAK")));
            }

            // Find the first one
            handle = FindFirstFile(localName, &findData);

            // Copy each file to tape
            if (INVALID_HANDLE_VALUE != handle)  {
                localDataSize.LowPart = findData.nFileSizeLow;
                localDataSize.HighPart = findData.nFileSizeHigh;
                bStrLocalName = localName;
                hr =  StoreDataWithRetry(  bStrLocalName,
                                           localDataStart,
                                           localDataSize,
                                           MVR_FLAG_BACKUP_SEMANTICS,
                                           &remoteDataSetStart,
                                           &remoteFileStart,
                                           &remoteFileSize,
                                           &remoteDataStart,
                                           &remoteDataSize,
                                           &remoteVerificationType,
                                           &remoteVerificationData,
                                           &dataStreamCRCType,
                                           &dataStreamCRC,
                                           &usn,
                                           &bFullMessage);
            }


        } WsbCatch(hr);
        if ( INVALID_HANDLE_VALUE != handle ) {
            FindClose(handle);
            handle = INVALID_HANDLE_VALUE;
        }

        //
        // Next save the NTMS Export files.
        //
        try  {
            DWORD               sizeGot;
            //
            // NTMS saves Export files in the EXPORT directory.  We take
            // all the files in this dir.  StoreData does the findFirst for us.
            //
            localName = "";
            WsbAffirmHr(localName.Realloc(256));
            WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY));
            WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, localName, 256, &sizeGot));
            WsbAffirmHr(localName.Append(OLESTR("\\system32\\NtmsData\\Export\\*.*")));

            bStrLocalName = localName;
            localDataStart.QuadPart = 0;
            localDataSize.QuadPart = 0;
            hr =  StoreDataWithRetry(  bStrLocalName,
                                            localDataStart,
                                            localDataSize,
                                            MVR_FLAG_BACKUP_SEMANTICS,
                                            &remoteDataSetStart,
                                            &remoteFileStart,
                                            &remoteFileSize,
                                            &remoteDataStart,
                                            &remoteDataSize,
                                            &remoteVerificationType,
                                            &remoteVerificationData,
                                            &dataStreamCRCType,
                                            &dataStreamCRC,
                                            &usn,
                                            &bFullMessage);


        } WsbCatch(hr);

    } WsbCatch(hr);

    //
    // Whatever happens, return OK
    //
    hr = S_OK;


    WsbTraceOut(OLESTR("CHsmWorkQueue::StoreDatabasesOnMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::StoreDataWithRetry(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn,
        OUT BOOL *bFullMessage
        )

/*++

Routine Description:

    Calls StoreData with retries in case the file to write from is in use.

Arguments:

    Same as StoreData

Return Value:

    From StoreData

--*/
{
#define MAX_STOREDATA_RETRIES  3

    HRESULT hr = S_OK;
    LONG    RetryCount = 0;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StoreDataWithRetry"), OLESTR("file <%ls>"),
            static_cast<OLECHAR *>(localName));

    for (RetryCount = 0; (RetryCount < MAX_STOREDATA_RETRIES) && (hr != E_ABORT) && (hr != MVR_E_MEDIA_ABORT);  RetryCount++) {
        if (RetryCount > 0) {
            WsbLogEvent(HSM_MESSAGE_DATABASE_FILE_COPY_RETRY, 0, NULL,
                WsbAbbreviatePath((WCHAR *) localName, 120), NULL);
        }
        // Make sure data mover is ready for work.
        WsbAffirmPointer(m_pDataMover);
        hr =  m_pDataMover->StoreData(localName, localDataStart, localDataSize,
            flags, pRemoteDataSetStart, pRemoteFileStart, pRemoteFileSize,
            pRemoteDataStart, pRemoteDataSize, pRemoteVerificationType,
            pRemoteVerificationData, pDatastreamCRCType, pDatastreamCRC,
            pUsn);
        WsbTrace(OLESTR("CHsmWorkQueue::StoreDataWithRetry: StoreData hr = <%ls>\n"),
                WsbHrAsString(hr) );
        if (S_OK == hr) break;
        Sleep(1000);
    }

    if (hr != S_OK) {
        if (*bFullMessage) {
            WsbLogEvent(HSM_MESSAGE_GENERAL_DATABASE_FILE_NOT_COPIED, 0, NULL, WsbHrAsString(hr), NULL);
			*bFullMessage = FALSE;
        }
        WsbLogEvent(HSM_MESSAGE_DATABASE_FILE_NOT_COPIED, 0, NULL,
            WsbAbbreviatePath((WCHAR *) localName, 120), WsbHrAsString(hr), NULL);
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::StoreDataWithRetry"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr) );
    return(hr);
}


HRESULT
CHsmWorkQueue::ShouldJobContinue(
    HRESULT problemHr
    )

/*++

Implements:

  CHsmWorkQueue::ShouldJobContinue().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ShouldJobContinue"), OLESTR("<%ls>"), WsbHrAsString(problemHr));
    try {
        // Collect some error counts and check if we've had too many
        if (S_OK == problemHr) {
            // Reset consecutive error count
            m_JobConsecutiveErrors = 0;
        } else {
            m_JobConsecutiveErrors++;
            m_JobTotalErrors++;
            if (m_JobConsecutiveErrors >= m_JobAbortMaxConsecutiveErrors) {
                WsbLogEvent(HSM_MESSAGE_TOO_MANY_CONSECUTIVE_JOB_ERRORS,
                        0, NULL, WsbLongAsString(m_JobConsecutiveErrors), NULL);
                hr = S_FALSE;
            } else if (m_JobTotalErrors >= m_JobAbortMaxTotalErrors) {
                WsbLogEvent(HSM_MESSAGE_TOO_MANY_TOTAL_JOB_ERRORS,
                        0, NULL, WsbLongAsString(m_JobTotalErrors), NULL);
                hr = S_FALSE;
            }
        }

        //
        // Evaluate the input HR to decide if we should try to continue with the job or if
        // we should abandon the job because the problem is not recoverable.
        //
        if (S_OK == hr) {
            switch (problemHr)  {
                case E_ABORT:
                case MVR_E_MEDIA_ABORT:
                case FSA_E_REPARSE_NOT_CREATED_DISK_FULL:
                case WSB_E_SYSTEM_DISK_FULL:
                    //
                    // we want to cancel the job
                    //
                    hr = S_FALSE;
                    break;

                default:
                    // Be optimistic and try to keep going
                    hr = S_OK;
                    break;
            }
        }

        // Abort the job if necessary
        if (S_FALSE == hr) {
            WsbAffirmHr(FailJob());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ShouldJobContinue"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::Remove(
    IHsmWorkItem *pWorkItem
    )
/*++

Implements:

  IHsmFsaTskMgr::Remove

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Remove"),OLESTR(""));
    try  {
        //
        // Remove the item from the queue and see if we need to
        // resume the scanner (if it is paused)
        //
        (void)m_pWorkToDo->RemoveAndRelease(pWorkItem);
        ULONG numItems;
        WsbAffirmHr(m_pWorkToDo->GetEntries(&numItems));
        WsbTrace(OLESTR("CHsmWorkQueue::Remove - num items in queue = <%lu>\n"),numItems);
        if (numItems <= m_QueueItemsToResume)  {
            WsbAffirmHr(ResumeScanner());
        }
    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Remove"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::ChangeSysState(
    IN OUT HSM_SYSTEM_STATE* pSysState
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ChangeSysState"), OLESTR(""));

    try {

        if (pSysState->State & HSM_STATE_SUSPEND) {
            // Should have already been paused via the job
        } else if (pSysState->State & HSM_STATE_RESUME) {
            // Should have already been resumed via the job
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Release the thread (we assume it has been stopped already)
            if (m_WorkerThread) {
                CloseHandle(m_WorkerThread);
                m_WorkerThread = 0;
            }

            if (m_pDataMover) {
                //
                // Cancel any active I/O
                //
                (void) m_pDataMover->Cancel();
            }

            // If Session is valid - unadvise and free session, otherwise, just try to
            // dismount media if it is mounted (which we don't know at this point)
            // Best effort dismount, no error checking so following resources will get released.
            if (m_pSession != 0) {
                EndSessions(FALSE, TRUE);
            } else {
                (void) DismountMedia(TRUE);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmWorkQueue::UnsetMediaInfo( void )

/*++

Routine Description:

    Sets the media data members back to their default (unset) values.

Arguments:

    None.

Return Value:

    S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UnsetMediaInfo"), OLESTR(""));

    m_MediaId        = GUID_NULL;
    m_MountedMedia   = GUID_NULL;
    m_MediaType      = HSM_JOB_MEDIA_TYPE_UNKNOWN;
    m_MediaName      = OLESTR("");
    m_MediaBarCode   = OLESTR("");
    m_MediaFreeSpace = 0;
    m_MediaCapacity = 0;
    m_MediaReadOnly = FALSE;
    m_MediaUpdate = WsbLLtoFT(0);
    m_BadMedia       = S_OK;
    m_RemoteDataSetStart.QuadPart   = 0;
    m_RemoteDataSet  = 0;

    WsbTraceOut(OLESTR("CHsmWorkQueue::UnsetMediaInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::UpdateMediaFreeSpace( void )

/*++
Routine Description:
    Updates media free space in the database based on Mover current information.
    This method should be called only while the current media is still mounted.

Arguments:
    None.

Return Value:
    S_OK:  Ok.
--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateMediaFreeSpace"), OLESTR(""));

    try
    {
        CComPtr<IMediaInfo>     pMediaInfo;
        LONGLONG                currentFreeSpace;

        WsbAssert(GUID_NULL != m_MediaId, E_UNEXPECTED);
        WsbAffirm(m_pDbWorkSession != 0, E_FAIL);

        // Find media record
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, 
                IID_IMediaInfo, (void**)&pMediaInfo));

        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());

        // Get updated free space
        WsbAffirmHr(pMediaInfo->GetFreeBytes(&currentFreeSpace));
        WsbAffirmHr(GetMediaParameters(currentFreeSpace));

        // Update in the media table
        WsbAffirmHr(pMediaInfo->SetFreeBytes(m_MediaFreeSpace));

        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateMediaFreeSpace"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::GetMediaFreeSpace( LONGLONG *pFreeSpace )

/*++
Routine Description:
    Retrieves internal free space from HSM DB (media table)

Arguments:
    None.

Return Value:
    S_OK:  Ok.
--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetMediaFreeSpace"), OLESTR(""));

    try
    {
        CComPtr<IMediaInfo>     pMediaInfo;

        WsbAssert(GUID_NULL != m_MediaId, E_UNEXPECTED);
        WsbAssert(m_pDbWorkSession != 0, E_UNEXPECTED);
        WsbAssertPointer(pFreeSpace);

        *pFreeSpace = 0;

        // Update in the media table
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, 
                IID_IMediaInfo, (void**)&pMediaInfo));

        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->GetFreeBytes(pFreeSpace));

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetMediaFreeSpace"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmworki.h ===
#ifndef _HSMWORKI_
#define _HSMWORKI_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HSMWORKI.H

Abstract:

    This class represents an HSM work item - a unit of work
    that is performed by the HSM engine

Author:

    Cat Brant   [cbrant]   5-May-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "job.h"
#include "task.h"

/*++

Class Name:
    
    CHsmWorkItem

Class Description:


--*/


class CHsmWorkItem : 
    public CWsbObject,
    public IHsmWorkItem,
    public CComCoClass<CHsmWorkItem,&CLSID_CHsmWorkItem>
{
public:
    CHsmWorkItem() {}
BEGIN_COM_MAP(CHsmWorkItem)
    COM_INTERFACE_ENTRY(IHsmWorkItem)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmWorkItem )

// CWsbCollectable
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
    
// IHsmWorkItem
public:
    STDMETHOD(CompareToIHsmWorkItem)(IHsmWorkItem* pWorkItem, SHORT* pResult);

    STDMETHOD(GetFsaPostIt)(IFsaPostIt  **ppFsaPostIt);
    STDMETHOD(GetFsaResource)(IFsaResource **ppFsaResource);
    STDMETHOD(GetId)(GUID *pId);
    STDMETHOD(GetMediaInfo)(GUID *pMediaId, FILETIME *pMediaLastUpdate,
                            HRESULT *pMediaLastError, BOOL *pMediaRecallOnly,
                            LONGLONG *pMediaFreeBytes, short *pMediaRemoteDataSet);
    STDMETHOD(GetResult)(HRESULT  *pHr);
    STDMETHOD(GetWorkType)(HSM_WORK_ITEM_TYPE *pWorkType);

    STDMETHOD(SetFsaPostIt)(IFsaPostIt  *pFsaPostIt);
    STDMETHOD(SetFsaResource)(IFsaResource *pFsaResource);
    STDMETHOD(SetMediaInfo)(GUID mediaId, FILETIME mediaLastUpdate,
                            HRESULT mediaLastError, BOOL mediaRecallOnly,
                            LONGLONG mediaFreeBytes, short mediaRemoteDataSet);
    STDMETHOD(SetResult)(HRESULT  hr);
    STDMETHOD(SetWorkType)(HSM_WORK_ITEM_TYPE workType);

protected:
    HSM_WORK_ITEM_TYPE      m_WorkType;         // Type of work to do
    CComPtr<IFsaPostIt>     m_pFsaPostIt;       // FSA work to do
    HRESULT                 m_WorkResult;       // Result of premigrate
    CComPtr<IFsaResource>   m_pFsaResource;     // Resource that had work

// Information about media containing the data - premigrates only
    GUID                    m_MyId;                 // Identifier for database searches
    GUID                    m_MediaId;              // HSM Engine Media ID
    FILETIME                m_MediaLastUpdate;      // Last update of copy
    HRESULT                 m_MediaLastError;       // S_OK or the last exception 
                                                    // ..encountered when accessing
                                                    // ..the media
    BOOL                    m_MediaRecallOnly;      // True if no more data is to
                                                    // ..be premigrated to the media
                                                    // ..Set by internal operations, 
                                                    // ..may not be changed externally
    LONGLONG                m_MediaFreeBytes;       // Real free space on media
    SHORT                   m_MediaRemoteDataSet;   // Next remote data set
};

#endif  // _HSMWORKI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\hsmworki.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmworki.cpp

Abstract:

    This class represents an HSM work item - a unit of work
    that is performed by the HSM engine

Author:

    Cat Brant   [cbrant]   5-May-1997

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
#include "wsb.h"
#include "fsa.h"
#include "task.h"
#include "hsmworki.h"

static USHORT iCount = 0;

HRESULT
CHsmWorkItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmWorkItem>   pWorkItem;

    WsbTraceIn(OLESTR("CHsmWorkItem::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IHsmWorkItem interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmWorkItem, (void**) &pWorkItem));

        // Compare the items
        hr = CompareToIHsmWorkItem(pWorkItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmWorkItem::CompareToIHsmWorkItem(
    IN IHsmWorkItem* pWorkItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmWorkItem::CompareToIHsmWorkItem().

--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_Id;           // Type of work to do

    WsbTraceIn(OLESTR("CHsmWorkItem::CompareToIHsmWorkItem"), OLESTR(""));

    try {
        //
        // Did they give us a valid item to compare to?
        //
        WsbAssert(0 != pWorkItem, E_POINTER);
        
        //
        // Get the ID
        //
        WsbAffirmHr(pWorkItem->GetId(&l_Id));

        if (l_Id != m_MyId){
            hr = S_FALSE;
        } 
        // If they asked for the relative value back, then return it to them.
        if (pResult != NULL) {
            if (S_OK == hr)  {
                *pResult = 0;
            } else {
                *pResult = 1;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::CompareToIHsmWorkItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmWorkItem::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmWorkItem::FinalConstruct"), OLESTR(""));
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        //
        // The comparison for database searches is based on the
        // ID of this object (m_MyId). 
        //
        WsbAffirmHr(CoCreateGuid(&m_MyId));
        m_WorkType = HSM_WORK_ITEM_NONE;
        m_MediaId = GUID_NULL;
        m_MediaLastUpdate =  WsbLLtoFT(0);
        m_MediaLastError = S_OK;
        m_MediaRecallOnly = FALSE;
        m_MediaFreeBytes = 0;

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmWorkItem::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmWorkItem::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CHsmWorkItem::FinalRelease"), OLESTR(""));
    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();
    
    iCount--;
    WsbTraceOut(OLESTR("CHsmWorkItem::FinalRelease"), OLESTR("Count is <%d>"), iCount);
    
}


HRESULT
CHsmWorkItem::GetFsaPostIt (
    OUT IFsaPostIt  **ppFsaPostIt
    )

/*++

Implements:

  IHsmWorkItem::GetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaPostIt, E_POINTER);
        *ppFsaPostIt = m_pFsaPostIt;
        if (0 != *ppFsaPostIt)  {
            (*ppFsaPostIt)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::GetFsaResource (
    OUT IFsaResource  **ppFsaResource
    )

/*++

Implements:

  IHsmWorkItem::GetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaResource, E_POINTER);
        *ppFsaResource = m_pFsaResource;
        if (0 != *ppFsaResource)  {
            (*ppFsaResource)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::GetId(
    OUT GUID *pId
    )

/*++

Implements:

  IHsmWorkItem::GetId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetId"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pId, E_POINTER);
        *pId = m_MyId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetId"), OLESTR("hr = <%ls>, Id = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToGuidAsString(pId));

    return(hr);
}

HRESULT
CHsmWorkItem::GetMediaInfo (
    OUT GUID *pMediaId, 
    OUT FILETIME *pMediaLastUpdate,
    OUT HRESULT *pMediaLastError, 
    OUT BOOL *pMediaRecallOnly,
    OUT LONGLONG *pMediaFreeBytes,
    OUT short *pMediaRemoteDataSet
    )

/*++

Implements:

  IHsmWorkItem::GetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetMediaInfo"), OLESTR(""));

    try {

        // Did they give us  valid pointers?
        WsbAssert(0 != pMediaId, E_POINTER);
        WsbAssert(0 != pMediaLastUpdate, E_POINTER);
        WsbAssert(0 != pMediaLastError, E_POINTER);
        WsbAssert(0 != pMediaRecallOnly, E_POINTER);
        WsbAssert(0 != pMediaFreeBytes, E_POINTER);
        WsbAssert(0 != pMediaRemoteDataSet, E_POINTER);
        
        *pMediaId = m_MediaId;
        *pMediaLastUpdate = m_MediaLastUpdate;
        *pMediaLastError = m_MediaLastError;
        *pMediaRecallOnly = m_MediaRecallOnly;
        *pMediaFreeBytes = m_MediaFreeBytes;
        *pMediaRemoteDataSet = m_MediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetMediaInfo"), 
        OLESTR("hr = <%ls>, Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaId), WsbPtrToFiletimeAsString(FALSE, pMediaLastUpdate),
        WsbPtrToHrAsString(pMediaLastError), WsbPtrToBoolAsString(pMediaRecallOnly),
        WsbPtrToLonglongAsString(pMediaFreeBytes), WsbPtrToShortAsString(pMediaRemoteDataSet));

    return(hr);
}


HRESULT
CHsmWorkItem::GetResult(
    OUT HRESULT *pHr
    )

/*++

Implements:

  IHsmWorkItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetResult"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pHr, E_POINTER);
        *pHr = m_WorkResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetResult"), OLESTR("hr = <%ls>, Result = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToHrAsString(pHr));

    return(hr);
}

HRESULT
CHsmWorkItem::GetWorkType(
    OUT HSM_WORK_ITEM_TYPE *pWorkType   
    )

/*++

Implements:

  IHsmWorkItem::GetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetWorkType"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pWorkType, E_POINTER);
        *pWorkType = m_WorkType;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CHsmWorkItem::SetFsaPostIt (
    IN IFsaPostIt  *pFsaPostIt
    )

/*++

Implements:

  IHsmWorkItem::SetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaPostIt, E_POINTER);
        m_pFsaPostIt = pFsaPostIt;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::SetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::SetFsaResource (
    IN IFsaResource  *pFsaResource
    )

/*++

Implements:

  IHsmWorkItem::SetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaResource, E_POINTER);
        m_pFsaResource = pFsaResource;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::SetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmWorkItem::SetMediaInfo (
    IN GUID mediaId, 
    IN FILETIME mediaLastUpdate,
    IN HRESULT mediaLastError, 
    IN BOOL mediaRecallOnly,
    IN LONGLONG mediaFreeBytes,
    IN short mediaRemoteDataSet
    )

/*++

Implements:

  IHsmWorkItem::SetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetMediaInfo"), 
        OLESTR("Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%d>"), 
        WsbGuidAsString(mediaId), WsbFiletimeAsString(FALSE, mediaLastUpdate),
        WsbHrAsString(mediaLastError), WsbBoolAsString(mediaRecallOnly),
        WsbLonglongAsString(mediaFreeBytes), mediaRemoteDataSet);

    try {
        m_MediaId          = mediaId;
        m_MediaLastUpdate  = mediaLastUpdate;
        m_MediaLastError   = mediaLastError;
        m_MediaRecallOnly  = mediaRecallOnly;
        m_MediaFreeBytes   = mediaFreeBytes;
        m_MediaRemoteDataSet = mediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetMediaInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::SetResult(
    IN HRESULT workResult
    )

/*++

Implements:

  IHsmWorkItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetResult"), OLESTR("Result is <%ls>"), WsbHrAsString(workResult));

    try {
    
        m_WorkResult = workResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetResult"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::SetWorkType(
    IN HSM_WORK_ITEM_TYPE workType  
    )

/*++

Implements:

  IHsmWorkItem::SetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetWorkType"), OLESTR(""));

    m_WorkType = workType;

    WsbTraceOut(OLESTR("CHsmWorkItem::SetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT CHsmWorkItem::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CHsmWorkItem;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CHsmWorkItem::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = 0;
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CHsmWorkItem::Load
(
    IN IStream* /*pStream*/
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::Load"), OLESTR(""));

    try {
        hr = E_NOTIMPL;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmWorkItem::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CHsmWorkItem::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmWorkItem::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
    
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\medinfo.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MedInfo.cpp

Abstract:

    This component is an object representation of the HSM Metadata media information
    record.

Author:

    Cat Brant   [cbrant]   27-Feb-1997

Revision History:

--*/


#include "stdafx.h"

#include "wsbgen.h"
#include "engine.h"
#include "metaint.h"
#include "metalib.h"
#include "MedInfo.h"
#include "segdb.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_META
static USHORT iCountMedinfo = 0;


HRESULT 
CMediaInfo::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        //
        // Initialize the master media record
        //
        m_Master.id = GUID_NULL;
        m_Master.ntmsId = GUID_NULL;
        m_Master.storagePoolId = GUID_NULL;
        m_Master.description = OLESTR("");
        m_Master.name = OLESTR("");
        m_Master.type = HSM_JOB_MEDIA_TYPE_UNKNOWN;
        m_Master.lastUpdate = WsbLLtoFT(0);
        m_Master.lastError = S_OK;
        m_Master.recallOnly = FALSE;
        m_Master.freeBytes = 0;
        m_Master.capacity = 0;
        m_Master.nextRemoteDataSet = 0;
        
        m_Recreate = FALSE;
        m_LogicalValidBytes = 0;
        
        //
        // Now initialize the last known good master
        //
        m_LastKnownGoodMaster.id = GUID_NULL;
        m_LastKnownGoodMaster.ntmsId = GUID_NULL;
        m_LastKnownGoodMaster.storagePoolId = GUID_NULL;
        m_LastKnownGoodMaster.description = OLESTR("");
        m_LastKnownGoodMaster.name = OLESTR("");
        m_LastKnownGoodMaster.type = HSM_JOB_MEDIA_TYPE_UNKNOWN;
        m_LastKnownGoodMaster.lastUpdate = WsbLLtoFT(0);
        m_LastKnownGoodMaster.lastError = S_OK;
        m_LastKnownGoodMaster.recallOnly = FALSE;
        m_LastKnownGoodMaster.freeBytes = 0;
        m_LastKnownGoodMaster.capacity = 0;
        m_LastKnownGoodMaster.nextRemoteDataSet = 0;
            
        //
        // Initialize the master's copy media records
        //
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++)  {
            m_Copy[i].id = GUID_NULL;
            m_Copy[i].description = OLESTR("");
            m_Copy[i].name = OLESTR("");
            m_Copy[i].lastUpdate = WsbLLtoFT(0);
            m_Copy[i].lastError = S_OK;
            m_Copy[i].nextRemoteDataSet = 0;
        }            
        
    } WsbCatch(hr);
    iCountMedinfo++;
    WsbTraceOut(OLESTR("CMediaInfo::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCountMedinfo);
    return(hr);
}



void
CMediaInfo::FinalRelease(
    void
    )

/*++

Implements:

  CMediaInfo::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CMediaInfo::FinalRelease"), OLESTR(""));
    
    CWsbDbEntity::FinalRelease();
    iCountMedinfo--;
    
    WsbTraceOut(OLESTR("CMediaInfo::FinalRelease"), OLESTR("Count is <%d>"), iCountMedinfo);
}



HRESULT
CMediaInfo::GetName(
    OLECHAR **pName,
    ULONG   bufferSize
    )
/*++

Implements:

  IMediaInfo::GetName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetName"),OLESTR("buffer size = <%lu>"), bufferSize);
    try {
        WsbAssertPointer(pName);
        CWsbStringPtr tmpName;
        tmpName = m_Master.name;
        WsbAffirmHr(tmpName.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetName"), OLESTR("hr = <%ls>, Name = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pName));
    return(hr);
}


HRESULT
CMediaInfo::GetCapacity( 
    LONGLONG *pCapacity 
    )
/*++

Implements:

  IMediaInfo::GetCapacity

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCapacity"),OLESTR(""));
    try {
        WsbAssertPointer(pCapacity);
        *pCapacity = m_Master.capacity;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCapacity"), OLESTR("hr = <%ls>, Capacity = <%ls>"), WsbHrAsString(hr), WsbPtrToLonglongAsString(pCapacity));
    return(hr);
}

HRESULT CMediaInfo::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::GetClassID"), OLESTR(""));
    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CMediaInfo;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT
CMediaInfo:: GetCopyName( 
    USHORT copyNumber, 
    OLECHAR **pName,
    ULONG   bufferSize
    )
/*++

Implements:

  IMediaInfo::GetCopyName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyName"),OLESTR(""));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pName);
        CWsbStringPtr tmpString;
        tmpString = m_Copy[copyNumber - 1].name;
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyName"), OLESTR("hr = <%ls>, Name = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pName));
    return(hr);
}

HRESULT
CMediaInfo:: GetCopyNextRemoteDataSet( 
    USHORT copyNumber, 
    SHORT  *pNextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::GetCopyNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyNextRemoteDataSet"),OLESTR(""));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pNextRemoteDataSet);
        *pNextRemoteDataSet = m_Copy[copyNumber - 1].nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyNextRemoteDataSet"), OLESTR("hr = <%ls>, NextRemoteDataSet = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyDescription( 
    USHORT copyNumber, 
    OLECHAR **pDescription,
    ULONG   bufferSize
    )       
/*++

Implements:

  IMediaInfo::GetCopyDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyDescription"),OLESTR("Copy = <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pDescription);
        CWsbStringPtr tmpDescription;
        tmpDescription = m_Copy[copyNumber - 1].description;
        WsbAffirmHr(tmpDescription.CopyTo(pDescription, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyDescription"), OLESTR("hr = <%ls>, CopyDescription = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pDescription));
    return(hr);
}


HRESULT
CMediaInfo::GetCopyInfo( 
    USHORT copyNumber, 
    GUID *pMediaSubsystemId, 
    OLECHAR **pDescription, 
    ULONG   descriptionBufferSize,
    OLECHAR **pName, 
    ULONG   nameBufferSize,
    FILETIME *pUpdate, 
    HRESULT *pLastError,
    SHORT  *pNextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::GetCopyInfo

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyInfo"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        if (pMediaSubsystemId != 0)  {
            *pMediaSubsystemId = m_Copy[copyNumber - 1].id;
        }
        if (pDescription != 0)  {
            CWsbStringPtr tmpDescription;
            tmpDescription = m_Copy[copyNumber - 1].description;
            tmpDescription.CopyTo(pDescription, descriptionBufferSize);
        }
        if (pName != 0)  {
            CWsbStringPtr tmpString;
            tmpString = m_Copy[copyNumber - 1].name;
            tmpString.CopyTo(pName, nameBufferSize);
        }
        if (pUpdate != 0)  {
            *pUpdate = m_Copy[copyNumber - 1].lastUpdate;
        }
        if (pLastError != 0 )  {
            *pLastError = m_Copy[copyNumber - 1].lastError;
        }
    
        if (pNextRemoteDataSet != 0 )  {
            *pNextRemoteDataSet = m_Copy[copyNumber - 1].nextRemoteDataSet;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyInfo"), 
            OLESTR("hr = <%ls>, SubSystemID = <%ls>, Description = <%ls>, Name = <%ls>, Update = <%ls>, LastError = <%ls>, NextRemoteDataSet = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSubsystemId), 
            WsbQuickString(WsbPtrToStringAsString(pDescription)), WsbQuickString(WsbPtrToStringAsString(pName)),
            WsbPtrToFiletimeAsString(FALSE, pUpdate), WsbPtrToHrAsString(pLastError),
            WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyLastError( 
    USHORT copyNumber, 
    HRESULT *pLastError 
    )
/*++

Implements:

  IMediaInfo::GetCopyLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyLastError"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pLastError); 
        *pLastError = m_Copy[copyNumber - 1].lastError;                               
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyLastError"), OLESTR("hr = <%ls>, Last Error = <%ls>"), WsbHrAsString(hr), WsbPtrToHrAsString(pLastError));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyMediaSubsystemId( 
    USHORT copyNumber, 
    GUID *pMediaSubsystemId 
    )
/*++

Implements:

  IMediaInfo::GetCopyMediaSubsystemId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyMediaSubsystemId"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pMediaSubsystemId); 
        *pMediaSubsystemId = m_Copy[copyNumber - 1].id;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyMediaSubsystemId"), OLESTR("hr = <%ls>, ID = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSubsystemId));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyUpdate(
    USHORT copyNumber, 
    FILETIME *pUpdate 
    )
/*++

Implements:

  IMediaInfo::GetCopyUpdate

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyUpdate"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pUpdate);
        *pUpdate = m_Copy[copyNumber - 1].lastUpdate;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyUpdate"), OLESTR("hr = <%ls>, Update = <%ls>"), WsbHrAsString(hr), WsbPtrToFiletimeAsString(FALSE,pUpdate));
    return(hr);
}

HRESULT
CMediaInfo::GetDescription(
    OLECHAR **pDescription,
    ULONG bufferSize
    )
/*++

Implements:

  IMediaInfo::GetDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetDescription"),OLESTR(""));
    try {
        WsbAssertPointer(pDescription);
        CWsbStringPtr tmpDescription;
        tmpDescription = m_Master.description;
        WsbAffirmHr(tmpDescription.CopyTo(pDescription, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetDescription"), OLESTR("hr = <%ls>, Description = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pDescription));
    return(hr);
}

HRESULT
CMediaInfo::GetFreeBytes( 
    LONGLONG *pFreeBytes
    )
/*++

Implements:

  IMediaInfo::GetFreeBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetFreeBytes"),OLESTR(""));
    try {
        WsbAssertPointer(pFreeBytes);
        *pFreeBytes = m_Master.freeBytes;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetFreeBytes"), OLESTR("hr = <%ls>, Free Space = <%ls>"), WsbHrAsString(hr), WsbPtrToLonglongAsString(pFreeBytes));
    return(hr);
}

HRESULT
CMediaInfo::GetId(
    GUID *pId
    )
/*++

Implements:

  IMediaInfo::GetId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetId"),OLESTR(""));
    try {
        WsbAssertPointer(pId);
        *pId = m_Master.id;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetId"), OLESTR("hr = <%ls>, Id = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pId));
    return(hr);
}

HRESULT
CMediaInfo::GetLastError(
    HRESULT *pLastError
    )
/*++

Implements:

  IMediaInfo::GetLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLastError"),OLESTR(""));
    try {
        WsbAssertPointer(pLastError);
        *pLastError = m_Master.lastError;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetLastError"), OLESTR("hr = <%ls>, LastError = <%ls>"), WsbHrAsString(hr), WsbPtrToHrAsString(pLastError));
    return(hr);
}

HRESULT
CMediaInfo::GetLogicalValidBytes(
    LONGLONG *pLogicalValidBytes
    )
/*++

Implements:

  IMediaInfo::GetLogicalValidBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLogicalValidBytes"),OLESTR(""));
    try {
        WsbAssertPointer(pLogicalValidBytes);
        *pLogicalValidBytes = m_LogicalValidBytes;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetLogicalValidBytes"), OLESTR("hr = <%ls>, LogicalValidBytes = <%ls>"), WsbHrAsString(hr), WsbPtrToLonglongAsString(pLogicalValidBytes));
    return(hr);
}

HRESULT
CMediaInfo::GetMediaInfo( 
    GUID* pMediaId, 
    GUID *pMediaSubsystemId, 
    GUID *pStoragePoolId, 
    LONGLONG *pFreeBytes, 
    LONGLONG *pCapacity, 
    HRESULT *pLastError, 
    SHORT *pNextRemoteDataSet, 
    OLECHAR **pDescription,
    ULONG descriptionBufferSize,
    HSM_JOB_MEDIA_TYPE *pType,
    OLECHAR **pName,
    ULONG nameBufferSize,
    BOOL *pRecallOnly,
    FILETIME *pUpdate,
    LONGLONG *pLogicalValidBytes,
    BOOL *pRecreate
    )
/*++

Implements:

  IMediaInfo::GetMediaInfo

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetMediaInfo"),OLESTR(""));
    try {
        //Make sure we can provide data memebers
        if (0 != pMediaId)  {
            *pMediaId = m_Master.id;
        }
        
        if (0 != pMediaSubsystemId)  {
            *pMediaSubsystemId = m_Master.ntmsId;
        }
        if (0 != pStoragePoolId)  {
            *pStoragePoolId = m_Master.storagePoolId;
        }
        if (0 != pDescription)  {
            CWsbStringPtr tmpString;
            tmpString = m_Master.description;
            WsbAffirmHr(tmpString.CopyTo(pDescription, descriptionBufferSize));
        }
        if (0 != pName)  {
            CWsbStringPtr tmpString;
            tmpString = m_Master.name;
            tmpString.CopyTo(pName, nameBufferSize);
        }
        if (0 != pType)  {
            *pType = m_Master.type;
        }
        if (0 != pUpdate)  {
            *pUpdate = m_Master.lastUpdate;
        }
        if (0 != pLastError)  {
            *pLastError = m_Master.lastError;
        }
        if (0 != pRecallOnly)  {
            *pRecallOnly = m_Master.recallOnly;
        }
        if (0 != pFreeBytes)  {
            *pFreeBytes = m_Master.freeBytes;
        }
        if (0 != pCapacity)  {
            *pCapacity = m_Master.capacity;
        }
        if (0 != pNextRemoteDataSet)  {
            *pNextRemoteDataSet = m_Master.nextRemoteDataSet;
        }
        if (0 != pLogicalValidBytes)  {
            *pLogicalValidBytes = m_LogicalValidBytes;
        }
        if (0 != pRecreate)  {
            *pRecreate = m_Recreate;
        }


    } WsbCatch(hr);

    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo id = <%ls>, ntmsId = <%ls>, StgPoolId = <%ls>\n"),
        WsbPtrToGuidAsString(pMediaId), WsbQuickString(WsbPtrToGuidAsString(pMediaSubsystemId)),
        WsbQuickString(WsbPtrToGuidAsString(pStoragePoolId)));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo Free = <%ls>, Cap = <%ls>, Last Error = <%ls>\n"), 
        WsbPtrToLonglongAsString(pFreeBytes),WsbQuickString(WsbPtrToLonglongAsString(pCapacity)),
        WsbPtrToHrAsString(pLastError));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo NextRemoteDataSet = <%ls>, Description = <%ls>, Type = <%ls>\n"), 
        WsbPtrToShortAsString(pNextRemoteDataSet),
        WsbPtrToStringAsString(pDescription),
        WsbQuickString(WsbPtrToShortAsString((SHORT *)pType)));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo Name = <%ls>, RecallOnly = <%ls>, Update = <%ls>\n"),
        WsbQuickString(WsbPtrToStringAsString(pName)),
        WsbQuickString(WsbPtrToBoolAsString(pRecallOnly)),
        WsbPtrToFiletimeAsString(FALSE, pUpdate));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo LogicalValid = <%ls>, Recreate = <%ls>\n"),
        WsbQuickString(WsbPtrToLonglongAsString(pLogicalValidBytes)),
        WsbQuickString(WsbPtrToBoolAsString(pRecreate)));
        
    WsbTraceOut(OLESTR("CMediaInfo::GetMediaInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::GetMediaSubsystemId( 
    GUID *pMediaSubsystemId 
    )
/*++

Implements:

  IMediaInfo::GetMediaSubsystemId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetMediaSubsystemId"),OLESTR(""));
    try {
        WsbAssertPointer(pMediaSubsystemId);
        *pMediaSubsystemId = m_Master.ntmsId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetMediaSubsystemId"), OLESTR("hr = <%ls>, SubsystemID = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSubsystemId));
    return(hr);
}

HRESULT
CMediaInfo::GetNextRemoteDataSet( 
    short *pNextRemoteDataSet 
    )
/*++

Implements:

  IMediaInfo::GetNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetNextRemoteDataSet"),OLESTR(""));
    try {                              
        WsbAssertPointer(pNextRemoteDataSet);
        *pNextRemoteDataSet = m_Master.nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetNextRemoteDataSet"), OLESTR("hr = <%ls>, Next Remote Data Set = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}

HRESULT
CMediaInfo::GetRecallOnlyStatus( 
    BOOL *pRecallOnlyStatus 
    )
/*++

Implements:

  IMediaInfo::GetRecallOnlyStatus

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetRecallOnlyStatus"),OLESTR(""));
    try {
        WsbAssertPointer(pRecallOnlyStatus);
        *pRecallOnlyStatus = m_Master.recallOnly;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetRecallOnlyStatus"), OLESTR("hr = <%ls>, Read only Status = <%ls>"), WsbHrAsString(hr), WsbPtrToBoolAsString(pRecallOnlyStatus));
    return(hr);
}

HRESULT CMediaInfo::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::GetSizeMax"), OLESTR(""));
    try {
        hr = E_NOTIMPL;
        pcbSize = 0;        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));
    return(hr);
}

HRESULT
CMediaInfo::GetStoragePoolId( 
    GUID *pStoragePoolId 
    )
/*++

Implements:

  IMediaInfo::GetStoragePoolId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetStoragePoolId"),OLESTR(""));
    try {
        WsbAssertPointer(pStoragePoolId);
        *pStoragePoolId = m_Master.storagePoolId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetStoragePoolId"), OLESTR("hr = <%ls>, Storage Pool Id = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pStoragePoolId));
    return(hr);
}

HRESULT
CMediaInfo::GetType( 
    HSM_JOB_MEDIA_TYPE *pType 
    )
/*++

Implements:

  IMediaInfo::GetType

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetType"),OLESTR(""));
    try {
        WsbAssertPointer(pType);
        *pType = m_Master.type;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetType"), OLESTR("hr = <%ls>, type = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString((SHORT *)pType));
    return(hr);
}

HRESULT
CMediaInfo::GetUpdate( 
    FILETIME *pUpdate 
    )
/*++

Implements:

  IMediaInfo::GetUpdate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetUpdate"),OLESTR(""));
    try {
        WsbAssertPointer(pUpdate);
        *pUpdate = m_Master.lastUpdate;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetUpdate"), OLESTR("hr = <%ls>, Update = <%ls>"), WsbHrAsString(hr), WsbPtrToFiletimeAsString(FALSE, pUpdate));
    return(hr);
}

HRESULT CMediaInfo::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        ULONG descriptionLen = (ULONG)SEG_DB_MAX_MEDIA_NAME_LEN;
        ULONG nameLen = (ULONG)SEG_DB_MAX_MEDIA_BAR_CODE_LEN;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.ntmsId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.storagePoolId));
        
        m_Master.description.Realloc(SEG_DB_MAX_MEDIA_NAME_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_Master.description, descriptionLen));
        m_Master.name.Realloc(SEG_DB_MAX_MEDIA_BAR_CODE_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_Master.name, nameLen));
        LONG tmpLong;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpLong));
        m_Master.type = (HSM_JOB_MEDIA_TYPE)tmpLong;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.freeBytes));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.capacity));
        WsbAffirmHr(WsbLoadFromStream(pStream, (LONG *)&m_Master.lastError));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.recallOnly));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.lastUpdate));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.nextRemoteDataSet));
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LogicalValidBytes));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Recreate));
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.ntmsId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.storagePoolId));
        
        m_LastKnownGoodMaster.description.Realloc(SEG_DB_MAX_MEDIA_NAME_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_LastKnownGoodMaster.description, descriptionLen));
        m_LastKnownGoodMaster.name.Realloc(SEG_DB_MAX_MEDIA_BAR_CODE_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_LastKnownGoodMaster.name, nameLen));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpLong));
        m_LastKnownGoodMaster.type = (HSM_JOB_MEDIA_TYPE)tmpLong;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.freeBytes));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.capacity));
        WsbAffirmHr(WsbLoadFromStream(pStream, (LONG *)&m_LastKnownGoodMaster.lastError));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.recallOnly));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.lastUpdate));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.nextRemoteDataSet));
        
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++ )  {
            WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Copy[i].id)));
            m_Copy[i].description.Realloc(SEG_DB_MAX_MEDIA_NAME_LEN);
            WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&(m_Copy[i].description), descriptionLen));
            m_Copy[i].name.Realloc(SEG_DB_MAX_MEDIA_BAR_CODE_LEN);
            WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&(m_Copy[i].name), nameLen));
            WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Copy[i].lastUpdate)));
            WsbAffirmHr(WsbLoadFromStream(pStream, (LONG *)&(m_Copy[i].lastError)));
            WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Copy[i].nextRemoteDataSet)));
        }

    } WsbCatch(hr);
    
    WsbTrace(OLESTR("ID = <%ls>, rmsId = <%ls>, stgPoolId = <%ls>\n"),  
        WsbQuickString(WsbGuidAsString(m_Master.id)), 
        WsbQuickString(WsbGuidAsString(m_Master.ntmsId)),
        WsbQuickString(WsbGuidAsString(m_Master.storagePoolId)));
    WsbTrace(OLESTR("Description = <%ls>, name = <%ls>, type = <%u>\n"), 
        (OLECHAR *)m_Master.description,
        (OLECHAR *)m_Master.name,
        m_Master.type);
    WsbTrace(OLESTR("FreeBytes = <%ls>, capacity = <%ls>, lastError = <%ls>\n"),
        WsbQuickString(WsbLonglongAsString(m_Master.freeBytes)),
        WsbQuickString(WsbLonglongAsString(m_Master.capacity)),
        WsbQuickString(WsbHrAsString(m_Master.lastError)));
    WsbTrace(OLESTR("RecallOnly = <%ls>, NextRemotDataSet = <%u>\n"),   
        WsbBoolAsString(m_Master.recallOnly),
        m_Master.nextRemoteDataSet);
    WsbTrace(OLESTR("LastUpdate = <%ls>, logicalValidBytes = <%ls>, Recreate = <%ls>\n"),    
        WsbFiletimeAsString(FALSE, m_Master.lastUpdate),
        WsbLonglongAsString(m_LogicalValidBytes),
        WsbBoolAsString(m_Recreate));
    
    
    WsbTraceOut(OLESTR("CMediaInfo::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT CMediaInfo::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" id = %ls,"), 
                WsbGuidAsString(m_Master.id)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" ntmsId = %ls,"), 
                WsbGuidAsString(m_Master.ntmsId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" StoragePoolId = %ls,"), 
                WsbGuidAsString(m_Master.storagePoolId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RS Media Name = %ls,"), (OLECHAR *)m_Master.description));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RMS Media Name = %ls,"), (OLECHAR *)m_Master.name));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Media Type = %u,"), m_Master.type));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Update = %ls,"), 
                WsbFiletimeAsString(FALSE, m_Master.lastUpdate)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Error = %ls,"), WsbHrAsString(m_Master.lastError)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Is Recall Only = %ls,"), WsbBoolAsString(m_Master.recallOnly)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Free Bytes = %ls,"), 
                WsbQuickString(WsbLonglongAsString(m_Master.freeBytes))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Capacity = %ls,"),
                WsbQuickString(WsbLonglongAsString(m_Master.capacity))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Logical Valid Bytes = %ls,"),
                WsbQuickString(WsbLonglongAsString(m_LogicalValidBytes))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" NextRemoteDataSet = %u,"), m_Master.nextRemoteDataSet));
        
        WsbAffirmHr(CWsbDbEntity::Print(pStream));
        //
        // Last Known Good Master
        //
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n   Last Known Good id = %ls,"), 
            WsbGuidAsString(m_LastKnownGoodMaster.id)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" ntmsId = %ls,"), 
                WsbGuidAsString(m_LastKnownGoodMaster.ntmsId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" StoragePoolId = %ls,"), 
                WsbGuidAsString(m_LastKnownGoodMaster.storagePoolId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RS Media Name = %ls,"), (OLECHAR *)m_LastKnownGoodMaster.description));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RMS Media Name = %ls,"), (OLECHAR *)m_LastKnownGoodMaster.name));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Media Type = %u,"), m_LastKnownGoodMaster.type));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Update = %ls,"), 
                WsbFiletimeAsString(FALSE, m_LastKnownGoodMaster.lastUpdate)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Error = %ls,"), WsbHrAsString(m_LastKnownGoodMaster.lastError)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Is Recall Only = %ls,"), WsbBoolAsString(m_LastKnownGoodMaster.recallOnly)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Free Bytes = %ls,"), 
                WsbQuickString(WsbLonglongAsString(m_LastKnownGoodMaster.freeBytes))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Capacity = %ls,"),
                WsbQuickString(WsbLonglongAsString(m_LastKnownGoodMaster.capacity))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" NextRemoteDataSet = %u,"), m_LastKnownGoodMaster.nextRemoteDataSet));
        //
        // Media Copies
        //
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++ )  {
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n   RS Media Copy %d RMS ID = %ls,") ,(i+1), WsbGuidAsString(m_Copy[i].id)));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RS Media Name = %ls,") , (OLECHAR *)m_Copy[i].description));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RMS Media Name = %ls,") , (OLECHAR *)m_Copy[i].name));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Update = %ls,") , WsbFiletimeAsString(FALSE,m_Copy[i].lastUpdate)));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Error = %ls,") , WsbHrAsString(m_Copy[i].lastError)));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" NextRemoteDataSet = %u,") , m_Copy[i].nextRemoteDataSet));
        }

        

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CMediaInfo::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    WsbTrace(OLESTR("ID = <%ls>, rmsId = <%ls>, stgPoolId = <%ls>\n"),
        WsbQuickString(WsbGuidAsString(m_Master.id)), 
        WsbQuickString(WsbGuidAsString(m_Master.ntmsId)),
        WsbQuickString(WsbGuidAsString(m_Master.storagePoolId)));
    WsbTrace(OLESTR("Description = <%ls>, name = <%ls>, type = <%u>\n"),
        (OLECHAR *)m_Master.description,
        (OLECHAR *)m_Master.name,
        m_Master.type);
    WsbTrace(OLESTR("FreeBytes = <%ls>, capacity = <%ls>, lastError = <%ls>\n"), 
        WsbQuickString(WsbLonglongAsString(m_Master.freeBytes)),
        WsbQuickString(WsbLonglongAsString(m_Master.capacity)),
        WsbHrAsString(m_Master.lastError));
    WsbTrace(OLESTR("RecallOnly = <%ls>, NextRemotDataSet = <%u>\n"),
        WsbBoolAsString(m_Master.recallOnly),
        m_Master.nextRemoteDataSet);
    WsbTrace(OLESTR("LastUpdate = <%ls>, logicalValidBytes = <%ls>, Recreate = <%ls>\n"),    
        WsbFiletimeAsString(FALSE, m_Master.lastUpdate),
        WsbLonglongAsString(m_LogicalValidBytes),
        WsbBoolAsString(m_Recreate));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.ntmsId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.storagePoolId));
        
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_Master.description));
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_Master.name));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_Master.type));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.freeBytes));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.capacity));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_Master.lastError));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.recallOnly));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.lastUpdate));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.nextRemoteDataSet));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_LogicalValidBytes));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Recreate));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.ntmsId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.storagePoolId));
        
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_LastKnownGoodMaster.description));
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_LastKnownGoodMaster.name));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_LastKnownGoodMaster.type));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.freeBytes));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.capacity));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_LastKnownGoodMaster.lastError));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.recallOnly));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.lastUpdate));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.nextRemoteDataSet));
        
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++ )  {
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].id));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].description));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].name));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].lastUpdate));
            WsbAffirmHr(WsbSaveToStream(pStream, (LONG)(m_Copy[i].lastError)));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].nextRemoteDataSet));
        }

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMediaInfo::SetName(
    OLECHAR *name
    )
/*++

Implements:

  IMediaInfo::SetName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetName"),OLESTR("Name = <%ls>"), name);
    try {
        WsbAssertPointer(name);
        m_Master.name = name;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCapacity( 
    LONGLONG capacity
    )
/*++

Implements:

  IMediaInfo::SetCapacity

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCapacity"),OLESTR("Capacity = <%ls>"), WsbLonglongAsString(capacity));
    try {
        m_Master.capacity = capacity;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCapacity"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyName( 
    USHORT copyNumber, 
    OLECHAR *name
    ) 
/*++

Implements:

  IMediaInfo::SetCopyName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyName"),OLESTR("copy = <%u>, Name = <%ls>"), copyNumber, name);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].name = name;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyNextRemoteDataSet( 
    USHORT copyNumber, 
    SHORT nextRemoteDataSet
    ) 
/*++

Implements:

  IMediaInfo::SetCopyNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyNextRemoteDataSet"),OLESTR("copy = <%u>, NextRemoteDataSet = <%d>"), copyNumber, nextRemoteDataSet);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].nextRemoteDataSet = nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyNextRemoteDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyDescription( 
    USHORT copyNumber, 
    OLECHAR *description
    ) 
/*++

Implements:

  IMediaInfo::SetCopyDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyDescription"),OLESTR("copy = <%u>, description = <%ls>"), copyNumber, description);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].description = description;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyDescription"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyInfo( 
    USHORT copyNumber, 
    GUID mediaSubsystemId, 
    OLECHAR *description, 
    OLECHAR *name, 
    FILETIME update, 
    HRESULT lastError,
    SHORT  nextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::SetCopyInfo

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyInfo"),OLESTR("copy = <%u>, SubsystemId = <%ls>, Description = <%ls>, Name = <%ls>, update = <%ls>, lastError = <%ls>, NextRemoteDataSet = <%d> "),
    copyNumber, WsbGuidAsString(mediaSubsystemId), description, name, WsbFiletimeAsString(FALSE, update),WsbHrAsString(lastError));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].id = mediaSubsystemId;
        m_Copy[copyNumber - 1].description = description;
        m_Copy[copyNumber - 1].name = name;
        m_Copy[copyNumber - 1].lastUpdate = update;
        m_Copy[copyNumber - 1].lastError = lastError;
        m_Copy[copyNumber - 1].nextRemoteDataSet = nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyLastError( 
    USHORT copyNumber, 
    HRESULT lastError 
    )
/*++

Implements:

  IMediaInfo::SetCopyLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyLastError"),OLESTR("Last Error = <%ls>"), WsbHrAsString(lastError));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].lastError = lastError;        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyLastError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyMediaSubsystemId( 
    USHORT copyNumber, 
    GUID mediaSubsystemId 
    ) 
/*++

Implements:

  IMediaInfo::SetCopyMediaSubsystemId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyMediaSubsystemId"),OLESTR("SubsystemId = <%ls>"), WsbGuidAsString(mediaSubsystemId));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].id = mediaSubsystemId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyMediaSubsystemId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyUpdate( 
    USHORT copyNumber, 
    FILETIME update 
    ) 
/*++

Implements:

  IMediaInfo::SetCopyUpdate

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyUpdate"),OLESTR("update = <%ls>"), WsbFiletimeAsString(FALSE, update));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].lastUpdate = update;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyUpdate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetDescription(
    OLECHAR *description 
    )
/*++

Implements:

  IMediaInfo::SetDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetDescription"),OLESTR("description = <%ls>"), description);
    try {
        WsbAssertPointer(description);
        m_Master.description = description;    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetDescription"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetFreeBytes( 
    LONGLONG FreeBytes 
    )
/*++

Implements:

  IMediaInfo::SetFreeBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetFreeBytes"),OLESTR("Free Space = <%ls>"), WsbLonglongAsString(FreeBytes));
    try {
        m_Master.freeBytes = FreeBytes;    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetFreeBytes"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetId( 
    GUID id
    )
/*++

Implements:

  IMediaInfo::SetId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetId"),OLESTR("ID = <%ls>"), WsbGuidAsString(id));
    try {
        m_Master.id = id;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetLastError( 
    HRESULT lastError
    )
/*++

Implements:

  IMediaInfo::SetLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetLastError"),OLESTR("last error = <%ls>"), WsbHrAsString(lastError));
    try {
        m_Master.lastError = lastError;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetLastError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetLogicalValidBytes(
    LONGLONG logicalValidBytes
    )
/*++

Implements:

  IMediaInfo::SetLogicalValidBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetLogicalValidBytes"),OLESTR("LogicalValidBytes = <%ls>"), WsbLonglongAsString(logicalValidBytes));
    try {
        m_LogicalValidBytes = logicalValidBytes;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetLogicalValidBytes"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CMediaInfo::SetMediaInfo
(
    GUID mediaId, 
    GUID mediaSubsystemId,
    GUID storagePoolId,
    LONGLONG FreeBytes,
    LONGLONG Capacity,
    HRESULT lastError,
    short nextRemoteDataSet,
    OLECHAR *description,
    HSM_JOB_MEDIA_TYPE type,
    OLECHAR *name,
    BOOL RecallOnly,
    FILETIME update,
    LONGLONG logicalValidBytes,
    BOOL recreate
    )
 /*++

Implements:

  IMediaInfo::SetMediaInfo().

--*/
{
    WsbTraceIn(OLESTR("CMediaInfo::SetMediaInfo"), OLESTR(""));
    
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo id = <%ls>, SubsystemId = <%ls>, StoragePoolId = <%ls>\n"), 
        WsbGuidAsString(mediaId), 
        WsbQuickString(WsbGuidAsString(mediaSubsystemId)), 
        WsbQuickString(WsbGuidAsString(storagePoolId)));
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo FreeBytes = <%ls>, Capacity = <%ls>, lastError = <%ls>\n"),
        WsbLonglongAsString(FreeBytes), 
        WsbQuickString(WsbLonglongAsString(Capacity)), 
        WsbHrAsString(lastError));
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo NextRemoteDataSet = <%d>, Description = <%ls>, Type = <%d>\n"), 
        nextRemoteDataSet, 
        (OLECHAR *)description, 
        type);
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo Name = <%ls>, RecallOnly = <%ls>, update = <%ls>\n"), 
        (OLECHAR *)name,
        WsbBoolAsString(RecallOnly),
        WsbFiletimeAsString(FALSE, update));
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo logicalValidBytes = <%ls>, recreate = <%ls>\n)"), 
        WsbLonglongAsString(logicalValidBytes), WsbBoolAsString(m_Recreate));

    m_isDirty = TRUE;
    
    m_Master.id = mediaId;
    m_Master.ntmsId = mediaSubsystemId;
    m_Master.storagePoolId = storagePoolId;
    m_Master.freeBytes = FreeBytes;
    m_Master.capacity = Capacity;
    m_Master.lastError = lastError;
    m_Master.description = description;
    m_Master.type = type;
    m_Master.name = name;
    m_Master.recallOnly = RecallOnly;
    m_Master.lastUpdate = update;
    m_Master.nextRemoteDataSet = nextRemoteDataSet;
    
    m_LogicalValidBytes = logicalValidBytes;
    m_Recreate = recreate;
    
    WsbTraceOut(OLESTR("CMediaInfo::SetMediaInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}

HRESULT
CMediaInfo::SetMediaSubsystemId( 
    GUID mediaSubsystemId 
    )
/*++

Implements:

  IMediaInfo::SetMediaSubsystemId 

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetMediaSubsystemId "),OLESTR("Subsystem Id = <%ls>"),
            WsbGuidAsString(mediaSubsystemId));
    try {
        m_Master.ntmsId = mediaSubsystemId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetMediaSubsystemId "), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetNextRemoteDataSet( 
    short nextRemoteDataSet 
    )
/*++

Implements:

  IMediaInfo::SetNextRemoteDataSet 

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetNextRemoteDataSet"),OLESTR("Data Set = <%u>"), nextRemoteDataSet);
    try {
        m_Master.nextRemoteDataSet = nextRemoteDataSet;
        m_LastKnownGoodMaster.nextRemoteDataSet = nextRemoteDataSet;

        //
        // Handle exception case where a copy reports more data sets than the
        // master.  This occurs when we increment the data set count, but
        // never write to the media, then create a media copy, then write
        // to the master which decrements the data set count to handle the
        // missing data set, then finally increment the data set count.
        for (int i=0; i< HSM_MAX_NUMBER_MEDIA_COPIES; i++) {
            if (m_Copy[i].nextRemoteDataSet > 0) {
                if (nextRemoteDataSet < m_Copy[i].nextRemoteDataSet) {
                    WsbAssert(nextRemoteDataSet+1 == m_Copy[i].nextRemoteDataSet, E_UNEXPECTED);
                    m_Copy[i].nextRemoteDataSet--;
                }
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetNextRemoteDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetRecallOnlyStatus( 
    BOOL RecallOnlyStatus 
    )
/*++

Implements:

  IMediaInfo::SetRecallOnlyStatus

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetRecallOnlyStatus"),OLESTR("Read Only Status = <%ls>"), 
        WsbBoolAsString(RecallOnlyStatus));
    try {
        m_Master.recallOnly = RecallOnlyStatus;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetRecallOnlyStatus"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetStoragePoolId( 
    GUID storagePoolId 
    )
/*++

Implements:

  IMediaInfo::SetStoragePoolId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetStoragePoolId"),OLESTR("Storage Pool Id = <%ls>"),
        WsbGuidAsString(storagePoolId));
    try {
        m_Master.storagePoolId = storagePoolId;    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetStoragePoolId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetType( 
    HSM_JOB_MEDIA_TYPE type 
    )
/*++

Implements:

  IMediaInfo::SetType

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetType"),OLESTR("type = <%u>"), (USHORT)type);
    try {
        m_Master.type = type;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetUpdate( 
    FILETIME update 
    )
/*++

Implements:

  IMediaInfo::SetUpdate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetUpdate"),OLESTR("Update = <%ls>"),
        WsbFiletimeAsString(FALSE, update));
    try {
        m_Master.lastUpdate = update;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetUpdate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT 
CMediaInfo::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IMediaInfo>     pMediaInfo1;
    CComPtr<IMediaInfo>     pMediaInfo2;

    WsbTraceIn(OLESTR("CMediaInfo::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
    
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::Test"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}



HRESULT 
CMediaInfo::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::UpdateKey"),OLESTR(""));
    try {
        WsbAffirmHr(pKey->SetToGuid(m_Master.id));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::UpdateKey"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetRecreate( 
    BOOL recreate
    )
/*++

Implements:

  IMediaInfo::SetRecreate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetRecreate"),OLESTR("Recreate = <%ls>"), WsbBoolAsString(recreate));
    try {
        m_Recreate = recreate;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetRecreate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CMediaInfo::GetRecreate( 
    BOOL *pRecreate
    )
/*++

Implements:

  IMediaInfo::GetRecreate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetRecreate"),OLESTR(""));
    try {
    
        WsbAssertPointer(pRecreate);
        *pRecreate = m_Recreate;
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetRecreate"), OLESTR("hr = <%ls>, recreate = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToBoolAsString(pRecreate));
    return(hr);
}


HRESULT
CMediaInfo::GetLastKnownGoodMasterInfo( 
    GUID* pId, 
    GUID *pNtmsId, 
    GUID *pStoragePoolId, 
    LONGLONG *pFreeBytes, 
    LONGLONG *pCapacity, 
    HRESULT *pLastError, 
    OLECHAR **pDescription, 
    ULONG descriptionBufferSize,
    HSM_JOB_MEDIA_TYPE *pType,
    OLECHAR **pName,
    ULONG nameBufferSize,
    BOOL *pRecallOnly,
    FILETIME *pUpdate,
    SHORT *pNextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::GetLastKnownGoodMasterInfo

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo"),OLESTR(""));
    try {
        //Make sure we can provide data memebers
        if (0 != pId)  {
            *pId = m_LastKnownGoodMaster.id;
        }
        
        if (0 != pNtmsId)  {
            *pNtmsId = m_LastKnownGoodMaster.ntmsId;
        }
        if (0 != pStoragePoolId)  {
            *pStoragePoolId = m_LastKnownGoodMaster.storagePoolId;
        }
        if (0 != pDescription)  {
            CWsbStringPtr tmpString;
            tmpString = m_LastKnownGoodMaster.description;
            tmpString.CopyTo(pDescription, descriptionBufferSize);
        }
        if (0 != pName)  {
            CWsbStringPtr tmpString;
            tmpString = m_LastKnownGoodMaster.name;
            tmpString.CopyTo(pName, nameBufferSize);
        }
        if (0 != pType)  {
            *pType = m_LastKnownGoodMaster.type;
        }
        if (0 != pUpdate)  {
            *pUpdate = m_LastKnownGoodMaster.lastUpdate;
        }
        if (0 != pLastError)  {
            *pLastError = m_LastKnownGoodMaster.lastError;
        }
        if (0 != pRecallOnly)  {
            *pRecallOnly = m_LastKnownGoodMaster.recallOnly;
        }
        if (0 != pFreeBytes)  {
            *pFreeBytes = m_LastKnownGoodMaster.freeBytes;
        }
        if (0 != pCapacity)  {
            *pCapacity = m_LastKnownGoodMaster.capacity;
        }
        if (0 != pNextRemoteDataSet)  {
            *pNextRemoteDataSet = m_LastKnownGoodMaster.nextRemoteDataSet;
        }


    } WsbCatch(hr);

    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Id = <%ls>, ntmsId = <%ls>, StgPoolId = <%ls>\n"),
        WsbPtrToGuidAsString(pId), WsbQuickString(WsbPtrToGuidAsString(pNtmsId)),
        WsbQuickString(WsbPtrToGuidAsString(pStoragePoolId)));
    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Free = <%ls>, Cap = <%ls>, Last Error = <%ls>\n"), 
        WsbPtrToLonglongAsString(pFreeBytes),WsbQuickString(WsbPtrToLonglongAsString(pCapacity)),
        WsbPtrToHrAsString(pLastError));
    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Description = <%ls>, Type = <%d)\n"), 
        WsbPtrToStringAsString(pDescription),
        WsbQuickString(WsbPtrToShortAsString((SHORT *)pType)));
    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Name = <%ls>, RecallOnly = <%ls>, Update = <%ls>, NextRemoteDataSet = <%ls>\n"),
        WsbQuickString(WsbPtrToStringAsString(pName)),
        WsbQuickString(WsbPtrToBoolAsString(pRecallOnly)),
        WsbPtrToFiletimeAsString(FALSE, pUpdate),
        WsbPtrToShortAsString(pNextRemoteDataSet));
        
    WsbTraceOut(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo"),   OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::GetLKGMasterNextRemoteDataSet( 
    short *pNextRemoteDataSet 
    )
/*++

Implements:

  IMediaInfo::GetLKGMasterNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLKGMasterNextRemoteDataSet"),OLESTR(""));
    try {                              
        WsbAssertPointer(pNextRemoteDataSet);
        *pNextRemoteDataSet = m_LastKnownGoodMaster.nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetLKGMasterNextRemoteDataSet"), OLESTR("hr = <%ls>, Next Last-Known-Good-Master Remote-Data-Set = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}


HRESULT 
CMediaInfo::SetLastKnownGoodMasterInfo
(
    GUID mediaId, 
    GUID mediaSubsystemId,
    GUID storagePoolId,
    LONGLONG FreeBytes,
    LONGLONG Capacity,
    HRESULT lastError,
    OLECHAR *description,
    HSM_JOB_MEDIA_TYPE type,
    OLECHAR *name,
    BOOL RecallOnly,
    FILETIME update,
    SHORT nextRemoteDataSet
    )
 /*++

Implements:

  IMediaInfo::SetLastKnownGoodMasterInfo().

--*/
{
    WsbTraceIn(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR(""));
    
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("id = <%ls>, SubsystemId = <%ls>, StoragePoolId = <%ls>\n"), 
        WsbGuidAsString(mediaId), 
        WsbQuickString(WsbGuidAsString(mediaSubsystemId)), 
        WsbQuickString(WsbGuidAsString(storagePoolId)));
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("FreeBytes = <%ls>, Capacity = <%ls>, lastError = <%ls>\n"),
        WsbLonglongAsString(FreeBytes), 
        WsbQuickString(WsbLonglongAsString(Capacity)), 
        WsbHrAsString(lastError));
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("Description = <%ls>, Type = <%d>\n"), 
        (OLECHAR *)description, 
        type);
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("Name = <%ls>, RecallOnly = <%ls>, update = <%ls>, nextRemoteDataSet = <%d>\n"), 
        (OLECHAR *)name,
        WsbBoolAsString(RecallOnly),
        WsbFiletimeAsString(FALSE, update),
        nextRemoteDataSet);

    m_isDirty = TRUE;
    
    m_LastKnownGoodMaster.id = mediaId;
    m_LastKnownGoodMaster.ntmsId = mediaSubsystemId;
    m_LastKnownGoodMaster.storagePoolId = storagePoolId;
    m_LastKnownGoodMaster.freeBytes = FreeBytes;
    m_LastKnownGoodMaster.capacity = Capacity;
    m_LastKnownGoodMaster.lastError = lastError;
    m_LastKnownGoodMaster.description = description;
    m_LastKnownGoodMaster.type = type;
    m_LastKnownGoodMaster.name = name;
    m_LastKnownGoodMaster.recallOnly = RecallOnly;
    m_LastKnownGoodMaster.lastUpdate = update;
    m_LastKnownGoodMaster.nextRemoteDataSet = nextRemoteDataSet;

    WsbTraceOut(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}



HRESULT
CMediaInfo::DeleteCopy( 
    USHORT copyNumber
    ) 
/*++

Implements:

  IMediaInfo::DeleteCopy

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::DeleteCopy"),OLESTR("copy = <%u>"), copyNumber);
    try {
        //
        // Make sure we have a valid copy number
        //
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        
        //
        // Null out the existing copy information
        //
        m_Copy[copyNumber - 1].id = GUID_NULL;
        m_Copy[copyNumber - 1].description = "";
        m_Copy[copyNumber - 1].name = "";
        m_Copy[copyNumber - 1].lastUpdate = WsbLLtoFT(0);
        m_Copy[copyNumber - 1].lastError = S_OK;
        m_Copy[copyNumber - 1].nextRemoteDataSet = 0;
        
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::DeleteCopy"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CMediaInfo::RecreateMaster( void )
/*++

Implements:

  IMediaInfo::RecreateMaster

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::RecreateMaster"),OLESTR(""));
    try {
        //
        // Mark the master as one that needs to be recreated
        //
        m_Recreate = TRUE;
        
        //
        // Also, make sure we don't add data to this master
        //
        m_Master.recallOnly = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::RecreateMaster"), OLESTR("hr = <%ls>"), 
                                                        WsbHrAsString(hr));
    return(hr);
}


//
// Internal (non COM) Helper functions
//


HRESULT
CMediaInfo::UpdateLastKnownGoodMaster( void )
/*++

Implements:

  IMediaInfo::UpdateLastKnownGoodMaster

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::UpdateLastKnownGoodMaster"),OLESTR(""));

    m_LastKnownGoodMaster.id = m_Master.id;
    m_LastKnownGoodMaster.ntmsId = m_Master.ntmsId;
    m_LastKnownGoodMaster.storagePoolId = m_Master.storagePoolId;
    m_LastKnownGoodMaster.freeBytes = m_Master.freeBytes;
    m_LastKnownGoodMaster.capacity = m_Master.capacity;
    m_LastKnownGoodMaster.lastError = m_Master.lastError;
    m_LastKnownGoodMaster.description = m_Master.description;
    m_LastKnownGoodMaster.type = m_Master.type;
    m_LastKnownGoodMaster.name = m_Master.name;
    m_LastKnownGoodMaster.recallOnly = m_Master.recallOnly;
    m_LastKnownGoodMaster.lastUpdate = m_Master.lastUpdate;
    m_LastKnownGoodMaster.nextRemoteDataSet = m_Master.nextRemoteDataSet;

    WsbTraceOut(OLESTR("CMediaInfo::UpdateLastKnownGoodMaster"), OLESTR("hr = <%ls>"), 
        WsbHrAsString(hr));
    return(hr);
}



HRESULT
CMediaInfo::WriteToDatabase( void )
/*++

Routine Description:

  This function writes the information to the metadata
  database.  Note all other set functions require the
  caller to call the Write() funtion for the entity.

Arguments:

  None

Return Value:
  
  S_OK: If the LastKnownGoodMaster is to be updated
  

--*/

{ 
    HRESULT                     hr = S_OK; 
    BOOLEAN                     openedDb = FALSE;
    CComPtr<IWsbDb>             pSegmentDb;
    CComPtr<IMediaInfo>         pMediaInfo;
    CComPtr<IHsmServer>         pServer;
    CComPtr<IWsbDbSession>      pDbSession;

    WsbTraceIn(OLESTR("CMediaInfo::WriteToDatabase"),OLESTR(""));
    try {
        //
        // Find the database containing the record that matches this 
        // collectable.  
        //
        WsbAffirmHr(CoCreateInstance( CLSID_HsmServer, 0, CLSCTX_SERVER, IID_IHsmServer, (void **)&pServer ));
        WsbAffirmHr(pServer->GetSegmentDb(&pSegmentDb));
        
        //
        // Find the database entity
        //
        WsbAffirmHr(pSegmentDb->Open(&pDbSession));
        openedDb = TRUE;
        WsbTrace(OLESTR("CMediaInfo::WriteToDatabase - Opened the database\n"));
        WsbAffirmHr(pSegmentDb->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                       (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(m_Master.id));
        WsbAffirmHr(pMediaInfo->FindEQ());
        
        // 
        // Write the changes to the database.  To be sure that the "outside" world
        // doesn't change anything but the allowed fields, just set the fields that are
        // allowed to be changed.
        //
        WsbAffirmHr(pMediaInfo->SetRecreate(m_Recreate));
        WsbAffirmHr(SetRecallOnlyStatus(m_Master.recallOnly));
        for (int i = 1; i <= HSM_MAX_NUMBER_MEDIA_COPIES; i++)  {
            WsbAffirmHr(pMediaInfo->SetCopyInfo( (SHORT)i, 
                                                m_Copy[i-1].id,
                                                (OLECHAR *)m_Copy[i-1].description, 
                                                (OLECHAR *)m_Copy[i-1].name, 
                                                m_Copy[i-1].lastUpdate,
                                                m_Copy[i-1].lastError,
                                                m_Copy[i-1].nextRemoteDataSet));
        }            
        WsbAffirmHr(pMediaInfo->Write());
        
    } WsbCatch(hr);

    if (openedDb) {
        WsbTrace(OLESTR("CMediaInfo::WriteToDatabase - Closing the database\n"));
        pSegmentDb->Close(pDbSession);
        pDbSession = 0;
        openedDb = FALSE;
    }
    
    WsbTraceOut(OLESTR("CMediaInfo::WriteToDatabase"), OLESTR("hr = <%ls>"), 
        WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by task.rc
//
#define IDS_TSKMGR_DESC                 1
#define IDS_HSMTSKMGR_DESC             10
#define IDS_SEGREC_DESC                20
#define IDS_BAGHOLE_DESC               30
#define IDS_MEDIAINFO_DESC             40
#define IDS_BAGINFO_DESC               50
#define IDS_SEGDB_DESC                 60
#define IDS_HSMWORKQUEUE_DESC          70
#define IDS_HSMWORKITEM_DESC           80
#define IDS_VOLASSIGN_DESC             90

#define IDR_CHsmTskMgr                      1
#define IDR_CHsmWorkQueue                   101
#define IDR_CHsmWorkItem                    201
#define IDR_CHsmRecallQueue                 301
#define IDR_CHsmRecallItem                  401

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\medinfo.h ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    medinfo.h

Abstract:

    Declaration of class CMedInfo

Author:


Revision History:

--*/


#include "resource.h"       // main symbols
#include "engine.h"         // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"
#include "metalib.h"        // Meta database

typedef struct _HSM_MEDIA_MASTER {
    GUID                id;                      //HSM Engine Media ID
    GUID                ntmsId;                  //HSM RMS/NTMS Media ID
    GUID                storagePoolId;           //Storage Pool ID
    CWsbStringPtr       description;             //Display name - RS generated
    CWsbStringPtr       name;                    //Barcode on media or NTMS generated
                                                 //name
    HSM_JOB_MEDIA_TYPE  type;                    //Type of media (HSM)
    FILETIME            lastUpdate;              //Last update of copy
    HRESULT             lastError;               //S_OK or the last exception 
                                                 //..encountered when accessing
                                                 //..the media
    BOOL                recallOnly;              //True if no more data is to
                                                 //..be premigrated to the media
                                                 //..Set by internal operations, 
                                                 //..may not be changed externally
    LONGLONG            freeBytes;               //Real free space on media
    LONGLONG            capacity;                //Total capacity of media
    SHORT               nextRemoteDataSet;       //Next remote data set
} HSM_MEDIA_MASTER, *PHSM_MEDIA_MASTER;

typedef struct _HSM_MEDIA_COPY {
    GUID                id;                    //HSM RMS/NTMS Media ID of copy
    CWsbStringPtr       description;           //RS generated name of copy (display name)
    CWsbStringPtr       name;                  //Barcode or NTMS generated name of copy
    FILETIME            lastUpdate;            //Last update of copy
    HRESULT             lastError;             //S_OK or the last exception 
                                               //..encountered when accessing
                                               //..the media
    SHORT               nextRemoteDataSet;     //The next remote data set of the media
                                               //..master that was copied
} HSM_MEDIA_COPY, *PHSM_MEDIA_COPY;


/////////////////////////////////////////////////////////////////////////////
// Task

class CMediaInfo : 
    public CWsbDbEntity,
    public IMediaInfo,
    public CComCoClass<CMediaInfo,&CLSID_CMediaInfo>
{
public:
    CMediaInfo() {}
BEGIN_COM_MAP(CMediaInfo)
    COM_INTERFACE_ENTRY(IMediaInfo)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CMediaInfo, _T("Task.MediaInfo.1"), _T("Task.MediaInfo"), IDS_MEDIAINFO_DESC, THREADFLAGS_BOTH)

// IMediaInfo
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
//*/
// IMediaInfo
public:
    STDMETHOD( GetCapacity )( LONGLONG *pCapacity );
    STDMETHOD( GetCopyDescription ) ( USHORT copyNumber, OLECHAR **pDescription, 
                                                         ULONG bufferSize);
    STDMETHOD( GetCopyInfo )( USHORT copyNumber, 
                              GUID *pMediaSubsystemId, 
                              OLECHAR **pDescription, 
                              ULONG descriptionBufferSize,
                              OLECHAR **pName, 
                              ULONG nameBufferSize,
                              FILETIME *pUpdate, 
                              HRESULT *pLastError,
                              SHORT  *pNextRemoteDataSet );
    STDMETHOD( GetCopyLastError )( USHORT copyNumber, HRESULT *pLastError );
    STDMETHOD( GetCopyMediaSubsystemId )( USHORT copyNumber, GUID *pMediaSubsystemId );
    STDMETHOD( GetCopyName )( USHORT copyNumber, OLECHAR **pName, ULONG bufferSize); 
    STDMETHOD( GetCopyNextRemoteDataSet )( USHORT copyNumber, SHORT *pNextRemoteDataSet); 
    STDMETHOD( GetCopyUpdate )(  USHORT copyNumber, FILETIME *pUpdate ); 
    STDMETHOD( GetDescription )(OLECHAR **pDescription, ULONG buffsize );
    STDMETHOD( GetFreeBytes )( LONGLONG *pFreeBytes);
    STDMETHOD( GetId )( GUID *pId);
    STDMETHOD( GetLastError    )( HRESULT *pLastError);
    STDMETHOD( GetLastKnownGoodMasterInfo    )( GUID* pMediaId, 
                               GUID *pMediaSubsystemId, 
                               GUID *pStoragePoolId, 
                               LONGLONG *pFreeBytes, 
                               LONGLONG *pCapacity, 
                               HRESULT *pLastError, 
                               OLECHAR **pDescription, 
                               ULONG descriptionBufferSize,
                               HSM_JOB_MEDIA_TYPE *pType,
                               OLECHAR **pName,
                               ULONG nameBufferSize,
                               BOOL *pReadOnly,
                               FILETIME *pUpdate,
                               SHORT *pNextRemoteDataSet);
    STDMETHOD( GetLKGMasterNextRemoteDataSet )( SHORT *pNextRemoteDataSet );
    STDMETHOD( GetLogicalValidBytes )( LONGLONG *pLogicalValidBytes);
    STDMETHOD( GetMediaInfo    )( GUID* pMediaId, 
                               GUID *pMediaSubsystemId, 
                               GUID *pStoragePoolId, 
                               LONGLONG *pFreeBytes, 
                               LONGLONG *pCapacity, 
                               HRESULT *pLastError, 
                               SHORT *pNextRemoteDataSet, 
                               OLECHAR **pDescription, 
                               ULONG descriptionBufferSize,
                               HSM_JOB_MEDIA_TYPE *pType,
                               OLECHAR **pName,
                               ULONG nameBufferSize,
                               BOOL *pReadOnly,
                               FILETIME *pUpdate,
                               LONGLONG *pLogicalValidBytes,
                               BOOL *pRecreate);
    STDMETHOD( GetMediaSubsystemId )( GUID *pRmsMediaId );
    STDMETHOD( GetName )( OLECHAR **pName, ULONG bufferSize); 
    STDMETHOD( GetNextRemoteDataSet )( SHORT *pNextRemoteDataSet );
    STDMETHOD( GetRecallOnlyStatus )( BOOL *pRecallOnlyStatus );
    STDMETHOD( GetRecreate )( BOOL *pRecreate );
    STDMETHOD( GetStoragePoolId )( GUID *pStoragePoolId );
    STDMETHOD( GetType     )( HSM_JOB_MEDIA_TYPE *pType );
    STDMETHOD( GetUpdate)( FILETIME *pUpdate );

    STDMETHOD( SetCapacity )( LONGLONG capacity);
    STDMETHOD( SetCopyDescription )    ( USHORT copyNumber, OLECHAR *name); 
    STDMETHOD( SetCopyInfo )( USHORT copyNumber, 
                              GUID mediaSubsystemId, 
                              OLECHAR *description, 
                              OLECHAR *name, 
                              FILETIME update, 
                              HRESULT lastError,
                              SHORT nextRemoteDataSet );
    STDMETHOD( SetCopyLastError )( USHORT copyNumber, HRESULT lastError );
    STDMETHOD( SetCopyMediaSubsystemId )( USHORT copyNumber, GUID mediaSybsystemMediaId ); 
    STDMETHOD( SetCopyName )( USHORT copyNumber, OLECHAR *barCode); 
    STDMETHOD( SetCopyNextRemoteDataSet )( USHORT copyNumber, SHORT nextRemoteDataSet); 
    STDMETHOD( SetCopyUpdate )( USHORT copyNumber, FILETIME update ); 
    STDMETHOD( SetDescription )(OLECHAR *description);
    STDMETHOD( SetFreeBytes )( LONGLONG FreeBytes );
    STDMETHOD( SetId )( GUID id);
    STDMETHOD( SetLastError )( HRESULT lastError);
    STDMETHOD( SetLastKnownGoodMasterInfo )( GUID mediaId, 
                               GUID mediaSubsystemMediaId, 
                               GUID storagePoolId, 
                               LONGLONG FreeBytes, 
                               LONGLONG Capacity, 
                               HRESULT lastError, 
                               OLECHAR *description, 
                               HSM_JOB_MEDIA_TYPE type,
                               OLECHAR *name,
                               BOOL     ReadOnly,
                               FILETIME update,
                               SHORT nextRemoteDataSet);
    STDMETHOD( SetLogicalValidBytes )( LONGLONG logicalValidBytes);
    STDMETHOD( SetMediaInfo )( GUID mediaId, 
                               GUID mediaSubsystemMediaId, 
                               GUID storagePoolId, 
                               LONGLONG FreeBytes, 
                               LONGLONG Capacity, 
                               HRESULT lastError, 
                               SHORT nextRemoteDataSet, 
                               OLECHAR *description, 
                               HSM_JOB_MEDIA_TYPE type,
                               OLECHAR *name,
                               BOOL     ReadOnly,
                               FILETIME update,
                               LONGLONG logicalValidBytes,
                               BOOL     recreate);
    STDMETHOD( SetMediaSubsystemId )( GUID rmsMediaId );
    STDMETHOD( SetName )( OLECHAR *barCode); 
    STDMETHOD( SetNextRemoteDataSet )( SHORT nextRemoteDataSet );
    STDMETHOD( SetRecallOnlyStatus )( BOOL readOnlyStatus );
    STDMETHOD( SetRecreate )( BOOL recreate );
    STDMETHOD( SetStoragePoolId )( GUID storagePoolId );
    STDMETHOD( SetType )( HSM_JOB_MEDIA_TYPE type );
    STDMETHOD( SetUpdate)( FILETIME update );
    STDMETHOD( DeleteCopy)( USHORT copyNumber );
    STDMETHOD( RecreateMaster )( void );
    STDMETHOD( UpdateLastKnownGoodMaster )( void  );

private:
    //
    // Helper functions
    //
    STDMETHOD( WriteToDatabase )( void  );

    HSM_MEDIA_MASTER    m_Master;                               //Media master information
    BOOL                m_Recreate;                             //True if the master is to 
                                                                //..be recreated - no more 
                                                                //..data is migrated to 
                                                                //..media in this state.
                                                                //..May be set through the 
                                                                //..UI and changed when 
                                                                //..master is recreated.
    LONGLONG            m_LogicalValidBytes;                     //Amount of valid data if 
                                                                //..space reclamation were 
                                                                //..to occur.
    HSM_MEDIA_MASTER    m_LastKnownGoodMaster;                  //Last known good media 
                                                                //..master information
    HSM_MEDIA_COPY      m_Copy[HSM_MAX_NUMBER_MEDIA_COPIES];    //Media copy information
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\segdb.h ===
// SegDb.h : Declaration of the CSegDb


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


#define SEG_KEY_TYPE          1
#define MEDIA_INFO_KEY_TYPE   1
#define BAG_INFO_KEY_TYPE     1
#define BAG_HOLE_KEY_TYPE     1
#define VOL_ASSIGN_KEY_TYPE   1

#define SEG_DB_MAX_MEDIA_NAME_LEN        MAX_COMPUTERNAME_LENGTH + 128 + 2
#define SEG_DB_MAX_MEDIA_BAR_CODE_LEN    MAX_COMPUTERNAME_LENGTH + 128 + 2

/////////////////////////////////////////////////////////////////////////////
// seg

class CSegDb : 
    public CWsbDb,
    public ISegDb,
    public CComCoClass<CSegDb,&CLSID_CSegDb>
{
public:
    CSegDb() {}
BEGIN_COM_MAP(CSegDb)
    COM_INTERFACE_ENTRY(ISegDb)
    COM_INTERFACE_ENTRY2(IWsbDb, ISegDb)
    COM_INTERFACE_ENTRY(IWsbDbPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
//  COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CSegDb, _T("Seg.SegDb.1"), _T("Seg.SegDb"), IDS_SEGDB_DESC, THREADFLAGS_BOTH)

DECLARE_PROTECT_FINAL_CONSTRUCT();

    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IWsbDb
    WSB_FROM_CWSBDB;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize) {
            return(CWsbDb::GetSizeMax(pSize)); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// ISegDb
public:
    STDMETHOD(Erase)( void );
    STDMETHOD(Initialize)(OLECHAR* root, IWsbDbSys* pDbSys, BOOL* pCreateFlag);
    STDMETHOD(BagHoleAdd)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen);
    STDMETHOD(BagHoleFind)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, IBagHole** ppIBagHole );
    STDMETHOD(BagHoleSubtract)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen);
    STDMETHOD(SegAdd)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, GUID MediaId, LONGLONG mediaStart, BOOL indirectRecord = FALSE );
    STDMETHOD(SegFind)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, ISegRec** ppISegRec );
    STDMETHOD(SegSubtract)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG SegLen);
    STDMETHOD(VolAssignAdd)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, GUID VolId);
    STDMETHOD(VolAssignFind)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, IVolAssign** ppIVolAssign );
    STDMETHOD(VolAssignSubtract)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen);

private:
    LONG                                m_value;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
#include "wsb.h"
#include "engcommn.h"
#include "esent.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\segdb.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SegDb.cpp

Abstract:

    This component is an provides the collection that contains the HSM segment records.

Author:

    Cat Brant   [cbrant]   12-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metaLib.h"
#include "engine.h"
#include "segdb.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_SEG

//  SEG_APPEND_OK returns TRUE if bag segment 2 can be appended to
//  segment 1
#define SEG_APPEND_OK(b1, s1, l1, b2, s2, l2) \
        (IsEqualGUID(b1, b2) && (s1 + l1 == s2))

//  SEG_EXPAND_OK returns TRUE if bag segment 2 can be added to
//  segment 1
#define SEG_EXPAND_OK(b1, s1, l1, b2, s2, l2) \
        (IsEqualGUID(b1, b2) && (s1 + l1 <= s2))

//  SEG_CONTAINS returns TRUE if bag segment 1 contains (the first
//    part of) segment 2
#define SEG_CONTAINS(b1, s1, l1, b2, s2, l2) \
        (IsEqualGUID(b1, b2) && (s1 <= s2) && ((s1 + l1) > s2))


HRESULT 
CSegDb::BagHoleAdd
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::BagHoleAdd

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::BagHoleAdd"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), SegStartLoc, 
        SegLen);

    try {
        BOOL                    found = FALSE;
        CComPtr<IBagHole>       pBagHole;    
        GUID                    l_BagId = GUID_NULL;
        LONGLONG                l_SegStartLoc = 0;
        LONGLONG                l_SegLen = 0;

        WsbAffirmHr(GetEntity(pDbSession, HSM_BAG_HOLE_REC_TYPE, IID_IBagHole,
                (void **)&pBagHole));
        WsbAffirmHr(pBagHole->SetBagHole(BagId, SegStartLoc, 0));

        //  Look for a segment to which to append this one
        WsbTrace(OLESTR("Finding BagHole Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        hr = pBagHole->FindLTE();
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            WsbAffirmHr(pBagHole->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));
            if (SEG_APPEND_OK(l_BagId, l_SegStartLoc,  l_SegLen,
                    BagId, SegStartLoc, SegLen)) {
                found = TRUE;
            }
        }

        if (found) {
            //  Append this segment to the existing record
            l_SegLen += SegLen;
        } else {
            //  Create a new record
            l_SegStartLoc = SegStartLoc;
            l_SegLen = SegLen;
            WsbAffirmHr(pBagHole->MarkAsNew());
        }
        WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));

        WsbTrace(OLESTR("Writing BagHole Record: <%ls>, <%I64u>, <%I64u>\n"),
                    WsbGuidAsString(BagId), 
                    l_SegStartLoc,
                    l_SegLen);
        WsbAffirmHr(pBagHole->Write());

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::BagHoleAdd"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::BagHoleFind
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    OUT IBagHole** ppIBagHole
    )
 /*++

Implements:

  ISegDb::BagHoleFind

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::BagHoleFind"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), SegStartLoc, 
        SegLen);

    try {
        CComPtr<IBagHole>       pBagHole;    
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;

        WsbAffirm(ppIBagHole != NULL, E_POINTER);
        WsbAffirmHr(GetEntity(pDbSession, HSM_BAG_HOLE_REC_TYPE, IID_IBagHole,
                (void **)&pBagHole));
        WsbAffirmHr(pBagHole->SetBagHole(BagId, SegStartLoc, 0));

        //  Look for a segment that contains this one
        WsbTrace(OLESTR("Finding BagHole Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        WsbAffirmHr(pBagHole->FindLTE());

        //  We found a record, see if it's the right one
        WsbAffirmHr(pBagHole->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));
        if (SEG_CONTAINS(l_BagId, l_SegStartLoc, l_SegLen,
                BagId, SegStartLoc, SegLen)) {
            *ppIBagHole = pBagHole;
            pBagHole->AddRef();
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::BagHoleFind"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::BagHoleSubtract
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::BagHoleSubtract

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::BagHoleSubtract"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        CComPtr<IBagHole>       pBagHole;    

        //  Find the segment record
        WsbAffirmHr(BagHoleFind(pDbSession, BagId, SegStartLoc, SegLen, &pBagHole));

        //  Get the current data
        WsbAffirmHr(pBagHole->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));

        //  Determine where the hole is
        if (l_SegStartLoc == SegStartLoc && l_SegLen == SegLen) {
            //  Hole is the entire segment -- delete it
            WsbAffirmHr(pBagHole->Remove());

        } else if (l_SegStartLoc == SegStartLoc) {
            //  Hole is at the beginning of the segment.  Just update the
            //  existing segment
            l_SegStartLoc += SegLen;
            WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));
            WsbAffirmHr(pBagHole->Write());

        } else if ((l_SegStartLoc + l_SegLen) == (SegStartLoc + SegLen)) {
            //  Hole is at the end of the segment.  Just update the
            //  existing segment
            l_SegLen -= SegLen;
            WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));
            WsbAffirmHr(pBagHole->Write());

        } else {
            //  Hole is in the middle of the segment.  Update the
            //  existing record to be the first part.
            LONGLONG    oldLen = l_SegLen;
            LONGLONG    offset = (SegStartLoc + SegLen) - l_SegStartLoc;

            l_SegLen = SegStartLoc - l_SegStartLoc;
            WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));
            WsbAffirmHr(pBagHole->Write());

            //  Create a new record for the second part.
            l_SegLen -= offset;
            l_SegStartLoc += offset;
            WsbAffirmHr(BagHoleAdd(pDbSession, BagId, l_SegStartLoc, l_SegLen));
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::BagHoleSubtract"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK

--*/
{
    HRESULT     hr = S_OK;

    m_value = 0;
    try {

        WsbAssertHr(CWsbDb::FinalConstruct());
        m_version = 1;

    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CSegDb::FinalRelease(
    void
    ) 
/*++

Routine Description:

  This method does some termination of the object that is necessary
  before destruction. 

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalDestruct().

--*/
{
    HRESULT     hr = S_OK;

    CWsbDb::FinalRelease();
    return(hr);
}

HRESULT 
CSegDb::Test
(
    OUT USHORT * pTestsPassed,
    OUT USHORT* pTestsFailed
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT             hr = S_OK;

#ifdef THIS_CODE_IS_WRONG
//  This is mostly wrong now
    ULONG               entries;
    GUID                    lastBagId;
    LONGLONG                lastStartLoc;
    GUID                    startBagId;
    LONGLONG                startSegStartLoc;
    LONGLONG                startSegLen;
    USHORT                  startSegType;
    GUID                    startPrimLoc;
    LONGLONG                    startSecLoc;
    USHORT              testsRun = 0;
    CComPtr<IWsbCollection> pColl;
    CComPtr<ISegRec>    pSegRec1;
    CComPtr<ISegRec>    pSegRec2;
    CComPtr<ISegRec>    pSegRec3;
    CComPtr<ISegRec>    pSegRec4;
    CComPtr<ISegRec>    pSegRec5;
    CComPtr<ISegRec>    pSegRec6;
    CComPtr<ISegRec>    pSegRec7;
    CComPtr<ISegRec>    pSegRec8;
    CComPtr<ISegRec>    pSegRec9;
    CComPtr<ISegRec>    pSegRec10;
    CComPtr<ISegRec>    pSegRec11;

    WsbTraceIn(OLESTR("CSegDb::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Clear out any entries that might be present.
        hr = S_OK;
        try {
            WsbAssertHr(Erase());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There shouldn't be any entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetSegments(&pColl));
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(0 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(pColl->IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // We need some collectable items to exercise the collection.
        WsbAssertHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec1));
        WsbAssertHr(pSegRec1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CSegRec,0 ));
        

        // Add the item to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec1->Write());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There should be 1 entry.
        hr = S_OK;
        try {
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // It should not be empty.
        hr = S_OK;
        try {
            WsbAssert(pColl->IsEmpty() == S_FALSE, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Does it think it has the item?
        hr = S_OK;
        try {
            WsbAssertHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec2));
            WsbAssertHr(pSegRec2->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec2->FindEQ());
            WsbAssert(pSegRec1->CompareToISegmentRecord(pSegRec2, NULL) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Add some more items
        WsbAssertHr(pSegRec2->SetSegmentRecord(CLSID_CWsbGuid, 0, 5, 0, CLSID_CSegRec,0 ));

        WsbAssertHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec3));
        WsbAssertHr(pSegRec3->SetSegmentRecord(CLSID_CWsbGuid, 0, 5, 0, CLSID_CSegRec,0 ));

        // Add the items to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec2->Write());
            WsbAssertHr(pSegRec3->Write());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There should be 3 entries.
        hr = S_OK;
        try {
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(3 == entries, E_FAIL);
            WsbAssertHr(pColl->OccurencesOf(pSegRec3, &entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Remove one of the two identical items.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec3->FindEQ());
            WsbAssertHr(pSegRec3->Remove());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There should be 2 entries.
        hr = S_OK;
        try {
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // How many copies does it have?
        hr = S_OK;
        try {
            WsbAssertHr(pColl->OccurencesOf(pSegRec1, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pColl->OccurencesOf(pSegRec3, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Can we find an entry?
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec3->FindEQ());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Does the collection still contain it?
        hr = S_OK;
        try {
            WsbAssert(pColl->Contains(pSegRec1) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Remove the last of the record, and verify
        // that it can't be found. Then puit it back.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec1->FindEQ());
            WsbAssertHr(pSegRec1->Remove());
            WsbAssert(pColl->Contains(pSegRec1) == S_FALSE, E_FAIL);
            WsbAssertHr(pSegRec1->MarkAsNew());
            WsbAssertHr(pSegRec1->Write());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
            WsbAssertHr(pColl->RemoveAllAndRelease());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(pColl->IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(Erase());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }


        try {
            WsbAssertHr(pSegRec1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec2->SetSegmentRecord(CLSID_CWsbGuid, 0, 5, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec3->SetSegmentRecord(CLSID_CWsbGuid, 5, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec4));
            WsbAssertHr(pSegRec4->SetSegmentRecord(CLSID_CWsbGuid, 10, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec5));
            WsbAssertHr(pSegRec5->SetSegmentRecord(CLSID_CWsbGuid, 15, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec6));
            WsbAssertHr(pSegRec6->SetSegmentRecord(CLSID_CWsbGuid, 20, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec7));
            WsbAssertHr(pSegRec7->SetSegmentRecord(CLSID_CWsbGuid, 25, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec8));
            WsbAssertHr(pSegRec8->SetSegmentRecord(CLSID_CWsbGuid, 30, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec9));
            WsbAssertHr(pSegRec9->SetSegmentRecord(CLSID_CWsbGuid, 35, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec10));
            WsbAssertHr(pSegRec10->SetSegmentRecord(CLSID_CWsbGuid, 40, 5, 0, CLSID_CSegRec,0 ));

            //  Add them in random order
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec2));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec2));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec2));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
            //  Check that they're sorted
            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec11));
            WsbAssertHr(pSegRec11->First());
            WsbAssertHr(pSegRec11->GetSegmentRecord(&startBagId, &startSegStartLoc, &startSegLen, &startSegType, &startPrimLoc, &startSecLoc));
            lastBagId = startBagId;
            lastStartLoc = startSegStartLoc;
            hr = S_OK;
            for ( ; ; ) {
                hr = pSegRec11->Next();
                if (hr != S_OK) break;
                WsbAssertHr(pSegRec11->GetSegmentRecord(&startBagId, &startSegStartLoc, &startSegLen, &startSegType, &startPrimLoc, &startSecLoc));
                WsbAssert(!IsEqualGUID(lastBagId, startBagId) || 
                        lastStartLoc <= startSegStartLoc, E_FAIL);
                lastBagId = startBagId;
                lastStartLoc = startSegStartLoc;
            }
            WsbAssert(hr == WSB_E_NOTFOUND, E_FAIL);
            hr = S_OK;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
            // Check that the last one is what we expect
            WsbAssertHr(pSegRec11->Last());
            WsbAssertHr(pSegRec11->CompareToISegmentRecord(pSegRec10, NULL));

            //  Look for a specific record
            WsbAssertHr(pSegRec5->FindEQ());

            //  Check for near misses
            WsbAssertHr(pSegRec11->SetSegmentRecord(CLSID_CWsbGuid, 23, 5, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec11->FindGT());
            WsbAssertHr(pSegRec11->CompareToISegmentRecord(pSegRec7, NULL));

            WsbAssertHr(pSegRec11->SetSegmentRecord(CLSID_CWsbGuid, 21, 5, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec11->FindLTE());
            WsbAssertHr(pSegRec11->CompareToISegmentRecord(pSegRec6, NULL));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        //  Clear the DB so we can shut it down
        hr = S_OK;
        try {
            WsbAssertHr(Erase());
            WsbAssertHr(Close());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

    } WsbCatch(hr);
#else
    *pTestsPassed = *pTestsFailed = 0;
#endif
    WsbTraceOut(OLESTR("CSegDb::Test"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(S_OK);
}


HRESULT 
CSegDb::Erase (
    void
    ) 
/*++

Routine Description:

  See ISegDb::Erase

Arguments:

  See ISegDb::Erase

Return Value:
  
    See ISegDb::Erase

--*/
{
    
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CSegDb::Erase"),OLESTR(""));

    try {
        //  To be done?
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegDb::Erase"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT
CSegDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CSegDb;
    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CSegDb::Initialize(
    IN     OLECHAR* root,
    IN     IWsbDbSys* pDbSys, 
    IN OUT BOOL*    pCreateFlag
    )

/*++

Implements:

  ISegDb::Initialize().

--*/
{
    BOOL                CreateFlag = FALSE;
    HRESULT             hr = S_OK;
    CWsbStringPtr       path;

    WsbTraceIn(OLESTR("CSegDb::Initialize"), 
        OLESTR("root = <%ls>, CreateFlag = <%ls>"), 
        WsbAbbreviatePath(root, 120), WsbPtrToBoolAsString(pCreateFlag));

    if (pCreateFlag) {
        CreateFlag = *pCreateFlag;
    }

    try {
        path = root;
        WsbAffirmHr(path.Append(OLESTR("\\SegDb")));

        m_pWsbDbSys = pDbSys;
        WsbAffirmPointer(m_pWsbDbSys);

        hr = Locate(path);

        if (hr == STG_E_FILENOTFOUND && CreateFlag){
            ULONG memSize;

            hr = S_OK;
            m_nRecTypes = 5;

            memSize = m_nRecTypes * sizeof(IDB_REC_INFO);
            m_RecInfo = (IDB_REC_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo, E_FAIL);
            ZeroMemory(m_RecInfo, memSize);

            //  Segment records
            m_RecInfo[0].Type = HSM_SEG_REC_TYPE;
            m_RecInfo[0].EntityClassId = CLSID_CSegRec;
            m_RecInfo[0].Flags = 0;
            m_RecInfo[0].MinSize = 2 * WSB_BYTE_SIZE_GUID +
                    3 * WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_USHORT;
            m_RecInfo[0].MaxSize = m_RecInfo[0].MinSize;
            m_RecInfo[0].nKeys = 1;

            memSize = m_RecInfo[0].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[0].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[0].Key, E_FAIL);
            ZeroMemory(m_RecInfo[0].Key, memSize);

            m_RecInfo[0].Key[0].Type = SEG_KEY_TYPE;
            m_RecInfo[0].Key[0].Size = WSB_BYTE_SIZE_GUID +
                    WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[0].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  Media information
            m_RecInfo[1].Type = HSM_MEDIA_INFO_REC_TYPE;
            m_RecInfo[1].EntityClassId = CLSID_CMediaInfo;
            m_RecInfo[1].Flags = 0;
            m_RecInfo[1].MinSize = 2 *  (WSB_BYTE_SIZE_GUID +             //Id
                                         WSB_BYTE_SIZE_GUID +             //ntmsId
                                         WSB_BYTE_SIZE_GUID +             //soragePoolId
                                         4                  +             //nme
                                         4                  +             //brCode
                                         WSB_BYTE_SIZE_SHORT+             //tpe
                                         WSB_BYTE_SIZE_FILETIME   +       //lastUpdate
                                         WSB_BYTE_SIZE_LONG       +       //lastError
                                         WSB_BYTE_SIZE_BOOL       +       //m_RecallOnly
                                         WSB_BYTE_SIZE_LONGLONG   +       //m_freeBytes
                                         WSB_BYTE_SIZE_LONGLONG   +       //m_Capacity
                                         WSB_BYTE_SIZE_SHORT)     +       //nextRemoteDataSet
                                   
                                   WSB_BYTE_SIZE_BOOL       +       //m_Recreate
                                   WSB_BYTE_SIZE_LONGLONG   +       //m_LocicalFreeSpace
                                   
                                   3 * (WSB_BYTE_SIZE_GUID  +       //m_RmsMediaId
                                        4                   +       //m_Name
                                        4                   +       //m_BarCode
                                        WSB_BYTE_SIZE_FILETIME +    //m_Update
                                        WSB_BYTE_SIZE_LONG  +       //m_LastError
                                        WSB_BYTE_SIZE_SHORT );      //nextRemoteDataSet
            m_RecInfo[1].MaxSize = m_RecInfo[1].MinSize + 5 * SEG_DB_MAX_MEDIA_NAME_LEN + 5 * SEG_DB_MAX_MEDIA_BAR_CODE_LEN;
            m_RecInfo[1].nKeys = 1;

            memSize = m_RecInfo[1].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[1].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[1].Key, E_FAIL);
            ZeroMemory(m_RecInfo[1].Key, memSize);

            m_RecInfo[1].Key[0].Type = MEDIA_INFO_KEY_TYPE;
            m_RecInfo[1].Key[0].Size = WSB_BYTE_SIZE_GUID;
            m_RecInfo[1].Key[0].Flags = IDB_KEY_FLAG_PRIMARY;

            //  Bag information
            m_RecInfo[2].Type = HSM_BAG_INFO_REC_TYPE;
            m_RecInfo[2].EntityClassId = CLSID_CBagInfo;
            m_RecInfo[2].Flags = 0;
            m_RecInfo[2].MinSize = (2 * WSB_BYTE_SIZE_GUID) +
                    (2 * WSB_BYTE_SIZE_LONGLONG) + (2 * WSB_BYTE_SIZE_USHORT) +
                    WSB_BYTE_SIZE_FILETIME + WSB_BYTE_SIZE_SHORT;
            m_RecInfo[2].MaxSize = m_RecInfo[2].MinSize;
            m_RecInfo[2].nKeys = 1;

            memSize = m_RecInfo[2].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[2].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[2].Key, E_FAIL);
            ZeroMemory(m_RecInfo[2].Key, memSize);

            m_RecInfo[2].Key[0].Type = BAG_INFO_KEY_TYPE;
            m_RecInfo[2].Key[0].Size = WSB_BYTE_SIZE_GUID;
            m_RecInfo[2].Key[0].Flags = IDB_KEY_FLAG_PRIMARY;

            //  Bag holes
            m_RecInfo[3].Type = HSM_BAG_HOLE_REC_TYPE;
            m_RecInfo[3].EntityClassId = CLSID_CBagHole;
            m_RecInfo[3].Flags = 0;
            m_RecInfo[3].MinSize = WSB_BYTE_SIZE_GUID +
                    2 * WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[3].MaxSize = m_RecInfo[3].MinSize;
            m_RecInfo[3].nKeys = 1;

            memSize = m_RecInfo[3].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[3].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[3].Key, E_FAIL);
            ZeroMemory(m_RecInfo[3].Key, memSize);

            m_RecInfo[3].Key[0].Type = BAG_HOLE_KEY_TYPE;
            m_RecInfo[3].Key[0].Size = WSB_BYTE_SIZE_GUID +
                    WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[3].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  Volume assignment
            m_RecInfo[4].Type = HSM_VOL_ASSIGN_REC_TYPE;
            m_RecInfo[4].EntityClassId = CLSID_CVolAssign;
            m_RecInfo[4].Flags = 0;
            m_RecInfo[4].MinSize = 2 * WSB_BYTE_SIZE_GUID +
                    2 * WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[4].MaxSize = m_RecInfo[4].MinSize;
            m_RecInfo[4].nKeys = 1;

            memSize = m_RecInfo[4].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[4].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[4].Key, E_FAIL);
            ZeroMemory(m_RecInfo[4].Key, memSize);

            m_RecInfo[4].Key[0].Type = VOL_ASSIGN_KEY_TYPE;
            m_RecInfo[4].Key[0].Size = WSB_BYTE_SIZE_GUID +
                    WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[4].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  Create the new DB
            WsbAssertHr(Create(path));
            CreateFlag = TRUE;

        } else if (hr == STG_E_FILENOTFOUND) {

            // DB doesn't exist, but we're not suppose to create it
            WsbLogEvent(WSB_MESSAGE_IDB_OPEN_FAILED, 0, NULL, 
                    WsbQuickString(WsbAbbreviatePath(path, 120)), NULL );
            hr = WSB_E_IDB_FILE_NOT_FOUND;
        }
    } WsbCatch(hr);

    if (pCreateFlag) {
        *pCreateFlag = CreateFlag;
    }

    WsbTraceOut(OLESTR("CSegDb::Initialize"), 
        OLESTR("hr = %ls, path = <%ls>, CreateFlag = <%ls>"), 
        WsbHrAsString(hr), WsbAbbreviatePath(path, 120), 
        WsbPtrToBoolAsString(pCreateFlag));

    return(hr);
}


HRESULT
CSegDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT             hr = S_OK;

    try {
        WsbAffirmHr(CWsbDb::Load(pStream));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CSegDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT             hr = S_OK;

    try {
        WsbAffirmHr(CWsbDb::Save(pStream, clearDirty));
    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CSegDb::SegAdd
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    IN GUID MediaId,
    IN LONGLONG mediaStart,
    IN BOOL indirectRecord
    )
 /*++

Implements:

  ISegDb::SegAdd

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::SegAdd"), 
        OLESTR("GUID = %ls, SegStartLoc = %I64u, SegLen = %I64u"), 
        WsbGuidAsString(BagId), SegStartLoc, SegLen);

    try {
        BOOL                    found = FALSE;
        CComPtr<ISegRec>        pSegRec;    
        GUID                    l_BagId = GUID_NULL;
        LONGLONG                l_SegStartLoc = 0;
        LONGLONG                l_SegLen = 0;
        USHORT                  l_SegFlags = SEG_REC_NONE;
        GUID                    l_MediaId = GUID_NULL;
        LONGLONG                l_MediaStart = 0;

        WsbAffirmHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec,
                                                    (void **)&pSegRec));
        WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, SegStartLoc, 
                            0, 0, GUID_NULL, 0 ));

        //  Look for a segment to which to append this one
        hr = pSegRec->FindLTE();
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_SegStartLoc, &l_SegLen, &l_SegFlags, 
                            &l_MediaId, &l_MediaStart));
            if (SEG_EXPAND_OK(l_BagId, l_SegStartLoc,  l_SegLen,
                    BagId, SegStartLoc, SegLen) &&
                    IsEqualGUID(MediaId, l_MediaId)) {
                WsbTrace(OLESTR("CSegDb::SegAdd: Found SegmentRecord: StartLoc = %I64u, Len = %I64u\n"),
                        l_SegStartLoc, l_SegLen);
                found = TRUE;
            }
        }

        if (found) {
            //  Append this segment to the existing record
            l_SegLen = (SegStartLoc - l_SegStartLoc) + SegLen;
            WsbTrace(OLESTR("CSegDb::SegAdd: new SegLen = %I64u\n"), l_SegLen);
        } else {
            //  Create a new segment record
            l_SegStartLoc = SegStartLoc;
            l_SegLen = SegLen;
            if (indirectRecord) {
                l_SegFlags = SEG_REC_INDIRECT_RECORD;
            } else {
                l_SegFlags = SEG_REC_NONE;
            }
            l_MediaId = MediaId;
            l_MediaStart = mediaStart;
            WsbAffirmHr(pSegRec->MarkAsNew());
            WsbTrace(OLESTR("CSegDb::SegAdd: add new segment\n"));
        }
        WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));

        WsbAffirmHr(pSegRec->Write());

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::SegAdd"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::SegFind
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    OUT ISegRec** ppISegRec
    )
 /*++

Implements:

  ISegDb::SegFind

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::SegFind"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        CComPtr<ISegRec>        pSegRec;    
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        USHORT                  l_SegFlags;
        GUID                    l_MediaId;
        LONGLONG                l_MediaStart;

        WsbAffirm(ppISegRec != NULL, E_POINTER);
        WsbAffirmHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec,
                (void **)&pSegRec));
        WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, SegStartLoc, 
                0, 0, GUID_NULL, 0 ));

        //  Look for a segment that contains this one
        WsbTrace(OLESTR("Finding SegmentRecord: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        WsbAffirmHr(pSegRec->FindLTE());

        //  We found a record, see if it's the right one
        WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_SegFlags, &l_MediaId, &l_MediaStart));
        if (SEG_CONTAINS(l_BagId, l_SegStartLoc, l_SegLen,
                BagId, SegStartLoc, SegLen)) {
            *ppISegRec = pSegRec;
            pSegRec->AddRef();
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::SegFind"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::SegSubtract
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::SegSubtract

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::SegSubtract"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        USHORT                  l_SegFlags;
        GUID                    l_MediaId;
        LONGLONG                l_MediaStart;
        CComPtr<ISegRec>        pSegRec;    

        //  Find the segment record
        WsbAffirmHr(SegFind(pDbSession, BagId, SegStartLoc, SegLen, &pSegRec));

        //  Get the current data
        WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_SegFlags, &l_MediaId, &l_MediaStart));

        //  Determine where the hole is
        if (l_SegStartLoc == SegStartLoc && l_SegLen == SegLen) {
            //  Hole is the entire segment -- delete it
            WsbAffirmHr(pSegRec->Remove());

        } else if (l_SegStartLoc == SegStartLoc) {
            //  Hole is at the beginning of the segment.  Just update the
            //  existing segment
            l_SegStartLoc += SegLen;
            l_MediaStart += SegLen;
            WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                    l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));
            WsbAffirmHr(pSegRec->Write());

        } else if ((l_SegStartLoc + l_SegLen) == (SegStartLoc + SegLen)) {
            //  Hole is at the end of the segment.  Just update the
            //  existing segment
            l_SegLen -= SegLen;
            WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                    l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));
            WsbAffirmHr(pSegRec->Write());

        } else {
            //  Hole is in the middle of the segment.  Update the
            //  existing record to be the first part.
            LONGLONG    oldLen = l_SegLen;
            LONGLONG    offset = (SegStartLoc + SegLen) - l_SegStartLoc;
            BOOL        bIndirect = FALSE;

            l_SegLen = SegStartLoc - l_SegStartLoc;
            WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                    l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));
            WsbAffirmHr(pSegRec->Write());

            //  Create a new record for the second part.
            l_SegLen -= offset;
            l_SegStartLoc += offset;
            l_MediaStart += offset;
            if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
                bIndirect = TRUE;
            }
            WsbAffirmHr(SegAdd(pDbSession, BagId, l_SegStartLoc, l_SegLen, l_MediaId,
                    l_MediaStart, bIndirect));
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::SegSubtract"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::VolAssignAdd
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    IN GUID VolId
    )
 /*++

Implements:

  ISegDb::VolAssignAdd

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::VolAssignAdd"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        BOOL                    found = FALSE;
        CComPtr<IVolAssign>     pVolAssign;    
        GUID                    l_BagId = GUID_NULL;
        LONGLONG                l_SegStartLoc = 0;
        LONGLONG                l_SegLen = 0;
        GUID                    l_VolId = GUID_NULL;

        WsbAffirmHr(GetEntity(pDbSession, HSM_VOL_ASSIGN_REC_TYPE, IID_IVolAssign,
                (void **)&pVolAssign));
        WsbAffirmHr(pVolAssign->SetVolAssign(BagId, SegStartLoc, 
                0, GUID_NULL));

        //  Look for a segment to which to append this one
        WsbTrace(OLESTR("Finding VolAssign Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        hr = pVolAssign->FindLTE();
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            WsbAffirmHr(pVolAssign->GetVolAssign(&l_BagId, &l_SegStartLoc, 
                    &l_SegLen, &l_VolId));
            if (SEG_APPEND_OK(l_BagId, l_SegStartLoc,  l_SegLen,
                    BagId, SegStartLoc, SegLen) && IsEqualGUID(l_VolId, VolId)) {
                found = TRUE;
            }
        }

        if (found) {
            //  Append this segment to the existing record
            l_SegLen += SegLen;
        } else {
            //  Create a new record
            l_SegStartLoc = SegStartLoc;
            l_SegLen = SegLen;
            l_VolId = VolId;
            WsbAffirmHr(pVolAssign->MarkAsNew());
        }
        WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                l_SegLen, l_VolId));

        WsbTrace(OLESTR("Writing VolAssign Record: <%ls>, <%I64u>, <%I64u>\n"),
                    WsbGuidAsString(BagId), 
                    l_SegStartLoc,
                    l_SegLen);
        WsbAffirmHr(pVolAssign->Write());

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::VolAssignAdd"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::VolAssignFind
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    OUT IVolAssign** ppIVolAssign
    )
 /*++

Implements:

  ISegDb::VolAssignFind

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::VolAssignFind"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        CComPtr<IVolAssign>     pVolAssign;    
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        GUID                    l_VolId;

        WsbAffirm(ppIVolAssign != NULL, E_POINTER);
        WsbAffirmHr(GetEntity(pDbSession, HSM_VOL_ASSIGN_REC_TYPE, IID_IVolAssign,
                (void **)&pVolAssign));
        WsbAffirmHr(pVolAssign->SetVolAssign(BagId, SegStartLoc, 0, GUID_NULL));

        //  Look for a segment that contains this one
        WsbTrace(OLESTR("Finding VolAssign Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        WsbAffirmHr(pVolAssign->FindLTE());

        //  We found a record, see if it's the right one
        WsbAffirmHr(pVolAssign->GetVolAssign(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_VolId));
        if (SEG_CONTAINS(l_BagId, l_SegStartLoc, l_SegLen,
                BagId, SegStartLoc, SegLen)) {
            *ppIVolAssign = pVolAssign;
            pVolAssign->AddRef();
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::VolAssignFind"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::VolAssignSubtract
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::VolAssignSubtract

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::VolAssignSubtract"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        GUID                    l_VolId;
        CComPtr<IVolAssign>     pVolAssign;    

        //  Find the segment record
        WsbAffirmHr(VolAssignFind(pDbSession, BagId, SegStartLoc, SegLen, &pVolAssign));

        //  Get the current data
        WsbAffirmHr(pVolAssign->GetVolAssign(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_VolId));

        //  Determine where the hole is
        if (l_SegStartLoc == SegStartLoc && l_SegLen == SegLen) {
            //  Hole is the entire segment -- delete it
            WsbAffirmHr(pVolAssign->Remove());

        } else if (l_SegStartLoc == SegStartLoc) {
            //  Hole is at the beginning of the segment.  Just update the
            //  existing segment
            l_SegStartLoc += SegLen;
            WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                    l_SegLen, l_VolId));
            WsbAffirmHr(pVolAssign->Write());

        } else if ((l_SegStartLoc + l_SegLen) == (SegStartLoc + SegLen)) {
            //  Hole is at the end of the segment.  Just update the
            //  existing segment
            l_SegLen -= SegLen;
            WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                    l_SegLen, l_VolId));
            WsbAffirmHr(pVolAssign->Write());

        } else {
            //  Hole is in the middle of the segment.  Update the
            //  existing record to be the first part.
            LONGLONG    oldLen = l_SegLen;
            LONGLONG    offset = (SegStartLoc + SegLen) - l_SegStartLoc;

            l_SegLen = SegStartLoc - l_SegStartLoc;
            WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                    l_SegLen, l_VolId));
            WsbAffirmHr(pVolAssign->Write());

            //  Create a new record for the second part.
            l_SegLen -= offset;
            l_SegStartLoc += offset;
            WsbAffirmHr(VolAssignAdd(pDbSession, BagId, l_SegStartLoc, l_SegLen,
                    l_VolId));
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::VolAssignSubtract"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\segrec.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SegmentRecord.cpp

Abstract:

    This component is an object representation of the HSM Metadata segment record. It
    is both a persistable and collectable.

Author:

    Cat Brant   [cbrant]   12-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "SegRec.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

#define SEG_KEY_TYPE 1

static USHORT iCountSegrec = 0;

HRESULT 
CSegRec::GetSegmentRecord(
    OUT GUID *pBagId, 
    OUT LONGLONG *pSegStartLoc, 
    OUT LONGLONG *pSegLen, 
    OUT USHORT *pSegFlags, 
    OUT GUID  *pPrimPos, 
    OUT LONGLONG *pSecPos
    ) 
/*++

Routine Description:

  See ISegRec::GetSegmentRecord

Arguments:

  See ISegRec::GetSegmentRecord

Return Value:
  
    See ISegRec::GetSegmentRecord

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::GetSegmentRecord"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pSegStartLoc, E_POINTER);
        WsbAssert(0 != pSegLen, E_POINTER);
        WsbAssert(0 != pSegFlags, E_POINTER);
        WsbAssert(0 != pPrimPos, E_POINTER);
        WsbAssert(0 != pSecPos, E_POINTER);

        //Provide the data members
        *pBagId = m_BagId;
        *pSegStartLoc = m_SegStartLoc;
        *pSegLen = m_SegLen;
        *pSegFlags = m_SegFlags;
        *pPrimPos = m_PrimPos;
        *pSecPos = m_SecPos;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::GetSegmentRecord"),
        OLESTR("hr = <%ls>, BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, SegFlags = <%ls>, PrimPos = <%ls>, SecPos = <%ls>"),
        WsbHrAsString(hr), WsbPtrToGuidAsString(pBagId), 
        WsbStringCopy(WsbPtrToLonglongAsString(pSegStartLoc)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSegLen)),
        WsbStringCopy(WsbPtrToUshortAsString(pSegFlags)),
        WsbStringCopy(WsbPtrToGuidAsString(pPrimPos)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSecPos)));

    return(hr);
}


HRESULT 
CSegRec::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::FinalConstruct"), OLESTR(""));
    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_SegStartLoc = 0;
        m_SegLen = 0;
        m_SegFlags = 0;
        m_PrimPos = GUID_NULL;
        m_SecPos = 0;
    } WsbCatch(hr);

    iCountSegrec++;
    WsbTraceOut(OLESTR("CSegRec::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCountSegrec);
    return(hr);
}

void
CSegRec::FinalRelease(
    void
    )

/*++

Implements:

  CSegRec::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CSegRec::FinalRelease"), OLESTR(""));
    
    CWsbDbEntity::FinalRelease();
    iCountSegrec--;
    
    WsbTraceOut(OLESTR("CSegRec::FinalRelease"), OLESTR("Count is <%d>"), iCountSegrec);
}

HRESULT CSegRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);
        *pclsid = CLSID_CSegRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSecRec::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CSegRec::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(LONGLONG) + 
                            WsbPersistSizeOf(LONGLONG)  + WsbPersistSizeOf(USHORT) +
                            WsbPersistSizeOf(GUID)  + WsbPersistSizeOf(LONGLONG);

//      pcbSize->QuadPart = WsbPersistSizeOf(CSegRec); //???????
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CSegRec::Load
(
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegStartLoc));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegLen));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegFlags));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_PrimPos));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SecPos));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegRec::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>, SegFlags = <%u>, PrimPos <%ls>, SecPos = <%I64u>"), 
        WsbStringCopy(WsbHrAsString(hr)), 
        WsbGuidAsString(m_BagId),
        m_SegStartLoc, m_SegLen, m_SegFlags, WsbStringCopy(WsbGuidAsString(m_PrimPos)), m_SecPos);

    return(hr);
}

HRESULT CSegRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegStartLoc));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegLen));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegFlags));
        WsbAffirmHr(WsbSaveToStream(pStream, m_PrimPos));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SecPos));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CSegRec::SetSegmentRecord
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen, 
    IN USHORT SegFlags, 
    IN GUID PrimPos, 
    IN LONGLONG SecPos 
    )
 /*++

Routine Description:

  See ISegRec::Set().

Arguments:

  See ISegRec::Set().

Return Value:

    S_OK        - Success.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::SetSegmentRecord"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>, SegFlags = <%X>, PrimPos = <%ls>, SecPos = <%I64u>"), 
        WsbStringCopy(WsbGuidAsString(BagId)), SegStartLoc, SegLen, SegFlags, 
        WsbStringCopy(WsbGuidAsString(PrimPos)), SecPos);

    m_isDirty = TRUE;
    m_BagId = BagId;
    m_SegStartLoc = SegStartLoc;
    m_SegLen = SegLen;
    m_SegFlags = SegFlags;
    m_PrimPos = PrimPos;
    m_SecPos = SecPos;

    WsbTraceOut(OLESTR("CSegRec::SetSegmentRecord"), OLESTR("hr = <%ls>"),
        WsbHrAsString(S_OK));
    return(hr);
}

HRESULT
CSegRec::GetSegmentFlags(
    USHORT *pSegFlags
    )
/*++

Implements:

  ISegRec::GetSegmentFlags().

--*/
{
    
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pSegFlags, E_POINTER);

        *pSegFlags = m_SegFlags;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CSegRec::SetSegmentFlags(
    USHORT SegFlags
    )
/*++

Implements:

  ISegRec::SetSegmentFlags().

--*/
{
    
    HRESULT     hr = S_OK;

    m_SegFlags = SegFlags;

    return(hr);
}

HRESULT
CSegRec::GetPrimPos(
    GUID *pPrimPos
    )
/*++

Implements:

  ISegRec::GetPrimPos().

--*/
{
    
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pPrimPos, E_POINTER);

        *pPrimPos = m_PrimPos;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CSegRec::SetPrimPos(
    GUID PrimPos
    )
/*++

Implements:

  ISegRec::SetPrimPos().

--*/
{
    
    HRESULT     hr = S_OK;

    m_PrimPos = PrimPos;

    return(hr);
}

HRESULT
CSegRec::GetSecPos(
    LONGLONG *pSecPos
    )
/*++

Implements:

  ISegRec::GetSecPos().

--*/
{
    
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pSecPos, E_POINTER);

        *pSecPos = m_SecPos;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CSegRec::SetSecPos(
    LONGLONG SecPos
    )
/*++

Implements:

  ISegRec::SetSecPos().

--*/
{
    
    HRESULT     hr = S_OK;

    m_SecPos = SecPos;

    return(hr);
}


HRESULT 
CSegRec::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
#if 0
    HRESULT                 hr = S_OK;
    CComPtr<ISegRec>        pSegment1;
    CComPtr<ISegRec>        pSegment2;
    GUID                    l_BagId;
    LONGLONG                    l_SegStartLoc;
    LONGLONG                    l_SegLen;
    USHORT                  l_SegFlags;
    GUID                    l_PrimPos;
    LONGLONG                    l_SecPos;

    WsbTraceIn(OLESTR("CSegRec::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pSegment interface.
        WsbAssertHr(((IUnknown*)(ISegRec*) this)->QueryInterface(IID_ISegRec,
                    (void**) &pSegment1));


        try {
            // Set the Segment to a value, and see if it is returned.
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CSegRec, 0, 6, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(pSegment1->GetSegmentRecord(&l_BagId, &l_SegStartLoc, &l_SegLen, &l_SegFlags, &l_PrimPos, &l_SecPos));

            WsbAssert((l_BagId == CLSID_CSegRec) && (l_SegStartLoc == 0) &&
                      (l_SegLen == 6) && (l_SegFlags == 0) && (l_PrimPos == CLSID_CSegRec) && 
                      (l_SecPos == 0), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAssertHr(CoCreateInstance(CLSID_CSegRec, NULL, CLSCTX_ALL, IID_ISegRec, (void**) &pSegment2));

            // Check the default values.
            WsbAssertHr(pSegment2->GetSegmentRecord(&l_BagId, &l_SegStartLoc, &l_SegLen, &l_SegFlags, &l_PrimPos, &l_SecPos));
            WsbAssert(((l_BagId == GUID_NULL) && (l_SegStartLoc == 0) && (l_SegLen == 0) &&
                      (l_SegFlags == 0) && (l_PrimPos == GUID_NULL) && (l_SecPos == 0)), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

#ifdef OLD_CODE
        hr = S_OK;
        try {
            // Equal
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 1, 100, 0, CLSID_CWsbBool,0 ));
            WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbBool, 1, 100, 0, CLSID_CWsbBool,0 ));

            WsbAssertHr(pSegment1->CompareToISegmentRecord(pSegment2, &result));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 5, 6, 3, CLSID_CWsbBool,1 ));
            WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));

            WsbAssert((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_FALSE), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             // CompareTo()
             WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 1, 100, 0, CLSID_CWsbBool,0 ));
             WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbBool, 10, 6, 0, CLSID_CWsbBool,0 ));

             WsbAssert((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_FALSE), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CWsbBool,0 ));
            WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));

            WsbAssert(((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_FALSE) && (result > 0)), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CWsbBool,0 ));
             WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CWsbBool,0 ));

             WsbAssert((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_OK), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
        // Try out the persistence stuff.
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;

            WsbAssertHr(pSegment1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAssertHr(pSegment2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

            LPOLESTR    szTmp = NULL;
            // The item should be dirty.
            try {
                WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));
                WsbAssertHr(pFile2->IsDirty());
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Save the item, and remember.
                WsbAssertHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbSegment.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // It shouldn't be dirty.
                WsbAssert((pFile2->IsDirty() == S_FALSE), E_FAIL);

            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Try reading it in to another object.
                WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));
                WsbAssertHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbSegment.tst"), 0));

                WsbAssertHr(pSegment1->CompareToISegmentRecord(pSegment2, &result));
            }WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }
        } WsbCatch(hr);
#endif
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::Test"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));
#else
    UNREFERENCED_PARAMETER(pTestsPassed);
    UNREFERENCED_PARAMETER(pTestsFailed);
#endif
    return(S_OK);
}


HRESULT CSegRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                WsbGuidAsString(m_BagId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", StartLoc = %ls"), 
                WsbLonglongAsString(m_SegStartLoc)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegLen = %ls"), 
                WsbLonglongAsString(m_SegLen)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegFlags = %X"), 
                m_SegFlags));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", PrimPos = %ls"), 
                WsbGuidAsString(m_PrimPos)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SecPos = %ls "), 
                WsbLonglongAsString(m_SecPos)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CSegRec::Split
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen, 
    IN ISegRec* /*pSegRec1*/,
    IN ISegRec* /*pSegRec2*/
    )
 /*++

Routine Description:

  See ISegRec::Split().

Arguments:

  See ISegRec::Split().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CSegRec::Split"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), SegStartLoc, SegLen);

    //Fill in the two segment records splitting the current record around the hole
    //Note that there may not always be two segments generated by the split e.g., if
    //the hole is at the beginning or end of the segment record or if the hole is the
    //entire record.


    WsbTraceOut(OLESTR("CSegRec::Split"), OLESTR("hr = <%ls>"),
        WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CSegRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
        WsbAffirmHr(pKey->AppendLonglong(m_SegStartLoc));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\task.cpp ===
// task.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f taskps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "engine.h"
#include "Task.h"
#include "TskMgr.h"
#include "metaint.h"
#include "metalib.h"
#include "segrec.h"
#include "segdb.h"
#include "baghole.h"
#include "bagInfo.h"
#include "medInfo.h"
#include "VolAsgn.h"
#include "hsmworkq.h"
#include "hsmworki.h"
#include "hsmreclq.h"
#include "hsmrecli.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CHsmTskMgr, CHsmTskMgr)
    OBJECT_ENTRY(CLSID_CHsmWorkQueue, CHsmWorkQueue)
    OBJECT_ENTRY(CLSID_CHsmWorkItem, CHsmWorkItem)
    OBJECT_ENTRY(CLSID_CHsmRecallQueue, CHsmRecallQueue)
    OBJECT_ENTRY(CLSID_CHsmRecallItem, CHsmRecallItem)
    OBJECT_ENTRY(CLSID_CSegRec, CSegRec)
    OBJECT_ENTRY(CLSID_CBagHole, CBagHole)
    OBJECT_ENTRY(CLSID_CBagInfo, CBagInfo)
    OBJECT_ENTRY(CLSID_CMediaInfo, CMediaInfo)
    OBJECT_ENTRY(CLSID_CVolAssign, CVolAssign)
    OBJECT_ENTRY(CLSID_CSegDb, CSegDb)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    // registers object
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) { 
      hr = _Module.RegisterServer( FALSE );
      CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CoInitialize(0);

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\segrec.h ===
// SegRec.h : Declaration of the CSegRec


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// seg

class CSegRec : 
    public CWsbDbEntity,
    public ISegRec,
    public CComCoClass<CSegRec,&CLSID_CSegRec>
{
public:
    CSegRec() {}
BEGIN_COM_MAP(CSegRec)
    COM_INTERFACE_ENTRY(ISegRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CSegRec, _T("Seg.SegRec.1"), _T("Seg.SegRec"), IDS_SEGREC_DESC, THREADFLAGS_BOTH)

// ISegRec
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// ISegmentRecord
public:
    STDMETHOD(GetSegmentRecord)(GUID* pBagId, LONGLONG *pSegStartLoc, LONGLONG *pSegLen, USHORT *pSegFlags, GUID *pPrimPos, LONGLONG *pSecPos );
    STDMETHOD(SetSegmentRecord)(GUID bagId, LONGLONG segStartLoc, LONGLONG SegLen, USHORT SegFlags, GUID PrimPos, LONGLONG SecPos );
    STDMETHOD(Split)(GUID bagId, LONGLONG segStartLoc, LONGLONG segLen, ISegRec* pSegRec1, ISegRec* pSegRec2);
    STDMETHOD(GetSegmentFlags)(USHORT *pSegFlags);
    STDMETHOD(SetSegmentFlags)(USHORT SegFlags);
    STDMETHOD(GetPrimPos)(GUID* pPrimPos);
    STDMETHOD(SetPrimPos)(GUID PrimPos);
    STDMETHOD(GetSecPos)(LONGLONG *pSecPos);
    STDMETHOD(SetSecPos)(LONGLONG SecPos);

private:
    GUID            m_BagId;
    LONGLONG        m_SegStartLoc;
    LONGLONG        m_SegLen;
    USHORT          m_SegFlags;
    GUID            m_PrimPos;
    LONGLONG        m_SecPos;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\tskmgr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

	 tskmgr.cpp

Abstract:

	 This class represents the HSM task manager

Author:

	 Cat Brant   [cbrant]   6-Dec-1996

Revision History:

     Incorporate demand recall queue support
     - Ravisankar Pudipeddi [ravisp]  1-Oct-199
    

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR

#include "wsb.h"
#include "hsmconn.h"
#include "hsmeng.h"

#include "fsa.h"
#include "task.h"
#include "tskmgr.h"
#include "hsmWorkQ.h"
#include "engine.h"

#define MAX_WORK_QUEUE_TYPES       7


HRESULT
CHsmTskMgr::FinalConstruct(
								  void
								  )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
	HRESULT     hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::FinalConstruct"),OLESTR(""));
	try {
		int index = 0;

		WsbAssertHr(CComObjectRoot::FinalConstruct());
		m_pWorkQueues = 0;
		m_NumWorkQueues = 0;

		// Set up queue type info and set limits
		m_nWorkQueueTypes = 0;
		m_pWorkQueueTypeInfo = static_cast<PHSM_WORK_QUEUE_TYPE_INFO>
									  (WsbAlloc(MAX_WORK_QUEUE_TYPES *
													sizeof(HSM_WORK_QUEUE_TYPE_INFO)));
		WsbAffirmPointer(m_pWorkQueueTypeInfo);

		// Migrate queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_MIGRATE;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 1;	 // For Migrate, this is useless now
																			 // - the limit is dynamically set
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		// Recall queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_RECALL;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 1;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		// Demand Recall queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_DEMAND_RECALL;
		//
		// MaxActiveAllowed is irrelevant for demand recall queues
		// as it is computed afresh
		//
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 1;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		// Validate queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_VALIDATE;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 2;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;


		// Validate_for_truncate queues.  MaxActiveAllowed is essentially
		// unlimited because this is the type of queue that the FSA's
		// auto-truncator creates. Because there is one queue for each managed
		// volume and these queues never go away, we can't limit the number
		// or we will create problems.  The Truncate job also
		// creates this type of queue which means that type of job is not
		// limited by this mechanism, but that's the way it goes.
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_VALIDATE_FOR_TRUNCATE;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 99999;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		m_nWorkQueueTypes = index;

	}WsbCatch(hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::FinalConstruct"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::FinalRelease(
								void
								)
/*++

Routine Description:

  This method does some clean up of the object that is necessary
  before destruction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalRelease().

--*/
{
	HRESULT     hr = S_OK;
	HSM_SYSTEM_STATE SysState;

	WsbTraceIn(OLESTR("CHsmTskMgr::FinalRelease"),OLESTR(""));

	SysState.State = HSM_STATE_SHUTDOWN;
	ChangeSysState(&SysState);

	CComObjectRoot::FinalRelease();

	// Free member resources
	if (0 != m_pWorkQueues) {
		WsbFree(m_pWorkQueues);
		m_pWorkQueues = NULL;
	}
	if (m_pWorkQueueTypeInfo) {
		WsbFree(m_pWorkQueueTypeInfo);
		m_pWorkQueueTypeInfo = NULL;
	}
	m_nWorkQueueTypes = 0;

	DeleteCriticalSection(&m_WorkQueueLock);
	DeleteCriticalSection(&m_CurrentRunningLock);
	DeleteCriticalSection(&m_CreateWorkQueueLock);


	WsbTraceOut(OLESTR("CHsmTskMgr::FinalRelease"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}

HRESULT
CHsmTskMgr::Init(
					 IUnknown *pServer
					 )
/*++
Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
--*/
{
	HRESULT     hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::Init"),OLESTR(""));
	try {
		// Initialize critical sections
		InitializeCriticalSectionAndSpinCount (&m_WorkQueueLock, 1000);
		InitializeCriticalSectionAndSpinCount (&m_CurrentRunningLock, 1000);
		InitializeCriticalSectionAndSpinCount (&m_CreateWorkQueueLock, 1000);
		//
		// Get the server interface
		//
		WsbAffirmHr(pServer->QueryInterface(IID_IHsmServer, (void **)&m_pServer));
		//We want a weak link to the server so decrement the reference count
		m_pServer->Release();
		WsbAffirmHr(m_pServer->QueryInterface(IID_IWsbCreateLocalObject, (void **)&m_pHsmServerCreate));
		// We want a weak link to the server so decrement the reference count
		m_pHsmServerCreate->Release();

		// Go ahead and preallocate some space for the work queues
		WsbAffirmHr(IncreaseWorkQueueArraySize(HsmWorkQueueArrayBumpSize));

	}WsbCatch( hr );

	WsbTraceOut(OLESTR("CHsmTskMgr::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return( hr );

}

HRESULT
CHsmTskMgr::ContactOk(
							void
							)
/*++
Routine Description:

  This allows the caller to see if the RPC connection
  to the task manager is OK

Arguments:

  None.

Return Value:

  S_OK
--*/
{

	return( S_OK );

}

HRESULT
CHsmTskMgr::DoFsaWork(
							IFsaPostIt *pFsaWorkItem
							)
/*++

Implements:

  IHsmFsaTskMgr::DoFsaWork

--*/
{
	HRESULT                     hr = S_OK;
	CComPtr<IHsmSession>        pSession;
	CComPtr<IHsmWorkQueue>      pWorkQueue;
	CComPtr<IHsmRecallQueue>    pRecallQueue;
	FSA_REQUEST_ACTION          workAction;
	GUID                        mediaId;
    LONGLONG                    dataSetStart;


	WsbTraceIn(OLESTR("CHsmTskMgr::DoFsaWork"),OLESTR(""));
	try {
		CWsbStringPtr       path;
		LONGLONG            fileVersionId;
		FSA_PLACEHOLDER     placeholder;
		GUID                hsmId, bagId;
		BOOL                bCreated;

		// Get the version Id from the work Item.
		WsbAffirmHr(pFsaWorkItem->GetFileVersionId(&fileVersionId));

		// Get the placeholder from the work item
		WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));

		// Get the HSM ID from the server
		WsbAffirmHr(m_pServer->GetID(&hsmId));

		//
		// Make sure this instance of the engine managed the file
		//
		if ((GUID_NULL != placeholder.hsmId) && (hsmId != placeholder.hsmId)) {
			CWsbStringPtr           path;

			(void)pFsaWorkItem->GetPath(&path, 0);
			hr = HSM_E_FILE_MANAGED_BY_DIFFERENT_HSM;
			WsbLogEvent(HSM_MESSAGE_FILE_MANAGED_BY_DIFFERENT_HSM, 0, NULL, WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
			WsbThrow(hr);
		}

		//
		// Make sure there is a work allocater for this session
		//
		WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
		WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
		WsbAffirmHr(pFsaWorkItem->GetRequestAction(&workAction));
		WsbTrace(OLESTR("CHsmTskMgr::DoFsaWork for <%ls> for <%lu>.\n"), (WCHAR *)path, workAction);

		if ((workAction == FSA_REQUEST_ACTION_FILTER_RECALL) ||
   		    (workAction == FSA_REQUEST_ACTION_FILTER_READ)) {
            WsbAffirmHr(FindRecallMediaToUse(pFsaWorkItem, &mediaId, &bagId, &dataSetStart));
			WsbAffirmHr(AddToRecallQueueForFsaSession(pSession,&pRecallQueue, &bCreated, &mediaId, &bagId, dataSetStart, pFsaWorkItem));

		} else {
			WsbAffirmHr(EnsureQueueForFsaSession(pSession, workAction, &pWorkQueue, &bCreated));
			//
			// Give the work to a queue
			//
			WsbAffirmHr(pWorkQueue->Add(pFsaWorkItem));
		}
		//
		// Start any queues that qualify (performance: only when a new queue is created)
		//
		if (bCreated) {
			WsbAffirmHr(StartQueues());
		}

	}WsbCatch (hr);


	WsbTraceOut(OLESTR("CHsmTskMgr::DoFsaWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::EnsureQueueForFsaSession(
												IN  IHsmSession     *pSession,
												IN  FSA_REQUEST_ACTION fsaAction,
												OUT IHsmWorkQueue   **ppWorkQueue,
												OUT BOOL            *bCreated
												)

/*++



--*/
{
	HRESULT                 hr = S_OK;
	HSM_WORK_QUEUE_STATE    state;
	ULONG                   index;
	CComPtr<IHsmSession>    l_pSession;
	HSM_WORK_QUEUE_TYPE     type1=HSM_WORK_TYPE_NONE;
	HSM_WORK_QUEUE_TYPE     type2;
	FILETIME                birthDate;
	SYSTEMTIME              systemTime;
	GUID                    sessionGuid;


	WsbTraceIn(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession"),OLESTR("FsaRequestAction = <%lu>, Waiting on CreateWorkQueueLock"), fsaAction);
	EnterCriticalSection(&m_CreateWorkQueueLock);
	try {
		WsbAffirm(0 != ppWorkQueue, E_POINTER);
		// Convert FSA action to work queue type
		switch (fsaAction) {
		case FSA_REQUEST_ACTION_FILTER_READ:
		case FSA_REQUEST_ACTION_FILTER_RECALL:
			//
			// Should not happen!! AddToRecallQueueForFsaSession is the
			// right interface for recall items
			//
			WsbThrow(E_INVALIDARG);
			break;
		case FSA_REQUEST_ACTION_RECALL:
			type1 = HSM_WORK_TYPE_FSA_RECALL;
			break;
		case FSA_REQUEST_ACTION_PREMIGRATE:
			type1 = HSM_WORK_TYPE_FSA_MIGRATE;
			break;
		case FSA_REQUEST_ACTION_VALIDATE:
			type1 = HSM_WORK_TYPE_FSA_VALIDATE;
			break;
		case FSA_REQUEST_ACTION_VALIDATE_FOR_TRUNCATE:
			type1 = HSM_WORK_TYPE_FSA_VALIDATE_FOR_TRUNCATE;
			break;
		default:
			hr = E_NOTIMPL;
			type1 = HSM_WORK_TYPE_NONE;
			break;
		}
		WsbTrace(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession: type1 = %d\n"),
					static_cast<int>(type1));

		// Check the array of work queues and see if there is one for
		// this session.
		*bCreated = FALSE;
		hr = FindWorkQueueElement(pSession, type1, &index, NULL);
		if (hr == S_OK) {
			WsbAffirmHr(GetWorkQueueElement(index, &l_pSession, ppWorkQueue, &type2, &state, &birthDate));
			if ((l_pSession != pSession) || (type1 != type2)) {
				*ppWorkQueue = 0;
				WsbAssertHr(E_UNEXPECTED);
			}
			if (HSM_WORK_QUEUE_NONE == state) {
				WsbTrace(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession: Creating new queue (state is NONE)\n"));
				WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkQueue, IID_IHsmWorkQueue,
																			  (void **)ppWorkQueue));
				WsbAffirmHr((*ppWorkQueue)->Init(m_pServer, pSession, (IHsmFsaTskMgr *)this, type1));
				GetSystemTime(&systemTime);
				WsbAffirmStatus(SystemTimeToFileTime(&systemTime, &birthDate));
				WsbAffirmHr(pSession->GetIdentifier(&sessionGuid));
				m_pWorkQueues[index].sessionId = sessionGuid;
				WsbAffirmHr(SetWorkQueueElement(index, pSession, *ppWorkQueue, type1, HSM_WORK_QUEUE_IDLE, birthDate));
				*bCreated = TRUE;
			}
		} else {
			if (hr == WSB_E_NOTFOUND) {
				hr = S_OK;
				WsbTrace(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession: Creating new queue (queue not found)\n"));
				WsbAffirmHr(AddWorkQueueElement(pSession, type1, &index));
				// The work queue has not been created so create it
				WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkQueue, IID_IHsmWorkQueue,
																			  (void **)ppWorkQueue));
				WsbAffirmHr((*ppWorkQueue)->Init(m_pServer, pSession, (IHsmFsaTskMgr *)this, type1));
				GetSystemTime(&systemTime);
				WsbAffirmStatus(SystemTimeToFileTime(&systemTime, &birthDate));
				WsbAffirmHr(pSession->GetIdentifier(&sessionGuid));
				m_pWorkQueues[index].sessionId = sessionGuid;
				WsbAffirmHr(SetWorkQueueElement(index, pSession, *ppWorkQueue, type1, HSM_WORK_QUEUE_IDLE, birthDate));
				*bCreated = TRUE;
			}
		}

	}WsbCatch( hr );

	LeaveCriticalSection(&m_CreateWorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::AddToRecallQueueForFsaSession(
														IN  IHsmSession     *pSession,
														OUT IHsmRecallQueue **ppWorkQueue,
														OUT BOOL            *bCreated,
														IN GUID             *pMediaId,
                                                        IN GUID             *pBagId,
                                                        IN LONGLONG          dataSetStart,
														IN IFsaPostIt 		  *pFsaWorkItem
														)

/*++



--*/
{
	HRESULT                 hr = S_OK;


	WsbTraceIn(OLESTR("CHsmTskMgr::AddToRecallQueueForFsaSession"),OLESTR("Waiting on CreateWorkQueueLock"));

	EnterCriticalSection(&m_WorkQueueLock);
	try {
		WsbAffirm(0 != ppWorkQueue, E_POINTER);
		//
		// This call will find the queue if it's already present -
		// and if not it will create a new queue and set it to the required media id
		//
		WsbAffirmHr(FindRecallQueueElement(pSession, pMediaId, ppWorkQueue, bCreated));
		hr = (*ppWorkQueue)->Add(pFsaWorkItem,
                                 pBagId,
                                 dataSetStart);

	}WsbCatch( hr );

	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::AddToRecallQueueForFsaSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::IncreaseWorkQueueArraySize(
												  ULONG numToAdd
												  )
{
	HRESULT             hr = S_OK;
	ULONG               memSize;
	LPVOID              pTemp;

	//Begin Critical Section
	WsbTraceIn(OLESTR("CHsmTskMgr::IncreaseWorkQueueArraySize"),OLESTR("NumToAdd = %lu - Waiting for WorkQueueLock"), numToAdd);
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		memSize = (m_NumWorkQueues + numToAdd) * sizeof(HSM_WORK_QUEUES);
		pTemp = WsbRealloc(m_pWorkQueues, memSize);
		WsbAffirm(0 != pTemp, E_FAIL);
		m_pWorkQueues = (HSM_WORK_QUEUES *) pTemp;
		ZeroMemory( (m_pWorkQueues + m_NumWorkQueues), (numToAdd * sizeof(HSM_WORK_QUEUES))
					 );
		m_NumWorkQueues += numToAdd;
	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::IncreaseWorkQueueArraySize"),OLESTR("hr = <%ls>, QueuesInArray = <%lu>"),
					WsbHrAsString(hr), m_NumWorkQueues);
	return(hr);
}


HRESULT
CHsmTskMgr::WorkQueueDone(
								 IHsmSession *pSession,
								 HSM_WORK_QUEUE_TYPE type,
								 GUID             *pMediaId
								 )
{
	HRESULT             hr = S_OK;
	ULONG               index;
	FILETIME            dummyTime;
	IHsmRecallQueue	 *pRecallQueue;
	BOOL					  locked = FALSE;

	WsbTraceIn(OLESTR("CHsmTskMgr::WorkQueueDone"),OLESTR("type = %d"),
				  static_cast<int>(type));
	try {
		EnterCriticalSection(&m_WorkQueueLock);
		locked = TRUE;
		//
		// Get the work queue index
		//
		hr = FindWorkQueueElement(pSession, type, &index, pMediaId);
		if (hr == S_OK) {
			WsbTrace(OLESTR("CHsmTskMgr::WorkQueueDone - ending queue # %lu\n"),
						index);
			ZeroMemory(&dummyTime, sizeof(FILETIME));
		   if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				//
				// It is possible for recall queues that an element was added
				// just before we entered the critical section above
				//
				pRecallQueue = m_pWorkQueues[index].pRecallQueue;
				if (pRecallQueue->IsEmpty() == S_OK) {
					//
					// Ok to destroy the queue
					//
					WsbAffirmHr(SetRecallQueueElement(index, 0, HSM_WORK_TYPE_NONE, HSM_WORK_QUEUE_NONE, dummyTime));
				} else {
					//
					// We are not going to destroy the queue, since an element seems to have been added
					// before we locked the work queues
					//
					hr = S_FALSE;
				}
			} else {
				WsbAffirmHr(SetWorkQueueElement(index, 0, 0, HSM_WORK_TYPE_NONE, HSM_WORK_QUEUE_NONE, dummyTime));
			}
			LeaveCriticalSection(&m_WorkQueueLock);
			locked = FALSE;

			if (hr == S_OK) {
				// Reduce active count for this work queue type
				// It must protected from starting (activating) queues
				EnterCriticalSection(&m_CurrentRunningLock);
				for (ULONG i = 0; i < m_nWorkQueueTypes; i++) {
					if (type == m_pWorkQueueTypeInfo[i].Type) {
						if (m_pWorkQueueTypeInfo[i].NumActive > 0) {
							m_pWorkQueueTypeInfo[i].NumActive--;
						}
						break;
					}
				}
    			LeaveCriticalSection(&m_CurrentRunningLock);
			}
		} else {
			LeaveCriticalSection(&m_WorkQueueLock);
			locked = FALSE;
			WsbAffirmHr(hr);
		}

		if (hr == S_OK) {
			//
			// If there are any queues waiting to start, start them
			//
			WsbAffirmHr(StartQueues());
		}
	}WsbCatchAndDo (hr,
						 if (locked) {
							 LeaveCriticalSection(&m_WorkQueueLock);
							 locked = FALSE;
						 }
						);


	WsbTraceOut(OLESTR("CHsmTskMgr::WorkQueueDone"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::AddWorkQueueElement(
										 IHsmSession *pSession,
										 HSM_WORK_QUEUE_TYPE type,
										 ULONG *pIndex
										 )
{
	HRESULT             hr = S_OK;
	BOOLEAN             foundOne = FALSE;

	WsbTraceIn(OLESTR("CHsmTskMgr::AddWorkQueueElement"),
				  OLESTR("type = %d, Waiting on WorkQueueLock"),
				  static_cast<int>(type));

	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);

	try {
		WsbAssert(0 != pIndex, E_POINTER);
		// Scan the array looking for an empty element
		for (ULONG i = 0; ((i < m_NumWorkQueues) && (foundOne == FALSE)); i++) {
			if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_NONE) {
				foundOne = TRUE;
				*pIndex = i;
				if (type != HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
					//
					// Stow away the session. For recall queues, the session
					// is stored in the work item
					//
					m_pWorkQueues[i].pSession = pSession;
				}
				m_pWorkQueues[i].queueType = type;
			}
		}

		if (foundOne == FALSE) {
			// There are no empty elements so we need to add more
			*pIndex = m_NumWorkQueues;
			WsbAffirmHr(IncreaseWorkQueueArraySize(HsmWorkQueueArrayBumpSize));
			if (type != HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				//
				// We store the session in the work-queue element itself..
				// Just indicate this slot is taken..
				//
				m_pWorkQueues[*pIndex].pSession = pSession;
			}
			m_pWorkQueues[*pIndex].queueType = type;
		}

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);

	WsbTraceOut(OLESTR("CHsmTskMgr::AddWorkQueueElement"),
					OLESTR("hr = <%ls>, index = %lu"),WsbHrAsString(hr), *pIndex);
	return(hr);
}

HRESULT
CHsmTskMgr::FindWorkQueueElement(
										  IHsmSession *pSession,
										  HSM_WORK_QUEUE_TYPE type,
										  ULONG *pIndex,
										  GUID *pMediaId
										  )
{
	HRESULT             hr = S_OK;
	BOOLEAN             foundOne = FALSE;
	GUID					  id;

	WsbTraceIn(OLESTR("CHsmTskMgr::FindWorkQueueElement"),
				  OLESTR("type = %d, Waiting on WorkQueueLock"),
				  static_cast<int>(type));

	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);

	try {

		WsbAssert(0 != pIndex, E_POINTER);

		// Scan the array looking for an empty element
		for (ULONG i = 0; ((i < m_NumWorkQueues) && (foundOne == FALSE)); i++) {
			if (m_pWorkQueues[i].queueType == type) {
				if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
					m_pWorkQueues[i].pRecallQueue->GetMediaId(&id);
					if (WsbCompareGuid(id, *pMediaId) != 0)  {
						continue;
					}
				} else if (pSession != m_pWorkQueues[i].pSession) {
					continue;
				}
				foundOne = TRUE;
				*pIndex = i;
			}
		}

		if (FALSE == foundOne) {
			hr = WSB_E_NOTFOUND;
		}
	}WsbCatch (hr);
	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::FindWorkQueueElement"),OLESTR("hr = <%ls>, index = <%ls>"),
					WsbHrAsString(hr), WsbPtrToUlongAsString(pIndex));
	return(hr);
}


HRESULT
CHsmTskMgr::FindRecallQueueElement(
											 IN IHsmSession *pSession,
											 IN GUID   *pMediaId,
											 OUT IHsmRecallQueue **ppWorkQueue,
											 OUT BOOL         *bCreated
											 )
{
	HRESULT             hr = S_OK;
	BOOLEAN             foundOne = FALSE;
	GUID                id;
	FILETIME            birthDate;
	SYSTEMTIME          systemTime;
	ULONG            index=0;

	UNREFERENCED_PARAMETER(pSession);

	//
	// Important assumption: m_WorkQueueLock is held before calling this function
	//
	WsbTraceIn(OLESTR("CHsmTskMgr::FindRecallQueueElement"),
				  OLESTR("Waiting on WorkQueueLock"));

	*bCreated =  FALSE;

	try {
		for (ULONG i=0;  (i < m_NumWorkQueues) && (foundOne == FALSE); i++) {
			//
			// Get the media id for the work queue
			//
			if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				if (m_pWorkQueues[i].pRecallQueue != NULL) {
					WsbAffirmHr(m_pWorkQueues[i].pRecallQueue->GetMediaId(&id));
					if ((WsbCompareGuid(id, *pMediaId) == 0)) {
						foundOne = TRUE;
						index = i;
					}
				}
			}
		}

		if (FALSE == foundOne) {
			//
			// No exisiting media queue was found. Make a new one
			//
			for (ULONG i = 0; ((i < m_NumWorkQueues) && (foundOne == FALSE)); i++) {
				if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_NONE) {
					foundOne = TRUE;
					index = i;
				}
			}

			if (foundOne == FALSE) {
				// There are no empty elements so we need to add more
				index = m_NumWorkQueues;
				WsbAffirmHr(IncreaseWorkQueueArraySize(HsmWorkQueueArrayBumpSize));
			}
			//
			// At this point we have the free slot index in index
			// The work queue has not been created so create it
			//
			WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallQueue, IID_IHsmRecallQueue,
																		  (void **)ppWorkQueue));
			WsbAffirmHr((*ppWorkQueue)->SetMediaId(pMediaId));
			WsbAffirmHr((*ppWorkQueue)->Init(m_pServer,  (IHsmFsaTskMgr *)this));
			GetSystemTime(&systemTime);
			WsbAffirmStatus(SystemTimeToFileTime(&systemTime, &birthDate));
			m_pWorkQueues[index].queueType = HSM_WORK_TYPE_FSA_DEMAND_RECALL;
			m_pWorkQueues[index].pSession = NULL;
			m_pWorkQueues[index].pRecallQueue = *ppWorkQueue;
			m_pWorkQueues[index].queueState = HSM_WORK_QUEUE_IDLE;
			m_pWorkQueues[index].birthDate = birthDate;
			//
			// Indicate a new queue was created
			//
			*bCreated = TRUE;
		} else {
			//
			// Queue is already present, index points to it
			//
			*ppWorkQueue = m_pWorkQueues[index].pRecallQueue;
			if (0 != *ppWorkQueue) {
				//
				// We need to AddRef it..
				//
				(*ppWorkQueue)->AddRef();
			}
		}
	}WsbCatch (hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::FindRecallQueueElement"),OLESTR("hr = <%ls>, index = <%ls>"),
					WsbHrAsString(hr), WsbLongAsString((LONG)index));
	return(hr);
}


HRESULT
CHsmTskMgr::GetWorkQueueElement(
										 ULONG index,
										 IHsmSession **ppSession,
										 IHsmWorkQueue **ppWorkQueue,
										 HSM_WORK_QUEUE_TYPE *pType,
										 HSM_WORK_QUEUE_STATE *pState,
										 FILETIME *pBirthDate
										 )
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::GetWorkQueueElement"),
				  OLESTR("index = %lu, Waiting on WorkQueueLock"), index);
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		*pType = m_pWorkQueues[index].queueType;

		*ppSession = m_pWorkQueues[index].pSession;
		if (0 != *ppSession) {
			(*ppSession)->AddRef();
		}

		*ppWorkQueue = m_pWorkQueues[index].pWorkQueue;
		if (0 != *ppWorkQueue) {
			(*ppWorkQueue)->AddRef();
		}
		*pState = m_pWorkQueues[index].queueState;
		*pBirthDate = m_pWorkQueues[index].birthDate;

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::GetWorkQueueElement"),
					OLESTR("hr = <%ls>, type = %d"),WsbHrAsString(hr),
					static_cast<int>(*pType));
	return(hr);
}


HRESULT
CHsmTskMgr::GetRecallQueueElement(
											ULONG index,
											IHsmRecallQueue **ppWorkQueue,
											HSM_WORK_QUEUE_STATE *pState,
											FILETIME *pBirthDate
											)
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::GetRecallQueueElement"),
				  OLESTR("index = %lu, Waiting on WorkQueueLock"), index);
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		WsbAffirm(m_pWorkQueues[index].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL, E_INVALIDARG);

		*ppWorkQueue = m_pWorkQueues[index].pRecallQueue;
		if (0 != *ppWorkQueue) {
			(*ppWorkQueue)->AddRef();
		}
		*pState = m_pWorkQueues[index].queueState;
		*pBirthDate = m_pWorkQueues[index].birthDate;

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::GetRecallQueueElement"),
					OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::SetWorkQueueElement(
										 ULONG index,
										 IHsmSession *pSession,
										 IHsmWorkQueue *pWorkQueue,
										 HSM_WORK_QUEUE_TYPE type,
										 HSM_WORK_QUEUE_STATE state,
										 FILETIME birthDate
										 )
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("Waiting on WorkQueueLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		m_pWorkQueues[index].pSession = pSession;
		m_pWorkQueues[index].pWorkQueue = pWorkQueue;
		m_pWorkQueues[index].queueType = type;
		m_pWorkQueues[index].queueState = state;
		m_pWorkQueues[index].birthDate = birthDate;

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::SetRecallQueueElement(
											ULONG index,
											IHsmRecallQueue *pWorkQueue,
											HSM_WORK_QUEUE_TYPE queueType,
											HSM_WORK_QUEUE_STATE state,
											FILETIME birthDate
											)
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("Waiting on WorkQueueLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		WsbAffirm(m_pWorkQueues[index].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL, E_INVALIDARG);
		//
		// Ensure the session pointer is empty, this is unused for recall queues
		//
		m_pWorkQueues[index].pSession = NULL;
		m_pWorkQueues[index].queueType = queueType;
		m_pWorkQueues[index].pRecallQueue = pWorkQueue;
		m_pWorkQueues[index].queueState = state;
		m_pWorkQueues[index].birthDate = birthDate;
	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::RemoveWorkQueueElement(
											 ULONG index
											 )
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::RemoveWorkQueueElement"),OLESTR("Waiting on WorkQueueLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		m_pWorkQueues[index].pSession = 0;
		m_pWorkQueues[index].pWorkQueue = 0;
		m_pWorkQueues[index].queueType = HSM_WORK_TYPE_NONE;
		m_pWorkQueues[index].queueState = HSM_WORK_QUEUE_NONE;
		ZeroMemory(&(m_pWorkQueues[index].birthDate), sizeof(FILETIME));

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::RemoveWorkQueueElement"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::StartQueues( void )
{
	HRESULT             hr = S_OK;
	ULONG               uActive;

	WsbTraceIn(OLESTR("CHsmTskMgr::StartQueues"),OLESTR("Waiting on CurrentRunningLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_CurrentRunningLock);
	try {
		// Go over work types, and start (activate) queues until the threshold
		// for the work type is reached
		for (ULONG i = 0; i < m_nWorkQueueTypes; i++) {
			// For Migrate queues, get the (dynamically set) Allowed limit
			if ((HSM_WORK_TYPE_FSA_MIGRATE == m_pWorkQueueTypeInfo[i].Type) ||
				 (HSM_WORK_TYPE_FSA_DEMAND_RECALL == m_pWorkQueueTypeInfo[i].Type)) {
				WsbAffirmHr(m_pServer->GetCopyFilesLimit( &(m_pWorkQueueTypeInfo[i].MaxActiveAllowed) ));
			}

			WsbTrace(OLESTR("CHsmTskMgr::StartQueues: QueueType[%lu].NumActive = %lu, Allowed = %lu\n"),
						i, m_pWorkQueueTypeInfo[i].NumActive,
						m_pWorkQueueTypeInfo[i].MaxActiveAllowed);
			while ((uActive = m_pWorkQueueTypeInfo[i].NumActive) <
					 m_pWorkQueueTypeInfo[i].MaxActiveAllowed) {
				WsbAffirmHr(StartFsaQueueType(m_pWorkQueueTypeInfo[i].Type));
				if (uActive == m_pWorkQueueTypeInfo[i].NumActive) {
					// no more work queues to activate - get out...
					break;
				}
			}
		}
	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_CurrentRunningLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::StartQueues"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::StartFsaQueueType(HSM_WORK_QUEUE_TYPE type)
{
	HRESULT                   hr = S_OK;
	CComPtr<IHsmWorkQueue>    pWorkQueue;
	CComPtr<IHsmRecallQueue>  pRecallQueue;
	ULONG                     index;

	WsbTraceIn(OLESTR("CHsmTskMgr::StartFsaQueueType"),OLESTR("type = %d"),
				  static_cast<int>(type));
	try {
		// Find the oldest queue of this type
		hr = FindOldestQueue(type, &index);
		if (S_OK == hr) {
			HSM_WORK_QUEUE_STATE    state;
			CComPtr<IHsmSession>    l_pSession;
			HSM_WORK_QUEUE_TYPE     l_type;
			FILETIME                birthDate;

			// Make sure that the queue is idle
			if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				WsbAffirmHr(GetRecallQueueElement(index, &pRecallQueue, &state, &birthDate));
			} else {
				WsbAffirmHr(GetWorkQueueElement(index, &l_pSession, &pWorkQueue,
														  &l_type, &state, &birthDate));
			}
			if (HSM_WORK_QUEUE_IDLE == state) {
				if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
					WsbAffirmHr(SetRecallQueueElement(index, pRecallQueue,
																 HSM_WORK_TYPE_FSA_DEMAND_RECALL,
																 HSM_WORK_QUEUE_STARTING, birthDate));
					WsbAffirmHr(pRecallQueue->Start());
					WsbAffirmHr(SetRecallQueueElement(index, pRecallQueue,
																 HSM_WORK_TYPE_FSA_DEMAND_RECALL,
																 HSM_WORK_QUEUE_STARTED, birthDate));
				} else {
					WsbAffirmHr(SetWorkQueueElement(index, l_pSession, pWorkQueue,
															  type, HSM_WORK_QUEUE_STARTING, birthDate));
					WsbAffirmHr(pWorkQueue->Start());
					WsbAffirmHr(SetWorkQueueElement(index, l_pSession, pWorkQueue,
															  type, HSM_WORK_QUEUE_STARTED, birthDate));
				}
				WsbTrace(OLESTR("CHsmTskMgr::StartFsaQueueType - started work queue %lu\n"),
							index);


				// Increment active count for this work queue type
				for (ULONG i = 0; i < m_nWorkQueueTypes; i++) {
					if (type == m_pWorkQueueTypeInfo[i].Type) {
						m_pWorkQueueTypeInfo[i].NumActive++;
						break;
					}
				}
			}
		} else {
			if (WSB_E_NOTFOUND == hr) {
				hr = S_OK;
			}
		}
		WsbAffirmHr( hr );

	}WsbCatch (hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::StartFsaQueueType"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::FindOldestQueue(
									HSM_WORK_QUEUE_TYPE type,
									ULONG               *pIndex
									)
{
	HRESULT                 hr = S_OK;
	FILETIME                oldestOne;
	LONG                    compare;
	ULONG                   oldestIndex = 0xFFFFFFFF;
	BOOLEAN                 firstOne;

	WsbTraceIn(OLESTR("CHsmTskMgr::FindOldestQueue"),OLESTR("type = %d"),
				  static_cast<int>(type));
	try {
		WsbAffirmPointer(pIndex);

		// Start out with the first time flag equal to TRUE so we select the first one with the right state and type
		firstOne = TRUE;

		for (ULONG i = 0; (i < m_NumWorkQueues); i++) {
			if ((type == m_pWorkQueues[i].queueType) && (HSM_WORK_QUEUE_IDLE == m_pWorkQueues[i].queueState)) {
				if (!firstOne)
					compare = CompareFileTime(&(m_pWorkQueues[i].birthDate), &(oldestOne));
				else
					compare = -1;
				if (compare < 0) {
					// found an older one
					firstOne = FALSE;
					oldestOne.dwLowDateTime = m_pWorkQueues[i].birthDate.dwLowDateTime;
					oldestOne.dwHighDateTime = m_pWorkQueues[i].birthDate.dwHighDateTime;
					oldestIndex = i;
				}
			}
		}

		if (0xFFFFFFFF == oldestIndex) {
			// Didn't find a match
			hr = WSB_E_NOTFOUND;
		} else {
			HSM_WORK_QUEUE_STATE    state;
			CComPtr<IHsmSession>    l_pSession;
			CComPtr<IHsmWorkQueue>  l_pWorkQueue;
			CComPtr<IHsmRecallQueue>  l_pRecallQueue;
			HSM_WORK_QUEUE_TYPE     type2;
			FILETIME                birthDate;

			// Make sure that the queue is idle
			if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				WsbAffirmHr(GetRecallQueueElement(oldestIndex, &l_pRecallQueue, &state, &birthDate));
			} else {
				WsbAffirmHr(GetWorkQueueElement(oldestIndex, &l_pSession, &l_pWorkQueue, &type2, &state, &birthDate));
			}
			if (HSM_WORK_QUEUE_IDLE == state) {
				*pIndex = oldestIndex;
				WsbTrace(OLESTR("CHsmTskMgr::FindOldestQueue: found index = %lu\n"),
							oldestIndex);
			} else {
				WsbTrace(OLESTR("CHsmTskMgr::FindOldestQueue - found NULL queue\n"));
				hr = WSB_E_NOTFOUND;
			}
		}

	}WsbCatch (hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::FindOldestQueue"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::ChangeSysState(
								  IN OUT HSM_SYSTEM_STATE* pSysState
								  )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
	HRESULT                 hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::ChangeSysState"), OLESTR(""));

	try {

		//  Loop over work queues
		if (0 != m_pWorkQueues) {
			FILETIME            dummyTime;
			ZeroMemory(&dummyTime, sizeof(FILETIME));
			for (ULONG i = 0; i < m_NumWorkQueues; i++) {
				if (m_pWorkQueues[i].pWorkQueue) {

					if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
						if (pSysState->State & HSM_STATE_SHUTDOWN) {
							m_pWorkQueues[i].pRecallQueue->Stop();
						}
						m_pWorkQueues[i].pRecallQueue->ChangeSysState(pSysState);
					} else {
						if (pSysState->State & HSM_STATE_SHUTDOWN) {
							m_pWorkQueues[i].pWorkQueue->Stop();
						}
						m_pWorkQueues[i].pWorkQueue->ChangeSysState(pSysState);
					}
				}

				if (pSysState->State & HSM_STATE_SHUTDOWN) {
					hr = SetWorkQueueElement(i, 0, 0, HSM_WORK_TYPE_NONE, HSM_WORK_QUEUE_NONE, dummyTime);
				}
			}
		}

	}WsbCatch(hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

	return(hr);
}


HRESULT
CHsmTskMgr::FindRecallMediaToUse(
							  IN  IFsaPostIt *pFsaWorkItem,
							  OUT GUID       *pMediaToUse,
                              OUT GUID       *pBagId,
                              OUT LONGLONG   *pDataSetStart
						  )
/*++


--*/
{
	HRESULT                 hr = S_OK;
	CComQIPtr<ISegDb, &IID_ISegDb> pSegDb;
	CComPtr<IWsbDb>                 pWsbDb;
	CComPtr<IWsbDbSession>  pDbWorkSession;
	BOOL                    openedDb = FALSE;

	WsbTraceIn(OLESTR("CHsmTskMgr::FindRecallMediaToUse"),OLESTR(""));
	try {
		WsbAssert(pMediaToUse != 0, E_POINTER);
		*pMediaToUse = GUID_NULL;

		CComPtr<ISegRec>        pSegRec;
		GUID                    l_BagId;
		LONGLONG                l_FileStart;
		LONGLONG                l_FileSize;
		USHORT                  l_SegFlags;
		GUID                    l_PrimPos;
		LONGLONG                l_SecPos;
		GUID                    storagePoolId;
		FSA_PLACEHOLDER         placeholder;

		//
		// Get the segment database
		//
		WsbAffirmHr(m_pServer->GetSegmentDb(&pWsbDb));
		pSegDb = pWsbDb;
		//
		// Go to the segment database to find out where the data
		// is located.
		//
		WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
		WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));

		WsbTrace(OLESTR("Finding SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
					WsbGuidAsString(placeholder.bagId),
					WsbStringCopy(WsbLonglongAsString(placeholder.fileStart)),
					WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

		WsbAffirmHr(pSegDb->Open(&pDbWorkSession));
		openedDb = TRUE;
		hr = pSegDb->SegFind(pDbWorkSession, placeholder.bagId, placeholder.fileStart,
									placeholder.fileSize, &pSegRec);
		if (S_OK != hr) {
			//
			// We couldn't find the segment record for this information!
			//
			hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
			WsbAffirmHr(hr);
		}
		WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
														  &l_PrimPos, &l_SecPos));
		WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

        //
        // In case of an indirect record, go to the dirtect record to get real location info
        //
        if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
            pSegRec = 0;

            WsbTrace(OLESTR("Finding indirect SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                    WsbGuidAsString(l_PrimPos), WsbStringCopy(WsbLonglongAsString(l_SecPos)),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

            hr = pSegDb->SegFind(pDbWorkSession, l_PrimPos, l_SecPos,
                                 placeholder.fileSize, &pSegRec);
            if (S_OK != hr)  {
                //
                // We couldn't find the direct segment record for this segment!
                //
                hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
                WsbAffirmHr(hr);
            }

            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
                                &l_PrimPos, &l_SecPos));
            WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

            // Don't support a second indirection for now !!
            WsbAssert(0 == (l_SegFlags & SEG_REC_INDIRECT_RECORD), HSM_E_BAD_SEGMENT_INFORMATION);
        }

		//
		// Go to the media database to get the media ID
		//
		CComPtr<IMediaInfo>     pMediaInfo;
		GUID                    l_RmsMediaId;

		WsbAffirmHr(pSegDb->GetEntity(pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
												(void**)&pMediaInfo));
		WsbAffirmHr(pMediaInfo->SetId(l_PrimPos));
		hr = pMediaInfo->FindEQ();
		if (S_OK != hr) {
			hr = HSM_E_MEDIA_INFO_NOT_FOUND;
			WsbAffirmHr(hr);
		}
		WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&l_RmsMediaId));
		*pMediaToUse = l_RmsMediaId;
        *pDataSetStart = l_SecPos;
        *pBagId = l_BagId;
		if (openedDb) {
			pSegDb->Close(pDbWorkSession);
			openedDb = FALSE;
		}

	}WsbCatchAndDo( hr,
					 if (openedDb){
						 pSegDb->Close(pDbWorkSession);}
					  ) ;

	WsbTraceOut(OLESTR("CHsmTskMgr::FindRecallMediaToUse"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\tsktrace.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    TskTrace.cpp

Abstract:

    These functions are used to provide an ability to trace the flow
    of the application for task manager debugging purposes.

Author:

    Cat Brant   [cbrant]   7-Dec-1996

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "fsa.h"


const OLECHAR*
TmFsaRequestActionAsString(
    FSA_REQUEST_ACTION  requestAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_REQUSEST_ACTION_MIGRATE) for
    the value of the request action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    requestAction       - An FSA_REQUEST_ACTION value.

Return Value:

    A string representation of the value of the request action.

--*/
{
    static OLECHAR  returnString[60];

    switch (requestAction) {
    case FSA_REQUEST_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_DELETE"));
            break;
    case FSA_REQUEST_ACTION_FILTER_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_FIILTER_RECALL"));
            break;
    case FSA_REQUEST_ACTION_PREMIGRATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_PREMIGRATE"));
            break;
    case FSA_REQUEST_ACTION_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_RECALL"));
            break;
    case FSA_REQUEST_ACTION_VALIDATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_VALIDATE"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_REQUEST_ACTION_?????"));
            break;
    }

    return(returnString);
}


const OLECHAR*
TmFsaResultActionAsString(
    FSA_RESULT_ACTION  resultAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_RESULT_ACTION_TRUNCATE) for
    the value of the result action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    resultAction        - An FSA_RESULT_ACTION value.

Return Value:

    A string representation of the value of the result action.

--*/
{
    static OLECHAR  returnString[60];

    switch (resultAction) {
    case FSA_RESULT_ACTION_NONE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_NONE"));
            break;
    case FSA_RESULT_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETE"));
            break;
    case FSA_RESULT_ACTION_DELETEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_LIST:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_LIST"));
            break;
    case FSA_RESULT_ACTION_OPEN:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_OPEN"));
            break;
    case FSA_RESULT_ACTION_PEEK:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_PEEK"));
            break;
    case FSA_RESULT_ACTION_REPARSE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REPARSE"));
            break;
    case FSA_RESULT_ACTION_TRUNCATE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_TRUNCATE"));
            break;
    case FSA_RESULT_ACTION_REWRITEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REWRITEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_RECALLEDDATA:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_RECALLEDDATA"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_RESULT_ACTION_?????"));
            break;
    }

    return(returnString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\volasgn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    VolAssign.cpp

Abstract:

    This component is an object representation of the HSM Metadata 
    Volume Assignement record.

Author:

    Ron White [ronw]        3-Jun-1997

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "VolAsgn.h"

#undef  WSB_TRACE_IS        
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

HRESULT 
CVolAssign::GetVolAssign(
    OUT GUID *pBagId, 
    OUT LONGLONG *pSegStartLoc, 
    OUT LONGLONG *pSegLen,
    OUT GUID *pVolId
    ) 
/*++

Implements:

  IVolAssign::GetVolAssign

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::GetVolAssign"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pSegStartLoc, E_POINTER);
        WsbAssert(0 != pSegLen, E_POINTER);
        WsbAssert(0 != pVolId, E_POINTER);

        //Provide the data members
        *pBagId = m_BagId;
        *pSegStartLoc = m_SegStartLoc;
        *pSegLen = m_SegLen;
        *pVolId = m_VolId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::GetVolAssign"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, VolId = <%ls>"),
        WsbPtrToGuidAsString(pBagId), 
        WsbStringCopy(WsbPtrToLonglongAsString(pSegStartLoc)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSegLen)),
        WsbStringCopy(WsbPtrToGuidAsString(pVolId)));
    return(hr);

}


HRESULT 
CVolAssign::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_SegStartLoc = 0;
        m_SegLen = 0;
        m_VolId = GUID_NULL;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CVolAssign::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CVolAssign;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}


HRESULT CVolAssign::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegStartLoc));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegLen));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_VolId));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CVolAssign::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, VolId = <%ls>"), 
        WsbHrAsString(hr), WsbGuidAsString(m_BagId),
        WsbStringCopy(WsbLonglongAsString(m_SegStartLoc)),
        WsbStringCopy(WsbLonglongAsString(m_SegLen)),
        WsbStringCopy(WsbGuidAsString(m_VolId)));

    return(hr);
}


HRESULT CVolAssign::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                WsbGuidAsString(m_BagId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", StartLoc = %ls"), 
                WsbLonglongAsString(m_SegStartLoc)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegLen = %ls"), 
                WsbLonglongAsString(m_SegLen)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" new VolId = %ls"), 
                WsbGuidAsString(m_VolId)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CVolAssign::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegStartLoc));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegLen));
        WsbAffirmHr(WsbSaveToStream(pStream, m_VolId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CVolAssign::SetVolAssign
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    IN GUID VolId
    )
 /*++

Implements:

  IVolAssign::SetVolAssign().

--*/
{
    WsbTraceIn(OLESTR("CVolAssign::SetVolAssign"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, VolId = <%ls>"), 
        WsbGuidAsString(BagId), 
        WsbStringCopy(WsbLonglongAsString(SegStartLoc)), 
        WsbStringCopy(WsbLonglongAsString(SegLen)),
        WsbStringCopy(WsbGuidAsString(VolId)));

    m_isDirty = TRUE;
    m_BagId = BagId;
    m_SegStartLoc = SegStartLoc;
    m_SegLen = SegLen;
    m_VolId = VolId;

    WsbTraceOut(OLESTR("CVolAssign::SetVolAssign"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CVolAssign::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
        WsbAffirmHr(pKey->AppendLonglong(m_SegStartLoc));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\filter\pch.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    PCH.H

Abstract:

    This module includes all  the headers which need
    to be precompiled & are included by all the source
    files in the RSFILTER project.

Author(s):

    Ravisankar Pudipeddi (ravisp) 

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#ifndef _RSFILTER_PCH_H_
#define _RSFILTER_PCH_H_

#include "ntifs.h"

//#define _NTIFS_
//#include "ntos.h"
//#include "ntseapi.h"
//#include "ntrtl.h"
//#include "nturtl.h"
//#include "fsrtl.h"
//#include "zwapi.h"

#include "stddef.h"

#define _WINDOWS_

#include <stdio.h>
#include "rpdata.h"
#include "rpio.h"
#include "rpfsa.h"
#include "rpfilter.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\engine\task\volasgn.h ===
// VolAsgn.h : Declaration of the CVolAssign


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// Task

class CVolAssign : 
    public CWsbDbEntity,
    public IVolAssign,
    public CComCoClass<CVolAssign,&CLSID_CVolAssign>
{
public:
    CVolAssign() {}
BEGIN_COM_MAP(CVolAssign)
    COM_INTERFACE_ENTRY(IVolAssign)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//  COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CVolAssign, _T("Task.VolAssign.1"), _T("Task.VolAssign"), IDS_VOLASSIGN_DESC, THREADFLAGS_BOTH)

// IVolAssign
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/)
        { return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT* /*pTestsPassed*/, USHORT* /*pTestsFailed*/)
        { return(E_NOTIMPL); }

// IVolAssign
public:
    STDMETHOD(GetVolAssign)(GUID* pBagId, LONGLONG *pSegStartLoc, 
            LONGLONG *pSegLen, GUID* VolId );
    STDMETHOD(SetVolAssign)(GUID bagId, LONGLONG segStartLoc, 
            LONGLONG SegLen, GUID VolId );

private:
    GUID            m_BagId;
    LONGLONG        m_SegStartLoc;
    LONGLONG        m_SegLen;
    GUID            m_VolId;    // New volume assignment
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\filter\rpcache.c ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    RpCache.c

Abstract:

    This module contains the routines for caching no-recall
    data from a file

Author:

    Ravisankar Pudipeddi (ravisp) 8/15/98

Environment:

    Kernel Mode

--*/

#include "pch.h"

#ifdef POOL_TAGGING
   #undef  ExAllocatePool
   #define ExAllocatePool(a, b) ExAllocatePoolWithTag(a, b, RP_CC_TAG)
#endif

//
// Spinlock used to protect assoc. irps list for the IRP
// We choose to use the low contention lock used to protect
// the queue of pending FSA requests
//
extern  KSPIN_LOCK     RsIoQueueLock;

#define RP_CACHE_PARAMETERS_KEY       L"RsFilter\\Parameters"

#define RP_CACHE_DEFAULT_BLOCK_SIZE   65536L
#define RP_CACHE_BLOCK_SIZE_KEY       L"CacheBlockSize"
ULONG   RspCacheBlockSize = RP_CACHE_DEFAULT_BLOCK_SIZE;

#define RP_CACHE_MAX_BUFFERS_SMALL  32L
#define RP_CACHE_MAX_BUFFERS_MEDIUM 48L
#define RP_CACHE_MAX_BUFFERS_LARGE  60L

#define RP_CACHE_MAX_BUFFERS_KEY      L"CacheMaxBuffers"
ULONG   RspCacheMaxBuffers = RP_CACHE_MAX_BUFFERS_SMALL;

#define RP_CACHE_DEFAULT_MAX_BUCKETS  11
#define RP_CACHE_MAX_BUCKETS_KEY      L"CacheMaxBuckets"
ULONG   RspCacheMaxBuckets = RP_CACHE_DEFAULT_MAX_BUCKETS;

#define RP_CACHE_DEFAULT_PREALLOCATE  0
#define RP_CACHE_PREALLOCATE_KEY      L"CachePreallocate"
ULONG   RspCachePreAllocate = RP_CACHE_DEFAULT_PREALLOCATE;

#define RP_NO_RECALL_DEFAULT_KEY      L"NoRecallDefault"
#define RP_NO_RECALL_DEFAULT          0
ULONG   RsNoRecallDefault = RP_NO_RECALL_DEFAULT;


PRP_CACHE_BUCKET RspCacheBuckets;
RP_CACHE_LRU     RspCacheLru;

BOOLEAN          RspCacheInitialized = FALSE;

//
//
// Counters go here
//

//
// Function prototypes go here
//

PRP_FILE_BUF
RsfRemoveHeadLru(
                IN BOOLEAN LruLockAcquired
                );


NTSTATUS
RsGetFileBuffer(
               IN PIRP      Irp,
               IN USN       Usn,
               IN ULONG     VolumeSerial,
               IN ULONGLONG FileId,
               IN ULONGLONG Block,
               IN BOOLEAN   LockPages,
               OUT PRP_FILE_BUF *FileBuf
               );

NTSTATUS
RsReadBlock(
           IN PFILE_OBJECT FileObject,
           IN PIRP         Irp,
           IN USN          Usn,
           IN ULONG        VolumeSerial,
           IN ULONGLONG    FileId,
           IN ULONGLONG    Block,
           IN BOOLEAN      LockPages,
           IN ULONG        Offset,
           IN ULONG        Length
           );

NTSTATUS
RsCacheReadCompletion(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP  Irp,
                     IN PVOID MasterIrp
                     );

NTSTATUS
RsCacheGetParameters(
                    VOID
                    );


PRP_FILE_BUF
RsCacheAllocateBuffer(
                     VOID
                     );

VOID
RsMoveFileBufferToTailLru(
                         IN PRP_FILE_BUF FileBuf
                         );


NTSTATUS
RsCancelNoRecall(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                );

NTSTATUS
RsNoRecallMasterIrpCompletion(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP  Irp,
                             IN PVOID Context
                             );

NTSTATUS
RsCacheSetMasterIrpCancelRoutine(
                                IN PIRP Irp,
                                IN PDRIVER_CANCEL CancelRoutine
                                );


NTSTATUS
RsCacheQueueRequestWithBuffer(
                             IN PRP_FILE_BUF FileBuf,
                             IN PIRP Irp,
                             IN BOOLEAN LockPages
                             );

PIRP
RsCacheGetNextQueuedRequest(
                           IN PRP_FILE_BUF FileBuf
                           );

NTSTATUS
RsCacheCancelQueuedRequest(
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          );
VOID
RsInsertHeadLru(
               IN PRP_FILE_BUF FileBuf
               );
VOID
RsInsertTailLru(
               IN PRP_FILE_BUF FileBuf
               );

VOID
RsRemoveFromLru(
               IN PRP_FILE_BUF FileBuf
               );

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT, RsCacheInitialize)
   #pragma alloc_text(INIT, RsCacheGetParameters)
   #pragma alloc_text(PAGE, RsGetNoRecallData)
   #pragma alloc_text(PAGE, RsReadBlock)
   #pragma alloc_text(PAGE, RsGetFileBuffer)
   #pragma alloc_text(PAGE, RsCacheAllocateBuffer)
   #pragma alloc_text(PAGE, RsCacheFsaIoComplete)
   #pragma alloc_text(PAGE, RsCacheFsaPartialData)
   #pragma alloc_text(PAGE, RsInsertHeadLru)
   #pragma alloc_text(PAGE, RsInsertTailLru)
   #pragma alloc_text(PAGE, RsMoveFileBufferToTailLru)
   #pragma alloc_text(PAGE, RsRemoveFromLru)
   #pragma alloc_text(PAGE, RsfRemoveHeadLru)
#endif


//
// VOID
// RsInitializeFileBuf(
//   IN PRP_FILE_BUF FileBuf,
//   IN PUCHAR       Data
// );
//
#define RsInitializeFileBuf(FileBuf, BufData) {                       \
    RtlZeroMemory((FileBuf), sizeof(RP_FILE_BUF));                    \
       InitializeListHead(&(FileBuf)->WaitQueue);                     \
    InitializeListHead(&(FileBuf)->LruLinks);                         \
    InitializeListHead(&(FileBuf)->BucketLinks);                      \
    ExInitializeResourceLite(&(FileBuf)->Lock);                           \
    (FileBuf)->State = RP_FILE_BUF_INVALID;                           \
    (FileBuf)->Data = BufData;                                        \
}

//
// VOID
// RsReinitializeFileBuf(
//   IN PRP_FILE_BUF FileBuf,
//   IN ULONG        VolumeSerial,
//   IN ULONGLONG    FileId,
//   IN USN          Usn,
//   IN ULONGLONG    Block
// );
//
#define RsReinitializeFileBuf(FileBuf, VolumeSerial, FileId, Usn, Block) { \
    (FileBuf)->VolumeSerial = VolumeSerial;                                \
    (FileBuf)->FileId = FileId;                                            \
    (FileBuf)->Block = Block;                                              \
    (FileBuf)->Usn = Usn;                                                  \
}

//
// VOID
// RsAcquireLru(
//   VOID
// );
//
#define RsAcquireLru()      {                                          \
    ExAcquireFastMutex(&RspCacheLru.Lock);                             \
}

//
// VOID
// RsReleaseLru(
//   VOID
// );
//
#define RsReleaseLru()     {                                            \
    ExReleaseFastMutex(&RspCacheLru.Lock);                              \
}

//
// VOID
// RsAcquireFileBufferExclusive(
//   IN PRP_FILE_BUF FileBuf
// );
//
#define RsAcquireFileBufferExclusive(FileBuf)                      {   \
    FsRtlEnterFileSystem();                                            \
    ExAcquireResourceExclusiveLite(&((FileBuf)->Lock), TRUE);              \
}

//
// VOID
// RsAcquireFileBufferShared(
//   IN PRP_FILE_BUF FileBuf
// );
//
#define RsAcquireFileBufferShared(FileBuf)                         { \
    FsRtlEnterFileSystem();                                          \
    ExAcquireResourceSharedLite(&((FileBuf)->Lock), TRUE);               \
}

//
// VOID
// RsReleaseFileBuffer(
//   IN PRP_FILE_BUF FileBuf
// );
//
#define RsReleaseFileBuffer(FileBuf)                               { \
    ExReleaseResourceLite(&((FileBuf)->Lock));                           \
    FsRtlExitFileSystem();                                           \
}


//
// PRP_FILE_BUF
// RsRemoveHeadLru(
//   IN BOOLEAN LruLockAcquired
// );
//
#define RsRemoveHeadLru(LruLockAcquired)    RsfRemoveHeadLru(LruLockAcquired)

//
// VOID
// RsInsertTailCacheBucket(
//   IN PRP_CACHE_BUCKET Bucket,
//   IN PRP_FILE_BUF     Block
// );
//
#define RsInsertTailCacheBucket(Bucket, Block)                       \
    InsertTailList(&((Bucket)->FileBufHead), &((Block)->BucketLinks))
//
// VOID
// RsRemoveFromCacheBucket(
//   IN PRP_FILE_BUF Block
// );
//
#define RsRemoveFromCacheBucket(Block)                               \
    RemoveEntryList(&((Block)->BucketLinks))

//
// VOID
// RsCacheIrpSetLockPages(
//  IN PIRP Irp,
//  IN BOOLEAN LockPages
// );
// /*++
//
//  Routine Description
//
//  Sets driver context state in the supplied IRP to indicate
//  whether the user buffer pages need to be locked before transferring
//  data or not
//
// --*/
//
#define RsCacheIrpSetLockPages(Irp, LockPages)                     { \
    if (LockPages) {                                                 \
       (Irp)->Tail.Overlay.DriverContext[1] = (PVOID) 1;             \
    } else {                                                         \
       (Irp)->Tail.Overlay.DriverContext[1] = (PVOID) 0;             \
    }                                                                \
}

//
// BOOLEAN
// RsCacheIrpGetLockPages(
//  IN PIRP  Irp
// );
// /*++
//
//  Routine Description
//
//  Retreives the driver context state from the IRP indicating whether
//  user buffer pages need to be locked before transferrring data or not
//
// --*/
//
#define RsCacheIrpGetLockPages(Irp)                                  \
      ((Irp)->Tail.Overlay.DriverContext[1] == (PVOID) 1)

//
// PLIST_ENTRY
// RsCacheIrpWaitQueueEntry(
//   IN PIRP Irp
// );
//
// /*++
//
// Routine Description
//
//   Returns the LIST_ENTRY in the IRP which is used to queue the
//   IRPs in the wait queue for a cache block
//
// --*/
//
#define RsCacheIrpWaitQueueEntry(Irp)                                \
    ((PLIST_ENTRY) &((Irp)->Tail.Overlay.DriverContext[2]))

//
// PIRP
// RsCacheIrpWaitQueueContainingIrp(
//   IN PLIST_ENTRY Entry
// );
//
// /*++
//
// Routine Description
//
//   Returns the containing IRP for the passed in LIST_ENTRY structure
//   which is used to queue the IRP in the wait queue for a cache-block
//
// --*/
//
#define RsCacheIrpWaitQueueContainingIrp(Entry)                      \
    CONTAINING_RECORD(Entry,                                         \
                      IRP,                                           \
                      Tail.Overlay.DriverContext[2])

VOID
RsInsertHeadLru(
               IN PRP_FILE_BUF FileBuf
               )
/*++

Routine Description

    Inserts the specified block at the head of the LRU

Arguments

    FileBuf - Pointer to cache block

Return value

    None
--*/
{
   PAGED_CODE();

   InsertHeadList(&RspCacheLru.FileBufHead,
                  &((FileBuf)->LruLinks));
   RspCacheLru.LruCount++;
   ASSERT (RspCacheLru.LruCount <= RspCacheLru.TotalCount);
   //
   // One more buffer added to LRU. Bump the semaphore count
   //
   KeReleaseSemaphore(&RspCacheLru.AvailableSemaphore,
                      IO_NO_INCREMENT,
                      1L,
                      FALSE);
}


VOID
RsInsertTailLru(
               IN PRP_FILE_BUF FileBuf
               )
/*++

Routine Description

    Inserts the specified block at the tail of the LRU

Arguments

    FileBuf - Pointer to cache block

Return value

    None
--*/
{

   PAGED_CODE();

   InsertTailList(&RspCacheLru.FileBufHead,
                  &((FileBuf)->LruLinks));
   RspCacheLru.LruCount++;

   ASSERT (RspCacheLru.LruCount <= RspCacheLru.TotalCount);
   //
   // One more buffer added to LRU. Bump the semaphore count
   //
   KeReleaseSemaphore(&RspCacheLru.AvailableSemaphore,
                      IO_NO_INCREMENT,
                      1L,
                      FALSE);
}


VOID
RsMoveFileBufferToTailLru(
                         IN PRP_FILE_BUF FileBuf
                         )
/*++

Routine Description

    Moves the specified block to end of the LRU,
    *if* it is on the LRU currently.

Arguments

    FileBuf - Pointer to the cache block


Return value

    None
--*/
{
   PAGED_CODE();

   if ((FileBuf)->LruLinks.Flink != &((FileBuf)->LruLinks)) {
      RemoveEntryList(&((FileBuf)->LruLinks));
      InsertTailList(&RspCacheLru.FileBufHead,
                     &((FileBuf)->LruLinks));
   }
}


VOID
RsRemoveFromLru(
               IN PRP_FILE_BUF FileBuf
               )
/*++

Routine Description

    Removes the specified block from th LRU,
    *if* it is on the LRU currently.

Arguments

    FileBuf - Pointer to the cache block


Return value

    None
--*/
{
   PAGED_CODE();

   if (FileBuf->LruLinks.Flink != &FileBuf->LruLinks) {
      LARGE_INTEGER timeout;
      NTSTATUS      status;

      //
      // This is getting bumped off the LRU
      //
      RspCacheLru.LruCount--;
      //
      // Adjust the semaphore count
      //
      timeout.QuadPart = 0;
      status =  KeWaitForSingleObject(&RspCacheLru.AvailableSemaphore,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      &timeout);

      ASSERT (status == STATUS_SUCCESS);
   }
   RemoveEntryList(&(FileBuf->LruLinks));
}


PRP_FILE_BUF
RsfRemoveHeadLru(IN BOOLEAN LruLockAcquired)

/*++

Routine Description

    Returns the buffer at the  head of the LRU list,
    Also resets the links of the buffer to point to itself
    - this is done so that this buffer would not be
    found later on a bucket and moved to the end of the
    list, before it gets added to the LRU


Arguments

    LruLockAcquired  - TRUE if LRU lock was acquired - in which case
                       we do not acquire/release the lock

                       FALSE if it was not in which we acquire and release
                       before returning as appropriate
Return Value

   Pointer to buffer at the head of LRU if LRU is not empty
   NULL if LRU is empty

--*/
{
   PLIST_ENTRY  entry;
   PRP_FILE_BUF fileBuf;

   PAGED_CODE();

   if (!LruLockAcquired) {
      RsAcquireLru();
   }

   entry = NULL;

   if (RspCacheLru.TotalCount < RspCacheMaxBuffers) {
      //
      // We can afford to allocate another
      //
      PRP_FILE_BUF buffer;

      buffer = RsCacheAllocateBuffer();

      if (buffer) {
         //
         // Got a buffer ..
         //
         entry = &buffer->LruLinks;
         RspCacheLru.TotalCount++;
      }
   }

   if (entry != NULL) {
      //
      // Release LRU if necessary
      //
      if (!LruLockAcquired) {
         RsReleaseLru();
      }
      return CONTAINING_RECORD(entry,
                               RP_FILE_BUF,
                               LruLinks);
   }

   if (IsListEmpty(&RspCacheLru.FileBufHead)) {
      //
      // No more free buffers..
      //
      if (!LruLockAcquired) {
         RsReleaseLru();
      }
      return NULL;
   }

   entry = RemoveHeadList(&RspCacheLru.FileBufHead);
   //
   // Important: reset entry's links
   //
   entry->Flink = entry->Blink = entry;

   fileBuf = CONTAINING_RECORD(entry,
                               RP_FILE_BUF,
                               LruLinks);

   //
   // If somebody is using the buffer right now (copying contents),
   // this will block till they are done with it
   //
   RsAcquireFileBufferExclusive(fileBuf);

   fileBuf->State = RP_FILE_BUF_INVALID;

   RsReleaseFileBuffer(fileBuf);
   //
   // Adjust count of buffers in LRU
   //
   ASSERT(RspCacheLru.LruCount > 0);
   RspCacheLru.LruCount--;

   if (!LruLockAcquired) {
      RsReleaseLru();
   }
   return fileBuf;
}


/*++
ULONG
RsHashFileBuffer(
                IN ULONG     VolumeSerial,
                IN ULONGLONG FileId,
                IN ULONGLONG Block
                )

Routine Description

    Hashes the supplied values and returns
    a value in the range 0 - (RspCacheMaxBuffers - 1)

Arguments

   VolumeSerial   - Volume serial number of the volume the file resides on
   FileId         - file id no. of the file
   Block          - Number of the block being hashed

Return Value

   Value in the range of 0 - (RspCacheMaxBuckets - 1)


--*/

#define RsHashFileBuffer(VolumeSerial, FileId, Block)   \
                       ((ULONG) ((Block) % RspCacheMaxBuckets))


NTSTATUS
RsGetNoRecallData(
                 IN PFILE_OBJECT FileObject,
                 IN PIRP         Irp,
                 IN USN          Usn,
                 IN LONGLONG     FileOffset,
                 IN LONGLONG     Length,
                 IN PUCHAR       UserBuffer)

/*++

Routine Description

   This is the entry point for the IRP_MJ_READ dispatch, which
   is called when it is concluded that user is requesting a no-recall read.
   This would dispatch the appropriate requests to read the requested data
   from cache (or from tape if it's not cached yet)

Arguments

   FileObject     -     Pointer to the file object for the file
   Irp            -     Original IRP requesting read
   Usn            -     Usn number of the file
   FileOffset     -     Offset in the file from which to read
   Length         -     Length of data to read
   UserBuffer     -     Buffer into which read data needs to be copied

Return value

   STATUS_PENDING       - If i/o is under progress to satisfy the read
   STATUS_SUCCESS       - If read was satisfied entirely from the cache
   Any other status     - Some error occurred

--*/
{

   PRP_FILTER_CONTEXT       filterContext;
   PRP_FILE_OBJ             entry;
   PRP_FILE_CONTEXT         context;
   ULONGLONG                startBlock, endBlock, blockNo;
   LONGLONG                 offset, length, userBufferOffset, userBufferLength;
   LONGLONG                 transferredLength;
   ULONG                    associatedIrpCount;
   PIRP                     irp;
   PIO_STACK_LOCATION       irpSp;
   ULONG                    volumeSerial;
   ULONGLONG                fileId;
   LONGLONG                 fileSize;
   PRP_NO_RECALL_MASTER_IRP readIo;
   PLIST_ENTRY              listEntry;
   NTSTATUS  status;

   PAGED_CODE();

   filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);

   if (filterContext == NULL) {
      //
      // Not found
      return STATUS_NOT_FOUND;
   }

   entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
   context = entry->fsContext;

   RsAcquireFileContextEntryLockShared(context);

   fileSize = (LONGLONG) context->rpData.data.dataStreamSize.QuadPart;

   RsReleaseFileContextEntryLock(context);

   //
   // Check if  read is  beyond end of file
   //
   if (FileOffset >= fileSize) {
      return STATUS_END_OF_FILE;
   }

   //
   // Negative offsets are not allowed
   //
   if (FileOffset < 0) {
      return STATUS_INVALID_PARAMETER;
   }

   if ((FileOffset + Length) > fileSize) {
      //
      // Adjust the length so we don't go past the end of the file
      //
      Length = fileSize - FileOffset;
   }

   //
   // If it's  zero length read, complete immediately
   //
   if (Length == 0) {
      Irp->IoStatus.Information = 0;
      return STATUS_SUCCESS;
   }

   volumeSerial = context->serial;
   fileId       = context->fileId;


   startBlock = FileOffset / RspCacheBlockSize;
   endBlock = (FileOffset + Length - 1) / RspCacheBlockSize;

   //
   // We satisfy the user request by breaking it up into
   // blocks of RspCacheBlockSize each.
   // An associated irp is created for each of these sub-transfers
   // and posted.
   // The master IRP will complete when all the associated ones do
   //

   readIo = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RP_NO_RECALL_MASTER_IRP),
                                  RP_RQ_TAG);

   if (readIo == NULL) {
       return  STATUS_INSUFFICIENT_RESOURCES;
   }

   readIo->MasterIrp = Irp;

   InitializeListHead(&readIo->AssocIrps);

   Irp->Tail.Overlay.DriverContext[0] = readIo;

   try {

      associatedIrpCount = 0;
      userBufferOffset = 0;
      userBufferLength = 0;
      transferredLength = 0;

      for (blockNo = startBlock; blockNo <= endBlock; blockNo++) {
         //
         // Create an associated irp  for this read block request
         // We only need 2 stack locations, for this irp.
         // this IRP is never going to go down the stack
         // However we simulate one IoCallDriver
         // (to let IoCompletion take its normal course)
         // so we need one stack location for us & one for the
         // 'logically next device'
         //
         irp = IoMakeAssociatedIrp(Irp,
                                   2);

         if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            return status;
         }

         associatedIrpCount++;
         InsertTailList(&readIo->AssocIrps, &irp->Tail.Overlay.ListEntry);
         //
         // Set the IRP to the first valid stack location
         //
         IoSetNextIrpStackLocation(irp);

         //
         // Fill the current stack loc. with the relevant paramters
         //
         irpSp = IoGetCurrentIrpStackLocation(irp);
         irpSp->MajorFunction = IRP_MJ_READ;
         irpSp->FileObject = FileObject;
         irpSp->DeviceObject = FsDeviceObject;


         irp->RequestorMode = Irp->RequestorMode;

         if (Irp->Flags & IRP_PAGING_IO) {
            //
            // Propogate the paging io flag to the associated irps so
            // completion in RsCompleteRead will be handled properly
            //
            irp->Flags |= IRP_PAGING_IO;
         }

         //
         // Compute the offset and lengths witin the user buffer chunk
         // that we will do the transfer to for this block
         // These will be stored in userBufferOffset and userBufferLength respectively
         // We also compute the actual transfer parameters to the user buffer from
         // the read tape block (the real transfer is from offset blockNo*RspCacheBlockSize
         // of length RspCacheBlockSize). By actual we mean the portion of the real transfer
         // that we actually copy to the user buffer. These are stored in the
         // irp read parameter block.
         //
         if (blockNo == startBlock) {
            userBufferOffset = 0;
            //
            // Length of transfer is the rest of the block or the original length, whichever is lesser
            //
            userBufferLength = MIN(Length, (RspCacheBlockSize - (FileOffset % RspCacheBlockSize)));

            irpSp->Parameters.Read.ByteOffset.QuadPart = FileOffset;
            irpSp->Parameters.Read.Length = (ULONG) userBufferLength;
         } else if (blockNo == endBlock) {
            //
            // add previous length to the offset to get new offset
            //
            userBufferOffset += userBufferLength;
            //
            // For the last block, the length of the transfer would be
            // Length - (length already transferred)
            //
            userBufferLength = (Length - transferredLength);
            irpSp->Parameters.Read.ByteOffset.QuadPart = blockNo*RspCacheBlockSize;
            irpSp->Parameters.Read.Length = (ULONG) userBufferLength;

         } else {
            //
            // add previous length to the offset to get new offset
            //
            userBufferOffset += userBufferLength;
            //
            // Length of transfer for in-between blocks is blocksized
            //
            userBufferLength = RspCacheBlockSize;
            irpSp->Parameters.Read.ByteOffset.QuadPart = blockNo*RspCacheBlockSize;
            irpSp->Parameters.Read.Length = (ULONG) userBufferLength;
         }

         transferredLength += userBufferLength;
         //
         // The buffer for this particular associated IRP starts at the
         // originally supplied buffer + the user buffer offset as calculated above.
         // the length is in irp->Parameters.Read.Length (as well as userBufferLength)
         //
         if (UserBuffer == NULL) {
            //
            // We need to get an MDL for the user buffer (this is not paging i/o,
            // so the pages are not locked down)
            //
            ASSERT (Irp->UserBuffer);

            irp->UserBuffer = (PUCHAR)Irp->UserBuffer + userBufferOffset;
            irp->MdlAddress = IoAllocateMdl(irp->UserBuffer,
                                            (ULONG) userBufferLength,
                                            FALSE,
                                            FALSE,
                                            NULL) ;
            if (!irp->MdlAddress) {
               //
               // A resource problem has been encountered. Set appropriate status
               // in the Irp, and begin the completion process.
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGetNoRecallData Unable to allocate an MDL for user buffer %x\n", (PUCHAR) Irp->UserBuffer+userBufferOffset));

               status = STATUS_INSUFFICIENT_RESOURCES;

               ExFreePool(readIo);

               Irp->IoStatus.Status =  status;
               Irp->IoStatus.Information = 0 ;
               IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
               return status;
            }
         } else {
            //
            //  The supplied user buffer is the system address of an already locked down
            //  pages. Just use it...
            //
            irp->UserBuffer = (PUCHAR)UserBuffer + userBufferOffset;
         }
      }

      //
      // Set the associated Irp count to one more than what it should be
      // this is to guard against the case where all the associated irps
      // complete in the loop below
      //
      Irp->AssociatedIrp.IrpCount =  (ULONG) ((endBlock - startBlock) + 2);
      //
      // Now all the associated irps are created, dispatch them off to recall the data
      //
      // Start with SUCCESS in master irp.
      // assoc. irps will update the status if necessary
      // in their completion routines
      //

      Irp->IoStatus.Status = STATUS_SUCCESS;
      status = STATUS_SUCCESS;

      IoSetCompletionRoutine(Irp,
                             &RsNoRecallMasterIrpCompletion,
                             readIo,
                             TRUE,
                             TRUE,
                             TRUE);


      IoSetNextIrpStackLocation(Irp);

      for (blockNo = startBlock; blockNo <= endBlock;  blockNo++) {

         BOOLEAN lockPages;

         irp = (PIRP) ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                                  &RsIoQueueLock);

         ExInterlockedInsertTailList(&readIo->AssocIrps,
                                     (PLIST_ENTRY) irp,
                                     &RsIoQueueLock);

         irp   = CONTAINING_RECORD(irp,
                                   IRP,
                                   Tail.Overlay.ListEntry);

         irpSp = IoGetCurrentIrpStackLocation(irp);

         //
         // If user passed in a valid pointer for UserBuffer,
         // it means the pages are already locked down.
         // if not we would need to lock them  when the
         // data transfer takes place, in RsPartialData
         //
         lockPages = (UserBuffer == NULL)?TRUE:FALSE;
         //
         // Since we are going to set a completion routine and
         // simulate an IoCallDriver, copy the parameters to the
         // the next stack location
         //
         IoCopyCurrentIrpStackLocationToNext(irp);
         IoSetCompletionRoutine(irp,
                                &RsCacheReadCompletion,
                                Irp,
                                TRUE,
                                TRUE,
                                TRUE);

         //
         // Simulate an IoCallDriver on the irp
         // before calling RsReadBlock
         //
         IoSetNextIrpStackLocation(irp);
         //
         // Dispatch to block read with real offset and length within the cache
         // block buffer that the copy takes place.
         // The real byte offset is in irpSp->Parameters.Read.ByteOffset
         // This modulo the block size is the relative offset within the block
         // The length is of course already calculated, in 
         // irpSp->Parameters.Read.Length
         //
         RsReadBlock(FileObject,
                     irp,
                     Usn,
                     volumeSerial,
                     fileId,
                     blockNo,
                     lockPages,
                     (ULONG) (irpSp->Parameters.Read.ByteOffset.QuadPart % (ULONGLONG) RspCacheBlockSize),
                     irpSp->Parameters.Read.Length);
      }
   } finally {
      //
      // Cleanup assoc. irps that we created if necessary
      //
      if (status != STATUS_SUCCESS) {
         //
         // If we get here, none of the assoc IRPs were dispatched
         //
         ASSERT (readIo != NULL);

         while (!IsListEmpty(&readIo->AssocIrps)) {

            listEntry = RemoveHeadList(&readIo->AssocIrps);

            ASSERT (listEntry != NULL);

            irp = CONTAINING_RECORD(listEntry,
                                    IRP,
                                    Tail.Overlay.ListEntry);
            if ((UserBuffer == NULL) && irp->MdlAddress) {
               IoFreeMdl(irp->MdlAddress);
            }
            IoFreeIrp(irp);
         }
         ExFreePool(readIo);
      }
   }
   //
   // All the assoc irps are dispatched:
   // now we can set the cancel routine for this IRP
   //
   status = RsCacheSetMasterIrpCancelRoutine(Irp,
                                             RsCancelNoRecall);
   return status;
}


NTSTATUS
RsCacheSetMasterIrpCancelRoutine(
                                IN  PIRP Irp,
                                IN  PDRIVER_CANCEL CancelRoutine)
/*++

Routine Description:

    This routine is called to set up an Irp for cancel.  We will set the cancel routine
    and initialize the Irp information we use during cancel.

Arguments:

    Irp - This is the Irp we need to set up for cancel.

    CancelRoutine - This is the cancel routine for this irp.


Return Value:

    STATUS_PENDING   - the cancel routine was set

    STATUS_CANCELLED - The Cancel flag was set in the IRP , so the IRP should
                       be completed as cancelled. The cancel routine will not
                       be set in this case

    Any other status - All the associated IRPs have already completed so
                       the master IRP should be completed with this status.
                       The cancel routine will not be set in this case
--*/
{

   KIRQL    irql;
   NTSTATUS status;
   //
   //  Assume that the Irp has not been cancelled.
   //
   IoAcquireCancelSpinLock( &irql );

   if (!Irp->Cancel) {
      //
      // decrease the associated irp count back again
      //
      if (InterlockedDecrement((PLONG) &Irp->AssociatedIrp.IrpCount) == 0) {
         //
         // All the assoc irps have already completed.
         status =  Irp->IoStatus.Status;
      } else {
         IoMarkIrpPending( Irp );
         IoSetCancelRoutine( Irp, CancelRoutine );
         status =  STATUS_PENDING;
      }
   } else {
      status = STATUS_CANCELLED;
   }

   IoReleaseCancelSpinLock( irql );
   return status;
}


NTSTATUS
RsCancelNoRecall(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )
/*++

Routine Description:

    This function filters cancels an outstanding read-no-recall master AND associated IRPs

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/
{
   PRP_NO_RECALL_MASTER_IRP readIo;
   PLIST_ENTRY              entry;
   PIRP                     assocIrp;

   UNREFERENCED_PARAMETER(DeviceObject);

   //
   // Bump the associated irp count so that the master IRP
   // doesn't complete automatically
   //
   InterlockedIncrement(&Irp->AssociatedIrp.IrpCount);

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   readIo = Irp->Tail.Overlay.DriverContext[0];
   ASSERT (readIo != NULL);


   entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                       &RsIoQueueLock);
   while (entry != NULL) {
      assocIrp = CONTAINING_RECORD(entry,
                                   IRP,
                                   Tail.Overlay.ListEntry);
      IoCancelIrp(assocIrp);
      entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                          &RsIoQueueLock);

   }
   //
   // The master IRP needs to be completed now
   //
   ASSERT (Irp->AssociatedIrp.IrpCount >= 1);
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return STATUS_SUCCESS;
}


NTSTATUS
RsCacheReadCompletion(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP  Irp,
                     IN PVOID Context
                     )
/*++

Routine Description

   This is the completion routine for each of the associated IRPs created
   to satisfy the original Master Irp for reading no-recall data
   This would update the master IRP status, Information as necessary

Arguments

   DeviceObject      - Not used
   Irp               - Pointer to the assoc. IRP being completed
   Context           - Pointer to the master irp

Return Value

   STATUS_SUCCESS

--*/
{
   PIRP                     assocIrp, masterIrp = (PIRP) Context;
   PLIST_ENTRY              entry;
   PRP_NO_RECALL_MASTER_IRP readIo;
   KIRQL                    oldIrql;

   UNREFERENCED_PARAMETER(DeviceObject);


   if (!NT_SUCCESS(Irp->IoStatus.Status)) {
      ((PIRP)(masterIrp))->IoStatus.Status = Irp->IoStatus.Status;
   } else {
      //
      // Update the read bytes count
      //
      ASSERT (masterIrp == Irp->AssociatedIrp.MasterIrp);

      InterlockedExchangeAdd((PLONG)&(((PIRP)(masterIrp))->IoStatus.Information),
                             (LONG)Irp->IoStatus.Information);
   }
   

   //
   // Extract the master irp structure
   //
   readIo = masterIrp->Tail.Overlay.DriverContext[0];

   ASSERT (readIo != NULL);

   ExAcquireSpinLock(&RsIoQueueLock,
                     &oldIrql);
   //
   // Iterate here to find the assoc irp and remove it
   //
   entry = readIo->AssocIrps.Flink;

   while ( entry != &readIo->AssocIrps) {
      assocIrp = CONTAINING_RECORD(entry,
                                   IRP,
                                   Tail.Overlay.ListEntry);
      if (Irp == assocIrp) {
         RemoveEntryList(entry);
         break;
      }
      entry = entry->Flink;
   }

   if (IsListEmpty(&(readIo->AssocIrps))) {
        //
        // Clear the master IRP cancel routine
        //
        RsClearCancelRoutine(masterIrp);
   }

   ExReleaseSpinLock(&RsIoQueueLock,
                     oldIrql);

   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }
   return STATUS_SUCCESS;
}


NTSTATUS
RsNoRecallMasterIrpCompletion(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP  Irp,
                             IN PVOID Context)
/*++

Routine Description

   This is the completion routine for master Irp for reading no-recall data

Arguments

   DeviceObject      - Not used
   Irp               - Pointer to the assoc. IRP being completed
   Context           - Pointer to the internal structure tracking the master &
                       associated irps.

Return Value

   STATUS_SUCCESS

--*/
{
   PRP_NO_RECALL_MASTER_IRP readIo = (PRP_NO_RECALL_MASTER_IRP) Context;
   PLIST_ENTRY entry;
   PIRP assocIrp;


   ASSERT (Irp->Tail.Overlay.DriverContext[0] == (PVOID) readIo);

   if (readIo != NULL) {
      //
      // Cancel the associated IRPs if they are still around
      //
      entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                          &RsIoQueueLock);
      while (entry != NULL) {
         assocIrp = CONTAINING_RECORD(entry,
                                      IRP,
                                      Tail.Overlay.ListEntry);
         IoCancelIrp(assocIrp);
         entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                             &RsIoQueueLock);

      }
      ExFreePool(readIo);
   }

   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }

   return STATUS_SUCCESS;
}


NTSTATUS
RsReadBlock(
           IN PFILE_OBJECT FileObject,
           IN PIRP         Irp,
           IN USN          Usn,
           IN ULONG        VolumeSerial,
           IN ULONGLONG    FileId,
           IN ULONGLONG    Block,
           IN BOOLEAN      LockPages,
           IN ULONG        Offset,
           IN ULONG        Length)
/*++

Routine Description

   Reads the requested block of data into the UserBuffer from the cache.
   If this block is not cached, it queues a no-recall with the fsa to fetch
   the data off the storage.
   The completion processing for the no-recall request would fill the
   UserBuffer and the cache block

Arguments

   FileObject   - Pointer to the file object of the file
   Irp          - Pointer to the associated irp for this block read
   Usn          - Usn of the file
   VolumeSerial - Volume serial number of the volume on which the file resides
   FileId       - File Id of the file
   Block        - Block number of the block that needs to be read
   LockPages    - Specifies if user buffer pages need to be locked down before copying
   Offset       - Offset  in the block from which to copy (0 <= Offset < RspCacheBlockSize)
   Length       - Length to copy ( <= RspCacheBlockSize)

Return value

    STATUS_SUCCESS      - Irp was completed successfully
    STATUS_PENDING      - I/O for the block was initiated and the Irp was
                          queued for completion after i/o finishes
    Any other status    - Some error occurred and Irp was completed with this status


--*/
{
   PRP_FILE_BUF         fileBuf = NULL;
   NTSTATUS             status = STATUS_SUCCESS;

   PAGED_CODE();

   //
   // Ensure caller isn't trying to bite more
   // than he can chew
   //
   ASSERT((Offset+Length) <= RspCacheBlockSize);

   status = RsGetFileBuffer(Irp,
                            Usn,
                            VolumeSerial,
                            FileId,
                            Block,
                            LockPages,
                            &fileBuf);

   switch (status) {

   case STATUS_SUCCESS: {
         //
         // Buffer containing valid data found in the cache
         // Complete the request here by copying the data directly
         //
         BOOLEAN unlock = FALSE;
         PUCHAR  userBuffer;

         ASSERT (fileBuf && (fileBuf->State == RP_FILE_BUF_VALID));

         status = STATUS_SUCCESS;

         if (LockPages) {
            //
            // We need to lock the pages before copying
            //
            try {
               MmProbeAndLockProcessPages (Irp->MdlAddress,
                                           IoGetRequestorProcess(Irp),
                                           Irp->RequestorMode,
                                           IoModifyAccess) ;       // Modifying the buffer
               //
               // Indicate that we would need to get the pages unlocked
               // after copying
               //
               unlock = TRUE;
            }except (EXCEPTION_EXECUTE_HANDLER) {

               //
               // Something serious went wrong. Free the Mdl, and complete this
               // Irp will some meaningful sort of error.
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Unable to lock read buffer!.\n"));
               RsLogError(__LINE__, AV_MODULE_RPCACHE, 0,
                          AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
               status = STATUS_INVALID_USER_BUFFER;

            }
            if (NT_SUCCESS(status)) {
               userBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                                                         NormalPagePriority) ;
               if (userBuffer == NULL) {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            }
         } else {
            //
            // The supplied UserBuffer in the IRP is the system address of
            // already locked down pages - we can directly access it
            //
            userBuffer = Irp->UserBuffer;
         }

         if (NT_SUCCESS(status)) {
            BOOLEAN synchronousIo;

            RtlCopyMemory(userBuffer, fileBuf->Data+Offset, Length);
            synchronousIo = BooleanFlagOn(FileObject->Flags, FO_SYNCHRONOUS_IO );
            Irp->IoStatus.Information += Length;

            if (synchronousIo) {
               //
               // Change the current byte offset in the file object
               // Use interlocked add because the associated IRPs can
               // complete in any order
               //
               ExInterlockedAddLargeStatistic(&FileObject->CurrentByteOffset,
                                              (ULONG)Irp->IoStatus.Information);
            }

         }

         if (unlock) {
            //
            // Unlock any pages we locked...
            //
            MmUnlockPages(Irp->MdlAddress);
            IoFreeMdl(Irp->MdlAddress);
            Irp->MdlAddress = NULL;
         }
         RsReleaseFileBuffer(fileBuf);
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;
      }

   case STATUS_WAIT_63 :
      //
      // Fall through deliberately
      //
   case STATUS_TIMEOUT: {
         //
         // Buffer was not found - so a new buffer
         // was allocated for us to initiate i/o on.
         // OR buffer was found but previous attempt at i/o failed
         // This latter case is treated the same as if the
         // buffer was not found.
         // OR we are doing a non-cached no-recall read
         // Queue a no-recall with the FSA for this.
         //
         ASSERT ((fileBuf == NULL)  || (fileBuf->State == RP_FILE_BUF_IO));
         status = RsQueueNoRecall(FileObject,
                                  Irp,
                                  Block*RspCacheBlockSize,
                                  RspCacheBlockSize,
                                  Offset,
                                  Length,
                                  fileBuf,
                                  //
                                  // RsQueueNoRecall expects the buffer to be NULL
                                  // (and a valid Irp->MdlAddress) if the pages needed
                                  // to be locked down - if not it uses the
                                  // supplied buffer pointer to copy the data to.
                                  //
                                  (LockPages) ? NULL: Irp->UserBuffer);

         if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }
         break;
      }

   case STATUS_PENDING: {
         //
         // IRP was queued on to a block with i/o in progress
         // Just return
         //
         break;
      }

   default : {
         //
         // Some unknown error Complete the IRP and return
         //

         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;
      }
   }
   return status;
}


NTSTATUS
RsGetFileBuffer(
               IN  PIRP         Irp,
               IN  USN          Usn,
               IN  ULONG        VolumeSerial,
               IN  ULONGLONG    FileId,
               IN  ULONGLONG    Block,
               IN  BOOLEAN      LockPages,
               OUT PRP_FILE_BUF *FileBuf
               )
/*++

Routine Description

    Locates and returns a locked buffer corresponding to the supplied
    volume/file/block ids.
    It's up to the calling routine to check if the buffer contains valid
    data - and if not to initiate i/o.
    In either case the caller is expected to release the buffer once
    it's done with it.

Arguments

    Usn           - USN of the file
    VolumeSerial  - Volume serial number of the volume on which the file resides
    FileId        - File id of the file
    Block         - Block number mapped to the buffer
    FileBuf       _ If return value is STATUS_SUCCESS, pointer to the locked buffer
                    for the block if the contents are valid is returned here -
                    if not, pointer to a free buffer on which i/o needs to be done

Return Value

    STATUS_SUCCESS  - FileBuf contains the pointer to the block with valid contents
                      In this case the block will be acquired shared
    STATUS_PENDING -  I/O had already begun on the block.
                      Hence this routine queues the new request to the block and returns this status
    STATUS_WAIT_63  - For lack of a better success status value. FileBuf contains the pointer to the
                      block on which I/O needs to be initiated. The block is removed from the LRU
    STATUS_TIMEOUT  - Timed out waiting for free buffer, *FileBuf will set to NULL

    STATUS_CANCELLED - The IRP was cancelled
--*/
{
   ULONG   bucketNumber;
   PRP_CACHE_BUCKET bucket;
   PRP_FILE_BUF  block;
   NTSTATUS status;
   BOOLEAN found;

   PAGED_CODE();

   //
   // Locate the bucket in which this block should reside
   //
   bucketNumber = RsHashFileBuffer(VolumeSerial, FileId, Block);

   bucket = &RspCacheBuckets[bucketNumber];
   //
   // Traverse the queue to find the block
   //
   found   = FALSE;

   RsAcquireLru();

   block = CONTAINING_RECORD(bucket->FileBufHead.Flink,
                             RP_FILE_BUF,
                             BucketLinks);

   while (block != CONTAINING_RECORD(&bucket->FileBufHead,
                                     RP_FILE_BUF,
                                     BucketLinks)) {
      if (block->FileId == FileId &&
          block->VolumeSerial == VolumeSerial &&
          block->Block == Block) {
         found = TRUE;
         break;
      }
      block = CONTAINING_RECORD(block->BucketLinks.Flink,
                                RP_FILE_BUF,
                                BucketLinks);
   }

   if (found) {
      //
      // We found the buffer corresponding to the block
      // Now we have 5 possible cases
      // 1. The buffer is busy - i.e. there's i/o in progress
      //    to fill the buffer with the block contents
      //    In this case, we unlock the bucket, wait for the
      //    i/o to complete and go back to try and find the block
      //
      // 2. I/O is completed on the buffer  successfully
      //    we move the buffer to the tail of the LRU if it was on the
      //    LRU, lock the buffer, unlock the queue and return
      //
      // 3. The buffer was found but the contents are stale
      //
      // 4. I/O completed with errors
      //
      // 5. The buffer contents are simply invalid and i/o needs to be initiated
      //
      if (block->State == RP_FILE_BUF_IO) {
         //
         // Case 1: Queue this request with the block and return
         //
         status = RsCacheQueueRequestWithBuffer(block,
                                                Irp,
                                                LockPages);
         if (status == STATUS_PENDING) {
            //
            // Queued successfully
            // Indicate i/o is in progress
            //
         } else if (status == STATUS_CANCELLED) {
            //
            // The IRP was cancelled : nothing to do, just return
            //
         } else {
            //
            // Couldn't queue it for some reason: just use the non-cached path for now
            //
            status = STATUS_TIMEOUT;
         }

      } else if ((Usn != block->Usn) ||
                 (block->State == RP_FILE_BUF_ERROR) ||
                 (block->State == RP_FILE_BUF_INVALID)) {
         // Case 3:
         // Block state is valid but has stale data: this
         // file buffer will be dispatched for I/O.
         // Or
         // Case 4:
         // Previous attempt at I/O ended in error
         // Or
         // Case 5:
         // Block is invalid and needs to refreshed with contents
         // In all cases, take it off the LRU since it will be dispatched
         // for i/o

         //
         // If somebody is using the block - i.e. copying data from it
         // we block till they are finished with it
         //
         RsAcquireFileBufferExclusive(block);

         block->State = RP_FILE_BUF_IO;

         RsReleaseFileBuffer(block);

         block->Usn = Usn;

         RsRemoveFromLru(block);
         //
         // Indicate i/o needs to be queued for this block
         //
         status = STATUS_WAIT_63;

      } else if (block->State == RP_FILE_BUF_VALID) {
         //
         // Case 2: block is valid
         //
         ASSERT (block->State == RP_FILE_BUF_VALID);

         RsAcquireFileBufferShared(block);

         RsMoveFileBufferToTailLru(block);

         status = STATUS_SUCCESS;
      }

      RsReleaseLru();

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileBuffer returning  block %x found on hash bucket %d\n", block, bucketNumber));

      *FileBuf = block;
   } else {
      PRP_CACHE_BUCKET blockBucket;
      ULONG blockBucketNumber;
      ULONG waitCount = 0;
      LARGE_INTEGER timeout;
      //
      // There's no buffer corresponding to the block allocated
      // Get one from the LRU free list
      //
      *FileBuf = NULL;

      timeout.QuadPart = 0;
      status = KeWaitForSingleObject(&RspCacheLru.AvailableSemaphore,
                                     UserRequest,
                                     KernelMode,
                                     FALSE,
                                     &timeout);

      if ((status == STATUS_TIMEOUT) ||
          (!NT_SUCCESS(status))) {
         //
         // That's all the time we'll wait..
         //
         RsReleaseLru();
         return status;
      }

      block = RsRemoveHeadLru(TRUE);

      if (block == NULL) {
         //
         // Should not happen!
         // Couldn't allocate a new free block and all the available ones are already
         // taken.
         //
         KeReleaseSemaphore(&RspCacheLru.AvailableSemaphore,
                            IO_NO_INCREMENT,
                            1L,
                            FALSE);

         RsReleaseLru();

         return STATUS_TIMEOUT;
      }

      //
      // block is a free buffer allocated from the LRU
      //
      ASSERT (block->State == RP_FILE_BUF_INVALID);

      blockBucketNumber = RsHashFileBuffer(block->VolumeSerial,
                                           block->FileId,
                                           block->Block);

      blockBucket = &RspCacheBuckets[blockBucketNumber];
      //
      // Reinitialize the block
      //
      RsReinitializeFileBuf(block, VolumeSerial, FileId, Usn, Block);
      //
      // Put the buffer in the busy state. We do not need to acuqire the buffer
      // because no body is using this buffer at this point
      //
      block->State = RP_FILE_BUF_IO;
      //
      // Remove the block from it's old queue
      //
      RsRemoveFromCacheBucket(block);
      //
      // Add it to the new queue
      //
      RsInsertTailCacheBucket(bucket, block);
      //
      // Release the current bucket
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileBuffer returning  block %x from LRU\n", block));

      *FileBuf = block;

      RsReleaseLru();
      status = STATUS_WAIT_63;
   }

   return status;
}


VOID
RsCacheFsaPartialData(
                     IN PRP_IRP_QUEUE       ReadIo,
                     IN PUCHAR              Buffer,
                     IN ULONGLONG           Offset,
                     IN ULONG               Length,
                     IN NTSTATUS            Status
                     )
/*++
Routine Description

    This is the cache hook which will copy incoming norecall data from
    FSA  to the cache buffer

Arguments

    ReadIo  - Pointer to the read irp request packet
    Buffer  - Pointer to the buffer containing  the incoming data
    Offset  - Offset in the buffer that this partial data corresponds to
    Length  - Length retrieved in this stretch
    Status  - Indicates if the data is valid (STATUS_SUCCESS) or
              error if it is not

Return Value

    None

--*/
{
   PRP_FILE_BUF fileBuf;

   PAGED_CODE();

   if (Status != STATUS_SUCCESS) {
      //
      // Not really interested in the buffer contents
      // We don't have any cleaning up to do either
      // Just return
      //
      return;
   }

   fileBuf = ReadIo->cacheBuffer;

   ASSERT (fileBuf);
   ASSERT (Length <= RspCacheBlockSize);
   //
   // Copy the data to the offset *within* the cache block
   //
   RtlCopyMemory(((CHAR *) fileBuf->Data) + Offset,
                 Buffer,
                 Length);
}


VOID
RsCacheFsaIoComplete(
                    IN PRP_IRP_QUEUE ReadIo,
                    IN NTSTATUS      Status
                    )

/*++
Routine Description

    This is the cache hook which will be called when the
    cache block i/o transfer is complete.
    This will mark the state of the cache file buffer
    as appropriate, and release it.
    If the cache buffer is valid, we add it to
    the tail of the LRU - if not to the head.
    (so it can be reclaimed immediately)
    We raise the appropriate events indicating
    that i/o is complete on the buffer and also
    that a free buffer is available
    Note this is called after the cancel routine is cleared
    in the IRP

Arguments

    ReadIo  - Pointer to the read i/o request packet
    Status  - Indicates if the status of the i/o request

Return Value

    None

--*/
{
   PRP_FILE_BUF fileBuf = ReadIo->cacheBuffer;
   PIRP         irp;
   BOOLEAN      unlock = FALSE;
   PUCHAR       userBuffer;
   KAPC_STATE   apcState;
   PIO_STACK_LOCATION irpSp;
   NTSTATUS     status;
   BOOLEAN synchronousIo;

   PAGED_CODE();

   ASSERT (fileBuf);

   RsAcquireLru();
   RsAcquireFileBufferExclusive(fileBuf);


   if (NT_SUCCESS(Status)) {
      fileBuf->State = RP_FILE_BUF_VALID;
      fileBuf->IoStatus = STATUS_SUCCESS;
      RsInsertTailLru(fileBuf);
   } else {
      fileBuf->State = RP_FILE_BUF_ERROR;
      fileBuf->IoStatus = Status;
      RsInsertHeadLru(fileBuf);
   }
   //
   // Complete all pending requests on the block here
   //
   while ((irp = RsCacheGetNextQueuedRequest(fileBuf)) != NULL) {

      if (NT_SUCCESS(Status)) {
         status = STATUS_SUCCESS;
         if (RsCacheIrpGetLockPages(irp)) {
            //
            // Probe and lock the buffer: we're going to write to it.
            // This is protected by the surrounding try-except
            //
            try {
               MmProbeAndLockProcessPages (irp->MdlAddress,
                                           IoGetRequestorProcess(irp),
                                           irp->RequestorMode,
                                           IoModifyAccess);
               unlock = TRUE;
               userBuffer = MmGetSystemAddressForMdlSafe(irp->MdlAddress,
                                                         NormalPagePriority) ;
               if (userBuffer == NULL) {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            }except(EXCEPTION_EXECUTE_HANDLER) {
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Unable to lock read buffer!.\n"));
               RsLogError(__LINE__, AV_MODULE_RPCACHE, 0,
                          AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
               status = STATUS_INVALID_USER_BUFFER;
            }
         } else {
            userBuffer = irp->UserBuffer;
         }
         if (NT_SUCCESS(status)) {
            //
            // The pages are locked down and we have a system address to copy the data to
            //
            irpSp = IoGetCurrentIrpStackLocation(irp);

            RtlCopyMemory(userBuffer,
                          fileBuf->Data,
                          irpSp->Parameters.Read.Length);

            irp->IoStatus.Information = irpSp->Parameters.Read.Length;

            synchronousIo = BooleanFlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO );

            if (synchronousIo) {
               //
               // Change the current byte offset in the file object
               // Use interlocked add because the associated IRPs can
               // complete in any order
               //
               ExInterlockedAddLargeStatistic(&irpSp->FileObject->CurrentByteOffset,
                                              (ULONG)irp->IoStatus.Information);
            }
         } else {
            //
            // We failed to get a system address for the MDL
            //
            irp->IoStatus.Information = 0;
         }
         if (unlock) {
            MmUnlockPages(irp->MdlAddress);
            unlock = FALSE;
            IoFreeMdl(irp->MdlAddress);
            irp->MdlAddress = NULL;
         }
         irp->IoStatus.Status = status;
         IoCompleteRequest(irp,
                           IO_DISK_INCREMENT);
      } else {
         //
         // I/o completed with errors
         //
         if (RsCacheIrpGetLockPages(irp)) {
            //
            // Free the already allocated MDL
            //
            IoFreeMdl(irp->MdlAddress);
            irp->MdlAddress = NULL;
         }
         irp->IoStatus.Status = Status;
         irp->IoStatus.Information = 0;
         IoCompleteRequest(irp,
                           IO_NO_INCREMENT);
      }
   }
   RsReleaseFileBuffer(fileBuf);
   RsReleaseLru();
}


NTSTATUS
RsCacheInitialize(VOID)
/*++

Routine Description

    Initializes the cache for no-recall buffers

Arguments

    None

Return Value

   Status

--*/
{
   ULONG i;
   PRP_FILE_BUF fileBuf;
   PUCHAR  data;

   PAGED_CODE();

   if (RspCacheInitialized) {
      return STATUS_SUCCESS;
   }

   //
   // Get all the registry based tunables
   //

   RsCacheGetParameters();

   //
   // Initialize the LRU structure
   //
   ExInitializeFastMutex(&(RspCacheLru.Lock));
   InitializeListHead(&RspCacheLru.FileBufHead);
   RspCacheLru.TotalCount = 0;
   RspCacheLru.LruCount = 0;

   //
   // Read the parameters here (RspCacheBlockSize, RspCacheMaxBuckets, RspCacheMaxBuffers)
   //

   //
   // Allocate and initialize the hash buckets
   //
   RspCacheBuckets = ExAllocatePool(NonPagedPool,
                                    RspCacheMaxBuckets * sizeof(RP_CACHE_BUCKET));
   if (RspCacheBuckets == NULL) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Could not allocate cache buckets!\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   for ( i = 0; i < RspCacheMaxBuckets ; i++) {
      InitializeListHead(&(RspCacheBuckets[i].FileBufHead));
   }
   //
   // Allocate the buffers and put them all on the
   // LRU
   //
   if (RspCachePreAllocate) {
      //
      // Initialize the buffers available semaphore
      //
      KeInitializeSemaphore(&RspCacheLru.AvailableSemaphore,
                            0,
                            RspCacheMaxBuffers);
      for (i = 0; i < RspCacheMaxBuffers; i++) {
         fileBuf = RsCacheAllocateBuffer();
         if (!fileBuf) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Failed to allocate cache buffer\n"));
            break;
         }
         RspCacheLru.TotalCount++;
         RsInsertTailLru(fileBuf);
      }
   } else {
      //
      // Initialize the buffers available semaphore.
      //
      KeInitializeSemaphore(&RspCacheLru.AvailableSemaphore,
                            RspCacheMaxBuffers,
                            RspCacheMaxBuffers);
   }

   RspCacheInitialized = TRUE;

   return STATUS_SUCCESS;
}


NTSTATUS
RsCacheGetParameters(VOID)
/*++

Routine Description

   Reads the no-recall cache tunables from registry

Arguments

   None

Return Value

   Status.

--*/
{
   PRTL_QUERY_REGISTRY_TABLE parms;
   ULONG                     parmsSize;
   NTSTATUS                  status;

   ULONG defaultBlockSize   = RP_CACHE_DEFAULT_BLOCK_SIZE;
   ULONG defaultMaxBuckets  = RP_CACHE_DEFAULT_MAX_BUCKETS;
   ULONG defaultPreAllocate = RP_CACHE_DEFAULT_PREALLOCATE;
   ULONG defaultNoRecall    = RP_NO_RECALL_DEFAULT;
   ULONG defaultMaxBuffers  = RP_CACHE_MAX_BUFFERS_SMALL;

   PAGED_CODE();

   parmsSize =  sizeof(RTL_QUERY_REGISTRY_TABLE) * 6;

   parms = ExAllocatePool(PagedPool,
                          parmsSize);

   if (!parms) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   switch (MmQuerySystemSize()) {

   case MmSmallSystem:{
         defaultMaxBuffers = RP_CACHE_MAX_BUFFERS_SMALL;
         break;}
   case MmMediumSystem:{
         defaultMaxBuffers = RP_CACHE_MAX_BUFFERS_MEDIUM;
         break;}
   case MmLargeSystem:{
         defaultMaxBuffers = RP_CACHE_MAX_BUFFERS_LARGE;
         break;}

   }

   RtlZeroMemory(parms, parmsSize);

   parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[0].Name          = RP_CACHE_BLOCK_SIZE_KEY;
   parms[0].EntryContext  = &RspCacheBlockSize;
   parms[0].DefaultType   = REG_DWORD;
   parms[0].DefaultData   = &defaultBlockSize;
   parms[0].DefaultLength = sizeof(ULONG);

   parms[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[1].Name          = RP_CACHE_MAX_BUFFERS_KEY;
   parms[1].EntryContext  = &RspCacheMaxBuffers;
   parms[1].DefaultType   = REG_DWORD;
   parms[1].DefaultData   = &defaultMaxBuffers;
   parms[1].DefaultLength = sizeof(ULONG);

   parms[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[2].Name          = RP_CACHE_MAX_BUCKETS_KEY;
   parms[2].EntryContext  = &RspCacheMaxBuckets;
   parms[2].DefaultType   = REG_DWORD;
   parms[2].DefaultData   = &defaultMaxBuckets;
   parms[2].DefaultLength = sizeof(ULONG);

   parms[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[3].Name          = RP_CACHE_PREALLOCATE_KEY;
   parms[3].EntryContext  = &RspCachePreAllocate;
   parms[3].DefaultType   = REG_DWORD;
   parms[3].DefaultData   = &defaultPreAllocate;
   parms[3].DefaultLength = sizeof(ULONG);

   parms[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[4].Name          = RP_NO_RECALL_DEFAULT_KEY;
   parms[4].EntryContext  = &RsNoRecallDefault;
   parms[4].DefaultType   = REG_DWORD;
   parms[4].DefaultData   = &defaultNoRecall;
   parms[4].DefaultLength = sizeof(ULONG);
   //
   // Perform the query
   //
   status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                   RP_CACHE_PARAMETERS_KEY,
                                   parms,
                                   NULL,
                                   NULL);
   ExFreePool(parms);
   return status;
}


PRP_FILE_BUF
RsCacheAllocateBuffer(VOID)
/*++

Routine Description

    Allocates and returns an initialized block
    of paged pool to buffer no-recall data

Arguments

    None

Return Value

   Pointer to the block if successfully allocated
   NULL if not
--*/
{
   PRP_FILE_BUF fileBuf;
   PUCHAR  data;

   PAGED_CODE();

   fileBuf = ExAllocatePool(NonPagedPool, sizeof(RP_FILE_BUF));
   if (!fileBuf) {
      return NULL;
   }

   data = ExAllocatePool(PagedPool, RspCacheBlockSize);

   if (!data) {
      ExFreePool(fileBuf);
      return NULL;
   }
   RsInitializeFileBuf(fileBuf, data);
   return fileBuf;
}


PIRP
RsCacheGetNextQueuedRequest(IN PRP_FILE_BUF FileBuf)
/*++

Routine Description

   Returns the next non-cancellable request from the
   queued requests for this block

Arguments

   FileBuf - Pointer to the block

Return Value

   NULL     - if none are found
   Pointer to non-cancellable request if one is found

--*/
{
   PIRP  irp;
   KIRQL cancelIrql;
   PLIST_ENTRY entry;
   BOOLEAN found = FALSE;

   IoAcquireCancelSpinLock(&cancelIrql);

   while (!IsListEmpty(&FileBuf->WaitQueue)) {
      //
      // Get next packet
      //
      entry = RemoveHeadList(&FileBuf->WaitQueue);
      //
      // Clear the cancel routine
      //
      irp = RsCacheIrpWaitQueueContainingIrp(entry);

      if (IoSetCancelRoutine(irp, NULL) == NULL) {
         //
         // This IRP was cancelled - let the cancel routine handle it
         //
         continue;
      } else {
         found = TRUE;
         break;
      }
   }

   IoReleaseCancelSpinLock(cancelIrql);

   return(found ? irp : NULL);
}


NTSTATUS
RsCacheCancelQueuedRequest(
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          )
/*++

Routine Description:

    This function filters cancels an outstanding read-no-recall IRP that
    has been queued to a block

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

   STATUS_SUCCESS

--*/
{

   RemoveEntryList(RsCacheIrpWaitQueueEntry(Irp));

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   Irp->IoStatus.Status = STATUS_CANCELLED;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp,
                     IO_NO_INCREMENT);
   return STATUS_SUCCESS;
}


NTSTATUS
RsCacheQueueRequestWithBuffer(
                             IN PRP_FILE_BUF FileBuf,
                             IN PIRP Irp,
                             IN BOOLEAN LockPages)
/*++

Routine Description

   Queues the IRP associated cache block, to be completed
   when the i/o on the block finishes

N.B.: LRU lock is acquired when this is called

Arguments

   FileBuf   -   Pointer to the cache block on which the request is waiting
   Irp       -   Pointer to the IRP which is waiting
   LockPages -   True if the IRP pages need to be locked down during transfer

Return Value

   STATUS_PENDING    - Irp has been queued
   STATUS_CANCELLED  - Irp was cancelled
   Any other status  - Error in queueing the request

--*/
{
   NTSTATUS status;
   KIRQL    cancelIrql;

   IoAcquireCancelSpinLock(&cancelIrql);

   if (!Irp->Cancel) {
      RsCacheIrpSetLockPages(Irp, LockPages);

      InsertHeadList(&FileBuf->WaitQueue,
                     RsCacheIrpWaitQueueEntry(Irp));

      IoMarkIrpPending( Irp );
      IoSetCancelRoutine( Irp, RsCacheCancelQueuedRequest);
      status = STATUS_PENDING;
   } else {
      status = STATUS_CANCELLED;
   }

   IoReleaseCancelSpinLock(cancelIrql);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\filter\rpfilfun.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2001
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFilfun.c

Abstract:

    This module contains support routines for the HSM file system filter.

Author:

    Rick Winter
    Ravisankar Pudipeddi   (ravisp)    - 1998

Environment:

    Kernel mode


Revision History:

	X-14	108353		Michael C. Johnson		 3-May-2001
		When checking a file to determine the type of recall also
		check a the potential target disk to see whether or not
		it is writable. This is necessary now that we have read-only
		NTFS volumes.

	X-13	365077		Michael C. Johnson		 1-May-2001
		Although IoCreateFileSpecifyDeviceObjectHint() allows us to 
		bypass share access checking it doesn't bypass the check for 
		a readonly file attribute. Revert to the old scheme of 
		directly munging the file object after a successful open. 
		Note that we can still use IoCreateFileSpecifyDeviceObjectHint() 
		to avoid traversing the entire IO stack.

	X-12	332127		Michael C. Johnson		10-Apr-2001
		Reduce the number of times a notification message is sent 
		to the service to once per file stream. Use the exisiting 
		RP_NOTIFICATION_SENT flag but use it for all cases.

	X-11	206961		Michael C. Johnson		16-Mar-2001
		Refresh the cached filename in the file context on each new 
		open of the file in case the file has been renamed since the
		last time we saw an open.

		273036
		Correct reported status on logging of failed reparse point
		deletions. 

		Add in memory trace mechanism in preparation for attempts
		to flush out lingering reparse point deletion troubles.

	X-10	326345		Michael C. Johnson		26-Feb-2001
		Only send a single RP_RECALL_WAITING to the fsa on any one
		file object. Use the new flag RP_NOTIFICATION_SENT to record 
		when notification has been done.


--*/


#include "pch.h"

ULONG                   RsFileContextId       = 1;
ULONG                   RsFileObjId           = 1;
ULONG                   RsNoRecallReadId      = 1;
ULONG                   RsFsaRequestCount     = 0;

ULONG                   RsDefaultTraceEntries = DEFAULT_TRACE_ENTRIES;
PRP_TRACE_CONTROL_BLOCK RsTraceControlBlock   = NULL;

KSPIN_LOCK              RsIoQueueLock;
LIST_ENTRY              RsIoQHead;

FAST_MUTEX              RsFileContextQueueLock;
LIST_ENTRY              RsFileContextQHead;

KSPIN_LOCK              RsValidateQueueLock;
LIST_ENTRY              RsValidateQHead;


//
// Semaphore signalling that a new FSCTL from FSA is available for RsFilter's
// consumption
//
KSEMAPHORE            RsFsaIoAvailableSemaphore;

extern PDRIVER_OBJECT FsDriverObject;
extern ULONG          RsAllowRecalls;
extern ULONG          RsNoRecallDefault;



NTSTATUS
RsCancelIoIrp(
             PDEVICE_OBJECT DeviceObject,
             PIRP Irp
             );

PRP_IRP_QUEUE
RsDequeuePacket(
               IN PLIST_ENTRY Head,
               IN PKSPIN_LOCK Lock
               );

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, RsAddQueue)
    #pragma alloc_text(PAGE, RsCheckRead)
    #pragma alloc_text(PAGE, RsCheckWrite)
    #pragma alloc_text(PAGE, RsAddFileObj)
    #pragma alloc_text(PAGE, RsMakeContext)
    #pragma alloc_text(PAGE, RsAcquireFileContext)
    #pragma alloc_text(PAGE, RsReleaseFileContext)
    #pragma alloc_text(PAGE, RsGetFileId)
    #pragma alloc_text(PAGE, RsGetFileName)
    #pragma alloc_text(PAGE, RsGetFileInfo)
    #pragma alloc_text(PAGE, RsQueueRecall)
    #pragma alloc_text(PAGE, RsQueueRecallOpen)
    #pragma alloc_text(PAGE, RsPartialWrite)
    #pragma alloc_text(PAGE, RsWriteReparsePointData)
    #pragma alloc_text(PAGE, RsGetRecallInfo)
    #pragma alloc_text(PAGE, RsGetFsaRequest)
    #pragma alloc_text(PAGE, RsGenerateDevicePath)
    #pragma alloc_text(PAGE, RsGenerateFullPath)
    #pragma alloc_text(PAGE, RsFreeFileObject)
    #pragma alloc_text(PAGE, RsFailAllRequests)
    #pragma alloc_text(PAGE, RsCancelRecalls)
    #pragma alloc_text(PAGE, RsIsNoRecall)
    #pragma alloc_text(PAGE, RsIsFastIoPossible)
    #pragma alloc_text(PAGE, RsQueueNoRecall)
    #pragma alloc_text(PAGE, RsQueueNoRecallOpen)
    #pragma alloc_text(PAGE, RsDoWrite)
    #pragma alloc_text(PAGE, RsPreserveDates)
    #pragma alloc_text(PAGE, RsCompleteAllRequests)
    #pragma alloc_text(PAGE, RsLogValidateNeeded)
    #pragma alloc_text(PAGE, RsQueueValidate)
    #pragma alloc_text(PAGE, RsQueueCancel)
    #pragma alloc_text(PAGE, RsGetFileUsn)
    #pragma alloc_text(PAGE, RsCheckVolumeReadOnly)

    #pragma alloc_text(INIT, RsTraceInitialize)

#endif


NTSTATUS
RsAddQueue(IN  ULONG          Serial,
           OUT PULONGLONG     RecallId,
           IN  ULONG          OpenOption,
           IN  PFILE_OBJECT   FileObject,
           IN  PDEVICE_OBJECT DevObj,
           IN  PDEVICE_OBJECT FilterDeviceObject,
           IN  PRP_DATA       PhData,
           IN  LARGE_INTEGER  RecallStart,
           IN  LARGE_INTEGER  RecallSize,
           IN  LONGLONG       FileId,
           IN  LONGLONG       ObjIdHi,
           IN  LONGLONG       ObjIdLo,
           IN  ULONG          DesiredAccess,
           IN  PRP_USER_SECURITY_INFO UserSecurityInfo)
/*++

Routine Description:

   This function adds a file object queue entry to the internal queue

Arguments:
   Open options from the Irp
   Irp
   IO_STACK_LOCATION
   Device object
   Placeholder data

Return Value:
  0 if queued ok
  non-zero otherwise


Note:  We will retrieve some security information.  The calls necessary to do this require that the
call be made from irql DISPATCH_LEVEL or above.


--*/
{
    PRP_FILE_OBJ            entry;
    ULONGLONG               filterId;
    PIRP                    ioIrp;
    PRP_FILE_CONTEXT        context;
    NTSTATUS                status;
    PRP_FILTER_CONTEXT      filterContext;
    BOOLEAN                 gotLock = FALSE;

    PAGED_CODE();

    try {

        entry = (RP_FILE_OBJ *) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILE_OBJ), RP_RQ_TAG);

        if (NULL == entry) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(entry, sizeof(RP_FILE_OBJ));

        entry->fileObj = FileObject;
        entry->devObj = DevObj;
        ExInitializeResourceLite(&entry->resource);
        KeInitializeSpinLock(&entry->qLock);
        InitializeListHead(&entry->readQueue);
        InitializeListHead(&entry->writeQueue);
        entry->openOptions = OpenOption;
        entry->objIdHi = ObjIdHi;
        entry->objIdLo = ObjIdLo;
        entry->fileId = FileId;
        entry->desiredAccess = DesiredAccess;
        entry->userSecurityInfo = UserSecurityInfo;

        if (UserSecurityInfo->isAdmin) {
            entry->flags |= RP_OPEN_BY_ADMIN;
        }

        if (UserSecurityInfo->localProc) {
            entry->flags |= RP_OPEN_LOCAL;
        }

        if (!(DesiredAccess & FILE_HSM_ACTION_ACCESS) ) {
            entry->flags |= RP_NO_DATA_ACCESS;
        }
        //
        // Now see if there is a file context entry for this file
        // This call will create one if necessary, or return an already existing one.
        // The file context entry is locked when this call returns and the
        // ref count bumped up
        //
        status = RsMakeContext(FileObject, &context);

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);
            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            return status;
        }

        gotLock = TRUE;
        entry->fsContext = context;


        if (!(context->flags & RP_FILE_INITIALIZED)) {
            //
            // We have to initialize it here.
            //
            InitializeListHead(&context->fileObjects);
            context->devObj = DevObj;
	    context->FilterDeviceObject = FilterDeviceObject;
            KeInitializeSpinLock(&context->qLock);
            KeInitializeEvent(&context->recallCompletedEvent,
                              NotificationEvent,
                              FALSE);
            context->fileId = FileId;
            context->recallSize = RecallSize;
            filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileContextId);
            context->filterId = filterId;
            context->serial = Serial;
            memcpy(&context->rpData, PhData, sizeof(RP_DATA));

            context->flags |= RP_FILE_INITIALIZED;

            if (RP_FILE_IS_TRUNCATED(PhData->data.bitFlags)) {
                context->state = RP_RECALL_NOT_RECALLED;
                context->recallStatus = STATUS_SUCCESS;
                context->currentOffset.QuadPart = 0;
            } else {
                //
                // File is pre-migrated
                //
                context->state = RP_RECALL_COMPLETED;
                context->recallStatus = STATUS_SUCCESS;
                context->currentOffset.QuadPart = RecallSize.QuadPart;
            }


            if (NT_SUCCESS(status) && RP_IS_NO_RECALL_OPTION(OpenOption)) {
                 status = RsGetFileUsn(context,
                                       FileObject,
                                       FilterDeviceObject);

            }

            if (!NT_SUCCESS(status)) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter:RsAddQueue: Failed to get the path (%x).\n", status));
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, status, AV_MSG_PATH_ERROR, NULL, NULL);
                //
                // Deref & release context
                //
                RsReleaseFileContext(context);
                gotLock = FALSE;
                ExDeleteResourceLite(&entry->resource);
                ExFreePool(entry);

                return(status);
            }
        }


        //
        // Discard any existing filename to force an update of cached filename 
        // in case of renames since the original open.
        //
        if (context->uniName != NULL) {
            ExFreePool(context->uniName);
            context->uniName = NULL;
        }

        status = RsGetFileInfo(entry, FilterDeviceObject);


        filterId = context->filterId;

        if (context->flags & RP_FILE_WAS_WRITTEN) {
            //
            // If file was written to - we cannot operate in a no-recall mode
            //
            RP_RESET_NO_RECALL_OPTION(OpenOption);
        }

        if (RP_IS_NO_RECALL_OPTION(OpenOption)) {
            //
            // Open no recall - the file object does not have an ID - each read will get one later.
            //
            entry->filterId = 0;

            RP_SET_NO_RECALL(entry);

        } else {
            //
            // A normal recall - assign a filter ID to the file object
            //
            entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
            entry->filterId <<= 32;
            entry->filterId |= RP_TYPE_RECALL;
            filterId |= entry->filterId;
        }

        *RecallId = filterId;

        filterContext= (PRP_FILTER_CONTEXT) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILTER_CONTEXT), RP_RQ_TAG);
        if (NULL == filterContext) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILTER_CONTEXT),
                       AV_MSG_MEMORY, NULL, NULL);
            //
            // Deref/free context
            //
            RsReleaseFileContext(context);
            gotLock = FALSE;

            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(filterContext, sizeof(RP_FILTER_CONTEXT));
        FsRtlInitPerStreamContext( &filterContext->context,
                                   FsDeviceObject,
                                   FileObject,
                                   RsFreeFileObject);
        filterContext->myFileObjEntry = entry;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsAddQueue: Allocated filter context tag  %x : %x (id = %I64X).\n", context, entry, *RecallId));

        status = FsRtlInsertPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), &filterContext->context);

        if (NT_SUCCESS(status)) {

            // Now that we have gotten everything setup we can put it on the queue
            //
            ExInterlockedInsertTailList(&context->fileObjects,
                                        (PLIST_ENTRY) entry,
                                        &context->qLock);
        } else {
            //
            // Failed to add filter context.
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Failed to insert filter context %x.\n", status));

            RsReleaseFileContext(context);
            gotLock = FALSE;

            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
        }

        RsReleaseFileContextEntryLock(context);
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsAddQueue", GetExceptionInformation())) {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
        }

    }
    return(status);
}


NTSTATUS
RsGetFileUsn(IN PRP_FILE_CONTEXT Context,
             IN PFILE_OBJECT     FileObject,
             IN PDEVICE_OBJECT   FilterDeviceObject)
/*++

Routine Description:

   This function retrieves the file USN of the specified file

Arguments:

   Context              -     pointer to the file context entry where the USN is stored
   FileObject           -     pointer to the file object
   FilterDeviceObject   -     pointer to the dev obj for RsFilter

Return Value:
  0 if queued ok
  non-zero otherwise

--*/
{
    PIRP               irp;
    KEVENT             event;
    PDEVICE_EXTENSION  deviceExtension = FilterDeviceObject->DeviceExtension;
    PUSN_RECORD        usnRecord;
    ULONG              usnRecordSize;
    NTSTATUS           status;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    usnRecordSize = sizeof(USN_RECORD) + 4096;
    usnRecord = ExAllocatePoolWithTag(PagedPool,
                                      usnRecordSize,
                                      RP_US_TAG);

    if (!usnRecord) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);


    irp =  IoBuildDeviceIoControlRequest(FSCTL_READ_FILE_USN_DATA,
                                         deviceExtension->FileSystemDeviceObject,
                                         NULL,
                                         0,
                                         usnRecord,
                                         usnRecordSize,
                                         FALSE,
                                         &event,
                                         &ioStatus);
    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the other stuff
    //
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->FileObject = FileObject;
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = usnRecordSize;

    ObReferenceObject(FileObject);

    status = IoCallDriver(deviceExtension->FileSystemDeviceObject,
                          irp);

    if (status == STATUS_PENDING) {
        (VOID)KeWaitForSingleObject(&event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        Context->usn = usnRecord->Usn;
    }

    ExFreePool(usnRecord);

    return status;
}


NTSTATUS
RsAddFileObj(IN PFILE_OBJECT   FileObj,
             IN PDEVICE_OBJECT FilterDeviceObject,
             IN RP_DATA        *PhData,
             IN ULONG          OpenOption)
/*++

Routine Description:

   This function adds a file object queue entry to the internal queue

Arguments:
   FileObj              -     pointer to the file object
   FilterDeviceObject   -     pointer to the dev obj for RsFilter
   PhData               -     pointer to the placeholder data
   OpenOption           -     File Open options from the Irp

Return Value:
  0 if queued ok
  non-zero otherwise

--*/
{
    PRP_FILE_OBJ            entry;
    ULONGLONG               filterId;
    PRP_FILE_CONTEXT        context;
    NTSTATUS                status = STATUS_FILE_IS_OFFLINE;
    PRP_FILTER_CONTEXT      filterContext;
    BOOLEAN                 gotLock = FALSE;

    PAGED_CODE();

    try {
        entry = (RP_FILE_OBJ *) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILE_OBJ), RP_RQ_TAG);
        if (NULL == entry) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);

            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        RtlZeroMemory(entry, sizeof(RP_FILE_OBJ));

        entry->fileObj = FileObj;
        entry->devObj = FileObj->DeviceObject;
        ExInitializeResourceLite(&entry->resource);
        KeInitializeSpinLock(&entry->qLock);
        InitializeListHead(&entry->readQueue);
        InitializeListHead(&entry->writeQueue);
        entry->openOptions = OpenOption;
        entry->flags = RP_NO_DATA_ACCESS;
        //
        // Now see if there is a file context entry for this file
        // This call will create one if necessary, or return an already existing one.
        // The file context entry is locked when this call returns.
        //
        status = RsMakeContext(FileObj, &context);

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);
            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            return(status);
        }

        gotLock = TRUE;
        entry->fsContext = context;


        if (!(context->flags & RP_FILE_INITIALIZED)) {
            //
            // We have to initialize it here.
            //
            // Get the volume serial number
            if ((FileObj !=0) && (FileObj->Vpb != 0)) {
                context->serial = FileObj->Vpb->SerialNumber;
            } else if ((FileObj->DeviceObject != 0) && (FileObj->DeviceObject->Vpb!=0)) {
                context->serial = FileObj->DeviceObject->Vpb->SerialNumber;
            } else {
                RsLogError(__LINE__,
                           AV_MODULE_RPFILFUN,
                           0,
                           AV_MSG_SERIAL,
                           NULL,
                           NULL);
                ExDeleteResourceLite(&entry->resource);
                ExFreePool(entry);
                //
                // Deref the context
                //
                RsReleaseFileContext(context);
                gotLock = FALSE;

                return(STATUS_INVALID_PARAMETER);
            }
            InitializeListHead(&context->fileObjects);
            context->devObj = FileObj->DeviceObject;
	    context->FilterDeviceObject = FilterDeviceObject;
            KeInitializeSpinLock(&context->qLock);
            KeInitializeEvent(&context->recallCompletedEvent,
                              NotificationEvent,
                              FALSE);
            filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileContextId);

            if (RP_IS_NO_RECALL_OPTION(OpenOption)) {
                entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
                entry->filterId <<= 32;
                entry->filterId &= ~RP_TYPE_RECALL;
                filterId |= entry->filterId;
                RP_SET_NO_RECALL(entry);
            } else {
                filterId |= RP_TYPE_RECALL;
            }

            context->filterId = filterId;

            if (RP_FILE_IS_TRUNCATED(PhData->data.bitFlags)) {
                context->state = RP_RECALL_NOT_RECALLED;
                context->recallStatus = 0;
                context->currentOffset.QuadPart = 0;
            } else {
                // File is pre-migrated
                context->state = RP_RECALL_COMPLETED;
                context->recallStatus = STATUS_SUCCESS;
                context->currentOffset.QuadPart = 0;
            }

            if (NULL != PhData) {
                memcpy(&context->rpData, PhData, sizeof(RP_DATA));
            }

            context->flags |= RP_FILE_INITIALIZED;
        }


        //
        // Discard any existing filename to force an update of cached filename 
        // in case of renames since the original open.
        //
        if (context->uniName != NULL) {
            ExFreePool(context->uniName);
            context->uniName = NULL;
        }

	RsGetFileInfo(entry, FilterDeviceObject);


        filterContext= (PRP_FILTER_CONTEXT) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILTER_CONTEXT), RP_RQ_TAG);
        if (NULL == filterContext) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILTER_CONTEXT),
                       AV_MSG_MEMORY, NULL, NULL);


            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);

            RsReleaseFileContext(context);
            gotLock = FALSE;

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(filterContext, sizeof(RP_FILTER_CONTEXT));
        FsRtlInitPerStreamContext(&filterContext->context,
                                  FsDeviceObject,
                                  FileObj,
                                  RsFreeFileObject);
        filterContext->myFileObjEntry = entry;


        status = FsRtlInsertPerStreamContext(FsRtlGetPerStreamContextPointer(FileObj), &filterContext->context);
        if (NT_SUCCESS(status)) {
            //
            // Now that we have gotten everything setup we can put it on the queue
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsAddFileObj: Allocated filter context tag (%x : %x).\n",
                                  context, entry));

            ExInterlockedInsertTailList(&context->fileObjects, (PLIST_ENTRY) entry, &context->qLock);
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        } else {
            //
            // Failed to add filter context.
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Failed to insert filter context %x.\n", status));

            RsReleaseFileContext(context);
            gotLock = FALSE;

            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            ExFreePool(filterContext);
        }

    }except (RsExceptionFilter(L"RsAddFileObj",GetExceptionInformation())) {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContext(context);
        }
        status = STATUS_UNEXPECTED_IO_ERROR;
    }

    return(status);
}


NTSTATUS
RsReleaseFileContext(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   This function frees a file context (if the refcount is zero).
   Lock the queue first then see if the refcount is zero.  If it is then
   remove the file object and free the memory.

Arguments:
   file context structure.

Return Value:
   STATUS_SUCCESS


--*/
{
    BOOLEAN            gotLock, found = FALSE;
    PRP_FILE_CONTEXT   entry;
    NTSTATUS           status = STATUS_SUCCESS;

    PAGED_CODE();

    try {
        RsAcquireFileContextQueueLock();
        gotLock = TRUE;

        entry = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                  RP_FILE_CONTEXT,
                                  list);

        while (entry != CONTAINING_RECORD(&RsFileContextQHead,
                                          RP_FILE_CONTEXT,
                                          list)) {
            if (entry == Context) {
                //
                // Found this one
                //
                if (InterlockedDecrement((PLONG) &entry->refCount) == 0) {
                    //
                    // If the refcount is still zero then dequeue and free the entry.
                    //
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsReleaseFileContext - Freeing file context %x\n", entry));

                    RemoveEntryList(&entry->list);
                    if (entry->uniName != NULL) {
                        ExFreePool(entry->uniName);
                    }
                    RsReleaseFileContextEntryLock(entry);
                    ExDeleteResourceLite(&entry->resource);
                    ExFreePool(entry);
                } else {
                    RsReleaseFileContextEntryLock(entry);
                }
                break;
            } else {
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_CONTEXT,
                                          list
                                         );
            }
        }
        RsReleaseFileContextQueueLock();
        gotLock = FALSE;
    }except (RsExceptionFilter(L"RsReleaseFileContext", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
    }
    return(status);
}


NTSTATUS
RsMakeContext(IN PFILE_OBJECT FileObj,
              OUT PRP_FILE_CONTEXT *Context)
/*++

Routine Description:

   This function finds or creates the file context entry for the given file object.
   Lock the queue first then see if there is already a context.  If not,
   allocate and initialize one.

Arguments:
   IN  file object
   OUT file context structure.

Return Value:
   STATUS_SUCCESS or error

--*/
{
    BOOLEAN            gotLock = FALSE, found = FALSE;
    PRP_FILE_CONTEXT   entry;
    NTSTATUS           status = STATUS_SUCCESS;

    PAGED_CODE();

    try {

        RsAcquireFileContextQueueLock();
        gotLock = TRUE;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMakeContext - Search the queue\n"));
        entry = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                  RP_FILE_CONTEXT,
                                  list);

        while (entry != CONTAINING_RECORD(&RsFileContextQHead,
                                          RP_FILE_CONTEXT,
                                          list)) {
            if (entry->fsContext == FileObj->FsContext) {
                //
                // Found our file context entry
                //
                *Context = entry;
                InterlockedIncrement((PLONG) &entry->refCount);
                RsReleaseFileContextQueueLock();
                gotLock = FALSE;

                RsAcquireFileContextEntryLockExclusive(entry);
                found = TRUE;
                break;
            } else {
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_CONTEXT,
                                          list
                                         );
            }
        }

        if (!found) {
            //
            // None there - create one and put it in the list.
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMakeContext - Not found - create a new context.\n"));

            entry = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILE_CONTEXT), RP_RQ_TAG);
            if (entry != NULL) {
                RtlZeroMemory(entry, sizeof(RP_FILE_CONTEXT));
                *Context = entry;
                entry->fsContext = FileObj->FsContext;
                ExInitializeResourceLite(&entry->resource);
                RsAcquireFileContextEntryLockExclusive(entry);
                entry->refCount = 1;
                InsertTailList(&RsFileContextQHead,  &entry->list);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                *Context = NULL;
            }

            RsReleaseFileContextQueueLock();
            gotLock = FALSE;
        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMakeContext - found %x.\n", entry));
        }
    }except(RsExceptionFilter(L"RsMakeContext", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
    }
    return(status);
}


NTSTATUS
RsFreeFileObject(IN PLIST_ENTRY FilterContext)
/*++

Routine Description:

   This function frees a file object structure.  It is called by the file system
   when a file object is going away.  We need to find the file context and remove
   the file object entry from it's list.  If the refcount for file context is now
   0 then we free the file context entry also.

Arguments:
   file context structure.

Return Value:
   STATUS_SUCCESS


--*/
{
    PRP_FILTER_CONTEXT      rpFilterContext = (PRP_FILTER_CONTEXT) FilterContext;
    PRP_FILE_OBJ            rpFileObject    = rpFilterContext->myFileObjEntry;
    PRP_FILE_CONTEXT        rpFileContext   = rpFileObject->fsContext;
    BOOLEAN                 done            = FALSE;
    BOOLEAN                 gotLock         = FALSE;

    PAGED_CODE();


    try {
        DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject:  %x : %x.\n", 
		     rpFileContext, rpFileObject));


        //
        // Lock the file context entry
        //
        RsAcquireFileContextEntryLockExclusive (rpFileContext);
        gotLock = TRUE;


        //
        // Remove the file object entry and free it.
        //
        rpFileObject = CONTAINING_RECORD (rpFileContext->fileObjects.Flink, 
					  RP_FILE_OBJ,
					  list);

        while ((!done) && (rpFileObject != CONTAINING_RECORD (&rpFileContext->fileObjects, 
							      RP_FILE_OBJ,
							      list))) {

            if (rpFileObject == rpFilterContext->myFileObjEntry) {
		//
                done = TRUE;
                RemoveEntryList (&rpFileObject->list);

            } else {

                //
                // Move on to next file object
                //
                rpFileObject = CONTAINING_RECORD (rpFileObject->list.Flink,
						  RP_FILE_OBJ, 
						  list
						);
            }
        }


        if (done == TRUE) {

            //
            // If it is a normal recall and the recall has started but we have not written any data yet then
            // tell the FSA to cancel it.
            //
            if (!RP_IS_NO_RECALL (rpFileObject) && (rpFileContext->state != RP_RECALL_COMPLETED) && !(rpFileObject->flags & RP_NO_DATA_ACCESS)) {
                //
                // No I/O has been done to the file yet - tell the FSA to cancel
                //
                RsQueueCancel (rpFileObject->filterId | rpFileContext->filterId);
            }


#ifdef TRUNCATE_ON_CLOSE

            if (!RP_IS_NO_RECALL (rpFileObject) && (rpFileContext->handle != 0) && (rpFileContext->state  == RP_RECALL_STARTED) && (rpFileObject->flags & RP_NO_DATA_ACCESS)) {
                //
                // IO has been started. If there are no more file objects referencing this context entry we
                // may as well stop the recall and re-truncate the file.
                //
                if (IsListEmpty (&rpFileContext->fileObjects)) {

                    DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - Could truncate partially recalled file.\n"));

                    RsLogError (__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
				AV_MSG_CODE_HIT, NULL, L"Partial recall truncate");
                }
            }


            //
            // If the file was recalled and the action flag says so then truncate it now.
            // Do this if we are the only opener.
            //
            DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - action = %x.\n", rpFileObject->recallAction));

            if ((!RP_IS_NO_RECALL (rpFileObject)) &&
                (rpFileContext->state == RP_RECALL_COMPLETED) &&
                (rpFileContext->recallStatus == STATUS_SUCCESS) &&
                (rpFileObject->recallAction & RP_RECALL_ACTION_TRUNCATE) &&
                (IsListEmpty (&rpFileContext->fileObjects))) {
                //
                // We have to reopen the file and truncate it now.  This happens when the FSA decides that a particular
                // client is recalling too many files.
                //
                RsTruncateOnClose(rpFileContext);
            }
#endif


            RsFreeUserSecurityInfo (rpFileObject->userSecurityInfo);
            ExDeleteResourceLite (&rpFileObject->resource);


            //
            // Deref/free the file context
            //
            RsReleaseFileContext (rpFileContext);
            gotLock = FALSE;
            ExFreePool (rpFileObject);

        } else {

            RsReleaseFileContextEntryLock (rpFileContext);
            gotLock = FALSE;
        }


        //
        // Always free the filter context pointer
        //
        ExFreePool(rpFilterContext);

    }except (RsExceptionFilter (L"RsFreeFileObject", GetExceptionInformation ()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock (rpFileContext);
        }
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
RsCheckRead(IN  PIRP Irp,
            IN  PFILE_OBJECT FileObject,
            IN  PDEVICE_EXTENSION DeviceExtension)

/*++

Routine Description:

   See if the file may be read.  Start the recall if it is not already started.  Either return OK
   or queue the read request.

Arguments:

    Irp             - Pointer to the read irp
    FileObject      - Pointer to the file object of the file
    DeviceExtension - Device extension for the RsFilter device object


Return Value:

    STATUS_SUCCESS      The read may be passed on down to the file system.
    STATUS_PENDING      The IRP has been queued pending a recall
    Any other status    An error occurred, caller should complete the IRP with this status

Note:

--*/
{
    NTSTATUS               retval = STATUS_FILE_IS_OFFLINE, qRet;
    BOOLEAN                gotLock = FALSE;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    PRP_IRP_QUEUE          readIo;
    PIO_STACK_LOCATION     currentStack ;
    ULONGLONG              filterId;
    LONGLONG               start, size;
    PRP_FILTER_CONTEXT     filterContext;

    PAGED_CODE();

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
    if (filterContext == NULL) {
        //
        // Not found - should not happen
        //
        return(STATUS_SUCCESS);
    }


    try {
        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = entry->fsContext;

        ASSERT(FileObject == entry->fileObj);

        currentStack = IoGetCurrentIrpStackLocation (Irp) ;

        RsAcquireFileContextEntryLockExclusive(context);
        gotLock = TRUE;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead (%x : %x) - State = %u\n", context, entry, context->state));

        //
        // We found the entry - if the recall has not been started then start it now,
        // If it has already been started and we do not have to wait then return OK,
        // otherwise queue the read.

        ObReferenceObject(entry->fileObj);

        switch (context->state) {
        
        case RP_RECALL_COMPLETED: {

                if (context->recallStatus == STATUS_CANCELLED) {
                    //
                    // Previous recall was cancelled by user. Start another recall
                    // now
                    // So fall through deliberately to the NOT_RECALLED_CASE
                    //
                } else {
                    if (NT_SUCCESS(context->recallStatus)) {
                        //
                        // Recall is done
                        //
                        retval = STATUS_SUCCESS;
                    } else {
                        //
                        // Recall is done but it failed. We return the
                        // uniform status value STATUS_FILE_IS_OFFLINE
                        //
                        retval = STATUS_FILE_IS_OFFLINE;
                    }
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    break;
                }
            }

        case RP_RECALL_NOT_RECALLED: {
                //
                // Start the recall here.
                // context Resource acquired
                //
                retval = STATUS_SUCCESS;
                RsAcquireFileObjectEntryLockExclusive(entry);

                readIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);

                if (readIo == NULL) {
                    //
                    // Problem ...
                    DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsFilter: RsCheckRead - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);


                    //
                    // Release the locks
                    //
                    RsReleaseFileObjectEntryLock(entry);
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    //
                    // Complete the read with an error.
                    //
                    retval = STATUS_FILE_IS_OFFLINE;
                    break;
                }

                RtlZeroMemory(readIo, sizeof(RP_IRP_QUEUE));

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queue Irp %x\n", Irp));

                readIo->irp = Irp;
                readIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                readIo->length = currentStack->Parameters.Read.Length;
                readIo->deviceExtension = DeviceExtension;

                ExInterlockedInsertHeadList(&entry->readQueue, (PLIST_ENTRY) readIo, &entry->qLock);


                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - After Q - Read Q: %u  Write Q %u\n",
                                      IsListEmpty(&entry->readQueue),
                                      IsListEmpty(&entry->writeQueue)));


                filterId = context->filterId | entry->filterId;
                start = context->rpData.data.dataStreamStart.QuadPart;
                size =  context->rpData.data.dataStreamSize.QuadPart;
                RsReleaseFileObjectEntryLock(entry);
                //
                // Assume the worst
                //
                retval = STATUS_FILE_IS_OFFLINE;
                //
                // We are going to hold the Irp so set a cancel routing and mark it pending
                //
                context->state = RP_RECALL_STARTED;
                KeResetEvent(&context->recallCompletedEvent);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                //
                // Indicate to FSA we are going to recall it
                //
                qRet = RsQueueRecallOpen(context,
                                         entry,
                                         filterId,
                                         start,
                                         size,
                                         RP_OPEN_FILE);
                if (NT_SUCCESS(qRet)) {

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queueing the recall (%I64x).\n", filterId));
                    qRet = RsQueueRecall(filterId, start, size);

                    if (NT_SUCCESS(qRet)) {
                        //
                        // Now we are ready to set the cancel routine
                        //
                        retval = RsSetCancelRoutine(Irp,
                                                    RsCancelReadRecall) ? STATUS_PENDING : STATUS_CANCELLED;
                    }
                }

                if (!NT_SUCCESS(qRet) || !NT_SUCCESS(retval)) {
                    //
                    // If it failed we need to fail this read and all others waiting on this recall.
                    // Since we unlocked the queue to start the recall we need to lock it again and walk through
                    // it to find all reads or writes that came in since we unlocked it.
                    //
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Failed to queue the recall.\n"));
                    //
                    // Pluck the current IRP out from the queue, that we added just now
                    // It will be completed  by the caller (the cancel routine wasn't set for
                    // this IRP yet, so we can safely remove it)
                    //
                    RsAcquireFileObjectEntryLockExclusive(entry);
                    RsInterlockedRemoveEntryList(&readIo->list,
                                                 &entry->qLock);
                    RsReleaseFileObjectEntryLock(entry);
                    ExFreePool(readIo);

                    RsAcquireFileContextEntryLockExclusive(context);
                    gotLock = TRUE;
                    context->state = RP_RECALL_NOT_RECALLED;
                    //
                    // If we got as far as queuing the recall, then we should not
                    // fail the other IRPs.
                    //
                    if (!NT_SUCCESS(qRet)) {
                        RsFailAllRequests(context, FALSE);
                    }
                    RsReleaseFileContextEntryLock(context);

                    retval = STATUS_FILE_IS_OFFLINE;
                    gotLock = FALSE;
                }
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queued the recall.\n"));
                ObDereferenceObject(entry->fileObj);
                break;
            }

        case RP_RECALL_STARTED: {
                //
                // Let the read complete if the data is available and no writes have been issued..
                // Must check if write is within portion of the file already recalled OR if the file has been recalled in full
                // but the state had not changed yet we let the read go anyway - they may be reading beyond the end of the file.
                //
                if (!(context->flags & RP_FILE_WAS_WRITTEN) &&
                    ((context->currentOffset.QuadPart >=
                      (currentStack->Parameters.Read.ByteOffset.QuadPart + currentStack->Parameters.Read.Length)) ||
                     (context->currentOffset.QuadPart == context->recallSize.QuadPart))) {

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Data for this read is available - let it go (flags = %x).\n",
                                          entry->fileObj->Flags));
                    retval = STATUS_SUCCESS;
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    break;
                }
                //
                // Wait for the recall to complete before allowing any reads
                // Once we get this stable we can try and let reads complete as the
                // data is available.
                //
                // context entry acquired.
                readIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);
                if (readIo == NULL) {
                    //

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckRead - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);

                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    retval = STATUS_FILE_IS_OFFLINE;
                    break;
                }

                RsAcquireFileObjectEntryLockExclusive(entry);
                RtlZeroMemory(readIo, sizeof(RP_IRP_QUEUE));

                //
                // We are going to hold the Irp..
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queue Irp %x\n", Irp));
                readIo->irp = Irp;
                readIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                readIo->length = currentStack->Parameters.Read.Length;
                readIo->deviceExtension = DeviceExtension;
                readIo->flags = 0;
                ExInterlockedInsertHeadList(&entry->readQueue, (PLIST_ENTRY) readIo, &entry->qLock);
                if (RsSetCancelRoutine(Irp,
                                       (PVOID) RsCancelReadRecall)) {
                    retval = STATUS_PENDING;
                    filterId = context->filterId | entry->filterId;
                    qRet = RsQueueRecallOpen(context,
                                             entry,
                                             filterId,
                                             0,0,
                                             RP_RECALL_WAITING);
                } else {
                    RsInterlockedRemoveEntryList(&readIo->list,
                                                 &entry->qLock);
                    retval = STATUS_CANCELLED;
                }


                RsReleaseFileObjectEntryLock(entry);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                break;
            }

        default: {
                //
                // Something strange - Fail the read
                //
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, context->state,
                           AV_MSG_UNEXPECTED_ERROR, NULL, NULL);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                retval = STATUS_FILE_IS_OFFLINE;
                break;
            }
        }

        if (gotLock == TRUE) {
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        }
    }except (RsExceptionFilter(L"RsCheckRead", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


NTSTATUS
RsCheckWrite(IN  PIRP Irp,
             IN  PFILE_OBJECT FileObject,
             IN  PDEVICE_EXTENSION DeviceExtension)
/*++

Routine Description:

   See if the file may be read.  Start the recall if it is not already started.  Either return OK
   or queue the read request.

Arguments:

    Irp             - Pointer to the write irp
    FileObject      - Pointer to the file object of the file
    DeviceExtension - Device extension for the RsFilter device object


Return Value:

    STATUS_SUCCESS      The read may be passed on down to the file system.
    STATUS_PENDING      The IRP has been queued pending a recall
    Any other status    An error occurred, caller should complete the IRP with this status

Note:

--*/
{
    NTSTATUS               retval = STATUS_FILE_IS_OFFLINE, qRet;
    BOOLEAN                gotLock = FALSE;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    PRP_IRP_QUEUE          writeIo;
    PIO_STACK_LOCATION     currentStack ;
    ULONGLONG              filterId;
    LONGLONG               start, size;
    PRP_FILTER_CONTEXT     filterContext;

    PAGED_CODE();

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);

    if (filterContext == NULL) {
        //
        // Not found - should this be STATUS_FILE_IS_OFFLINE?
        //
        return STATUS_SUCCESS;
    }

    try {
        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = entry->fsContext;

        ASSERT(FileObject == entry->fileObj);

        currentStack = IoGetCurrentIrpStackLocation (Irp) ;

        RsAcquireFileContextEntryLockExclusive(context);
        gotLock = TRUE;

        context->flags |= RP_FILE_WAS_WRITTEN;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite (%x : %x) - State = %u\n", context, entry, context->state));

        //
        // We found the entry - if the recall has not been started then start it now,
        // If it has already been started and we do not have to wait then return OK,
        // otherwise queue the read.

        ObReferenceObject(entry->fileObj);

        switch (context->state) {
        
        case RP_RECALL_COMPLETED: {

                if (context->recallStatus == STATUS_CANCELLED) {
                    //
                    // Previous recall was cancelled by user. Start another recall
                    // now
                    // So fall through deliberately to the NOT_RECALLED_CASE
                    //
                } else {
                    if (NT_SUCCESS(context->recallStatus)) {
                        if (!(context->flags & RP_FILE_REPARSE_POINT_DELETED)) {
                            RsReleaseFileContextEntryLock(context);
                            gotLock = FALSE;

                            retval = RsDeleteReparsePoint(context);

                            if (!NT_SUCCESS(retval)) {
                                RsLogError(__LINE__,
                                           AV_MODULE_RPFILFUN,
                                           retval,
                                           AV_MSG_DELETE_REPARSE_POINT_FAILED,
                                           NULL,
                                           NULL);
                            } else {
                                RsAcquireFileContextEntryLockExclusive(context);
                                gotLock = TRUE;
                                context->flags |= RP_FILE_REPARSE_POINT_DELETED;
                                RsReleaseFileContextEntryLock(context);
                                gotLock = FALSE;
                            }
                        } else {
                            RsReleaseFileContextEntryLock(context);
                            gotLock = FALSE;
                        }
                        retval = STATUS_SUCCESS;
                    } else {
                        //
                        // Recall is done but it failed. We return
                        // the uniform status STATUS_FILE_IS_OFFLINE;
                        //
                        RsReleaseFileContextEntryLock(context);
                        gotLock = FALSE;
                        retval = STATUS_FILE_IS_OFFLINE;
                    }
                    ObDereferenceObject(entry->fileObj);
                    break;
                }
            }

        case RP_RECALL_NOT_RECALLED: {
                //
                // Start the recall here.
                // context Resource acquired
                //
                retval = STATUS_SUCCESS;
                qRet = STATUS_SUCCESS;
                RsAcquireFileObjectEntryLockExclusive(entry);

                writeIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);
                if (writeIo == NULL) {
                    //
                    // Problem ...
                    DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsFilter: RsCheckWrite - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);
                    //
                    // Release the locks
                    //
                    RsReleaseFileObjectEntryLock(entry);
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    //
                    // Complete the read with an error.
                    //
                    retval = STATUS_FILE_IS_OFFLINE;
                    break;
                }

                RtlZeroMemory(writeIo, sizeof(RP_IRP_QUEUE));
                //
                // We are going to hold the Irp
                //
                DebugTrace((DPFLTR_RSFILTER_ID, DBG_INFO, "RsFilter: RsCheckWrite - Queue Irp %x\n", Irp));

                writeIo->irp = Irp;
                writeIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                writeIo->length = currentStack->Parameters.Read.Length;
                writeIo->deviceExtension = DeviceExtension;

                ExInterlockedInsertHeadList(&entry->writeQueue, (PLIST_ENTRY) writeIo, &entry->qLock);

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - After Q - Read Q: %u  Write Q %u\n",
                           IsListEmpty(&entry->readQueue),
                           IsListEmpty(&entry->writeQueue)));

                if (RP_IS_NO_RECALL(entry)) {
                    //
                    // Need to indicate to FSA a normal recall will happen
                    //     We have to do this on a write - because the file would
                    // be normally in a no-recall mode till the first write
                    // We don't have this issue with a read - because a recall
                    // would be queued on the read ONLY if the file was explicitly
                    // opened with recall on data access. This would mean that the
                    // recall intent is posted to FSA at create time itself
                    //
                    entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
                    entry->filterId <<= 32;
                    entry->filterId |= RP_TYPE_RECALL;

                    filterId = context->filterId | entry->filterId;
                    start = context->rpData.data.dataStreamStart.QuadPart;
                    size =  context->rpData.data.dataStreamSize.QuadPart;
                } else {
                    //
                    //
                    //
                    filterId = context->filterId | entry->filterId;
                    start = context->rpData.data.dataStreamStart.QuadPart;
                    size =  context->rpData.data.dataStreamSize.QuadPart;
                }
                RsReleaseFileObjectEntryLock(entry);
                //
                // Assume the worst
                //
                retval  = STATUS_FILE_IS_OFFLINE;

                context->state = RP_RECALL_STARTED;
                KeResetEvent(&context->recallCompletedEvent);

                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                //
                // Indicate to FSA we are going to recall it
                //
                qRet = RsQueueRecallOpen(context,
                                         entry,
                                         filterId,
                                         start,
                                         size,
                                         RP_OPEN_FILE);

                if (NT_SUCCESS(qRet)) {

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - Queueing the recall.\n"));

                    qRet = RsQueueRecall(filterId, start, size);

                    if (NT_SUCCESS(qRet)) {
                        //
                        // Now we're ready to set the cancel routine for the IRP
                        //
                        retval = RsSetCancelRoutine(Irp,
                                                    (PVOID) RsCancelWriteRecall) ? STATUS_PENDING : STATUS_CANCELLED;
                    }
                }

                if (!NT_SUCCESS(qRet) || !NT_SUCCESS(retval)) {
                    //
                    // If it failed we need to fail this read and all others waiting on this recall.
                    // Since we unlocked the queue to start the recall we need to lock it again and walk through
                    // it to find all reads or writes that came in since we unlocked it.
                    //
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckWrite - Failed to queue the recall.\n"));

                    //
                    // Pluck the current IRP out from the queue, that we added just now
                    // It will be completed  by the caller
                    //
                    RsAcquireFileObjectEntryLockExclusive(entry);
                    RsInterlockedRemoveEntryList(&writeIo->list,
                                                 &entry->qLock);
                    RsReleaseFileObjectEntryLock(entry);

                    RsAcquireFileContextEntryLockExclusive(context);
                    gotLock = TRUE;
                    context->state = RP_RECALL_NOT_RECALLED;
                    //
                    // If we got as far as queueing the recall, we
                    // should not be failing the other IRPs
                    //
                    if (!NT_SUCCESS(qRet)) {
                        RsFailAllRequests(context, FALSE);
                    }
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    retval = STATUS_FILE_IS_OFFLINE;
                    ExFreePool(writeIo);
                }
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - Queued the recall.\n"));
                ObDereferenceObject(entry->fileObj);
                break;
            }

        case RP_RECALL_STARTED: {
                //
                // Always wait for the recall to complete before allowing any reads
                // Once we get this stable we can try and let reads complete as the
                // data is available.
                //
                // context entry acquired.

                writeIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);
                if (writeIo == NULL) {
                    //

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckWrite - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);


                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    retval = STATUS_FILE_IS_OFFLINE ;
                    break;
                }

                RtlZeroMemory(writeIo, sizeof(RP_IRP_QUEUE));

                RsAcquireFileObjectEntryLockExclusive(entry);
                //
                // We are going to hold the Irp
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - Queue Irp %x\n", Irp));
                writeIo->irp = Irp;
                writeIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                writeIo->length = currentStack->Parameters.Read.Length;
                writeIo->deviceExtension = DeviceExtension;
                writeIo->flags = 0;
                ExInterlockedInsertHeadList(&entry->writeQueue, (PLIST_ENTRY) writeIo, &entry->qLock);
                if (RsSetCancelRoutine(Irp,
                                       (PVOID) RsCancelWriteRecall)) {
                    retval = STATUS_PENDING;
                    filterId = context->filterId | entry->filterId;
                    qRet = RsQueueRecallOpen(context,
                                             entry,
                                             filterId,
                                             0,0,
                                             RP_RECALL_WAITING);
                } else {
                    RsInterlockedRemoveEntryList(&writeIo->list,
                                                 &entry->qLock);
                    retval = STATUS_CANCELLED;
                }
                RsReleaseFileObjectEntryLock(entry);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                break;
            }

        default: {
                //
                // Something strange - Fail the write
                //
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, context->state,
                           AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                retval = STATUS_FILE_IS_OFFLINE;
                break;
            }
        }

        if (gotLock == TRUE) {
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        }

    }except (RsExceptionFilter(L"RsCheckWrite", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


BOOLEAN
RsIsFileObj(IN  PFILE_OBJECT FileObj,
            IN  BOOLEAN      ReturnContextData,
            OUT PRP_DATA *RpData,
            OUT POBJECT_NAME_INFORMATION *Str,
            OUT LONGLONG *FileId,
            OUT LONGLONG *ObjIdHi,
            OUT LONGLONG *ObjIdLo,
            OUT ULONG *Options,
            OUT ULONGLONG *FilterId,
            OUT USN       *Usn)
/*++

Routine Description:

    Determine if a file object is on the queue,
    and return context data if required


Arguments:

   FileObj           - Pointer to the file object being tested
   ReturnContextData - If TRUE, context data from the filter context is returned
                       via the next few parameters
   RpData            - If not NULL, this will be filled with a pointer to the reparse point data
   (so on - each of the other arguments, if non null, will be filled with the relevant data)
   .....
   ......

Return Value:

   TRUE -   file object is managed by HSM and found in the queue.
   FALSE  othersise


--*/
{
    BOOLEAN                retval;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                gotLock = FALSE;

    try {

        filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObj), FsDeviceObject, FileObj);
        if (filterContext == NULL) {
            //
            // Not found
            return(FALSE);
        }

        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = entry->fsContext;

        if (context->fileObjectToWrite == FileObj) {
            //
            // Do not look at writes for this file object
            //
            return(FALSE);
        }

        retval = TRUE;

        if (ReturnContextData) {
            RsAcquireFileContextEntryLockShared(context);
            RsAcquireFileObjectEntryLockShared(entry);
            gotLock = TRUE;

            if (RpData) {
                *RpData = &context->rpData;
            }

            if (Str != NULL) {
                *Str = context->uniName;
            }
            if (FileId != NULL) {
                *FileId = entry->fileId;
            }
            if (ObjIdLo != NULL) {
                *ObjIdLo = entry->objIdLo;
            }

            if (ObjIdHi != NULL) {
                *ObjIdHi = entry->objIdHi;
            }

            if (Options != NULL) {
                *Options = entry->openOptions;
            }

            if (FilterId != NULL) {
                *FilterId = context->filterId;
            }

            if (Usn != NULL) {
                *Usn = context->usn;
            }

            RsReleaseFileContextEntryLock(context);
            RsReleaseFileObjectEntryLock(entry);
            gotLock = FALSE;
        }
    }except (RsExceptionFilter(L"RsIsFileObj", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
            RsReleaseFileObjectEntryLock(entry);
        }
        retval = FALSE;
    }


    return(retval);
}


NTSTATUS
RsQueueRecall(IN ULONGLONG FilterId,
              IN ULONGLONG RecallStart,
              IN ULONGLONG RecallSize)
/*++

Routine Description:

   This function starts a recall for the specified offset and length

Arguments:
   filterID
   offset and length

Return Value:
  0 if queued ok
  non-zero otherwise



--*/
{
    ULONG                   retval;
    RP_MSG                  *msg;
    PIRP                    ioIrp;
    PIO_STACK_LOCATION      irpSp;

    PAGED_CODE();

    try {
        //
        // If the FSA is not running then fail right away.
        //
        if (FALSE == RsAllowRecalls) {
            return(STATUS_FILE_IS_OFFLINE);
        }
        //
        // Get a free IOCTL
        //
        ioIrp = RsGetFsaRequest();

        if (NULL != ioIrp) {

            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = RP_RECALL_FILE;
                msg->msg.rReq.filterId = FilterId;
                msg->msg.rReq.offset = RecallStart;
                msg->msg.rReq.length = RecallSize;
                msg->msg.rReq.threadId = HandleToUlong(PsGetCurrentThreadId());
            }

            // Complete a device IOCTL to let the WIN32 code know we have
            // one ready to go.
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            DebugTrace((DPFLTR_RSFILTER_ID, DBG_INFO, "RsFilter: RsQueueRecall - complete FSA IOCTL.\n"));

            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
    }except (RsExceptionFilter(L"RsQueueRecall", GetExceptionInformation())) {
        retval = STATUS_UNEXPECTED_IO_ERROR;
    }
    return(retval);
}


NTSTATUS
RsQueueNoRecall(IN PFILE_OBJECT FileObject,
                IN PIRP         Irp,
                IN ULONGLONG    RecallStart,
                IN ULONGLONG    RecallSize,
                IN ULONG        BufferOffset,
                IN ULONG        BufferLength,
                IN PRP_FILE_BUF CacheBuffer OPTIONAL,
                IN PVOID        UserBuffer)
/*++

Routine Description:

   This function starts a recall for the specified offset and length

Arguments:

   FileObject   - Pointer to file object
   Irp          - IRP associated with the recall
   RecallStart  - This is the start offset of the actuall recall in the file
   RecallSize   - Length of bytes needed to be recalled
   BufferOffset -  This is the offset at which the caller actually needs data
                   to be copied into the user buffer. This is >= the RecallStart
                   offset.
   BufferLength - Length of data the user actually needs. This is <= RecallSize
   CacheBuffer  - If present, this is the cache buffer associated with the recall
                  (into which the recall data will be copied )
   UserBuffer   - UserBuffer for the data

Return Value:
  0 if queued ok
  non-zero otherwise
--*/
{
    RP_MSG                   *msg;
    PIRP                     ioIrp;
    PIO_STACK_LOCATION       irpSp;
    PRP_IRP_QUEUE            readIo;
    ULONGLONG                readId;
    LARGE_INTEGER            combinedId;
    PRP_FILTER_CONTEXT       filterContext;
    PRP_FILE_OBJ             entry;
    PRP_FILE_CONTEXT         context;
    NTSTATUS                 retval;

    PAGED_CODE();

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
    if (filterContext == NULL) {
        //
        // Not found
        return(STATUS_NOT_FOUND);
    }

    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;

    try {
        //
        // If the FSA is not running then fail right away.
        //
        if (FALSE == RsAllowRecalls) {
            return(STATUS_FILE_IS_OFFLINE);
        }
        readId = InterlockedIncrement((PLONG) &RsNoRecallReadId);
        readId &= RP_READ_MASK;

        //
        // We have to queue a fake open to get the filter ID correct in the FSA
        // then we queue the recall for the read we need.
        //

        combinedId.QuadPart = context->filterId;
        combinedId.HighPart |= (ULONG) readId;

        if ((retval = RsQueueNoRecallOpen(entry,
                                          combinedId.QuadPart,
                                          RecallStart,
                                          RecallSize)) != STATUS_SUCCESS) {
            return(retval);
        }

        readIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);

        if (readIo == NULL) {
            //
            // Problem ...
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsQueueNoRecall - No memory!\n"));

            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                       AV_MSG_MEMORY, NULL, NULL);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        //
        // Get a free IOCTL to queue the recall
        //
        ioIrp = RsGetFsaRequest();

        if (ioIrp == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(readIo, sizeof(RP_IRP_QUEUE));

        readIo->readId = readId;
        readIo->irp = Irp;
        readIo->irp->IoStatus.Information = 0;
        readIo->cacheBuffer = CacheBuffer;
        readIo->userBuffer =  UserBuffer;
        readIo->offset = BufferOffset;
        readIo->length = BufferLength;
        readIo->recallOffset = RecallStart;
        readIo->recallLength = RecallSize;
        readIo->flags  |= RP_IRP_NO_RECALL;

        ExInterlockedInsertHeadList(&entry->readQueue,
                                    (PLIST_ENTRY) readIo,
                                    &entry->qLock);

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsQueueNoRecall - Irp %x was queued.\n", readIo->irp));

        msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
        msg->inout.command = RP_RECALL_FILE;
        msg->msg.rReq.filterId = combinedId.QuadPart;
        msg->msg.rReq.offset = RecallStart;
        msg->msg.rReq.length = RecallSize;
        msg->msg.rReq.threadId = HandleToUlong(PsGetCurrentThreadId());
        //
        // Complete a device IOCTL to let the WIN32 code know we have
        // one ready to go.
        //
        // We're going to hold this IRP: set the cancel routine here
        //
        if (!RsSetCancelRoutine(Irp, (PVOID) RsCancelReadRecall)) {
            RsInterlockedRemoveEntryList(&readIo->list,
                                         &entry->qLock);
            //
            // Add back the now unused FSA request to the queue
            //
            RsAddIo(ioIrp);
            //
            // This was cancelled
            //
            retval =  STATUS_CANCELLED;
        } else {
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_PENDING;
        }
    }except (RsExceptionFilter(L"RsQueueNoRecall", GetExceptionInformation())) {
        //
        // Something bad happened - just log an error and return
        //
        retval = STATUS_UNEXPECTED_IO_ERROR;
    }

    return(retval);
}


NTSTATUS
RsQueueNoRecallOpen(IN PRP_FILE_OBJ Entry,
                    IN ULONGLONG    FilterId,
                    IN ULONGLONG    Offset,
                    IN ULONGLONG    Size)
/*++

Routine Description:

   Queue a request for a no-recall recall

Arguments:
   file object entry (locked)
   filterID
   offset and length

Return Value:

   Status

--*/
{
    NTSTATUS                 retval;
    RP_MSG                   *msg;
    PIRP                     ioIrp;
    PIO_STACK_LOCATION       irpSp;
    PRP_FILE_CONTEXT         context;

    PAGED_CODE();

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueNoRecallOpen.\n"));

    ioIrp = RsGetFsaRequest();

    if (NULL != ioIrp) {
        context = Entry->fsContext;
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueNoRecallOpen - context %x.\n", context));
        RsAcquireFileContextEntryLockShared(context);
        RsAcquireFileObjectEntryLockExclusive(Entry);

        if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
            msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
            msg->inout.command = RP_OPEN_FILE;
            if (context->uniName != NULL) {
                msg->msg.oReq.nameLen = context->uniName->Name.Length + sizeof(WCHAR);  // Account for the NULL
            } else {
                msg->msg.oReq.nameLen = 0;
            }
            msg->msg.oReq.filterId = FilterId;
            msg->msg.oReq.options = Entry->openOptions;
            msg->msg.oReq.objIdHi = Entry->objIdHi;
            msg->msg.oReq.objIdLo = Entry->objIdLo;
            msg->msg.oReq.offset.QuadPart = Offset;
            msg->msg.oReq.size.QuadPart = Size;
            msg->msg.oReq.userInfoLen  = Entry->userSecurityInfo->userInfoLen;
            msg->msg.oReq.userInstance = Entry->userSecurityInfo->userInstance;
            msg->msg.oReq.userAuthentication = Entry->userSecurityInfo->userAuthentication;
            msg->msg.oReq.tokenSourceId = Entry->userSecurityInfo->tokenSourceId;
            msg->msg.oReq.isAdmin = (Entry->flags & RP_OPEN_BY_ADMIN);
            msg->msg.oReq.localProc =(Entry->flags & RP_OPEN_LOCAL);

            msg->msg.oReq.serial = context->serial;

            memcpy(&msg->msg.oReq.eaData, &context->rpData, sizeof(RP_DATA));
            //
            // Complete a device IOCTL to let the WIN32 code know we have
            // one ready to go.
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueNoRecallOpen queue open for ID %I64x.\n", FilterId));
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;

        } else {
            ioIrp->IoStatus.Status = STATUS_INVALID_USER_BUFFER;
            ioIrp->IoStatus.Information = 0;
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter:   RsQueueNoRecallOpen IO request had invalid buffer - %p.\n", ioIrp->AssociatedIrp.SystemBuffer));
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0 ,
                       AV_MSG_UNEXPECTED_ERROR, NULL, NULL);
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_INVALID_USER_BUFFER;
        }
        RsReleaseFileContextEntryLock(context);
        RsReleaseFileObjectEntryLock(Entry);
    } else {
        retval = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(retval);
}


NTSTATUS
RsQueueRecallOpen(IN PRP_FILE_CONTEXT Context,
                  IN PRP_FILE_OBJ Entry,
                  IN ULONGLONG    FilterId,
                  IN ULONGLONG    Offset,
                  IN ULONGLONG    Size,
                  IN ULONG        Command)
/*++

Routine Description:

   Queue a request for a recall

Arguments:
   file object entry (locked)
   filterID
   offset and length

Return Value:
  0 if queued ok
  non-zero otherwise

--*/
{
    PIRP                      ioIrp;
    PRP_MSG                   msg;
    NTSTATUS                  retval;
    PIO_STACK_LOCATION        irpSp;

    PAGED_CODE();

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueRecallOpen.\n"));

    //
    // If the request is to send a recall waiting notification and one has already 
    // been sent for this recall instance then there is no need to send another.
    //
    if (Entry->flags & RP_NOTIFICATION_SENT) {

        retval = STATUS_SUCCESS;

    } else {

        ioIrp = RsGetFsaRequest();

        if (NULL != ioIrp) {
            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = Command;
                ASSERT (Context->uniName != NULL);
                msg->msg.oReq.nameLen = Context->uniName->Name.Length + sizeof(WCHAR);  // Account for a NULL
                msg->msg.oReq.filterId = FilterId;
                msg->msg.oReq.options = Entry->openOptions;
                msg->msg.oReq.fileId = Context->fileId;
                msg->msg.oReq.objIdHi = Entry->objIdHi;
                msg->msg.oReq.objIdLo = Entry->objIdLo;
                msg->msg.oReq.offset.QuadPart = Offset;
                msg->msg.oReq.size.QuadPart = Size;
                msg->msg.oReq.serial = Context->serial;

                memcpy(&msg->msg.oReq.eaData, &Context->rpData, sizeof(RP_DATA));
                //
                // Get user info 
                //
                msg->msg.oReq.userInfoLen  = Entry->userSecurityInfo->userInfoLen;
                msg->msg.oReq.userInstance = Entry->userSecurityInfo->userInstance;
                msg->msg.oReq.userAuthentication = Entry->userSecurityInfo->userAuthentication;
                msg->msg.oReq.tokenSourceId = Entry->userSecurityInfo->tokenSourceId;
                msg->msg.oReq.isAdmin = (Entry->flags & RP_OPEN_BY_ADMIN);
                msg->msg.oReq.localProc =(Entry->flags & RP_OPEN_LOCAL);

                RtlCopyMemory(msg->msg.oReq.tokenSource, 
                              Entry->userSecurityInfo->tokenSource,
                              sizeof(Entry->userSecurityInfo->tokenSource));

                //
                // Complete a device IOCTL to let the WIN32 code know we have
                // one ready to go.
                //
                irpSp = IoGetCurrentIrpStackLocation(ioIrp);
                ioIrp->IoStatus.Status = STATUS_SUCCESS;
                ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueRecallOpen queue open for ID %I64x.\n", FilterId));
                IoCompleteRequest(ioIrp, IO_NO_INCREMENT);

		Entry->flags |= RP_NOTIFICATION_SENT;


                retval = STATUS_SUCCESS;
            } else {
                ioIrp->IoStatus.Status = STATUS_INVALID_USER_BUFFER;
                ioIrp->IoStatus.Information = 0;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter:   RsQueueRecallOpen IO request had invalid buffer - %p.\n", ioIrp->AssociatedIrp.SystemBuffer));
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0 ,
                           AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

                IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
                retval = STATUS_INVALID_USER_BUFFER;
            }
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return retval;
}


NTSTATUS
RsQueueCancel(IN ULONGLONG FilterId)
/*++

Routine Description:

   Queue a recall cancelled request to the Fsa

Arguments:
   filter ID

Return Value:
  0 if queued ok
  non-zero otherwise


--*/
{
    NTSTATUS              retval;
    RP_MSG                *msg;
    BOOLEAN               gotLock = FALSE;
    PIRP                  ioIrp;
    PIO_STACK_LOCATION    irpSp;

    PAGED_CODE();

    try {
        //
        // Need to wait for IO entry as long as there are no IOCTLS or until we time out
        //
        ioIrp = RsGetFsaRequest();

        if (NULL != ioIrp) {
            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = RP_CANCEL_RECALL;
                msg->msg.cReq.filterId = FilterId;
            }
            //
            // Complete a device IOCTL to let the WIN32 code know we have
            // one cancelled
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:  Notify Fsa of cancelled recall %I64x\n", FilterId));
    }except (RsExceptionFilter(L"RsQueueCancel", GetExceptionInformation())) {
    }
    return(retval);
}


NTSTATUS
RsPreserveDates(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

    Preserve the last modified date for this file object

Arguments:

    File object list entry

Return Value:


Note:


--*/
{
    NTSTATUS                    retval = STATUS_SUCCESS;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp;
    FILE_BASIC_INFORMATION      dateInfo;
    PDEVICE_OBJECT              deviceObject;

    PAGED_CODE();

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Build Irp for Set file info.\n"));
        //
        // First get the file info so we have the attributes
        //
        deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);
        irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

        if (irp) {
            irp->UserEvent = &event;
            irp->UserIosb = &Iosb;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
            irp->RequestorMode = KernelMode;
            irp->Flags |= IRP_SYNCHRONOUS_API;
            //
            // Initialize the event
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            //
            // Set up the I/O stack location.
            //

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
            irpSp->FileObject = Context->fileObjectToWrite;
            irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
            irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
            irp->AssociatedIrp.SystemBuffer = &dateInfo;

            //
            // Set the completion routine.
            //
            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            //
            // Send it to the FSD
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Call driver to get date info\n"));
            Iosb.Status = 0;

            retval = IoCallDriver(deviceObject,
                                  irp);

            if (retval == STATUS_PENDING) {
                retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }

            retval = Iosb.Status;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Query returns %x.\n", retval));
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
        }

        if (retval == STATUS_SUCCESS) {
            irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
            if (irp) {
                irp->UserEvent = &event;
                irp->UserIosb = &Iosb;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();
                irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
                irp->RequestorMode = KernelMode;
                irp->Flags |= IRP_SYNCHRONOUS_API;
                //
                // Initialize the event
                //
                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                //
                // Set up the I/O stack location.
                //
                dateInfo.LastWriteTime.QuadPart = -1;
                dateInfo.ChangeTime.QuadPart = -1;

                irpSp = IoGetNextIrpStackLocation(irp);
                irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
                irpSp->FileObject = Context->fileObjectToWrite;
                irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
                irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
                irp->AssociatedIrp.SystemBuffer = &dateInfo;

                //
                // Set the completion routine.
                //
                IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

                //
                // Send it to the FSD
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Call driver to set dates to -1.\n"));
                Iosb.Status = 0;

                retval = IoCallDriver(deviceObject,
                                      irp);

                if (retval == STATUS_PENDING) {
                    retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                }

                retval = Iosb.Status;

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Set dates returns %x.\n", retval));

                if (!NT_SUCCESS(retval)) {
                    //
                    // Log an error
                    //
                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, retval,
                               AV_MSG_PRESERVE_DATE_FAILED, NULL, NULL);
                }


            } else {
                retval = STATUS_INSUFFICIENT_RESOURCES;
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                           AV_MSG_MEMORY, irpSp, NULL);
            }
        }
    }except (RsExceptionFilter(L"RsPreserveDates", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Returning %x.\n", retval));
    return(retval);
}


NTSTATUS
RsDoWrite( IN PDEVICE_OBJECT   DeviceObject,
           IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   Partial data for a recall has been received - write it out to the file.

Arguments:

   DeviceObject - Filter device object
   Context      - File context entry


Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    KEVENT              event;
    PIO_STACK_LOCATION  irpSp;
    IO_STATUS_BLOCK     Iosb;
    PIRP                irp;
    PDEVICE_EXTENSION   deviceExtension;
    LARGE_INTEGER       fileOffset;

    PAGED_CODE();

    try {
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite Writing to file (%u bytes at offset %I64u.\n",
                              Context->nextWriteSize, Context->currentOffset.QuadPart));

        //
        //  Write the data back to the file
        //

        fileOffset.QuadPart = Context->currentOffset.QuadPart;

        irp = IoBuildAsynchronousFsdRequest(
                                           IRP_MJ_WRITE,
                                           IoGetRelatedDeviceObject(Context->fileObjectToWrite),
                                           (PVOID) Context->nextWriteBuffer,
                                           Context->nextWriteSize,
                                           &fileOffset,
                                           &Iosb);

        if (irp) {
            irp->Flags |= IRP_NOCACHE  | IRP_SYNCHRONOUS_API;
            irpSp = IoGetNextIrpStackLocation(irp);

            irpSp->FileObject = Context->fileObjectToWrite;

            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            // Initialize the event on which we'll wait for the write to complete.     //
            KeInitializeEvent(&event, NotificationEvent, FALSE);    //

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Calling driver for Irp %x\n", irp));
            retval = IoCallDriver(IoGetRelatedDeviceObject(Context->fileObjectToWrite),
                                  irp);
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Call driver returned %x\n", retval));

            if (retval == STATUS_PENDING) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Wait for event.\n"));
                retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

                retval = Iosb.Status;
            }
        }

        if (!NT_SUCCESS(retval)) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Failed to write data - %x\n", retval));
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, retval,
                       AV_MSG_WRITE_FAILED, NULL, NULL);
        } else {
            //
            // Update the file object list with recall status.
            // Complete any reads that are ready to go.
            //
            Context->currentOffset.QuadPart += Context->nextWriteSize;
        }

    }except (RsExceptionFilter(L"RsDoWrite", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}



PRP_FILE_CONTEXT
RsAcquireFileContext(IN ULONGLONG FilterId,
                     IN BOOLEAN   Exclusive)
/*++

Routine Description:

   Acquire exclusive access to the file object entry

Arguments:
   filterID

Return Value:
  Pointer to the file context entry (locked exclusive) or NULL

--*/
{
    BOOLEAN          gotLock = FALSE, done;
    ULONGLONG        combinedId;
    PRP_FILE_CONTEXT entry;

    PAGED_CODE();

    try {

        RsAcquireFileContextQueueLock();
        gotLock = TRUE;
        combinedId = (FilterId & RP_CONTEXT_MASK);

        if (TRUE == IsListEmpty(&RsFileContextQHead)) {
            RsReleaseFileContextQueueLock();   // Something strange
            gotLock = FALSE;
            return(NULL) ;
        }

        entry = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                  RP_FILE_CONTEXT,
                                  list);
        done = FALSE;
        while (entry != CONTAINING_RECORD(&RsFileContextQHead,
                                          RP_FILE_CONTEXT,
                                          list)) {
            if (entry->filterId == combinedId) {
                //
                // Found our file context entry
                //
                done = TRUE;
                break;
            }
            entry = CONTAINING_RECORD(entry->list.Flink,
                                      RP_FILE_CONTEXT,
                                      list
                                     );
        }

        if (done) {
            InterlockedIncrement((PLONG) &entry->refCount);
        }

        RsReleaseFileContextQueueLock();
        gotLock = FALSE;
        if (done) {
            //
            // Acquire the entry exclusively
            //
            if (Exclusive) {
                RsAcquireFileContextEntryLockExclusive(entry);
            } else {
                RsAcquireFileContextEntryLockShared(entry);
            }
        } else {
            entry = NULL;
        }
    }except (RsExceptionFilter(L"RsAcquireFileContext", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
        entry = NULL;
    }

    return(entry);
}



NTSTATUS
RsPartialData(IN  PDEVICE_OBJECT DeviceObject,
              IN  ULONGLONG FilterId,
              IN  NTSTATUS Status,
              IN  CHAR *Buffer,
              IN  ULONG BufLen,
              IN  ULONGLONG BuffOffset)
/*++

Routine Description:

   Partial data for a recall on read has been received - fill in the read buffer or write the
   data out to the file, depending on the type of recall.

Arguments:

    DeviceObject - Filter device object
    FilterId   - The ID assigned when this request was added to the queue
    Status     - The status to complete the Irp with (if applicable).
    Buffer     - Buffer containing no-recall data
    BufLen     - Amount of data recalled in this transfer (length of Buffer)
    BuffOffset - If this is a RECALL, absolute file offset this transfer corresponds to
                 If this is a NO_RECALL, the offset within the original requested
                 block of data, that this buffer corresponds to

Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    PRP_FILE_CONTEXT    context;
    PRP_FILE_OBJ        entry;
    NTSTATUS            retval = STATUS_SUCCESS;
    KIRQL               rirqL;
    PRP_IRP_QUEUE       readIo;
    BOOLEAN             done, found;
    LARGE_INTEGER       combinedId;
    KAPC_STATE          apcState;
    BOOLEAN             gotLock = FALSE;

    UNREFERENCED_PARAMETER(Status);

    try {
        context = RsAcquireFileContext(FilterId, TRUE);

        if (NULL == context) {
            return(STATUS_INVALID_PARAMETER);
        }

        gotLock = TRUE;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPartialData - Context = %x buffer = %x\n",
                              context,
                              Buffer));

        combinedId.QuadPart = FilterId;

        //
        // If a normal recall then write the data to the file.
        //
        if (combinedId.QuadPart & RP_TYPE_RECALL) {
            //
            // Normal recall - write the data to the file
            //
            retval = RsPartialWrite(DeviceObject,
                                    context,
                                    Buffer,
                                    BufLen,
                                    BuffOffset);
            //
            // If the file has been fully recalled we can change the file state to pre-migrated.
            // We do this now rather than waiting for the recall completion message because of a race condition
            // with our regression test code.  When the last read is completed the test code closes the file and checks the state
            // and verifies that it is pre-migrated.  In some cases this happens before we get the recall completion message
            // and update the state of the file.
            //

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPartialData - After write - retval = %x curent = %I64u end = %I64u\n",
                                  retval,
                                  context->currentOffset.QuadPart,
                                  context->rpData.data.dataStreamSize.QuadPart));

            if ( (NT_SUCCESS(retval)) && (context->currentOffset.QuadPart == context->rpData.data.dataStreamSize.QuadPart)) {

                retval = RsSetPremigratedState(context);

                if (NT_SUCCESS(retval)) {
                    context->state = RP_RECALL_COMPLETED;
                    context->recallStatus = STATUS_SUCCESS;
                } else {
                    //
                    // Something went wrong in setting the file to premigrated
                    // Let's clean up
                    //
                    context->state = RP_RECALL_NOT_RECALLED;
                    context->recallStatus = retval;
                    RsTruncateFile(context);
                }
            }

            //
            // Complete whatever reads we can
            //
            if (NT_SUCCESS(retval)) {
                RsCompleteReads(context);
            }
            RsReleaseFileContext(context);
            gotLock = FALSE;
        } else {
            //
            // Find the read that this data is for ...
            //
            done = FALSE;
            //
            // Lock the file object queue
            //
            entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                      RP_FILE_OBJ,
                                      list);

            while ((!done) && (entry != CONTAINING_RECORD(&context->fileObjects,
                                                          RP_FILE_OBJ,
                                                          list))) {
                if (RP_IS_NO_RECALL(entry) && (!IsListEmpty(&entry->readQueue))) {
                    //
                    // Look at the reads to see if one has the matching ID
                    //
                    //
                    found = FALSE;
                    ExAcquireSpinLock(&entry->qLock, &rirqL);
                    readIo =  CONTAINING_RECORD(entry->readQueue.Flink,
                                                RP_IRP_QUEUE,
                                                list);
                    while ((readIo != CONTAINING_RECORD(&entry->readQueue,
                                                        RP_IRP_QUEUE,
                                                        list)) && (FALSE == found)) {
                        if (readIo->readId == (combinedId.HighPart & RP_READ_MASK)) {
                            //
                            // Found our read entry
                            found = TRUE;
                            //
                            // At this point the IRP will become non-cancellable
                            // The FSA does fetch the data for the entire request of the IRP
                            // so the RECALL_COMPLETE message from the FSA is going to arrive
                            // pretty soon. Since the i/o is essentially complete, making the
                            // IRP non-cancellable from this point is not bad
                            //
                            if (!RsClearCancelRoutine(readIo->irp)) {
                                //
                                // Yes we found the entry - however it's being cancelled
                                // Let the cancel handle it
                                //
                                readIo = NULL;
                            }
                        } else {
                            readIo = CONTAINING_RECORD(readIo->list.Flink,
                                                       RP_IRP_QUEUE,
                                                       list);
                        }
                    }
                    ExReleaseSpinLock(&entry->qLock, rirqL);

                    if (found) {
                        done = TRUE;
                        break;
                    }
                }
                //
                // Move on to next file object
                //
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_OBJ,
                                          list
                                         );
            }


            if (!found) {
                //
                // ERROR - read was not found
                //
                RsReleaseFileContext(context);
                gotLock = FALSE;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsPartialData - Read Irp not found!\n"));
                return(STATUS_INVALID_USER_BUFFER);
            }
            //
            // Note we only use the low part because reads are limited in size
            //

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Partial data of %u bytes at offset %I64u\n",
                                  BufLen, BuffOffset));
            //
            // Check if the request was cancelled
            //
            if (readIo == NULL) {
                RsReleaseFileContext(context);
                gotLock = FALSE;
                return STATUS_CANCELLED;
            }

            if (readIo->userBuffer == NULL) {
                //
                // Now comes the slightly risky part of this operation. Now that the
                // MDL has been allocated, it is IMPERATIVE that the buffer be probed
                // and locked so that when the buffer copy thread runs, it does not
                // have to be concerned with touching this memory at a raised IRQL.
                //
                // It is safe to stick the MDL in the Irp->MdlAddress as the file
                // systems look at that field before attempting to probe and lock
                // the users buffer themselves. If they see the Mdl, they will just
                // use it instead.
                //
                // CRITICAL CRITICAL CRITICAL CRITICAL CRITICAL CRITICAL CRITICAL
                //
                // This MUST take place within a try except handler, so that if something
                // should happen to the user buffer before the driver got to this point,
                // a graceful failure can occur. Otherwise the system could bug check.

                try {
                    MmProbeAndLockProcessPages (readIo->irp->MdlAddress,
                                                IoGetRequestorProcess(readIo->irp),
                                                readIo->irp->RequestorMode,
                                                //
                                                // Modifying the buffer
                                                //
                                                IoModifyAccess);      

                }except (EXCEPTION_EXECUTE_HANDLER) {

                    //
                    // Something serious went wrong. Free the Mdl, and complete this
                    // Irp with some meaningful sort of error.
                    //

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsPartialData unable to lock read buffer\n"));
                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                               AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
                    retval = STATUS_INVALID_USER_BUFFER;

                }
                //
                // Everything that needs to be done has been done at this point.
                // Therefore, just get the data we need and return it in the callers buffer.
                //
                //
                // Get the system address for the MDL which represents the users buffer.
                //

                if (STATUS_SUCCESS == retval) {
                    readIo->userBuffer = MmGetSystemAddressForMdlSafe(readIo->irp->MdlAddress,
                                                                      NormalPagePriority) ;
                    if (readIo->userBuffer == NULL) {
                        retval = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

            }

            //
            // See if we need to copy this data to the user buffer
            // i.e. check if there is an overlap between the data that the
            // user requested and the data that is brought in
            //
            if (readIo->userBuffer &&
                ((BuffOffset + BufLen) >  readIo->offset) &&
                (BuffOffset  <=  (readIo->offset + readIo->length - 1))) {
                ULONGLONG userBeg, userEnd;
                ULONGLONG recallBeg, recallEnd;
                ULONGLONG targetOffset, sourceOffset;
                ULONGLONG targetLength;
                //
                // There are 2 possibilities here for the overlap
                //
                userBeg   = readIo->offset;
                userEnd   = readIo->offset + readIo->length - 1;
                recallBeg = BuffOffset;
                recallEnd = BuffOffset + BufLen - 1 ;

                if (recallBeg > userBeg) {
                    //
                    //
                    // In the following picture, CacheXXXX denotes the cache buffer's
                    // aligned begin and end offsets -  which is what the original recall request is for.
                    // UserXXXX denotes the offset within this cache buffer (0-based) that
                    // we need to copy the data to (target offsets)
                    // RecallXXXX is the offsets within this cache buffer (0-based) that has been
                    // currently recalled, which are the source offsets for copying the data from
                    // 0                                                RspCacheBlockSize-1
                    // CacheBufferBegin                               CacheBufferEnd
                    // ==============================================================
                    //          TargetOffset = RecallBegin-UserBegin
                    //     UserBegin           UserEnd
                    //     ============================
                    //          RecallBegin                   RecallEnd
                    //          ==================================
                    //          SourceOffset=0
                    // In this case, we begin copying at offset RecallBegin and copy till UserEnd or
                    // RecallEnd, whichever occurs earlier
                    //
                    //
                    // target offset is the offset within the user buffer that copying begins
                    // source offset is the offset within the recalled data buffer that copying begins
                    // target length is the length of the copy
                    //
                    targetOffset = (recallBeg - userBeg);
                    sourceOffset = 0;
                    targetLength = MIN(recallEnd, userEnd) - recallBeg + 1;
                } else {
                    //
                    // 0                                               RspCacheBlockSize-1
                    // CacheBufferBegin                               CacheBufferEnd
                    // ==============================================================
                    //              TargetOffset = 0
                    //              UserBegin                        UserEnd
                    //              =====================================
                    //    RecallBegin                   RecallEnD
                    //    ==================================
                    //             SourceOffset = (UserBegin-RecallBegin)
                    // In this case, we begin copying at offset UserBegin and copy till UserEnd
                    // or RecallEnd, whichever occurs earlier
                    //
                    targetOffset = 0;
                    sourceOffset = (userBeg - recallBeg);
                    targetLength = MIN(recallEnd, userEnd) - userBeg + 1;
                }

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Copying from %X to %X length %X bytes, current irql %X\n",
                                      Buffer+sourceOffset, ((CCHAR *) readIo->userBuffer)+targetOffset,
                                      targetLength, KeGetCurrentIrql()));
                RtlCopyMemory(((CHAR *) readIo->userBuffer) + targetOffset,
                              Buffer+sourceOffset,
                              (ULONG) targetLength);

                readIo->irp->IoStatus.Information += (ULONG) targetLength;
            }

            //
            // Call the no recall cache manager to finish with the buffer
            //
            if (readIo->cacheBuffer) {
                RsCacheFsaPartialData(readIo,
                                      (PUCHAR) Buffer,
                                      BuffOffset,
                                      BufLen,
                                      retval);
            }
            //
            // At this point make the IRP cancellable again..
            //
            if (!RsSetCancelRoutine(readIo->irp,
                                    RsCancelReadRecall)) {
                //
                // It is attempted to be cancelled..So be it.
                //
                retval = STATUS_CANCELLED;

                RsCompleteRecall(DeviceObject,
                                 FilterId,
                                 retval,
                                 0,
                                 FALSE);
            }
            RsReleaseFileContext(context);
            gotLock = FALSE;
        }

    }except (RsExceptionFilter(L"RsPartialData", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContext(context);
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }
    return(retval);
}


NTSTATUS
RsPartialWrite(IN  PDEVICE_OBJECT   DeviceObject,
               IN  PRP_FILE_CONTEXT Context,
               IN  CHAR *Buffer,
               IN  ULONG BufLen,
               IN  ULONGLONG Offset)
/*++

Routine Description:

   Partial data for a recall has been received - write it out to the file.
   NOTE: The file context entry lock is held by caller  when calling this
   routine

Arguments:

   DeviceObject - Filter device object
   Context      - File context entry
   Buffer       - Buffer with the data
   BufLen       - Length of the buffer
   Offset       - Offset into the file

Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;

    PAGED_CODE();

    try {
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPartialWrite - Writing to file (%u bytes at offset %I64u.\n",
                              BufLen, Offset));

        //
        //  If the recall was cancelled or some other kind of error ocurred we need to fail any more writes we may receive.
        //
        if (Context->state == RP_RECALL_COMPLETED) {
            return(Context->recallStatus);
        }

        if (Context->createSectionLock) {
            return STATUS_FILE_IS_OFFLINE;     
        }

        //
        //  Write the data back to the file
        //
        //
        // Open the target file if it is not already opened..
        //
        RsReleaseFileContextEntryLock(Context);

        if (Context->handle == 0) {
            retval = RsOpenTarget(Context,
                                  0,
                                  GENERIC_READ | GENERIC_WRITE,
                                  &Context->handle,
                                  &Context->fileObjectToWrite);
            //
            // Context is referenced if the open was successful
            //
            if (NT_SUCCESS(retval)) {
                //
                // Indicate to USN the writes are happening by HSM
                // and preserve last modified date
                //
                RsMarkUsn(Context);
                RsPreserveDates(Context);
            }
        }

        RsAcquireFileContextEntryLockExclusive(Context);

        if (NT_SUCCESS(retval)) {
            //
            //  Write the data back to the file
            //
            Context->nextWriteBuffer = Buffer;
            Context->currentOffset.QuadPart = Offset;
            Context->nextWriteSize = BufLen;
            //
            // Release the file context while writing to the file to avoid
            // deadlocks... (why???) code added by rick.
            //
            RsReleaseFileContextEntryLock(Context);
            retval = RsDoWrite(DeviceObject, Context);
            RsAcquireFileContextEntryLockExclusive(Context);

        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsPartialWrite - Failed to open the file - %x\n", retval));
        }

    }except (RsExceptionFilter(L"RsPartialWrite", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


NTSTATUS
RsCompleteIrp(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context
             )
/*++

Routine Description:

   completion routine for partialWrite

Arguments:



Return Value:


Note:

--*/
{
    //  Set the event so that our call will wake up.    //
    UNREFERENCED_PARAMETER( DeviceObject );

    if (Irp->MdlAddress) {
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteIrp - Free MDL.\n"));
        MmUnlockPages (Irp->MdlAddress) ;
        IoFreeMdl (Irp->MdlAddress) ;
    }

    KeSetEvent( (PKEVENT)Context, 0, FALSE );

    //
    // Propogate status/information to the user iosb
    //
    if (Irp->UserIosb) {
        Irp->UserIosb->Status      =  Irp->IoStatus.Status;
        Irp->UserIosb->Information =  Irp->IoStatus.Information;
    }

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
RsFailAllRequests(IN PRP_FILE_CONTEXT Context,
                  IN BOOLEAN          FailNoRecallReads)
/*++

Routine Description:

    Fail all reads and writes waiting on a recall for this file id.

Arguments:

    Context             - Pointer to file context entry
    FailNoRecallReads   - If this TRUE pending NO_RECALL reads will be failed
                          as well as regular read/writes

Return Value:

    Status

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    PRP_FILE_OBJ        entry;
    BOOLEAN             done = FALSE;

    PAGED_CODE();

    try {
        //
        // Lock the file object queue
        //
        entry = CONTAINING_RECORD(Context->fileObjects.Flink,
                                  RP_FILE_OBJ,
                                  list);

        while ((!done) && (entry != CONTAINING_RECORD(&Context->fileObjects,
                                                      RP_FILE_OBJ,
                                                      list))) {
            if (FailNoRecallReads || !RP_IS_NO_RECALL(entry)) {
                //

                RsCompleteAllRequests(Context, entry, STATUS_FILE_IS_OFFLINE);
            }
            //
            // Move on to next file object
            //
            entry = CONTAINING_RECORD(entry->list.Flink,
                                      RP_FILE_OBJ,
                                      list
                                     );
        }

    }except (RsExceptionFilter(L"RsFailAllRequests", GetExceptionInformation())) {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


NTSTATUS
RsCompleteAllRequests(IN PRP_FILE_CONTEXT Context,
                      IN PRP_FILE_OBJ Entry,
                      IN NTSTATUS     Status)
/*++

Routine Description:

    Complete all reads and writes waiting on a recall for this file object.
    This function works ok even if  the caller has acquired the file object resource
    (and assumed it was OK to hold the resource until all reads and writes have
    completed.)

Arguments:

    File object list entry, status

Return Value:


Note:


--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    NTSTATUS            localStatus;
    PRP_IRP_QUEUE       pndIo;
    KAPC_STATE          apcState;

    PAGED_CODE();

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Entry: %x Read Q: %u  Write Q %u\n",
                              Entry,
                              IsListEmpty(&Entry->readQueue),
                              IsListEmpty(&Entry->writeQueue)));
        //
        // For normal recalls just complete the Irps
        //
        pndIo = RsDequeuePacket(&Entry->readQueue, &Entry->qLock);
        while (pndIo != NULL) {
            if (pndIo->flags & RP_IRP_NO_RECALL) {
                //
                // For no recall we only have reads to deal with and we must be sure to
                // free the MDL if required.
                //
                pndIo->irp->IoStatus.Status = Status;
                pndIo->irp->IoStatus.Information = 0;
                RsCompleteRead(pndIo, (BOOLEAN) ((NULL == pndIo->userBuffer) ? FALSE : TRUE));
            } else {
                //
                // Attach to the originator process so the IRP can be completed in that
                // context
                //
                KeStackAttachProcess((PKPROCESS) IoGetRequestorProcess(pndIo->irp), &apcState);
                if (Status != STATUS_SUCCESS) {
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Failing read %x\n", pndIo->irp));
                    pndIo->irp->IoStatus.Status = Status;
                    pndIo->irp->IoStatus.Information = 0;
                    IoCompleteRequest (pndIo->irp, IO_NO_INCREMENT) ;
                } else {
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Complete read %x ext = %x\n", pndIo->irp, pndIo->deviceExtension));
                    //
                    // Resend the IRP down
                    //
                    IoSkipCurrentIrpStackLocation(pndIo->irp);
                    localStatus =  IoCallDriver( pndIo->deviceExtension->FileSystemDeviceObject, pndIo->irp );
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteAllRequests - NTFS returned status %X\n", localStatus));
                }
                KeUnstackDetachProcess(&apcState);
            }

            ExFreePool(pndIo);

            pndIo = RsDequeuePacket(&Entry->readQueue, &Entry->qLock);
        }

        pndIo = RsDequeuePacket(&Entry->writeQueue, &Entry->qLock);
        while ( pndIo != NULL) {

            if (Status != STATUS_SUCCESS) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCompleteAllRequests - Fail write %x\n", pndIo->irp));

                //
                // Attach to the originator process so the IRP can be completed in that
                // context
                //
                pndIo->irp->IoStatus.Status = Status;
                pndIo->irp->IoStatus.Information = 0;

                KeStackAttachProcess((PKPROCESS) IoGetRequestorProcess(pndIo->irp),
                                     &apcState);

                IoCompleteRequest (pndIo->irp, IO_NO_INCREMENT) ;

                KeUnstackDetachProcess(&apcState);
            } else {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Complete write %x\n", pndIo->irp));
                //
                // Resend the IRP down
                //
                IoSkipCurrentIrpStackLocation(pndIo->irp);
                //
                // Attach to the originator process so the IRP can be completed in that
                // context
                //
                KeStackAttachProcess((PKPROCESS) IoGetRequestorProcess(pndIo->irp),
                                     &apcState);

                localStatus = IoCallDriver( pndIo->deviceExtension->FileSystemDeviceObject,
                                            pndIo->irp );

                KeUnstackDetachProcess(&apcState);
                //
                // Now delete the reparse point if there was one
                //
                if (!(Context->flags & RP_FILE_REPARSE_POINT_DELETED) && NT_SUCCESS(localStatus)) {

		    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteAllRequests: deleteing reparse point, pndIo=%x\n", pndIo));

		    localStatus = RsDeleteReparsePoint(Context);

		    if (!NT_SUCCESS(localStatus)) {
			RsLogError(__LINE__,
				   AV_MODULE_RPFILFUN,
				   localStatus,
				   AV_MSG_DELETE_REPARSE_POINT_FAILED,
				   NULL,
				   NULL);
		    } else {
			RsAcquireFileContextEntryLockExclusive(Context);
			Context->flags |= RP_FILE_REPARSE_POINT_DELETED;
			RsReleaseFileContextEntryLock(Context);
		    }
		}



                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteAllRequests - NTFS returned status %X\n", localStatus));

            }

            ExFreePool(pndIo);
            pndIo = RsDequeuePacket(&Entry->writeQueue, &Entry->qLock);
        }
    }except (RsExceptionFilter(L"RsCompleteAllRequests", GetExceptionInformation()))
    {
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Done.\n"));
    return(retval);
}


NTSTATUS
RsCompleteReads(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   Completes all reads for which data is available for all file objects

Arguments:

    Context - file context entry


Return Value:

    0 If successful, non-zero if the id was not found.


--*/
{
    PRP_FILE_OBJ        entry, oldEntry;
    BOOLEAN             found;
    KIRQL               rirqL;
    PRP_IRP_QUEUE       readIo, oldReadIo;
    NTSTATUS            localStatus;
    KAPC_STATE          apcState;
    PEPROCESS           process;
    LIST_ENTRY          satisfiableIrps;

    try {

        if (Context->flags & RP_FILE_WAS_WRITTEN) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - File was writen - do not complete reads for %I64x!\n", Context->filterId));
            return(STATUS_SUCCESS);
        }

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - Complete reads for %I64x!\n", Context->filterId));
        //
        // Lock the file object queue
        //
        entry = CONTAINING_RECORD(Context->fileObjects.Blink,
                                  RP_FILE_OBJ,
                                  list);

        while (entry != CONTAINING_RECORD(&Context->fileObjects,
                                          RP_FILE_OBJ,
                                          list)) {
            //
            // Ref this file object so it does not go away unexpectedly
            //
            ObReferenceObject(entry->fileObj);
            InitializeListHead(&satisfiableIrps);

            //
            // Look at the reads and prepare a list of all that can be completed
            // Start at the end of the list as those will be the earliest reads issued.
            //

            ExAcquireSpinLock(&entry->qLock, &rirqL);

            readIo = CONTAINING_RECORD(entry->readQueue.Blink,
                                       RP_IRP_QUEUE,
                                       list);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - Checking read %p - list head is %p\n", readIo, &entry->readQueue));

            while (readIo != CONTAINING_RECORD(&entry->readQueue,
                                               RP_IRP_QUEUE,
                                               list)) {
                //
                //  Save the next entry  to be visited
                //
                oldReadIo = CONTAINING_RECORD(readIo->list.Blink,
                                              RP_IRP_QUEUE,
                                              list);
                if (!(readIo->readId & RP_READ_MASK) &&
                    (Context->currentOffset.QuadPart >= (LONGLONG) (readIo->offset + readIo->length))) {
                    //
                    // This one can be completed - *if* we can clear the cancel routine
                    // if not, irp is in the process of being cancelled and we will let it be cancelled
                    // after we release the entry->qLock
                    //
                    if (RsClearCancelRoutine(readIo->irp)) {
                        RemoveEntryList(&readIo->list);
                        InsertTailList(&satisfiableIrps,
                                       &readIo->list);

                    }

                }
                readIo = oldReadIo;
            }

            ExReleaseSpinLock(&entry->qLock, rirqL);

            //
            // We have to release the lock on the context entry first so the possible paging read that this may cause
            // can be passed through by RsCheckRead (which will get the same context lock on a different thread)
            // We can safely assume the context entry will not be freed out from underneath us because
            // we are still recalling the file (this code is called from RsPartialWrite)
            //
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - Complete read for offset %I64u & %u bytes\n", readIo->offset, readIo->length));
            RsReleaseFileContextEntryLock(Context);

            readIo = CONTAINING_RECORD(satisfiableIrps.Flink,
                                       RP_IRP_QUEUE,
                                       list);
            while (readIo != CONTAINING_RECORD(&satisfiableIrps,
                                               RP_IRP_QUEUE,
                                               list)) {
                //
                // Attach to the originator process so the IRP can be completed in that context

                process = IoGetRequestorProcess(readIo->irp);
                ObReferenceObject(process);

                KeStackAttachProcess((PKPROCESS) process, &apcState);
                //
                //
                // Resend the IRP down
                IoSkipCurrentIrpStackLocation(readIo->irp);
                localStatus =  IoCallDriver( readIo->deviceExtension->FileSystemDeviceObject, readIo->irp );
                //
                // Get the lock again.
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteReads - NTFS returned status %X\n", localStatus));
                KeUnstackDetachProcess(&apcState);

                ObDereferenceObject(process);
                oldReadIo = readIo;
                readIo = CONTAINING_RECORD(oldReadIo->list.Flink,
                                           RP_IRP_QUEUE,
                                           list);
                ExFreePool(oldReadIo);
            }

            RsAcquireFileContextEntryLockExclusive(Context);
            //
            // Move on to next file object
            //
            oldEntry = entry;
            entry = CONTAINING_RECORD(entry->list.Blink,
                                      RP_FILE_OBJ,
                                      list
                                     );

            ObDereferenceObject(oldEntry->fileObj);
        }

    }except (RsExceptionFilter(L"RsCompleteReads", GetExceptionInformation()))
    {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCompleteReads - Exception = %x.\n", GetExceptionCode()));

    }

    return(STATUS_SUCCESS);
}


VOID
RsCancelRecalls(VOID)
/*++

Routine Description:

    Cancel all pending recall activity.

Arguments:

    None

Return Value:

    None

Note:

    All pending recall activity is canceled.  Any recall requests are failed with
    STATUS_FILE_IS_OFFLINE.


--*/
{
    PRP_FILE_CONTEXT  context;
    BOOLEAN           gotLock = FALSE;

    PAGED_CODE();

    try {
        RsAcquireFileContextQueueLock();
        gotLock = TRUE;
        context = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                    RP_FILE_CONTEXT,
                                    list);

        while (context != CONTAINING_RECORD(&RsFileContextQHead,
                                            RP_FILE_CONTEXT,
                                            list)) {

            RsAcquireFileContextEntryLockExclusive(context);

            context->recallStatus = STATUS_CANCELLED;
            context->state = RP_RECALL_COMPLETED;

            KeSetEvent(&context->recallCompletedEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            RsFailAllRequests(context, TRUE);

            RsReleaseFileContextEntryLock(context);

            context = CONTAINING_RECORD(context->list.Flink,
                                        RP_FILE_CONTEXT,
                                        list
                                       );
        }


        RsReleaseFileContextQueueLock();
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsCancelRecalls", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
    }
}


NTSTATUS
RsGetRecallInfo(IN OUT PRP_MSG               Msg,
                OUT    PULONG_PTR            InfoSize,
                IN     KPROCESSOR_MODE       RequestorMode)
/*++

Routine Description:

    Return the file name and SID info to the FSA.  This is retrieved via an FSCTL call because
    the information is variable in size and may be large (file path may be 32K).

Arguments:

    Msg       FSCTL request message from the Fsa.
    InfoSize  Size of the recall info is returned in this parameter

Return Value:

    STATUS_NO_SUCH_FILE - File entry was not found
    STATUS_BUFFER_OVERFLOW - An exception was hit

Note:


--*/
{
    PRP_FILE_CONTEXT    context;
    WCHAR               *nInfo;
    NTSTATUS            retval;
    BOOLEAN             done, gotLock = FALSE;
    PRP_FILE_OBJ        entry;

    PAGED_CODE();

    try {
        //
        context = RsAcquireFileContext(Msg->msg.riReq.filterId, FALSE);

        if (NULL == context) {
            *InfoSize = 0;
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGetRecallInfo Returns %x\n", STATUS_NO_SUCH_FILE));
            return(STATUS_NO_SUCH_FILE);
        }
        gotLock = TRUE;
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo context = %x\n",
                              context));

        //
        // Now find the file object entry
        //
        done = FALSE;
        //
        // Lock the file object queue
        //
        entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                  RP_FILE_OBJ,
                                  list);

        while ((!done) && (entry != CONTAINING_RECORD(&context->fileObjects,
                                                      RP_FILE_OBJ,
                                                      list))) {
            if (Msg->msg.riReq.filterId & RP_TYPE_RECALL) {
                if (entry->filterId == (Msg->msg.riReq.filterId & RP_FILE_MASK)) {
                    //
                    // This is the one.
                    //
                    done = TRUE;
                }
            } else {
                //
                // This is a no-recall open - we have to find the ID in the read Irp.
                //
                if (RP_IS_NO_RECALL(entry)) {
                    //
                    // Since there is no user notification for this type of open we don't really care
                    // which file object entry we use so we get the first one opened for no-recall.
                    //
                    done = TRUE;
                }
            }

            if (!done) {
                //
                // Move on to next file object
                //
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_OBJ,
                                          list
                                         );
            }
        }


        if (done) {
            //
            // Return the file ID, name, and user info
            //
            Msg->msg.riReq.fileId = entry->fileId;

            if (NULL != entry->userSecurityInfo->userInfo) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo copy user info - %u bytes\n", entry->userSecurityInfo->userInfoLen));
                //
                // Make sure the buffer supplied is valid
                //
                if (RequestorMode != KernelMode) {
                    ProbeForWrite(&Msg->msg.riReq.userToken,
                                  entry->userSecurityInfo->userInfoLen,
                                  sizeof(UCHAR));
                };
                RtlCopyMemory(&Msg->msg.riReq.userToken,
                              entry->userSecurityInfo->userInfo,
                              entry->userSecurityInfo->userInfoLen);
            }

            if (context->uniName != NULL) {
                nInfo = (WCHAR *) ((CHAR *) &Msg->msg.riReq.userToken + entry->userSecurityInfo->userInfoLen);

                //
                // Make sure the buffer supplied is valid
                //
                if (RequestorMode != KernelMode) {
                    ProbeForWrite(nInfo,
                                  context->uniName->Name.Length,
                                  sizeof(UCHAR));
                };

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo copy file name - %u bytes\n", context->uniName->Name.Length));

                RtlCopyMemory(nInfo, context->uniName->Name.Buffer, context->uniName->Name.Length);

                nInfo[context->uniName->Name.Length / sizeof(WCHAR)] = L'\0';
                *InfoSize = sizeof(RP_MSG) + context->uniName->Name.Length + entry->userSecurityInfo->userInfoLen + sizeof(WCHAR);
            } else {
                *InfoSize = sizeof(RP_MSG) + entry->userSecurityInfo->userInfoLen;
            }
            retval = STATUS_SUCCESS;
        } else {
            *InfoSize = 0;
            retval = STATUS_NO_SUCH_FILE;
        }
        RsReleaseFileContext(context);
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsGetRecallInfo", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContext(context);
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo Returns %x\n", retval));

    return(retval);
}


NTSTATUS
RsWriteReparsePointData(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description

   Writes out the reparse point data to the specified file

Arguments

   Context  - Pointer to the structure which specificies the file object
              and the reparse point data that needs to be written out

Return Value

   STATUS_SUCCESS                - Reparse point data written out as specified
   STATUS_INSUFFICIENT_RESOURCES - Failure to allocate memory
   STATUS_INVALID_USER_BUFFER    - Buffer passed in was bad (touching it caused
                                   an exception)
   STATUS_NOT_SUPPORTED          - File system did not support writing of the reparse
                                   point data


--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PREPARSE_DATA_BUFFER        pRpBuffer = NULL;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp = NULL;
    PDEVICE_OBJECT              deviceObject;
    BOOLEAN                     oldWriteAccess;

    PAGED_CODE();

    try {

        //
        // Attempt allocating the RP buffer to write out
        //
        pRpBuffer = ExAllocatePoolWithTag(PagedPool,
                                          REPARSE_DATA_BUFFER_HEADER_SIZE + sizeof(Context->rpData),
                                          RP_FO_TAG
                                         );
        if (!pRpBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);

        irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

        if (!irp) {
            ExFreePool(pRpBuffer);
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Setup the reparse data buffer
        //
        RtlZeroMemory(pRpBuffer, REPARSE_DATA_BUFFER_HEADER_SIZE);
        pRpBuffer->ReparseTag = IO_REPARSE_TAG_HSM;
        pRpBuffer->ReparseDataLength = sizeof(Context->rpData);
        //
        // Copy in the reparse point data
        //
        RtlCopyMemory(((PUCHAR)pRpBuffer) + REPARSE_DATA_BUFFER_HEADER_SIZE,
                      &Context->rpData,
                      sizeof(Context->rpData));

        irp->UserEvent = &event;
        irp->UserIosb = &Iosb;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
        irp->RequestorMode = KernelMode;
        irp->Flags |= IRP_SYNCHRONOUS_API;
        //
        // Initialize the event
        //
        KeInitializeEvent(&event,
                          SynchronizationEvent,
                          FALSE);

        //
        // Set up the I/O stack location.
        //
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
        irpSp->FileObject = Context->fileObjectToWrite;
        irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_SET_REPARSE_POINT;
        irpSp->Parameters.FileSystemControl.InputBufferLength = REPARSE_DATA_BUFFER_HEADER_SIZE + sizeof(Context->rpData);

        irp->AssociatedIrp.SystemBuffer = pRpBuffer;
        //
        // Set the completion routine.
        //
        IoSetCompletionRoutine( irp,
                                RsCompleteIrp,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE );
        //
        // Give the file object permission to write
        //
        oldWriteAccess = Context->fileObjectToWrite->WriteAccess;
        Context->fileObjectToWrite->WriteAccess = TRUE;

        //
        // Send it to the FSD
        //
        Iosb.Status = STATUS_NOT_SUPPORTED;
        status = IoCallDriver(deviceObject,
                              irp);

        if (status == STATUS_PENDING) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsWriteReparsePointData - Wait for event.\n"));
            status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        //
        // Restore the old access rights
        //
        Context->fileObjectToWrite->WriteAccess = oldWriteAccess;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsWriteReparsePointData Iosb returns %x.\n", status));

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, status,
                       AV_MSG_WRITE_REPARSE_FAILED, NULL, NULL);
        }


        //
        // Free the allocated reparse data buffer
        //
        ExFreePool(pRpBuffer);
        pRpBuffer = NULL;
    }except (RsExceptionFilter(L"RsWriteReparsePointData", GetExceptionInformation()))
    {
        status = STATUS_INVALID_USER_BUFFER;
        if (pRpBuffer) {
            ExFreePool(pRpBuffer);
        }
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsWriteReparsePointData- Returning %x.\n", status));
    return(status);
}




NTSTATUS
RsAddIo(PIRP irp)
/*++

Routine Description:

    Add a IOCTL request to the queue.  These requests will be
    removed from the queue and completed when recall activity is detected.
    Recall activity includes requests to recall a file as well as notifications
    of events like the deletion or overwriting of a file with a HSM reparse point.


Arguments:

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    0 on success, non-zero if error (no memory)

Note:

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            retval = STATUS_SUCCESS;

    RsGetIoLock(&oldIrql);

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAddIo %u\n", RsFsaRequestCount));

    InsertTailList(&RsIoQHead,
                   &irp->Tail.Overlay.ListEntry);

    if (RsSetCancelRoutine(irp,
                           RsCancelIoIrp)) {
        KeReleaseSemaphore(&RsFsaIoAvailableSemaphore,
                           IO_NO_INCREMENT,
                           1L,
                           FALSE);
        InterlockedIncrement((PLONG) &RsFsaRequestCount);
        retval = STATUS_PENDING;
    } else {
        RemoveEntryList(&irp->Tail.Overlay.ListEntry);
        retval = STATUS_CANCELLED;
    }

    RsPutIoLock(oldIrql);

    return(retval);
}


PIRP
RsRemoveIo(VOID)
/*++

Routine Description:

    Remove one of the IOCTL requests on the queue


Arguments:

    None

Return Value:

    Pointer to an IRP or NULL

Note:

--*/
{
    PLIST_ENTRY      entry;
    PIRP             irp;
    RP_MSG          *msg;
    KIRQL            oldIrql;

    RsGetIoLock(&oldIrql);

    entry = RemoveHeadList(&RsIoQHead);

    if ( entry == &RsIoQHead) {
        RsPutIoLock(oldIrql);
        return NULL;
    };

    irp = CONTAINING_RECORD(entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    if (!RsClearCancelRoutine(irp)) {
        //
        // This is going to be cancelled, let the cancel routine finish with it
        //
        irp = NULL;
    } else {
        InterlockedDecrement((PLONG) &RsFsaRequestCount);
    }

    RsPutIoLock(oldIrql);

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsRemoveIo %u\n", RsFsaRequestCount));

    return(irp);
}


ULONG
RsIsNoRecall(IN PFILE_OBJECT FileObject,
             OUT PRP_DATA    *RpData)
/*++

Routine Description:

    Determine if a file object is on the queue and was open with no-recall on read option


Arguments:

    IN  - File Object
    OUT - Reparse point data

Return Value:



Note:
    This function should not be used to determine if reads should be passed to the FSA as no-recall
    reads.  If another handle was opened for recall and written to then the reads should wait for the recall
    to complete.  This function can be used to determine if the reparse point info should be munged.

--*/
{
    ULONG                  retval;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                gotLock = FALSE;

    PAGED_CODE();

    try {

        filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
        if (filterContext == NULL) {
            //
            // Not found
            return(FALSE);
        }

        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = (PRP_FILE_CONTEXT) entry->fsContext;

        ASSERT(FileObject == entry->fileObj);

        RsAcquireFileContextEntryLockShared(context);
        gotLock = TRUE;
        retval = FALSE;
        if (RP_IS_NO_RECALL(entry)) {

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: reporting file (%x : %x) open for no recall.\n", context, entry));

            *RpData = &context->rpData;
            retval = TRUE;
        }
        RsReleaseFileContextEntryLock(context);
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsIsNoRecall", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
        }
    }

    return(retval);
}


BOOLEAN
RsIsFastIoPossible(IN PFILE_OBJECT FileObject)
/*++

Routine Description:

    Determine if Fast IO is OK for this file object


Arguments:

    None

Return Value:



Note:

--*/
{
    BOOLEAN                retval = TRUE;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                gotLock = FALSE;

    PAGED_CODE();

    try {

        filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
        if (filterContext == NULL) {
            //
            // Not found
            return(TRUE);
        }

        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = entry->fsContext;
        RsAcquireFileObjectEntryLockShared(entry);
        gotLock = TRUE;
        //
        // If the file has not been recalled yet then fast IO is not allowed.
        //
        if (context->state != RP_RECALL_COMPLETED) {
            retval = FALSE;
        }

        RsReleaseFileObjectEntryLock(entry);
        gotLock = FALSE;
    }except (RsExceptionFilter(L"RsIsFastIoPossible", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileObjectEntryLock(entry);
        }
    }
    return(retval);
}


VOID
RsCancelIo(VOID)
/*++

Routine Description:

    Cancel all the IOCTL requests on the queue.

Arguments:

    FILE OBJECT - If this is not NULL we cancel only the requests for this file object

Return Value:

    NONE

Note:

--*/
{
    PIRP             irp;
    PLIST_ENTRY      entry;
    LIST_ENTRY       cancelledIrps;
    KIRQL            irql;
    LARGE_INTEGER    timeout;

    InitializeListHead(&cancelledIrps);

    RsGetIoLock(&irql);

    while (!IsListEmpty(&RsIoQHead)) {
        entry = RemoveHeadList(&RsIoQHead);
        irp = CONTAINING_RECORD(entry,
                                IRP,
                                Tail.Overlay.ListEntry);

        if (RsClearCancelRoutine(irp)) {
            irp->IoStatus.Status = STATUS_CANCELLED;
            irp->IoStatus.Information = 0;
            //
            // Add it to our queue of IRPs which will be
            // completed after we get back to a safer IRQL
            //
            InsertTailList(&cancelledIrps,
                           &irp->Tail.Overlay.ListEntry);
        }
    }

    RsPutIoLock(irql);
    //
    // Complete the cancelled IRPs
    //
    timeout.QuadPart = 0;
    while (!IsListEmpty(&cancelledIrps)) {
        entry = RemoveHeadList(&cancelledIrps);
        irp = CONTAINING_RECORD(entry,
                                IRP,
                                Tail.Overlay.ListEntry);
        IoCompleteRequest(irp,
                          IO_NO_INCREMENT);
        InterlockedDecrement((PLONG) &RsFsaRequestCount);
        //
        // The semaphore count needs to be adjusted
        // Do a simple zero-length wait to decrement it
        //
        ASSERT (KeReadStateSemaphore(&RsFsaIoAvailableSemaphore) > 0);

        KeWaitForSingleObject(&RsFsaIoAvailableSemaphore,
                              Executive,
                              KernelMode,
                              FALSE,
                              &timeout);
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsCancelIo %u\n", RsFsaRequestCount));
}


NTSTATUS
RsCancelIoIrp(
             PDEVICE_OBJECT DeviceObject,
             PIRP Irp)
/*++

Routine Description

    This function filters cancels an outstanding IOCTL IRP
    Since this is only called if the FSA service is killed or crashes
    we set RsAllowRecalls to FALSE to prevent further recall activity
    and cancel any pending recall activity.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.
--*/
{
    NTSTATUS        status;
    LARGE_INTEGER   timeout;
    PRP_MSG         msg;

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel IOCTL ...\n"));

    UNREFERENCED_PARAMETER(DeviceObject);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    RsAllowRecalls = FALSE;
    RsCancelRecalls();

    RsInterlockedRemoveEntryList(&Irp->Tail.Overlay.ListEntry,
                                 &RsIoQueueLock);

    if (NULL != Irp->AssociatedIrp.SystemBuffer) {
        msg = (RP_MSG *) Irp->AssociatedIrp.SystemBuffer;
        msg->inout.command = RP_CANCEL_ALL_DEVICEIO;
    }

    InterlockedDecrement((PLONG) &RsFsaRequestCount);
    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsCancelIoIrp %u\n", RsFsaRequestCount));

    //
    // The semaphore count needs to be adjusted
    // Do a simple zero-length wait to decrement it
    //
    ASSERT (KeReadStateSemaphore(&RsFsaIoAvailableSemaphore) > 0);

    timeout.QuadPart = 0L;
    status =  KeWaitForSingleObject(&RsFsaIoAvailableSemaphore,
                                    UserRequest,
                                    KernelMode,
                                    FALSE,
                                    &timeout);

    ASSERT (status == STATUS_SUCCESS);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return(STATUS_SUCCESS);
}


VOID
RsCancelReadRecall(IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp)
/*++

Routine Description:


    Cancel routine for the recall Irp.  If it is on the queue then clean it up.


Arguments:

    DeviceObject - Pointer to the device object
            Irp  - Pointer to the IRP

Return Value:

    None

--*/
{
    KIRQL                  oldIrql;
    PIO_STACK_LOCATION     currentStack ;
    PRP_IRP_QUEUE          io;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                found = FALSE, gotLock = FALSE;
    LARGE_INTEGER          combinedId;


    UNREFERENCED_PARAMETER(DeviceObject);
    currentStack = IoGetCurrentIrpStackLocation (Irp) ;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(currentStack->FileObject), FsDeviceObject, currentStack->FileObject);
    if (filterContext == NULL) {
        //
        // Not found
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }

    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;

    RsAcquireFileObjectEntryLockExclusive(entry);
    gotLock = TRUE;

    try {

        ExAcquireSpinLock(&entry->qLock,
                          &oldIrql);

        io =  CONTAINING_RECORD (entry->readQueue.Flink,
                                 RP_IRP_QUEUE,
                                 list);

        while (io != CONTAINING_RECORD(&entry->readQueue,
                                       RP_IRP_QUEUE,
                                       list)) {

            if (io->irp == Irp) {
                //
                // Remove irp from queue

                RemoveEntryList(&io->list);
                found = TRUE;
                break;
            } else {
                io = CONTAINING_RECORD(io->list.Flink,
                                       RP_IRP_QUEUE,
                                       list);
            }
        }
        ExReleaseSpinLock(&entry->qLock,
                          oldIrql);
        RsReleaseFileObjectEntryLock(entry);
        gotLock = FALSE;

        if (found) {
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            //
            // We need to clean up if this for a READ_NO_RECALL
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Found the read Irp\n"));

            if (RP_IS_NO_RECALL(entry)) {
                //
                // Complete the read
                //
                RsCompleteRead(io, (BOOLEAN) ((NULL == io->userBuffer) ? FALSE : TRUE));
                //
                // Tell the FSA to cancel it.
                //
                combinedId.QuadPart  = context->filterId;
                combinedId.HighPart |= (ULONG) io->readId;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel read for ID #%I64x.\n",
                                      combinedId.QuadPart));
                RsQueueCancel(combinedId.QuadPart);

            } else {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel a read for ID #%I64x.\n",
                                      entry->filterId));
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            ExFreePool(io);
        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Did not find the read Irp\n"));
            //
            // Cancel the request anyway
            //
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }except (RsExceptionFilter(L"RsCancelReadRecall", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileObjectEntryLock(entry);
        }
    }
    return;
}


VOID
RsCancelWriteRecall(IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp)
/*++

Routine Description:


    Cancel routine for the recall Irp.  If it is on the queue then clean it up.


Arguments:

    DeviceObject - Pointer to the device object
            Irp  - Pointer to the IRP

Return Value:

    None

--*/
{
    KIRQL                  oldIrql;
    PRP_IRP_QUEUE          io;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    PIO_STACK_LOCATION     currentStack ;
    BOOLEAN                found = FALSE, gotLock = FALSE;

    UNREFERENCED_PARAMETER(DeviceObject);
    currentStack = IoGetCurrentIrpStackLocation (Irp) ;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(currentStack->FileObject), FsDeviceObject, currentStack->FileObject);
    if (filterContext == NULL) {
        //
        // Not found
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }

    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;
    RsAcquireFileObjectEntryLockExclusive(entry);
    gotLock = TRUE;

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel recall ID #%I64x.\n",
                              entry->filterId));


        ExAcquireSpinLock(&entry->qLock,
                          &oldIrql);

        io = CONTAINING_RECORD(entry->writeQueue.Flink,
                               RP_IRP_QUEUE,
                               list);

        while (io != CONTAINING_RECORD(&entry->writeQueue,
                                       RP_IRP_QUEUE,
                                       list)) {
            if (io->irp == Irp) {
                //
                // Remove irp from queue
                //
                RemoveEntryList (&io->list);
                found = TRUE;
                break;
            } else {
                io = CONTAINING_RECORD(io->list.Flink,
                                       RP_IRP_QUEUE,
                                       list);
            }
        }

        ExReleaseSpinLock(&entry->qLock,
                          oldIrql);

        RsReleaseFileObjectEntryLock(entry);
        gotLock = TRUE;
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel a write for ID #%I64x\n",
                              entry->filterId | context->filterId));

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        if (found) {
            ExFreePool(io);
        }
    }except (RsExceptionFilter(L"RsCancelWriteRecall", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileObjectEntryLock(entry);
        }
    }
    return;
}


ULONG
RsTerminate(VOID)
/*++

Routine Description:

    Called on termination to clean up any necessary items.

Arguments:

    NONE

Return Value:

    0

Note:


--*/
{
    PAGED_CODE();

    return(0);
}


NTSTATUS RsGenerateDevicePath(IN PDEVICE_OBJECT deviceObject,
                              OUT POBJECT_NAME_INFORMATION *nameInfo
                             )
/*++

Routine Description:

    Generate a full path specification from the device object.

Arguments:

    deviceObject  - the file object to get the device object from
    nameInfo - where to put the name


Return Value:

    0 on success

Note:


--*/
{
    NTSTATUS                   status;
    ULONG                      size;
    NTSTATUS                   retval = STATUS_SUCCESS;
    USHORT                     nLen;
    POBJECT_NAME_INFORMATION   deviceName = NULL;
    UNICODE_STRING             tmpString;


    PAGED_CODE();

    try {
        if (deviceName = ExAllocatePoolWithTag( NonPagedPool, AV_DEV_OBJ_NAME_SIZE, RP_FN_TAG)) {
            size = AV_DEV_OBJ_NAME_SIZE;

            status = ObQueryNameString(
                                      deviceObject,
                                      deviceName,
                                      size,
                                      &size
                                      );

            if (!NT_SUCCESS(status)) {
                if (AV_DEV_OBJ_NAME_SIZE < size) {
                    /* Did not allocate enough space for the device name -
                        reallocate and try again */
                    ExFreePool(deviceName);
                    if (deviceName = ExAllocatePoolWithTag( NonPagedPool, size + 10, RP_FN_TAG)) {
                        status = ObQueryNameString(
                                                  deviceObject,
                                                  deviceName,
                                                  size + 10,
                                                  &size
                                                  );
                    } else {
                        RsLogError(__LINE__, AV_MODULE_RPFILFUN, size,
                                   AV_MSG_MEMORY, NULL, NULL);
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }
                }

            }
        } else {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, AV_DEV_OBJ_NAME_SIZE,
                       AV_MSG_MEMORY, NULL, NULL);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        if (!NT_SUCCESS(status)) {
            //
            // Failed to get device object name
            //
            // Log an error
            //
            ExFreePool(deviceName);
            return(STATUS_NO_SUCH_DEVICE);
        }

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGenerateDevicePath Device name is %u bytes - %ws\n",
                              deviceName->Name.Length, deviceName->Name.Buffer));

        nLen = (USHORT) (AV_NAME_OVERHEAD + size);

        if (*nameInfo = ExAllocatePoolWithTag( NonPagedPool, nLen, RP_FN_TAG)) {
            RtlZeroMemory(*nameInfo, nLen);
            (*nameInfo)->Name.Length = 0;
            (*nameInfo)->Name.MaximumLength = (USHORT) (nLen - sizeof(OBJECT_NAME_INFORMATION));
            (*nameInfo)->Name.Buffer = (WCHAR *) ((CHAR *) *nameInfo + sizeof(OBJECT_NAME_INFORMATION));


            RtlInitUnicodeString(&tmpString, (PWCHAR) L"");
            //RtlInitUnicodeString(&tmpString, L"\\\\.");
            RtlCopyUnicodeString(&(*nameInfo)->Name, &tmpString);

            status = RtlAppendUnicodeStringToString(&(*nameInfo)->Name, &deviceName->Name);
            if (NT_SUCCESS(status)) {
                retval = STATUS_SUCCESS;
            } else {
                retval = status;
            }

        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateDevicePath failed - no memory\n"));
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, nLen,
                       AV_MSG_MEMORY, NULL, NULL);
        }

        ExFreePool(deviceName);
        deviceName = NULL;

    }except (RsExceptionFilter(L"RsGenerateDevicePath", GetExceptionInformation()))
    {
        if (*nameInfo != NULL)
            ExFreePool( *nameInfo );

        if (deviceName != NULL)
            ExFreePool( deviceName );

        retval = STATUS_BUFFER_OVERFLOW;
    }

    return(retval);
}



NTSTATUS RsGenerateFullPath(IN POBJECT_NAME_INFORMATION fileName,
                            IN PDEVICE_OBJECT deviceObject,
                            OUT POBJECT_NAME_INFORMATION *nameInfo
                           )
/*++

Routine Description:

    Generate a full path specification from the file object and file name given.
    Return the path with the device specific portion.

Arguments:

    fileName      - Path from the root of the device
    deviceObject  - the file object to get the device object from
    nameInfo - where to put the name


Return Value:

    0 on success

Note:


--*/
{
    NTSTATUS                   status;
    ULONG                      size;
    NTSTATUS                   retval = STATUS_SUCCESS;
    USHORT                     nLen;
    POBJECT_NAME_INFORMATION   deviceName = NULL;

    PAGED_CODE();

    try {
        *nameInfo = NULL;
        size = AV_DEV_OBJ_NAME_SIZE;
        if (deviceName = ExAllocatePoolWithTag( NonPagedPool, size, RP_FN_TAG)) {
            status = ObQueryNameString(
                                      deviceObject,
                                      deviceName,
                                      size,
                                      &size
                                      );

            if (!NT_SUCCESS(status)) {
                if (AV_DEV_OBJ_NAME_SIZE < size) {
                    /* Did not allocate enough space for the device name -
                        reallocate and try again */
                    ExFreePool(deviceName);
                    if (deviceName = ExAllocatePoolWithTag( NonPagedPool, size + 10, RP_FN_TAG)) {
                        status = ObQueryNameString(
                                                  deviceObject,
                                                  deviceName,
                                                  size + 10,
                                                  &size
                                                  );
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGenerateFullPath - Second try for device name returned %x.\n", status));
                    } else {
                        RsLogError(__LINE__, AV_MODULE_RPFILFUN, size,
                                   AV_MSG_MEMORY, NULL, NULL);
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }
                }

            }
        } else {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, AV_DEV_OBJ_NAME_SIZE,
                       AV_MSG_MEMORY, NULL, NULL);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        if (!NT_SUCCESS(status)) {
            //
            // Failed to get device object name
            //
            ExFreePool(deviceName);
            //
            // Log an error
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateFullPath - Failed to get the device name - %x.\n", status));
            return(STATUS_NO_SUCH_DEVICE);
        }

        nLen = (USHORT) (AV_NAME_OVERHEAD +
                         fileName->Name.MaximumLength +
                         size);

        if (*nameInfo = ExAllocatePoolWithTag( NonPagedPool, nLen, RP_FN_TAG)) {

            (*nameInfo)->Name.Length = 0;
            (*nameInfo)->Name.MaximumLength = (USHORT) (nLen - sizeof(OBJECT_NAME_INFORMATION));
            (*nameInfo)->Name.Buffer = (PWCHAR) ((CHAR *) *nameInfo + sizeof(OBJECT_NAME_INFORMATION));

            RtlCopyUnicodeString(&(*nameInfo)->Name, &deviceName->Name);

            status = RtlAppendUnicodeStringToString(&(*nameInfo)->Name, &fileName->Name);
            if (NT_SUCCESS(status)) {
                retval = STATUS_SUCCESS;
            } else {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateFullPath - Failed to append filename (nLen = %u, fileName = %u dev = %u) - %x.\n",
                                      nLen, fileName->Name.MaximumLength, size, status));
                ExFreePool( *nameInfo );
                retval = status;
            }

        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateFullPath failed - no memory\n"));
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, nLen,
                       AV_MSG_MEMORY, NULL, NULL);
        }

        ExFreePool(deviceName);
        deviceName = NULL;

    }except (RsExceptionFilter(L"RsGenerateFullPath", GetExceptionInformation()))
    {
        if (*nameInfo != NULL)
            ExFreePool( *nameInfo );

        if (deviceName != NULL)
            ExFreePool( deviceName );

        retval = STATUS_BUFFER_OVERFLOW;
    }

    return(retval);
}



BOOLEAN
RsAddValidateObj(ULONG serial, LARGE_INTEGER cTime)
/*++

Routine Description:


 Add an entry to the queue if needed.


Arguments:
    Volume serial number
    Time

Return Value:

 Return TRUE if the registry should be updated, FALSE if not.

Note:


--*/
{
    PRP_VALIDATE_INFO    entry;
    KIRQL                irqL;
    LARGE_INTEGER        lTime;
    BOOLEAN              done = FALSE;
    BOOLEAN              gotLock = FALSE;


    try {
        RsGetValidateLock(&irqL);
        gotLock = TRUE;

        entry = (RP_VALIDATE_INFO *) RsValidateQHead.Flink;
        while ((entry != (RP_VALIDATE_INFO *) &RsValidateQHead) && (FALSE == done)) {
            if (entry->serial == serial) {
                done = TRUE;
            } else {
                entry = (RP_VALIDATE_INFO *) entry->list.Flink;
                if (entry == (RP_VALIDATE_INFO *) &RsValidateQHead) {
                    done = TRUE;
                }
            }
        }


        if (entry != (RP_VALIDATE_INFO *) &RsValidateQHead) {
            lTime.QuadPart = entry->lastSetTime.QuadPart;
        }

        RsPutValidateLock(irqL);
        gotLock = FALSE;

        if (entry == (RP_VALIDATE_INFO *) &RsValidateQHead) {
            entry = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_VALIDATE_INFO), RP_VO_TAG);
            if (NULL == entry) {
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_VALIDATE_INFO),
                           AV_MSG_MEMORY, NULL, NULL);

                return(TRUE);
            }

            entry->serial = serial;
            entry->lastSetTime.QuadPart = cTime.QuadPart;
            ExInterlockedInsertTailList(&RsValidateQHead, (PLIST_ENTRY) entry, &RsValidateQueueLock);
            return(TRUE);
        }

    }except (RsExceptionFilter(L"RsAddValidateObj", GetExceptionInformation()))
    {
        if (gotLock == TRUE) {
            RsPutValidateLock(irqL);
        }

    }
    //
    // There was already an entry.  If this was an hour or more later
    // we need to update the registry again.
    //
    if ( (cTime.QuadPart - lTime.QuadPart) >= AV_FT_TICKS_PER_HOUR) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
RsRemoveValidateObj(ULONG serial)
/*++

Routine Description:


 remove an entry from the queue if needed.


Arguments:
    Volume serial number
    Time

Return Value:

 Return TRUE for success

Note:


--*/
{
    PRP_VALIDATE_INFO    entry;
    KIRQL                irqL;
    BOOLEAN              done = FALSE;
    BOOLEAN              retval = FALSE;
    BOOLEAN              gotLock = FALSE;


    try {
        RsGetValidateLock(&irqL);
        gotLock = TRUE;

        entry =  CONTAINING_RECORD(RsValidateQHead.Flink,
                                   RP_VALIDATE_INFO,
                                   list);
        while ((entry != CONTAINING_RECORD(&RsValidateQHead,
                                           RP_VALIDATE_INFO,
                                           list)) && (FALSE == done)) {
            if (entry->serial == serial) {
                RemoveEntryList(&entry->list);
                done = TRUE;
            } else {
                entry =  CONTAINING_RECORD(entry->list.Flink,
                                           RP_VALIDATE_INFO,
                                           list);
            }
        }

        RsPutValidateLock(irqL);
        gotLock = FALSE;

        if (done) {
            ExFreePool(entry);
        }
    }except (RsExceptionFilter(L"RsRemoveValidateObj", GetExceptionInformation()))
    {
        retval = FALSE;
        if (gotLock == TRUE) {
            RsPutValidateLock(irqL);
        }

    }
    return(retval);
}



VOID
RsLogValidateNeeded(ULONG serial)
/*++

Routine Description:

    Log the fact that a validate job needs to be run on a given volume.
    If it was already logged in the last hour then forget it, otherwise update it.
    Let the Fsa know by completing an IOCTL (if the FSA is running).
    Write an entry to the registry to indicate it in case the Fsa is not running.

Arguments:

    Serial number of the volume

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS            retval;
    WCHAR               serBuf[10];
    LARGE_INTEGER       cTime;
    UNICODE_STRING      str;

    PAGED_CODE();

    KeQuerySystemTime(&cTime);

    if (RsAddValidateObj(serial, cTime) == TRUE) {
        str.Buffer = &serBuf[0];
        str.Length = 10 * sizeof(WCHAR);
        str.MaximumLength = 10 * sizeof(WCHAR);

        retval = RtlIntegerToUnicodeString(serial, 16, &str);
        serBuf[8] = L'\0';
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Reg value name is %ws\n", serBuf));

        if (!NT_SUCCESS(RsQueueValidate(serial))) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                       AV_MSG_VALIDATE_WARNING, NULL, NULL);
        }
        retval = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, FSA_VALIDATE_LOG_KEY_NAME, serBuf, REG_BINARY, &cTime, sizeof(LARGE_INTEGER));
        if (!NT_SUCCESS(retval)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                       AV_MSG_VALIDATE_WARNING, NULL, NULL);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Set registry entry returned %x\n", retval));
        }
    }
}


NTSTATUS
RsQueueValidate(ULONG serial)
/*++

Routine Description:

   Let the Fsa know that a validate job is needed

Arguments:
   Volume serial number

Return Value:

   Status

--*/
{
    ULONG               retval;
    RP_MSG              *msg;
    PIRP                ioIrp;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    try {
        //
        // Need to wait for IO entry as long as there are no IOCTLS or until we time out
        //
        ioIrp = RsGetFsaRequest();
        if (NULL != ioIrp) {

            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = RP_RUN_VALIDATE;
                msg->msg.oReq.serial = serial;
            }
            //
            // Now that we have gotten everything setup we can put it on the queue
            //
            //
            // Complete a device IOCTL to let the Fsa know
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Letting the Fsa know a validate is needed for %x\n",
                                  serial));

            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
    }except (RsExceptionFilter(L"RsQueueValidate", GetExceptionInformation())) {
        retval = STATUS_UNEXPECTED_IO_ERROR;
    }

    return(retval);
}



VOID
RsLogError(ULONG line,
           ULONG file,
           ULONG code,
           NTSTATUS ioError,
           PIO_STACK_LOCATION irpSp,
           WCHAR *msgString)
/*++

Routine Description:

    Log an error to the event log.

Arguments:

   Line number
   Source file ID
   Error code
   IRP (may be NULL if no IRP is involved)
   Message parm string - 30 Unicode chars max
                         (optional - NULL if not needed)

Return Value:

    NONE

Note:

   The information may be seen in the NT event log.  You need to view the
   NT system log.  You will see events with RsFilter as the source.  If
   you view the event detail you will see the log message and some hex
   data.  At offset 0x28 you will see the line, file id, and error code
   information (4 bytes each - lo byte first).


--*/
{
    PIO_ERROR_LOG_PACKET    pErr;
    PAV_ERR                 eStuff;
    AV_ERR                  memErr;
    size_t                  size;
    BOOLEAN                 gotMem = FALSE;


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Log error %u in %u of %u\n", code, line, file));

    if (msgString != NULL)
        size = wcslen(msgString) * sizeof(WCHAR) + sizeof(WCHAR);
    else
        size = 0;

    if (sizeof(IO_ERROR_LOG_PACKET) + sizeof(AV_ERR) + size > ERROR_LOG_MAXIMUM_SIZE)
        size -=  (sizeof(IO_ERROR_LOG_PACKET) + sizeof(AV_ERR) + size) -
                 ERROR_LOG_MAXIMUM_SIZE;


    if (ioError == AV_MSG_MEMORY) {
        // No memory to allocate for the error packet - use the stack
        // allocated one and make sure there is no additional message string
        eStuff = &memErr;
        size = 0;
    } else {
        eStuff = ExAllocatePoolWithTag( NonPagedPool, size + sizeof(AV_ERR), RP_ER_TAG);
        if (eStuff != NULL) {
            gotMem = TRUE;
        } else {
            // no memory - do the best we can.
            eStuff = &memErr;
            size = 0;
            gotMem = FALSE;
        }
    }


    pErr = (PVOID) IoAllocateErrorLogEntry(FsDriverObject->DeviceObject,
                                           (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + sizeof(AV_ERR) + size));

    if (NULL != pErr) {
        if (NULL != irpSp)
            pErr->MajorFunctionCode = irpSp->MajorFunction;
        else
            pErr->MajorFunctionCode = 0;

        pErr->RetryCount = 0;
        pErr->DumpDataSize = offsetof(AV_ERR, string);
        pErr->NumberOfStrings = 1;
        pErr->StringOffset = offsetof(IO_ERROR_LOG_PACKET, DumpData) +
                             offsetof(AV_ERR, string);
        pErr->EventCategory = 0;
        pErr->ErrorCode = ioError;
        pErr->UniqueErrorValue = code;
        pErr->FinalStatus = STATUS_SUCCESS;
        pErr->SequenceNumber = 0x999;
        pErr->IoControlCode = 0;

        memset(eStuff, 0, sizeof(AV_ERR));
        eStuff->line = line;
        eStuff->file = file;
        eStuff->code = code;

        //
        // Copy the string if it is there AND we allocated memory for it
        //
        if ( (NULL != msgString) && (gotMem)) {
            RtlCopyMemory(eStuff->string, msgString, size);
            eStuff->string[(size / sizeof(WCHAR)) - 1] = L'\0';
        }

        RtlCopyMemory(&pErr->DumpData[0], eStuff, sizeof(AV_ERR) + size);
        IoWriteErrorLogEntry((PVOID) pErr);
    }

    if (gotMem) {
        ExFreePool(eStuff);
    }
}


PIRP
RsGetFsaRequest(VOID)
/*++

Routine description

Gets the next free FSA action request packet, to be used for filter/fsa communication,
sent down by the FSA and returns it.
If none are available immediately, waits for a limited time for one
to become available.

Arguments

None

Return Value

Pointer to the next free FSA request packet if successful
NULL if there are none and we've timed out waiting for a free one.


--*/
{
    PIRP           ioIrp = NULL;
    LARGE_INTEGER  waitInterval;
    NTSTATUS       status;

    PAGED_CODE();

    while (TRUE) {
        //
        // Get hold of a pending FSCTL
        //
        if (FALSE == RsAllowRecalls) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:  recalls disabled, not getting Fsa request\n"));
            break;
        }

        waitInterval.QuadPart = RP_WAIT_FOR_FSA_IO_TIMEOUT;

        status =  KeWaitForSingleObject(&RsFsaIoAvailableSemaphore,
                                        UserRequest,
                                        KernelMode,
                                        FALSE,
                                        &waitInterval);
        if (status == STATUS_TIMEOUT) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO,  "RsFilter:  out of FSCTLs and timed out waiting for one\n"));
            //
            // Log this error so PSS may identify that the recall failed
            // specifically because we ran out of resources to communicate
            // with the recall engine 
            //
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0, AV_MSG_OUT_OF_FSA_REQUESTS, NULL, NULL);
            break;
        }

        ioIrp = RsRemoveIo();

        if (NULL == ioIrp) {
            //
            // io was cancelled for some reason after it was retrieved.
            // Try to get another
            //
            continue;
        } else {
            //
            // Found a  free FSCTL
            //
            break;
        }
    }

    return ioIrp;
}


NTSTATUS
RsGetFileInfo(IN PRP_FILE_OBJ   Entry,
              IN PDEVICE_OBJECT DeviceObject )

/*++

Routine Description:

   Get the needed information to fill out the file object queue info.

Arguments:

    Entry               - Pointer to the file object entry
    DeviceObject        - Filter device object for RsFilter


Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    PRP_FILE_CONTEXT    context;

    PAGED_CODE();

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileInfo - Getting file name & id information.\n"));

        context = Entry->fsContext;

        if (context->fileId == 0) {
            //
            // No file ID - we need to get it now
            //
            retval = RsGetFileId(Entry,
                                 DeviceObject);
        }

        if ((retval == STATUS_SUCCESS) && (context->uniName == NULL)) {
            //
            // No file name - we need to get it now
            //
            retval = RsGetFileName(Entry,
                                   DeviceObject);
        }


    }except (RsExceptionFilter(L"RsGetFileInfo", GetExceptionInformation()))
    {

        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileInfo - Returning %x.\n", retval));

    return(retval);
}



NTSTATUS
RsGetFileName(IN PRP_FILE_OBJ Entry,
              IN PDEVICE_OBJECT DeviceObject)

/*++

Routine Description:

   Get the file name

Arguments:

    Entry        -  File object queue entry

    DeviceObject -  Filter Device Object for RsFilter

Return Value:

    0 If successful, non-zero if the name was not found.

Note:

--*/
{
    NTSTATUS                retval = STATUS_SUCCESS;
    KEVENT                  event;
    PIO_STACK_LOCATION      irpSp = NULL;
    IO_STATUS_BLOCK         Iosb;
    PIRP                    irp;
    PDEVICE_EXTENSION       deviceExtension;
    PFILE_NAME_INFORMATION  nameInfo;
    ULONG                   size;
    PRP_FILE_CONTEXT        context;

    PAGED_CODE();

    try {

        context = Entry->fsContext;

        deviceExtension = DeviceObject->DeviceExtension;

        retval = STATUS_BUFFER_OVERFLOW;
        size = sizeof(FILE_NAME_INFORMATION) + 1024;

        while (retval == STATUS_BUFFER_OVERFLOW) {

            irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

            if (irp) {
                irp->UserEvent = &event;
                irp->UserIosb = &Iosb;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();
                irp->Tail.Overlay.OriginalFileObject = Entry->fileObj;
                irp->RequestorMode = KernelMode;
                irp->Flags |= IRP_SYNCHRONOUS_API;
                //
                // Initialize the event
                //
                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                //
                // Set up the I/O stack location.
                //

                irpSp = IoGetNextIrpStackLocation(irp);
                irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
                irpSp->DeviceObject = Entry->devObj;
                irpSp->FileObject = Entry->fileObj;
                irpSp->Parameters.QueryFile.FileInformationClass = FileNameInformation;

                Iosb.Status = STATUS_SUCCESS;

                //
                // Set the completion routine.
                //
                IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

                //
                // Send it to the FSD
                //
                nameInfo = ExAllocatePoolWithTag(NonPagedPool, size, RP_FO_TAG);
                if (NULL != nameInfo) {
                    irpSp->Parameters.QueryFile.Length = size;
                    irp->AssociatedIrp.SystemBuffer = nameInfo;

                    retval = IoCallDriver(deviceExtension->FileSystemDeviceObject, irp);

                    if (retval == STATUS_PENDING) {
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileName - Wait for event.\n"));
                        retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

                        retval = Iosb.Status;
                        DebugTrace((DPFLTR_RSFILTER_ID, DBG_INFO, "RsFilter: QUERY_INFO returned STATUS_PENDING: nameInfo=%x size=%x\n", nameInfo, size));
                    }

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileName - Get name info returned %x.\n", retval));

                    if (retval == STATUS_BUFFER_OVERFLOW) {
                        // Now we have the name size - allocate space and get the name
                        DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsFilter: QUERY_INFO returned STATUS_BUFFER_OVERFLOW: nameInfo=%x size=%x\n", nameInfo, size));
                        size = nameInfo->FileNameLength + sizeof(FILE_NAME_INFORMATION);
                        ExFreePool(nameInfo);
                        nameInfo = NULL;
                    } else if (retval == STATUS_SUCCESS) {
                        context->uniName = ExAllocatePoolWithTag(NonPagedPool, sizeof(OBJECT_NAME_INFORMATION) + nameInfo->FileNameLength + sizeof(WCHAR), RP_FN_TAG);
                        if (context->uniName != NULL) {
                            context->uniName->Name.Length = (USHORT) nameInfo->FileNameLength;
                            context->uniName->Name.MaximumLength = (USHORT) nameInfo->FileNameLength + sizeof(WCHAR);
                            context->uniName->Name.Buffer = (PWSTR) ((CHAR *) context->uniName + sizeof(OBJECT_NAME_INFORMATION));
                            RtlCopyMemory(context->uniName->Name.Buffer,
                                          nameInfo->FileName,
                                          context->uniName->Name.Length);

                        } else {
                            // no memory for the file name
                            retval = STATUS_INSUFFICIENT_RESOURCES;
                            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(OBJECT_NAME_INFORMATION) + nameInfo->FileNameLength + 2,
                                       AV_MSG_MEMORY, irpSp, NULL);
                        }

                        ExFreePool(nameInfo);
                    } else {
                        ExFreePool(nameInfo);
                    }
                } else {
                    // No memory = free the irp and report an error

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, size,
                               AV_MSG_MEMORY, irpSp, NULL);
                    IoFreeIrp(irp);
                    retval = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                retval = STATUS_INSUFFICIENT_RESOURCES;
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                           AV_MSG_MEMORY, irpSp, NULL);

            }
        }
    }except (RsExceptionFilter(L"RsGetFileName", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileName - Returning %x.\n", retval));
    return(retval);
}


NTSTATUS
RsGetFileId(IN PRP_FILE_OBJ    Entry,
            IN PDEVICE_OBJECT  DeviceObject)

/*++

Routine Description:

   Get the file name

Arguments:

    Entry        -  File object queue entry
    DeviceObject -  Filter Device Object for RsFilter


Return Value:

    0 If successful, non-zero if the name was not found.

Note:

--*/
{
    NTSTATUS                    retval = STATUS_SUCCESS;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp;
    PDEVICE_EXTENSION           deviceExtension;
    FILE_INTERNAL_INFORMATION   idInfo;
    PRP_FILE_CONTEXT            context;

    PAGED_CODE();

    try {

        context = Entry->fsContext;

        deviceExtension = DeviceObject->DeviceExtension;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Build Irp for File ID ext = %x.\n", deviceExtension->FileSystemDeviceObject));
        irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

        if (irp) {
            irp->UserEvent = &event;
            irp->UserIosb = &Iosb;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->Tail.Overlay.OriginalFileObject = Entry->fileObj;
            irp->RequestorMode = KernelMode;
            irp->Flags |= IRP_SYNCHRONOUS_API;
            //
            // Initialize the event
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            //
            // Set up the I/O stack location.
            //

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
            irpSp->DeviceObject = Entry->devObj;
            irpSp->FileObject = Entry->fileObj;
            irpSp->Parameters.QueryFile.Length = sizeof(FILE_INTERNAL_INFORMATION);
            irpSp->Parameters.QueryFile.FileInformationClass = FileInternalInformation;
            irp->AssociatedIrp.SystemBuffer = &idInfo;

            //
            // Set the completion routine.
            //
            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            //
            // Send it to the FSD
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Call driver for File ID.\n"));
            Iosb.Status = 0;

            retval = IoCallDriver(deviceExtension->FileSystemDeviceObject, irp);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - IoCallDriver returns %x.\n", retval));

            if (retval == STATUS_PENDING) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Wait for event.\n"));
                retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }

            retval = Iosb.Status;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Iosb returns %x.\n", retval));

            if (retval == STATUS_SUCCESS) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - File ID is %x%x.\n",
                                      idInfo.IndexNumber.HighPart,
                                      idInfo.IndexNumber.LowPart));
                context->fileId = idInfo.IndexNumber.QuadPart;
            }
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
        }
    }except (RsExceptionFilter(L"RsGetFileId", GetExceptionInformation()))
    {

        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Returning %x.\n", retval));
    return(retval);
}


BOOLEAN
RsSetCancelRoutine(IN PIRP Irp,
                   IN PDRIVER_CANCEL CancelRoutine)
/*++

Routine Description:

    This routine is called to set up an Irp for cancel.  We will set the cancel routine
    and initialize the Irp information we use during cancel.

Arguments:

    Irp - This is the Irp we need to set up for cancel.

    CancelRoutine - This is the cancel routine for this irp.


Return Value:

    BOOLEAN - TRUE if we initialized the Irp, FALSE if the Irp has already
        been marked cancelled.  It will be marked cancelled if the user
        has cancelled the irp before we could put it in the queue.

--*/
{

    KIRQL Irql;
    BOOLEAN retval = TRUE;

    //
    //  Assume that the Irp has not been cancelled.
    //
    IoAcquireCancelSpinLock( &Irql );

    if (!Irp->Cancel) {
        IoMarkIrpPending( Irp );
        IoSetCancelRoutine( Irp, CancelRoutine );
    } else {
        retval = FALSE;
    }
    IoReleaseCancelSpinLock( Irql );
    return retval;
}


BOOLEAN
RsClearCancelRoutine (
                     IN PIRP Irp
                     )

/*++

Routine Description:

    This routine is called to clear an Irp from cancel.  It is called when RsFilter is
    internally ready to continue processing the Irp.  We need to know if cancel
    has already been called on this Irp.  In that case we allow the cancel routine
    to complete the Irp.

Arguments:

    Irp - This is the Irp we want to process further.

Return Value:

    BOOLEAN - TRUE if we can proceed with processing the Irp,  FALSE if the cancel
        routine will process the Irp.

--*/
{
    KIRQL   oldIrql;
    BOOLEAN retval = TRUE;

    IoAcquireCancelSpinLock(&oldIrql);
    //
    //  Check if the cancel routine has been called.
    //
    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
        //
        //  Let our cancel routine handle the Irp.
        //
        retval = FALSE;
    }

    IoReleaseCancelSpinLock(oldIrql);
    return retval;
}


LONG
RsExceptionFilter (
                  IN WCHAR *FunctionName,
                  IN PEXCEPTION_POINTERS ExceptionPointer
                  )

/*++

Routine Description:

    This routine logs the exception that occurred.

Arguments:

    Function name
    ExceptionPointer - Supplies the exception record to logged

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER

--*/
{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    WCHAR    name[256];

    DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsExceptionFilter %ws %p %X\n", FunctionName, ExceptionPointer->ExceptionRecord->ExceptionAddress, ExceptionCode));

#if DBG
    DbgPrint("RsFilter, excpetion in  %ws exception pointer %p exception address %p exception code %x\n", FunctionName, ExceptionPointer, ExceptionPointer->ExceptionRecord->ExceptionAddress, ExceptionCode);

    DbgBreakPoint();
#endif

    swprintf(name, L"%p - %.20ws", ExceptionPointer->ExceptionRecord->ExceptionAddress, FunctionName);

    RsLogError(__LINE__, AV_MODULE_RPFILFUN,
               ExceptionCode,
               AV_MSG_EXCEPTION,
               NULL,
               name);
    return EXCEPTION_EXECUTE_HANDLER;
}


VOID
RsInterlockedRemoveEntryList(PLIST_ENTRY Entry,
                             PKSPIN_LOCK Lock)
/*++

Routine Description

    Removes the supplied entry from the queue it is on

Arguments

    Entry -     Entry to be removed from the linked list (could be anywhere in the list)

    Lock -      Pointer to spinlock protecting the list

Return Value

    None

--*/
{
    KIRQL oldIrql;

    ExAcquireSpinLock(Lock, &oldIrql);
    RemoveEntryList(Entry);
    ExReleaseSpinLock(Lock, oldIrql);
}


PRP_IRP_QUEUE
RsDequeuePacket(
               IN PLIST_ENTRY Head,
               IN PKSPIN_LOCK Lock)
/*++

Routine Description

   Dequeues a pending IRP entry packet from the queue it is on

Arguments

    Head -      Pointer to the head of the queue

    Lock -      Pointer to spinlock protecting the list

Return Value

    Pointer to the next non-cancellable packet on the queue
    NULL if none can be found

--*/
{
    PRP_IRP_QUEUE entry;
    KIRQL         oldIrql;
    BOOLEAN       found = FALSE;

    ExAcquireSpinLock(Lock, &oldIrql);

    while (!IsListEmpty(Head)) {
        entry = (PRP_IRP_QUEUE) RemoveHeadList(Head);
        //
        // We found another packet. If this packet is
        // not already cancelled - then we are done
        //
        entry = CONTAINING_RECORD(entry,
                                  RP_IRP_QUEUE,
                                  list);

        if (RsClearCancelRoutine(entry->irp)) {
            //
            // This packet was not cancelled
            //
            found = TRUE;
            break;
        }
    }

    ASSERT ((!found) || !(entry->irp->Cancel));

    ExReleaseSpinLock(Lock, oldIrql);

    return(found ? entry : NULL);
}




NTSTATUS
RsCheckVolumeReadOnly (IN     PDEVICE_OBJECT FilterDeviceObject,
		       IN OUT PBOOLEAN       pbReturnedFlagReadOnly)

/*++

Routine Description:

    Determine if the target volume is writable

Arguments:

    FilterDeviceObject     - Filter Device Object for this filtered volume
    pbReturnedFlagReadOnly - output flag indicating if the volume is readonly


Return Value:

    0 If successful, non-zero if the test was not completed

Note:

--*/
{
    NTSTATUS                      retval                = STATUS_SUCCESS;
    POBJECT_NAME_INFORMATION      VolumeNameInfo        = NULL;
    PFILE_OBJECT                  VolumeFileObject      = NULL;
    HANDLE                        VolumeHandle          = NULL;
    BOOLEAN                       bObjectReferenced     = FALSE;
    BOOLEAN                       bHandleOpened         = FALSE;
    PDEVICE_EXTENSION             deviceExtension       = FilterDeviceObject->DeviceExtension;
    IO_STATUS_BLOCK               Iosb;
    OBJECT_ATTRIBUTES             objAttributes;
    ULONG                         ReturnedLength;
    UNICODE_STRING                ucsSlash;
    UNICODE_STRING                ucsRootDirectory;

    struct {
	FILE_FS_ATTRIBUTE_INFORMATION VolumeInformation;
	WCHAR                         VolumeNameBuffer [50];
    } FsAttributeInformationBuffer;


    PAGED_CODE();


    ucsRootDirectory.Buffer = NULL;
    ucsRootDirectory.Length = 0;

    RtlInitUnicodeString (&ucsSlash, L"\\");


    ASSERT (NULL != deviceExtension->RealDeviceObject);


    if (NT_SUCCESS (retval)) {

	retval = RsGenerateDevicePath (deviceExtension->RealDeviceObject, &VolumeNameInfo);

    }



    if (NT_SUCCESS (retval)) {

	ucsRootDirectory.MaximumLength = VolumeNameInfo->Name.Length + ucsSlash.Length + sizeof (UNICODE_NULL);
	ucsRootDirectory.Buffer        = ExAllocatePoolWithTag (NonPagedPool, ucsRootDirectory.MaximumLength, RP_RD_TAG);


	if (NULL == ucsRootDirectory.Buffer) {

	    retval = STATUS_INSUFFICIENT_RESOURCES;

	}
    }



    if (NT_SUCCESS (retval)) {

	RtlCopyUnicodeString (&ucsRootDirectory, &VolumeNameInfo->Name);
	RtlAppendUnicodeStringToString (&ucsRootDirectory, &ucsSlash);

	InitializeObjectAttributes (&objAttributes,
				    &ucsRootDirectory,
				    OBJ_KERNEL_HANDLE,
				    NULL,
				    NULL);


	retval = IoCreateFileSpecifyDeviceObjectHint (&VolumeHandle, 
						      FILE_READ_ATTRIBUTES | SYNCHRONIZE,
						      &objAttributes, 
						      &Iosb, 
						      NULL,
						      0L,
						      FILE_SHARE_DELETE,
						      FILE_OPEN,
						      FILE_SYNCHRONOUS_IO_NONALERT,
						      NULL,
						      0,
						      CreateFileTypeNone,
						      NULL,
						      IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING,
						      deviceExtension->FileSystemDeviceObject);

	bHandleOpened = NT_SUCCESS (retval);
    }


    if (NT_SUCCESS (retval)) {

	retval = ObReferenceObjectByHandle (VolumeHandle,
					    FILE_READ_ATTRIBUTES,
					    *IoFileObjectType,
					    KernelMode,
					    &VolumeFileObject,
					    NULL);

	bObjectReferenced = NT_SUCCESS (retval);

    }



    if (NT_SUCCESS (retval)) {

	retval = IoQueryVolumeInformation (VolumeFileObject,
					   FileFsAttributeInformation,
					   sizeof (FsAttributeInformationBuffer),
					   &FsAttributeInformationBuffer,
					   &ReturnedLength);

    }


    if (NT_SUCCESS (retval)) {

	ASSERT (ReturnedLength >= sizeof (FsAttributeInformationBuffer.VolumeInformation));

	*pbReturnedFlagReadOnly = (0 != (FsAttributeInformationBuffer.VolumeInformation.FileSystemAttributes & 
					 FILE_READ_ONLY_VOLUME));

    }



    if (bObjectReferenced) {
	ObDereferenceObject (VolumeFileObject);
    }

    if (bHandleOpened) {
        ZwClose (VolumeHandle);
    }

    if (NULL != ucsRootDirectory.Buffer) {
        ExFreePool (ucsRootDirectory.Buffer);
    }

    if (NULL != VolumeNameInfo) {
	ExFreePool (VolumeNameInfo);
    }


    return (retval);
}


NTSTATUS RsTraceInitialize (ULONG ulRequestedTraceEntries)
    {
    NTSTATUS			status      = STATUS_SUCCESS;
    PRP_TRACE_CONTROL_BLOCK	tcb         = NULL;


    if ((NULL == RsTraceControlBlock) && (ulRequestedTraceEntries > 0))
	{
	tcb = (PRP_TRACE_CONTROL_BLOCK) ExAllocatePoolWithTag (NonPagedPool,
							       sizeof (RP_TRACE_CONTROL_BLOCK),
							       RP_TC_TAG);

	status = (NULL == tcb) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;


	if (NT_SUCCESS (status))
	    {
	    KeInitializeSpinLock (&tcb->Lock);

	    tcb->EntryNext    = 0;
	    tcb->EntryMaximum = ulRequestedTraceEntries;
	    tcb->EntryBuffer  = (PRP_TRACE_ENTRY) ExAllocatePoolWithTag (NonPagedPool,
									 sizeof (RP_TRACE_ENTRY) * ulRequestedTraceEntries,
									 RP_TE_TAG);

	    status = (NULL == tcb->EntryBuffer) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;
	    }


	if (NT_SUCCESS (status))
	    {
	    RsTraceControlBlock = tcb;
	    tcb = NULL;
	    }
	}


    if (NULL != tcb)
	{
	if (NULL != tcb->EntryBuffer) ExFreePool (tcb->EntryBuffer);

	ExFreePool (tcb);
	}


    return (status);
    }


/*
** Add a trace entry to the trace buffer.
*/
VOID RsTraceAddEntry (RpModuleCode ModuleCode,
		      USHORT       usLineNumber,
		      ULONG_PTR    Value1,
		      ULONG_PTR    Value2,
		      ULONG_PTR    Value3,
		      ULONG_PTR    Value4)
    {
    PRP_TRACE_ENTRY		teb;
    PRP_TRACE_CONTROL_BLOCK	tcb = RsTraceControlBlock;
    LARGE_INTEGER		Timestamp;
    KIRQL			PreviousIpl;


    if (NULL != tcb)
	{
	KeQuerySystemTime (&Timestamp);

	KeAcquireSpinLock (&tcb->Lock, &PreviousIpl);

	if (tcb->EntryNext >= tcb->EntryMaximum) 
	    {
	    tcb->EntryNext = 0;
	    }

	teb = &tcb->EntryBuffer [tcb->EntryNext];

	teb->ModuleCode   = ModuleCode;
	teb->usLineNumber = usLineNumber;
	teb->usIrql       = (USHORT) PreviousIpl;
	teb->Timestamp    = Timestamp;
	teb->Value1       = Value1;
	teb->Value2       = Value2;
	teb->Value3       = Value3;
	teb->Value4       = Value4;

	tcb->EntryNext++;

	KeReleaseSpinLock (&tcb->Lock, PreviousIpl);
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\filter\rpsec.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpSec.c

Abstract:

    This module contains security related support routines for the HSM file system filter.

Author:

    Rick Winter

Environment:

    Kernel mode


Revision History:

    1998:
    Ravisankar Pudipeddi   (ravisp) 
        
--*/

#include "pch.h"

NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
             PSID Sid
             );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid (
            PSID Sid1,
            PSID Sid2
            );

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, RsGetUserInfo)
#endif

VOID
RsGetUserInfo(
              IN  PSECURITY_SUBJECT_CONTEXT SubjectContext,
              OUT PRP_USER_SECURITY_INFO    UserSecurityInfo)
{
   NTSTATUS            status;
   char                *tBuff;
   PTOKEN_USER         user;
   PTOKEN_STATISTICS   stats;
   PTOKEN_SOURCE       source;
   BOOLEAN             lProc = FALSE;
   ULONG               ix;
   PACCESS_TOKEN       token;

   PAGED_CODE();

   token = SeQuerySubjectContextToken(SubjectContext);

   user = NULL;
   status = SeQueryInformationToken(token, TokenUser, &user);

   if ((NT_SUCCESS(status)) && (NULL != user)) {
      UserSecurityInfo->userInfoLen = RtlLengthSid(user->User.Sid);
      tBuff = (char *) ExAllocatePoolWithTag(NonPagedPool, 
                                             UserSecurityInfo->userInfoLen, 
                                             RP_SE_TAG);
      if (NULL == tBuff) {
         RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                    AV_MSG_USER_ERROR, NULL, NULL);
         UserSecurityInfo->userInfoLen = 0;
         UserSecurityInfo->userInfo = NULL;
      } else {
         RtlCopyMemory(tBuff, user->User.Sid, UserSecurityInfo->userInfoLen);
         UserSecurityInfo->userInfo = tBuff;
      }

      ExFreePool(user);
   } else {
      // Unable to get user info
      RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                 AV_MSG_USER_ERROR, NULL, NULL);
      UserSecurityInfo->userInfoLen = 0;
      UserSecurityInfo->userInfo = NULL;
   }

   UserSecurityInfo->isAdmin = SeTokenIsAdmin(token);

   stats = NULL;
   status = SeQueryInformationToken(token, TokenStatistics, &stats);
   if ((NT_SUCCESS( status )) && (NULL != stats) ) {
      RtlCopyLuid(&UserSecurityInfo->userInstance, &stats->TokenId);
      RtlCopyLuid(&UserSecurityInfo->userAuthentication, &stats->AuthenticationId);
      UserSecurityInfo->localProc = lProc;
      ExFreePool(stats);
   } else {
      UserSecurityInfo->userInstance.LowPart = 0L;
      UserSecurityInfo->userInstance.HighPart = 0L;
      UserSecurityInfo->userAuthentication.LowPart = 0L;
      UserSecurityInfo->userAuthentication.HighPart = 0L;
      RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                 AV_MSG_USER_ERROR, NULL, NULL);
   }

   source = NULL;
   strcpy(UserSecurityInfo->tokenSource, "???");
   status = SeQueryInformationToken(token, TokenSource, &source);
   if ((NT_SUCCESS( status )) && (NULL != source)) {
      RtlCopyLuid(&UserSecurityInfo->tokenSourceId, &source->SourceIdentifier);
      strncpy(UserSecurityInfo->tokenSource, source->SourceName, TOKEN_SOURCE_LENGTH);
      ExFreePool(source);
      //
      // Remove trailing spaces from the source name and NULL terminate it
      //
      ix = TOKEN_SOURCE_LENGTH - 1;
      UserSecurityInfo->tokenSource[ix] = '\0';
      ix--;
      while (UserSecurityInfo->tokenSource[ix] == ' ') {
         UserSecurityInfo->tokenSource[ix] = '\0';
         ix--;
      }

   } else {
      UserSecurityInfo->tokenSourceId.LowPart = 0L;
      UserSecurityInfo->tokenSourceId.HighPart = 0L;
      strcpy(UserSecurityInfo->tokenSource, "N/A");
      RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                 AV_MSG_USER_ERROR, NULL, NULL);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\filter\rpfilter.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2001
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFilter.c

Abstract:

    This module contains the code that traps file access activity for
    the HSM system.

Author:

    This is a modified version of a sample program provided by
    Darryl E. Havens (darrylh) 26-Jan-1995 (Microsoft).
    Modified by Rick Winter

Environment:

    Kernel mode


Revision History:

    1998:
    Ravisankar Pudipeddi   (ravisp)

	X-13	108353		Michael C. Johnson		 3-May-2001
		When checking a file to determine the type of recall also
		check a the potential target disk to see whether or not
		it is writable. This is necessary now that we have read-only
		NTFS volumes.

	X-12	322750		Michael C. Johnson		 1-Mar-2001
		Ensure pool for fast IO dispatch table is always released 
		following an error in DriverEntry() 

		194325
		Ensure that the completion routines for Mount and LoadFs do
		not call inappropriate routines at an elevated IRLQ

		360053
		Return STATUS_INSUFFICIENT_RESOURCES when we fail to allocate
		an mdl in RsRead().

	X-11	311579		Michael C. Johnson		16-Feb-2001
		When fetching object id's need to account for possible 
		unalignment of source. This matters on IA64.

	X-10	238109		Michael C. Johnson		 5-Dec-2000
		Change from using GUID form of reparse point to the non-GUID 
		form when handling FSCTL_SET_REPARSE_POINT

--*/

#include "pch.h"
#pragma   hdrstop
#include "initguid.h"
#include "rpguid.h"


#define IsLongAligned(P)    ((P) == ALIGN_DOWN_POINTER((P), ULONG))

NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
             PSID Sid
             );

ULONG     ExtendedDebug = 0;

#if DBG
   #define DBGSTATIC
   #undef ASSERTMSG
   #define ASSERTMSG(msg,exp) if (!(exp)) { DbgPrint("%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp); if (KD_DEBUGGER_ENABLED) { DbgBreakPoint(); } }
#else
   #define DBGSTATIC
   #undef ASSERTMSG
   #define ASSERTMSG(msg,exp)
#endif // DBG



extern KSPIN_LOCK               RsIoQueueLock;
extern KSPIN_LOCK               RsValidateQueueLock;
extern LIST_ENTRY               RsIoQHead;
extern LIST_ENTRY               RsValidateQHead;
extern LIST_ENTRY               RsFileContextQHead;
extern FAST_MUTEX               RsFileContextQueueLock;
extern ULONG                    RsFileObjId;
extern ULONG                    RsNoRecallDefault;
extern KSEMAPHORE               RsFsaIoAvailableSemaphore;


/* This must be set to TRUE to allow recalls */
ULONG         RsAllowRecalls = FALSE;

#if DBG
// Controls debug output
ULONG        RsTraceLevel = 0;            // Set via debugger or registry
#endif

//
// Define the device extension structure for this driver's extensions.
//

#define RSFILTER_DEVICE_TYPE   FILE_DEVICE_DISK_FILE_SYSTEM


//
// Hack for legacy backup clients to let them skip remote storage files
//
#define RSFILTER_SKIP_FILES_FOR_LEGACY_BACKUP_VALUE     L"SkipFilesForLegacyBackup"
ULONG   RsSkipFilesForLegacyBackup = 0;

//
// Media type determines whether we use cached/uncached no-recall path
// IMPORTANT: Keep these in sync with those defined in engcommn.h
//
#define RSENGINE_PARAMS_KEY           L"Remote_Storage_Server\\Parameters"
#define RSENGINE_MEDIA_TYPE_VALUE     L"MediaType"

//
// Media types that we recognize.
// IMPORTANT: Keep these in sync with those defined in engcommn.h
//
#define RS_SEQUENTIAL_ACCESS_MEDIA    0
#define RS_DIRECT_ACCESS_MEDIA        1

BOOLEAN RsUseUncachedNoRecall     =   FALSE;

//
// Define driver entry routine.
//

NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           );

//
// Define the local routines used by this driver module.  This includes a
// a sample of how to filter a create file operation, and then invoke an I/O
// completion routine when the file has successfully been created/opened.
//

NTSTATUS
RsInitialize(
    VOID
);

DBGSTATIC
NTSTATUS
RsPassThrough(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             );

DBGSTATIC
NTSTATUS
RsCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );


DBGSTATIC
NTSTATUS
RsCreateCheck(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context
             );


DBGSTATIC
NTSTATUS
RsOpenComplete(
              IN PDEVICE_OBJECT DeviceObject,
              IN PIRP Irp,
              IN PVOID Context
              );

DBGSTATIC
NTSTATUS
RsRead(
      IN PDEVICE_OBJECT DeviceObject,
      IN PIRP Irp
      );

DBGSTATIC
NTSTATUS
RsWrite(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       );

DBGSTATIC
NTSTATUS
RsShutdown(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          );


DBGSTATIC
NTSTATUS
RsCleanupFile(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             );

DBGSTATIC
NTSTATUS
RsClose(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       );

DBGSTATIC
NTSTATUS
RsRecallFsControl(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP  Irp
                 );

DBGSTATIC
NTSTATUS
RsFsControl(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           );

DBGSTATIC
NTSTATUS
RsFsControlMount(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
		);
DBGSTATIC
NTSTATUS
RsFsControlLoadFs(
		 IN PDEVICE_OBJECT DeviceObject,
		 IN PIRP Irp
		 );

DBGSTATIC
NTSTATUS
RsFsControlUserFsRequest (
		         IN PDEVICE_OBJECT DeviceObject,
		         IN PIRP Irp
		         );
DBGSTATIC
PVOID
RsMapUserBuffer (
                IN OUT PIRP Irp
                );

DBGSTATIC
VOID
RsFsNotification(
                IN PDEVICE_OBJECT DeviceObject,
                IN BOOLEAN FsActive
                );

DBGSTATIC
BOOLEAN
RsFastIoCheckIfPossible(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN BOOLEAN Wait,
                       IN ULONG LockKey,
                       IN BOOLEAN CheckForReadOperation,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoRead(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN ULONG Length,
            IN BOOLEAN Wait,
            IN ULONG LockKey,
            OUT PVOID Buffer,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            );

DBGSTATIC
BOOLEAN
RsFastIoWrite(
             IN PFILE_OBJECT FileObject,
             IN PLARGE_INTEGER FileOffset,
             IN ULONG Length,
             IN BOOLEAN Wait,
             IN ULONG LockKey,
             IN PVOID Buffer,
             OUT PIO_STATUS_BLOCK IoStatus,
             IN PDEVICE_OBJECT DeviceObject
             );

DBGSTATIC
BOOLEAN
RsFastIoQueryBasicInfo(
                      IN PFILE_OBJECT FileObject,
                      IN BOOLEAN Wait,
                      OUT PFILE_BASIC_INFORMATION Buffer,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      );

DBGSTATIC
BOOLEAN
RsFastIoQueryStandardInfo(
                         IN PFILE_OBJECT FileObject,
                         IN BOOLEAN Wait,
                         OUT PFILE_STANDARD_INFORMATION Buffer,
                         OUT PIO_STATUS_BLOCK IoStatus,
                         IN PDEVICE_OBJECT DeviceObject
                         );

DBGSTATIC
BOOLEAN
RsFastIoLock(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN PLARGE_INTEGER Length,
            PEPROCESS ProcessId,
            ULONG Key,
            BOOLEAN FailImmediately,
            BOOLEAN ExclusiveLock,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            );

DBGSTATIC
BOOLEAN
RsFastIoUnlockSingle(
                    IN PFILE_OBJECT FileObject,
                    IN PLARGE_INTEGER FileOffset,
                    IN PLARGE_INTEGER Length,
                    PEPROCESS ProcessId,
                    ULONG Key,
                    OUT PIO_STATUS_BLOCK IoStatus,
                    IN PDEVICE_OBJECT DeviceObject
                    );

DBGSTATIC
BOOLEAN
RsFastIoUnlockAll(
                 IN PFILE_OBJECT FileObject,
                 PEPROCESS ProcessId,
                 OUT PIO_STATUS_BLOCK IoStatus,
                 IN PDEVICE_OBJECT DeviceObject
                 );

DBGSTATIC
BOOLEAN
RsFastIoUnlockAllByKey(
                      IN PFILE_OBJECT FileObject,
                      PVOID ProcessId,
                      ULONG Key,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      );

DBGSTATIC
BOOLEAN
RsFastIoDeviceControl(
                     IN PFILE_OBJECT FileObject,
                     IN BOOLEAN Wait,
                     IN PVOID InputBuffer OPTIONAL,
                     IN ULONG InputBufferLength,
                     OUT PVOID OutputBuffer OPTIONAL,
                     IN ULONG OutputBufferLength,
                     IN ULONG IoControlCode,
                     OUT PIO_STATUS_BLOCK IoStatus,
                     IN PDEVICE_OBJECT DeviceObject
                     );


DBGSTATIC
VOID
RsFastIoDetachDevice(
                    IN PDEVICE_OBJECT SourceDevice,
                    IN PDEVICE_OBJECT TargetDevice
                    );

/* **** New Fast IO dispatch points for NT 4.x */


DBGSTATIC
BOOLEAN
RsFastIoQueryNetworkOpenInfo(
                            IN PFILE_OBJECT FileObject,
                            IN BOOLEAN Wait,
                            OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
                            OUT PIO_STATUS_BLOCK IoStatus,
                            IN PDEVICE_OBJECT DeviceObject
                            );

DBGSTATIC
NTSTATUS
RsFastIoAcquireForModWrite(
                          IN PFILE_OBJECT FileObject,
                          IN PLARGE_INTEGER EndingOffset,
                          OUT PERESOURCE *ResourceToRelease,
                          IN PDEVICE_OBJECT DeviceObject
                          );

DBGSTATIC
BOOLEAN
RsFastIoMdlRead(
               IN PFILE_OBJECT FileObject,
               IN PLARGE_INTEGER FileOffset,
               IN ULONG Length,
               IN ULONG LockKey,
               OUT PMDL *MdlChain,
               OUT PIO_STATUS_BLOCK IoStatus,
               IN PDEVICE_OBJECT DeviceObject
               );


DBGSTATIC
BOOLEAN
RsFastIoMdlReadComplete(
                       IN PFILE_OBJECT FileObject,
                       IN PMDL MdlChain,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoPrepareMdlWrite(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoMdlWriteComplete(
                        IN PFILE_OBJECT FileObject,
                        IN PLARGE_INTEGER FileOffset,
                        IN PMDL MdlChain,
                        IN PDEVICE_OBJECT DeviceObject
                        );

DBGSTATIC
BOOLEAN
RsFastIoReadCompressed(
                      IN PFILE_OBJECT FileObject,
                      IN PLARGE_INTEGER FileOffset,
                      IN ULONG Length,
                      IN ULONG LockKey,
                      OUT PVOID Buffer,
                      OUT PMDL *MdlChain,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                      IN ULONG CompressedDataInfoLength,
                      IN PDEVICE_OBJECT DeviceObject
                      );

DBGSTATIC
BOOLEAN
RsFastIoWriteCompressed(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       IN PVOID Buffer,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN  struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                       IN ULONG CompressedDataInfoLength,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoMdlReadCompleteCompressed(
                                 IN PFILE_OBJECT FileObject,
                                 IN PMDL MdlChain,
                                 IN PDEVICE_OBJECT DeviceObject
                                 );

DBGSTATIC
BOOLEAN
RsFastIoMdlWriteCompleteCompressed(
                                  IN PFILE_OBJECT FileObject,
                                  IN PLARGE_INTEGER FileOffset,
                                  IN PMDL MdlChain,
                                  IN PDEVICE_OBJECT DeviceObject
                                  );

DBGSTATIC
BOOLEAN
RsFastIoQueryOpen(
                 IN PIRP Irp,
                 OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
                 IN PDEVICE_OBJECT DeviceObject
                 );

DBGSTATIC
NTSTATUS
RsAsyncCompletion(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp,
                 IN PVOID Context
                 );

DBGSTATIC
NTSTATUS
RsPreAcquireFileForSectionSynchronization(
                                   IN  PFS_FILTER_CALLBACK_DATA Data,
                                   OUT PVOID *CompletionContext
                                 );

DBGSTATIC
VOID
RsPostAcquireFileForSectionSynchronization(
                                  IN    PFS_FILTER_CALLBACK_DATA Data,
                                  IN    NTSTATUS AcquireStatus,
                                  IN    PVOID CompletionContext
                                );
DBGSTATIC
VOID
RsPostReleaseFileForSectionSynchronization(
                                  IN  PFS_FILTER_CALLBACK_DATA Data,
                                  IN  NTSTATUS ReleaseStatus,
                                  IN  PVOID CompletionContext
                                );


NTSTATUS
RsFsctlRecallFile(IN PFILE_OBJECT FileObject);


NTSTATUS
RsRecallFile(IN PRP_FILTER_CONTEXT FilterContext);

NTSTATUS
RsQueryInformation(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  );
NTSTATUS
RsQueryInformationCompletion(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PVOID Context
                            );

//
// Global storage for this file system filter driver.
//

PDRIVER_OBJECT FsDriverObject;
PDEVICE_OBJECT FsDeviceObject;

ERESOURCE FsLock;

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT, DriverEntry)
   #pragma alloc_text(PAGE, RsCreate)
   #pragma alloc_text(PAGE, RsShutdown)
   #pragma alloc_text(PAGE, RsCleanupFile)
   #pragma alloc_text(PAGE, RsClose)
   #pragma alloc_text(PAGE, RsRecallFsControl)
   #pragma alloc_text(PAGE, RsFsControl)
   #pragma alloc_text(PAGE, RsFsControlMount)
   #pragma alloc_text(PAGE, RsFsControlLoadFs)
   #pragma alloc_text(PAGE, RsFsControlUserFsRequest)
   #pragma alloc_text(PAGE, RsFsNotification)
   #pragma alloc_text(PAGE, RsFastIoCheckIfPossible)
   #pragma alloc_text(PAGE, RsFastIoRead)
   #pragma alloc_text(PAGE, RsFastIoWrite)
   #pragma alloc_text(PAGE, RsFastIoQueryBasicInfo)
   #pragma alloc_text(PAGE, RsFastIoQueryStandardInfo)
   #pragma alloc_text(PAGE, RsFastIoLock)
   #pragma alloc_text(PAGE, RsFastIoUnlockSingle)
   #pragma alloc_text(PAGE, RsFastIoUnlockAll)
   #pragma alloc_text(PAGE, RsFastIoUnlockAllByKey)
   #pragma alloc_text(PAGE, RsFastIoDeviceControl)
   #pragma alloc_text(PAGE, RsFastIoDetachDevice)
   #pragma alloc_text(PAGE, RsFastIoQueryNetworkOpenInfo)
   #pragma alloc_text(PAGE, RsFastIoMdlRead)
   #pragma alloc_text(PAGE, RsFastIoPrepareMdlWrite)
   #pragma alloc_text(PAGE, RsFastIoMdlWriteComplete)
   #pragma alloc_text(PAGE, RsFastIoReadCompressed)
   #pragma alloc_text(PAGE, RsFastIoWriteCompressed)
   #pragma alloc_text(PAGE, RsFastIoQueryOpen)
   #pragma alloc_text(PAGE, RsFsctlRecallFile)
   #pragma alloc_text(PAGE, RsInitialize)
   #pragma alloc_text(PAGE, RsRecallFile)
   #pragma alloc_text(PAGE, RsQueryInformation)
   #pragma alloc_text(PAGE, RsCompleteRead)
   #pragma alloc_text(PAGE, RsPreAcquireFileForSectionSynchronization)
   #pragma alloc_text(PAGE, RsPostAcquireFileForSectionSynchronization)
   #pragma alloc_text(PAGE, RsPostReleaseFileForSectionSynchronization)
#endif

NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           )

/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
   UNICODE_STRING         nameString;
   UNICODE_STRING         symString;
   PDEVICE_OBJECT         deviceObject;
   PFILE_OBJECT           fileObject;
   NTSTATUS               status;
   PFAST_IO_DISPATCH      fastIoDispatch;
   ULONG                  i;
   PDEVICE_EXTENSION      deviceExtension;
   FS_FILTER_CALLBACKS    fsFilterCallbacks;

   UNREFERENCED_PARAMETER(RegistryPath);


   //
   // Create the device object.
   //

   RtlInitUnicodeString( &nameString, RS_FILTER_DEVICE_NAME);

   FsDriverObject = DriverObject;

   status = IoCreateDevice(
                          DriverObject,
                          sizeof( DEVICE_EXTENSION ),
                          &nameString,
                          FILE_DEVICE_DISK_FILE_SYSTEM,
                          FILE_DEVICE_SECURE_OPEN,
                          FALSE,
                          &deviceObject
                          );

   if (!NT_SUCCESS( status )) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "Error creating RsFilter device, error: %x\n", status ));
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_STARTUP, NULL, NULL);

      return status;
   }


   RtlInitUnicodeString( &symString, RS_FILTER_INTERNAL_SYM_LINK);
   status = IoCreateSymbolicLink(&symString, &nameString);
   if (!NT_SUCCESS( status )) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "Error creating symbolic link, error: %x\n", status ));
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_SYMBOLIC_LINK, NULL, NULL);

      IoDeleteDevice( deviceObject );
      return status;
   }

   FsDeviceObject = deviceObject;

   //
   // Initialize the driver object with this device driver's entry points.
   //

   for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
      DriverObject->MajorFunction[i] = RsPassThrough;
   }
   DriverObject->MajorFunction[IRP_MJ_CREATE] = RsCreate;
   DriverObject->MajorFunction[IRP_MJ_READ] = RsRead;
   DriverObject->MajorFunction[IRP_MJ_WRITE] = RsWrite;
   DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = RsShutdown;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] = RsCleanupFile;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] = RsClose;
   DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = RsFsControl;
   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = RsQueryInformation;

   //
   // Allocate fast I/O data structure and fill it in.
   //

   fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, sizeof( FAST_IO_DISPATCH ), RP_LT_TAG );
   if (!fastIoDispatch) {
      IoDeleteDevice( deviceObject );
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_STARTUP, NULL, NULL);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
   fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
   fastIoDispatch->FastIoCheckIfPossible = RsFastIoCheckIfPossible;
   fastIoDispatch->FastIoRead = RsFastIoRead;
   fastIoDispatch->FastIoWrite = RsFastIoWrite;
   fastIoDispatch->FastIoQueryBasicInfo = RsFastIoQueryBasicInfo;
   fastIoDispatch->FastIoQueryStandardInfo = RsFastIoQueryStandardInfo;
   fastIoDispatch->FastIoLock = RsFastIoLock;
   fastIoDispatch->FastIoUnlockSingle = RsFastIoUnlockSingle;
   fastIoDispatch->FastIoUnlockAll = RsFastIoUnlockAll;
   fastIoDispatch->FastIoUnlockAllByKey = RsFastIoUnlockAllByKey;
   fastIoDispatch->FastIoDeviceControl = RsFastIoDeviceControl;
   fastIoDispatch->FastIoDetachDevice = RsFastIoDetachDevice;
   fastIoDispatch->FastIoQueryNetworkOpenInfo = RsFastIoQueryNetworkOpenInfo;
   fastIoDispatch->MdlRead = RsFastIoMdlRead;
   fastIoDispatch->MdlReadComplete = RsFastIoMdlReadComplete;
   fastIoDispatch->PrepareMdlWrite = RsFastIoPrepareMdlWrite;
   fastIoDispatch->MdlWriteComplete = RsFastIoMdlWriteComplete;
   fastIoDispatch->FastIoReadCompressed = RsFastIoReadCompressed;
   fastIoDispatch->FastIoWriteCompressed = RsFastIoWriteCompressed;
   fastIoDispatch->MdlReadCompleteCompressed = RsFastIoMdlReadCompleteCompressed;
   fastIoDispatch->MdlWriteCompleteCompressed = RsFastIoMdlWriteCompleteCompressed;
   fastIoDispatch->FastIoQueryOpen = RsFastIoQueryOpen;

   DriverObject->FastIoDispatch = fastIoDispatch;

   //
   //  Setup the callbacks for the operations we receive through
   //  the FsFilter interface.
   //
   RtlZeroMemory(&fsFilterCallbacks, sizeof(FS_FILTER_CALLBACKS));

   fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
   fsFilterCallbacks.PreAcquireForSectionSynchronization = RsPreAcquireFileForSectionSynchronization;
   fsFilterCallbacks.PostAcquireForSectionSynchronization = RsPostAcquireFileForSectionSynchronization;
   fsFilterCallbacks.PostReleaseForSectionSynchronization = RsPostReleaseFileForSectionSynchronization;

   status = FsRtlRegisterFileSystemFilterCallbacks(DriverObject, &fsFilterCallbacks);

   if (!NT_SUCCESS( status )) {

       ExFreePool( fastIoDispatch );
       IoDeleteDevice( deviceObject );
       return status;
   }


   //
   // Initialize global data structures.
   //
   ExInitializeResourceLite( &FsLock );

   InitializeListHead(&RsIoQHead);
   InitializeListHead(&RsFileContextQHead);
   InitializeListHead(&RsValidateQHead);

   RsInitializeFileContextQueueLock();

   KeInitializeSpinLock(&RsIoQueueLock);
   KeInitializeSpinLock(&RsValidateQueueLock);


   //
   // Register this driver for watching file systems coming and going.
   //
   status = IoRegisterFsRegistrationChange( DriverObject, RsFsNotification );

   if (!NT_SUCCESS( status )) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Error registering FS change notification, error: %x\n", status ));
      ExFreePool( fastIoDispatch );
      IoDeleteDevice( deviceObject );
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_STARTUP, NULL, NULL);
      return status;
   }

   //
   // Indicate that the type for this device object is a primary, not a filter
   // device object so that it doesn't accidentally get used to call a file
   // system.
   //
   deviceExtension = deviceObject->DeviceExtension;
   deviceExtension->Type = 0;
   deviceExtension->Size = sizeof( DEVICE_EXTENSION );
   deviceExtension->WriteStatus = RsVolumeStatusUnknown;

   RtlInitUnicodeString( &nameString, (PWCHAR) L"\\Ntfs" );
   status = IoGetDeviceObjectPointer(
                                    &nameString,
                                    FILE_READ_ATTRIBUTES,
                                    &fileObject,
                                    &deviceObject
                                    );

   //
   // If NTFS was found then we must be starting while NT is up.
   // Try and attach now.
   //
   if (NT_SUCCESS( status )) {
      RsFsNotification( deviceObject, TRUE );
      ObDereferenceObject( fileObject );
   }
   //
   // Semaphore used to control access to the FSCTLs used for FSA-Filter communication
   // Set the limit to a few orders of magnitude more than  what the FSA could potentially
   // send
   //
   KeInitializeSemaphore(&RsFsaIoAvailableSemaphore,
                         0,
                         RP_MAX_RECALL_BUFFERS*1000);

   RsInitialize();
   RsCacheInitialize();

   RsTraceInitialize (RsDefaultTraceEntries);

   RsTrace0 (ModRpFilter);
   return STATUS_SUCCESS;
}


DBGSTATIC
NTSTATUS
RsPassThrough(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             )

/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to filter file system implementors:  This routine actually "passes"
    through the request by taking this driver out of the loop.  If the driver
    would like to pass the I/O request through, but then also see the result,
    then rather than essentially taking itself out of the loop it could keep
    itself in by copying the caller's parameters to the next stack location
    and then set its own completion routine.  Note that it's important to not
    copy the caller's I/O completion routine into the next stack location, or
    the caller's routine will get invoked twice.

    Hence, this code could do the following:

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    deviceExtension = DeviceObject->DeviceExtension;
    nextIrpSp = IoGetNextIrpStackLocation( Irp );

    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );
    IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );

    return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );

    This example actually NULLs out the caller's I/O completion routine, but
    this driver could set its own completion routine so that it could be
    notified when the request was completed.

    Note also that the following code to get the current driver out of the loop
    is not really kosher, but it does work and is much more efficient than the
    above.


--*/

{
   PDEVICE_EXTENSION deviceExtension;

   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
      return STATUS_INVALID_DEVICE_REQUEST;
   }
   //
   // Get this driver out of the driver stack and get to the next driver as
   // quickly as possible.
   //
   IoSkipCurrentIrpStackLocation (Irp);

   //
   // Now call the appropriate file system driver with the request.
   //

   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
}


DBGSTATIC
NTSTATUS
RsClose(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       )
{
   PDEVICE_EXTENSION    deviceExtension;
   PIO_STACK_LOCATION   currentStack;
   PRP_FILTER_CONTEXT   rpFilterContext;

   PAGED_CODE();


   //
   // Get a pointer to this driver's device extension for the specified
   // device.  Note that if the device being opened is the primary device
   // object rather than a filter device object, simply indicate that the
   // operation worked.
   //
   deviceExtension = DeviceObject->DeviceExtension;


   if (!deviceExtension->Type) {

      DebugTrace((DPFLTR_RSFILTER_ID,
                  DBG_VERBOSE, 
                  "RsFilter: Enter Close (Primary device) - devExt = %x\n", 
                  deviceExtension));


      Irp->IoStatus.Status      = STATUS_SUCCESS;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_DISK_INCREMENT );

      return STATUS_SUCCESS;

   } 


   currentStack = IoGetCurrentIrpStackLocation (Irp);

   DebugTrace((DPFLTR_RSFILTER_ID,
               DBG_VERBOSE, 
               "RsFilter: Enter Close (Filter device) - devExt = %x\n", 
               deviceExtension));


   //
   // Remove it from the queue if it was there
   //
   rpFilterContext = (PRP_FILTER_CONTEXT) FsRtlRemovePerStreamContext (FsRtlGetPerStreamContextPointer (currentStack->FileObject), FsDeviceObject, currentStack->FileObject);


   if (NULL != rpFilterContext) {

       ASSERT (currentStack->FileObject == ((PRP_FILE_OBJ)(rpFilterContext->myFileObjEntry))->fileObj);

       RsFreeFileObject ((PLIST_ENTRY) rpFilterContext);
   }



   //
   // Get this driver out of the driver stack and get to the next driver as
   // quickly as possible.
   //
   IoSkipCurrentIrpStackLocation (Irp);


   //
   // Now call the appropriate file system driver with the request.
   //
   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
}


DBGSTATIC
NTSTATUS
RsCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )

/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
   PIO_STACK_LOCATION     irpSp;
   PDEVICE_EXTENSION      deviceExtension;
   NTSTATUS               status;
   RP_PENDING_CREATE      pnding;
   PIO_STATUS_BLOCK       statusBlock;
   PRP_USER_SECURITY_INFO userSecurityInfo     = NULL;
   BOOLEAN                freeUserSecurityInfo = FALSE;
   BOOLEAN                bVolumeReadOnly      = FALSE;
   RP_VOLUME_WRITE_STATUS eNewVolumeWriteStatus;

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter Create\n"));

   PAGED_CODE();

   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_SUCCESS;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_DISK_INCREMENT );
      return STATUS_SUCCESS;
   }


   //
   // Get a pointer to the current stack location in the IRP.  This is where
   // the function codes and parameters are stored.
   //

   irpSp = IoGetCurrentIrpStackLocation( Irp );



   //
   // See if we have already determined the write status for this volume. 
   // If not then go ahead and do it now. Note that due to the way this is
   // synchronised the first few create calls might each try and make the
   // determination but only the first will succeed with the update. We
   // choose this to keep the normal path as light weight as possible.
   //
   if ((RsVolumeStatusUnknown == deviceExtension->WriteStatus) && !deviceExtension->AttachedToNtfsControlDevice) {

       status = RsCheckVolumeReadOnly (DeviceObject, &bVolumeReadOnly);

       if (NT_SUCCESS (status)) {

           eNewVolumeWriteStatus = (bVolumeReadOnly) 
					? RsVolumeStatusReadOnly
					: RsVolumeStatusReadWrite;

	   InterlockedCompareExchange ((volatile LONG *) &deviceExtension->WriteStatus, 
				       eNewVolumeWriteStatus, 
				       RsVolumeStatusUnknown);

       }
   }


   //
   // Simply copy this driver stack location contents to the next driver's
   // stack.
   // Set a completion routine to check for the reparse point error return.
   //

   IoCopyCurrentIrpStackLocationToNext( Irp);


   //
   // If the Fsa is loaded and the file is not being opened
   // with FILE_OPEN_REPARSE_POINT then set a completion routine
   //
   if (!(irpSp->Parameters.Create.Options & FILE_OPEN_REPARSE_POINT)) {


      RtlZeroMemory(&pnding, sizeof(RP_PENDING_CREATE));

      KeInitializeEvent(&pnding.irpCompleteEvent, SynchronizationEvent, FALSE);

      IoSetCompletionRoutine (Irp,
                              RsCreateCheck,
                              &pnding,
                              TRUE,        // Call on success
                              TRUE,        // fail
                              TRUE) ;      // and on cancel
      //
      //
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: create calling IoCallDriver (%x) (pending)\n", Irp));

      status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Leave create pending (%x)\n", Irp));
      //
      // We wait for the event to be set by the
      // completion routine.
      //
      KeWaitForSingleObject( &pnding.irpCompleteEvent,
                             UserRequest,
                             KernelMode,
                             FALSE,
                             (PLARGE_INTEGER) NULL );

      if (pnding.flags & RP_PENDING_RESEND_IRP) {
         //
         // If we need to reissue the IRP then do so now.
         //
         userSecurityInfo = ExAllocatePoolWithTag(PagedPool,
                                                  sizeof(RP_USER_SECURITY_INFO),
                                                  RP_SE_TAG);
         if (userSecurityInfo == NULL) {
             Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
             Irp->IoStatus.Information = 0;
             IoCompleteRequest( Irp, IO_DISK_INCREMENT );
             return STATUS_INSUFFICIENT_RESOURCES;
         }

         freeUserSecurityInfo = TRUE;

         RsGetUserInfo(&(irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext),
                    userSecurityInfo);

         KeClearEvent(&pnding.irpCompleteEvent);

         //
         // Completion routine has already been set for us.
         //
         statusBlock = Irp->UserIosb;
         status = IoCallDriver(deviceExtension->FileSystemDeviceObject,
                               Irp);

         if (((pnding.flags & RP_PENDING_NO_OPLOCK) ||
              (pnding.flags & RP_PENDING_IS_RECALL) ||
              (pnding.flags & RP_PENDING_RESET_OFFLINE))) {

            if (status == STATUS_PENDING) {
               //
               // We have to wait for the create IRP to finish in this case.
               //
               (VOID) KeWaitForSingleObject( &pnding.irpCompleteEvent,
                                             UserRequest,
                                             KernelMode,
                                             FALSE,
                                             (PLARGE_INTEGER) NULL );

               status = statusBlock->Status;
            }

            if (!NT_SUCCESS(status)) {
               ExFreePool(pnding.qInfo);
               RsFreeUserSecurityInfo(userSecurityInfo);
               return status;
            }

            if (pnding.flags & RP_PENDING_NO_OPLOCK) {
               status = RsAddFileObj(pnding.fileObject,
                                     DeviceObject,
                                     NULL,
                                     pnding.options);
            }

            if (NT_SUCCESS(status) && (pnding.flags & RP_PENDING_IS_RECALL) && (NULL != pnding.qInfo)) {
               PRP_CREATE_INFO qInfo;
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Queue a recall\n"));

               qInfo = pnding.qInfo;
               if (!NT_SUCCESS(status = RsAddQueue(qInfo->serial,
                                                   &pnding.filterId,
                                                   qInfo->options,
                                                   pnding.fileObject,
                                                   pnding.deviceObject,
                                                   DeviceObject,
                                                   &qInfo->rpData,
                                                   qInfo->rpData.data.dataStreamStart,
                                                   qInfo->rpData.data.dataStreamSize,
                                                   qInfo->fileId,
                                                   qInfo->objIdHi,
                                                   qInfo->objIdLo,
                                                   qInfo->desiredAccess,
                                                   userSecurityInfo))) {
                  //
                  //
                  // Some kind of error queueing the recall
                  // We have to fail the open but the file is already open -
                  // What do we do here?
                  // Answer: we call the new API IoCancelFileOpen
                  //
                  Irp->IoStatus.Status = status;
                  IoCancelFileOpen(deviceExtension->FileSystemDeviceObject,
                                   pnding.fileObject);
               } else {
                  //
                  // We will keep the user-info
                  //
                  freeUserSecurityInfo = FALSE;
               }
            }

            if (NT_SUCCESS(status) && (pnding.flags & RP_PENDING_RESET_OFFLINE)) {
               status = RsSetResetAttributes(pnding.fileObject,
                                             0,
                                             FILE_ATTRIBUTE_OFFLINE);
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: file opened for overwrite, reset FILE_ATTRIBUTE_OFFLINE,status of RsSetResetAttributes: %x\n",
                                     status));
               status = STATUS_SUCCESS;
            }
         }
      } else {
        status = Irp->IoStatus.Status;

      }

      if (freeUserSecurityInfo) {
         //
         // We can discard the cached user info
         //
         ASSERT (userSecurityInfo != NULL);
         RsFreeUserSecurityInfo(userSecurityInfo);

      }
      //
      // Finally free the qInfo allocated in RsCreateCheck
      //
      if (pnding.qInfo) {
         ExFreePool(pnding.qInfo);
      }
      //
      // This IRP never completed. Complete it now
      //
      IoCompleteRequest(Irp,
                        IO_NO_INCREMENT);
   } else {
      //
      // File opened with FILE_OPEN_REPARSE_POINT
      // Call the appropriate file system driver with the request.
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Open with FILE_OPEN_REPARSE_POINT - %x\n", irpSp->FileObject));
      IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );

      status =  IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
   }

   return status;
}


DBGSTATIC
NTSTATUS
RsCreateCheck(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context
             )

/*++

Routine Description:

   This completion routine will be called by the I/O manager when an
   file create request has been completed by a filtered driver. If the
   returned code is a reparse error and it is a HSM reparse point then
   we must set up for the recall and re-issue the open request.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the Irp that is being completed

   Context - Driver defined context - points to RP_PENDING_CREATE

Return Value:

   STATUS_SUCCESS           - Recall is complete
   STATUS_MORE_PROCESSING_REQUIRED  - Open request was sent back to file system
   STATUS_FILE_IS_OFFLINE   - File is offline and cannot be retrieved at this time


--*/

{
   PREPARSE_DATA_BUFFER  pHdr;
   PRP_DATA              pRpData;
   PIO_STACK_LOCATION    irpSp;
   PFILE_OBJECT          fileObject;
   ULONG                 dwRemainingNameLength;
   NTSTATUS              status;
   ULONG                 dwDisp;
   PDEVICE_EXTENSION     deviceExtension;
   ULONG                 qual;
   PRP_CREATE_INFO       qInfo;
   NTSTATUS              retval;
   LONGLONG              fileId;
   LONGLONG              objIdHi;
   LONGLONG              objIdLo;
   PRP_PENDING_CREATE    pnding;


   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter create completion\n"));

   pnding = (PRP_PENDING_CREATE) Context;

   if (Irp->IoStatus.Status != STATUS_REPARSE) {
      //
      // Propogate the IRP pending flag.
      //

      if (Irp->PendingReturned) {
         IoMarkIrpPending( Irp );
      }

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Leave create completion - no reparse\n"));
      KeSetEvent(&pnding->irpCompleteEvent, IO_NO_INCREMENT, FALSE);
      //
      // This packet would be completed by RsCreate
      //
      return(STATUS_MORE_PROCESSING_REQUIRED);
   }

   try {
      pHdr = (PREPARSE_DATA_BUFFER) Irp->Tail.Overlay.AuxiliaryBuffer;
      status = STATUS_SUCCESS;

      if (pHdr->ReparseTag == IO_REPARSE_TAG_HSM) {
         //
         // Insure that the reparse point data is at least the
         // minimum size we expect.
         //
         irpSp = IoGetCurrentIrpStackLocation( Irp );
         pRpData = (PRP_DATA) &pHdr->GenericReparseBuffer.DataBuffer;
         status = STATUS_FILE_IS_OFFLINE;
         //
         // Assume the data is invalid
         //
         Irp->IoStatus.Status = STATUS_FILE_IS_OFFLINE;

         if ((NULL != pRpData) &&
             (pHdr->ReparseDataLength >= sizeof(RP_DATA))) {
            //
            // Check the qualifier and signature
            //
            //
            // Clear the originator bit just in case.
            //
            RP_CLEAR_ORIGINATOR_BIT( pRpData->data.bitFlags );

            RP_GEN_QUALIFIER(pRpData, qual);
            if ((RtlCompareMemory(&pRpData->vendorId, &RP_MSFT_VENDOR_ID, sizeof(GUID)) == sizeof(GUID)) ||
                (pRpData->qualifier == qual)) {

               status = STATUS_MORE_PROCESSING_REQUIRED;

            } // Else error (STATUS_FILE_IS_OFFLINE;

         } // else error (STATUS_FILE_IS_OFFLINE);

         if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                       AV_MSG_DATA_ERROR, NULL, NULL);
         }

      } // Else pass it on (STATUS_SUCCESS)


      if (status == STATUS_MORE_PROCESSING_REQUIRED) {
         //
         // From here we need to process the Irp in some way.
         // Either pass it back to NTFS again or send it to the
         // HSM engine
         //

         deviceExtension = DeviceObject->DeviceExtension;
         dwRemainingNameLength = (ULONG) pHdr->Reserved; // Length of unparsed portion of the file name
         dwDisp = (irpSp->Parameters.Create.Options & 0xff000000) >> 24;
#ifdef IF_RICK_IS_RIGHT_ABOUT_REMOVING_THIS
         //
         // If they are opening the file without read or write access then we need to remember the
         // file object so we can fail oplocks
         //
         if ((RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) &&
             !(irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_HSM_ACTION_ACCESS) ) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Remember open of truncated file for non-data access\n"));
            pnding->Flags |= RP_PENDING_NO_OPLOCK;
            pnding->options = irpSp->Parameters.Create.Options;
         }
#endif
         pnding->fileObject = irpSp->FileObject;
         pnding->deviceObject = irpSp->FileObject->DeviceObject;
         //
         // If the unnamed datastream is being opened for read or write access and the disposition
         // is not overwrite or supercede then we have to recall it.
         //
         if ((dwRemainingNameLength == 0) &&
             (dwDisp != FILE_SUPERSEDE) && (dwDisp != FILE_OVERWRITE) && (dwDisp != FILE_OVERWRITE_IF) ) {
            //
            // Attempting to read or write the primary stream
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: HSM Reparse point was hit. Length = %u\n",
                                  pHdr->ReparseDataLength));

            retval = STATUS_SUCCESS;
            //
            // Check for legacy backup.
            // If it is backup intent, and caller has backup privilege,
            // and read only (no delete access), and the caller has not specified
            // FILE_OPEN_NO_RECALL or FILE_OPEN_REPARSE_POINT (this last is granted
            // because we don't have this completion routine in this case)
            // then it is legacy backup.
            // Now if the registry hack override says we should skip them, so we do.
            // If not we simply add FILE_OPEN_NO_RECALL flag to permit a deep-backup
            // without letting the files that are being backed up being recalled to disk
            //
            if ((irpSp->Parameters.Create.Options & FILE_OPEN_FOR_BACKUP_INTENT) &&
                (irpSp->Parameters.Create.SecurityContext->AccessState->Flags & TOKEN_HAS_BACKUP_PRIVILEGE) &&
                !(irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE)  &&
                !(irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA)) {

                if (RsSkipFilesForLegacyBackup && !RP_IS_NO_RECALL_OPTION(irpSp->Parameters.Create.Options) && (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags))) {
                    //
                    // Legacy backup and the file is offline
                    //
                    retval               = STATUS_ACCESS_DENIED;
                    Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
                } else {
                    //
                    // File is premigrated or it is not legacy backup
                    // We continue to set the NO_RECALL flag for premigrated files,
                    // it is harmless - because we don't really go to the tape for
                    // these files and ensure correctness for future
                    //
                    RP_SET_NO_RECALL_OPTION(irpSp->Parameters.Create.Options);
                }
            }



	    // If we are considering a recall of a truncated file then we should check that we 
	    // can actually repopulate the file, that is, the volume isn't read-only because 
	    // (say) it's a snapshot. If it is readonly then we should turn read requests into 
	    // 'no recall' requests and fail write requests.
	    //
            if (NT_SUCCESS (retval)                                        && 
		!RP_IS_NO_RECALL_OPTION (irpSp->Parameters.Create.Options) && 
		(RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags))             &&
		(RsVolumeStatusReadOnly == deviceExtension->WriteStatus)) {

		if ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA) ||
		    (irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE)) {

		    // Wanted write access to the file but this is a readonly volume. Something
		    // not quite right here.
		    //
		    retval               = STATUS_MEDIA_WRITE_PROTECTED;
                    Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;

		} else {

		    // Won't be able to put the file back on the volume so turn the request 
		    // into a 'no recall' request.
		    //
		    RP_SET_NO_RECALL_OPTION (irpSp->Parameters.Create.Options);

		}

            }



            if (NT_SUCCESS(retval)) {
               //
               // It is a HSM reparse point and needs a recall (or was opened no recall)
               //
               fileObject = irpSp->FileObject;
               if (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) {
                  //
                  // Note that we assume that a fileId or objectId of zero is never valid.
                  //
                  if (fileObject->FileName.Length == sizeof(LONGLONG)) {
                     //
                     // Open by file ID
                     //
                     fileId = * ((LONGLONG *) fileObject->FileName.Buffer);
                     objIdLo = 0;
                     objIdHi = 0;
                  } else {
                     //
                     // Must be open by object ID
                     //
                     objIdLo = * ((LONGLONG UNALIGNED *) &fileObject->FileName.Buffer[(fileObject->FileName.Length -      sizeof(LONGLONG))  / sizeof(WCHAR)]);
                     objIdHi = * ((LONGLONG UNALIGNED *) &fileObject->FileName.Buffer[(fileObject->FileName.Length - (2 * sizeof(LONGLONG))) / sizeof(WCHAR)]);
                     fileId = 0;
                  }

               } else {
                  fileId = 0;
               }
               //
               // If open no recall was requested - it had better be read only access
               // Write or delete access is not allowed.
               //
               if ((irpSp->Parameters.Create.Options & FILE_OPEN_NO_RECALL) &&
                   ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA) ||
                    (irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE))) {
                  retval = STATUS_INVALID_PARAMETER;
                  Irp->IoStatus.Status = retval;
               }
            }

            if (STATUS_SUCCESS == retval) {
               //
               // We have to place all files with our reparse point on the list of files to watch IO for.
               // It is possible that the file is pre-migrated now but will be truncated by the time the open
               // really completes (truncate on close).
               //
               // If this file is not premigrated, we have to mark the file object as
               // random acces to prevent cache read ahead.  Cache read ahead would
               // cause deadlocks when it attempted to read portions of the file
               // that have not been recalled yet.
               //
               if (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) {
                  irpSp->FileObject->Flags |= FO_RANDOM_ACCESS;
               }

               if ( RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags) &&
                    (FALSE == RsAllowRecalls) &&
                    (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_HSM_ACTION_ACCESS)) {
                  //
                  // Remote Storage system is not running and they wanted read/write data access.
                  //
                  status = STATUS_FILE_IS_OFFLINE;
                  Irp->IoStatus.Status = status;
               } else {
#if DBG
                  if (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) {
                     DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCreate: Open By ID\n"));
                  } else {
                     DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCreate: Open by name\n"));

                  }

                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Desired Access : %x\n",
                                        irpSp->Parameters.Create.SecurityContext->DesiredAccess));
#endif // DBG
                  //
                  // From here out we must use a worker thread
                  // because some of the calls cannot be used at dispatch level
                  //
                  if (qInfo = ExAllocatePoolWithTag( NonPagedPool, sizeof(RP_CREATE_INFO) , RP_WQ_TAG)) {

                     //
                     // Get the serial number from the file object or the device object
                     // in the file object or the device object passed in.
                     // If it is not in any of these places we have a problem.
                     //
                     if ((irpSp->FileObject != 0) && (irpSp->FileObject->Vpb != 0)) {
                        qInfo->serial = irpSp->FileObject->Vpb->SerialNumber;
                     } else if ((irpSp->DeviceObject != 0) && (irpSp->FileObject->DeviceObject->Vpb != 0)) {
                        qInfo->serial = irpSp->FileObject->DeviceObject->Vpb->SerialNumber;
                     } else if (DeviceObject->Vpb != 0) {
                        qInfo->serial = DeviceObject->Vpb->SerialNumber;
                     } else {
                        //
                        // ERROR - no volume serial number - this is fatal
                        //
                        qInfo->serial = 0;
                        RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                                   AV_MSG_SERIAL, NULL, NULL);
                     }
                     qInfo->options = irpSp->Parameters.Create.Options;
                     qInfo->irp = Irp;
                     qInfo->irpSp = irpSp;
                     qInfo->desiredAccess = irpSp->Parameters.Create.SecurityContext->DesiredAccess;

                     qInfo->fileId = fileId;
                     qInfo->objIdHi = objIdHi;
                     qInfo->objIdLo = objIdLo;
                     RtlMoveMemory(&qInfo->rpData, pRpData, sizeof(RP_DATA));

                     pnding->qInfo = qInfo;

                     qInfo->irpSp = IoGetCurrentIrpStackLocation( qInfo->irp );
                     qInfo->irpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

		     IoCopyCurrentIrpStackLocationToNext( qInfo->irp );


                     //
                     // We have to free the buffer here because NTFS will assert if
                     // it is not NULL and the IO system has not had the chance to
                     // free it.
                     //
                     ExFreePool(qInfo->irp->Tail.Overlay.AuxiliaryBuffer);
                     qInfo->irp->Tail.Overlay.AuxiliaryBuffer = NULL;

                     IoSetCompletionRoutine( qInfo->irp,
                                             RsOpenComplete,
                                             pnding,
                                             TRUE,        // Call on success
                                             TRUE,        // fail
                                             TRUE) ;      // and on cancel

                     pnding->flags |= RP_PENDING_IS_RECALL | RP_PENDING_RESEND_IRP;
                     status = STATUS_MORE_PROCESSING_REQUIRED;
                  } else {
                     //
                     // Failed to get memory for queue information
                     //
                     status = STATUS_INVALID_PARAMETER;
                     Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                     RsLogError(__LINE__, AV_MODULE_RPFILTER, sizeof(RP_CREATE_INFO),
                                AV_MSG_MEMORY, NULL, NULL);
                  }
               }
            }
         } else {
            //
            // There is a data stream or read/write data was not
            // specified so just open with FILE_OPEN_REPARSE_POINT
            //
            status = STATUS_MORE_PROCESSING_REQUIRED;
            irpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

	    IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine( Irp,
                                    RsOpenComplete,
                                    pnding,
                                    TRUE,        // Call on success
                                    TRUE,        // fail
                                    TRUE) ;      // and on cancel

            if (dwRemainingNameLength != 0) {
               //
               // A named data stream is being opened
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Opening datastream.\n"));
            } else {

               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Opening with FILE_OVERWRITE or FILE_OVERWRITE_IF or FILE_SUPERSEDE\n"));

               ASSERT ((dwDisp == FILE_OVERWRITE) || (dwDisp == FILE_OVERWRITE_IF) || (dwDisp == FILE_SUPERSEDE));

               if (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) {
                  //
                  // Indicate that we need to reset the FILE_ATTRIBUTE_OFFLINE here
                  // This is because the file is being over-written - hence we can clear
                  // this attribute safely if NTFS successfuly completes the open with
                  // these options
                  //
                  pnding->flags |= RP_PENDING_RESET_OFFLINE;
               }
            }
            //
            // We have to free the buffer here because NTFS will assert if
            // it is not NULL and the IO system has not had the chance to
            // free it.
            //
            ExFreePool(Irp->Tail.Overlay.AuxiliaryBuffer);

            Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
            pnding->flags |= RP_PENDING_RESEND_IRP;
         }
      }

      if (status != STATUS_MORE_PROCESSING_REQUIRED) {
         //
         // We want to pass the Irp untouched except we need to
         // Propogate the IRP pending flag.
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Irp as is\n"));

         if (Irp->PendingReturned) {
            IoMarkIrpPending( Irp );
         }

         if (status != STATUS_SUCCESS) {
            //
            // Irp status already set.
            //
            Irp->IoStatus.Information = 0;
         }
      } else {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Not our reparse point\n"));
      }

   }except (RsExceptionFilter(L"RsCreateCheck", GetExceptionInformation()) ) {
      //
      // Propogate the IRP pending flag.
      //

      if (Irp->PendingReturned) {
         IoMarkIrpPending( Irp );
      }
   }

   KeSetEvent(&pnding->irpCompleteEvent, IO_NO_INCREMENT, FALSE);

   return(STATUS_MORE_PROCESSING_REQUIRED);
}


DBGSTATIC
NTSTATUS
RsOpenComplete(
              IN PDEVICE_OBJECT DeviceObject,
              IN PIRP Irp,
              IN PVOID Context
              )

/*++

Routine Description:

   This completion routine will be called by the I/O manager when an
   file create request has been completed by a filtered driver. The file object is on the queue and
   we just need to get the rest of the information we need to fill in the entry before letting the
   application get it's handle.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the Irp that is being completed

   Context - Driver defined context - points to RP_PENDING_CREATE structure

Return Value:

   STATUS_SUCCESS


--*/

{
   PIO_STACK_LOCATION  irpSp;
   PRP_PENDING_CREATE  pnding;

   UNREFERENCED_PARAMETER(DeviceObject);

   pnding = (PRP_PENDING_CREATE) Context;

   irpSp = IoGetCurrentIrpStackLocation( Irp );

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsOpenComplete:  create options %x \n",irpSp->Parameters.Create.Options));

   if ((irpSp->FileObject) && RP_IS_NO_RECALL_OPTION(irpSp->Parameters.Create.Options)) {
      //
      // Do not support cached IO to this file
      //
      irpSp->FileObject->Flags &= ~FO_CACHE_SUPPORTED;
   }

   //
   // Propogate the IRP pending flag.
   //
   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }

   // Signal the mainline code that the open is now complete.

   KeSetEvent(&pnding->irpCompleteEvent, IO_NO_INCREMENT, FALSE);

   //
   // The IRP will be completed by RsCreate
   //
   return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
RsRead(
      IN PDEVICE_OBJECT DeviceObject,
      IN PIRP Irp
      )

/*++

Routine Description:

   This entry point is called any time than IRP_MJ_READ has been requested
   of the file system driver that this filter is layered on top of. This
   code is required to correctly set the parameters (in the Irp stack) and
   pass the Irp (after setting its stack location) down.

   The file system filter will accomplish these objectives by taking the
   following steps:

   1. Copy current Irp stack location to the next Irp stack location.
   2. If file was open with no recall option then return the data
      otherwise call the targeted file system.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the I/O request packet for this request

Return Value:

   The NTSTATUS returned from the filtered file system when called with this
   Irp.

--*/

{
   PIO_STACK_LOCATION          currentStack ;
   BOOLEAN                     pagingIo;
   PUCHAR                      buffer;
   LARGE_INTEGER               offset, length;
   PRP_DATA                    pRpData;
   NTSTATUS                    status = STATUS_SUCCESS;
   POBJECT_NAME_INFORMATION    str;
   LONGLONG                    fileId;
   LONGLONG                    objIdHi;
   LONGLONG                    objIdLo;
   ULONG                       options;
   PDEVICE_EXTENSION           deviceExtension;
   ULONGLONG                   filterId;
   USN                         usn;

   status = STATUS_SUCCESS;
   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_NO_INCREMENT );

      return STATUS_INVALID_DEVICE_REQUEST;
   }


   //
   // As the rest of this routine will need to know information contained
   // in the stack locations (current and next) of the Irp that is being
   // dealt with, get those pointers now.
   //
   currentStack = IoGetCurrentIrpStackLocation (Irp) ;

   //
   // If this is not one of ours we should bail out asap
   //

   if (RsIsFileObj(currentStack->FileObject, TRUE, &pRpData, &str, &fileId, &objIdHi, &objIdLo, &options, &filterId, &usn) == FALSE) {
      //
      // An operation which does not require data modification has been
      // encountered.
      //
      // Get this driver out of the driver stack and get to the next driver as
      // quickly as possible.
      //

      IoSkipCurrentIrpStackLocation (Irp);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Untouched read\n"));
      return(IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp ));
   }
   //
   // Check if the file needs to be recalled...
   //
   if (!RP_IS_NO_RECALL_OPTION(options)) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Read: Offset = %I64x size = %u File Obj = %x.\n",
                            currentStack->Parameters.Read.ByteOffset.QuadPart,
                            currentStack->Parameters.Read.Length,
                            currentStack->FileObject));

      if ((status = RsCheckRead(Irp, currentStack->FileObject, deviceExtension)) == STATUS_SUCCESS) {
         //
         // Pass the read to the file system
         //
         IoSkipCurrentIrpStackLocation (Irp);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Read: Offset = %x%x size = %u.\n",
                             currentStack->Parameters.Read.ByteOffset.HighPart,
                             currentStack->Parameters.Read.ByteOffset.LowPart,
                             currentStack->Parameters.Read.Length));

         status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
      } else if (status == STATUS_PENDING) {
         //
         // It was queued until the data is recalled (or failed already) - return the status from RsCheckRead
         // Fall through to return the status
         //
      } else {
         //
         // Some error occurred: complete the IRP with the error status
         //
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0 ;
         IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
      }
   } else {
      //
      //
      // File was open no-recall - if it is pre-migrated then we need not go to the FSA for the data and can let the reads go.
      //
      if (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) {
         if (FALSE == RsAllowRecalls) {
            RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                       AV_MSG_FSA_ERROR, NULL, NULL);

            Irp->IoStatus.Status = STATUS_FILE_IS_OFFLINE;
            Irp->IoStatus.Information = 0 ;
            IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
            return(STATUS_FILE_IS_OFFLINE) ;
         }


         //
         // Get the current flag status of IRP_PAGING_IO
         //
         pagingIo = BooleanFlagOn (Irp->Flags, IRP_PAGING_IO) ;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Read (No Recall): Offset = %x%x size = %u Pageio = %u.\n",
                               currentStack->Parameters.Read.ByteOffset.HighPart,
                               currentStack->Parameters.Read.ByteOffset.LowPart,
                               currentStack->Parameters.Read.Length,
                               pagingIo));
         //
         // This is a read which requires action on the part of the file system
         // filter driver.
         //
         if (!pagingIo) {
            //
            // Set the buffer pointer to NULL so we know to lock the memory and get
            // the system address later.
            //
            buffer = NULL;

         } else {
            //
            // If it is paging IO we already have a locked down buffer so we can just
            // save away the system address.
            //
            buffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                                                  NormalPagePriority);

            if (buffer == NULL) {
               Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
               Irp->IoStatus.Information = 0 ;
               IoCompleteRequest (Irp, IO_NO_INCREMENT);
	       return(STATUS_INSUFFICIENT_RESOURCES);
            }
         }


         //
         // Now that the a virtual address valid in system space has been obtained
         // for the user buffer, call the support routine to get the data
         //

         offset.QuadPart = currentStack->Parameters.Read.ByteOffset.QuadPart;
         length.QuadPart = currentStack->Parameters.Read.Length;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: read...\n"));

         Irp->IoStatus.Information = 0;      // Initialize in case partial data is returned.

         if (!RsUseUncachedNoRecall) {
            //
            // Use cached no-recall path
            //
            status = RsGetNoRecallData(currentStack->FileObject,
                                       Irp,
                                       usn,
                                       offset.QuadPart,
                                       length.QuadPart,
                                       buffer);
         }  else {
             //
             // Use non-cached no-recall path
             //
             if (buffer == NULL) {
                //
                // We need to get an MDL for the user buffer (this is not paging i/o,
                // so the pages are not locked down)
                //
                ASSERT (Irp->UserBuffer);

                Irp->MdlAddress = IoAllocateMdl(
                                            Irp->UserBuffer,
                                            currentStack->Parameters.Read.Length,
                                            FALSE,
                                            FALSE,
                                            NULL) ;
                if (!Irp->MdlAddress) {
                    //
                    // A resource problem has been encountered. Set appropriate status
                    // in the Irp, and begin the completion process.
                    //
                   DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckRead - norecall - Unable to allocate an MDL for user buffer %x\n", (PUCHAR) Irp->UserBuffer));

                   status = STATUS_INSUFFICIENT_RESOURCES;
                }
              }
              if (NT_SUCCESS(status)) {
                    status = RsQueueNoRecall(
                                         currentStack->FileObject,
                                         Irp,
                                         offset.QuadPart,
                                         length.QuadPart,
                                         0,
                                         currentStack->Parameters.Read.Length,
                                         NULL,
                                         //
                                         // RsQueueNoRecall expects the buffer to be NULL
                                         // (and a valid Irp->MdlAddress) if the pages needed
                                         // to be locked down - if not it uses the
                                         // supplied buffer pointer to copy the data to.
                                         //
                                         buffer);

             }

         }

         if (status != STATUS_PENDING) {
            //
            // Failed to queue the recall
            //
            if (status != STATUS_SUCCESS) {
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetNoRecallData Failed to queue the request, status 0x%X\n", status));
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
            //
            // Fall through to return the status
            //
         } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: read returning pending\n"));
         }
      } else {
         //
         // Pass the read to the file system (file is pre-migrated)
         //
         IoSkipCurrentIrpStackLocation (Irp);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Read: Offset = %x%x size = %u.\n",
                             currentStack->Parameters.Read.ByteOffset.HighPart,
                             currentStack->Parameters.Read.ByteOffset.LowPart,
                             currentStack->Parameters.Read.Length));

         status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
      }
   }

   return(status);

}


VOID
RsCompleteRead(IN PRP_IRP_QUEUE ReadIo,
               IN BOOLEAN Unlock)
/*++
Routine Description

   Completes the passed in no-recall Irp and unlocks any buffers & frees the Mdl
   if necessary

Arguments

   ReadIo - pointer to the RP_IRP_QUEUE entry for the IRP
   Unlock - If TRUE, the pages mapped by Irp->MdlAddress will be unlocked

Return Value

   None
--*/
{
   BOOLEAN                 pagingIo, synchronousIo;
   PIO_STACK_LOCATION      currentStack ;
   PIRP                    irp = NULL;

   PAGED_CODE();

   try {

      irp = ReadIo->irp;

      currentStack = IoGetCurrentIrpStackLocation (irp) ;
      pagingIo = BooleanFlagOn (irp->Flags, IRP_PAGING_IO) ;
      synchronousIo = BooleanFlagOn( currentStack->FileObject->Flags, FO_SYNCHRONOUS_IO );

      if (ReadIo->cacheBuffer) {
         //
         // This is a cached no-recall-read
         // Indicate to RsCache that this transfer is complete
         //
         RsCacheFsaIoComplete(ReadIo,
                              irp->IoStatus.Status);
      }

      if (!pagingIo) {
         //
         // Now that the data has been filled in, unmap the MDL so that
         // the data will be updated.
         //
         if (Unlock) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Unlock buffer....\n"));
            MmUnlockPages (irp->MdlAddress) ;
         }
         IoFreeMdl(irp->MdlAddress);
         irp->MdlAddress = NULL;
      }

      if (synchronousIo) {
         //
         // Change the current byte offset in the file object
         //
         currentStack->FileObject->CurrentByteOffset.QuadPart += irp->IoStatus.Information;
      }

      if (irp->IoStatus.Status != STATUS_SUCCESS) {
         irp->IoStatus.Information = 0;
      }

   }except (RsExceptionFilter(L"RsCompleteRead", GetExceptionInformation()) ) {
   }
   //
   // Everything has been unwound now. So, complete the irp.
   //
   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Completing read (%x) with status of %x.\n", irp, irp->IoStatus.Status));

   IoCompleteRequest (irp, IO_NO_INCREMENT) ;
}


NTSTATUS
RsWrite(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       )

/*++

Routine Description:

   This entry point is called any time than IRP_MJ_WRITE has been requested
   of the file system driver that this filter is layered on top of. This
   code is required to correctly set the parameters (in the Irp stack) and
   pass the Irp (after setting its stack location) down.

   The file system filter will accomplish these objectives by taking the
   following steps:

   1. Copy current Irp stack location to the next Irp stack location.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the I/O request packet for this request

Return Value:

   The NTSTATUS returned from the filtered file system when called with this
   Irp.

--*/

{
   PIO_STACK_LOCATION          currentStack ;
   NTSTATUS                    status;
   PDEVICE_EXTENSION           deviceExtension;
   BOOLEAN                     pagingIo;

   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_NO_INCREMENT );

      return STATUS_INVALID_DEVICE_REQUEST;
   }
   //
   // As the rest of this routine will need to know information contained
   // in the stack locations (current and next) of the Irp that is being
   // dealt with, get those pointers now.
   //

   currentStack = IoGetCurrentIrpStackLocation (Irp) ;

   //
   // If this is paging i/o, or not one of ours we should bail out asap
   //
   pagingIo = BooleanFlagOn(Irp->Flags, IRP_PAGING_IO);

   if (pagingIo || (RsIsFileObj(currentStack->FileObject, FALSE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == FALSE)) {
      //
      //
      // Get this driver out of the driver stack and get to the next driver as
      // quickly as possible.
      //

      IoSkipCurrentIrpStackLocation (Irp);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Untouched write\n"));
      return(IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp ));
   }
   //
   // It is a normal open - either queue the request or pass it on now.
   //
   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Write: Offset = %x%x size = %u File Obj = %x.\n",
                         currentStack->Parameters.Write.ByteOffset.HighPart,
                         currentStack->Parameters.Write.ByteOffset.LowPart,
                         currentStack->Parameters.Write.Length,
                         currentStack->FileObject));

   if ((status = RsCheckWrite(Irp, currentStack->FileObject, deviceExtension)) == STATUS_SUCCESS) {
      //
      // Pass the write to the file system
      //
      IoSkipCurrentIrpStackLocation (Irp);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Write: Offset = %x%x size = %u.\n",
                          currentStack->Parameters.Write.ByteOffset.HighPart,
                          currentStack->Parameters.Write.ByteOffset.LowPart,
                          currentStack->Parameters.Write.Length));

      status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
   } else if (status == STATUS_PENDING) {
      //
      // It was queued until the data is recalled (or failed already) - return the status from RsCheckWrite
      //
   } else {
      //
      // Some error occurred: complete the IRP with the error status
      //
      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0 ;
      IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
   }

   return(status);
}


DBGSTATIC
NTSTATUS
RsShutdown(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          )

/*++

Routine Description:
    System is shutting down - complete all outstanding device IO requests

Arguments:

    DeviceObject - Pointer to the target device object

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
   PDEVICE_EXTENSION     deviceExtension;


   PAGED_CODE();


   //
   // Get a pointer to this driver's device extension for the specified device.
   //
   deviceExtension = DeviceObject->DeviceExtension;


   //
   // Simply copy this driver stack location contents to the next driver's
   // stack.
   //
   IoCopyCurrentIrpStackLocationToNext( Irp );
   IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


   RsCancelRecalls();

   RsCancelIo();

   //
   // Now call the appropriate file system driver with the request.
   //

   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
}


DBGSTATIC
NTSTATUS
RsCleanupFile(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             )

/*++

Routine Description:

    This function filters file cleanup operations.  If the file object is on our list
    then we may need to do some additional cleanup.  All of this will only happen on
    the last cleanup on the file.  This consists of the following:

    For files opened without no-recall option:

        If the file was not written by the user then we need to preserve the dates and mark the
        USN source info. (Since it was written by us to recall it).

        If the file was written by the user we should (may?) remove the reparse point information and
        tell the FSA of the change.

        If the file has not been fully recalled yet ???? (other file objects may be waiting on it).

        If the recall had never started (or is being done on another file object) then we just remove the
        file object from the list and let it go.


    For files opened with the no-recall option:

        Just remove it from the list.



Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
   PDEVICE_EXTENSION           deviceExtension;

   PAGED_CODE();


   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_SUCCESS;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest( Irp, IO_DISK_INCREMENT );
      return STATUS_SUCCESS;
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: RsCleanup\n"));


   //
   // Simply copy this driver stack location contents to the next driver's
   // stack.
   //
   IoCopyCurrentIrpStackLocationToNext( Irp );
   IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Leave cleanup\n"));

   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );

}


DBGSTATIC
NTSTATUS
RsRecallFsControl(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP  Irp
                 )
/*++

Routine Description

   This handles all the recall-specific FSCTLs directed towards the primary device object
   for RsFilter
Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
   NTSTATUS                status;
   PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
   PRP_MSG                 msg;


   PAGED_CODE();

   switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

   case FSCTL_HSM_MSG: {
         //
         // This is an HSM specific message (METHOD_BUFFERED)
         //
         msg = (RP_MSG *) Irp->AssociatedIrp.SystemBuffer;
         if (msg == NULL) {
            status = STATUS_INVALID_USER_BUFFER;
            break;
         }
         status = STATUS_UNSUCCESSFUL;
         //
         // Make sure we can read the msg part
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - msg = %x.\n", msg));

         if (irpSp->Parameters.FileSystemControl.InputBufferLength >= sizeof(RP_MSG)) {
            switch (msg->inout.command) {

            case RP_GET_REQUEST: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTRL Wait for recall request\n"));
                  status = RsAddIo(Irp);

                  if (NT_SUCCESS(status)) {
                     status = STATUS_PENDING;
                  } else {
                     Irp->IoStatus.Information = 0;
                  }
                  break;
               }

            default: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Unknown FSCTL! (%u)\n",
                                        msg->inout.command));
                  /* Complete the fsctl request */
                  status = STATUS_INVALID_PARAMETER;
                  Irp->IoStatus.Information = 0;
                  break;
               }
            }
         } else {
            status = STATUS_INVALID_USER_BUFFER;
            Irp->IoStatus.Information = 0;
         }

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - Complete request (%u) - %x.\n",
                               Irp->IoStatus.Information,
                               status));
         break;
      }

   case FSCTL_HSM_DATA: {
         try {
            //
            // This is an HSM specific message (METHOD_NEITHER)
            //
            ULONG length;

            status = STATUS_UNSUCCESSFUL;

            if ((irpSp->Parameters.FileSystemControl.Type3InputBuffer == NULL) ||
                (irpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(RP_MSG))) {
               status = STATUS_INVALID_PARAMETER;
               break;
            }
            msg = (PRP_MSG) irpSp->Parameters.FileSystemControl.Type3InputBuffer;
            if (Irp->RequestorMode != KernelMode) {
               ProbeForWrite(msg,
                             sizeof(RP_MSG),
                             sizeof(UCHAR));
            };

            switch (msg->inout.command) {

            case RP_RECALL_COMPLETE: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Fsa action complete %I64x (%x)\n",
                                        msg->msg.rRep.filterId, msg->inout.status));
                  (VOID) RsCompleteRecall(DeviceObject,
                                          msg->msg.rRep.filterId,
                                          msg->inout.status,
                                          msg->msg.rRep.actionFlags,
                                          TRUE);
                  /* Complete the FSCTL request */
                  Irp->IoStatus.Information = 0;
                  status = STATUS_SUCCESS;
                  break;
               }
            case RP_SUSPEND_NEW_RECALLS: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Suspend new recalls\n"));
                  RsAllowRecalls = FALSE;
                  /* Complete the FSCTL request */
                  status = STATUS_SUCCESS;
                  break;
               }
            case RP_ALLOW_NEW_RECALLS: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Allow new recalls\n"));
                  RsAllowRecalls = TRUE;
                  //
                  // Reload the registry params
                  //
                  status = RsInitialize();
                  break;
               }

            case RP_CANCEL_ALL_RECALLS: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel all recalls\n"));
                  RsCancelRecalls();
                  /* Complete the FSCTL request */
                  status = STATUS_SUCCESS;
                  break;
               }

            case RP_CANCEL_ALL_DEVICEIO: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel all FSCTL\n"));
                  RsCancelIo();
                  /* Complete the FSCTL request */
                  status = STATUS_SUCCESS;
                  break;
               }

            case RP_PARTIAL_DATA: {

                  PMDL mdlAddress;
                  ULONG total;
                  //
                  // Check if the passed in parameters are valid
                  //
                  status = STATUS_SUCCESS;

                  total = msg->msg.pRep.offsetToData + msg->msg.pRep.bytesRead;

                  if ((total < msg->msg.pRep.offsetToData) || (total < msg->msg.pRep.bytesRead)) {
                     //
                     // Overflow
                     //
                     status = STATUS_INVALID_PARAMETER;
                     break;
                  }

                  if (irpSp->Parameters.FileSystemControl.InputBufferLength < total) {
                     DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Invalid buffer for RP_PARTIAL_DATA - %u \n", irpSp->Parameters.FileSystemControl.InputBufferLength));
                     status = STATUS_INVALID_USER_BUFFER;
                     break;
                  }
                  //
                  // Now map the user buffer to a system address, since
                  // we would be accessing it another process context
                  //
                  mdlAddress = IoAllocateMdl(msg,
                                             irpSp->Parameters.FileSystemControl.InputBufferLength,
                                             FALSE,
                                             FALSE,
                                             NULL);
                  if (!mdlAddress) {
                     status = STATUS_INSUFFICIENT_RESOURCES;
                     break;
                  }
                  //
                  // This is protected by the enclosing try-except for
                  // FsControl module
                  //
                  try {
                     MmProbeAndLockPages(mdlAddress,
                                         UserMode,
                                         IoReadAccess);
                  }except (EXCEPTION_EXECUTE_HANDLER) {
                       DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Unable to lock read buffer!.\n"));
                        RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                                   AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
                       IoFreeMdl(mdlAddress);
                       status = STATUS_INVALID_USER_BUFFER;
                  }

                  if (!NT_SUCCESS(status)) {
                    break;
                  }

                  //
                  // Update msg to point to the system address
                  //
                  msg = MmGetSystemAddressForMdlSafe(mdlAddress,
                                                     NormalPagePriority);

                  if (msg == NULL) {
                     IoFreeMdl(mdlAddress);
                     break;
                  }

                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Partial data for a recall on read %I64x (%u)\n",
                                        msg->msg.pRep.filterId, msg->inout.status));
                  status = RsPartialData(DeviceObject,
                                         msg->msg.pRep.filterId,
                                         msg->inout.status,
                                         (CHAR *) msg + msg->msg.pRep.offsetToData,
                                         msg->msg.pRep.bytesRead,
                                         msg->msg.pRep.byteOffset);

                  MmUnlockPages(mdlAddress);
                  IoFreeMdl(mdlAddress);
                  Irp->IoStatus.Information = 0;
                  break;
               }

            case RP_GET_RECALL_INFO: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Get Recall info for %I64x\n",
                                        msg->msg.riReq.filterId));

                  status = RsGetRecallInfo(msg,
                                           &Irp->IoStatus.Information,
                                           Irp->RequestorMode);
                  break;
               }

            default: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Unknown FSCTL! (%u)\n",
                                        msg->inout.command));
                  /* Complete the fsctl request */
                  status = STATUS_INVALID_PARAMETER;
                  Irp->IoStatus.Information = 0;
                  break;
               }

            }
         }except (RsExceptionFilter(L"RsFilter", GetExceptionInformation())) {
            ASSERTMSG("RsFilter: Exception occurred in processing msg\n",FALSE);
            status = STATUS_INVALID_USER_BUFFER;
         }
         break;
      }
   default: {
         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   }

   if (status != STATUS_PENDING) {
      Irp->IoStatus.Status = status;
      IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
   }

   return status;
}



DBGSTATIC
NTSTATUS
RsFsControl(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp            = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION   deviceExtension  = DeviceObject->DeviceExtension;


    PAGED_CODE();


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter FsControl\n"));


    if (!deviceExtension->Type) {
        //
	// This is for the primary device object
        //
        status = RsRecallFsControl(DeviceObject, Irp);

    } else {
	//
	// Begin by determining the minor function code for this file system control
	// function.
	//
	if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

	    status = RsFsControlMount (DeviceObject, Irp);


	} else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

	    status = RsFsControlLoadFs (DeviceObject, Irp);


	} else if (irpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) {

	    status = RsFsControlUserFsRequest (DeviceObject, Irp);


        } else {
            //
            // Not  a minor function we are interested in
            // Just get out of the way
            //
            IoSkipCurrentIrpStackLocation(Irp);

            status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
        }
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit FsControl\n"));

    return status;
}



DBGSTATIC
NTSTATUS
RsFsControlMount(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
		)
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp                    = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION   deviceExtension          = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION   NewFilterDeviceExtension = NULL;
    PDEVICE_OBJECT      NewFilterDeviceObject    = NULL;
    PDEVICE_OBJECT      pRealDevice              = NULL;
    PDEVICE_OBJECT	pTargetDevice            = NULL;
    KEVENT              CompletionEvent;
    PVPB		vpb;


    //
    // This is a mount request. Create a device object that can be
    // attached to the file system's volume device object if this request
    // is successful. We allocate this memory now since we can not return
    // an error in the completion routine.  
    //
    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Mount volume\n"));


    status = IoCreateDevice (FsDriverObject,
			     sizeof( DEVICE_EXTENSION ),
			     (PUNICODE_STRING) NULL,
			     FILE_DEVICE_DISK_FILE_SYSTEM,
			     0,
			     FALSE,
			     &NewFilterDeviceObject);


    if (!NT_SUCCESS (status)) {

        //
        // Something went wrong, we cannot filter this volume
        //
	DebugTrace ((DPFLTR_RSFILTER_ID, 
		     DBG_VERBOSE, 
		     "RsFilter: Mount volume - failed to create device object (0x%08x)\n",
		     status));

        IoSkipCurrentIrpStackLocation(Irp);

        status = IoCallDriver (deviceExtension->FileSystemDeviceObject, Irp);

    } else {

	//
	// Set up the completion context
	//
	// Note that we need to save the RealDevice object
	// pointed to by the vpb parameter because this vpb
	// may be changed by the underlying file system. Both
	// FAT and CDFS may change the VPB address if the
	// volume being mounted is one they recognize from a
	// previous mount.
	//
	pRealDevice = irpSp->Parameters.MountVolume.Vpb->RealDevice;

        KeInitializeEvent (&CompletionEvent, SynchronizationEvent, FALSE);

	IoCopyCurrentIrpStackLocationToNext( Irp );

	IoSetCompletionRoutine (Irp,
				RsAsyncCompletion,
				&CompletionEvent,
				TRUE,
				TRUE,
				TRUE);

        status = IoCallDriver (deviceExtension->FileSystemDeviceObject, Irp);

	if (STATUS_PENDING == status) {

            KeWaitForSingleObject (&CompletionEvent, UserRequest, KernelMode, FALSE, NULL);

	}



        if (NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            // Note that the VPB must be picked up from the target device object
            // in case the file system did a remount of a previous volume, in
            // which case it has replaced the VPB passed in as the target with
            // a previously mounted VPB.  
            //
            vpb = pRealDevice->Vpb;

            pTargetDevice = IoGetAttachedDevice( vpb->DeviceObject );


            NewFilterDeviceExtension = NewFilterDeviceObject->DeviceExtension;

            NewFilterDeviceExtension->RealDeviceObject       = vpb->RealDevice;
            NewFilterDeviceExtension->Attached               = TRUE;
            NewFilterDeviceExtension->Type                   = RSFILTER_DEVICE_TYPE;
            NewFilterDeviceExtension->Size                   = sizeof( DEVICE_EXTENSION );
            NewFilterDeviceExtension->WriteStatus            = RsVolumeStatusUnknown;
            NewFilterDeviceExtension->FileSystemDeviceObject = IoAttachDeviceToDeviceStack (NewFilterDeviceObject, pTargetDevice);

	    ASSERT (NULL != NewFilterDeviceExtension->FileSystemDeviceObject);


            NewFilterDeviceObject->Flags |= (NewFilterDeviceExtension->FileSystemDeviceObject->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO)); 
            NewFilterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        } else {

            //
            // The mount request failed.  Simply delete the device object that was
            // created in case this request succeeded.
            //
            FsRtlEnterFileSystem();
            ExAcquireResourceExclusiveLite( &FsLock, TRUE );
            IoDeleteDevice( NewFilterDeviceObject);
            ExReleaseResourceLite( &FsLock );
            FsRtlExitFileSystem();
        }


	status = Irp->IoStatus.Status;

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Mount volume exit 0x%08X\n", status));

    return (status);
}



DBGSTATIC
NTSTATUS
RsFsControlLoadFs(
		 IN PDEVICE_OBJECT DeviceObject,
		 IN PIRP Irp
		 )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    KEVENT              CompletionEvent;


    //
    // This is a load file system request being sent to a mini-file system
    // recognizer driver.  Detach from the file system now, and set
    // the address of a completion routine in case the function fails, in
    // which case a reattachment needs to occur.  Likewise, if the function
    // is successful, then the device object needs to be deleted.
    //
    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Load file system\n"));

    KeInitializeEvent (&CompletionEvent, SynchronizationEvent, FALSE);


    IoDetachDevice( deviceExtension->FileSystemDeviceObject );
    deviceExtension->Attached = FALSE;

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine (Irp,
			    RsAsyncCompletion,
			    &CompletionEvent,
			    TRUE,
			    TRUE,
			    TRUE);

    status = IoCallDriver (deviceExtension->FileSystemDeviceObject, Irp);

    if (STATUS_PENDING == status) {

        KeWaitForSingleObject (&CompletionEvent, UserRequest, KernelMode, FALSE, NULL);

    }



    //
    // Begin by determining whether or not the load file system request was
    // completed successfully.
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        // The load was not successful.  Simply reattach to the recognizer
        // driver in case it ever figures out how to get the driver loaded
        // on a subsequent call.
        //

        IoAttachDeviceToDeviceStack (DeviceObject, deviceExtension->FileSystemDeviceObject);
        deviceExtension->Attached = TRUE;

    } else {

        //
        // The load was successful.  However, in order to ensure that these
        // drivers do not go away, the I/O system has artifically bumped the
        // reference count on all parties involved in this manuever.  Therefore,
        // simply remember to delete this device object at some point in the
        // future when its reference count is zero.
        //
        FsRtlEnterFileSystem();
        ExAcquireResourceExclusiveLite( &FsLock, TRUE );
        IoDeleteDevice( DeviceObject);
        ExReleaseResourceLite( &FsLock );
        FsRtlExitFileSystem();
    }


    status = Irp->IoStatus.Status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Load file system exit 0x%08X\n", status));

    return (status);
}



DBGSTATIC
NTSTATUS
RsFsControlUserFsRequest (
		         IN PDEVICE_OBJECT DeviceObject,
		         IN PIRP Irp
		         )
{
    NTSTATUS                        status;
    PIO_STACK_LOCATION              irpSp                 = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION               deviceExtension       = DeviceObject->DeviceExtension;
    PRP_DATA                        pRpData;
    PRP_DATA                        tmpRp;
    PFILE_ALLOCATED_RANGE_BUFFER    CurrentBuffer;
    PFILE_ALLOCATED_RANGE_BUFFER    OutputBuffer;
    ULONG                           RemainingBytes;
    LONGLONG                        StartingOffset;
    LONGLONG                        Length;
    ULONG                           InputBufferLength;
    ULONG                           OutputBufferLength;
    PCHAR                           rpOutputBuffer;
    PREPARSE_DATA_BUFFER            pRpBuffer;
    LARGE_INTEGER                   fSize;
    PRP_MSG                         msg;



    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: FsCtl handler\n"));

    switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_HSM_MSG: {
            //
            // This is an HSM specific message (METHOD_BUFFERED)
            //
            msg = (RP_MSG *) Irp->AssociatedIrp.SystemBuffer;
            if (msg == NULL) {
                status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            status = STATUS_UNSUCCESSFUL;

            //
            // Make sure we can read the msg part
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - msg = %x.\n", msg));
            if (irpSp->Parameters.FileSystemControl.InputBufferLength >= sizeof(RP_MSG)) {
                switch (msg->inout.command) {
                    case RP_CHECK_HANDLE: {
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - Check Handle.\n"));
                        if (irpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(RP_MSG)) {
                            status = STATUS_BUFFER_TOO_SMALL;
                            Irp->IoStatus.Information = 0;
                        } else {
                            fSize.QuadPart = 0;
                            if ((irpSp->FileObject == NULL) || (irpSp->FileObject->SectionObjectPointer == NULL)) {
                                //
                                // If the wrong kind of handle is passed down
                                // like a volume handle, this could be NULL.
                                //
                                status = STATUS_INVALID_PARAMETER;
                            } else {
                                msg->msg.hRep.canTruncate =
                                MmCanFileBeTruncated(irpSp->FileObject->SectionObjectPointer,
                                                     &fSize);
                                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - returning %x.\n", msg->msg.hRep.canTruncate));
                                status = STATUS_SUCCESS;
                                Irp->IoStatus.Information = sizeof(RP_MSG);
                            }
                        }
                        break;
                    }
                    default: {
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: invalid RP_MSG (%u)\n",
                                              msg->inout.command));
                        status = STATUS_INVALID_PARAMETER;
                        Irp->IoStatus.Information = 0;
                        break;
                    }
                }
            } else {
                status = STATUS_INVALID_USER_BUFFER;
                Irp->IoStatus.Information = 0;
            }

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - Complete request (%u) - %x.\n",
                                  Irp->IoStatus.Information,
                                  status));
            if (status != STATUS_PENDING) {
                Irp->IoStatus.Status = status;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
            return status;
            break;
        }

        case FSCTL_QUERY_ALLOCATED_RANGES: {

            if (RsIsNoRecall(irpSp->FileObject, &pRpData) == TRUE) {

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFsControl Handling Query Allocated Ranges for %x\n", irpSp->FileObject));
                Irp->IoStatus.Information = 0;

                try {

                    status = STATUS_SUCCESS;
                    if (irpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(FILE_ALLOCATED_RANGE_BUFFER)) {
                        //
                        // Buffer too small
                        //
                        status = STATUS_INVALID_PARAMETER;
                    } else {
                        RemainingBytes = irpSp->Parameters.FileSystemControl.OutputBufferLength;
                        OutputBuffer = RsMapUserBuffer(Irp);
                        if (OutputBuffer != NULL) {
                            CurrentBuffer = OutputBuffer - 1;

                            if (Irp->RequestorMode != KernelMode) {
                                ProbeForRead( irpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                              irpSp->Parameters.FileSystemControl.InputBufferLength,
                                              sizeof( ULONG ));

                                ProbeForWrite( OutputBuffer, RemainingBytes, sizeof( ULONG ));

                            } else if (!IsLongAligned(irpSp->Parameters.FileSystemControl.Type3InputBuffer ) ||
                                       !IsLongAligned(OutputBuffer)) {
                                status = STATUS_INVALID_USER_BUFFER;
                                leave;
                            }
                            //
                            //  Carefully extract the starting offset and length from
                            //  the input buffer.  If we are beyond the end of the file
                            //  or the length is zero then return immediately.  Otherwise
                            //  trim the length to file size.
                            //

                            StartingOffset = ((PFILE_ALLOCATED_RANGE_BUFFER) irpSp->Parameters.FileSystemControl.Type3InputBuffer)->FileOffset.QuadPart;
                            Length = ((PFILE_ALLOCATED_RANGE_BUFFER) irpSp->Parameters.FileSystemControl.Type3InputBuffer)->Length.QuadPart;
                            //
                            //  Check that the input parameters are valid.
                            //

                            if ((Length < 0) ||
                                 (StartingOffset < 0) ||
                                 (Length > MAXLONGLONG - StartingOffset)) {

                                status = STATUS_INVALID_PARAMETER;
                                leave;
                            }
                            //
                            //  Check that the requested range is within file size
                            //  and has a non-zero length.
                            //

                            if (Length == 0) {
                                leave;
                            }

                            if (StartingOffset > pRpData->data.dataStreamSize.QuadPart) {
                                leave;
                            }

                            if (pRpData->data.dataStreamSize.QuadPart - StartingOffset < Length) {
                                Length = pRpData->data.dataStreamSize.QuadPart - StartingOffset;
                            }

                            // Now just say that the whole thing is there

                            if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {
                                status = STATUS_BUFFER_TOO_SMALL;

                            } else {
                                CurrentBuffer += 1;
                                CurrentBuffer->FileOffset.QuadPart = StartingOffset;
                                CurrentBuffer->Length.QuadPart = Length;
                                Irp->IoStatus.Information = sizeof( FILE_ALLOCATED_RANGE_BUFFER );
                            }
                            leave;
                        } else {
                            // Unable to map the user buffer
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    status = STATUS_INVALID_USER_BUFFER;
                }

                Irp->IoStatus.Status = status;
                IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
                return(STATUS_SUCCESS) ;
            }
               break;
        }

        case FSCTL_GET_REPARSE_POINT: {

            if (RsIsNoRecall(irpSp->FileObject, &pRpData) == TRUE) {

                //
                //  Get the length of the input and output buffers.
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFsControl Handling Get Reparse Point for %x\n", irpSp->FileObject));

                InputBufferLength  = irpSp->Parameters.FileSystemControl.InputBufferLength;
                OutputBufferLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;
                Irp->IoStatus.Information = 0;

                if (Irp->AssociatedIrp.SystemBuffer != NULL) {
                    rpOutputBuffer = (PCHAR)Irp->AssociatedIrp.SystemBuffer;
                } else if (Irp->MdlAddress != NULL) {
                    rpOutputBuffer = (PCHAR)MmGetSystemAddressForMdlSafe( Irp->MdlAddress,
                                                                          NormalPagePriority );
                    if (rpOutputBuffer == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } else {
                    //
                    //  Return an invalid user buffer error.
                    //
                    rpOutputBuffer = NULL;
                    status = STATUS_INVALID_USER_BUFFER;
                }


                if ((rpOutputBuffer != NULL) && ((sizeof(RP_DATA) + REPARSE_DATA_BUFFER_HEADER_SIZE) > OutputBufferLength)) {

                    //
                    //  The input buffer is too short. Return a buffer too small error.
                    //  The caller receives the required length in  IoStatus.Information.
                    //

                    status = STATUS_BUFFER_OVERFLOW;

                    //
                    //  Now copy whatever portion of the reparse buffer will fit.  Hopefully the
                    //  caller allocated enough to hold the header, which contains the reparse
                    //  tag and reparse data length.
                    //

                    if (OutputBufferLength > 0) {
                        if (OutputBufferLength >= REPARSE_DATA_BUFFER_HEADER_SIZE) {
                            pRpBuffer = (PREPARSE_DATA_BUFFER) rpOutputBuffer;
                            pRpBuffer->ReparseTag = IO_REPARSE_TAG_HSM;
                            pRpBuffer->ReparseDataLength = sizeof(RP_DATA);
                            pRpBuffer->Reserved = 0;
                        }

                        if (OutputBufferLength > REPARSE_DATA_BUFFER_HEADER_SIZE) {
                            RtlCopyMemory( rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE,
                                           pRpData,
                                           OutputBufferLength - REPARSE_DATA_BUFFER_HEADER_SIZE);
                        }
                        if (OutputBufferLength > (ULONG) (REPARSE_DATA_BUFFER_HEADER_SIZE + FIELD_OFFSET(RP_DATA, data.migrationTime))) {
                            //
                            // Now fake out the bit to say it is pre-migrated (not truncated)
                            //
                            tmpRp = (PRP_DATA) (rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE);
                            tmpRp->data.bitFlags &= ~RP_FLAG_TRUNCATED;
                            RP_GEN_QUALIFIER(tmpRp, tmpRp->qualifier)
                        }
                    }
                } else if (rpOutputBuffer != NULL) {
                    //
                    //  Copy the value of the reparse point attribute to the buffer.
                    //  Return all the value including the system header fields (e.g., Tag and Length)
                    //  stored at the beginning of the value of the reparse point attribute.
                    //

                    pRpBuffer = (PREPARSE_DATA_BUFFER) rpOutputBuffer;
                    pRpBuffer->ReparseTag = IO_REPARSE_TAG_HSM;
                    pRpBuffer->ReparseDataLength = sizeof(RP_DATA);
                    pRpBuffer->Reserved = 0;

                    RtlCopyMemory( rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE,
                                   pRpData,
                                   sizeof(RP_DATA));

                    //
                    // Now fake out the bit to say it is pre-migrated (not truncated)
                    //
                    tmpRp = (PRP_DATA) (rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE);
                    tmpRp->data.bitFlags &= ~RP_FLAG_TRUNCATED;
                    RP_GEN_QUALIFIER(tmpRp, tmpRp->qualifier)
                    status = STATUS_SUCCESS;
                }

                Irp->IoStatus.Status = status;
                if (OutputBufferLength <= sizeof(RP_DATA) + REPARSE_DATA_BUFFER_HEADER_SIZE) {
                    Irp->IoStatus.Information = OutputBufferLength;
                } else {
                    Irp->IoStatus.Information = sizeof(RP_DATA) + REPARSE_DATA_BUFFER_HEADER_SIZE;
                }
                 IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
                 return(status);
            }
            break;
        }

        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
        case FSCTL_REQUEST_BATCH_OPLOCK:
        case FSCTL_REQUEST_FILTER_OPLOCK: {
            if ((RsIsFileObj(irpSp->FileObject, TRUE, &pRpData, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == TRUE) &&  RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags))  {
                //
                // Fail oplocks on any file that is in the file object list.
                // This is to prevent a deadlock problem that was seen with Content Indexing where
                // they open for read_attribute access (thus not recalling) and setting an oplock
                // then opening for recall.  The recall causes an oplock break and CI cannot process
                // it because the thread is tied up waiting for the recall.
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Failing oplock for truncated file opened with non-data access.\n"));

		status = STATUS_OPLOCK_NOT_GRANTED;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
                return(status) ;
            }
            break;
        }

        case FSCTL_SET_REPARSE_POINT: {
            //
            // First see if it if our tag.  If not let it pass, otherwise...
            //  If it is us setting it then let it go.
            //  If it is someone else (backup) then we need to note it so we can do a validate job at some point.
            //  If the file is being truncated and it has a filter context (for any file object) then we
            //  need to touch up some of the entries in the context entry to make sure the state is correct.
            //
            InputBufferLength  = irpSp->Parameters.FileSystemControl.InputBufferLength;
            //
            // There had better be a buffer at least large enough for the reparse point tag and length
            //
            if ((Irp->AssociatedIrp.SystemBuffer != NULL) &&
                 (InputBufferLength >= (REPARSE_DATA_BUFFER_HEADER_SIZE + sizeof(RP_DATA)))) {

                pRpBuffer = (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;
                if ((pRpBuffer->ReparseTag == IO_REPARSE_TAG_HSM) &&
                    (pRpBuffer->ReparseDataLength >= sizeof(RP_DATA))) {
                    //
                    // It is our tag - now see if we set it or someone else did.
                    //
                    tmpRp = (PRP_DATA) &pRpBuffer->GenericReparseBuffer.DataBuffer[0];
                    if (RP_IS_ENGINE_ORIGINATED(tmpRp->data.bitFlags)) {
                        RP_CLEAR_ORIGINATOR_BIT(tmpRp->data.bitFlags);
                        //
                        // See if it is getting truncated
                        //
                        if (RP_FILE_IS_TRUNCATED(tmpRp->data.bitFlags)) {
                            PRP_FILTER_CONTEXT      filterContext;
                            PRP_FILE_OBJ            entry;
                            PRP_FILE_CONTEXT        context;

                            filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(irpSp->FileObject), FsDeviceObject, irpSp->FileObject);

                            if (filterContext != NULL) {
                                entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
                                context = entry->fsContext;
                                RsAcquireFileContextEntryLockExclusive(context);
                                context->state = RP_RECALL_NOT_RECALLED;
                                context->recallStatus = 0;
                                context->currentOffset.QuadPart = 0;
                                memcpy(&context->rpData, tmpRp, sizeof(RP_DATA));
                                KeClearEvent(&context->recallCompletedEvent);
                                RsReleaseFileContextEntryLock(context);
                            }
                        }
                    } else {
                        //
                        // It must be backup or someone else.  We need to flag the event so that the
                        // engine can clean things up later with a validate job.
                        //
                        //
                        // Get the serial number from the file object or the device object
                        // in the file object or the device object passed in.
                        // If it is not in any of these places we have a problem.
                        //
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Set of Reparse Point by non-HSM program.\n"));

                        if ((irpSp->FileObject != 0) && (irpSp->FileObject->Vpb != 0)) {
                            RemainingBytes = irpSp->FileObject->Vpb->SerialNumber;
                        } else if ((irpSp->DeviceObject != 0) && (irpSp->FileObject->DeviceObject->Vpb != 0)) {
                            RemainingBytes = irpSp->FileObject->DeviceObject->Vpb->SerialNumber;
                        } else if (DeviceObject->Vpb != 0) {
                            RemainingBytes = DeviceObject->Vpb->SerialNumber;
                        } else {
                            //
                            // ERROR - no volume serial number - We cannot log which volume
                            // needs a validate.  Let it go but log an event.
                            //
                            RemainingBytes = 0;
                            RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                                       AV_MSG_SERIAL, NULL, NULL);
                        }
                        if (RemainingBytes != 0) {
                            //
                            // Set the registry entry or let the Fsa know a validate is needed
                            //
                            RsLogValidateNeeded(RemainingBytes);
                        }
                    }
                }
            }
            break;
        }

        case FSCTL_RECALL_FILE: {
            //
            // Forces explicit recall of file
            // This will be honored only if the file is opened for write access
            // *and* it is not opened for NO_RECALL
            //
            status = RsFsctlRecallFile(irpSp->FileObject);
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        default: {
            break;
        }
    } // End of the switch


    //
    // Just get out of the way
    //
    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: FsCtl handler exit 0x%08X\n", status));

    return (status);
}



PVOID
RsMapUserBuffer (
                IN OUT PIRP Irp
                )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

Return Value:

    Mapped address

--*/

{
   PVOID SystemBuffer;

   PAGED_CODE();

   //
   // If there is no Mdl, then we must be in the Fsd, and we can simply
   // return the UserBuffer field from the Irp.
   //

   if (Irp->MdlAddress == NULL) {

      return Irp->UserBuffer;

   } else {

      //
      //  MM can return NULL if there are no system ptes.
      //

      SystemBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress,
                                                   NormalPagePriority );

      return SystemBuffer;
   }
}


DBGSTATIC
VOID
RsFsNotification(
                IN PDEVICE_OBJECT DeviceObject,
                IN BOOLEAN FsActive
                )

/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/

{
   NTSTATUS                    status;
   PDEVICE_OBJECT              deviceObject;
   PDEVICE_OBJECT              nextAttachedDevice;
   PDEVICE_OBJECT              fsDevice;
   PDEVICE_OBJECT              ntfsDevice;
   UNICODE_STRING              ntfsName;
   POBJECT_NAME_INFORMATION    nameInfo;
   CHAR                        buff[64 + sizeof(OBJECT_NAME_INFORMATION)];
   ULONG                       size;
   PFILE_OBJECT                fileObject;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter Fs Notification\n"));
   //
   // Begin by determine whether or not the file system is a disk-based file
   // system.  If not, then this driver is not concerned with it.
   //

   if (DeviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM) {
      return;
   }


   //
   // Find the Ntfs device object (if there) and see if the passed in device object is the same.
   // If it is we may be loading after boot time and may not be the top level driver.
   // If this is the case the name may we get from ObQueryNameString may not be NTFS but we will
   // attach anyway and hope it works.  We will log a warning so we know this happened.
   //


   RtlInitUnicodeString( &ntfsName, (PWCHAR) L"\\Ntfs" );
   status = IoGetDeviceObjectPointer(
                                    &ntfsName,
                                    FILE_READ_ATTRIBUTES,
                                    &fileObject,
                                    &ntfsDevice
                                    );

   if (NT_SUCCESS( status )) {
      ObDereferenceObject( fileObject );
   } else {
      ntfsDevice = NULL;
   }

   //
   // If it is not the NTFS file system we do not care about it either
   //

   nameInfo = (POBJECT_NAME_INFORMATION) buff;
   status = ObQueryNameString(
                             DeviceObject->DriverObject,
                             nameInfo,
                             64,
                             &size
                             );


   if (NT_SUCCESS(status)) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Checking %ws\n", nameInfo->Name.Buffer));

      RtlInitUnicodeString(&ntfsName, (PWCHAR) RP_NTFS_NAME);

      if (0 != RtlCompareUnicodeString(&nameInfo->Name,
                                       &ntfsName, TRUE)) {
         //
         // The name did not match - see if the device object matches
         //
         if (DeviceObject == ntfsDevice) {
            //
            // The name does not match but the deivce is NTFS.
            // We will go ahrad and attach but we will log an event so we know what
            // happened.
            RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                       AV_MSG_REGISTER_WARNING, NULL, NULL);

         } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Skipping %ws\n", nameInfo->Name.Buffer));
            return;
         }
      }
   } else {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Failed to get driver name\n"));
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_REGISTER_ERROR, NULL, NULL);

      /* Assume it it not NTFS ! */
      return;
   }

   //
   // Begin by determining whether this file system is registering or
   // unregistering as an active file system.
   //

   if (FsActive) {

      PDEVICE_EXTENSION deviceExtension;


      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Attach to %ws\n", nameInfo->Name.Buffer));
      //
      // The file system has registered as an active file system.  If it is
      // a disk-based file system attach to it.
      //

      FsRtlEnterFileSystem();
      ExAcquireResourceExclusiveLite( &FsLock, TRUE );
      status = IoCreateDevice(
                             FsDriverObject,
                             sizeof( DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &deviceObject
                             );
      if (NT_SUCCESS( status )) {
         deviceExtension = deviceObject->DeviceExtension;
         fsDevice = deviceExtension->FileSystemDeviceObject  =
                    IoAttachDeviceToDeviceStack(deviceObject, DeviceObject);

         if (NULL == fsDevice) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Error attaching to the device (%x) (Flags = %x)",
                                  status, DeviceObject->Flags));
            if (DeviceObject->Flags & DO_DEVICE_INITIALIZING) {
               //
               // Some filter drivers accidentally or intentionally leave the DO_DEVICE_INITIALIZING
               // flag set.  This prevents any other filters from attaching.  We log a
               // special error here to alert technical support that this has happened.
               // The only thing that can be done is to find out what driver is the offender and
               // adjust the load order to get us in first.  The author of the offending driver
               // should be contacted and informed of the error and urged to correct it.  Any
               // dependancy of the offending driver may have of loading before HSM cannot be
               // satisfied in this case and the user would have to choose between HSM and the
               // other application.
               //
               RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                          AV_MSG_ATTACH_INIT_ERROR, NULL, NULL);
            } else {
               RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                          AV_MSG_ATTACH_ERROR, NULL, NULL);
            }
            IoDeleteDevice( deviceObject );
         } else {
            deviceExtension->Type                        = RSFILTER_DEVICE_TYPE;
            deviceExtension->Size                        = sizeof( DEVICE_EXTENSION );
            deviceExtension->Attached                    = TRUE;
	    deviceExtension->AttachedToNtfsControlDevice = TRUE;
	    deviceExtension->WriteStatus                 = RsVolumeStatusUnknown;

            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
         }
      } else {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Error creating a device object (%x)", status));
         RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                    AV_MSG_REGISTER_ERROR, NULL, NULL);
      }
      ExReleaseResourceLite( &FsLock );
      FsRtlExitFileSystem();
   } else {

      //
      // Search the linked list of drivers attached to this device and check
      // to see whether this driver is attached to it.  If so, remove it.
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Detach from %ws\n", nameInfo->Name.Buffer));

      if (nextAttachedDevice = DeviceObject->AttachedDevice) {

         PDEVICE_EXTENSION deviceExtension;

         //
         // This registered file system has someone attached to it.  Scan
         // until this driver's device object is found and detach it.
         //

         FsRtlEnterFileSystem();
         ExAcquireResourceSharedLite( &FsLock, TRUE );

         while (nextAttachedDevice) {
            deviceExtension = nextAttachedDevice->DeviceExtension;
            if (deviceExtension->Type == RSFILTER_DEVICE_TYPE &&
                deviceExtension->Size == sizeof( DEVICE_EXTENSION )) {

               //
               // A device object that may belong to this driver has been
               // located.  Scan the list of device objects owned by this
               // driver to see whether or not is actually belongs to this
               // driver.
               //

               fsDevice = FsDriverObject->DeviceObject;
               while (fsDevice) {
                  if (fsDevice == nextAttachedDevice) {
                     IoDetachDevice( DeviceObject );
                     deviceExtension = fsDevice->DeviceExtension;
                     deviceExtension->Attached = FALSE;

                     if (!fsDevice->AttachedDevice) {
                        IoDeleteDevice( fsDevice );
                     }
                     // **** What to do if still attached?
                     ExReleaseResourceLite( &FsLock );
                     FsRtlExitFileSystem();
                     return;
                  }
                  fsDevice = fsDevice->NextDevice;
               }

            }


            DeviceObject = nextAttachedDevice;
            nextAttachedDevice = nextAttachedDevice->AttachedDevice;
         }
         ExReleaseResourceLite( &FsLock );
         FsRtlExitFileSystem();
      }
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit Fs notification\n"));
   return;
}


DBGSTATIC
BOOLEAN
RsFastIoCheckIfPossible(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN BOOLEAN Wait,
                       IN ULONG LockKey,
                       IN BOOLEAN CheckForReadOperation,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT      deviceObject;
   PFAST_IO_DISPATCH   fastIoDispatch;


   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter fast Io check\n"));

   //
   // Do not allow fast io on files opened with no-recall option
   //
   if (RsIsFastIoPossible(FileObject) == TRUE) {
      deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
      if (!deviceObject) {
         return FALSE;
      }
      fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

      if (fastIoDispatch && fastIoDispatch->FastIoCheckIfPossible) {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit Fast IO check -= system\n"));
         return(fastIoDispatch->FastIoCheckIfPossible)(
                                                      FileObject,
                                                      FileOffset,
                                                      Length,
                                                      Wait,
                                                      LockKey,
                                                      CheckForReadOperation,
                                                      IoStatus,
                                                      deviceObject
                                                      );
      } else {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit Fast Io check - False\n"));
         return FALSE;
      }
   } else {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: No fast IO on files being recalled.\n"));
      return FALSE;
   }


}


DBGSTATIC
BOOLEAN
RsFastIoRead(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN ULONG Length,
            IN BOOLEAN Wait,
            IN ULONG LockKey,
            OUT PVOID Buffer,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT      deviceObject;
   PFAST_IO_DISPATCH   fastIoDispatch;
   ULONG               options = 0;


   PAGED_CODE();
   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Read\n"));

   //
   // Do not allow fast io on files opened with no-recall option
   //
   if (RsIsFastIoPossible(FileObject) == TRUE) {
      deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
      if (!deviceObject) {
         return FALSE;
      }
      fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

      if (fastIoDispatch && fastIoDispatch->FastIoRead) {
         return(fastIoDispatch->FastIoRead)(
                                           FileObject,
                                           FileOffset,
                                           Length,
                                           Wait,
                                           LockKey,
                                           Buffer,
                                           IoStatus,
                                           deviceObject
                                           );
      } else {
         return FALSE;
      }
   } else {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Do not allow fast IO on read-no-recall\n"));
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoWrite(
             IN PFILE_OBJECT FileObject,
             IN PLARGE_INTEGER FileOffset,
             IN ULONG Length,
             IN BOOLEAN Wait,
             IN ULONG LockKey,
             IN PVOID Buffer,
             OUT PIO_STATUS_BLOCK IoStatus,
             IN PDEVICE_OBJECT DeviceObject
             )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Write\n"));

   if (RsIsFastIoPossible(FileObject) == TRUE) {
      deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
      if (!deviceObject) {
         return FALSE;
      }
      fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

      if (fastIoDispatch && fastIoDispatch->FastIoWrite) {
         return(fastIoDispatch->FastIoWrite)(
                                            FileObject,
                                            FileOffset,
                                            Length,
                                            Wait,
                                            LockKey,
                                            Buffer,
                                            IoStatus,
                                            deviceObject
                                            );
      } else {
         return FALSE;
      }
   } else {
      return FALSE;
   }


}


DBGSTATIC
BOOLEAN
RsFastIoQueryBasicInfo(
                      IN PFILE_OBJECT FileObject,
                      IN BOOLEAN Wait,
                      OUT PFILE_BASIC_INFORMATION Buffer,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;
   BOOLEAN retval;
   ULONG openOptions;



   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io QBasic\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryBasicInfo) {
      retval =  (fastIoDispatch->FastIoQueryBasicInfo)(
                                                      FileObject,
                                                      Wait,
                                                      Buffer,
                                                      IoStatus,
                                                      deviceObject
                                                      );
   } else {
      return FALSE;
   }

   if (retval &&
       RsIsFileObj(FileObject, TRUE, NULL, NULL, NULL, NULL, NULL, &openOptions, NULL, NULL) &&
       RP_IS_NO_RECALL_OPTION(openOptions)) {
      //
      // This file was opened NO_RECALL, so we strip the FILE_ATTRIBUTE_OFFLINE bit
      //
      Buffer->FileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
   }

   return retval;
}


DBGSTATIC
BOOLEAN
RsFastIoQueryStandardInfo(
                         IN PFILE_OBJECT FileObject,
                         IN BOOLEAN Wait,
                         OUT PFILE_STANDARD_INFORMATION Buffer,
                         OUT PIO_STATUS_BLOCK IoStatus,
                         IN PDEVICE_OBJECT DeviceObject
                         )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io QStandard\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryStandardInfo) {
      return(fastIoDispatch->FastIoQueryStandardInfo)(
                                                     FileObject,
                                                     Wait,
                                                     Buffer,
                                                     IoStatus,
                                                     deviceObject
                                                     );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoLock(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN PLARGE_INTEGER Length,
            PEPROCESS ProcessId,
            ULONG Key,
            BOOLEAN FailImmediately,
            BOOLEAN ExclusiveLock,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Lock\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoLock) {
      return(fastIoDispatch->FastIoLock)(
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        ProcessId,
                                        Key,
                                        FailImmediately,
                                        ExclusiveLock,
                                        IoStatus,
                                        deviceObject
                                        );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoUnlockSingle(
                    IN PFILE_OBJECT FileObject,
                    IN PLARGE_INTEGER FileOffset,
                    IN PLARGE_INTEGER Length,
                    PEPROCESS ProcessId,
                    ULONG Key,
                    OUT PIO_STATUS_BLOCK IoStatus,
                    IN PDEVICE_OBJECT DeviceObject
                    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Unlock\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoUnlockSingle) {
      return(fastIoDispatch->FastIoUnlockSingle)(
                                                FileObject,
                                                FileOffset,
                                                Length,
                                                ProcessId,
                                                Key,
                                                IoStatus,
                                                deviceObject
                                                );
   } else {
      return FALSE;
   }
}


DBGSTATIC
BOOLEAN
RsFastIoUnlockAll(
                 IN PFILE_OBJECT FileObject,
                 PEPROCESS ProcessId,
                 OUT PIO_STATUS_BLOCK IoStatus,
                 IN PDEVICE_OBJECT DeviceObject
                 )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Unlock all\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoUnlockAll) {
      return(fastIoDispatch->FastIoUnlockAll)(
                                             FileObject,
                                             ProcessId,
                                             IoStatus,
                                             deviceObject
                                             );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoUnlockAllByKey(
                      IN PFILE_OBJECT FileObject,
                      PVOID ProcessId,
                      ULONG Key,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Unlock by key\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoUnlockAllByKey) {
      return(fastIoDispatch->FastIoUnlockAllByKey)(
                                                  FileObject,
                                                  ProcessId,
                                                  Key,
                                                  IoStatus,
                                                  deviceObject
                                                  );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoDeviceControl(
                     IN PFILE_OBJECT FileObject,
                     IN BOOLEAN Wait,
                     IN PVOID InputBuffer OPTIONAL,
                     IN ULONG InputBufferLength,
                     OUT PVOID OutputBuffer OPTIONAL,
                     IN ULONG OutputBufferLength,
                     IN ULONG IoControlCode,
                     OUT PIO_STATUS_BLOCK IoStatus,
                     IN PDEVICE_OBJECT DeviceObject
                     )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Ioctl\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoDeviceControl) {
      return(fastIoDispatch->FastIoDeviceControl)(
                                                 FileObject,
                                                 Wait,
                                                 InputBuffer,
                                                 InputBufferLength,
                                                 OutputBuffer,
                                                 OutputBufferLength,
                                                 IoControlCode,
                                                 IoStatus,
                                                 deviceObject
                                                 );
   } else {
      return FALSE;
   }

}



DBGSTATIC
VOID
RsFastIoDetachDevice(
                    IN PDEVICE_OBJECT SourceDevice,
                    IN PDEVICE_OBJECT TargetDevice
                    )

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to this driver's device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PAGED_CODE();

   //
   // Simply acquire the database lock for exclusive access, and detach from
   // the file system's volume device object.
   //

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Detach device\n"));

   FsRtlEnterFileSystem();
   ExAcquireResourceExclusiveLite( &FsLock, TRUE );
   IoDetachDevice( TargetDevice );
   IoDeleteDevice( SourceDevice );
   ExReleaseResourceLite( &FsLock );
   FsRtlExitFileSystem();
}

/* New Fast Io routines for NT 4.x */

DBGSTATIC
BOOLEAN
RsFastIoQueryNetworkOpenInfo(
                            IN PFILE_OBJECT FileObject,
                            IN BOOLEAN Wait,
                            OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
                            OUT PIO_STATUS_BLOCK IoStatus,
                            IN PDEVICE_OBJECT DeviceObject
                            )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io QNetOpen\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryNetworkOpenInfo) {
      return(fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                                                        FileObject,
                                                        Wait,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject
                                                        );
   } else {
      return FALSE;
   }

}


DBGSTATIC
NTSTATUS
RsFastIoAcquireForModWrite(
                          IN PFILE_OBJECT FileObject,
                          IN PLARGE_INTEGER EndingOffset,
                          OUT PERESOURCE *ResourceToRelease,
                          IN PDEVICE_OBJECT DeviceObject
                          )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for acquiring the
    file resource prior to attempting a modified write operation.

    This function simply invokes the file system's cooresponding routine, or
    returns an error if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object whose resource is to be acquired.

    EndingOffset - The offset to the last byte being written plus one.

    ResourceToRelease - Pointer to a variable to return the resource to release.
        Not defined if an error is returned.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is either success or failure based on whether or not
    fast I/O is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Acquire Mod Write\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->AcquireForModWrite) {
      return(fastIoDispatch->AcquireForModWrite)(
                                                FileObject,
                                                EndingOffset,
                                                ResourceToRelease,
                                                DeviceObject
                                                );
   } else {
      return STATUS_NOT_IMPLEMENTED;
   }
}


DBGSTATIC
BOOLEAN
RsFastIoMdlRead(
               IN PFILE_OBJECT FileObject,
               IN PLARGE_INTEGER FileOffset,
               IN ULONG Length,
               IN ULONG LockKey,
               OUT PMDL *MdlChain,
               OUT PIO_STATUS_BLOCK IoStatus,
               IN PDEVICE_OBJECT DeviceObject
               )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Mdl Read\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlRead) {
      return(fastIoDispatch->MdlRead)(
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     LockKey,
                                     MdlChain,
                                     IoStatus,
                                     deviceObject
                                     );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoMdlReadComplete(
                       IN PFILE_OBJECT FileObject,
                       IN PMDL MdlChain,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Mdl Read Complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlReadComplete) {
      return(fastIoDispatch->MdlReadComplete)(
                                             FileObject,
                                             MdlChain,
                                             deviceObject
                                             );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoPrepareMdlWrite(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Prep Mdl Write\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->PrepareMdlWrite) {
      return(fastIoDispatch->PrepareMdlWrite)(
                                             FileObject,
                                             FileOffset,
                                             Length,
                                             LockKey,
                                             MdlChain,
                                             IoStatus,
                                             deviceObject
                                             );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoMdlWriteComplete(
                        IN PFILE_OBJECT FileObject,
                        IN PLARGE_INTEGER FileOffset,
                        IN PMDL MdlChain,
                        IN PDEVICE_OBJECT DeviceObject
                        )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Mdl Write Complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlWriteComplete) {
      return(fastIoDispatch->MdlWriteComplete)(
                                              FileObject,
                                              FileOffset,
                                              MdlChain,
                                              deviceObject
                                              );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoReadCompressed(
                      IN PFILE_OBJECT FileObject,
                      IN PLARGE_INTEGER FileOffset,
                      IN ULONG Length,
                      IN ULONG LockKey,
                      OUT PVOID Buffer,
                      OUT PMDL *MdlChain,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                      IN ULONG CompressedDataInfoLength,
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Read Compressed\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoReadCompressed) {
      return(fastIoDispatch->FastIoReadCompressed)(
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  LockKey,
                                                  Buffer,
                                                  MdlChain,
                                                  IoStatus,
                                                  CompressedDataInfo,
                                                  CompressedDataInfoLength,
                                                  deviceObject
                                                  );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoWriteCompressed(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       IN PVOID Buffer,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                       IN ULONG CompressedDataInfoLength,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Write Compressed\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoWriteCompressed) {
      return(fastIoDispatch->FastIoWriteCompressed)(
                                                   FileObject,
                                                   FileOffset,
                                                   Length,
                                                   LockKey,
                                                   Buffer,
                                                   MdlChain,
                                                   IoStatus,
                                                   CompressedDataInfo,
                                                   CompressedDataInfoLength,
                                                   deviceObject
                                                   );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoMdlReadCompleteCompressed(
                                 IN PFILE_OBJECT FileObject,
                                 IN PMDL MdlChain,
                                 IN PDEVICE_OBJECT DeviceObject
                                 )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;


   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Read Compressed complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlReadCompleteCompressed) {
      return(fastIoDispatch->MdlReadCompleteCompressed)(
                                                       FileObject,
                                                       MdlChain,
                                                       deviceObject
                                                       );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoMdlWriteCompleteCompressed(
                                  IN PFILE_OBJECT FileObject,
                                  IN PLARGE_INTEGER FileOffset,
                                  IN PMDL MdlChain,
                                  IN PDEVICE_OBJECT DeviceObject
                                  )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Write Compressed complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlWriteCompleteCompressed) {
      return(fastIoDispatch->MdlWriteCompleteCompressed)(
                                                        FileObject,
                                                        FileOffset,
                                                        MdlChain,
                                                        deviceObject
                                                        );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoQueryOpen(
                 IN PIRP Irp,
                 OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
                 IN PDEVICE_OBJECT DeviceObject
                 )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;
   BOOLEAN result;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Q Open\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryOpen) {
      PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

      irpSp->DeviceObject = deviceObject;

      result = (fastIoDispatch->FastIoQueryOpen)(
                                                Irp,
                                                NetworkInformation,
                                                deviceObject
                                                );
      if (!result) {
         irpSp->DeviceObject = DeviceObject;
      }
      return result;
   } else {
      return FALSE;
   }
}


DBGSTATIC
NTSTATUS
RsAsyncCompletion(
                 IN PDEVICE_OBJECT pDeviceObject,
                 IN PIRP           pIrp,
                 IN PVOID          pvContext
                 )
/*++

Routine Description:

    This routine is invoked for the completion of a mount or load fs
    request. It's only job is to synchronise with the mainline code.


Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the completion context.


Return Value:

    STATUS_MORE_PROCESSING_REQUIRED if the qork item was queued or the
    return value of the real completion code if not..

--*/

{
   PKEVENT	pCompletionEvent = (PKEVENT) pvContext;


   UNREFERENCED_PARAMETER (pDeviceObject);
   UNREFERENCED_PARAMETER (pIrp);

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Async completion\n"));

   KeSetEvent (pCompletionEvent, IO_NO_INCREMENT, FALSE);


   return STATUS_MORE_PROCESSING_REQUIRED;
}


DBGSTATIC
NTSTATUS
RsPreAcquireFileForSectionSynchronization(
                    IN  PFS_FILTER_CALLBACK_DATA Data,
                    OUT PVOID *CompletionContext
                               )
/*++


Routine Description:

    This routine is the FS Filter pre-acquire file routine - called
    as a result of Mm attempting to acquire the file exclusively  in 
    preparation for a create section.

    The file- if it is a HSM migrated file- is recalled in this callback.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.

    CompletionContext - A context set by this operation that will be passed
        to the corresponding RsPostFsFilterOperation call.
        The completion context is set to point to the createSectionLock count
        in the file context for this file. This will be appropriately 
        incremented in the PostAcquire callback if the acquire was successful

Return Value:

    STATUS_SUCCESS          if the operation can continue 
    STATUS_FILE_IS_OFFLINE  the file could not be recalled or the recall was
                            cancelled
--*/
{
   PFILE_OBJECT           fileObject;
   PRP_FILE_OBJ           entry;
   PRP_FILTER_CONTEXT     filterContext;
   PRP_FILE_CONTEXT       context;
   NTSTATUS               status = STATUS_SUCCESS;


   fileObject = Data->FileObject;

   filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(fileObject), FsDeviceObject, fileObject);

   if (filterContext != NULL) {
      entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
      ASSERT (entry != NULL);
      //
      // Now - if the file is in the no recall mode, but we see
      // a memory mapping section open for it, and the file has
      // been opened with write intent we should convert
      // the file to a recall on data access mode and initiate
      // the recall. Essentially if a file is open for write access
      // and we go through the acquire file for create section path,
      // (a memory mapped section is being opened), we recall right now,
      // even though we might never see a write for it later.
      // We are forced to do this because, if a user writes through
      // the mapped view, we could possibly not see the writes (Ntfs
      // will flush the pages to disk)
      //
      //
      if (RP_IS_NO_RECALL(entry) && (entry->desiredAccess & FILE_WRITE_DATA)) {
         //
         // Convert the file to recall mode
         //
         RP_RESET_NO_RECALL(entry);
      }

      //
      // If it was opened for no recall we do nothing, otherwise we must start
      // the recall here, before acquiring the resource.
      //
      if (!RP_IS_NO_RECALL(entry)) {
         //
         // Need to recall
         //
         status = RsRecallFile(filterContext);
      }
      if (!NT_SUCCESS(status)) {
           //
           // We are failing this op., so the post-acquire would not be 
           // called
           //
           status = STATUS_FILE_IS_OFFLINE;
      } else {
            //
            // Set the completion context for the post operation
            //
            context = entry->fsContext;
            ASSERT (context != NULL);
           *CompletionContext = &context->createSectionLock;
      }
   }

   return status;
}


DBGSTATIC
VOID
RsPostAcquireFileForSectionSynchronization(
                    IN PFS_FILTER_CALLBACK_DATA Data,
                    IN NTSTATUS AcquireStatus,
                    IN PVOID    CompletionContext
                               )
/*++


Routine Description:

    This routine is the FS Filter post-acquire file routine - called
    as a result of Mm attempting to acquire the file exclusively  in 
    preparation for a create section, just after the acquire succeeded

    If the completion context was non-NULL then the acquire was for a
    HSM managed file. We increment the createSection lock for the file
    to indicate there is an exclusive lock on this file

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
    AcquireStatus - Status of the AcquireFile operation

    CompletionContext - A context set by the PreAcquire operation: this is
                        file context's create section lock if set. 
                        If it is NULL, then the file is not a HSM file so just 
                        do nothing                    

Return Value:

    NONE

--*/
{

   PAGED_CODE();

   if (NT_SUCCESS(AcquireStatus) && (CompletionContext != NULL)) {
          InterlockedIncrement((PULONG) CompletionContext);
   }
}



DBGSTATIC
VOID
RsPostReleaseFileForSectionSynchronization(
                    IN PFS_FILTER_CALLBACK_DATA Data,
                    IN NTSTATUS ReleaseStatus,
                    IN PVOID    CompletionContext
                               )
/*++


Routine Description:

    This routine is the FS Filter post-release file routine - called
    as a result of Mm attempting to acquire the file exclusively  in 
    preparation for a create section, just after the release is done

    We simply decrement the create section lock count for the file if
    it is a HSM managed file.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
           about this operation.

    ReleaseStatus - Status of the ReleaseFile operation

    CompletionContext - A context set by the PreAcquire operation. Unused.
                        

Return Value:

    NONE

--*/
{
   PFILE_OBJECT           fileObject;
   PRP_FILE_OBJ           entry;
   PRP_FILTER_CONTEXT     filterContext;
   PRP_FILE_CONTEXT       context;

   PAGED_CODE();

   if (NT_SUCCESS(ReleaseStatus)) {

       fileObject = Data->FileObject;
       filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(fileObject), FsDeviceObject, fileObject);

       if (filterContext != NULL) {
           entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
           ASSERT (entry != NULL);
           context = entry->fsContext;
           ASSERT (context != NULL);
           InterlockedDecrement(&context->createSectionLock);
        }
   }

   return;
}


NTSTATUS
RsFsctlRecallFile(IN PFILE_OBJECT FileObject)
/*++

Routine Description

    This routine recalls the file specified by the file object
    if it is not already recalled.

Arguments

    FileObject - Pointer to the file object for the file to be recalled

Return Value

    Status of the recall

--*/
{
   PRP_FILTER_CONTEXT     filterContext;
   PRP_FILE_OBJ           entry;
   NTSTATUS               status = STATUS_SUCCESS;

   PAGED_CODE();

   filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);

   if (filterContext != NULL) {
      entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;

      if (!(entry->desiredAccess & FILE_WRITE_DATA) &&
          !(entry->desiredAccess & FILE_READ_DATA)) {
         //
         // Just  a confirmation - take this check away when shipping
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO,"RsRecallFile: attempting a recall on a file not opened for read or write\n"));
         return STATUS_ACCESS_DENIED;
      }

      if (RP_IS_NO_RECALL(entry)) {
         return STATUS_ACCESS_DENIED;
      }

      //
      // Obviously the file is going to get out of the no-recall state
      //
      RP_RESET_NO_RECALL(entry);

      status = RsRecallFile(filterContext);
   }
   return status;
}


NTSTATUS
RsRecallFile(IN PRP_FILTER_CONTEXT FilterContext)
/*++

Routine Description

    This routine recalls the file specified by the file object
    if it is not already recalled.

Arguments

    FilterContext - pointer to the filter context

Return Value

    Status of the recall

--*/
{

   NTSTATUS               retval = STATUS_FILE_IS_OFFLINE, status, qRet;
   BOOLEAN                gotLock;
   PRP_FILE_OBJ           entry;
   PRP_FILE_CONTEXT       context;
   PKEVENT                eventToWaitOn;
   ULONGLONG              filterId;
   LONGLONG               start, size;

   PAGED_CODE();

   entry = (PRP_FILE_OBJ) FilterContext->myFileObjEntry;

   context = entry->fsContext;

   RsAcquireFileContextEntryLockExclusive(context);
   gotLock = TRUE;
   try {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - RecallStatus = %u.\n",
                            context->state));

      ObReferenceObject(entry->fileObj);

      switch (context->state) {

      case RP_RECALL_COMPLETED: {
            //
            // Nothing we can do if recallStatus is not STATUS_SUCCESS
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall complete.\n"));
            if (context->recallStatus == STATUS_CANCELLED) {
               //
               // Previous recall was cancelled by user. Start another recall
               // now
               // So fall through deliberately to the NOT_RECALLED_CASE
               //
            } else {
               retval = context->recallStatus;
               ObDereferenceObject(entry->fileObj);
               RsReleaseFileContextEntryLock(context);
               gotLock = FALSE;
               break;
            }
         }
      case RP_RECALL_NOT_RECALLED: {
            //
            // Start the recall here.
            //
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - Queueing the recall.\n"));

            retval = STATUS_SUCCESS;
            context->state = RP_RECALL_STARTED;

            KeResetEvent(&context->recallCompletedEvent);

            entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
            entry->filterId <<= 32;
            entry->filterId |= RP_TYPE_RECALL;

            filterId = context->filterId | entry->filterId;
            start = context->rpData.data.dataStart.QuadPart;
            size =  context->rpData.data.dataSize.QuadPart;

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;

            qRet = RsQueueRecallOpen(context,
                                     entry,
                                     filterId,
                                     start,
                                     size,
                                     RP_OPEN_FILE);
            start = context->rpData.data.dataStreamStart.QuadPart;
            size =  context->rpData.data.dataStreamSize.QuadPart;


            if (NT_SUCCESS(qRet)) {
               qRet = RsQueueRecall(filterId ,
                                    start,
                                    size);
            };

            if (!NT_SUCCESS(qRet)) {
               //
               // If it failed we need to fail any reads we get later, since we
               // cannot fail this call.
               //
               RsAcquireFileContextEntryLockExclusive(context);
               gotLock = TRUE;

               context->state = RP_RECALL_NOT_RECALLED;
               context->recallStatus = STATUS_FILE_IS_OFFLINE;
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - Failed to queue the recall.\n"));
               //
               // If we got as far as queuing the recall, then we should not
               // fail the other IRPs.
               //
               RsFailAllRequests(context, FALSE);

               RsReleaseFileContextEntryLock(context);
               gotLock = FALSE;
               retval = STATUS_FILE_IS_OFFLINE;

            } else {
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - Queued the recall.\n"));
               eventToWaitOn = &context->recallCompletedEvent;
               status = KeWaitForSingleObject(eventToWaitOn,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);

               if (status == STATUS_SUCCESS) {
                    retval = context->recallStatus;
               } else {
                    //
                    // Wait did not succeed
                    //
                    retval = STATUS_FILE_IS_OFFLINE;
               }

               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall done - %x.\n", context->state));
            }

            ObDereferenceObject(entry->fileObj);
            break;
         }

      case RP_RECALL_STARTED: {
            //
            // recall is started. we wait for it to complete here
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall started.\n"));
            eventToWaitOn = &context->recallCompletedEvent;

            filterId = context->filterId | entry->filterId;
            qRet = RsQueueRecallOpen(context,
                                     entry,
                                     filterId,
                                     0,0,
                                     RP_RECALL_WAITING);

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
            status = KeWaitForSingleObject(eventToWaitOn,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall finished.\n"));
            if (status == STATUS_SUCCESS) {
                 retval = context->recallStatus;
            } else {
                //
                // Wait did not succeed
                //
                retval = STATUS_FILE_IS_OFFLINE;
            }
            ObDereferenceObject(entry->fileObj);
            break;
         }


      default:  {
            //
            // Something strange - Fail the write
            //
            RsLogError(__LINE__, AV_MODULE_RPFILTER, context->state,
                       AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

            //
            // TEMPORARY BEGIN: to track down RSFilter bug
            //
            DbgPrint("RsFilter: Unexpected error! File context = %x, Contact RaviSp to debug\n", context);
            DbgBreakPoint();
            //
            // TEMPORARY END
            //

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
            ObDereferenceObject(entry->fileObj);
            retval = STATUS_FILE_IS_OFFLINE;
            break;
         }
      }

      if (gotLock == TRUE) {
         RsReleaseFileContextEntryLock(context);
         gotLock = FALSE;
      }
   }except (RsExceptionFilter(L"RsRecallFile", GetExceptionInformation())) {
      //
      // Something bad happened - just log an error and return
      //
      if (gotLock == TRUE) {
         RsReleaseFileContextEntryLock(context);
         gotLock = FALSE;
      }
      retval = STATUS_INVALID_USER_BUFFER;
   }

   return retval;
}


NTSTATUS
RsQueryInformation(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )
/*++

Routine Description

   Filters the IRP_MJ_QUERY_INFORMATION call
   We mask out FILE_ATTRIBUTE_OFFLINE while returning the attributes

Arguments

   DeviceObject   - Pointer to our device object
   Irp            - The set information Irp

Return Value

   status

--*/
{
   PIO_STACK_LOCATION          currentStack ;
   NTSTATUS                    status = STATUS_SUCCESS;
   PDEVICE_EXTENSION           deviceExtension;
   ULONG                        openOptions;

   PAGED_CODE();

   deviceExtension = DeviceObject->DeviceExtension;

   try {
      if (!deviceExtension->Type) {
         status = STATUS_INVALID_DEVICE_REQUEST;
         leave;
      }

      currentStack = IoGetCurrentIrpStackLocation (Irp) ;

      if (currentStack->Parameters.QueryFile.FileInformationClass != FileBasicInformation &&  currentStack->Parameters.QueryFile.FileInformationClass != FileAllInformation) {
         //
         // We are not interested in this IRP
         //
         IoSkipCurrentIrpStackLocation(Irp);
         leave;
      }

      //
      // Check if this is hsm managed & if so get the reparse point data
      //
      if (RsIsFileObj(currentStack->FileObject, TRUE, NULL, NULL, NULL, NULL, NULL, &openOptions, NULL, NULL) == FALSE) {
         //
         //
         // Get this driver out of the driver stack and get to the next driver as
         // quickly as possible.
         //
         IoSkipCurrentIrpStackLocation(Irp);
         leave;
      }

      if (!RP_IS_NO_RECALL_OPTION(openOptions)) {
         IoSkipCurrentIrpStackLocation(Irp);
         leave;
      }

      IoCopyCurrentIrpStackLocationToNext(Irp);
      IoSetCompletionRoutine( Irp,
                              RsQueryInformationCompletion,
                              NULL,
                              TRUE,
                              TRUE,
                              TRUE );
   } finally {
      if (NT_SUCCESS(status)) {
         status = IoCallDriver(deviceExtension->FileSystemDeviceObject,
                               Irp);
      } else {
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;
         IoCompleteRequest( Irp, IO_NO_INCREMENT );
      }
   }
   return status;
}


NTSTATUS
RsQueryInformationCompletion(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PVOID Context
                            )
/*++

Routine Description:

   Completion routine for query information

Arguments:



Return Value:


Note:

--*/
{
   PIO_STACK_LOCATION currentStack = IoGetCurrentIrpStackLocation(Irp);
   PFILE_BASIC_INFORMATION  basicInfo;

   UNREFERENCED_PARAMETER( DeviceObject );

   if (NT_SUCCESS(Irp->IoStatus.Status)) {
      if (currentStack->Parameters.QueryFile.FileInformationClass == FileBasicInformation) {
         basicInfo = Irp->AssociatedIrp.SystemBuffer;
      } else if (currentStack->Parameters.QueryFile.FileInformationClass == FileAllInformation) {
         basicInfo = &(((PFILE_ALL_INFORMATION) Irp->AssociatedIrp.SystemBuffer)->BasicInformation);
      } else {
         //
         // This shouldn't happen
         //
         return STATUS_SUCCESS;

      }
      //
      // Turn off the OFFLINE attribute
      //
      basicInfo->FileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
   }

   return STATUS_SUCCESS;
}


NTSTATUS
RsInitialize(VOID)
/*++

Routine Description:

    Initialize the environment.

Arguments:

    NONE

Return Value:

    0

Note:

    This is called when the FSA enables recalls


--*/
{
   PRTL_QUERY_REGISTRY_TABLE parms;
   ULONG                     parmsSize;
   NTSTATUS                  status = STATUS_SUCCESS;
   ULONG                     defaultSkipFilesForLegacyBackup = 0;
   ULONG                     defaultMediaType = RS_SEQUENTIAL_ACCESS_MEDIA, mediaType;

   PAGED_CODE();

   parmsSize =  sizeof(RTL_QUERY_REGISTRY_TABLE) * 2;

   parms = ExAllocatePoolWithTag(PagedPool,
                                 parmsSize,
                                 RP_ER_TAG
                                );

   if (!parms) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(parms, parmsSize);

   parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[0].Name          = RSFILTER_SKIP_FILES_FOR_LEGACY_BACKUP_VALUE;
   parms[0].EntryContext  = &RsSkipFilesForLegacyBackup;
   parms[0].DefaultType   = REG_DWORD;
   parms[0].DefaultData   = &defaultSkipFilesForLegacyBackup;
   parms[0].DefaultLength = sizeof(ULONG);

   //
   // Perform the query
   //
   status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                   RSFILTER_PARAMS_KEY,
                                   parms,
                                   NULL,
                                   NULL);

   if (NT_SUCCESS(status)) {

       RtlZeroMemory(parms, parmsSize);

       parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
       parms[0].Name          = RSENGINE_MEDIA_TYPE_VALUE;
       parms[0].EntryContext  = &mediaType;
       parms[0].DefaultType   = REG_DWORD;
       parms[0].DefaultData   = &defaultMediaType;
       parms[0].DefaultLength = sizeof(ULONG);

       status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                       RSENGINE_PARAMS_KEY,
                                       parms,
                                       NULL,
                                       NULL);
       if (NT_SUCCESS(status)) {
            if (mediaType == RS_DIRECT_ACCESS_MEDIA) {
                RsUseUncachedNoRecall = TRUE;
            } else  {
                RsUseUncachedNoRecall = FALSE;
            }
       }
   }

   ExFreePool(parms);

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsafltr.h ===
#ifndef _FSAFLTR_
#define _FSAFLTR_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsafltr.h

Abstract:

    This class represents a file system filter for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "rpdata.h"
#include "rpguid.h"
#include "rpio.h"


typedef struct _FSA_IOCTL_CONTROL {
    HANDLE      dHand;
    OVERLAPPED  overlap;
    RP_MSG      in;
    RP_MSG      out;
    DWORD       outSize;
    struct _FSA_IOCTL_CONTROL   *next;
} FSA_IOCTL_CONTROL, *PFSA_IOCTL_CONTROL;

//
// This defines the length of time a client structure will be kept around after 
// the last recall was done (in seconds).
//
#define FSA_CLIENT_EXPIRATION_TIME  600 // 10 minutes
#define THREAD_HANDLE_COUNT 2 //for WaitForMultipleObjects array

/*++

Class Name:
    
    CFsaFilter

Class Description:

    This class represents a file system filter for NTFS 5.0.

--*/

class CFsaFilter : 
    public CWsbCollectable,
    public IFsaFilter,
    public IFsaFilterPriv,
    public CComCoClass<CFsaFilter,&CLSID_CFsaFilterNTFS>
{
public:
    CFsaFilter() {}
BEGIN_COM_MAP(CFsaFilter)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IFsaFilter)
    COM_INTERFACE_ENTRY(IFsaFilterPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaFilter)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaFilterPriv
public:
    STDMETHOD(Init)(IFsaServer* pServer);
    STDMETHOD(SetIdentifier)(GUID id);
    STDMETHOD(IoctlThread)(void);
    STDMETHOD(PipeThread)(void);
    STDMETHOD(SendCancel)(IFsaFilterRecallPriv *pRecallPriv);
    STDMETHOD(SendComplete)(IFsaFilterRecallPriv *pRecall, HRESULT result);

// IFsaFilter
public:
    STDMETHOD(Cancel)(void);
    STDMETHOD(CancelRecall)(IFsaFilterRecall* pRecall);
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIFilter)(IFsaFilter* pFilter, SHORT* pResult);
    STDMETHOD(DeleteRecall)(IFsaFilterRecall* pRecall);
    STDMETHOD(EnumRecalls)(IWsbEnum** ppEnum);
    STDMETHOD(GetAdminExemption)(BOOL *isExempt);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetLogicalName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetMaxRecallBuffers)(ULONG* pMaxBuffers);
    STDMETHOD(GetMaxRecalls)(ULONG* pMaxRecalls);
    STDMETHOD(GetMinRecallInterval)(ULONG* pMinIterval);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(IsEnabled)();
    STDMETHOD(Pause)(void);
    STDMETHOD(Resume)(void);
    STDMETHOD(SetIsEnabled)(BOOL isEnabled);
    STDMETHOD(SetMaxRecalls)(ULONG maxRecalls);
    STDMETHOD(SetMinRecallInterval)(ULONG minIterval);
    STDMETHOD(SetMaxRecallBuffers)(ULONG maxBuffers);
    STDMETHOD(Start)(void);
    STDMETHOD(StopIoctlThread)(void);
    STDMETHOD(FindRecall)(GUID recallId, IFsaFilterRecall** pRecall);
    STDMETHOD(SetAdminExemption)(BOOL isExempt);

private:
    HRESULT DoOpenAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoRecallWaitingAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoRecallAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoNoRecallAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoCloseAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoPreDeleteAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoPostDeleteAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoCancelRecall(ULONGLONG filterId);
    HRESULT CleanupClients(void);
    NTSTATUS CFsaFilter::TranslateHresultToNtStatus(HRESULT hr);
    

protected:
    GUID                        m_id;
    HSM_JOB_STATE               m_state;
    ULONG                       m_maxRecalls;
    ULONG                       m_minRecallInterval;
    ULONG                       m_maxRecallBuffers;
    HANDLE                      m_pipeHandle;
    HANDLE                      m_pipeThread;
    HANDLE                      m_ioctlThread;
    HANDLE                      m_ioctlHandle;
    HANDLE                      m_terminateEvent;
    IFsaServer*                 m_pFsaServer;       // Parent Pointer, Weak Reference
    CComPtr<IWsbCollection>     m_pClients;
    CComPtr<IWsbCollection>     m_pRecalls;
    CRITICAL_SECTION            m_clientLock;       // Protect client collection from multiple thread access
    CRITICAL_SECTION            m_recallLock;       // Protect recall collection from multiple thread access
    CRITICAL_SECTION            m_stateLock;        // Protect state change while sending new Ioctls
    BOOL                        m_isEnabled;
    BOOL                        m_exemptAdmin;      // TRUE = exempt admin from runaway recall check
};

#endif  // _FSAFLTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\filter\rpzw.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpZw.c

Abstract:

    This module contains support routines for the HSM file system filter.

Author:

    Rick Winter
    Ravisankar Pudipeddi (ravisp)  - 1998

Environment:

    Kernel mode


Revision History:

	X-11	365077		Michael C. Johnson		 1-May-2001
		Although IoCreateFileSpecifyDeviceObjectHint() allows us to 
		bypass share access checking it doesn't bypass the check for 
		a readonly file attribute. Revert to the old scheme of 
		directly munging the file object after a successful open. 
		Note that we can still use IoCreateFileSpecifyDeviceObjectHint() 
		to avoid traversing the entire IO stack.

	X-10	206961		Michael C. Johnson		28-Mar-2001
		Open the target file by Id rather than by name so avoiding 
		troubles with renames happening after the initial collection
		of the filename on the first open of the file.

--*/

#include "pch.h"

extern ULONG RsNoRecallDefault;

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, RsMarkUsn)
   #pragma alloc_text(PAGE, RsOpenTarget)
   #pragma alloc_text(PAGE, RsQueryValueKey)
   #pragma alloc_text(PAGE, RsTruncateOnClose)
   #pragma alloc_text(PAGE, RsSetPremigratedState)
   #pragma alloc_text(PAGE, RsDeleteReparsePoint)
   #pragma alloc_text(PAGE, RsSetResetAttributes)
   #pragma alloc_text(PAGE, RsTruncateFile)
   #pragma alloc_text(PAGE, RsSetEndOfFile)
#endif


NTSTATUS
RsMarkUsn(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

    Mark the USN record for this file object

Arguments:

   Context      - File context entry

Return Value:


Note:


--*/

{
   NTSTATUS                    retval = STATUS_SUCCESS;
   KEVENT                      event;
   PIO_STACK_LOCATION          irpSp;
   IO_STATUS_BLOCK             Iosb;
   PIRP                        irp;
   PDEVICE_OBJECT              deviceObject;
   PMARK_HANDLE_INFO           pHinfo;
   HANDLE                      volHandle;
   OBJECT_ATTRIBUTES           volName;
   POBJECT_NAME_INFORMATION    nameInfo = NULL;

   PAGED_CODE();

   try {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn.\n"));

      //
      // Attempt allocating the buffer
      //
      pHinfo = ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(MARK_HANDLE_INFO),
                                     RP_FO_TAG
                                    );
      if (!pHinfo) {
         RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(MARK_HANDLE_INFO),
                    AV_MSG_MEMORY, NULL, NULL);
         return STATUS_INSUFFICIENT_RESOURCES;
      }


      retval = RsGenerateDevicePath(Context->fileObjectToWrite->DeviceObject, &nameInfo);

      if (!NT_SUCCESS(retval)) {
          ExFreePool(pHinfo);
          return retval;
      }

      InitializeObjectAttributes(&volName, &nameInfo->Name, OBJ_CASE_INSENSITIVE| OBJ_KERNEL_HANDLE, NULL, NULL);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Open volume - %ws.\n", nameInfo->Name.Buffer));

      retval = ZwOpenFile(&volHandle,
                          FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                          &volName,
                          &Iosb,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          0);


      if (!NT_SUCCESS(retval)) {
         //
         // Log an error
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsMarkUsn - failed to open volume - %ws - %x.\n",
                               nameInfo->Name.Buffer, retval));


         RsLogError(__LINE__, AV_MODULE_RPZW, retval,
                    AV_MSG_MARK_USN_FAILED, NULL, NULL);

         ExFreePool(pHinfo);
         ExFreePool(nameInfo);
         return(retval);
      }

      ExFreePool(nameInfo);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Build Irp for mark usn.\n"));

      //
      // First get the file info so we have the attributes
      //
      deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);
      irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

      if (irp) {
         irp->UserEvent = &event;
         irp->UserIosb = &Iosb;
         irp->Tail.Overlay.Thread = PsGetCurrentThread();
         irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
         irp->RequestorMode = KernelMode;
         //
         // Initialize the event
         //
         KeInitializeEvent(&event, SynchronizationEvent, FALSE);

         //
         // Set up the I/O stack location.
         //

         irpSp = IoGetNextIrpStackLocation(irp);
         irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
         irpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
         irpSp->FileObject = Context->fileObjectToWrite;
         irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_MARK_HANDLE;
         irpSp->Parameters.FileSystemControl.InputBufferLength = sizeof(MARK_HANDLE_INFO);
         irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;

         irp->AssociatedIrp.SystemBuffer = pHinfo;

         pHinfo->UsnSourceInfo = USN_SOURCE_DATA_MANAGEMENT;
         pHinfo->VolumeHandle = volHandle;
         pHinfo->HandleInfo = 0;
         //
         // Set the completion routine.
         //
         IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

         //
         // Send it to the FSD
         //
         Iosb.Status = 0;
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Call driver to mark USN\n"));

         retval = IoCallDriver(deviceObject, irp);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - IoCallDriver returns %x.\n", retval));

         if (retval == STATUS_PENDING) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Wait for event.\n"));
            retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
         }

         ExFreePool(pHinfo);
         retval = Iosb.Status;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Iosb returns %x.\n", retval));

         if (!NT_SUCCESS(retval)) {
            //
            // Log an error
            //
            RsLogError(__LINE__, AV_MODULE_RPZW, retval,
                       AV_MSG_MARK_USN_FAILED, NULL, NULL);

         }
         ZwClose(volHandle);
      } else {
         ZwClose(volHandle);
         ExFreePool(pHinfo);
         RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(IRP),
                    AV_MSG_MEMORY, NULL, NULL);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Failed to allocate an Irp.\n"));
         retval = STATUS_INSUFFICIENT_RESOURCES;
      }

   }except (RsExceptionFilter(L"RsMarkUsn", GetExceptionInformation()) ) {
      retval = STATUS_INVALID_USER_BUFFER;
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Returning %x.\n", retval));
   return(retval);
}


NTSTATUS
RsCompleteRecall(IN PDEVICE_OBJECT DeviceObject,
                 IN ULONGLONG filterId, 
                 IN NTSTATUS recallStatus, 
                 IN ULONG RecallAction,
                 IN BOOLEAN CancellableRead) 
/*++

Routine Description:

   Completes the recall processing for this filter id.  All reads/writes are allowed to
   complete for all file objects waiting on this recall.  The file object remains in the queue until
   it is closed.

Arguments:

    DeviceObject - Filter device object
    FilterId     - The ID assigned when this request was added to the queue
    RecallStatus - Status of the recall operation
    RecallAction - Bitmask of actions to take after successful recall
    CancellableRead - This parameter is only checked if this was for a 
                      read-no-recall that is completing.
                      If TRUE - it indicates the IRP is cancellable,
                      if FALSE - the IRP is not cancellable

Return Value:

    0 If successful, non-zero if the id was not found.

Note:
    Do not count on the file context entry being there after this call.

--*/

{
   PRP_FILE_CONTEXT    context;
   PRP_FILE_OBJ        entry;
   BOOLEAN             done = FALSE, found;
   KIRQL               rirqL;
   LONGLONG            fileId;
   PRP_IRP_QUEUE       readIo;
   LARGE_INTEGER       combinedId;
   NTSTATUS            status = STATUS_SUCCESS;
   BOOLEAN             gotLock = FALSE;


   try {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Completion for %I64x!\n", filterId));

      context = RsAcquireFileContext(filterId, TRUE);

      if (NULL == context) {
         return(STATUS_SUCCESS);
      }

      gotLock = TRUE;
      combinedId.QuadPart = filterId;
      //
      //
      if (!(combinedId.QuadPart & RP_TYPE_RECALL)) {
         //
         // If this was no-recall open we need to complete the
         // read now.  We do this by finding the correct file object entry and the matching read.
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Look for no-recall read.\n"));
         done = FALSE;
         found = FALSE;
         //
         // Lock the file object queue
         //
         entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                   RP_FILE_OBJ,
                                   list);

         while ((!done) && (entry != CONTAINING_RECORD(&context->fileObjects,
                                                       RP_FILE_OBJ,
                                                       list))) {
            if (!IsListEmpty(&entry->readQueue)) {
               //
               // Look at the reads to see if one has the matching ID
               //
               //                 
               found = FALSE;
               ExAcquireSpinLock(&entry->qLock, &rirqL);
               readIo =  CONTAINING_RECORD(entry->readQueue.Flink,
                                           RP_IRP_QUEUE,
                                           list);

               while ((readIo != CONTAINING_RECORD(&entry->readQueue,
                                                   RP_IRP_QUEUE,
                                                   list)) && (FALSE == found)) {
                  if (readIo->readId == (combinedId.HighPart & RP_READ_MASK)) {
                     //
                     // Found our read entry 
                     //
                     found = TRUE;
                     if (CancellableRead) {
                         //
                         // Clear the cancel routine first
                         //
                         if (RsClearCancelRoutine(readIo->irp)) {
                              RemoveEntryList(&readIo->list);
                         } else {
                              readIo = NULL;
                         }                   
                     } else {
                        RemoveEntryList(&readIo->list);
                     }
                  } else {
                     readIo = CONTAINING_RECORD(readIo->list.Flink,
                                                RP_IRP_QUEUE,
                                                list);
                  }
               }

               ExReleaseSpinLock(&entry->qLock, rirqL);

               if (found) {
                  done = TRUE;
                  break;
               }
            }
            //
            // Move on to next file object
            //
            entry = CONTAINING_RECORD(entry->list.Flink,
                                      RP_FILE_OBJ,
                                      list
                                     );
         }
         RsReleaseFileContext(context);

         if (!found) {
            //
            // Read was not found!
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCompleteRecall - no recall read Irp not found!\n"));
            return  (STATUS_NOT_FOUND);
         }

         if (readIo == NULL) {
            //
            // It was cancelled..
            //
            return STATUS_CANCELLED;
         }
    
         if (!NT_SUCCESS(status)) {
             readIo->irp->IoStatus.Status = STATUS_FILE_IS_OFFLINE;
         } else {
             readIo->irp->IoStatus.Status = recallStatus;
         }

         RsCompleteRead(readIo,
         (BOOLEAN) ((NULL == readIo->userBuffer) ? FALSE : TRUE));

         ExFreePool(readIo);

      } else {
         //
         // Normal recall
         //
         // We need to release the file context resource whilt making calls to NTFS because it could deadlock with
         // reads that may be going on.  The read causes a paging IO read (which holds the paging IO resource) and
         // when we see the paging IO read we try to get the context resource in RsCheckRead and if we are holding it
         // here and a call here requires the paging IO esource we deadlock.
         //

         fileId = context->fileId;
         //
         // If we did not complete the recall we need to re-truncate the file
         //
         if (((context->currentOffset.QuadPart != 0) &&
             (context->currentOffset.QuadPart != context->rpData.data.dataStreamSize.QuadPart))) {
           //
           // The recall is being abandoned by FSA for some reason before it's complete
           //
           DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, 
                     "RsFilter: RsCompleteRecall - File was not fully recalled - %I64u bytes of %I64u\n",
                     context->currentOffset.QuadPart,
                     context->rpData.data.dataStreamSize.QuadPart));
            
            context->state = RP_RECALL_NOT_RECALLED;
            context->recallStatus = recallStatus;
            RsTruncateFile(context);

         } else if (!NT_SUCCESS(recallStatus)) {
             //
             // Completed with errors and none of the file was ever recalled 
             //
             context->state = RP_RECALL_NOT_RECALLED;
             context->recallStatus = recallStatus;
         } else {
             //
             // The context has the true recall status at this point
             // i.e. the FSA might think the recall completed successfully -
             // but if we fail to set the premigrated state or something else failed,
             // the filter would have updated context->recallStatus appropriately
             //
             recallStatus = context->recallStatus;
         }

         if (context->handle != 0) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Closing the handle.\n"));
            ObDereferenceObject( context->fileObjectToWrite );

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;

            ZwClose(context->handle);

            RsAcquireFileContextEntryLockExclusive(context);
            gotLock = TRUE;

            InterlockedDecrement((PLONG) &context->refCount);
            context->handle = 0;
         }
         //
         // Technically the recall's not complete till we get this message from FSA
         //
         KeSetEvent(&context->recallCompletedEvent,
                    IO_NO_INCREMENT,
                    FALSE);
         //
         // Now complete the reads and writes for all file objects
         // that have not been completed yet (but only the ones
         // open for recall).
         //
         do {
            done = TRUE;

            entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                      RP_FILE_OBJ,
                                      list);

            while (entry != CONTAINING_RECORD(&context->fileObjects,
                                              RP_FILE_OBJ,
                                              list)) {


               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Checking %x, QHead is (%x).\n", entry, &context->fileObjects));

               if ((!RP_IS_NO_RECALL(entry)) &&
                   !(entry->flags & RP_NO_DATA_ACCESS)  &&
                   (!IsListEmpty(&entry->readQueue)  ||
                    !IsListEmpty(&entry->writeQueue)) ) {
                  //
                  // Complete pending requests on this file which have been waiting for
                  // the recall
                  //
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Completing entry %x (next is %x) Qhead is (%x).\n",
                                        entry, entry->list.Flink, &context->fileObjects));

                  RsReleaseFileContextEntryLock(context);
                  gotLock = FALSE;
                  //
                  // Reference the file object so the file object (and context)
                  // entry is not removed on us.
                  //
                  ObReferenceObject(entry->fileObj);

                  if (entry->filterId == (combinedId.QuadPart & RP_FILE_MASK)) {
                     entry->recallAction = RecallAction;
                  }
                  //
                  // Complete all pending IRPs for this file object
                  // If failing them - use STATUS_FILE_IS_OFFLINE
                  //
                  RsCompleteAllRequests(context, entry, NT_SUCCESS(recallStatus)?recallStatus:STATUS_FILE_IS_OFFLINE);
                  //
                  // Now we can  release the file object
                  //
                  ObDereferenceObject(entry->fileObj);

                  RsAcquireFileContextEntryLockExclusive(context);
                  gotLock = TRUE;
                  //
                  // We have to rescan the entire list again because
                  // we let go of the file context lock
                  //
                  entry = NULL;
                  done = FALSE;
                  break;
               }
               //
               // Move on to next file object
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Get next entry %x.\n", entry->list.Flink));

               entry = CONTAINING_RECORD(entry->list.Flink,
                                         RP_FILE_OBJ,
                                         list
                                        );
            }
         } while (!done);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Done.\n"));
         //
         // deref the context entry and free it if required.
         //
         RsReleaseFileContext(context);
         gotLock = FALSE;
      }

   }except (RsExceptionFilter(L"RsCompleteRecall", GetExceptionInformation())) {
        if (gotLock) {
            RsReleaseFileContext(context);
            gotLock = FALSE;
        }
        status = STATUS_UNSUCCESSFUL;
   }

   return (status);
}



NTSTATUS
RsOpenTarget(IN  PRP_FILE_CONTEXT Context,
             IN  ULONG            OpenAccess,
	     IN  ULONG            AdditionalAccess,
             OUT HANDLE          *Handle,
             OUT PFILE_OBJECT    *FileObject)
/*++

Routine Description:

    Open the target file with the given access and modifies
    the access after opening.

Arguments:

    Context             - Pointer to file context
    OpenAccess          - Access flags with which to open the file
    AdditionalAccess    - Additional access needed but which would fail an access check
                          eg when we need to recall a readonly file.
    FileObject          - Pointer to the file object of open is returned here

Return Value:

    Status

--*/

{
   NTSTATUS                  retval = STATUS_SUCCESS;
   OBJECT_ATTRIBUTES         obj;
   IO_STATUS_BLOCK           iob;
   PDEVICE_EXTENSION         deviceExtension = Context->FilterDeviceObject->DeviceExtension;
   POBJECT_NAME_INFORMATION  nameInfo = NULL;
   OBJECT_HANDLE_INFORMATION handleInformation;
   LARGE_INTEGER             byteOffset;
   UNICODE_STRING            strFileId;
   HANDLE                    VolumeHandle;


   PAGED_CODE();


   //
   // Get a handle for the volume
   //
   retval = RsGenerateDevicePath (Context->devObj, &nameInfo);

   if (!NT_SUCCESS (retval)) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - Failed to generate the full path - %x.\n", retval));
   }


   if (NT_SUCCESS(retval)) {

      InitializeObjectAttributes (&obj,
				  &nameInfo->Name,
				  OBJ_KERNEL_HANDLE,
				  NULL,
				  NULL);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsOpenTarget - Opening Volume %ws.\n", nameInfo->Name.Buffer));

      retval = IoCreateFile (&VolumeHandle, 
			     FILE_READ_ATTRIBUTES | SYNCHRONIZE,
			     &obj, 
			     &iob, 
			     NULL,
			     0L,
			     FILE_SHARE_READ | FILE_SHARE_WRITE,
			     FILE_OPEN,
			     FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
			     NULL,
			     0,
			     CreateFileTypeNone,
			     NULL,
			     IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);

      if (!NT_SUCCESS (retval)) {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - IoCreateFile (Volume) returned %x.\n", retval));
      }
   }



   if (NT_SUCCESS(retval)) {
      //
      // Now that we have a handle to the volume, do a relative open by file id.
      //
      RtlInitUnicodeString (&strFileId, (PWCHAR) &Context->fileId);

      strFileId.Length        = 8;
      strFileId.MaximumLength = 8;


      InitializeObjectAttributes (&obj,
				  &strFileId,
				  OBJ_KERNEL_HANDLE,
				  VolumeHandle,
				  NULL);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsOpenTarget - Opening target file by Id %ws.\n", nameInfo->Name.Buffer));


      retval = IoCreateFileSpecifyDeviceObjectHint (Handle, 
						    OpenAccess | SYNCHRONIZE,
						    &obj,
						    &iob,
						    NULL,
						    0L,
						    0L,
						    FILE_OPEN,
						    FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
						    NULL,
						    0,
						    CreateFileTypeNone,
						    NULL,
						    IO_IGNORE_SHARE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING,
						    deviceExtension->FileSystemDeviceObject);


      ZwClose (VolumeHandle);

      if (!NT_SUCCESS (retval)) {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - IoCreateFile (target) returned %x.\n", retval));
      }
   }


   if (NT_SUCCESS(retval)) {

      retval = ObReferenceObjectByHandle( *Handle,
					  0L,
					  NULL,
					  KernelMode,
					  (PVOID *) FileObject,
					  &handleInformation);

      if (!NT_SUCCESS(retval)) {

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - ref file object returned %x.\n", retval));
	 ZwClose(*Handle);
	 retval = STATUS_UNSUCCESSFUL;

      } else {

         // Apply the extra access directly to the file object if required. This is 
         // what lets us bypass the readonly attribute that may be set on the file.
         //
         if (AdditionalAccess & GENERIC_WRITE) {
	    (*FileObject)->WriteAccess = TRUE;
	 }

         if (AdditionalAccess & GENERIC_READ) {
            (*FileObject)->ReadAccess = TRUE;
         }

         //
         // Reference the context
         //
         InterlockedIncrement((PLONG) &Context->refCount);
         retval = STATUS_SUCCESS;

      }
   }


   if (NULL != nameInfo) {
      ExFreePool(nameInfo);
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsOpenTarget - returning %x.\n", retval));

   return(retval);
}



//
//  Local Support routine
//

NTSTATUS
RsQueryValueKey (
                IN PUNICODE_STRING KeyName,
                IN PUNICODE_STRING ValueName,
                IN OUT PULONG ValueLength,
                IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
                IN OUT PBOOLEAN DeallocateKeyValue
                )

/*++

Routine Description:

    Given a unicode value name this routine will return the registry
    information for the given key and value.

Arguments:

    KeyName - the unicode name for the key being queried.

    ValueName - the unicode name for the registry value located in the registry.

    ValueLength - On input it is the length of the allocated buffer.  On output
        it is the length of the buffer.  It may change if the buffer is
        reallocated.

    KeyValueInformation - On input it points to the buffer to use to query the
        the value information.  On output it points to the buffer used to
        perform the query.  It may change if a larger buffer is needed.

    DeallocateKeyValue - Indicates if the KeyValueInformation buffer is on the
        stack or needs to be deallocated.

Return Value:

    NTSTATUS - indicates the status of querying the registry.

--*/

{
   HANDLE        Handle;
   NTSTATUS      Status;
   ULONG         RequestLength;
   ULONG         ResultLength;
   OBJECT_ATTRIBUTES ObjectAttributes;
   PVOID         NewKey;

   PAGED_CODE();

   InitializeObjectAttributes( &ObjectAttributes,
                               KeyName,
                               0,
                               NULL,
                               NULL);

   Status = ZwOpenKey( &Handle,
                       KEY_READ,
                       &ObjectAttributes);

   if (!NT_SUCCESS( Status )) {

      return Status;
   }

   RequestLength = *ValueLength;


   while (TRUE) {

      Status = ZwQueryValueKey( Handle,
                                ValueName,
                                KeyValueFullInformation,
                                *KeyValueInformation,
                                RequestLength,
                                &ResultLength);

      ASSERT( Status != STATUS_BUFFER_OVERFLOW );

      if (Status == STATUS_BUFFER_OVERFLOW) {

         //
         // Try to get a buffer big enough.
         //

         if (*DeallocateKeyValue) {

            ExFreePool( *KeyValueInformation );
            *ValueLength = 0;
            *KeyValueInformation = NULL;
            *DeallocateKeyValue = FALSE;
         }

         RequestLength += 256;

         NewKey = (PKEY_VALUE_FULL_INFORMATION)
                  ExAllocatePoolWithTag( PagedPool,
                                         RequestLength,
                                         'TLSR');

         if (NewKey == NULL) {
            return STATUS_NO_MEMORY;
         }

         *KeyValueInformation = NewKey;
         *ValueLength = RequestLength;
         *DeallocateKeyValue = TRUE;

      } else {

         break;
      }
   }

   ZwClose(Handle);

   if (NT_SUCCESS(Status)) {

      //
      // Treat as if no value was found if the data length is zero.
      //

      if ((*KeyValueInformation)->DataLength == 0) {

         Status = STATUS_OBJECT_NAME_NOT_FOUND;
      }
   }

   return Status;
}

#ifdef TRUNCATE_ON_CLOSE
NTSTATUS
RsTruncateOnClose (
                  IN PRP_FILE_CONTEXT Context
                  )

/*++

Routine Description:

    Truncate the file specified by the context entry

Arguments:

   Context      - Context entry

Return Value:

   status

--*/
{
   NTSTATUS                status = STATUS_SUCCESS;
   LARGE_INTEGER           fSize;

   PAGED_CODE();

   //
   // Open the file for exclusive access (ask for read/write data)
   // If it fails then someone else has it open and we can just bail out.
   //
   //
   //
   //    BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE 
   //
   // We need to make sure that the access check in RsOpenTarget() actually 
   // happens in this case. If we ever turn this functionality on then we 
   // need to have a means of telling RsOpenTarget() to not bypass the 
   // access check.
   //
   //    BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE 
   //
   ASSERT (FALSE);

   RsReleaseFileContextEntryLock(Context);
   if (NT_SUCCESS (status = RsOpenTarget(Context,
                                         FILE_READ_DATA | FILE_WRITE_DATA,
					 0,
                                         &Context->handle,
                                         &Context->fileObjectToWrite))) {

      //
      // Indicate to USN the writes are happening by HSM
      // and preserve last modified date
      //
      RsMarkUsn(Context);
      RsPreserveDates(Context);
      RsAcquireFileContextEntryLockExclusive(Context);

      fSize.QuadPart = 0;
      if (MmCanFileBeTruncated(Context->fileObjectToWrite->SectionObjectPointer, &fSize)) {
         if (NT_SUCCESS (status = RsTruncateFile(Context))) {
            Context->rpData.data.bitFlags |= RP_FLAG_TRUNCATED;
            RP_CLEAR_ORIGINATOR_BIT( Context->rpData.data.bitFlags );
            RP_GEN_QUALIFIER(&(Context->rpData), Context->rpData.qualifier);
            //
            // Note that the originator bit is not included in the checksum
            //
            RP_SET_ORIGINATOR_BIT( Context->rpData.data.bitFlags );
            status = RsWriteReparsePointData(Context);
            Context->state = RP_RECALL_NOT_RECALLED;
            Context->recallStatus = 0;
            Context->currentOffset.QuadPart = 0;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - File truncated on close.\n"));
         }
      } else {
         RsAcquireFileContextEntryLockExclusive(Context);
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - File not truncated on close because another user has it open.\n"));
      }
      ObDereferenceObject( Context->fileObjectToWrite );
      Context->fileObjectToWrite = NULL;
      ZwClose(Context->handle);
      Context->handle = 0;
      //
      // We can deref the context now
      //
      InterlockedDecrement((PLONG) &Context->refCount);
   }

   return(status);
}
#endif


NTSTATUS
RsSetPremigratedState(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   Marks the file as pre-migrated.

Arguments:

   Context      - File context entry

Return Value:

    0 If successful, non-zero if the id was not found.

Note:
   Assumes the context entry is locked and releases it temporarily.  Acquired exclusive on exit.

--*/

{
   LARGE_INTEGER  currentTime;
   NTSTATUS       status = STATUS_SUCCESS;

   PAGED_CODE();

   try {
      if (Context->handle != 0) {
         Context->rpData.data.bitFlags &= ~RP_FLAG_TRUNCATED;
         KeQuerySystemTime(&currentTime);
         Context->rpData.data.recallTime = currentTime;
         Context->rpData.data.recallCount++;
         RP_CLEAR_ORIGINATOR_BIT( Context->rpData.data.bitFlags );

         RP_GEN_QUALIFIER(&(Context->rpData), Context->rpData.qualifier);
         //
         // Note that the originator bit is not included in the checksum
         //
         RP_SET_ORIGINATOR_BIT( Context->rpData.data.bitFlags );
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetPremigrated - Setting %x to premigrated.\n", Context));

         RsReleaseFileContextEntryLock(Context);

         status = RsWriteReparsePointData(Context);

         if (NT_SUCCESS(status)) {

             NTSTATUS setAttributeStatus;
             //
             // This operation may fail but it is not critical
             //
             setAttributeStatus = RsSetResetAttributes(Context->fileObjectToWrite,
                                                       0,
                                                       FILE_ATTRIBUTE_OFFLINE);
             if (!NT_SUCCESS(setAttributeStatus)) {
                 //
                 // This is non-critical. Just log a message indicating we failed to 
                 // reset FILE_ATTRIBUTE_OFFLINE for the file though it's premgirated
                 //
                 RsLogError(__LINE__, 
                            AV_MODULE_RPZW, 
                            setAttributeStatus,
                            AV_MSG_RESET_FILE_ATTRIBUTE_OFFLINE_FAILED, 
                            NULL, 
                            (PWCHAR) Context->uniName->Name.Buffer);
             }
         }  else {
                //
                // Log an error
                //
                RsLogError(__LINE__, 
                           AV_MODULE_RPZW, 
                           status,
                           AV_MSG_SET_PREMIGRATED_STATE_FAILED, 
                           NULL, 
                           (PWCHAR) Context->uniName->Name.Buffer);
                //
                // Truncate the file back... 
                //
                RsTruncateFile(Context);
         }

         RsAcquireFileContextEntryLockExclusive(Context);
      }

   }except (RsExceptionFilter(L"RsSetPremigrated", GetExceptionInformation()) ) {
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsSetPremigrated - Exception = %x.\n", GetExceptionCode()));

   }

   return (status);
}


NTSTATUS
RsDeleteReparsePoint(IN PRP_FILE_CONTEXT Context)
                     
/*++

Routine description

   Deletes HSM reparse point on the file - if there was one

Arguments

   Context - pointer to the file context entry for the file

Return  Value

   Status

--*/
{
   REPARSE_DATA_BUFFER rpData;
   NTSTATUS status;
   IO_STATUS_BLOCK ioStatus;
   PIRP              irp;
   PIO_STACK_LOCATION irpSp;
   KEVENT event;
   HANDLE       handle = NULL;
   PFILE_OBJECT fileObject = NULL;
   PDEVICE_OBJECT deviceObject;
   BOOLEAN      gotLock = FALSE;

   PAGED_CODE();
   try {
      RsAcquireFileContextEntryLockExclusive(Context);
      gotLock = TRUE;

      status = RsOpenTarget(Context,
                            0,
                            GENERIC_WRITE,
                            &handle,
                            &fileObject);

      if (!NT_SUCCESS(status)) {
         RsReleaseFileContextEntryLock(Context);
         gotLock = FALSE;
         return status;
      }
      RtlZeroMemory(&rpData, sizeof(REPARSE_DATA_BUFFER_HEADER_SIZE));
      rpData.ReparseTag = IO_REPARSE_TAG_HSM;
      rpData.ReparseDataLength = 0;

      KeInitializeEvent(&event,
                        SynchronizationEvent,
                        FALSE);
    
      deviceObject = IoGetRelatedDeviceObject(fileObject);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDeleteReparsePoint: DevObj stack locations %d\n", deviceObject->StackSize));
      
      irp =  IoBuildDeviceIoControlRequest(FSCTL_DELETE_REPARSE_POINT,
                                           deviceObject,
                                           &rpData,
                                           REPARSE_DATA_BUFFER_HEADER_SIZE,
                                           NULL,
                                           0,
                                           FALSE,
                                           &event,
                                           &ioStatus);

      if (irp == NULL) {
         RsReleaseFileContextEntryLock(Context);
         gotLock = FALSE;
         ObDereferenceObject(fileObject);
         ZwClose(handle);
         //
         // We can deref the context now
         //
         InterlockedDecrement((PLONG) &Context->refCount);
         return STATUS_INSUFFICIENT_RESOURCES;
      }
      //
      // Fill in the other stuff
      //
      irp->Tail.Overlay.OriginalFileObject = fileObject;
      //
      // Important since we supply a user event & wait for the IRP to complete
      //
      irp->Flags |= IRP_SYNCHRONOUS_API;

      irpSp = IoGetNextIrpStackLocation(irp);
      irpSp->FileObject = fileObject;
      irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
      irpSp->Parameters.FileSystemControl.InputBufferLength = REPARSE_DATA_BUFFER_HEADER_SIZE;
      status = IoCallDriver(deviceObject,
                            irp);

      fileObject = NULL;
      if (status == STATUS_PENDING) {
         (VOID)KeWaitForSingleObject(&event,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     (PLARGE_INTEGER) NULL);
         status = ioStatus.Status;
      }

      RsReleaseFileContextEntryLock(Context);
      gotLock = FALSE;

      DebugTrace((DPFLTR_RSFILTER_ID, DBG_VERBOSE, "RsFilter: RsDeleteReparsePoint: fileObject %x, handle %x\n", fileObject, handle));

      ZwClose(handle);
      //
      // We can deref the context now
      //
      InterlockedDecrement((PLONG) &Context->refCount);

   } except (RsExceptionFilter(L"RsDeleteReparsePoint", GetExceptionInformation())) {

      if (gotLock) {
         RsReleaseFileContextEntryLock(Context);
         gotLock = FALSE;
      }
      if (handle != NULL) {
          if (fileObject != NULL) {
               ObDereferenceObject(fileObject);
          }
          ZwClose(handle);
          InterlockedDecrement((PLONG) &Context->refCount);
      }
   }
   return status;
}


NTSTATUS
RsSetResetAttributes(IN PFILE_OBJECT     FileObject,
                     IN ULONG            SetAttributes,
                     IN ULONG            ResetAttributes)
/*++

Routine Description:

    Sets and resets the supplied file attributes for the file

Arguments:

    FileObject          - Pointer to the file object
    SetAttributes       - The list of attributes that need to be set
    ResetAttributes     - The list of attributes that need to be turned off

Return Value:

     STATUS_INVALID_PARAMETER - SetAttributes/ResetAttributes were not
                                mutually exclusive
     STATUS_SUCCESS           - Successfully set/reset attributes
     any other status         - some error occurred


--*/

{
   NTSTATUS                    retval = STATUS_SUCCESS;
   KEVENT                      event;
   PIO_STACK_LOCATION          irpSp;
   IO_STATUS_BLOCK             Iosb;
   PIRP                        irp;
   FILE_BASIC_INFORMATION      info;
   PDEVICE_OBJECT              deviceObject;

   PAGED_CODE();

   try {

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Build Irp for Set file info.\n"));

      //
      // Set and reset attributes should be mutually exclusive
      //
      if ((SetAttributes & ResetAttributes) != 0) {
        return STATUS_INVALID_PARAMETER;
      }
      //
      // If both are 0, we have nothing to do
      //
      if ((SetAttributes | ResetAttributes) == 0) {
        return STATUS_SUCCESS;
      }

      //
      // First get the file info so we have the attributes
      //
      deviceObject = IoGetRelatedDeviceObject(FileObject);
      irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

      if (irp) {
         irp->UserEvent = &event;
         irp->UserIosb = &Iosb;
         irp->Tail.Overlay.Thread = PsGetCurrentThread();
         irp->Tail.Overlay.OriginalFileObject = FileObject;
         irp->RequestorMode = KernelMode;
         irp->Flags |= IRP_SYNCHRONOUS_API;
         //
         // Initialize the event
         //
         KeInitializeEvent(&event, SynchronizationEvent, FALSE);

         //
         // Set up the I/O stack location.
         //

         irpSp = IoGetNextIrpStackLocation(irp);
         irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
         irpSp->FileObject = FileObject;
         irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
         irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
         irp->AssociatedIrp.SystemBuffer = &info;

         //
         // Set the completion routine.
         //
         IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

         //
         // Send it to the FSD
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Call driver to get date info\n"));
         Iosb.Status = 0;

         retval = IoCallDriver(deviceObject, irp);

         if (retval == STATUS_PENDING) {
            retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
         }

         retval = Iosb.Status;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Query returns %x.\n", retval));
      } else {
         retval = STATUS_INSUFFICIENT_RESOURCES;
         RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(IRP),
                    AV_MSG_MEMORY, NULL, NULL);
      }

      if (retval == STATUS_SUCCESS) {
         irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
         if (irp) {
            irp->UserEvent = &event;
            irp->UserIosb = &Iosb;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->Tail.Overlay.OriginalFileObject = FileObject;
            irp->RequestorMode = KernelMode;
            irp->Flags |= IRP_SYNCHRONOUS_API;
            //
            // Initialize the event
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);
            //
            // Set the requisite attributes
            //
            info.FileAttributes |= SetAttributes;
            //
            // Reset the requisite attributes
            //
            info.FileAttributes &= ~ResetAttributes;

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
            irpSp->FileObject = FileObject;
            irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
            irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
            irp->AssociatedIrp.SystemBuffer = &info;

            //
            // Set the completion routine.
            //
            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            //
            // Send it to the FSD
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Call driver to set dates to -1.\n"));
            Iosb.Status = 0;

            retval = IoCallDriver(deviceObject, irp);


            if (retval == STATUS_PENDING) {
               retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }

            retval = Iosb.Status;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Set dates returns %x.\n", retval));

            if (!NT_SUCCESS(retval)) {
               //
               // Log an error
               //
               RsLogError(__LINE__, AV_MODULE_RPZW, retval,
                          AV_MSG_PRESERVE_DATE_FAILED, NULL, NULL);
            }


         } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(IRP),
                       AV_MSG_MEMORY, irpSp, NULL);
         }
      }
   }except (RsExceptionFilter(L"RsSetAttributes", GetExceptionInformation())) {
      retval = STATUS_INVALID_USER_BUFFER;
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Returning %x.\n", retval));
   return(retval);
}


NTSTATUS
RsTruncateFile(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description

   Set the file size

Arguments

   Context - Represents the file to truncate

Return Value

   STATUS_SUCCESS                - File was truncated
   STATUS_INSUFFICIENT_RESOURCES - Failure to allocate memory
   Other                         - Status from file system


--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;


    PAGED_CODE();

    try {

        status = RsSetEndOfFile(Context, 0);
        if (NT_SUCCESS(status)) {
            status = RsSetEndOfFile(Context,
                                    Context->rpData.data.dataStreamSize.QuadPart);
        }

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                       AV_MSG_SET_SIZE_FAILED, NULL, (PWCHAR) L"RsTruncateFile");

        }

    }except (RsExceptionFilter(L"RsTruncateFile", GetExceptionInformation()))
    {
        status = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsTruncateFile - Returning %x.\n", status));
    return(status);
}


NTSTATUS
RsSetEndOfFile(IN PRP_FILE_CONTEXT Context,
               IN ULONGLONG size)
/*++

Routine Description

   Set the file size

Arguments

   DeviceObject - Filter device object
   Context - Represents the file to set the size of
   Size    - Size to set

Return Value

   STATUS_SUCCESS                - File size was set
   STATUS_INSUFFICIENT_RESOURCES - Failure to allocate memory
   Other                         - Status from file system


--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp = NULL;
    BOOLEAN                     oldWriteAccess;
    FILE_END_OF_FILE_INFORMATION info;
    PDEVICE_OBJECT              deviceObject;


    PAGED_CODE();

    try {

        deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);

        irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

        if (!irp) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        irp->UserEvent = &event;
        irp->UserIosb = &Iosb;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
        irp->RequestorMode = KernelMode;
        irp->Flags |= IRP_SYNCHRONOUS_API;
        //
        // Initialize the event
        //
        KeInitializeEvent(&event,
                          SynchronizationEvent,
                          FALSE);

        //
        // Set up the I/O stack location.
        //
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
        irpSp->FileObject   = Context->fileObjectToWrite;
        irpSp->Parameters.SetFile.Length = sizeof(FILE_END_OF_FILE_INFORMATION);
        irpSp->Parameters.SetFile.FileInformationClass = FileEndOfFileInformation;
        irpSp->Parameters.SetFile.FileObject = Context->fileObjectToWrite;
        irp->AssociatedIrp.SystemBuffer = &info;

        info.EndOfFile.QuadPart = size;
        //
        // Set the completion routine.
        //
        IoSetCompletionRoutine( irp,
                                RsCompleteIrp,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE );
        //
        // Give the file object permission to write
        //
        oldWriteAccess = Context->fileObjectToWrite->WriteAccess;
        Context->fileObjectToWrite->WriteAccess = TRUE;

        //
        // Send it to the FSD
        //
        Iosb.Status = STATUS_NOT_SUPPORTED;
        status = IoCallDriver(deviceObject,
                              irp);

        if (status == STATUS_PENDING) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetEndOfFile - Wait for event.\n"));
            status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        //
        // Restore the old access rights
        //
        Context->fileObjectToWrite->WriteAccess = oldWriteAccess;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetEndOffile Iosb returns %x.\n", status));
        //
        // Free the allocated reparse data buffer
        //
    }except (RsExceptionFilter(L"RsSetEndOfFile", GetExceptionInformation()))
    {
        status = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetEndOfFile - Returning %x.\n", status));
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsafltr.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsafltr.cpp

Abstract:

    This class represents a file system filter for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "stdafx.h"
extern "C" {
#include "devioctl.h"
#include <winerror.h>
#include "aclapi.h"

// #define MAC_SUPPORT  // NOTE: You must define MAC_SUPPORT in fsaftrcl.cpp to enable all the code

#ifdef MAC_SUPPORT
#include <macfile.h>
#endif  
}

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "HsmConn.h"
#include "job.h"
#include "fsa.h"
#include "fsafltr.h"
#include "fsaitemr.h"


#ifdef MAC_SUPPORT
extern HANDLE   FsaDllSfm;
extern BOOL     FsaMacSupportInstalled;

extern "C" {
typedef DWORD (*AdminConnect) (LPWSTR lpwsServerName, PAFP_SERVER_HANDLE phAfpServer);

extern  AdminConnect    pAfpAdminConnect;

typedef VOID (*AdminDisconnect) (AFP_SERVER_HANDLE hAfpServer);

extern  AdminDisconnect pAfpAdminDisconnect;

typedef VOID (*AdminBufferFree) (PVOID pBuffer);

extern  AdminBufferFree pAfpAdminBufferFree;

typedef DWORD (*AdminSessionEnum) (AFP_SERVER_HANDLE hAfpServer, LPBYTE *lpbBuffer,
                    DWORD dwPrefMaxLen, LPDWORD lpdwEntriesRead, LPDWORD lpdwTotalEntries,
                    LPDWORD lpdwResumeHandle);

extern  AdminSessionEnum    pAfpAdminSessionEnum;
}
#endif  

DWORD FsaIoctlThread(void *pFilterInterface);
DWORD FsaPipeThread(void *pFilterInterface);


HRESULT
CFsaFilter::Cancel(
    void
    )

/*++

Implements:

  IFsaFilter::Cancel().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CFsaFilter::Cancel"), OLESTR(""));
    
    try {

        WsbAffirm((HSM_JOB_STATE_ACTIVE == m_state), E_UNEXPECTED);

        oldState = m_state;
        m_state = HSM_JOB_STATE_CANCELLING;

        try {

            // TBD - Do whatever it takes to cancel
            WsbAssertHr(E_NOTIMPL);
            m_state = HSM_JOB_STATE_CANCELLED;

        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::CancelRecall(
    IN IFsaFilterRecall* pRecall
    )

/*++

Implements:

  IFsaFilter::CancelRecall().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;

    WsbTraceIn(OLESTR("CFsaFilter::CancelRecall"), OLESTR(""));
    
    try {

        WsbAssert(pRecall != 0, E_POINTER);

        // Get the private interface and tell the recall to cancel itself.
        WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->Cancel());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CancelRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaFilter>     pFilter;

    WsbTraceIn(OLESTR("CFsaFilter::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilter, (void**) &pFilter));

        // Compare the rules.
        hr = CompareToIFilter(pFilter, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilter::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilter::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaFilter::CompareToIdentifier"), OLESTR(""));

    try {

        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilter::CompareToIFilter(
    IN IFsaFilter* pFilter,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilter::CompareToIFilter().

--*/
{
    HRESULT         hr = S_OK;
    GUID            id;

    WsbTraceIn(OLESTR("CFsaFilter::CompareToIFilter"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pFilter, E_POINTER);
        WsbAffirmHr(pFilter->GetIdentifier(&id));
        // Either compare the name or the id.
        hr = CompareToIdentifier(id, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CompareToIFilter"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilter::CleanupClients(
    void
    )

/*++

Implements:

  CFsaFilter::CleanupClients()

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterClient>       pClient;
    CComPtr<IWsbEnum>               pEnum;
    FILETIME                        now, last;
    LARGE_INTEGER                   tNow, tLast;

    WsbTraceIn(OLESTR("CFsaFilter::CleanupClients"), OLESTR(""));
    
    EnterCriticalSection(&m_clientLock);

    try {

        WsbAffirmHr(m_pClients->Enum(&pEnum));
        hr = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);

        while (S_OK == hr) {
            GetSystemTimeAsFileTime(&now);
            tNow.LowPart = now.dwLowDateTime;
            tNow.HighPart = now.dwHighDateTime;
    
            WsbAffirmHr(pClient->GetLastRecallTime(&last));
            tLast.LowPart = last.dwLowDateTime;
            tLast.HighPart = last.dwHighDateTime;
            //
            //  Get the time (in 100 nano-second units)
            //  from the end of the last recall until now.
            //
            if (tLast.QuadPart != 0) {
                tNow.QuadPart -= tLast.QuadPart;
                //
                // Convert to seconds and check against the expiration time
                //
                tNow.QuadPart /= (LONGLONG) 10000000;
                if (tNow.QuadPart > (LONGLONG) FSA_CLIENT_EXPIRATION_TIME) {
                    //
                    // This client structure is old - blow it away
                    //
                    WsbTrace(OLESTR("CFsaFilter::CleanupClients - cleaning up old client (%ls)\n"),
                        WsbLonglongAsString(tNow.QuadPart));
                    m_pClients->RemoveAndRelease(pClient);
                    pClient = NULL;
                    WsbAffirmHr(pEnum->Reset());
                }
            }

            pClient = NULL;
            hr = pEnum->Next(IID_IFsaFilterClient, (void**) &pClient);
        }
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    LeaveCriticalSection(&m_clientLock);

    WsbTraceOut(OLESTR("CFsaFilter::CleanupClients"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilter::DeleteRecall(
    IN IFsaFilterRecall* pRecall
    )

/*++

Implements:

  IFsaFilter::DeleteRecall().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;

    WsbTraceIn(OLESTR("CFsaFilter::DeleteRecall"), OLESTR(""));
    
    try {
        ULONG numEnt;

        WsbAssert(pRecall != 0, E_POINTER);

        // Delete the request.
        WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->Delete());

        // Remove it from our collection.
        EnterCriticalSection(&m_recallLock);
        m_pRecalls->RemoveAndRelease(pRecall);
        LeaveCriticalSection(&m_recallLock);

        m_pRecalls->GetEntries(&numEnt);
        WsbTrace(OLESTR("CFsaFilter::DeleteRecall: Recall queue has %u entries after delete.\n"),
                numEnt);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::DeleteRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::EnumRecalls(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IFsaFilter::EnumRecalls().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Enum(ppEnum);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        WsbAffirmHr(CoCreateGuid(&m_id));
        m_state = HSM_JOB_STATE_IDLE;

        //
        // Start out enabled 
        //

        m_isEnabled = TRUE;
        //
        // These are the default parameters.
        // The max recalls and admin exemption setting are configurable via the admin gui.
        //
        m_minRecallInterval = 10;
        m_maxRecallBuffers = RP_MAX_RECALL_BUFFERS;
        m_maxRecalls = RP_DEFAULT_RUNAWAY_RECALL_LIMIT;
        m_exemptAdmin = FALSE;                   // By default admin is NOT exempt

        m_ioctlHandle = INVALID_HANDLE_VALUE;
        m_pipeHandle  = INVALID_HANDLE_VALUE;

        InitializeCriticalSection(&m_clientLock);
        InitializeCriticalSection(&m_recallLock);
        InitializeCriticalSection(&m_stateLock);
    
        // Create the Client List collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pClients));

        // Create the Recall List collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pRecalls));


#ifdef MAC_SUPPORT
        //
        // Attempt to load the Mac support 
        //
        FsaDllSfm = LoadLibrary(L"SFMAPI.DLL");
        if (FsaDllSfm != NULL) {
            //
            // The DLL is there - try importing the functions we will need
            //
            try {
                WsbAffirmPointer((pAfpAdminConnect = (AdminConnect) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminConnect")));
                WsbAffirmPointer((pAfpAdminDisconnect = (AdminDisconnect) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminDisconnect")));
                WsbAffirmPointer((pAfpAdminBufferFree = (AdminBufferFree) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminBufferFree")));
                WsbAffirmPointer((pAfpAdminSessionEnum = (AdminSessionEnum) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminSessionEnum")));
                FsaMacSupportInstalled = TRUE;
            } WsbCatchAndDo(hr, 
                FreeLibrary((HMODULE) FsaDllSfm);
                FsaDllSfm = NULL;
                );
        }

#endif


    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaFilter::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT     hr = S_OK;
	HANDLE		pThreadHandles[THREAD_HANDLE_COUNT];
    DWORD       nThreadCount = 0;
    BOOL        bThreads = TRUE;
    BOOL        bTerminated = TRUE;
    

    WsbTraceIn(OLESTR("CFsaFilter::FinalRelease"), OLESTR(""));
#ifdef MAC_SUPPORT
    if (FsaDllSfm != NULL) {
        FreeLibrary((HMODULE) FsaDllSfm);
        FsaDllSfm = NULL;
    }
#endif

    //
    // Stop the ioctl and pipe threads
    //
    m_state = HSM_JOB_STATE_SUSPENDING;

	// But wait until they've completed first.
    if ((m_pipeThread) && (m_ioctlThread)) {
        pThreadHandles[0] = m_pipeThread;
        pThreadHandles[1] = m_ioctlThread;
        nThreadCount = 2;
    } else if (m_pipeThread) {
        pThreadHandles[0] = m_pipeThread;
        nThreadCount = 1;
    } else if (m_ioctlThread) {
        pThreadHandles[0] = m_ioctlThread;
        nThreadCount = 1;
    } else{
        // neither of the threads exist, skip wait.
        bThreads = FALSE;
    }

    if (bThreads) {

        switch (WaitForMultipleObjects(nThreadCount, pThreadHandles, TRUE, 20000)) {
            case WAIT_FAILED: {
                WsbTrace(OLESTR("CFsaFilter::FinalRelease: WaitforMultipleObjects returned error %lu\n"),
                    GetLastError());
            }
            // fall through...

            case WAIT_TIMEOUT: {
                WsbTrace(OLESTR("CFsaFilter::FinalRelease: force-terminating threads.\n"));

                // after timeout, force termination on threads
                // bTerminated specify if the force-termination succeeds
                DWORD dwExitCode;
                if (GetExitCodeThread( m_ioctlThread, &dwExitCode)) {
                    if (dwExitCode == STILL_ACTIVE) {   // thread still active
                        if (!TerminateThread (m_ioctlThread, 0)) {
                            WsbTrace(OLESTR("CFsaFilter::FinalRelease: TerminateThread returned error %lu\n"),
                                GetLastError());
                            bTerminated = FALSE;
                        }
                    }
                } else {
                    WsbTrace(OLESTR("CFsaFilter::FinalRelease: GetExitCodeThread returned error %lu\n"),
                                GetLastError());
                    bTerminated = FALSE;
                }

                if (GetExitCodeThread( m_pipeThread, &dwExitCode)) {
                    if (dwExitCode == STILL_ACTIVE) {   // thread still active
                        if (!TerminateThread (m_pipeThread, 0)) {
                            WsbTrace(OLESTR("CFsaFilter::FinalRelease: TerminateThread returned error %lu\n"),
                                GetLastError());
                            bTerminated = FALSE;
                        }
                    }
                } else {
                    WsbTrace(OLESTR("CFsaFilter::FinalRelease: GetExitCodeThread returned error %lu\n"),
                                GetLastError());
                    bTerminated = FALSE;
                }

                break;
            }

            default:
                break;
        }
    }

    if (m_pipeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_pipeHandle);
        m_pipeHandle = INVALID_HANDLE_VALUE;
    }
    
    if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_ioctlHandle);
        m_ioctlHandle = INVALID_HANDLE_VALUE;
    }

    if (m_terminateEvent != INVALID_HANDLE_VALUE) {
        CloseHandle(m_terminateEvent);
        m_terminateEvent = INVALID_HANDLE_VALUE;
    }

    // delete CS only if threads were teriminated properly
    if (bTerminated) {
        DeleteCriticalSection(&m_clientLock);
        DeleteCriticalSection(&m_recallLock);
        DeleteCriticalSection(&m_stateLock);
    }

    CWsbCollectable::FinalRelease();

    WsbTraceOut(OLESTR("CFsaFilter::FinalRelease"), OLESTR(""));

    return(hr);

}




HRESULT
CFsaFilter::FindRecall(
    IN  GUID recallId, 
    OUT IFsaFilterRecall** pRecall
    )

/*++

Implements:

  CFsaFilter:FindRecall().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;


    WsbTraceIn(OLESTR("CFsaFilter::FindRecall"), OLESTR(""));

    
    try {

        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->SetIdentifier(recallId));
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) pRecall);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::FindRecall"), OLESTR(""));

    return(hr);
}



HRESULT
CFsaFilter::GetAdminExemption(
    OUT BOOL *pIsExempt
    )

/*++

Implements:

  IFsaFilter::GetAdminExemption().

--*/
{
    HRESULT         hr = S_OK;

    
    try {

        WsbAssert(0 != pIsExempt, E_POINTER);
        *pIsExempt = m_exemptAdmin;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaFilter::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilter::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaFilterNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaFilter::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaFilter::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetLogicalName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilter::GetLogicalName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER); 
        WsbAssert(m_pFsaServer != 0, E_POINTER); 

        // This has not been official defined, but for now the logical name will be the same name
        // as the FSA, since we will only have one filter.
        WsbAffirmHr(m_pFsaServer->GetLogicalName(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetMaxRecallBuffers(
    OUT ULONG* pMaxBuffers
    )

/*++

Implements:

  IFsaFilter::GetMaxRecallBuffers().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMaxBuffers, E_POINTER); 
        *pMaxBuffers = m_maxRecallBuffers;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetMaxRecalls(
    OUT ULONG* pMaxRecalls
    )

/*++

Implements:

  IFsaFilter::GetMaxRecalls().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMaxRecalls, E_POINTER); 
        *pMaxRecalls = m_maxRecalls;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetMinRecallInterval(
    OUT ULONG* pMinInterval
    )

/*++

Implements:

  IFsaFilter::GetMinRecallInterval().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMinInterval, E_POINTER); 
        *pMinInterval = m_minRecallInterval;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;


    WsbTraceIn(OLESTR("CFsaFilter::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // We are only storing the configuration information, NOT the collections.
        pSize->QuadPart = WsbPersistSizeOf(GUID) + 3 * WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(BOOL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaFilter::GetState(
    OUT HSM_JOB_STATE* pState
    )

/*++

Implements:

  IPersistStream::GetState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilter::GetState"), OLESTR(""));

    try {

        WsbAssert(0 != pState, E_POINTER);

        *pState = m_state;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::GetState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Init(
    IN IFsaServer* pFsaServer
    )

/*++

Implements:

  IFsaFilterPriv::Init().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pFsaServer, E_POINTER);

        // Store the parent FSA?
        m_pFsaServer = pFsaServer;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CFsaFilter::IsEnabled(
    void
    )

/*++

Implements:

  IFsaFilter::IsEnabled().

--*/
{
    return(m_isEnabled ? S_OK : S_FALSE);
}


HRESULT
CFsaFilter::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilter::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxRecalls));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_minRecallInterval));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxRecallBuffers));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isEnabled));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_exemptAdmin));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilter::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Pause(
    void
    )

/*++

Implements:

  IFsaFilter::Pause().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;
    RP_MSG                  tmp;
    DWORD                   outSize = 0;


    WsbTraceIn(OLESTR("CFsaFilter::Pause"), OLESTR(""));
    
    try {

        WsbAffirm((HSM_JOB_STATE_ACTIVE == m_state), E_UNEXPECTED);

        oldState = m_state;
        m_state = HSM_JOB_STATE_PAUSING;

        try {
            //
            // Tell the kernel mode driver to stop accepting new recall requests.
            //
            if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
                tmp.inout.command = RP_SUSPEND_NEW_RECALLS;
                WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                            sizeof(RP_MSG),
                            &tmp, sizeof(RP_MSG), &outSize, NULL))
            }
            m_state = HSM_JOB_STATE_PAUSED;

        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Resume(
    void
    )

/*++

Implements:

  IFsaFilter::Resume().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;
    RP_MSG                  tmp;
    DWORD                   outSize = 0;


    WsbTraceIn(OLESTR("CFsaFilter::Resume"), OLESTR(""));
    
    try {

        WsbAffirm((HSM_JOB_STATE_PAUSED == m_state), E_UNEXPECTED);
         
        oldState = m_state;
        m_state = HSM_JOB_STATE_RESUMING;

        try {
            //
            // Tell the kernel mode driver to start accepting recall requests.
            //
            if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
                tmp.inout.command = RP_ALLOW_NEW_RECALLS;
                WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                            sizeof(RP_MSG),
                            &tmp, sizeof(RP_MSG), &outSize, NULL))
            }

            m_state = HSM_JOB_STATE_ACTIVE;

        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaFilter::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxRecalls));
        WsbAffirmHr(WsbSaveToStream(pStream, m_minRecallInterval));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxRecallBuffers));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isEnabled));
        WsbAffirmHr(WsbSaveToStream(pStream, m_exemptAdmin));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::SendCancel(
    IN IFsaFilterRecallPriv *pRecallPriv
    )

/*++

Implements:

  IFsaFilterPriv::SendCancel()

--*/
{
    HRESULT                     hr = S_OK;
    RP_MSG                      tmp;
    DWORD                       outSize;
    ULONG                       numEnt;
    ULONGLONG                   driversId;
    CComPtr<IFsaFilterRecall>   pRecall;
    
    //Get Drivers ID of failing recall
    WsbAffirmHr(pRecallPriv->GetDriversRecallId(&driversId));

    tmp.inout.command = RP_RECALL_COMPLETE;
    tmp.inout.status = STATUS_CANCELLED;
    tmp.msg.rRep.actionFlags = 0;
    tmp.msg.rRep.filterId = driversId;
    
    DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
            &tmp, sizeof(RP_MSG), &outSize, NULL);

    //
    // Remove it from our collection
    //

    EnterCriticalSection(&m_recallLock);
    hr = m_pRecalls->RemoveAndRelease(pRecallPriv);
    LeaveCriticalSection(&m_recallLock);
    WsbAffirmHr(hr);

    hr = m_pRecalls->GetEntries(&numEnt);
    WsbTrace(OLESTR("CFsaFilter::SendCancel: Recall queue has %u entries after delete\n"), 
            numEnt);
    hr = S_OK;



    return(hr);
}

#define FSA_MAX_XFER    (1024 * 1024)   
#define FSA_MIN_XFER    (8 * 1024)  


HRESULT
CFsaFilter::SendComplete(
    IN IFsaFilterRecallPriv *pRecallPriv,
    IN HRESULT              status
    )

/*++

Implements:

  IFsaFilterPriv::SendComplete()

--*/
{
HRESULT                     hr = S_OK;
RP_MSG                      tmp;
BOOL                        code = FALSE;
ULONG                       numEnt;
BOOL                        didSend = FALSE;
DWORD                       ioSize;
CComPtr<IFsaFilterRecall>   pRecall;
CWsbStringPtr               pName;



    try {
        ioSize = sizeof(RP_MSG);

        WsbAffirmHr(pRecallPriv->QueryInterface(IID_IFsaFilterRecall, (void**) &pRecall));
        //  Get path of file failing recall.
        WsbAffirmHr(pRecall->GetPath((OLECHAR**) &pName, 0))
        WsbAssertPointer(pName);

        tmp.inout.command = RP_RECALL_COMPLETE;
        if (status == S_OK)
            tmp.inout.status = 0;
        else {
            // If the error indicates that Engine is not initialized yet -
            // log an error with law severity (it is considered as a normal situation)
            if (status != HSM_E_NOT_READY) {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(status), NULL);
            } else {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED_NOT_READY, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(status), NULL);
            }
            tmp.inout.status = TranslateHresultToNtStatus(status);
        }

        WsbAffirmHr(pRecall->GetRecallFlags(&tmp.msg.rRep.actionFlags));

        WsbAffirmHr(pRecallPriv->GetDriversRecallId(&tmp.msg.rRep.filterId));
        WsbTrace(OLESTR("CFsaFilter::SendComplete: id = %I64x status = %s\n"), 
            tmp.msg.rRep.filterId, WsbHrAsString(status));
    
        WsbAffirmHr(pRecallPriv->LogComplete(status));

        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, ioSize,
                &tmp, sizeof(RP_MSG), &ioSize, NULL));

        didSend = TRUE;

        WsbTrace(OLESTR("CFsaFilter::SendComplete: Ioctl returned %u  (%x)\n"), code, GetLastError());

        //
        // Remove it from our collection
        //

        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->RemoveAndRelease(pRecallPriv);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);

        hr = m_pRecalls->GetEntries(&numEnt);
        WsbTrace(OLESTR("CFsaFilter::SendComplete: Recall queue has %u entries after delete\n"), 
                numEnt);
        hr = S_OK;

    } WsbCatchAndDo(hr,
        RP_MSG  aTmp;

        //
        // Log an event
        //
        WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(hr), NULL);

        //
        // If for some reason we did not tell the filter to complete the IO we
        // try it here (with a error indication) so we have done everything possible to keep the
        // application from hanging.
        //
        if (didSend == FALSE) {
            WsbAffirmHr(pRecallPriv->GetDriversRecallId(&aTmp.msg.pRep.filterId));
            aTmp.inout.command = RP_RECALL_COMPLETE;
            aTmp.inout.status = STATUS_FILE_IS_OFFLINE;
            aTmp.msg.rRep.actionFlags = 0;

            DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &aTmp, sizeof(RP_MSG),
                    &aTmp, sizeof(RP_MSG), &ioSize, NULL);
            //
            // Remove it from our collection
            //

            EnterCriticalSection(&m_recallLock);
            hr = m_pRecalls->RemoveAndRelease(pRecallPriv);
            LeaveCriticalSection(&m_recallLock);
        }
    

    );

    return(hr);
}


HRESULT
CFsaFilter::SetAdminExemption(
    IN BOOL isExempt
    )

/*++

Implements:

  IFsaFilter::SetAdminExemption().

--*/
{
    HRESULT         hr = S_OK;

    m_exemptAdmin = isExempt;   // TRUE == Admin is exempt from runaway recall check.

    m_isDirty = TRUE;

    return(hr);
}
    

    

HRESULT
CFsaFilter::SetIdentifier(
    IN GUID id
    )

/*++

Implements:

  IFsaFilterPriv::SetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    m_id = id;

    m_isDirty = TRUE;

    return(hr);
}
    

HRESULT
CFsaFilter::SetIsEnabled(
    IN BOOL isEnabled
    )

/*++

Implements:

  IFsaFilter::SetIsEnabled().

--*/
{
    m_isEnabled = isEnabled;

    return(S_OK);
}


HRESULT
CFsaFilter::SetMaxRecallBuffers(
    IN ULONG maxBuffers
    )

/*++

Implements:

  IFsaFilter::SetMaxRecallBuffers().

--*/
{
    m_maxRecallBuffers = maxBuffers;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CFsaFilter::SetMaxRecalls(
    IN ULONG maxRecalls
    )

/*++

Implements:

  IFsaFilter::SetMaxRecalls().

--*/
{
    m_maxRecalls = maxRecalls;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CFsaFilter::SetMinRecallInterval(
    IN ULONG minInterval
    )

/*++

Implements:

  IFsaFilter::SetMinRecallInterval().

--*/
{
    m_minRecallInterval = minInterval;
    m_isDirty = TRUE;

    return(S_OK);
}

HRESULT
CFsaFilter::StopIoctlThread(
    void
    )

/*++

Implements:


 IFsaFilterPriv::StopIoctlThread()

     This stops the IOCTL thread and cancels outstanding IO to the 
     kernel mode File System Filter.

--*/

{
    HRESULT         hr = S_OK;
    RP_MSG          tmp;
    DWORD           outSize;

    WsbTraceIn(OLESTR("CFsaFilter::StopIoctlThread"), OLESTR(""));

    try {

        //
        // Signal the event to indicate to PipeThread that we are terminating
        // It is important to do this first before setting the state to IDLE,
        // to avoid deadlocks/race conditions 
        //
        WsbAffirmStatus(SetEvent(m_terminateEvent));
        //
        // Set the filter state to idle
        //
        EnterCriticalSection(&m_stateLock);
        m_state = HSM_JOB_STATE_IDLE;

        //
        // Cancel the IOCTLS in the kernel filter.
        //
        tmp.inout.command = RP_CANCEL_ALL_DEVICEIO;
        BOOL bTmpStatus = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL);

        LeaveCriticalSection(&m_stateLock);
        WsbAffirmStatus(bTmpStatus);

        //
        // Cancel any pending recalls
        //
        tmp.inout.command = RP_CANCEL_ALL_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL));
    

        //
        // Now tell the filter we are going away and it should fail all recall activity .
        //
    
        tmp.inout.command = RP_SUSPEND_NEW_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::StopIoctlThread"), OLESTR("Hr = %ls"), WsbHrAsString(hr));

    return(0);
}




DWORD FsaIoctlThread(
    void* pVoid
    )

/*++


--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CFsaFilter*) pVoid)->IoctlThread();
    CoUninitialize();
    return(hr);
}



DWORD FsaPipeThread(
    void* pVoid
    )

/*++


--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CFsaFilter*) pVoid)->PipeThread();
    CoUninitialize();
    return(hr);
}



HRESULT
CFsaFilter::Start(
    void
    )

/*++

Implements:

  IFsaFilter::Start().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;
	DWORD					tid;

    WsbTraceIn(OLESTR("CFsaFilter::Start"), OLESTR(""));
    
    try {
        //
        // Create the event that is used to signal termination
        //
        WsbAffirmHandle((m_terminateEvent = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL)));

        WsbAffirm((HSM_JOB_STATE_IDLE == m_state) || (HSM_JOB_STATE_CANCELLED == m_state), E_UNEXPECTED);
         
        oldState = m_state;
        m_state = HSM_JOB_STATE_STARTING;

        try {

            // TBD - Do whatever it takes to start.
            // 
            // This consists of starting a thread that will issue the IOCTL
            // requests to the kernel mode filter.  These IOCTL requests 
            // will complete when the kernel mode filter detects that a 
            // recall is needed.
            //

            WsbAffirm((m_pipeThread = CreateThread(0, 0, FsaPipeThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));
 
            if (m_pipeThread == NULL) {           
                m_state = oldState;
                WsbAssertHr(E_FAIL);  // TBD What error to return here??
            }

            WsbAffirm((m_ioctlThread = CreateThread(0, 0, FsaIoctlThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));
 
            if (m_ioctlThread == NULL) {           
                m_state = oldState;
                WsbAssertHr(E_FAIL);  // TBD What error to return here??
            }


        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Start"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilter::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


NTSTATUS
CFsaFilter::TranslateHresultToNtStatus(
    HRESULT hr
    )

/*++

Implements:

  CFsaFilter::TranslateHresultToNtStatus().

--*/
{
    NTSTATUS        ntStatus = 0;
    DWORD           w32Error;
    
    switch (hr) {
        case RMS_E_CARTRIDGE_BUSY:
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        case RMS_E_DRIVE_BUSY:
        case RMS_E_TIMEOUT:
        case RMS_E_CARTRIDGE_UNAVAILABLE:
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        case RMS_E_LIBRARY_UNAVAILABLE:
        case RMS_E_NTMS_NOT_CONNECTED:
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        case ERROR_IO_DEVICE:
            ntStatus = STATUS_REMOTE_STORAGE_MEDIA_ERROR;
            break;

        case STATUS_END_OF_FILE:
            ntStatus = hr;
            break;

        case E_FAIL:    
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        default:
            if (hr & FACILITY_NT_BIT) {
                //
                // NT status code - return it unchanged (except for removing the facility bit)
                //
                ntStatus = hr & ~(FACILITY_NT_BIT);
            } else if (hr & FACILITY_WIN32) {
                w32Error = hr & 0x0000ffff;
                //
                // Now convert the win32 error to a NT status code.
                //
                // Since there does not seem to be any easy macro to do this we convert the most common ones
                // and punt on the rest.
                //
                switch (w32Error) {
                    case ERROR_NOT_ENOUGH_MEMORY:
                    case ERROR_OUTOFMEMORY:
                        ntStatus = STATUS_NO_MEMORY;
                        break;

                    case ERROR_HANDLE_DISK_FULL:
                    case ERROR_DISK_FULL:
                        ntStatus = STATUS_DISK_FULL;
                        break;

                    default:
                        ntStatus = STATUS_FILE_IS_OFFLINE;
                        break;
                }
            } else {
                ntStatus = STATUS_FILE_IS_OFFLINE;
            }
            break;
    }

    return(ntStatus);
}



HRESULT
CFsaFilter::DoRecallAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoRecallAction()
    
    Find the already created recall object and start the data transfer.

--*/


{
CComPtr<IFsaFilterRecall>       pRecall;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaResource>           pRecallResource;
HRESULT                         hr = S_OK;
RP_MSG                          tmp;
DWORD                           outSize;
BOOL                            gotToInit = FALSE;

    //
    //
    try {
        //
        // Get the Filter ID and find the recall object.
        //
        pRecall = NULL;
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
            NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
            (void**) &pRecallPriv));

        WsbAffirmHr(pRecallPriv->SetDriversRecallId(pIoCmd->out.msg.rReq.filterId));
        WsbAffirmHr(pRecallPriv->SetThreadId(pIoCmd->out.msg.rReq.threadId));
        WsbAffirmHr(pRecallPriv->CompareBy(FSA_RECALL_COMPARE_ID));

        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) &pRecall);
        LeaveCriticalSection(&m_recallLock);

        WsbAffirmHr(hr);

        WsbAffirmHr(pRecall->CheckRecallLimit(m_minRecallInterval, m_maxRecalls, (BOOLEAN)( m_exemptAdmin ? TRUE : FALSE ) ) );
       
        pRecallPriv = 0;

        WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        
        WsbTrace(OLESTR("CFsaFilter::DoRecallAction: Recall object Found - Calling StartRecall.\n"));
    
        // Set marker for event logging.  If we have failed before this point
        // we want to issue an event.  Init logs it's own events
        //
        gotToInit = TRUE;
        WsbAffirmHr(pRecallPriv->StartRecall(pIoCmd->out.msg.rReq.offset, 
                    pIoCmd->out.msg.rReq.length));
    
        WsbTrace(OLESTR("CFsaFilter::DoRecallAction: Recall Started.\n"));
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        tmp.inout.status = TranslateHresultToNtStatus(hr);
        tmp.inout.command = RP_RECALL_COMPLETE;
        tmp.msg.rRep.actionFlags = 0;
        tmp.msg.rRep.filterId = pIoCmd->out.msg.rReq.filterId;
        DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL);

        WsbTrace(OLESTR("CFsaFilter::DoRecallAction: Exception during recall processing.\n"));
    
        if (FALSE == gotToInit)  {
            CWsbStringPtr   pName; 
            HRESULT hrPath = S_FALSE;
            //
            //  If we didn't complete init and the error was not due to the runaway recall limit, then we need to log an event here.
            //  Otherwise, an event is already sent.
            //
            //  Get path of file failing recall.
            if (pRecall != 0) {
                hrPath = pRecall->GetPath((OLECHAR**) &pName, 0);
            }

            if (SUCCEEDED(hrPath) && ((WCHAR *)pName != NULL)) {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(hr), NULL);
            } else {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, OLESTR("Path is NULL"), WsbHrAsString(hr), NULL);
            }

            //
            //  We also have to free the recall object
            //
            if (pRecall != NULL) {
                EnterCriticalSection(&m_recallLock);
                m_pRecalls->RemoveAndRelease(pRecall);
                LeaveCriticalSection(&m_recallLock);
            } 
        }

        );
    //
    // Cleanup any old client structures
    // TBD This should be async and not in the recall path
    //
    CleanupClients();

    return(hr);
}




HRESULT
CFsaFilter::DoOpenAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoOpenAction()
    
    Create an entry for the user opening the file and start the reall notification identification process.

--*/


{
CComPtr<IFsaFilterClient>       pClient, pFoundClient;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaResource>           pRecallResource;
CComPtr<IFsaScanItem>           pScanItem;
HRESULT                         hr = S_OK;
PRP_MSG                         aTmp = NULL;
RP_MSG                          tmp;
DWORD                           ioLen, outSize;
FSA_PLACEHOLDER                 placeHolder;
OLECHAR                         *pPath = NULL;
DWORD                           nameLen;
DWORD                           dNameLen;
CWsbStringPtr                   uName;
CWsbStringPtr                   dName;
CWsbStringPtr                   idPath;
WCHAR                           userName[USER_NAME_LEN];
WCHAR                           domainName[USER_NAME_LEN];
SID_NAME_USE                    nUse;
BOOL                            gotToInit = FALSE;
LONGLONG                        fileId;    
BOOL                            status;
DWORD                           lErr;

    //
    // Got a recall request from the filter.  Create the
    // necessary objects.  The recall is not actually started until the first read or write.
    //
    //  See if a client object already exists for the
    //  authentication ID given by the filter driver.
    //  If it was found then check the runaway recall limit
    //  and fail the recall if the limit has been reached.
    //  If the client object does not exist then create it
    //  and start the identification process (this is done by 
    //  the client object).
    //  Get the resource interface for the volume the file is on.
    //  Create the recall object and initialize it.
    //
    try {
        ULONG numEnt;
    
        //
        // Get the file path from the filter.
        // We get it in a separate call because the path and 
        // security information could be very large.
        // Allocate the amount of space we will need and make the 
        // IOCTL call to get it.
        //
        ioLen = sizeof(RP_MSG) + pIoCmd->out.msg.oReq.userInfoLen +
                pIoCmd->out.msg.oReq.nameLen;
    
        WsbAffirmPointer((aTmp = (RP_MSG *) malloc(ioLen)));
    
        aTmp->inout.command = RP_GET_RECALL_INFO;
        aTmp->msg.riReq.filterId = pIoCmd->out.msg.oReq.filterId;
        status = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, aTmp,
                    ioLen,
                    aTmp, ioLen, &outSize, NULL);

        if (!status) {
            lErr = GetLastError();
            if (lErr == ERROR_FILE_NOT_FOUND) {
                //
                // This is OK - the file must have been closed
                // We can just bail out.
                WsbThrow(S_OK);
            } else {
                //
                // Anything else must be an error
                //
                WsbThrow(HRESULT_FROM_WIN32(lErr));
            }
        }
                
    
        //
        // The path is UNICODE and in the format of
        // \path\file.ext.
        // or if open by ID the the ID is in the message
        //
        fileId = aTmp->msg.riReq.fileId;
        
        pPath = (OLECHAR *) ((CHAR *) &aTmp->msg.riReq.userToken +
                            pIoCmd->out.msg.oReq.userInfoLen);
    
        //
        // Get the resource interface via the serial number
        //

        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pRecallResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Found the resource.\n"));

        //if (pIoCmd->out.msg.oReq.options & FILE_OPEN_BY_FILE_ID) {
        //    if ((pIoCmd->out.msg.oReq.objIdHi != 0) || (pIoCmd->out.msg.oReq.objIdLo != 0)) {
        //        WsbAffirmHr(pRecallResource->FindObjectId(pIoCmd->out.msg.oReq.objIdHi, pIoCmd->out.msg.oReq.objIdLo, NULL, &pScanItem));
        //    } else {
        //        WsbAffirmHr(pRecallResource->FindFileId(pIoCmd->out.msg.oReq.fileId, NULL, &pScanItem));
        //    }
        //    WsbAffirmHr(pScanItem->GetPathAndName(NULL, &idPath, 0));
        //    pPath = idPath;
        //}
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Recall request for <%ls>\n"),
                WsbAbbreviatePath(pPath, 120));

        pFoundClient = NULL;
        //
        // Recall notification is not done for no-recall operations - skip the client stuf
        //
        if (!(pIoCmd->out.msg.oReq.options & FILE_OPEN_NO_RECALL)) {
           //
           // Set up the client interface.
           // If one has not been created for this authentication ID then
           // create one now.
           // 
       
           WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Client ID is %x:%x.\n"),
                   pIoCmd->out.msg.oReq.userAuthentication.HighPart, 
                   pIoCmd->out.msg.oReq.userAuthentication.LowPart);
       
           WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
           WsbAffirmHr(pClient->SetAuthenticationId(pIoCmd->out.msg.oReq.userAuthentication.HighPart, pIoCmd->out.msg.oReq.userAuthentication.LowPart));
           WsbAffirmHr(pClient->SetTokenSource(pIoCmd->out.msg.oReq.tokenSource));
           WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
       
           EnterCriticalSection(&m_clientLock);
           hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
           LeaveCriticalSection(&m_clientLock);
       
           if (hr == WSB_E_NOTFOUND) {
               //
               // Did not find an existing client structure - 
               // use the one we created for the find to initialize a new
               // one.  Add it to the collection in the filter object. 
               //
               WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Create new client object.\n"));
       
               EnterCriticalSection(&m_clientLock);
               hr = m_pClients->Add(pClient);
               LeaveCriticalSection(&m_clientLock);
               WsbAffirmHr(hr);
               pFoundClient = pClient;
       
               //
               // Get the username from the SID passed from the 
               // kernel mode filter.
               //
               try {
                   nameLen = USER_NAME_LEN;
                   dNameLen = USER_NAME_LEN;
                   WsbAffirmStatus((LookupAccountSidW(NULL, 
                           (PSID) &aTmp->msg.riReq.userToken,
                           userName, &nameLen, 
                           domainName, &dNameLen, &nUse)));
       
                   WsbTrace(OLESTR("CFsaFilter::DoOpenAction: User = %ls/%ls.\n"),
                           domainName, userName);
       
               } WsbCatchAndDo(hr,
                   //
                   // We do not consider it a fatal error if we cannot
                   // get the user name and domain.
                   //
                   WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Failed to get the user name - %x.\n"),
                           GetLastError());
                   wcscpy(userName, L"");
                   wcscpy(domainName, L"");
               );
       
               WsbAffirmHr(pFoundClient->SetUserName(userName));
               WsbAffirmHr(pFoundClient->SetDomainName(domainName));
           } else {
               //
               // The find did not return WSB_E_NOTFOUND.  Make sure it was not
               // some other error.
               //
               WsbAffirmHr(hr);
               WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Found the client object.\n"));
               WsbAffirmHr(pFoundClient->GetUserName((OLECHAR **) &uName, 0));
               WsbAffirmHr(pFoundClient->GetDomainName((OLECHAR **) &dName, 0));
               wcsncpy(userName, (WCHAR *) uName, USER_NAME_LEN);
               wcsncpy(domainName, (WCHAR *) dName, USER_NAME_LEN);
           }
       
           WsbTrace(OLESTR("CFsaFilter::DoOpenAction: User = %ls/%ls.\n"),
                   domainName, userName);
   
           //
           // Start the identification process if needed
           //
           // TBD This might be better done in an async fashion.
           //
           WsbAffirmHr(pFoundClient->StartIdentify());
           WsbAffirmHr(pFoundClient->SetIsAdmin((BOOLEAN) pIoCmd->out.msg.oReq.isAdmin));
        }
        
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Building recall request.\n"));
        //
        // Fill in the placeholder data the filter object will need
        //
        WsbAffirmHr(CopyRPDataToPlaceholder(&(pIoCmd->out.msg.oReq.eaData), &placeHolder));
        
        //
        // Now start the recall
        // 
        //
        // Create the recall interface and initialize it.
        // 
    
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
            NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
            (void**) &pRecallPriv));
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Recall object created.\n"));
    
        //
        //  Add it to the collection 
        //
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Add(pRecallPriv);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);
    
        hr = m_pRecalls->GetEntries(&numEnt);
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Recall queue has %u entries. Calling Init.\n"),
                numEnt);

        //
        // Set marker for event logging.  If we have failed before this point
        // we want to issue an event.  Init logs it's own events
        //
        gotToInit = TRUE;
        WsbAffirmHr(pRecallPriv->Init(pFoundClient, 
                    pIoCmd->out.msg.oReq.filterId, 
                    pRecallResource, pPath, fileId,
                    pIoCmd->out.msg.oReq.offset.QuadPart,
                    pIoCmd->out.msg.oReq.size.QuadPart,
                    pIoCmd->out.msg.oReq.options,
                    &placeHolder, 
                    (IFsaFilterPriv*) this));
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Init complete.\n"));
    
        free(aTmp);
        aTmp = NULL;
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        if (hr != S_OK) {
           tmp.inout.status = TranslateHresultToNtStatus(hr);
           tmp.inout.command = RP_RECALL_COMPLETE;
           tmp.msg.rRep.actionFlags = 0;
           tmp.msg.rRep.filterId = pIoCmd->out.msg.oReq.filterId;
           DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
                           &tmp, sizeof(RP_MSG), &outSize, NULL);
   
           WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Exception during recall processing.\n"));
        }

        //  NOTE:  IF RUNAWAY RECALL BEHAVIOR CHANGES TO TRUNCATE ON CLOSE, CHANGE
        //  FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED TO FSA_MESSAGE_HIT_RECALL_LIMIT_TRUNCATEONCLOSE.
    
        if ((hr != S_OK) && (FALSE == gotToInit))  {
            //  If we didn't complete init, then we need to log an event here.
            //  Otherwise, an event is already sent.
            if (hr == FSA_E_HIT_RECALL_LIMIT) {
                WsbLogEvent(FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED, 0, NULL, userName, NULL);
            } else {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pPath, 120), WsbHrAsString(hr), NULL);
            }
        }

        if (NULL != aTmp)
            free(aTmp);
        aTmp = NULL;
        );
    //
    // Cleanup any old client structures
    // TBD This should be async and not in the recall path
    //
    CleanupClients();

    return(hr);
}


HRESULT
CFsaFilter::DoRecallWaitingAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoRecallWaitingAction()
    
   Start the reall notification identification process: this is just another client
   waiting on an already issued recall

--*/


{
CComPtr<IFsaFilterClient>       pClient, pFoundClient;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaFilterRecall>       pRecall;
CComPtr<IFsaResource>           pRecallResource;
CComPtr<IFsaScanItem>           pScanItem;
HRESULT                         hr = S_OK;
PRP_MSG                         aTmp = NULL;
DWORD                           ioLen, outSize;
OLECHAR                         *pPath = NULL;
DWORD                           nameLen;
DWORD                           dNameLen;
CWsbStringPtr                   uName;
CWsbStringPtr                   dName;
CWsbStringPtr                   idPath;
WCHAR                           userName[USER_NAME_LEN];
WCHAR                           domainName[USER_NAME_LEN];
SID_NAME_USE                    nUse;
LONGLONG                        fileId;    
BOOL                            status;
DWORD                           lErr;

    //
    // Got a recall request from the filter.  Create the
    // necessary objects.  The recall is not actually started until the first read or write.
    //
    //  See if a client object already exists for the
    //  authentication ID given by the filter driver.
    //  If it was found then check the runaway recall limit
    //  and fail the recall if the limit has been reached.
    //  If the client object does not exist then create it
    //  and start the identification process (this is done by 
    //  the client object).
    //  Get the resource interface for the volume the file is on.
    //  Create the recall object and initialize it.
    //
    try {
    
        //
        // Get the file path from the filter.
        // We get it in a separate call because the path and 
        // security information could be very large.
        // Allocate the amount of space we will need and make the 
        // IOCTL call to get it.
        //
        ioLen = sizeof(RP_MSG) + pIoCmd->out.msg.oReq.userInfoLen +
                pIoCmd->out.msg.oReq.nameLen;
    
        WsbAffirmPointer((aTmp = (RP_MSG *) malloc(ioLen)));
    
        aTmp->inout.command = RP_GET_RECALL_INFO;
        aTmp->msg.riReq.filterId = pIoCmd->out.msg.oReq.filterId;
        status = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, aTmp,
                    ioLen,
                    aTmp, ioLen, &outSize, NULL);

        if (!status) {
            lErr = GetLastError();
            if (lErr == ERROR_FILE_NOT_FOUND) {
                //
                // This is OK - the file must have been closed
                // We can just bail out.
                WsbThrow(S_OK);
            } else {
                //
                // Anything else must be an error
                //
                WsbThrow(HRESULT_FROM_WIN32(lErr));
            }
        }
                
    
        //
        // The path is UNICODE and in the format of
        // \path\file.ext.
        // or if open by ID the the ID is in the message
        //
        fileId = aTmp->msg.riReq.fileId;
        
        pPath = (OLECHAR *) ((CHAR *) &aTmp->msg.riReq.userToken +
                            pIoCmd->out.msg.oReq.userInfoLen);
    
        //
        // Get the resource interface via the serial number
        //

        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pRecallResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Found the resource.\n"));

        WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Recall request for <%ls>\n"),
                WsbAbbreviatePath(pPath, 120));

        pFoundClient = NULL;
        //
        // Recall notification is not done for no-recall operations - skip the client stuf
        //
        if (!(pIoCmd->out.msg.oReq.options & FILE_OPEN_NO_RECALL)) {
           //
           // Set up the client interface.
           // If one has not been created for this authentication ID then
           // create one now.
           // 
       
           WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Client ID is %x:%x.\n"),
                   pIoCmd->out.msg.oReq.userAuthentication.HighPart, 
                   pIoCmd->out.msg.oReq.userAuthentication.LowPart);
       
           WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
           WsbAffirmHr(pClient->SetAuthenticationId(pIoCmd->out.msg.oReq.userAuthentication.HighPart, pIoCmd->out.msg.oReq.userAuthentication.LowPart));
           WsbAffirmHr(pClient->SetTokenSource(pIoCmd->out.msg.oReq.tokenSource));
           WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
           EnterCriticalSection(&m_clientLock);
           hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
           LeaveCriticalSection(&m_clientLock);
           if (hr == WSB_E_NOTFOUND) {
               //
               // Did not find an existing client structure - 
               // use the one we created for the find to initialize a new
               // one.  Add it to the collection in the filter object. 
               //
               WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Create new client object.\n"));
       
               EnterCriticalSection(&m_clientLock);
               hr = m_pClients->Add(pClient);
               LeaveCriticalSection(&m_clientLock);
               WsbAffirmHr(hr);
               pFoundClient = pClient;
       
               //
               // Get the username from the SID passed from the 
               // kernel mode filter.
               //
               try {
                   nameLen = USER_NAME_LEN;
                   dNameLen = USER_NAME_LEN;
                   WsbAffirmStatus((LookupAccountSidW(NULL, 
                           (PSID) &aTmp->msg.riReq.userToken,
                           userName, &nameLen, 
                           domainName, &dNameLen, &nUse)));
       
                   WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: User = %ls/%ls.\n"),
                           domainName, userName);
       
               } WsbCatchAndDo(hr,
                   //
                   // We do not consider it a fatal error if we cannot
                   // get the user name and domain.
                   //
                   WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Failed to get the user name - %x.\n"),
                           GetLastError());
                   wcscpy(userName, L"");
                   wcscpy(domainName, L"");
               );
       
               WsbAffirmHr(pFoundClient->SetUserName(userName));
               WsbAffirmHr(pFoundClient->SetDomainName(domainName));
           } else {
               //
               // The find did not return WSB_E_NOTFOUND.  Make sure it was not
               // some other error.
               //
               WsbAffirmHr(hr);
               WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Found the client object.\n"));
               WsbAffirmHr(pFoundClient->GetUserName((OLECHAR **) &uName, 0));
               WsbAffirmHr(pFoundClient->GetDomainName((OLECHAR **) &dName, 0));
               wcsncpy(userName, (WCHAR *) uName, USER_NAME_LEN);
               wcsncpy(domainName, (WCHAR *) dName, USER_NAME_LEN);
           }
           WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: User = %ls/%ls.\n"),
                   domainName, userName);
   
           WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
                         NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
                        (void**) &pRecallPriv));
           WsbAffirmHr(pRecallPriv->SetDriversRecallId((pIoCmd->out.msg.oReq.filterId & 0xFFFFFFFF)));
           WsbAffirmHr(pRecallPriv->CompareBy(FSA_RECALL_COMPARE_CONTEXT_ID));
           EnterCriticalSection(&m_recallLock);
           hr = m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) &pRecall);
           LeaveCriticalSection(&m_recallLock);
        
           WsbAffirmHr(hr);

           //
           // Start the identification process if needed
           //
           // TBD This might be better done in an async fashion.
           //
           WsbAffirmHr(pFoundClient->StartIdentify());
           WsbAffirmHr(pFoundClient->SetIsAdmin((BOOLEAN) pIoCmd->out.msg.oReq.isAdmin));

           // Note: code for the notify itself is moved to AddClient method
           hr = pRecall->AddClient(pFoundClient); 
           if (hr != S_OK) {
               WsbTrace(OLESTR("CFsaFilterRecall::DoRecallWaitingAction: AddClient returned %ls.\n"),
                    WsbHrAsString(hr));

           }
           hr = S_OK;
        }
        free(aTmp);
        aTmp = NULL;
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        if (NULL != aTmp)
            free(aTmp);
        aTmp = NULL;
        );
    //
    // Cleanup any old client structures
    // TBD This should be async and not in the recall path
    //
    CleanupClients();

    return(hr);
}




HRESULT
CFsaFilter::DoNoRecallAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoNoRecallAction()
    
    This is used for read without recall - the data is copied to memory and not
    written to the file.


--*/


{
CComPtr<IFsaFilterClient>       pClient, pFoundClient;
//CComPtr<IFsaFilterRecallPriv>   pRecall;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaResource>           pRecallResource;
CComPtr<IFsaScanItem>           pScanItem;
HRESULT                         hr = S_OK;
PRP_MSG                         aTmp = NULL;
RP_MSG                          tmp;
DWORD                           ioLen, outSize;
FSA_PLACEHOLDER                 placeHolder;
OLECHAR                         *pPath;
CWsbStringPtr                   idPath;
CWsbStringPtr                   uName;
CWsbStringPtr                   dName;
WCHAR                           userName[USER_NAME_LEN];
WCHAR                           domainName[USER_NAME_LEN];


    try {   
    
        //
        // Get the file path from the filter.
        // We get it in a separate call because the path and 
        // security information could be very large.
        // Allocate the amount of space we will need and make the 
        // IOCTL call to get it.
        //
        ioLen = sizeof(RP_MSG) + pIoCmd->out.msg.oReq.userInfoLen +
                pIoCmd->out.msg.oReq.nameLen;
    
        WsbAffirmPointer((aTmp = (RP_MSG *) malloc(ioLen)));
    
        aTmp->inout.command = RP_GET_RECALL_INFO;
        aTmp->msg.riReq.filterId = pIoCmd->out.msg.oReq.filterId;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, aTmp,
                    ioLen,
                    aTmp, ioLen, &outSize, NULL));
    
    
        //
        // The path is UNICODE and in the format of
        // \path\file.ext.
        //
        //
        pPath = (OLECHAR *) ((CHAR *) &aTmp->msg.riReq.userToken +
                            pIoCmd->out.msg.oReq.userInfoLen);
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Recall (on read) request for %.80ls.\n"),
                pPath);
    
        //
        // Get the resource interface via the serial number
        //

        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pRecallResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Found the resource.\n"));
    
        if (pIoCmd->out.msg.oReq.options & FILE_OPEN_BY_FILE_ID) {
            if ((pIoCmd->out.msg.oReq.objIdHi != 0) || (pIoCmd->out.msg.oReq.objIdLo != 0)) {
                WsbAffirmHr(pRecallResource->FindObjectId(pIoCmd->out.msg.oReq.objIdHi, pIoCmd->out.msg.oReq.objIdLo, NULL, &pScanItem));
            } else {
                WsbAffirmHr(pRecallResource->FindFileId(pIoCmd->out.msg.oReq.fileId, NULL, &pScanItem));
            }
            WsbAffirmHr(pScanItem->GetPathAndName(NULL, &idPath, 0));
            pPath = idPath;
        }

        //
        // Set up the client interface.
        // If one has not been created for this authentication ID then
        // they are out of luck
        // 
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Client ID is %x:%x.\n"),
                pIoCmd->out.msg.oReq.userAuthentication.HighPart, 
                pIoCmd->out.msg.oReq.userAuthentication.LowPart);
    
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
        WsbAffirmHr(pClient->SetAuthenticationId(pIoCmd->out.msg.oReq.userAuthentication.HighPart, pIoCmd->out.msg.oReq.userAuthentication.LowPart));
        WsbAffirmHr(pClient->SetTokenSource(pIoCmd->out.msg.oReq.tokenSource));
        WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
    
        EnterCriticalSection(&m_clientLock);
        hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
        LeaveCriticalSection(&m_clientLock);
    
        if (hr != WSB_E_NOTFOUND) {
            //
            // The find did not return WSB_E_NOTFOUND.  Make sure it was not
            // some other error.
            //
            WsbAffirmHr(hr);
            WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Found the client object.\n"));
            WsbAffirmHr(pFoundClient->GetUserName((OLECHAR **) &uName, 0));
            WsbAffirmHr(pFoundClient->GetDomainName((OLECHAR **) &dName, 0));
            wcsncpy(userName, (WCHAR *) uName, USER_NAME_LEN);
            wcsncpy(domainName, (WCHAR *) dName, USER_NAME_LEN);
            WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: User = %ls/%ls.\n"),
                    domainName, userName);
            //
            // Start the identification process if needed
            //
            // TBD This might be better done in an async fashion.
            //
            WsbAffirmHr(pFoundClient->StartIdentify());
        } else  {
            WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: User = UNKNOWN.\n"));
            pFoundClient = 0;
        }

    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Building recall request.\n"));
        //
        // Fill in the placeholder data the filter object will need
        //
        if (RP_FILE_IS_TRUNCATED(pIoCmd->out.msg.oReq.eaData.data.bitFlags))
            placeHolder.isTruncated = TRUE;
        else
            placeHolder.isTruncated = FALSE;
    
    
        placeHolder.migrationTime.dwLowDateTime = pIoCmd->out.msg.oReq.eaData.data.migrationTime.LowPart;
        placeHolder.migrationTime.dwHighDateTime = pIoCmd->out.msg.oReq.eaData.data.migrationTime.HighPart;
        placeHolder.hsmId = pIoCmd->out.msg.oReq.eaData.data.hsmId;
        placeHolder.bagId = pIoCmd->out.msg.oReq.eaData.data.bagId;
        placeHolder.fileStart = pIoCmd->out.msg.oReq.eaData.data.fileStart.QuadPart;
        placeHolder.fileSize = pIoCmd->out.msg.oReq.eaData.data.fileSize.QuadPart;
        placeHolder.dataStart = pIoCmd->out.msg.oReq.eaData.data.dataStart.QuadPart;
        placeHolder.dataSize = pIoCmd->out.msg.oReq.eaData.data.dataSize.QuadPart;
        placeHolder.fileVersionId = pIoCmd->out.msg.oReq.eaData.data.fileVersionId.QuadPart;
        placeHolder.verificationData = pIoCmd->out.msg.oReq.eaData.data.verificationData.QuadPart;
        placeHolder.verificationType = pIoCmd->out.msg.oReq.eaData.data.verificationType;
        placeHolder.recallCount = pIoCmd->out.msg.oReq.eaData.data.recallCount;
        placeHolder.recallTime.dwLowDateTime = pIoCmd->out.msg.oReq.eaData.data.recallTime.LowPart;
        placeHolder.recallTime.dwHighDateTime = pIoCmd->out.msg.oReq.eaData.data.recallTime.HighPart;
        placeHolder.dataStreamStart = pIoCmd->out.msg.oReq.eaData.data.dataStreamStart.QuadPart;
        placeHolder.dataStreamSize = pIoCmd->out.msg.oReq.eaData.data.dataStreamSize.QuadPart;
        placeHolder.dataStream = pIoCmd->out.msg.oReq.eaData.data.dataStream;
    
        //
        // Now start the recall
        // 
        //
        // Create the recall interface and initialize it.
        // 
    
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
            NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
            (void**) &pRecallPriv));
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Recall object created.\n"));
    
        //
        //  Add it to the collection 
        //
    
        // 
        // Just  add & init
        //
        
        //WsbAffirmHr(pRecallPriv->QueryInterface(IID_IFsaFilterRecall, (void **)&pRecall));
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Add(pRecallPriv);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Calling Init.\n"));
    
        WsbAffirmHr(pRecallPriv->Init(pFoundClient, 
                    pIoCmd->out.msg.oReq.filterId, 
                    pRecallResource, pPath,
                    pIoCmd->out.msg.oReq.fileId,
                    pIoCmd->out.msg.oReq.offset.QuadPart,
                    pIoCmd->out.msg.oReq.size.QuadPart,
                    pIoCmd->out.msg.oReq.options,
                    &placeHolder, 
                    (IFsaFilterPriv*) this));
    
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Init complete.\n"));
    
        free(aTmp);
        aTmp = NULL;
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        tmp.inout.status = TranslateHresultToNtStatus(hr);
        tmp.inout.command = RP_RECALL_COMPLETE;
        tmp.msg.rRep.actionFlags = 0;
        tmp.msg.rRep.filterId = pIoCmd->out.msg.oReq.filterId;
        DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL);

        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Exception during recall processing.\n"));
    
        if (NULL != aTmp)
            free(aTmp);
        aTmp = NULL;
        );

    
    return(hr);
}




HRESULT
CFsaFilter::DoCloseAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoCloseAction()
    
    Handles any action that must be done to log the fact that a premigrated files data
    has changed.

--*/


{
HRESULT                 hr = S_OK;
OLECHAR                 *pPath;
CComPtr<IFsaScanItem>   pScanItem;
CComPtr<IFsaResource>   pResource;
CWsbStringPtr           idPath;

    
    try {
        //
        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoCloseAction: Found the resource.\n"));
    
        //
        // The path we give to the recall object does not include the
        // device name.
        //
        WsbAffirmHr(pResource->FindFileId(pIoCmd->out.msg.oReq.fileId, NULL, &pScanItem));
        WsbAffirmHr(pScanItem->GetPathAndName(NULL, &idPath, 0));
        //
        // We are done with this scan item
        //
        pScanItem = 0;
        pPath = idPath;

        WsbTrace(OLESTR("CFsaFilter::DoCloseAction: Close action logging for %.80ls.\n"),
                pPath);


    } WsbCatchAndDo(hr,
        //
        // Something failed while logging the close information.
        // Free any resources required and
        // tell the kernel mode filter that the close logging failed.
        //
    
        WsbTrace(OLESTR("CFsaFilter::DoCloseAction: Exception during close processing.\n"));
        );

    return(hr);

}


HRESULT
CFsaFilter::DoPreDeleteAction(
    PFSA_IOCTL_CONTROL /*pIoCmd*/
    )

/*++

Implements:


 CFsaFilter::DoPreDeleteAction()
    
    Log the possible delete.  Note that the file id is passed and not the name.

--*/
{
HRESULT     hr = S_OK;


    WsbTrace(OLESTR("CFsaFilter::DoPreDeleteAction: Pre-Delete action.\n"));

    return(hr);

}

HRESULT
CFsaFilter::DoPostDeleteAction(
    PFSA_IOCTL_CONTROL /*pIoCmd*/
    )

/*++

Implements:


 CFsaFilter::DoPostDeleteAction()
    
    Log the completed delete.

--*/
{
HRESULT     hr = S_OK;


    WsbTrace(OLESTR("CFsaFilter::DoPostDeleteAction: Post-Delete action.\n"));


    return(hr);

}


HRESULT
CFsaFilter::DoCancelRecall(
    ULONGLONG filterId
    )

/*++

Implements:


 CFsaFilter::DoCancelRecall
    
    Cancel the specified recall request.

--*/
{
HRESULT                         hr = S_OK;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaFilterRecall>       pRecall;


    WsbTraceIn(OLESTR("CFsaFilter::DoCancelRecall"), OLESTR(""));

    try {
        ULONG numEnt;


        if (S_OK == m_pRecalls->GetEntries(&numEnt)) {
            WsbTrace(OLESTR("CFsaFilter::DoCancelRecall: Recall queue has %u entries before cancel\n"),
                numEnt);
        }
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->SetDriversRecallId(filterId));
        WsbAffirmHr(pRecallPriv->CompareBy(FSA_RECALL_COMPARE_ID));


        // >>> ENTER CRITICAL SECTION
        EnterCriticalSection(&m_recallLock);
        try {
            //
            // Find the recall, and cancel.
            //
            WsbAffirmHr(m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) &pRecall));
            pRecallPriv = NULL;
            WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
            WsbAffirmHr(pRecallPriv->CancelByDriver());
            //
            // Now remove the recall from our collection
            //
            WsbAffirmHr(m_pRecalls->RemoveAndRelease(pRecallPriv));

            WsbAffirmHr(m_pRecalls->GetEntries(&numEnt));
            WsbTrace(OLESTR("CFsaFilter::DoCancelRecall: Recall queue has %u entries after cancel\n"), numEnt);

        } WsbCatch(hr);
        LeaveCriticalSection(&m_recallLock);
        WsbThrow(hr);
        // <<< LEAVE CRITICAL SECTION


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::DoCancelRecall"), OLESTR("Hr = %ls"), WsbHrAsString(hr));
    return(hr);

}




HRESULT
CFsaFilter::IoctlThread(
    void
    )

/*++

Implements:


 IFsaFilterPriv::IoctlThread()

     This is started as a thread and issues IOCTL requests to the 
     kernel mode File System Filter and waits for recall requests.

--*/

{
HRESULT         hr = S_OK;
HANDLE          port = NULL;
ULONG           index;
RP_MSG          tmp;
DWORD           outSize;
OVERLAPPED      *ovlp;
DWORD_PTR       key;
DWORD           lastError;
//PSID            psidAdministrators;
ULONG           numIoPending = 0;
OLECHAR         ioctlDrive[128];
CWsbStringPtr   pDrv;
BOOL            code;
PFSA_IOCTL_CONTROL              pIoCmd, pIo;
PFSA_IOCTL_CONTROL              pIoList = NULL;
SID_IDENTIFIER_AUTHORITY        siaNtAuthority = SECURITY_NT_AUTHORITY;
CComPtr<IFsaResource>           pResource;
BOOL                            ioctlCancelled = FALSE;

    WsbTraceIn(OLESTR("CFsaFilter::IoctlThread"), OLESTR(""));

    try {
        
        //
        // Set the ioctlDrive for the filter.
        // The ioctlDrive needs to be any NTFS drive letter.  By opening
        // any NTFS drive we can issue IOCTL requests that the kernel mode filter
        // will see.  It does not matter if the drive chosen is managed or not.
        // We just get the first resource interface in the list and get its drive 
        // letter to build the string.
        //
        swprintf(ioctlDrive, L"%s", RS_FILTER_SYM_LINK);                 
        WsbTrace(OLESTR("CFsaFilter::IoctlThread: Drive = %ls\n"), ioctlDrive);
        //
        // Now issue several IOCTL requests to the filter driver to get 
        // recall requests.  We must always keep at least one pending
        // so the filter driver has somewhere to go when a migrated file is 
        // opened.  We will issue the configured amount (m_maxRecallBuffers)
        // and wait for completion of any of them via a completion port.
        //
        for (index = 0; index < m_maxRecallBuffers; index++) {
            WCHAR       nameString[MAX_PATH];
            
            WsbAffirmPointer((pIoCmd = new FSA_IOCTL_CONTROL));
            pIoCmd->next = pIoList;
            pIoList = pIoCmd;
            pIoCmd->overlap.hEvent = NULL;
            pIoCmd->dHand = NULL;
            
            //
            // Create an event, a handle, and put it in the completion port.
            //
            swprintf(nameString, OLESTR("Ioctl Completion Port Event %d"), index); 
            WsbAffirmHandle(pIoCmd->overlap.hEvent = CreateEvent(NULL, TRUE, FALSE, nameString));
            WsbAffirmHandle(pIoCmd->dHand = CreateFile(ioctlDrive, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL));
    
            WsbAffirmHandle(port = CreateIoCompletionPort(pIoCmd->dHand, port, (DWORD_PTR) pIoCmd, 1));
    
            pIoCmd->in.inout.command = RP_GET_REQUEST;
            pIoCmd->outSize = sizeof(RP_MSG);
            //
            // DeviceIoctlControl should always return ERROR_IO_PENDING
            //
            code = DeviceIoControl(pIoCmd->dHand, FSCTL_HSM_MSG, &pIoCmd->in,
                        sizeof(RP_MSG),
                        &pIoCmd->out, pIoCmd->outSize, &pIoCmd->outSize,
                        &pIoCmd->overlap);

            lastError = GetLastError();
            if ( (code == 0) && (lastError == ERROR_IO_PENDING)) {
                // Life is good
                numIoPending++;
            } else {
                WsbTrace(OLESTR("CFsaFilter::IoctlThread: DeviceIoControl returned %ls/%ls\n"), 
                        WsbBoolAsString(code), WsbLongAsString(lastError));
            }       
        }
    
        WsbTrace(OLESTR("CFsaFilter::IoctlThread: %ls ioctls issued successfully.\n"), WsbLongAsString(numIoPending));
    
        //
        // Open the handle we will use for commands to the kernel filter
        //
        WsbAffirmHandle(m_ioctlHandle = CreateFile(ioctlDrive, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL));

        //
        // Just in case we left the filter with outstanding recalls from a previous
        // debug session or crash we tell it to cancel everything now.
        //
    
        tmp.inout.command = RP_CANCEL_ALL_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL))
    

        //
        // Now that we are ready to get recall requests we can tell the 
        // driver to start checking for recall activity.
        //
    
        tmp.inout.command = RP_ALLOW_NEW_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL))
    
        WsbTrace(OLESTR("CFsaFilter::IoctlThread: Kernel level filter recalls enabled.\n"));

        //
        // We are now ready to rock and roll
        //
        m_state = HSM_JOB_STATE_ACTIVE;
    
        //
        // Now just sit around and wait for the IO requests to complete.  When  
        // they do we are either quitting or a recall request was detected.
        //
        while (TRUE) {
            //
            // Wait for an IO request to complete.
            //
            if (! GetQueuedCompletionStatus(port, &outSize, &key, &ovlp, INFINITE)) {
                DWORD dwErr = GetLastError();               
                if (ERROR_OPERATION_ABORTED == dwErr) {
                    numIoPending--;
                    ioctlCancelled = TRUE;          
                }
                WsbAffirmHr(HRESULT_FROM_WIN32(dwErr));
            } else {
                numIoPending--;
            }
            
			pIoCmd = (FSA_IOCTL_CONTROL *) key;
			WsbAffirm(NULL != pIoCmd, E_FAIL);

			WsbTrace(OLESTR("CFsaFilter::IoctlThread: Filter event detected (%x:%x), Id = %I64x.\n"), 
				pIoCmd->out.inout.command,
				pIoCmd->out.msg.oReq.action,
				pIoCmd->out.msg.oReq.filterId);
			switch (pIoCmd->out.inout.command) {
				case RP_OPEN_FILE:
					hr = DoOpenAction(pIoCmd);
					break;

				case RP_RECALL_WAITING:
					hr = DoRecallWaitingAction(pIoCmd);
					break;

				//
				// Must be a cancelled recall
				//
				case RP_CANCEL_RECALL:
					DoCancelRecall(pIoCmd->out.msg.cReq.filterId);
					break;
				case RP_RUN_VALIDATE:
					//
					// A validate job is needed on a given volume (serial number is passed)
					// No completion message is expected by the filter for this action.
					//
					WsbTrace(OLESTR("CFsaFilter::Ioctlthread - Validate job for %x is needed\n"),
							pIoCmd->out.msg.oReq.serial);
					try {
						SYSTEMTIME      sysTime;
						FILETIME        curTime;
						LARGE_INTEGER   ctime;
        
						GetLocalTime(&sysTime);
						WsbAffirmStatus(SystemTimeToFileTime(&sysTime, &curTime));
						ctime.LowPart = curTime.dwLowDateTime;
						ctime.HighPart = curTime.dwHighDateTime;
						ctime.QuadPart += WSB_FT_TICKS_PER_HOUR * 2;
						curTime.dwLowDateTime = ctime.LowPart;
						curTime.dwHighDateTime = ctime.HighPart;
						WsbAffirmStatus(FileTimeToSystemTime(&curTime, &sysTime));
						WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pResource));
						WsbAffirmHr(pResource->SetupValidateJob(sysTime));
					} WsbCatchAndDo(hr,
						//
						// Log an event indicating that the validate job should be run manually
						//
						CWsbStringPtr   tmpStr;

						if (pResource != 0) {
							hr = pResource->GetLogicalName(&tmpStr, 0);
							if (hr != S_OK) {
								tmpStr = L"<Unknown Volume>";
							}
						} else {
							tmpStr = L"<Unknown Volume>";
						}
						WsbLogEvent(FSA_MESSAGE_AUTOVALIDATE_SCHEDULE_FAILED, 0, NULL, (OLECHAR *) tmpStr, NULL);
					);
					break;
				case RP_RECALL_FILE:
					hr = DoRecallAction(pIoCmd);
					break;
                    
				case RP_START_NOTIFY:
            
					break;
				case RP_END_NOTIFY:

					break;
				case RP_CLOSE_FILE:
            
					break;
				default:
					WsbTrace(OLESTR("CFsaFilter::IoctlThread: Unknown filter request - %u.\n"), 
						pIoCmd->out.inout.command);
					break;
			}

			WsbTrace(OLESTR("CFsaFilter::IoctlThread: Issue new Ioctl.\n"));
			//
			// If object is still active, reset the event and issue another IOCTL
			//
            EnterCriticalSection(&m_stateLock);
            if (m_state == HSM_JOB_STATE_ACTIVE) {
    			ResetEvent(pIoCmd->overlap.hEvent);
	    		pIoCmd->in.inout.command = RP_GET_REQUEST;
		    	pIoCmd->outSize = sizeof(RP_MSG);
			    code = DeviceIoControl(pIoCmd->dHand, FSCTL_HSM_MSG,
				    	&pIoCmd->in,
					    sizeof(RP_MSG),
					    &pIoCmd->out, pIoCmd->outSize,
					    &pIoCmd->outSize, &pIoCmd->overlap);
                lastError = GetLastError();
                if ( (code == 0) && (lastError == ERROR_IO_PENDING)) {
                    // Life is good
                    numIoPending++;
                } else {
                    WsbTrace(OLESTR("CFsaFilter::IoctlThread: DeviceIoControl returned %ls/%ls\n"), 
                            WsbBoolAsString(code), WsbLongAsString(lastError));
                }       
            } else {
                //
                // Get out of the while loop
                //
                hr = S_OK;
                LeaveCriticalSection(&m_stateLock);
                break;
            }
            LeaveCriticalSection(&m_stateLock);

        } // End while active
    
        //
        // Now tell the filter we are going away and it should fail all recall activity .
        //
        tmp.inout.command = RP_SUSPEND_NEW_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL))

    } WsbCatch(hr);

    //
    // We need to wait for rest of Ioctls to be cancelled if we got out of the loop
    // either because the object is not active or the first Ioctl was cancelled
    // We cannot free Ioctl related data safely until all of them are done
    //
    if ((S_OK == hr) || ioctlCancelled) {
        //
        // Try to wait for the rest of the Ioctls to be cancelled 
        //
        HRESULT freeHr;

        hr = S_OK;

        try {
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: Waiting for %lu more Ioctls to complete before freeing their resources\n"), numIoPending);
            for (index = 0; index < numIoPending; index++) {
                if (! GetQueuedCompletionStatus(port, &outSize, &key, &ovlp, 2000)) {
                    DWORD dwErr = GetLastError();               
                    if (ERROR_OPERATION_ABORTED != dwErr) {
                        WsbAffirmHr(HRESULT_FROM_WIN32(dwErr));
                    }
                 }
            }

            //
            // If we got here, all the Ioctls were cancelled or completed as expected.
            // It is safe to free their related resources
            //
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: All of %lu Ioctls completed - free resources\n"), m_maxRecallBuffers);
      		pIoCmd = pIoList;
	        while (pIoCmd != NULL) {
                if (pIoCmd->overlap.hEvent != NULL) {
    		        CloseHandle(pIoCmd->overlap.hEvent);
                }
                if (pIoCmd->dHand != NULL) {
    		        CloseHandle(pIoCmd->dHand);
                }
    	        pIo = pIoCmd;
		        pIoCmd = pIoCmd->next;
		        delete pIo;
	        }
            pIoList = NULL;
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: Freed Ioctls resources successfully\n"));

        } WsbCatchAndDo(freeHr,
            WsbTraceAlways(L"CFsaResource::IoctlThread - Failed to free Ioctls, freeHr = %ls\n", 
                WsbHrAsString(freeHr));
        );

    }

    //
    // Free rest of allocated resources
    // Note that if we couldn't wait for all the Ioctls to complete (or cancel)
    //  we better exit without freeing the Ioctl list
    //
    if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_ioctlHandle);
        m_ioctlHandle = INVALID_HANDLE_VALUE;
    }
    if (port != NULL) {
        CloseHandle(port);
    }

    if (m_state == HSM_JOB_STATE_ACTIVE) {
        //
        // There must have been an error of some kind 
        //
        WsbLogEvent(FSA_MESSAGE_IOCTLTHREADFAILED, 0, NULL, WsbHrAsString(hr), NULL);
    }

    //
    // Set the filter state to idle
    //
    m_state = HSM_JOB_STATE_IDLE;
		
    WsbTraceOut(OLESTR("CFsaFilter::IoctlThread"), OLESTR("Hr = %ls"), WsbHrAsString(hr));

    return(0);
}
		




HRESULT
CFsaFilter::PipeThread(
    void
    )

/*++

Implements:


 IFsaFilterPriv::PipeThread()

     This is started as a thread and creates the named pipe used by recall notification
     clients to identify themselves.  When an identification response is received we
     impersonate the client, get the authentication token and find the client instance that
     matches the token.  If we find the client object we wet the machine name.

--*/

{
HRESULT                 hr = S_OK;
BOOL                    exitLoop, code, connected;
DWORD                   lastError, bytesRead, retCode;
WCHAR                   pName[100];
WSB_PIPE_MSG            msg; 
CComPtr<IFsaFilterClient>       pClient;
HANDLE                  tHandle = INVALID_HANDLE_VALUE;
HANDLE                  handleArray[2];
DWORD                   retLen;
TOKEN_STATISTICS        tStats;
SHORT                   result;
OVERLAPPED              pOverlap;
WCHAR                   machineName[MAX_COMPUTERNAME_LENGTH + 1];

    memset (&pOverlap, 0, sizeof(OVERLAPPED));
    pOverlap.hEvent = INVALID_HANDLE_VALUE;

    try {

        WsbTraceIn(OLESTR("CFsaFilter::PipeThread"), OLESTR(""));
    
        //
        // Create a client instance to use for finding the client of interest.
        //
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
    
        //
        //   Create a security scheme that allows anyone to write to the pipe on the client side,
        //   but preserves create-access (therefore creating-server-side privilege) to local system and admins.
        //
        PSID pAdminSID = NULL;
        PSID pSystemSID = NULL;
        PSID pWorldSID = NULL;
        PSID pGuestSID = NULL;
        PSID pAnonymousSID = NULL;
        PACL pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
#define     FSA_PIPE_NUM_ACE      5
        EXPLICIT_ACCESS ea[FSA_PIPE_NUM_ACE];
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        SECURITY_ATTRIBUTES sa;

        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * FSA_PIPE_NUM_ACE);

        try {
            // Create a SID for World
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthWorld, 1,
                                 SECURITY_WORLD_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pWorldSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the World limited access to the pipe
            ea[0].grfAccessPermissions = (FILE_ALL_ACCESS & ~(FILE_CREATE_PIPE_INSTANCE | WRITE_OWNER | WRITE_DAC));
            ea[0].grfAccessMode = SET_ACCESS;
            ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[0].Trustee.pMultipleTrustee = NULL;
            ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea[0].Trustee.ptstrName  = (LPTSTR) pWorldSID;

            // Create a SID for Guest
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_GUESTS,
                                 0, 0, 0, 0, 0, 0,
                                 &pGuestSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the Guests limited access to the pipe
            ea[1].grfAccessPermissions = (FILE_ALL_ACCESS & ~(FILE_CREATE_PIPE_INSTANCE | WRITE_OWNER | WRITE_DAC));
            ea[1].grfAccessMode = SET_ACCESS;
            ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[1].Trustee.pMultipleTrustee = NULL;
            ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea[1].Trustee.ptstrName  = (LPTSTR) pGuestSID;

            // Create a SID for Anonymous
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                                 SECURITY_ANONYMOUS_LOGON_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pAnonymousSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the Anonymous limited access to the pipe
            ea[2].grfAccessPermissions = (FILE_ALL_ACCESS & ~(FILE_CREATE_PIPE_INSTANCE | WRITE_OWNER | WRITE_DAC));
            ea[2].grfAccessMode = SET_ACCESS;
            ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[2].Trustee.pMultipleTrustee = NULL;
            ea[2].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[2].Trustee.TrusteeType = TRUSTEE_IS_USER;
            ea[2].Trustee.ptstrName  = (LPTSTR) pAnonymousSID;

            // Create a SID for the Administrators group.
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &pAdminSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the Administrators group full access to the pipe
            ea[3].grfAccessPermissions = FILE_ALL_ACCESS;
            ea[3].grfAccessMode = SET_ACCESS;
            ea[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[3].Trustee.pMultipleTrustee = NULL;
            ea[3].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[3].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea[3].Trustee.ptstrName  = (LPTSTR) pAdminSID;

            // Create a SID for the local system account
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSystemSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the local system full access to the pipe
            ea[4].grfAccessPermissions = FILE_ALL_ACCESS;
            ea[4].grfAccessMode = SET_ACCESS;
            ea[4].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[4].Trustee.pMultipleTrustee = NULL;
            ea[4].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[4].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[4].Trustee.TrusteeType = TRUSTEE_IS_USER;
            ea[4].Trustee.ptstrName  = (LPTSTR) pSystemSID;

            // Create a new ACL that contains the new ACEs.
            WsbAffirmNoError( SetEntriesInAcl(FSA_PIPE_NUM_ACE, ea, NULL, &pACL));

            // Initialize a security descriptor.  
            pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
            WsbAffirmPointer(pSD);
            WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
            // Add the ACL to the security descriptor. 
            WsbAffirmStatus(SetSecurityDescriptorDacl(
                                pSD, 
                                TRUE,     // fDaclPresent flag   
                                pACL, 
                                FALSE));   // not a default DACL 

            // Initialize a security attributes structure.
            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
    
            //
            // Create a local named pipe with
            // the hsm pipe name
            // '.' signifies local pipe.
    
            swprintf(pName, L"\\\\.\\PIPE\\%s",  WSB_PIPE_NAME);
    
            WsbAffirmHandle((m_pipeHandle = CreateNamedPipeW(pName,
                        PIPE_ACCESS_DUPLEX                // Duplex - NT5 for some reason needs this vs inbound only
                        | FILE_FLAG_OVERLAPPED            // Use overlapped structure.
                        | FILE_FLAG_FIRST_PIPE_INSTANCE,  // Make sure we are the creator of the pipe
                        PIPE_WAIT |                       // Wait on messages.
                        PIPE_TYPE_BYTE,
                        WSB_MAX_PIPES,
                        WSB_PIPE_BUFF_SIZE,
                        WSB_PIPE_BUFF_SIZE,
                        WSB_PIPE_TIME_OUT,                // Specify time out.
                        &sa)));                           // Security attributes.

        } WsbCatch(hr);

        //
        // Free security objects and verify hr of pipe creation
        //
        if (pAdminSID) {
            FreeSid(pAdminSID);
        }
        if (pSystemSID) {
            FreeSid(pSystemSID);
        }
        if (pWorldSID) {
            FreeSid(pWorldSID);
        }
        if (pGuestSID) {
            FreeSid(pGuestSID);
        }
        if (pAnonymousSID) {
            FreeSid(pAnonymousSID);
        }
        if (pACL) {
            LocalFree(pACL);
        }
        if (pSD) {
            WsbFree(pSD);
        }

        WsbAffirmHr(hr);


        //
        // Create an event for overlapped i/o
        //
        WsbAffirmHandle((pOverlap.hEvent = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE, 
                                                       NULL)));
             
        //
        // Initialize the handle array. The first element sbould be the terminate event,
        // because we need to know if it signalled and always break out of the loop
        // regardless of whether the overlapped i/o is done or not
        // 
        handleArray[0] = m_terminateEvent;
        handleArray[1] = pOverlap.hEvent;

        exitLoop = FALSE;
        while ((!exitLoop) && ((m_state == HSM_JOB_STATE_ACTIVE) || (m_state == HSM_JOB_STATE_STARTING)))  {
            connected = FALSE;
            //
            // Block until a client connects.
            //
            code = ConnectNamedPipe(m_pipeHandle, &pOverlap);
            if (!code) {
                lastError = GetLastError();
        
                switch (lastError) {
                    // IO_PENDING, wait on the event 
                    case ERROR_IO_PENDING:  {
                         
                        retCode = WaitForMultipleObjects(2,
                                                         handleArray, 
                                                         FALSE,
                                                         INFINITE);
                        if (retCode == WAIT_OBJECT_0) {
                           //
                           // The termination event got signalled
                           //
                           exitLoop = TRUE;
                           continue;
                        } else if (retCode == (WAIT_OBJECT_0+1)) {
                           //
                           // A client connected
                           //
                           connected = TRUE;
                        }
                        break;
                    }

                    case ERROR_BROKEN_PIPE: {
                        //
                        // Pipe is broken, reconnect
                        //
                        break;
                    }

                    default: {
                        //
                        // Something else is wrong, just reconnect
                        //
                        break;
                    }
                }
            } else {
                connected = TRUE;
            }
        
        
            if (connected) {
                //
                // A client connected - get the identify message, identify them and continue waiting for 
                // pipe conections.
                //
                WsbTrace(OLESTR("CFsaFilter::PipeThread: Client has connected.\n"));
    
                pOverlap.Offset = 0;
                pOverlap.OffsetHigh = 0;
                code = ReadFile(m_pipeHandle, &msg, sizeof(WSB_PIPE_MSG), &bytesRead, &pOverlap);
                if (!code) {
                    lastError = GetLastError();
                }
                else {
                    lastError = ERROR_IO_PENDING;   // Read returned right away 
                }
            
                switch (lastError) {
                    // IO_PENDING, wait on the event or timeout in 4 seconds 
                    case ERROR_IO_PENDING:
                        if (!code)  {
                            retCode = WaitForMultipleObjects(2, 
                                                             handleArray,
                                                             FALSE,
                                                             (DWORD) 4000);
                        } else {
                            retCode = WAIT_OBJECT_0 + 1;    // Read returned right away
                        }
                        if (retCode == (WAIT_OBJECT_0+1)) {
                            //
                            // Read some data.  Do the identification
                            //
                            GetOverlappedResult(m_pipeHandle, &pOverlap, &bytesRead, FALSE);
                            if (bytesRead == sizeof(WSB_PIPE_MSG)) {
                                //
                                // Find the client instance that matches this user 
                                //
                                code = ImpersonateNamedPipeClient(m_pipeHandle);
                                if (code) {
                                    code = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY,
                                                TRUE, &tHandle);
                                }

                                if (code) {
                                    code = GetTokenInformation(tHandle, TokenStatistics, &tStats,
                                                sizeof(TOKEN_STATISTICS), &retLen);
                                    CloseHandle(tHandle);
                                    if (code) {
                                        //
                                        // Get the passed in machine name in a local buffer and null terminated
                                        //
                                        wcsncpy(machineName, msg.msg.idrp.clientName, MAX_COMPUTERNAME_LENGTH);
                                        machineName[MAX_COMPUTERNAME_LENGTH] = L'\0';

                                        //
                                        // First we need to clean up any old client objects that
                                        // have the same machine name.  It is assumed that there can
                                        // only be one client per machine and a duplicate means that 
                                        // they must have re-connected with a different authentication
                                        // token.
                                        //
                                        {
                                        CComPtr<IFsaFilterClient>       pFoundClient;
    
                                            WsbAffirmHr(pClient->SetMachineName(machineName));
                                            WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_MACHINE));
                                            EnterCriticalSection(&m_clientLock);
                                            hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
                                            LeaveCriticalSection(&m_clientLock);
                                            if (hr == S_OK) {
                                                //
                                                // Found one with the same machine name - make sure the token
                                                // does not match, just to be sure.
                                                //
                                                hr = pFoundClient->CompareToAuthenticationId(tStats.AuthenticationId.HighPart, 
                                                    tStats.AuthenticationId.LowPart, &result);
    
                                                if (hr != S_OK) {
                                                    //
                                                    // It did not match - remove and release this one from 
                                                    // the collection.
                                                    //
                                                    EnterCriticalSection(&m_clientLock);
                                                    hr = m_pClients->RemoveAndRelease(pFoundClient);
                                                    LeaveCriticalSection(&m_clientLock);
                                                }
                                            }   
                                        }   // Let pFoundClient go out of scope
    
    
                                        {
                                        CComPtr<IFsaFilterClient>       pFoundClient;
    
                                            //
                                            // Now set the machine name for this client if we can find
                                            // it by authentication id.
                                            //
                                            WsbAffirmHr(pClient->SetAuthenticationId(tStats.AuthenticationId.HighPart, 
                                                    tStats.AuthenticationId.LowPart));
                                            WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
                    
                                            WsbTrace(OLESTR("CFsaFilter::PipeThread: Finding client instance (%x:%x).\n"),
                                                    tStats.AuthenticationId.HighPart, 
                                                    tStats.AuthenticationId.LowPart);
                                    
                                            EnterCriticalSection(&m_clientLock);
                                            hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
                                            LeaveCriticalSection(&m_clientLock);
                                            if (hr == S_OK) {
                                                //
                                                // Got it - set the machine name
                                                //
                                                WsbTrace(OLESTR("CFsaFilter::PipeThread: Identify client as %ws.\n"),
                                                    machineName);
                                    
                                                pFoundClient->SetMachineName(machineName);
                                            } else {
                                                WsbTrace(OLESTR("CFsaFilter::PipeThread: Failed to find the client instance (%ls).\n"), 
                                                    WsbHrAsString(hr));
                                            }
                                        } // Let pFoundClient go out of scope
                                    } else {
                                        WsbTrace(OLESTR("CFsaFilter::PipeThread: GetTokenInformation returned %u.\n"),
                                            GetLastError());
                                    }
                                } else {
                                    WsbTrace(OLESTR("CFsaFilter::PipeThread: OpenThreadToken or ImpersonateNamedPipeClient returned %u.\n"),
                                        GetLastError());
                                }
                                RevertToSelf();
                                DisconnectNamedPipe(m_pipeHandle);
                            } else {
                                //
                                // Bad data was read - blow them off
                                //
                                WsbTrace(OLESTR("CFsaFilter::PipeThread: Bad message size (%u)\n"),
                                    bytesRead);
                                DisconnectNamedPipe(m_pipeHandle);
                            }
    
                        } else {
                            //
                            // Timeout or error - cancel the read and disconnect the client
                            //
                            DisconnectNamedPipe(m_pipeHandle);
                            if (retCode == WAIT_OBJECT_0) {
                                //
                                // Termination event was signalled
                                //
                                exitLoop = TRUE;
                                continue;
                            }
                        }
                        break;
                    case ERROR_BROKEN_PIPE: {
                        // Pipe is broken., 
                        DisconnectNamedPipe(m_pipeHandle);
                        break;
                    }

                    default: {
                        // Something else is wrong.
                        DisconnectNamedPipe(m_pipeHandle);
                        break;
                    }
                }
            }
        } // End while state 

    } WsbCatch(hr);

    if (m_pipeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_pipeHandle);
        m_pipeHandle = INVALID_HANDLE_VALUE;
    }

    if (pOverlap.hEvent != INVALID_HANDLE_VALUE) {
        CloseHandle(pOverlap.hEvent);
    }

    WsbTraceOut(OLESTR("CFsaFilter::PipeThread"), OLESTR("Hr = %ls"), WsbHrAsString(hr));

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsa.cpp ===
/*++

 

Module Name:

    fsa.cpp

Abstract:

    DLL main for Fsa

Author:

    Ran Kalach          [rankala]         28-July-1999

Revision History:

--*/

// fsa.cpp : Implementation of DLL Exports.

// Note: Currently, Fsa proxy/stub is compiled into a different DLL.
//      Below is relevant information if it is decided to merge the two DLLs.
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ...int.idl by adding the following 
//      files to the Outputs.
//          ...
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ...ps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"

#include "fsa.h"
#include "fsafltr.h"
#include "fsaftclt.h"
#include "fsaftrcl.h"
#include "fsaitem.h"
#include "fsaprem.h"
#include "fsaunmdb.h"
#include "fsarcvy.h"
#include "fsarsc.h"
#include "fsasrvr.h"
#include "fsatrunc.h"
#include "fsapost.h"
#include "task.h"

#include <stdio.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CFsaFilterClientNTFS, CFsaFilterClient)
    OBJECT_ENTRY(CLSID_CFsaFilterNTFS, CFsaFilter)
    OBJECT_ENTRY(CLSID_CFsaFilterRecallNTFS, CFsaFilterRecall)
    OBJECT_ENTRY(CLSID_CFsaPostIt, CFsaPostIt)
    OBJECT_ENTRY(CLSID_CFsaPremigratedDb, CFsaPremigratedDb)
    OBJECT_ENTRY(CLSID_CFsaPremigratedRec, CFsaPremigratedRec)
    OBJECT_ENTRY(CLSID_CFsaRecoveryRec, CFsaRecoveryRec)
    OBJECT_ENTRY(CLSID_CFsaResourceNTFS, CFsaResource)
    OBJECT_ENTRY(CLSID_CFsaScanItemNTFS, CFsaScanItem)
    OBJECT_ENTRY(CLSID_CFsaServerNTFS, CFsaServer)
    OBJECT_ENTRY(CLSID_CFsaTruncatorNTFS, CFsaTruncator)
    OBJECT_ENTRY(CLSID_CFsaUnmanageDb, CFsaUnmanageDb)
    OBJECT_ENTRY(CLSID_CFsaUnmanageRec, CFsaUnmanageRec)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
      hr = _Module.RegisterServer( FALSE );
      CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaftclt.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaftclt.cpp

Abstract:

    This class represents a user who the filter has detected accessing a file with placeholder information.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "stdafx.h"
extern "C" {
#include <ntseapi.h>
#include <wchar.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmshare.h>
#include <lmapibuf.h>
#include <lmerr.h>

// #define MAC_SUPPORT  // NOTE: You must define MAC_SUPPORT in fsafltr.cpp to enable all the code

#ifdef MAC_SUPPORT
#include <macfile.h>
#endif  
}


#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaftclt.h"

static USHORT iCountFtclt = 0;  // Count of existing objects

//
// We need to dynamically load the DLL for MAC support because it is not there if
// the MAC service is not installed.
//
#ifdef MAC_SUPPORT
HANDLE      FsaDllSfm = 0;
BOOL        FsaMacSupportInstalled = FALSE;

extern "C" {
DWORD   (*pAfpAdminConnect) (LPWSTR lpwsServerName, PAFP_SERVER_HANDLE phAfpServer);
VOID    (*pAfpAdminDisconnect) (AFP_SERVER_HANDLE hAfpServer);
VOID    (*pAfpAdminBufferFree) (PVOID pBuffer);
DWORD   (*pAfpAdminSessionEnum) (AFP_SERVER_HANDLE hAfpServer, LPBYTE *lpbBuffer,
            DWORD dwPrefMaxLen, LPDWORD lpdwEntriesRead, LPDWORD lpdwTotalEntries,
            LPDWORD lpdwResumeHandle);
}
#endif  

DWORD FsaIdentifyThread(void *pNotifyInterface);



DWORD FsaIdentifyThread(
    void* pVoid
    )

/*++
    Entry point of the thread that performs identify operation with remote clients.

--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CFsaFilterClient*) pVoid)->IdentifyThread();
    CoUninitialize();
    return(hr);
}



static
HRESULT
GetNotifyClientInterface(
    IN  OLECHAR * machineName,
    OUT IFsaRecallNotifyClient ** ppClient
    )
{
    HRESULT hr = S_OK;

    try {

        //
        // Make sure parameters OK and OUTs initially cleared
        //

        WsbAffirmPointer ( ppClient );
        *ppClient = 0;

        //
        // If connecting local, things work better to use NULL
        // for the computer name
        //

        if ( machineName ) {

            CWsbStringPtr localMachine;
            WsbAffirmHr( WsbGetComputerName( localMachine ) );

            if( _wcsicmp( localMachine, machineName ) == 0 ) {

                machineName = 0;

            }

        }

        //
        // Set server info
        //
        COSERVERINFO        csi;
        COAUTHINFO          cai;
        memset ( &csi, 0, sizeof ( csi ) );
        memset ( &cai, 0, sizeof ( cai ) );

        // Set machine name
        csi.pwszName  = machineName;

        // Create a proxy with security settings of no authentication (note that RsNotify is running with this security)
        cai.dwAuthnSvc = RPC_C_AUTHN_WINNT;
        cai.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;
        cai.pwszServerPrincName = NULL;
        cai.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
        cai.pAuthIdentityData = NULL;
        cai.dwCapabilities = EOAC_NONE;

        cai.dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;

        csi.pAuthInfo = &cai;

        //
        // We want IFsaRecallNotifyClient back
        //

        MULTI_QI            mqi;
        memset ( &mqi, 0, sizeof ( mqi ) );
        mqi.pIID = &IID_IFsaRecallNotifyClient;

        //
        // Make the connection...
        //

        WsbAffirmHr ( CoCreateInstanceEx ( 
            CLSID_CFsaRecallNotifyClient, 0, 
	        CLSCTX_NO_FAILURE_LOG | ( machineName ? CLSCTX_REMOTE_SERVER : CLSCTX_LOCAL_SERVER ), 
            &csi, 1, &mqi ) );
        WsbAffirmHr ( mqi.hr );

        //
        // We need to make sure we clean up correctly if any interface
        // post-processing fails, so assign over to a smart pointer for
        // the time being
        //

        CComPtr<IFsaRecallNotifyClient> pClientTemp = (IFsaRecallNotifyClient*)mqi.pItf;
        mqi.pItf->Release ( );

        //
        // Finally, we need to set the security on the procy to allow the
        // anonymous connection. Values should be the same as above (COAUTHINFO)
        // We need to make sure this is a remote machine first. Otherwise, we
        // get an error of E_INVALIDARG.
        //
        if( machineName ) {

            CComPtr<IClientSecurity> pSecurity;
            WsbAffirmHr( pClientTemp->QueryInterface( IID_IClientSecurity, (void**)&pSecurity ) );

            WsbAffirmHr( pSecurity->SetBlanket ( pClientTemp, RPC_C_AUTHN_NONE, RPC_C_AUTHZ_NONE, 0, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, 0, 0 ) );

        }

        //
        // Finally, assign over and AddRef the return.
        //

        *ppClient = pClientTemp;
        (*ppClient)->AddRef ( );

    } WsbCatch ( hr );

    return ( hr );
}



HRESULT
CFsaFilterClient::CheckRecallLimit(
    IN DWORD   minRecallInterval,
    IN DWORD   maxRecalls,
    IN BOOLEAN exemptAdmin
    )

/*++

Implements:

  IWsbCollectable::CheckRecallLimit().

--*/
{
    HRESULT                     hr = S_OK;
    FILETIME                    now, last;
    LARGE_INTEGER               tNow, tLast;
    ULONG                       rCount;


    WsbTraceIn(OLESTR("CFsaFilterClient::CheckRecallLimit"), OLESTR(""));
    
    try {
        //
        // Now check for runaway recall limits if the user is not
        // an administrator
        //
        
        if ((!m_isAdmin) || (!exemptAdmin)) {
            //
            // See if the time since the end of the last recall is 
            // less than m_minRecallInterval (in seconds) and if so, 
            // increment the count.
            // If not, then reset the count (if we were not 
            // already triggered).
            // If the count is equal to the max then set the trigger.
            //
            WsbTrace(OLESTR("CHsmFilter::IoctlThread: Not an administrator or admin is not exempt.\n"));
            GetSystemTimeAsFileTime(&now);
            tNow.LowPart = now.dwLowDateTime;
            tNow.HighPart = now.dwHighDateTime;
    
            GetLastRecallTime(&last);
    
            tLast.LowPart = last.dwLowDateTime;
            tLast.HighPart = last.dwHighDateTime;
            //
            //  Get the time (in 100 nano-second units)
            //  from the end of the last recall until now.
            //
            tNow.QuadPart -= tLast.QuadPart;
            //
            // Convert to seconds and check against the interval time
            //
            tNow.QuadPart /= (LONGLONG) 10000000;
            if (tNow.QuadPart < (LONGLONG) minRecallInterval) {
                //
                // This one counts - increment the count
                // and check for a trigger.
                //
                GetRecallCount(&rCount);
                rCount++;
                SetRecallCount(rCount);
    
                WsbTrace(OLESTR("CHsmFilterClient::CheckRecallLimit: Recall count bumped to %ls.\n"),
                        WsbLongAsString(rCount));
    
                if (rCount >= maxRecalls) {
                    // 
                    // Hit the runaway recall limit.  Set the 
                    // limit flag.
                    //
                    WsbTrace(OLESTR("CHsmFilter::IoctlThread: Hit the runaway recall limit!!!.\n"));
                    SetHitRecallLimit(TRUE);
                }
            } else {
                //
                // Reset the count if they are not already triggered.
                // If they are triggered then reset the trigger and
                // limit if it has been a respectable time.
                // TBD - What is a respectable time??
                //
                if (HitRecallLimit() != S_FALSE) {
                    if (tNow.QuadPart > (LONGLONG) minRecallInterval * 100) {
                        //
                        // A respectable time has passed - reset the trigger and count.
                        //
                        WsbTrace(OLESTR("CHsmFilterClient::CheckRecallLimit: Resetting recall limit trigger and count.\n"));
                        SetHitRecallLimit(FALSE);
                        SetRecallCount(0);
                        m_loggedLimitError = FALSE;
                    }
                } else {
                    //
                    // This one did not count and they were not already triggered.
                    // Reset the count to zero.
                    //
                    WsbTrace(OLESTR("CHsmFilterClient::CheckRecallLimit: Resetting recall count.\n"));
                    SetRecallCount(0);
                }
            }
            //
            // Fail if the limit is hit.
            //
            WsbAffirm(HitRecallLimit() == S_FALSE, FSA_E_HIT_RECALL_LIMIT);
        }

    } WsbCatch(hr);

    //  NOTE - IF RUNAWAY RECALL BEHAVIOR CHANGES TO TRUNCATE ON CLOSE, CHANGE
    //  FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED TO FSA_MESSAGE_HIT_RECALL_LIMIT_TRUNCATEONCLOSE.

    if ( (hr == FSA_E_HIT_RECALL_LIMIT) && (!m_loggedLimitError)) {
        WsbLogEvent(FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED, 0, NULL, (WCHAR *) m_userName, NULL);
        m_loggedLimitError = TRUE;
    }

    WsbTraceOut(OLESTR("CHsmFilterClient::CheckRecallLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::CompareBy(
    FSA_FILTERCLIENT_COMPARE by
    )

/*++

Implements:

  IFsaFilterClient::CompareBy().

--*/
{
    HRESULT                 hr = S_OK;

    m_compareBy = by;
    m_isDirty = TRUE;

    return(hr);
}


HRESULT
CFsaFilterClient::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaFilterClient>   pClient;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilterClient, (void**) &pClient));

        // Compare the rules.
        hr = CompareToIClient(pClient, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmFilterClient::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterClient::CompareToAuthenticationId(
    IN LONG luidHigh,
    IN ULONG luidLow,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterClient::CompareToAuthenticationId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareToAuthenticationId"), OLESTR(""));

    try {

        if (m_luidHigh > luidHigh) {
            aResult = 1;
        } else if (m_luidHigh < luidHigh) {
            aResult = -1;
        } else if (m_luidLow > luidLow) {
            aResult = 1;
        } else if (m_luidLow < luidLow) {
            aResult = -1;
        } else {
            aResult = 0;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::CompareToAuthenticationId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterClient::CompareToIClient(
    IN IFsaFilterClient* pClient,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterClient::CompareToIClient().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   name;
    LONG            luidHigh;
    ULONG           luidLow;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareToIClient"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pClient, E_POINTER);

        switch (m_compareBy) {
        case FSA_FILTERCLIENT_COMPARE_ID:
            WsbAffirmHr(pClient->GetAuthenticationId(&luidHigh, &luidLow));
            hr = CompareToAuthenticationId(luidHigh, luidLow, pResult);
            break;
        case FSA_FILTERCLIENT_COMPARE_MACHINE:
            WsbAffirmHr(pClient->GetMachineName(&name, 0));
            hr = CompareToMachineName(name, pResult);
            break;
        default:
            WsbAssert(FALSE, E_UNEXPECTED);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::CompareToIClient"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterClient::CompareToMachineName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterClient::CompareToMachineName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareToMachineName"), OLESTR(""));

    try {

        aResult = (SHORT)wcscmp(name, m_machineName); // TBD - Case sensitive or not?

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::CompareToMachineName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CFsaFilterClient::FinalConstruct"),OLESTR(""));
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        m_compareBy = FSA_FILTERCLIENT_COMPARE_ID;
        m_luidHigh = 0;
        m_luidLow = 0;
        m_hasRecallDisabled = FALSE;
        m_hitRecallLimit = FALSE;
        m_lastRecallTime.dwLowDateTime = 0; 
        m_lastRecallTime.dwHighDateTime = 0;    
        m_identified = FALSE;
        m_tokenSource = L"";
        m_msgCounter = 1;
        m_identifyThread = NULL;
        m_isAdmin = FALSE;
        m_loggedLimitError = FALSE;
    
    } WsbCatch(hr);

    iCountFtclt++;
    WsbTraceOut(OLESTR("CFsaFilterClient::FinalConstruct"),OLESTR("Count is <%d>"), iCountFtclt);

    return(hr);
}
void
CFsaFilterClient::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CFsaFilterClient::FinalRelease"),OLESTR(""));
   
    CWsbCollectable::FinalRelease();

    iCountFtclt--;
    WsbTraceOut(OLESTR("CFsaFilterClient::FinalRelease"),OLESTR("Count is <%d>"), iCountFtclt);
}


HRESULT
CFsaFilterClient::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaFilterClientNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaFilterClient::GetAuthenticationId(
    OUT LONG* pLuidHigh,
    OUT ULONG* pLuidLow
    )

/*++

Implements:

  IFsaFilterClient::GetAuthenticationId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pLuidHigh, E_POINTER);
        WsbAssert(0 != pLuidLow, E_POINTER);

        *pLuidHigh = m_luidHigh;
        *pLuidLow = m_luidLow;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetDomainName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterClient::GetDomainName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_domainName.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetIsAdmin(
    OUT BOOLEAN *pIsAdmin
    )

/*++

Implements:

  IPersist::GetIsAdmin().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::GetIsAdmin"), OLESTR(""));

    try {

        WsbAssert(0 != pIsAdmin, E_POINTER);
        *pIsAdmin = m_isAdmin;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::GetIsAdmin"), OLESTR("hr = <%ls>, isAdmin = <%u>"), WsbHrAsString(hr), *pIsAdmin);

    return(hr);
}


HRESULT
CFsaFilterClient::GetLastRecallTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaFilterClient::GetLastRecallTime().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER); 
        *pTime = m_lastRecallTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetMachineName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterClient::GetMachineName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_machineName.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetRecallCount(
    OUT ULONG* pCount
    )

/*++

Implements:

  IFsaFilterClient::GetRecallCount().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pCount, E_POINTER); 
        *pCount = m_recallCount;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetUserName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterClient::GetUserName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_userName.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaFilterClient::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = 0;

        // WE don't need to persist these.
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaFilterClient::HasRecallDisabled(
    void
    )

/*++

Implements:

  IFsaFilterClient::HasRecallDisabled().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::HasRecallDisabled"), OLESTR(""));
    
    if (!m_hasRecallDisabled) {
        hr = S_FALSE;
    }

    WsbTraceOut(OLESTR("CHsmFilterClient::HasRecallDisabled"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::HitRecallLimit(
    void
    )

/*++

Implements:

  IFsaFilterClient::HitRecallLimit().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::HitRecallLimit"), OLESTR(""));
    
    if (!m_hitRecallLimit) {
        hr = S_FALSE;
    }

    WsbTraceOut(OLESTR("CHsmFilterClient::HitRecallLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilterClient::IdentifyThread(
    void
    )

/*++

Implements:

  CFsaFilterClient::IdentifyThread().

--*/
{
#define WSB_BUFF_SIZE           1024

    HRESULT             hr = S_OK;
    BOOL                done, guestUser, noUser;
    DWORD               res, totalEnt, numEnt;
    UCHAR               *buff = NULL;
    NET_API_STATUS      status;
    SESSION_INFO_1      *sess;
    CWsbStringPtr       pipePath;
    ULONG               holdOff = 0;
#ifdef MAC_SUPPORT
    LPBYTE              macBuff = NULL;
    PAFP_SESSION_INFO   macInfo;
    AFP_SERVER_HANDLE   macHandle = 0;
    DWORD               macResume = 0;
    DWORD               macTotalEntries, macTotalRead;
    DWORD               result;
#endif


    WsbTraceIn(OLESTR("CFsaFilterClient::IdentifyThread"), OLESTR(""));

    try {
        WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread Flag: %x  Client ID: %x:%x Source: %ls\n"), 
            m_identified, m_luidHigh, m_luidLow, (WCHAR *) m_tokenSource);

        //
        // If already identified then we bail out here.
        //
        WsbAffirm(m_identified == FALSE, S_OK);

        
        done = FALSE;
        res = 0;
        
        noUser = FALSE;
        if (_wcsicmp(m_userName, L"GUEST") == 0) {
            /* It is the guest user - find all sessions and
                send to ones marked guest */
            guestUser = TRUE;
        } else {
            guestUser = FALSE;
            if (wcslen(m_userName) == 0) {
                noUser = TRUE;
            }
        }

        CComPtr<IFsaRecallNotifyClient> pRecallClient;

        WsbGetComputerName( pipePath );

        WsbAffirmHr(pipePath.Prepend("\\\\"));
        WsbAffirmHr(pipePath.Append("\\pipe\\"));
        WsbAffirmHr(pipePath.Append(WSB_PIPE_NAME));

        while ( done == FALSE ) {

            if ( (guestUser == FALSE) && (noUser == FALSE) ) {

                // If NetSessionEnum fails, try calling again for al